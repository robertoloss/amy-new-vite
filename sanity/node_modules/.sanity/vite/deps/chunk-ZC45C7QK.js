import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module2) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a5, b3) {
      if (a5 === b3)
        return true;
      if (a5 && b3 && typeof a5 == "object" && typeof b3 == "object") {
        if (a5.constructor !== b3.constructor)
          return false;
        var length2, i4, keys2;
        if (Array.isArray(a5)) {
          length2 = a5.length;
          if (length2 != b3.length)
            return false;
          for (i4 = length2; i4-- !== 0; )
            if (!equal(a5[i4], b3[i4]))
              return false;
          return true;
        }
        var it2;
        if (hasMap && a5 instanceof Map && b3 instanceof Map) {
          if (a5.size !== b3.size)
            return false;
          it2 = a5.entries();
          while (!(i4 = it2.next()).done)
            if (!b3.has(i4.value[0]))
              return false;
          it2 = a5.entries();
          while (!(i4 = it2.next()).done)
            if (!equal(i4.value[1], b3.get(i4.value[0])))
              return false;
          return true;
        }
        if (hasSet && a5 instanceof Set && b3 instanceof Set) {
          if (a5.size !== b3.size)
            return false;
          it2 = a5.entries();
          while (!(i4 = it2.next()).done)
            if (!b3.has(i4.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a5) && ArrayBuffer.isView(b3)) {
          length2 = a5.length;
          if (length2 != b3.length)
            return false;
          for (i4 = length2; i4-- !== 0; )
            if (a5[i4] !== b3[i4])
              return false;
          return true;
        }
        if (a5.constructor === RegExp)
          return a5.source === b3.source && a5.flags === b3.flags;
        if (a5.valueOf !== Object.prototype.valueOf && typeof a5.valueOf === "function" && typeof b3.valueOf === "function")
          return a5.valueOf() === b3.valueOf();
        if (a5.toString !== Object.prototype.toString && typeof a5.toString === "function" && typeof b3.toString === "function")
          return a5.toString() === b3.toString();
        keys2 = Object.keys(a5);
        length2 = keys2.length;
        if (length2 !== Object.keys(b3).length)
          return false;
        for (i4 = length2; i4-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys2[i4]))
            return false;
        if (hasElementType && a5 instanceof Element)
          return false;
        for (i4 = length2; i4-- !== 0; ) {
          if ((keys2[i4] === "_owner" || keys2[i4] === "__v" || keys2[i4] === "__o") && a5.$$typeof) {
            continue;
          }
          if (!equal(a5[keys2[i4]], b3[keys2[i4]]))
            return false;
        }
        return true;
      }
      return a5 !== a5 && b3 !== b3;
    }
    module2.exports = function isEqual2(a5, b3) {
      try {
        return equal(a5, b3);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module2) {
    function isObject4(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject4;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module2) {
    var root = require_root();
    var now2 = function() {
      return root.Date.now();
    };
    module2.exports = now2;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string4) {
      var index3 = string4.length;
      while (index3-- && reWhitespace.test(string4.charAt(index3))) {
      }
      return index3;
    }
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string4) {
      return string4 ? string4.slice(0, trimmedEndIndex(string4) + 1).replace(reTrimStart, "") : string4;
    }
    module2.exports = baseTrim;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var nativeObjectToString = objectProto2.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e5) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module2) {
    var objectProto2 = Object.prototype;
    var nativeObjectToString = objectProto2.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module2) {
    var baseTrim = require_baseTrim();
    var isObject4 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module2) {
    var isObject4 = require_isObject();
    var now2 = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce3(func2, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject4(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time3) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time3;
        result = func2.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time3) {
        lastInvokeTime = time3;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time3) : result;
      }
      function remainingWait(time3) {
        var timeSinceLastCall = time3 - lastCallTime, timeSinceLastInvoke = time3 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time3) {
        var timeSinceLastCall = time3 - lastCallTime, timeSinceLastInvoke = time3 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time3 = now2();
        if (shouldInvoke(time3)) {
          return trailingEdge(time3);
        }
        timerId = setTimeout(timerExpired, remainingWait(time3));
      }
      function trailingEdge(time3) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time3);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now2());
      }
      function debounced() {
        var time3 = now2(), isInvoking = shouldInvoke(time3);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time3;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module2.exports = debounce3;
  }
});

// node_modules/nano-pubsub/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  default: () => createPubSub
});
function createPubSub() {
  var subscribers = /* @__PURE__ */ Object.create(null);
  var nextId = 0;
  function subscribe(subscriber) {
    var id2 = nextId++;
    subscribers[id2] = subscriber;
    return function unsubscribe() {
      delete subscribers[id2];
    };
  }
  function publish2(event) {
    for (var id2 in subscribers) {
      subscribers[id2](event);
    }
  }
  return {
    publish: publish2,
    subscribe
  };
}
var init_esm = __esm({
  "node_modules/nano-pubsub/dist/esm/index.js"() {
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element4 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment5 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement4(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object2) {
          return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element4;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment5;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement4;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/tslib/tslib.es6.mjs
function __extends(d3, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
function __rest(s5, e5) {
  var t4 = {};
  for (var p2 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p2) && e5.indexOf(p2) < 0)
      t4[p2] = s5[p2];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p2 = Object.getOwnPropertySymbols(s5); i4 < p2.length; i4++) {
      if (e5.indexOf(p2[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p2[i4]))
        t4[p2[i4]] = s5[p2[i4]];
    }
  return t4;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t4[0] & 1)
      throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f3, y4, t4, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n4) {
    return function(v2) {
      return step([n4, v2]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
          return t4;
        if (y4 = 0, t4)
          op = [op[0] & 2, t4.value];
        switch (op[0]) {
          case 0:
          case 1:
            t4 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t4[1]) {
              _2.label = t4[1];
              t4 = op;
              break;
            }
            if (t4 && _2.label < t4[2]) {
              _2.label = t4[2];
              _2.ops.push(op);
              break;
            }
            if (t4[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e5) {
        op = [6, e5];
        y4 = 0;
      } finally {
        f3 = t4 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o4) {
  var s5 = typeof Symbol === "function" && Symbol.iterator, m4 = s5 && o4[s5], i4 = 0;
  if (m4)
    return m4.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o4, n4) {
  var m4 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m4)
    return o4;
  var i4 = m4.call(o4), r4, ar = [], e5;
  try {
    while ((n4 === void 0 || n4-- > 0) && !(r4 = i4.next()).done)
      ar.push(r4.value);
  } catch (error) {
    e5 = { error };
  } finally {
    try {
      if (r4 && !r4.done && (m4 = i4["return"]))
        m4.call(i4);
    } finally {
      if (e5)
        throw e5.error;
    }
  }
  return ar;
}
function __spreadArray(to2, from4, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l3 = from4.length, ar; i4 < l3; i4++) {
      if (ar || !(i4 in from4)) {
        if (!ar)
          ar = Array.prototype.slice.call(from4, 0, i4);
        ar[i4] = from4[i4];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from4));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i4, q3 = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n4) {
    if (g2[n4])
      i4[n4] = function(v2) {
        return new Promise(function(a5, b3) {
          q3.push([n4, v2, a5, b3]) > 1 || resume(n4, v2);
        });
      };
  }
  function resume(n4, v2) {
    try {
      step(g2[n4](v2));
    } catch (e5) {
      settle(q3[0][3], e5);
    }
  }
  function step(r4) {
    r4.value instanceof __await ? Promise.resolve(r4.value.v).then(fulfill, reject) : settle(q3[0][2], r4);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v2) {
    if (f3(v2), q3.shift(), q3.length)
      resume(q3[0][0], q3[0][1]);
  }
}
function __asyncValues(o4) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m4 = o4[Symbol.asyncIterator], i4;
  return m4 ? m4.call(o4) : (o4 = typeof __values === "function" ? __values(o4) : o4[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n4) {
    i4[n4] = o4[n4] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o4[n4](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d3, v2) {
    Promise.resolve(v2).then(function(v6) {
      resolve({ value: v6, done: d3 });
    }, reject);
  }
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d3, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
        d4.__proto__ = b4;
      } || function(d4, b4) {
        for (var p2 in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p2))
            d4[p2] = b4[p2];
      };
      return extendStatics(d3, b3);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t4) {
        for (var s5, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
          s5 = arguments[i4];
          for (var p2 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p2))
              t4[p2] = s5[p2];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/styled-components/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache3 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var init_emotion_memoize_esm = __esm({
  "node_modules/styled-components/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
  }
});

// node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex, isPropValid;
var init_emotion_is_prop_valid_esm = __esm({
  "node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js"() {
    init_emotion_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    isPropValid = memoize(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module2) {
    module2.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key2 = keysA[idx];
        if (!bHasOwnProperty(key2)) {
          return false;
        }
        var valueA = objA[key2];
        var valueB = objB[key2];
        ret = compare ? compare.call(compareContext, valueA, valueB, key2) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/stylis/src/Enum.js
var MS, MOZ, WEBKIT, COMMENT, RULESET, DECLARATION, IMPORT, KEYFRAMES, LAYER;
var init_Enum = __esm({
  "node_modules/stylis/src/Enum.js"() {
    MS = "-ms-";
    MOZ = "-moz-";
    WEBKIT = "-webkit-";
    COMMENT = "comm";
    RULESET = "rule";
    DECLARATION = "decl";
    IMPORT = "@import";
    KEYFRAMES = "@keyframes";
    LAYER = "@layer";
  }
});

// node_modules/stylis/src/Utility.js
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index3) {
  return value.charCodeAt(index3) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}
var abs, from, assign;
var init_Utility = __esm({
  "node_modules/stylis/src/Utility.js"() {
    abs = Math.abs;
    from = String.fromCharCode;
    assign = Object.assign;
  }
});

// node_modules/stylis/src/Tokenizer.js
function node(value, root, parent3, type, props, children, length2, siblings) {
  return { value, root, parent: parent3, type, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index3, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index3, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index3) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index3, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index3) {
  while (!token(peek()))
    next();
  return slice(index3, position);
}
var line, column, length, position, character, characters;
var init_Tokenizer = __esm({
  "node_modules/stylis/src/Tokenizer.js"() {
    init_Utility();
    line = 1;
    column = 1;
    length = 0;
    position = 0;
    character = 0;
    characters = "";
  }
});

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent3, rule, rules, rulesets, pseudo, points, declarations) {
  var index3 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous3 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous3 = character2, character2 = next()) {
      case 40:
        if (previous3 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous3);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent3, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index3++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent3, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent3, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent3, index3, offset3, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index3 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous3;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous3 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent3, index3, offset3, rules, points, type, props, children, length2, siblings) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size4 = sizeof(rule);
  for (var i4 = 0, j2 = 0, k3 = 0; i4 < index3; ++i4)
    for (var x3 = 0, y4 = substr(value, post + 1, post = abs(j2 = points[i4])), z3 = value; x3 < size4; ++x3)
      if (z3 = trim(j2 > 0 ? rule[x3] + " " + y4 : replace(y4, /&\f/g, rule[x3])))
        props[k3++] = z3;
  return node(value, root, parent3, offset3 === 0 ? RULESET : type, props, children, length2, siblings);
}
function comment(value, root, parent3, siblings) {
  return node(value, root, parent3, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent3, length2, siblings) {
  return node(value, root, parent3, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
var init_Parser = __esm({
  "node_modules/stylis/src/Parser.js"() {
    init_Enum();
    init_Utility();
    init_Tokenizer();
  }
});

// node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/))
        return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index3) {
        return length2 = index3, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span") ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span") ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a5, b3, c4, d3, e5, f3) {
        return MS + a5 + ":" + b3 + f3 + (c4 ? MS + a5 + "-span:" + (d3 ? e5 : +e5 - +b3) + f3 : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}
var init_Prefixer = __esm({
  "node_modules/stylis/src/Prefixer.js"() {
    init_Enum();
    init_Utility();
  }
});

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i4 = 0; i4 < children.length; i4++)
    output += callback(children[i4], i4, children, callback) || "";
  return output;
}
function stringify(element, index3, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(",")))
        return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
var init_Serializer = __esm({
  "node_modules/stylis/src/Serializer.js"() {
    init_Enum();
    init_Utility();
  }
});

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index3, children, callback) {
    var output = "";
    for (var i4 = 0; i4 < length2; i4++)
      output += collection[i4](element, index3, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index3, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}
var init_Middleware = __esm({
  "node_modules/stylis/src/Middleware.js"() {
    init_Enum();
    init_Utility();
    init_Tokenizer();
    init_Serializer();
    init_Prefixer();
  }
});

// node_modules/stylis/index.js
var init_stylis = __esm({
  "node_modules/stylis/index.js"() {
    init_Enum();
    init_Utility();
    init_Parser();
    init_Prefixer();
    init_Tokenizer();
    init_Serializer();
    init_Middleware();
  }
});

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys;
var init_emotion_unitless_esm = __esm({
  "node_modules/@emotion/unitless/dist/emotion-unitless.esm.js"() {
    unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
  }
});

// node_modules/styled-components/dist/styled-components.browser.esm.js
var styled_components_browser_esm_exports = {};
__export(styled_components_browser_esm_exports, {
  ServerStyleSheet: () => ut,
  StyleSheetConsumer: () => je,
  StyleSheetContext: () => ke,
  StyleSheetManager: () => Fe,
  ThemeConsumer: () => Ue,
  ThemeContext: () => He,
  ThemeProvider: () => Xe,
  __PRIVATE__: () => pt,
  createGlobalStyle: () => at,
  css: () => nt,
  default: () => st,
  isStyledComponent: () => ee,
  keyframes: () => ct,
  styled: () => st,
  useTheme: () => Je,
  version: () => m,
  withTheme: () => lt
});
function P(e5, t4, n4) {
  return void 0 === n4 && (n4 = N), e5.theme !== n4.theme && e5.theme || t4 || n4.theme;
}
function A(e5) {
  return e5.replace(C, "-").replace(I, "");
}
function R(e5) {
  var t4, n4 = "";
  for (t4 = Math.abs(e5); t4 > 52; t4 = t4 / 52 | 0)
    n4 = D(t4 % 52) + n4;
  return (D(t4 % 52) + n4).replace(O, "$1-$2");
}
function x(e5) {
  return R(j(e5) >>> 0);
}
function V(e5) {
  return "string" == typeof e5 && e5 || e5.displayName || e5.name || "Component";
}
function F(e5) {
  return "string" == typeof e5 && e5.charAt(0) === e5.charAt(0).toLowerCase();
}
function W(e5) {
  return ("type" in (t4 = e5) && t4.type.$$typeof) === $ ? G : "$$typeof" in e5 ? Y[e5.$$typeof] : B;
  var t4;
}
function K(e5, t4, n4) {
  if ("string" != typeof t4) {
    if (Z) {
      var o4 = X(t4);
      o4 && o4 !== Z && K(e5, o4, n4);
    }
    var r4 = H(t4);
    U && (r4 = r4.concat(U(t4)));
    for (var s5 = W(e5), i4 = W(t4), a5 = 0; a5 < r4.length; ++a5) {
      var c4 = r4[a5];
      if (!(c4 in L || n4 && n4[c4] || i4 && c4 in i4 || s5 && c4 in s5)) {
        var l3 = J(t4, c4);
        try {
          q(e5, c4, l3);
        } catch (e6) {
        }
      }
    }
  }
  return e5;
}
function Q(e5) {
  return "function" == typeof e5;
}
function ee(e5) {
  return "object" == typeof e5 && "styledComponentId" in e5;
}
function te(e5, t4) {
  return e5 && t4 ? "".concat(e5, " ").concat(t4) : e5 || t4 || "";
}
function ne(e5, t4) {
  if (0 === e5.length)
    return "";
  for (var n4 = e5[0], o4 = 1; o4 < e5.length; o4++)
    n4 += t4 ? t4 + e5[o4] : e5[o4];
  return n4;
}
function oe(e5) {
  return null !== e5 && "object" == typeof e5 && e5.constructor.name === Object.name && !("props" in e5 && e5.$$typeof);
}
function re(e5, t4, n4) {
  if (void 0 === n4 && (n4 = false), !n4 && !oe(e5) && !Array.isArray(e5))
    return t4;
  if (Array.isArray(t4))
    for (var o4 = 0; o4 < t4.length; o4++)
      e5[o4] = re(e5[o4], t4[o4]);
  else if (oe(t4))
    for (var o4 in t4)
      e5[o4] = re(e5[o4], t4[o4]);
  return e5;
}
function se(e5, t4) {
  Object.defineProperty(e5, "toString", { value: t4 });
}
function ae() {
  for (var e5 = [], t4 = 0; t4 < arguments.length; t4++)
    e5[t4] = arguments[t4];
  for (var n4 = e5[0], o4 = [], r4 = 1, s5 = e5.length; r4 < s5; r4 += 1)
    o4.push(e5[r4]);
  return o4.forEach(function(e6) {
    n4 = n4.replace(/%[a-z]/, e6);
  }), n4;
}
function ce(t4) {
  for (var n4 = [], o4 = 1; o4 < arguments.length; o4++)
    n4[o4 - 1] = arguments[o4];
  return false ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t4, " for more information.").concat(n4.length > 0 ? " Args: ".concat(n4.join(", ")) : "")) : new Error(ae.apply(void 0, __spreadArray([ie[t4]], n4, false)).trim());
}
function Se() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
function Oe(e5, t4) {
  return e5.map(function(e6) {
    return "rule" === e6.type && (e6.value = "".concat(t4, " ").concat(e6.value), e6.value = e6.value.replaceAll(",", ",".concat(t4, " ")), e6.props = e6.props.map(function(e7) {
      return "".concat(t4, " ").concat(e7);
    })), Array.isArray(e6.children) && "@keyframes" !== e6.type && (e6.children = Oe(e6.children, t4)), e6;
  });
}
function De(e5) {
  var t4, n4, o4, r4 = void 0 === e5 ? N : e5, s5 = r4.options, i4 = void 0 === s5 ? N : s5, a5 = r4.plugins, c4 = void 0 === a5 ? E : a5, l3 = function(e6, o5, r5) {
    return r5 === n4 || r5.startsWith(n4) && r5.endsWith(n4) && r5.replaceAll(n4, "").length > 0 ? ".".concat(t4) : e6;
  }, u3 = c4.slice();
  u3.push(function(e6) {
    e6.type === RULESET && e6.value.includes("&") && (e6.props[0] = e6.props[0].replace(Ie, n4).replace(o4, l3));
  }), i4.prefix && u3.push(prefixer), u3.push(stringify);
  var p2 = function(e6, r5, s6, a6) {
    void 0 === r5 && (r5 = ""), void 0 === s6 && (s6 = ""), void 0 === a6 && (a6 = "&"), t4 = a6, n4 = r5, o4 = new RegExp("\\".concat(n4, "\\b"), "g");
    var c5 = e6.replace(Ae, ""), l4 = compile(s6 || r5 ? "".concat(s6, " ").concat(r5, " { ").concat(c5, " }") : c5);
    i4.namespace && (l4 = Oe(l4, i4.namespace));
    var p3 = [];
    return serialize(l4, middleware(u3.concat(rulesheet(function(e7) {
      return p3.push(e7);
    })))), p3;
  };
  return p2.hash = c4.length ? c4.reduce(function(e6, t5) {
    return t5.name || ce(15), k(e6, t5.name);
  }, 5381).toString() : "", p2;
}
function Ve() {
  return (0, import_react.useContext)(ke);
}
function Fe(e5) {
  var t4 = (0, import_react.useState)(e5.stylisPlugins), n4 = t4[0], r4 = t4[1], c4 = Ve().styleSheet, l3 = (0, import_react.useMemo)(function() {
    var t5 = c4;
    return e5.sheet ? t5 = e5.sheet : e5.target && (t5 = t5.reconstructWithOptions({ target: e5.target }, false)), e5.disableCSSOMInjection && (t5 = t5.reconstructWithOptions({ useCSSOMInjection: false })), t5;
  }, [e5.disableCSSOMInjection, e5.sheet, e5.target, c4]), u3 = (0, import_react.useMemo)(function() {
    return De({ options: { namespace: e5.namespace, prefix: e5.enableVendorPrefixes }, plugins: n4 });
  }, [e5.enableVendorPrefixes, e5.namespace, n4]);
  (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n4, e5.stylisPlugins) || r4(e5.stylisPlugins);
  }, [e5.stylisPlugins]);
  var d3 = (0, import_react.useMemo)(function() {
    return { shouldForwardProp: e5.shouldForwardProp, styleSheet: l3, stylis: u3 };
  }, [e5.shouldForwardProp, l3, u3]);
  return import_react.default.createElement(ke.Provider, { value: d3 }, import_react.default.createElement(xe.Provider, { value: u3 }, e5.children));
}
function ze(e5) {
  for (var t4 = "", n4 = 0; n4 < e5.length; n4++) {
    var o4 = e5[n4];
    if (1 === n4 && "-" === o4 && "-" === e5[0])
      return e5;
    $e(o4) ? t4 += "-" + o4.toLowerCase() : t4 += o4;
  }
  return t4.startsWith("ms-") ? "-" + t4 : t4;
}
function Ge(e5, t4, n4, o4) {
  if (Be(e5))
    return [];
  if (ee(e5))
    return [".".concat(e5.styledComponentId)];
  if (Q(e5)) {
    if (!Q(s5 = e5) || s5.prototype && s5.prototype.isReactComponent || !t4)
      return [e5];
    var r4 = e5(t4);
    return "object" != typeof r4 || Array.isArray(r4) || r4 instanceof Me || oe(r4) || null === r4 || console.error("".concat(V(e5), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Ge(r4, t4, n4, o4);
  }
  var s5;
  return e5 instanceof Me ? n4 ? (e5.inject(n4, o4), [e5.getName(o4)]) : [e5] : oe(e5) ? Le(e5) : Array.isArray(e5) ? Array.prototype.concat.apply(E, e5.map(function(e6) {
    return Ge(e6, t4, n4, o4);
  })) : [e5.toString()];
}
function Ye(e5) {
  for (var t4 = 0; t4 < e5.length; t4 += 1) {
    var n4 = e5[t4];
    if (Q(n4) && !ee(n4))
      return false;
  }
  return true;
}
function Je() {
  var e5 = (0, import_react.useContext)(He);
  if (!e5)
    throw ce(18);
  return e5;
}
function Xe(e5) {
  var n4 = import_react.default.useContext(He), r4 = (0, import_react.useMemo)(function() {
    return function(e6, n5) {
      if (!e6)
        throw ce(14);
      if (Q(e6)) {
        var o4 = e6(n5);
        if (null === o4 || Array.isArray(o4) || "object" != typeof o4)
          throw ce(7);
        return o4;
      }
      if (Array.isArray(e6) || "object" != typeof e6)
        throw ce(8);
      return n5 ? __assign(__assign({}, n5), e6) : e6;
    }(e5.theme, n4);
  }, [e5.theme, n4]);
  return e5.children ? import_react.default.createElement(He.Provider, { value: r4 }, e5.children) : null;
}
function Qe(e5, r4, s5) {
  var i4 = ee(e5), a5 = e5, c4 = !F(e5), p2 = r4.attrs, d3 = void 0 === p2 ? E : p2, h3 = r4.componentId, f3 = void 0 === h3 ? function(e6, t4) {
    var n4 = "string" != typeof e6 ? "sc" : A(e6);
    Ze[n4] = (Ze[n4] || 0) + 1;
    var o4 = "".concat(n4, "-").concat(x("6.1.1" + n4 + Ze[n4]));
    return t4 ? "".concat(t4, "-").concat(o4) : o4;
  }(r4.displayName, r4.parentComponentId) : h3, m4 = r4.displayName, y4 = void 0 === m4 ? function(e6) {
    return F(e6) ? "styled.".concat(e6) : "Styled(".concat(V(e6), ")");
  }(e5) : m4, v2 = r4.displayName && r4.componentId ? "".concat(A(r4.displayName), "-").concat(r4.componentId) : r4.componentId || f3, g2 = i4 && a5.attrs ? a5.attrs.concat(d3).filter(Boolean) : d3, S4 = r4.shouldForwardProp;
  if (i4 && a5.shouldForwardProp) {
    var w3 = a5.shouldForwardProp;
    if (r4.shouldForwardProp) {
      var C2 = r4.shouldForwardProp;
      S4 = function(e6, t4) {
        return w3(e6, t4) && C2(e6, t4);
      };
    } else
      S4 = w3;
  }
  var I3 = new qe(s5, v2, i4 ? a5.componentStyle : void 0);
  function O3(e6, r5) {
    return function(e7, r6, s6) {
      var i5 = e7.attrs, a6 = e7.componentStyle, c5 = e7.defaultProps, p3 = e7.foldedComponentIds, d4 = e7.styledComponentId, h4 = e7.target, f4 = import_react.default.useContext(He), m5 = Ve(), y5 = e7.shouldForwardProp || m5.shouldForwardProp;
      (0, import_react.useDebugValue)(d4);
      var v6 = function(e8, n4, o4) {
        for (var r7, s7 = __assign(__assign({}, n4), { className: void 0, theme: o4 }), i6 = 0; i6 < e8.length; i6 += 1) {
          var a7 = Q(r7 = e8[i6]) ? r7(s7) : r7;
          for (var c6 in a7)
            s7[c6] = "className" === c6 ? te(s7[c6], a7[c6]) : "style" === c6 ? __assign(__assign({}, s7[c6]), a7[c6]) : a7[c6];
        }
        return n4.className && (s7.className = te(s7.className, n4.className)), s7;
      }(i5, r6, P(r6, f4, c5) || N), g3 = v6.as || h4, S5 = {};
      for (var w4 in v6)
        void 0 === v6[w4] || "$" === w4[0] || "as" === w4 || "theme" === w4 || ("forwardedAs" === w4 ? S5.as = v6.forwardedAs : y5 && !y5(w4, g3) || (S5[w4] = v6[w4], y5 || false || isPropValid(w4) || Ke.has(w4) || !_.has(g3) || (Ke.add(w4), console.warn('styled-components: it looks like an unknown prop "'.concat(w4, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var b3 = function(e8, t4) {
        var n4 = Ve(), o4 = e8.generateAndInjectStyles(t4, n4.styleSheet, n4.stylis);
        return (0, import_react.useDebugValue)(o4), o4;
      }(a6, v6);
      e7.warnTooManyClasses && e7.warnTooManyClasses(b3);
      var E3 = te(p3, d4);
      return b3 && (E3 += " " + b3), v6.className && (E3 += " " + v6.className), S5[F(g3) && !_.has(g3) ? "class" : "className"] = E3, S5.ref = s6, (0, import_react.createElement)(g3, S5);
    }(D3, e6, r5);
  }
  O3.displayName = y4;
  var D3 = import_react.default.forwardRef(O3);
  return D3.attrs = g2, D3.componentStyle = I3, D3.displayName = y4, D3.shouldForwardProp = S4, D3.foldedComponentIds = i4 ? te(a5.foldedComponentIds, a5.styledComponentId) : "", D3.styledComponentId = v2, D3.target = i4 ? a5.target : e5, Object.defineProperty(D3, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e6) {
    this._foldedDefaultProps = i4 ? function(e7) {
      for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
        t4[n4 - 1] = arguments[n4];
      for (var o4 = 0, r5 = t4; o4 < r5.length; o4++)
        re(e7, r5[o4], true);
      return e7;
    }({}, a5.defaultProps, e6) : e6;
  } }), b(y4, v2), D3.warnTooManyClasses = function(e6, t4) {
    var n4 = {}, o4 = false;
    return function(r5) {
      if (!o4 && (n4[r5] = true, Object.keys(n4).length >= 200)) {
        var s6 = t4 ? ' with the id of "'.concat(t4, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e6).concat(s6, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o4 = true, n4 = {};
      }
    };
  }(y4, v2), se(D3, function() {
    return ".".concat(D3.styledComponentId);
  }), c4 && K(D3, e5, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D3;
}
function et(e5, t4) {
  for (var n4 = [e5[0]], o4 = 0, r4 = t4.length; o4 < r4; o4 += 1)
    n4.push(t4[o4], e5[o4 + 1]);
  return n4;
}
function nt(t4) {
  for (var n4 = [], o4 = 1; o4 < arguments.length; o4++)
    n4[o4 - 1] = arguments[o4];
  if (Q(t4) || oe(t4)) {
    var r4 = t4;
    return tt(Ge(et(E, __spreadArray([r4], n4, true))));
  }
  var s5 = t4;
  return 0 === n4.length && 1 === s5.length && "string" == typeof s5[0] ? Ge(s5) : tt(Ge(et(s5, n4)));
}
function ot(n4, o4, r4) {
  if (void 0 === r4 && (r4 = N), !o4)
    throw ce(1, o4);
  var s5 = function(t4) {
    for (var s6 = [], i4 = 1; i4 < arguments.length; i4++)
      s6[i4 - 1] = arguments[i4];
    return n4(o4, r4, nt.apply(void 0, __spreadArray([t4], s6, false)));
  };
  return s5.attrs = function(e5) {
    return ot(n4, o4, __assign(__assign({}, r4), { attrs: Array.prototype.concat(r4.attrs, e5).filter(Boolean) }));
  }, s5.withConfig = function(e5) {
    return ot(n4, o4, __assign(__assign({}, r4), e5));
  }, s5;
}
function at(n4) {
  for (var r4 = [], s5 = 1; s5 < arguments.length; s5++)
    r4[s5 - 1] = arguments[s5];
  var i4 = nt.apply(void 0, __spreadArray([n4], r4, false)), a5 = "sc-global-".concat(x(JSON.stringify(i4))), c4 = new it(i4, a5);
  b(a5);
  var l3 = function(e5) {
    var t4 = Ve(), n5 = import_react.default.useContext(He), r5 = import_react.default.useRef(t4.styleSheet.allocateGSInstance(a5)).current;
    return import_react.default.Children.count(e5.children) && console.warn("The global style component ".concat(a5, " was given child JSX. createGlobalStyle does not render children.")), i4.some(function(e6) {
      return "string" == typeof e6 && -1 !== e6.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t4.styleSheet.server && u3(r5, e5, t4.styleSheet, n5, t4.stylis), import_react.default.useLayoutEffect(function() {
      if (!t4.styleSheet.server)
        return u3(r5, e5, t4.styleSheet, n5, t4.stylis), function() {
          return c4.removeStyles(r5, t4.styleSheet);
        };
    }, [r5, e5, t4.styleSheet, n5, t4.stylis]), null;
  };
  function u3(e5, n5, o4, r5, s6) {
    if (c4.isStatic)
      c4.renderStyles(e5, g, o4, s6);
    else {
      var i5 = __assign(__assign({}, n5), { theme: P(n5, r5, l3.defaultProps) });
      c4.renderStyles(e5, i5, o4, s6);
    }
  }
  return import_react.default.memo(l3);
}
function ct(t4) {
  for (var n4 = [], o4 = 1; o4 < arguments.length; o4++)
    n4[o4 - 1] = arguments[o4];
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  var r4 = ne(nt.apply(void 0, __spreadArray([t4], n4, false))), s5 = x(r4);
  return new Me(s5, r4);
}
function lt(e5) {
  var n4 = import_react.default.forwardRef(function(n5, r4) {
    var s5 = P(n5, import_react.default.useContext(He), e5.defaultProps);
    return void 0 === s5 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "'.concat(V(e5), '"')), import_react.default.createElement(e5, __assign({}, n5, { theme: s5, ref: r4 }));
  });
  return n4.displayName = "WithTheme(".concat(V(e5), ")"), K(n4, e5);
}
var import_react, import_shallowequal, f, m, y, v, g, S, w, b, E, N, _, C, I, O, D, T, k, j, M, $, z, B, L, G, Y, q, H, U, J, X, Z, ie, le, ue, pe, de, he, fe, me, ye, ve, ge, we, be, Ee, Ne, Pe, _e, Ce, Ie, Ae, Re, Te, ke, je, xe, Me, $e, Be, Le, We, qe, He, Ue, Ze, Ke, tt, rt, st, it, ut, pt, dt;
var init_styled_components_browser_esm = __esm({
  "node_modules/styled-components/dist/styled-components.browser.esm.js"() {
    init_tslib_es6();
    init_emotion_is_prop_valid_esm();
    import_react = __toESM(require_react());
    import_shallowequal = __toESM(require_shallowequal());
    init_stylis();
    init_emotion_unitless_esm();
    f = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
    m = "6.1.1";
    y = "undefined" != typeof window && "HTMLElement" in window;
    v = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);
    g = {};
    S = /invalid hook call/i;
    w = /* @__PURE__ */ new Set();
    b = function(t4, n4) {
      if (true) {
        var o4 = n4 ? ' with the id of "'.concat(n4, '"') : "", s5 = "The component ".concat(t4).concat(o4, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", i4 = console.error;
        try {
          var a5 = true;
          console.error = function(t5) {
            for (var n5 = [], o5 = 1; o5 < arguments.length; o5++)
              n5[o5 - 1] = arguments[o5];
            S.test(t5) ? (a5 = false, w.delete(s5)) : i4.apply(void 0, __spreadArray([t5], n5, false));
          }, (0, import_react.useRef)(), a5 && !w.has(s5) && (console.warn(s5), w.add(s5));
        } catch (e5) {
          S.test(e5.message) && w.delete(s5);
        } finally {
          console.error = i4;
        }
      }
    };
    E = Object.freeze([]);
    N = Object.freeze({});
    _ = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
    C = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
    I = /(^-|-$)/g;
    O = /(a)(d)/gi;
    D = function(e5) {
      return String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));
    };
    k = function(e5, t4) {
      for (var n4 = t4.length; n4; )
        e5 = 33 * e5 ^ t4.charCodeAt(--n4);
      return e5;
    };
    j = function(e5) {
      return k(5381, e5);
    };
    M = "function" == typeof Symbol && Symbol.for;
    $ = M ? Symbol.for("react.memo") : 60115;
    z = M ? Symbol.for("react.forward_ref") : 60112;
    B = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
    L = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
    G = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
    Y = ((T = {})[z] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, T[$] = G, T);
    q = Object.defineProperty;
    H = Object.getOwnPropertyNames;
    U = Object.getOwnPropertySymbols;
    J = Object.getOwnPropertyDescriptor;
    X = Object.getPrototypeOf;
    Z = Object.prototype;
    ie = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
    le = function() {
      function e5(e6) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e6;
      }
      return e5.prototype.indexOfGroup = function(e6) {
        for (var t4 = 0, n4 = 0; n4 < e6; n4++)
          t4 += this.groupSizes[n4];
        return t4;
      }, e5.prototype.insertRules = function(e6, t4) {
        if (e6 >= this.groupSizes.length) {
          for (var n4 = this.groupSizes, o4 = n4.length, r4 = o4; e6 >= r4; )
            if ((r4 <<= 1) < 0)
              throw ce(16, "".concat(e6));
          this.groupSizes = new Uint32Array(r4), this.groupSizes.set(n4), this.length = r4;
          for (var s5 = o4; s5 < r4; s5++)
            this.groupSizes[s5] = 0;
        }
        for (var i4 = this.indexOfGroup(e6 + 1), a5 = (s5 = 0, t4.length); s5 < a5; s5++)
          this.tag.insertRule(i4, t4[s5]) && (this.groupSizes[e6]++, i4++);
      }, e5.prototype.clearGroup = function(e6) {
        if (e6 < this.length) {
          var t4 = this.groupSizes[e6], n4 = this.indexOfGroup(e6), o4 = n4 + t4;
          this.groupSizes[e6] = 0;
          for (var r4 = n4; r4 < o4; r4++)
            this.tag.deleteRule(n4);
        }
      }, e5.prototype.getGroup = function(e6) {
        var t4 = "";
        if (e6 >= this.length || 0 === this.groupSizes[e6])
          return t4;
        for (var n4 = this.groupSizes[e6], o4 = this.indexOfGroup(e6), r4 = o4 + n4, s5 = o4; s5 < r4; s5++)
          t4 += "".concat(this.tag.getRule(s5)).concat("/*!sc*/\n");
        return t4;
      }, e5;
    }();
    ue = /* @__PURE__ */ new Map();
    pe = /* @__PURE__ */ new Map();
    de = 1;
    he = function(e5) {
      if (ue.has(e5))
        return ue.get(e5);
      for (; pe.has(de); )
        de++;
      var t4 = de++;
      if ((0 | t4) < 0 || t4 > 1073741824)
        throw ce(16, "".concat(t4));
      return ue.set(e5, t4), pe.set(t4, e5), t4;
    };
    fe = function(e5, t4) {
      de = t4 + 1, ue.set(e5, t4), pe.set(t4, e5);
    };
    me = "style[".concat(f, "][").concat("data-styled-version", '="').concat("6.1.1", '"]');
    ye = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
    ve = function(e5, t4, n4) {
      for (var o4, r4 = n4.split(","), s5 = 0, i4 = r4.length; s5 < i4; s5++)
        (o4 = r4[s5]) && e5.registerName(t4, o4);
    };
    ge = function(e5, t4) {
      for (var n4, o4 = (null !== (n4 = t4.textContent) && void 0 !== n4 ? n4 : "").split("/*!sc*/\n"), r4 = [], s5 = 0, i4 = o4.length; s5 < i4; s5++) {
        var a5 = o4[s5].trim();
        if (a5) {
          var c4 = a5.match(ye);
          if (c4) {
            var l3 = 0 | parseInt(c4[1], 10), u3 = c4[2];
            0 !== l3 && (fe(u3, l3), ve(e5, u3, c4[3]), e5.getTag().insertRules(l3, r4)), r4.length = 0;
          } else
            r4.push(a5);
        }
      }
    };
    we = function(e5) {
      var t4 = document.head, n4 = e5 || t4, o4 = document.createElement("style"), r4 = function(e6) {
        var t5 = Array.from(e6.querySelectorAll("style[".concat(f, "]")));
        return t5[t5.length - 1];
      }(n4), s5 = void 0 !== r4 ? r4.nextSibling : null;
      o4.setAttribute(f, "active"), o4.setAttribute("data-styled-version", "6.1.1");
      var i4 = Se();
      return i4 && o4.setAttribute("nonce", i4), n4.insertBefore(o4, s5), o4;
    };
    be = function() {
      function e5(e6) {
        this.element = we(e6), this.element.appendChild(document.createTextNode("")), this.sheet = function(e7) {
          if (e7.sheet)
            return e7.sheet;
          for (var t4 = document.styleSheets, n4 = 0, o4 = t4.length; n4 < o4; n4++) {
            var r4 = t4[n4];
            if (r4.ownerNode === e7)
              return r4;
          }
          throw ce(17);
        }(this.element), this.length = 0;
      }
      return e5.prototype.insertRule = function(e6, t4) {
        try {
          return this.sheet.insertRule(t4, e6), this.length++, true;
        } catch (e7) {
          return false;
        }
      }, e5.prototype.deleteRule = function(e6) {
        this.sheet.deleteRule(e6), this.length--;
      }, e5.prototype.getRule = function(e6) {
        var t4 = this.sheet.cssRules[e6];
        return t4 && t4.cssText ? t4.cssText : "";
      }, e5;
    }();
    Ee = function() {
      function e5(e6) {
        this.element = we(e6), this.nodes = this.element.childNodes, this.length = 0;
      }
      return e5.prototype.insertRule = function(e6, t4) {
        if (e6 <= this.length && e6 >= 0) {
          var n4 = document.createTextNode(t4);
          return this.element.insertBefore(n4, this.nodes[e6] || null), this.length++, true;
        }
        return false;
      }, e5.prototype.deleteRule = function(e6) {
        this.element.removeChild(this.nodes[e6]), this.length--;
      }, e5.prototype.getRule = function(e6) {
        return e6 < this.length ? this.nodes[e6].textContent : "";
      }, e5;
    }();
    Ne = function() {
      function e5(e6) {
        this.rules = [], this.length = 0;
      }
      return e5.prototype.insertRule = function(e6, t4) {
        return e6 <= this.length && (this.rules.splice(e6, 0, t4), this.length++, true);
      }, e5.prototype.deleteRule = function(e6) {
        this.rules.splice(e6, 1), this.length--;
      }, e5.prototype.getRule = function(e6) {
        return e6 < this.length ? this.rules[e6] : "";
      }, e5;
    }();
    Pe = y;
    _e = { isServer: !y, useCSSOMInjection: !v };
    Ce = function() {
      function e5(e6, n4, o4) {
        void 0 === e6 && (e6 = N), void 0 === n4 && (n4 = {});
        var r4 = this;
        this.options = __assign(__assign({}, _e), e6), this.gs = n4, this.names = new Map(o4), this.server = !!e6.isServer, !this.server && y && Pe && (Pe = false, function(e7) {
          for (var t4 = document.querySelectorAll(me), n5 = 0, o5 = t4.length; n5 < o5; n5++) {
            var r5 = t4[n5];
            r5 && "active" !== r5.getAttribute(f) && (ge(e7, r5), r5.parentNode && r5.parentNode.removeChild(r5));
          }
        }(this)), se(this, function() {
          return function(e7) {
            for (var t4 = e7.getTag(), n5 = t4.length, o5 = "", r5 = function(n6) {
              var r6 = function(e8) {
                return pe.get(e8);
              }(n6);
              if (void 0 === r6)
                return "continue";
              var s6 = e7.names.get(r6), i4 = t4.getGroup(n6);
              if (void 0 === s6 || 0 === i4.length)
                return "continue";
              var a5 = "".concat(f, ".g").concat(n6, '[id="').concat(r6, '"]'), c4 = "";
              void 0 !== s6 && s6.forEach(function(e8) {
                e8.length > 0 && (c4 += "".concat(e8, ","));
              }), o5 += "".concat(i4).concat(a5, '{content:"').concat(c4, '"}').concat("/*!sc*/\n");
            }, s5 = 0; s5 < n5; s5++)
              r5(s5);
            return o5;
          }(r4);
        });
      }
      return e5.registerId = function(e6) {
        return he(e6);
      }, e5.prototype.reconstructWithOptions = function(n4, o4) {
        return void 0 === o4 && (o4 = true), new e5(__assign(__assign({}, this.options), n4), this.gs, o4 && this.names || void 0);
      }, e5.prototype.allocateGSInstance = function(e6) {
        return this.gs[e6] = (this.gs[e6] || 0) + 1;
      }, e5.prototype.getTag = function() {
        return this.tag || (this.tag = (e6 = function(e7) {
          var t4 = e7.useCSSOMInjection, n4 = e7.target;
          return e7.isServer ? new Ne(n4) : t4 ? new be(n4) : new Ee(n4);
        }(this.options), new le(e6)));
        var e6;
      }, e5.prototype.hasNameForId = function(e6, t4) {
        return this.names.has(e6) && this.names.get(e6).has(t4);
      }, e5.prototype.registerName = function(e6, t4) {
        if (he(e6), this.names.has(e6))
          this.names.get(e6).add(t4);
        else {
          var n4 = /* @__PURE__ */ new Set();
          n4.add(t4), this.names.set(e6, n4);
        }
      }, e5.prototype.insertRules = function(e6, t4, n4) {
        this.registerName(e6, t4), this.getTag().insertRules(he(e6), n4);
      }, e5.prototype.clearNames = function(e6) {
        this.names.has(e6) && this.names.get(e6).clear();
      }, e5.prototype.clearRules = function(e6) {
        this.getTag().clearGroup(he(e6)), this.clearNames(e6);
      }, e5.prototype.clearTag = function() {
        this.tag = void 0;
      }, e5;
    }();
    Ie = /&/g;
    Ae = /^\s*\/\/.*$/gm;
    Re = new Ce();
    Te = De();
    ke = import_react.default.createContext({ shouldForwardProp: void 0, styleSheet: Re, stylis: Te });
    je = ke.Consumer;
    xe = import_react.default.createContext(void 0);
    Me = function() {
      function e5(e6, t4) {
        var n4 = this;
        this.inject = function(e7, t5) {
          void 0 === t5 && (t5 = Te);
          var o4 = n4.name + t5.hash;
          e7.hasNameForId(n4.id, o4) || e7.insertRules(n4.id, o4, t5(n4.rules, o4, "@keyframes"));
        }, this.name = e6, this.id = "sc-keyframes-".concat(e6), this.rules = t4, se(this, function() {
          throw ce(12, String(n4.name));
        });
      }
      return e5.prototype.getName = function(e6) {
        return void 0 === e6 && (e6 = Te), this.name + e6.hash;
      }, e5;
    }();
    $e = function(e5) {
      return e5 >= "A" && e5 <= "Z";
    };
    Be = function(e5) {
      return null == e5 || false === e5 || "" === e5;
    };
    Le = function(t4) {
      var n4, o4, r4 = [];
      for (var s5 in t4) {
        var i4 = t4[s5];
        t4.hasOwnProperty(s5) && !Be(i4) && (Array.isArray(i4) && i4.isCss || Q(i4) ? r4.push("".concat(ze(s5), ":"), i4, ";") : oe(i4) ? r4.push.apply(r4, __spreadArray(__spreadArray(["".concat(s5, " {")], Le(i4), false), ["}"], false)) : r4.push("".concat(ze(s5), ": ").concat((n4 = s5, null == (o4 = i4) || "boolean" == typeof o4 || "" === o4 ? "" : "number" != typeof o4 || 0 === o4 || n4 in unitlessKeys || n4.startsWith("--") ? String(o4).trim() : "".concat(o4, "px")), ";")));
      }
      return r4;
    };
    We = j("6.1.1");
    qe = function() {
      function e5(e6, t4, n4) {
        this.rules = e6, this.staticRulesId = "", this.isStatic = false, this.componentId = t4, this.baseHash = k(We, t4), this.baseStyle = n4, Ce.registerId(t4);
      }
      return e5.prototype.generateAndInjectStyles = function(e6, t4, n4) {
        var o4 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e6, t4, n4) : "";
        if (this.isStatic && !n4.hash)
          if (this.staticRulesId && t4.hasNameForId(this.componentId, this.staticRulesId))
            o4 = te(o4, this.staticRulesId);
          else {
            var r4 = ne(Ge(this.rules, e6, t4, n4)), s5 = R(k(this.baseHash, r4) >>> 0);
            if (!t4.hasNameForId(this.componentId, s5)) {
              var i4 = n4(r4, ".".concat(s5), void 0, this.componentId);
              t4.insertRules(this.componentId, s5, i4);
            }
            o4 = te(o4, s5), this.staticRulesId = s5;
          }
        else {
          for (var a5 = k(this.baseHash, n4.hash), c4 = "", l3 = 0; l3 < this.rules.length; l3++) {
            var u3 = this.rules[l3];
            if ("string" == typeof u3)
              c4 += u3, a5 = k(a5, u3);
            else if (u3) {
              var p2 = ne(Ge(u3, e6, t4, n4));
              a5 = k(a5, p2 + l3), c4 += p2;
            }
          }
          if (c4) {
            var d3 = R(a5 >>> 0);
            t4.hasNameForId(this.componentId, d3) || t4.insertRules(this.componentId, d3, n4(c4, ".".concat(d3), void 0, this.componentId)), o4 = te(o4, d3);
          }
        }
        return o4;
      }, e5;
    }();
    He = import_react.default.createContext(void 0);
    Ue = He.Consumer;
    Ze = {};
    Ke = /* @__PURE__ */ new Set();
    tt = function(e5) {
      return Object.assign(e5, { isCss: true });
    };
    rt = function(e5) {
      return ot(Qe, e5);
    };
    st = rt;
    _.forEach(function(e5) {
      st[e5] = rt(e5);
    });
    it = function() {
      function e5(e6, t4) {
        this.rules = e6, this.componentId = t4, this.isStatic = Ye(e6), Ce.registerId(this.componentId + 1);
      }
      return e5.prototype.createStyles = function(e6, t4, n4, o4) {
        var r4 = o4(ne(Ge(this.rules, t4, n4, o4)), ""), s5 = this.componentId + e6;
        n4.insertRules(s5, s5, r4);
      }, e5.prototype.removeStyles = function(e6, t4) {
        t4.clearRules(this.componentId + e6);
      }, e5.prototype.renderStyles = function(e6, t4, n4, o4) {
        e6 > 2 && Ce.registerId(this.componentId + e6), this.removeStyles(e6, n4), this.createStyles(e6, t4, n4, o4);
      }, e5;
    }();
    ut = function() {
      function e5() {
        var e6 = this;
        this._emitSheetCSS = function() {
          var t4 = e6.instance.toString(), n4 = Se(), o4 = ne([n4 && 'nonce="'.concat(n4, '"'), "".concat(f, '="true"'), "".concat("data-styled-version", '="').concat("6.1.1", '"')].filter(Boolean), " ");
          return "<style ".concat(o4, ">").concat(t4, "</style>");
        }, this.getStyleTags = function() {
          if (e6.sealed)
            throw ce(2);
          return e6._emitSheetCSS();
        }, this.getStyleElement = function() {
          var n4;
          if (e6.sealed)
            throw ce(2);
          var r4 = ((n4 = {})[f] = "", n4["data-styled-version"] = "6.1.1", n4.dangerouslySetInnerHTML = { __html: e6.instance.toString() }, n4), s5 = Se();
          return s5 && (r4.nonce = s5), [import_react.default.createElement("style", __assign({}, r4, { key: "sc-0-0" }))];
        }, this.seal = function() {
          e6.sealed = true;
        }, this.instance = new Ce({ isServer: true }), this.sealed = false;
      }
      return e5.prototype.collectStyles = function(e6) {
        if (this.sealed)
          throw ce(2);
        return import_react.default.createElement(Fe, { sheet: this.instance }, e6);
      }, e5.prototype.interleaveWithNodeStream = function(e6) {
        throw ce(3);
      }, e5;
    }();
    pt = { StyleSheet: Ce, mainSheet: Re };
    "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
    dt = "__sc-".concat(f, "__");
    "undefined" != typeof window && (window[dt] || (window[dt] = 0), 1 === window[dt] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window[dt] += 1);
  }
});

// node_modules/refractor/lang/javascript.js
var require_javascript = __commonJS({
  "node_modules/refractor/lang/javascript.js"(exports, module2) {
    "use strict";
    module2.exports = javascript;
    javascript.displayName = "javascript";
    javascript.aliases = ["js"];
    function javascript(Prism) {
      Prism.languages.javascript = Prism.languages.extend("clike", {
        "class-name": [
          Prism.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        keyword: [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        number: {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism.languages.insertBefore("javascript", "keyword", {
        regex: {
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        parameter: [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism.languages.javascript
          }
        ],
        constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism.languages.insertBefore("javascript", "string", {
        hashbang: {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism.languages.javascript
              }
            },
            string: /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined("script", "javascript");
        Prism.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism.languages.js = Prism.languages.javascript;
    }
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element4 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment5 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement4(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element4;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment5;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement4;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development2();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject2(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i4 = 0; i4 < 10; i4++) {
          test2["_" + String.fromCharCode(i4)] = i4;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n4) {
          return test2[n4];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from4;
      var to2 = toObject2(target);
      var symbols;
      for (var s5 = 1; s5 < arguments.length; s5++) {
        from4 = Object(arguments[s5]);
        for (var key2 in from4) {
          if (hasOwnProperty.call(from4, key2)) {
            to2[key2] = from4[key2];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from4);
          for (var i4 = 0; i4 < symbols.length; i4++) {
            if (propIsEnumerable.call(from4, symbols[i4])) {
              to2[symbols[i4]] = from4[symbols[i4]];
            }
          }
        }
      }
      return to2;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has2 = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has2;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
    "use strict";
    var ReactIs = require_react_is2();
    var assign3 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has2 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is2(x3, y4) {
        if (x3 === y4) {
          return x3 !== 0 || 1 / x3 === 1 / y4;
        } else {
          return x3 !== x3 && y4 !== y4;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate2) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate2(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate2(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate2(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i4 = 0; i4 < propValue.length; i4++) {
            var error = typeChecker(propValue, i4, componentName, location, propFullName + "[" + i4 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeChecker() {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeTypeChecker() {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate2(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i4 = 0; i4 < expectedValues.length; i4++) {
            if (is2(propValue, expectedValues[i4])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key2, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate2(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key2 in propValue) {
            if (has2(propValue, key2)) {
              var error = typeChecker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
          var checker = arrayOfTypeCheckers[i4];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i4 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate2(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i5 = 0; i5 < arrayOfTypeCheckers.length; i5++) {
            var checker2 = arrayOfTypeCheckers[i5];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createNodeChecker() {
        function validate2(props, propName, componentName, location, propFullName) {
          if (!isNode4(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function invalidValidatorError(componentName, location, propFullName, key2, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key2 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key2 in shapeTypes) {
            var checker = shapeTypes[key2];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
            }
            var error = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign3({}, props[propName], shapeTypes);
          for (var key2 in allKeys) {
            var checker = shapeTypes[key2];
            if (has2(shapeTypes, key2) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key2 + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function isNode4(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode4);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator2 = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator2.next()).done) {
                  if (!isNode4(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator2.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode4(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    if (true) {
      ReactIs = require_react_is2();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module2) {
    module2.exports = extend2;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend2() {
      var target = {};
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key2 in source) {
          if (hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/property-information/lib/util/schema.js
var require_schema = __commonJS({
  "node_modules/property-information/lib/util/schema.js"(exports, module2) {
    "use strict";
    module2.exports = Schema;
    var proto2 = Schema.prototype;
    proto2.space = null;
    proto2.normal = {};
    proto2.property = {};
    function Schema(property, normal, space) {
      this.property = property;
      this.normal = normal;
      if (space) {
        this.space = space;
      }
    }
  }
});

// node_modules/property-information/lib/util/merge.js
var require_merge = __commonJS({
  "node_modules/property-information/lib/util/merge.js"(exports, module2) {
    "use strict";
    var xtend = require_immutable();
    var Schema = require_schema();
    module2.exports = merge3;
    function merge3(definitions) {
      var length2 = definitions.length;
      var property = [];
      var normal = [];
      var index3 = -1;
      var info;
      var space;
      while (++index3 < length2) {
        info = definitions[index3];
        property.push(info.property);
        normal.push(info.normal);
        space = info.space;
      }
      return new Schema(
        xtend.apply(null, property),
        xtend.apply(null, normal),
        space
      );
    }
  }
});

// node_modules/property-information/normalize.js
var require_normalize = __commonJS({
  "node_modules/property-information/normalize.js"(exports, module2) {
    "use strict";
    module2.exports = normalize4;
    function normalize4(value) {
      return value.toLowerCase();
    }
  }
});

// node_modules/property-information/lib/util/info.js
var require_info = __commonJS({
  "node_modules/property-information/lib/util/info.js"(exports, module2) {
    "use strict";
    module2.exports = Info;
    var proto2 = Info.prototype;
    proto2.space = null;
    proto2.attribute = null;
    proto2.property = null;
    proto2.boolean = false;
    proto2.booleanish = false;
    proto2.overloadedBoolean = false;
    proto2.number = false;
    proto2.commaSeparated = false;
    proto2.spaceSeparated = false;
    proto2.commaOrSpaceSeparated = false;
    proto2.mustUseProperty = false;
    proto2.defined = false;
    function Info(property, attribute) {
      this.property = property;
      this.attribute = attribute;
    }
  }
});

// node_modules/property-information/lib/util/types.js
var require_types = __commonJS({
  "node_modules/property-information/lib/util/types.js"(exports) {
    "use strict";
    var powers = 0;
    exports.boolean = increment();
    exports.booleanish = increment();
    exports.overloadedBoolean = increment();
    exports.number = increment();
    exports.spaceSeparated = increment();
    exports.commaSeparated = increment();
    exports.commaOrSpaceSeparated = increment();
    function increment() {
      return Math.pow(2, ++powers);
    }
  }
});

// node_modules/property-information/lib/util/defined-info.js
var require_defined_info = __commonJS({
  "node_modules/property-information/lib/util/defined-info.js"(exports, module2) {
    "use strict";
    var Info = require_info();
    var types = require_types();
    module2.exports = DefinedInfo;
    DefinedInfo.prototype = new Info();
    DefinedInfo.prototype.defined = true;
    var checks = [
      "boolean",
      "booleanish",
      "overloadedBoolean",
      "number",
      "commaSeparated",
      "spaceSeparated",
      "commaOrSpaceSeparated"
    ];
    var checksLength = checks.length;
    function DefinedInfo(property, attribute, mask, space) {
      var index3 = -1;
      var check;
      mark(this, "space", space);
      Info.call(this, property, attribute);
      while (++index3 < checksLength) {
        check = checks[index3];
        mark(this, check, (mask & types[check]) === types[check]);
      }
    }
    function mark(values, key2, value) {
      if (value) {
        values[key2] = value;
      }
    }
  }
});

// node_modules/property-information/lib/util/create.js
var require_create = __commonJS({
  "node_modules/property-information/lib/util/create.js"(exports, module2) {
    "use strict";
    var normalize4 = require_normalize();
    var Schema = require_schema();
    var DefinedInfo = require_defined_info();
    module2.exports = create2;
    function create2(definition) {
      var space = definition.space;
      var mustUseProperty = definition.mustUseProperty || [];
      var attributes = definition.attributes || {};
      var props = definition.properties;
      var transform = definition.transform;
      var property = {};
      var normal = {};
      var prop;
      var info;
      for (prop in props) {
        info = new DefinedInfo(
          prop,
          transform(attributes, prop),
          props[prop],
          space
        );
        if (mustUseProperty.indexOf(prop) !== -1) {
          info.mustUseProperty = true;
        }
        property[prop] = info;
        normal[normalize4(prop)] = prop;
        normal[normalize4(info.attribute)] = prop;
      }
      return new Schema(property, normal, space);
    }
  }
});

// node_modules/property-information/lib/xlink.js
var require_xlink = __commonJS({
  "node_modules/property-information/lib/xlink.js"(exports, module2) {
    "use strict";
    var create2 = require_create();
    module2.exports = create2({
      space: "xlink",
      transform: xlinkTransform,
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    function xlinkTransform(_2, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    }
  }
});

// node_modules/property-information/lib/xml.js
var require_xml = __commonJS({
  "node_modules/property-information/lib/xml.js"(exports, module2) {
    "use strict";
    var create2 = require_create();
    module2.exports = create2({
      space: "xml",
      transform: xmlTransform,
      properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
      }
    });
    function xmlTransform(_2, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    }
  }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
var require_case_sensitive_transform = __commonJS({
  "node_modules/property-information/lib/util/case-sensitive-transform.js"(exports, module2) {
    "use strict";
    module2.exports = caseSensitiveTransform;
    function caseSensitiveTransform(attributes, attribute) {
      return attribute in attributes ? attributes[attribute] : attribute;
    }
  }
});

// node_modules/property-information/lib/util/case-insensitive-transform.js
var require_case_insensitive_transform = __commonJS({
  "node_modules/property-information/lib/util/case-insensitive-transform.js"(exports, module2) {
    "use strict";
    var caseSensitiveTransform = require_case_sensitive_transform();
    module2.exports = caseInsensitiveTransform;
    function caseInsensitiveTransform(attributes, property) {
      return caseSensitiveTransform(attributes, property.toLowerCase());
    }
  }
});

// node_modules/property-information/lib/xmlns.js
var require_xmlns = __commonJS({
  "node_modules/property-information/lib/xmlns.js"(exports, module2) {
    "use strict";
    var create2 = require_create();
    var caseInsensitiveTransform = require_case_insensitive_transform();
    module2.exports = create2({
      space: "xmlns",
      attributes: {
        xmlnsxlink: "xmlns:xlink"
      },
      transform: caseInsensitiveTransform,
      properties: {
        xmlns: null,
        xmlnsXLink: null
      }
    });
  }
});

// node_modules/property-information/lib/aria.js
var require_aria = __commonJS({
  "node_modules/property-information/lib/aria.js"(exports, module2) {
    "use strict";
    var types = require_types();
    var create2 = require_create();
    var booleanish = types.booleanish;
    var number2 = types.number;
    var spaceSeparated = types.spaceSeparated;
    module2.exports = create2({
      transform: ariaTransform,
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number2,
        ariaColIndex: number2,
        ariaColSpan: number2,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number2,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number2,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number2,
        ariaRowIndex: number2,
        ariaRowSpan: number2,
        ariaSelected: booleanish,
        ariaSetSize: number2,
        ariaSort: null,
        ariaValueMax: number2,
        ariaValueMin: number2,
        ariaValueNow: number2,
        ariaValueText: null,
        role: null
      }
    });
    function ariaTransform(_2, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    }
  }
});

// node_modules/property-information/lib/html.js
var require_html = __commonJS({
  "node_modules/property-information/lib/html.js"(exports, module2) {
    "use strict";
    var types = require_types();
    var create2 = require_create();
    var caseInsensitiveTransform = require_case_insensitive_transform();
    var boolean = types.boolean;
    var overloadedBoolean = types.overloadedBoolean;
    var booleanish = types.booleanish;
    var number2 = types.number;
    var spaceSeparated = types.spaceSeparated;
    var commaSeparated = types.commaSeparated;
    module2.exports = create2({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        capture: boolean,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number2,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number2 | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number2,
        hidden: boolean,
        high: number2,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: commaSeparated,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number2,
        manifest: null,
        max: null,
        maxLength: number2,
        media: null,
        method: null,
        min: null,
        minLength: number2,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number2,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number2,
        rowSpan: number2,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shape: null,
        size: number2,
        sizes: null,
        slot: null,
        span: number2,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: commaSeparated,
        start: number2,
        step: null,
        style: null,
        tabIndex: number2,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number2,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        // Several. Use CSS `text-align` instead,
        aLink: null,
        // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated,
        // `<object>`. List of URIs to archives
        axis: null,
        // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null,
        // `<body>`. Use CSS `background-image` instead
        bgColor: null,
        // `<body>` and table elements. Use CSS `background-color` instead
        border: number2,
        // `<table>`. Use CSS `border-width` instead,
        borderColor: null,
        // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number2,
        // `<body>`
        cellPadding: null,
        // `<table>`
        cellSpacing: null,
        // `<table>`
        char: null,
        // Several table elements. When `align=char`, sets the character to align on
        charOff: null,
        // Several table elements. When `char`, offsets the alignment
        classId: null,
        // `<object>`
        clear: null,
        // `<br>`. Use CSS `clear` instead
        code: null,
        // `<object>`
        codeBase: null,
        // `<object>`
        codeType: null,
        // `<object>`
        color: null,
        // `<font>` and `<hr>`. Use CSS instead
        compact: boolean,
        // Lists. Use CSS to reduce space between items instead
        declare: boolean,
        // `<object>`
        event: null,
        // `<script>`
        face: null,
        // `<font>`. Use CSS instead
        frame: null,
        // `<table>`
        frameBorder: null,
        // `<iframe>`. Use CSS `border` instead
        hSpace: number2,
        // `<img>` and `<object>`
        leftMargin: number2,
        // `<body>`
        link: null,
        // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null,
        // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null,
        // `<img>`. Use a `<picture>`
        marginHeight: number2,
        // `<body>`
        marginWidth: number2,
        // `<body>`
        noResize: boolean,
        // `<frame>`
        noHref: boolean,
        // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean,
        // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean,
        // `<td>` and `<th>`
        object: null,
        // `<applet>`
        profile: null,
        // `<head>`
        prompt: null,
        // `<isindex>`
        rev: null,
        // `<link>`
        rightMargin: number2,
        // `<body>`
        rules: null,
        // `<table>`
        scheme: null,
        // `<meta>`
        scrolling: booleanish,
        // `<frame>`. Use overflow in the child context
        standby: null,
        // `<object>`
        summary: null,
        // `<table>`
        text: null,
        // `<body>`. Use CSS `color` instead
        topMargin: number2,
        // `<body>`
        valueType: null,
        // `<param>`
        version: null,
        // `<html>`. Use a doctype.
        vAlign: null,
        // Several. Use CSS `vertical-align` instead
        vLink: null,
        // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number2,
        // `<img>` and `<object>`
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number2,
        security: null,
        unselectable: null
      }
    });
  }
});

// node_modules/property-information/html.js
var require_html2 = __commonJS({
  "node_modules/property-information/html.js"(exports, module2) {
    "use strict";
    var merge3 = require_merge();
    var xlink = require_xlink();
    var xml = require_xml();
    var xmlns = require_xmlns();
    var aria = require_aria();
    var html = require_html();
    module2.exports = merge3([xml, xlink, xmlns, aria, html]);
  }
});

// node_modules/property-information/find.js
var require_find = __commonJS({
  "node_modules/property-information/find.js"(exports, module2) {
    "use strict";
    var normalize4 = require_normalize();
    var DefinedInfo = require_defined_info();
    var Info = require_info();
    var data = "data";
    module2.exports = find2;
    var valid = /^data[-\w.:]+$/i;
    var dash = /-[a-z]/g;
    var cap = /[A-Z]/g;
    function find2(schema, value) {
      var normal = normalize4(value);
      var prop = value;
      var Type = Info;
      if (normal in schema.normal) {
        return schema.property[schema.normal[normal]];
      }
      if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
        if (value.charAt(4) === "-") {
          prop = datasetToProperty(value);
        } else {
          value = datasetToAttribute(value);
        }
        Type = DefinedInfo;
      }
      return new Type(prop, value);
    }
    function datasetToProperty(attribute) {
      var value = attribute.slice(5).replace(dash, camelcase);
      return data + value.charAt(0).toUpperCase() + value.slice(1);
    }
    function datasetToAttribute(property) {
      var value = property.slice(4);
      if (dash.test(value)) {
        return property;
      }
      value = value.replace(cap, kebab);
      if (value.charAt(0) !== "-") {
        value = "-" + value;
      }
      return data + value;
    }
    function kebab($0) {
      return "-" + $0.toLowerCase();
    }
    function camelcase($0) {
      return $0.charAt(1).toUpperCase();
    }
  }
});

// node_modules/hast-util-parse-selector/index.js
var require_hast_util_parse_selector = __commonJS({
  "node_modules/hast-util-parse-selector/index.js"(exports, module2) {
    "use strict";
    module2.exports = parse4;
    var search = /[#.]/g;
    function parse4(selector, defaultTagName) {
      var value = selector || "";
      var name = defaultTagName || "div";
      var props = {};
      var start2 = 0;
      var subvalue;
      var previous3;
      var match5;
      while (start2 < value.length) {
        search.lastIndex = start2;
        match5 = search.exec(value);
        subvalue = value.slice(start2, match5 ? match5.index : value.length);
        if (subvalue) {
          if (!previous3) {
            name = subvalue;
          } else if (previous3 === "#") {
            props.id = subvalue;
          } else if (props.className) {
            props.className.push(subvalue);
          } else {
            props.className = [subvalue];
          }
          start2 += subvalue.length;
        }
        if (match5) {
          previous3 = match5[0];
          start2++;
        }
      }
      return { type: "element", tagName: name, properties: props, children: [] };
    }
  }
});

// node_modules/space-separated-tokens/index.js
var require_space_separated_tokens = __commonJS({
  "node_modules/space-separated-tokens/index.js"(exports) {
    "use strict";
    exports.parse = parse4;
    exports.stringify = stringify3;
    var empty2 = "";
    var space = " ";
    var whiteSpace = /[ \t\n\r\f]+/g;
    function parse4(value) {
      var input = String(value || empty2).trim();
      return input === empty2 ? [] : input.split(whiteSpace);
    }
    function stringify3(values) {
      return values.join(space).trim();
    }
  }
});

// node_modules/comma-separated-tokens/index.js
var require_comma_separated_tokens = __commonJS({
  "node_modules/comma-separated-tokens/index.js"(exports) {
    "use strict";
    exports.parse = parse4;
    exports.stringify = stringify3;
    var comma2 = ",";
    var space = " ";
    var empty2 = "";
    function parse4(value) {
      var values = [];
      var input = String(value || empty2);
      var index3 = input.indexOf(comma2);
      var lastIndex = 0;
      var end2 = false;
      var val;
      while (!end2) {
        if (index3 === -1) {
          index3 = input.length;
          end2 = true;
        }
        val = input.slice(lastIndex, index3).trim();
        if (val || !end2) {
          values.push(val);
        }
        lastIndex = index3 + 1;
        index3 = input.indexOf(comma2, lastIndex);
      }
      return values;
    }
    function stringify3(values, options) {
      var settings = options || {};
      var left = settings.padLeft === false ? empty2 : space;
      var right = settings.padRight ? space : empty2;
      if (values[values.length - 1] === empty2) {
        values = values.concat(empty2);
      }
      return values.join(right + comma2 + left).trim();
    }
  }
});

// node_modules/hastscript/factory.js
var require_factory = __commonJS({
  "node_modules/hastscript/factory.js"(exports, module2) {
    "use strict";
    var find2 = require_find();
    var normalize4 = require_normalize();
    var parseSelector = require_hast_util_parse_selector();
    var spaces = require_space_separated_tokens().parse;
    var commas = require_comma_separated_tokens().parse;
    module2.exports = factory;
    var own = {}.hasOwnProperty;
    function factory(schema, defaultTagName, caseSensitive) {
      var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
      return h3;
      function h3(selector, properties2) {
        var node5 = parseSelector(selector, defaultTagName);
        var children = Array.prototype.slice.call(arguments, 2);
        var name = node5.tagName.toLowerCase();
        var property;
        node5.tagName = adjust && own.call(adjust, name) ? adjust[name] : name;
        if (properties2 && isChildren(properties2, node5)) {
          children.unshift(properties2);
          properties2 = null;
        }
        if (properties2) {
          for (property in properties2) {
            addProperty(node5.properties, property, properties2[property]);
          }
        }
        addChild(node5.children, children);
        if (node5.tagName === "template") {
          node5.content = { type: "root", children: node5.children };
          node5.children = [];
        }
        return node5;
      }
      function addProperty(properties2, key2, value) {
        var info;
        var property;
        var result;
        if (value === null || value === void 0 || value !== value) {
          return;
        }
        info = find2(schema, key2);
        property = info.property;
        result = value;
        if (typeof result === "string") {
          if (info.spaceSeparated) {
            result = spaces(result);
          } else if (info.commaSeparated) {
            result = commas(result);
          } else if (info.commaOrSpaceSeparated) {
            result = spaces(commas(result).join(" "));
          }
        }
        if (property === "style" && typeof value !== "string") {
          result = style(result);
        }
        if (property === "className" && properties2.className) {
          result = properties2.className.concat(result);
        }
        properties2[property] = parsePrimitives(info, property, result);
      }
    }
    function isChildren(value, node5) {
      return typeof value === "string" || "length" in value || isNode4(node5.tagName, value);
    }
    function isNode4(tagName, value) {
      var type = value.type;
      if (tagName === "input" || !type || typeof type !== "string") {
        return false;
      }
      if (typeof value.children === "object" && "length" in value.children) {
        return true;
      }
      type = type.toLowerCase();
      if (tagName === "button") {
        return type !== "menu" && type !== "submit" && type !== "reset" && type !== "button";
      }
      return "value" in value;
    }
    function addChild(nodes2, value) {
      var index3;
      var length2;
      if (typeof value === "string" || typeof value === "number") {
        nodes2.push({ type: "text", value: String(value) });
        return;
      }
      if (typeof value === "object" && "length" in value) {
        index3 = -1;
        length2 = value.length;
        while (++index3 < length2) {
          addChild(nodes2, value[index3]);
        }
        return;
      }
      if (typeof value !== "object" || !("type" in value)) {
        throw new Error("Expected node, nodes, or string, got `" + value + "`");
      }
      nodes2.push(value);
    }
    function parsePrimitives(info, name, value) {
      var index3;
      var length2;
      var result;
      if (typeof value !== "object" || !("length" in value)) {
        return parsePrimitive(info, name, value);
      }
      length2 = value.length;
      index3 = -1;
      result = [];
      while (++index3 < length2) {
        result[index3] = parsePrimitive(info, name, value[index3]);
      }
      return result;
    }
    function parsePrimitive(info, name, value) {
      var result = value;
      if (info.number || info.positiveNumber) {
        if (!isNaN(result) && result !== "") {
          result = Number(result);
        }
      } else if (info.boolean || info.overloadedBoolean) {
        if (typeof result === "string" && (result === "" || normalize4(value) === normalize4(name))) {
          result = true;
        }
      }
      return result;
    }
    function style(value) {
      var result = [];
      var key2;
      for (key2 in value) {
        result.push([key2, value[key2]].join(": "));
      }
      return result.join("; ");
    }
    function createAdjustMap(values) {
      var length2 = values.length;
      var index3 = -1;
      var result = {};
      var value;
      while (++index3 < length2) {
        value = values[index3];
        result[value.toLowerCase()] = value;
      }
      return result;
    }
  }
});

// node_modules/hastscript/html.js
var require_html3 = __commonJS({
  "node_modules/hastscript/html.js"(exports, module2) {
    "use strict";
    var schema = require_html2();
    var factory = require_factory();
    var html = factory(schema, "div");
    html.displayName = "html";
    module2.exports = html;
  }
});

// node_modules/hastscript/index.js
var require_hastscript = __commonJS({
  "node_modules/hastscript/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_html3();
  }
});

// node_modules/character-entities-legacy/index.json
var require_character_entities_legacy = __commonJS({
  "node_modules/character-entities-legacy/index.json"(exports, module2) {
    module2.exports = {
      AElig: "",
      AMP: "&",
      Aacute: "",
      Acirc: "",
      Agrave: "",
      Aring: "",
      Atilde: "",
      Auml: "",
      COPY: "",
      Ccedil: "",
      ETH: "",
      Eacute: "",
      Ecirc: "",
      Egrave: "",
      Euml: "",
      GT: ">",
      Iacute: "",
      Icirc: "",
      Igrave: "",
      Iuml: "",
      LT: "<",
      Ntilde: "",
      Oacute: "",
      Ocirc: "",
      Ograve: "",
      Oslash: "",
      Otilde: "",
      Ouml: "",
      QUOT: '"',
      REG: "",
      THORN: "",
      Uacute: "",
      Ucirc: "",
      Ugrave: "",
      Uuml: "",
      Yacute: "",
      aacute: "",
      acirc: "",
      acute: "",
      aelig: "",
      agrave: "",
      amp: "&",
      aring: "",
      atilde: "",
      auml: "",
      brvbar: "",
      ccedil: "",
      cedil: "",
      cent: "",
      copy: "",
      curren: "",
      deg: "",
      divide: "",
      eacute: "",
      ecirc: "",
      egrave: "",
      eth: "",
      euml: "",
      frac12: "",
      frac14: "",
      frac34: "",
      gt: ">",
      iacute: "",
      icirc: "",
      iexcl: "",
      igrave: "",
      iquest: "",
      iuml: "",
      laquo: "",
      lt: "<",
      macr: "",
      micro: "",
      middot: "",
      nbsp: "",
      not: "",
      ntilde: "",
      oacute: "",
      ocirc: "",
      ograve: "",
      ordf: "",
      ordm: "",
      oslash: "",
      otilde: "",
      ouml: "",
      para: "",
      plusmn: "",
      pound: "",
      quot: '"',
      raquo: "",
      reg: "",
      sect: "",
      shy: "",
      sup1: "",
      sup2: "",
      sup3: "",
      szlig: "",
      thorn: "",
      times: "",
      uacute: "",
      ucirc: "",
      ugrave: "",
      uml: "",
      uuml: "",
      yacute: "",
      yen: "",
      yuml: ""
    };
  }
});

// node_modules/character-reference-invalid/index.json
var require_character_reference_invalid = __commonJS({
  "node_modules/character-reference-invalid/index.json"(exports, module2) {
    module2.exports = {
      "0": "",
      "128": "",
      "130": "",
      "131": "",
      "132": "",
      "133": "",
      "134": "",
      "135": "",
      "136": "",
      "137": "",
      "138": "",
      "139": "",
      "140": "",
      "142": "",
      "145": "",
      "146": "",
      "147": "",
      "148": "",
      "149": "",
      "150": "",
      "151": "",
      "152": "",
      "153": "",
      "154": "",
      "155": "",
      "156": "",
      "158": "",
      "159": ""
    };
  }
});

// node_modules/is-decimal/index.js
var require_is_decimal = __commonJS({
  "node_modules/is-decimal/index.js"(exports, module2) {
    "use strict";
    module2.exports = decimal;
    function decimal(character2) {
      var code = typeof character2 === "string" ? character2.charCodeAt(0) : character2;
      return code >= 48 && code <= 57;
    }
  }
});

// node_modules/is-hexadecimal/index.js
var require_is_hexadecimal = __commonJS({
  "node_modules/is-hexadecimal/index.js"(exports, module2) {
    "use strict";
    module2.exports = hexadecimal;
    function hexadecimal(character2) {
      var code = typeof character2 === "string" ? character2.charCodeAt(0) : character2;
      return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
    }
  }
});

// node_modules/is-alphabetical/index.js
var require_is_alphabetical = __commonJS({
  "node_modules/is-alphabetical/index.js"(exports, module2) {
    "use strict";
    module2.exports = alphabetical;
    function alphabetical(character2) {
      var code = typeof character2 === "string" ? character2.charCodeAt(0) : character2;
      return code >= 97 && code <= 122 || code >= 65 && code <= 90;
    }
  }
});

// node_modules/is-alphanumerical/index.js
var require_is_alphanumerical = __commonJS({
  "node_modules/is-alphanumerical/index.js"(exports, module2) {
    "use strict";
    var alphabetical = require_is_alphabetical();
    var decimal = require_is_decimal();
    module2.exports = alphanumerical;
    function alphanumerical(character2) {
      return alphabetical(character2) || decimal(character2);
    }
  }
});

// node_modules/parse-entities/decode-entity.browser.js
var require_decode_entity_browser = __commonJS({
  "node_modules/parse-entities/decode-entity.browser.js"(exports, module2) {
    "use strict";
    var el;
    var semicolon = 59;
    module2.exports = decodeEntity;
    function decodeEntity(characters2) {
      var entity = "&" + characters2 + ";";
      var char2;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char2 = el.textContent;
      if (char2.charCodeAt(char2.length - 1) === semicolon && characters2 !== "semi") {
        return false;
      }
      return char2 === entity ? false : char2;
    }
  }
});

// node_modules/parse-entities/index.js
var require_parse_entities = __commonJS({
  "node_modules/parse-entities/index.js"(exports, module2) {
    "use strict";
    var legacy = require_character_entities_legacy();
    var invalid = require_character_reference_invalid();
    var decimal = require_is_decimal();
    var hexadecimal = require_is_hexadecimal();
    var alphanumerical = require_is_alphanumerical();
    var decodeEntity = require_decode_entity_browser();
    module2.exports = parseEntities;
    var own = {}.hasOwnProperty;
    var fromCharCode = String.fromCharCode;
    var noop3 = Function.prototype;
    var defaults2 = {
      warning: null,
      reference: null,
      text: null,
      warningContext: null,
      referenceContext: null,
      textContext: null,
      position: {},
      additional: null,
      attribute: false,
      nonTerminated: true
    };
    var tab = 9;
    var lineFeed = 10;
    var formFeed = 12;
    var space = 32;
    var ampersand = 38;
    var semicolon = 59;
    var lessThan = 60;
    var equalsTo = 61;
    var numberSign = 35;
    var uppercaseX = 88;
    var lowercaseX = 120;
    var replacementCharacter = 65533;
    var name = "named";
    var hexa = "hexadecimal";
    var deci = "decimal";
    var bases = {};
    bases[hexa] = 16;
    bases[deci] = 10;
    var tests = {};
    tests[name] = alphanumerical;
    tests[deci] = decimal;
    tests[hexa] = hexadecimal;
    var namedNotTerminated = 1;
    var numericNotTerminated = 2;
    var namedEmpty = 3;
    var numericEmpty = 4;
    var namedUnknown = 5;
    var numericDisallowed = 6;
    var numericProhibited = 7;
    var messages = {};
    messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
    messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
    messages[namedEmpty] = "Named character references cannot be empty";
    messages[numericEmpty] = "Numeric character references cannot be empty";
    messages[namedUnknown] = "Named character references must be known";
    messages[numericDisallowed] = "Numeric character references cannot be disallowed";
    messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
    function parseEntities(value, options) {
      var settings = {};
      var option;
      var key2;
      if (!options) {
        options = {};
      }
      for (key2 in defaults2) {
        option = options[key2];
        settings[key2] = option === null || option === void 0 ? defaults2[key2] : option;
      }
      if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
      }
      return parse4(value, settings);
    }
    function parse4(value, settings) {
      var additional = settings.additional;
      var nonTerminated = settings.nonTerminated;
      var handleText = settings.text;
      var handleReference = settings.reference;
      var handleWarning = settings.warning;
      var textContext = settings.textContext;
      var referenceContext = settings.referenceContext;
      var warningContext = settings.warningContext;
      var pos = settings.position;
      var indent = settings.indent || [];
      var length2 = value.length;
      var index3 = 0;
      var lines = -1;
      var column2 = pos.column || 1;
      var line2 = pos.line || 1;
      var queue2 = "";
      var result = [];
      var entityCharacters;
      var namedEntity;
      var terminated;
      var characters2;
      var character2;
      var reference;
      var following;
      var warning2;
      var reason;
      var output;
      var entity;
      var begin;
      var start2;
      var type;
      var test;
      var prev2;
      var next4;
      var diff2;
      var end2;
      if (typeof additional === "string") {
        additional = additional.charCodeAt(0);
      }
      prev2 = now2();
      warning2 = handleWarning ? parseError : noop3;
      index3--;
      length2++;
      while (++index3 < length2) {
        if (character2 === lineFeed) {
          column2 = indent[lines] || 1;
        }
        character2 = value.charCodeAt(index3);
        if (character2 === ampersand) {
          following = value.charCodeAt(index3 + 1);
          if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
            queue2 += fromCharCode(character2);
            column2++;
            continue;
          }
          start2 = index3 + 1;
          begin = start2;
          end2 = start2;
          if (following === numberSign) {
            end2 = ++begin;
            following = value.charCodeAt(end2);
            if (following === uppercaseX || following === lowercaseX) {
              type = hexa;
              end2 = ++begin;
            } else {
              type = deci;
            }
          } else {
            type = name;
          }
          entityCharacters = "";
          entity = "";
          characters2 = "";
          test = tests[type];
          end2--;
          while (++end2 < length2) {
            following = value.charCodeAt(end2);
            if (!test(following)) {
              break;
            }
            characters2 += fromCharCode(following);
            if (type === name && own.call(legacy, characters2)) {
              entityCharacters = characters2;
              entity = legacy[characters2];
            }
          }
          terminated = value.charCodeAt(end2) === semicolon;
          if (terminated) {
            end2++;
            namedEntity = type === name ? decodeEntity(characters2) : false;
            if (namedEntity) {
              entityCharacters = characters2;
              entity = namedEntity;
            }
          }
          diff2 = 1 + end2 - start2;
          if (!terminated && !nonTerminated) {
          } else if (!characters2) {
            if (type !== name) {
              warning2(numericEmpty, diff2);
            }
          } else if (type === name) {
            if (terminated && !entity) {
              warning2(namedUnknown, 1);
            } else {
              if (entityCharacters !== characters2) {
                end2 = begin + entityCharacters.length;
                diff2 = 1 + end2 - begin;
                terminated = false;
              }
              if (!terminated) {
                reason = entityCharacters ? namedNotTerminated : namedEmpty;
                if (settings.attribute) {
                  following = value.charCodeAt(end2);
                  if (following === equalsTo) {
                    warning2(reason, diff2);
                    entity = null;
                  } else if (alphanumerical(following)) {
                    entity = null;
                  } else {
                    warning2(reason, diff2);
                  }
                } else {
                  warning2(reason, diff2);
                }
              }
            }
            reference = entity;
          } else {
            if (!terminated) {
              warning2(numericNotTerminated, diff2);
            }
            reference = parseInt(characters2, bases[type]);
            if (prohibited(reference)) {
              warning2(numericProhibited, diff2);
              reference = fromCharCode(replacementCharacter);
            } else if (reference in invalid) {
              warning2(numericDisallowed, diff2);
              reference = invalid[reference];
            } else {
              output = "";
              if (disallowed(reference)) {
                warning2(numericDisallowed, diff2);
              }
              if (reference > 65535) {
                reference -= 65536;
                output += fromCharCode(reference >>> (10 & 1023) | 55296);
                reference = 56320 | reference & 1023;
              }
              reference = output + fromCharCode(reference);
            }
          }
          if (reference) {
            flush();
            prev2 = now2();
            index3 = end2 - 1;
            column2 += end2 - start2 + 1;
            result.push(reference);
            next4 = now2();
            next4.offset++;
            if (handleReference) {
              handleReference.call(
                referenceContext,
                reference,
                { start: prev2, end: next4 },
                value.slice(start2 - 1, end2)
              );
            }
            prev2 = next4;
          } else {
            characters2 = value.slice(start2 - 1, end2);
            queue2 += characters2;
            column2 += characters2.length;
            index3 = end2 - 1;
          }
        } else {
          if (character2 === 10) {
            line2++;
            lines++;
            column2 = 0;
          }
          if (character2 === character2) {
            queue2 += fromCharCode(character2);
            column2++;
          } else {
            flush();
          }
        }
      }
      return result.join("");
      function now2() {
        return {
          line: line2,
          column: column2,
          offset: index3 + (pos.offset || 0)
        };
      }
      function parseError(code, offset3) {
        var position3 = now2();
        position3.column += offset3;
        position3.offset += offset3;
        handleWarning.call(warningContext, messages[code], position3, code);
      }
      function flush() {
        if (queue2) {
          result.push(queue2);
          if (handleText) {
            handleText.call(textContext, queue2, { start: prev2, end: now2() });
          }
          queue2 = "";
        }
      }
    }
    function prohibited(code) {
      return code >= 55296 && code <= 57343 || code > 1114111;
    }
    function disallowed(code) {
      return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
    }
  }
});

// node_modules/prismjs/components/prism-core.js
var require_prism_core = __commonJS({
  "node_modules/prismjs/components/prism-core.js"(exports, module2) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism = function(_self2) {
      var lang2 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens2) {
            if (tokens2 instanceof Token) {
              return new Token(tokens2.type, encode(tokens2.content), tokens2.alias);
            } else if (Array.isArray(tokens2)) {
              return tokens2.map(encode);
            } else {
              return tokens2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o4) {
            return Object.prototype.toString.call(o4).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o4, visited) {
            visited = visited || {};
            var clone2;
            var id2;
            switch (_2.util.type(o4)) {
              case "Object":
                id2 = _2.util.objId(o4);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone2 = /** @type {Record<string, any>} */
                {};
                visited[id2] = clone2;
                for (var key2 in o4) {
                  if (o4.hasOwnProperty(key2)) {
                    clone2[key2] = deepClone(o4[key2], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone2
                );
              case "Array":
                id2 = _2.util.objId(o4);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone2 = [];
                visited[id2] = clone2;
                /** @type {Array} */
                /** @type {any} */
                o4.forEach(function(v2, i4) {
                  clone2[i4] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone2
                );
              default:
                return o4;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m4 = lang2.exec(element.className);
              if (m4) {
                return m4[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang2, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i4 in scripts) {
                  if (scripts[i4].src == src) {
                    return scripts[i4];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id2, redef) {
            var lang3 = _2.util.clone(_2.languages[id2]);
            for (var key2 in redef) {
              lang3[key2] = redef[key2];
            }
            return lang3;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before3, insert, root) {
            root = root || /** @type {any} */
            _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token3 in grammar) {
              if (grammar.hasOwnProperty(token3)) {
                if (token3 == before3) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token3)) {
                  ret[token3] = grammar[token3];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key2, value) {
              if (value === old && key2 != inside) {
                this[key2] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o4, callback, type, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i4 in o4) {
              if (o4.hasOwnProperty(i4)) {
                callback.call(o4, i4, o4[i4], type || i4);
                var property = o4[i4];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i4, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prisms API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async2, callback) {
          _2.highlightAllUnder(document, async2, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async2, callback) {
          var env2 = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env2);
          env2.elements = Array.prototype.slice.apply(env2.container.querySelectorAll(env2.selector));
          _2.hooks.run("before-all-elements-highlight", env2);
          for (var i4 = 0, element; element = env2.elements[i4++]; ) {
            _2.highlightElement(element, async2 === true, env2.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async2, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent3 = element.parentElement;
          if (parent3 && parent3.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent3, language);
          }
          var code = element.textContent;
          var env2 = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env2.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env2);
            env2.element.innerHTML = env2.highlightedCode;
            _2.hooks.run("after-highlight", env2);
            _2.hooks.run("complete", env2);
            callback && callback.call(env2.element);
          }
          _2.hooks.run("before-sanity-check", env2);
          parent3 = env2.element.parentElement;
          if (parent3 && parent3.nodeName.toLowerCase() === "pre" && !parent3.hasAttribute("tabindex")) {
            parent3.setAttribute("tabindex", "0");
          }
          if (!env2.code) {
            _2.hooks.run("complete", env2);
            callback && callback.call(env2.element);
            return;
          }
          _2.hooks.run("before-highlight", env2);
          if (!env2.grammar) {
            insertHighlightedCode(_2.util.encode(env2.code));
            return;
          }
          if (async2 && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env2.language,
              code: env2.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env2.code, env2.grammar, env2.language));
          }
        },
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env2 = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env2);
          if (!env2.grammar) {
            throw new Error('The language "' + env2.language + '" has no grammar.');
          }
          env2.tokens = _2.tokenize(env2.code, env2.grammar);
          _2.hooks.run("after-tokenize", env2);
          return Token.stringify(_2.util.encode(env2.tokens), env2.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token3 in rest) {
              grammar[token3] = rest[token3];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray4(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks2 = _2.hooks.all;
            hooks2[name] = hooks2[name] || [];
            hooks2[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env2) {
            var callbacks2 = _2.hooks.all[name];
            if (!callbacks2 || !callbacks2.length) {
              return;
            }
            for (var i4 = 0, callback; callback = callbacks2[i4++]; ) {
              callback(env2);
            }
          }
        },
        Token
      };
      _self2.Prism = _2;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify3(o4, language) {
        if (typeof o4 == "string") {
          return o4;
        }
        if (Array.isArray(o4)) {
          var s5 = "";
          o4.forEach(function(e5) {
            s5 += stringify3(e5, language);
          });
          return s5;
        }
        var env2 = {
          type: o4.type,
          content: stringify3(o4.content, language),
          tag: "span",
          classes: ["token", o4.type],
          attributes: {},
          language
        };
        var aliases2 = o4.alias;
        if (aliases2) {
          if (Array.isArray(aliases2)) {
            Array.prototype.push.apply(env2.classes, aliases2);
          } else {
            env2.classes.push(aliases2);
          }
        }
        _2.hooks.run("wrap", env2);
        var attributes = "";
        for (var name in env2.attributes) {
          attributes += " " + name + '="' + (env2.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes + ">" + env2.content + "</" + env2.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match5 = pattern.exec(text);
        if (match5 && lookbehind && match5[1]) {
          var lookbehindLength = match5[1].length;
          match5.index += lookbehindLength;
          match5[0] = match5[0].slice(lookbehindLength);
        }
        return match5;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token3 in grammar) {
          if (!grammar.hasOwnProperty(token3) || !grammar[token3]) {
            continue;
          }
          var patterns2 = grammar[token3];
          patterns2 = Array.isArray(patterns2) ? patterns2 : [patterns2];
          for (var j2 = 0; j2 < patterns2.length; ++j2) {
            if (rematch && rematch.cause == token3 + "," + j2) {
              return;
            }
            var patternObj = patterns2[j2];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match5;
              if (greedy) {
                match5 = matchPattern(pattern, pos, text, lookbehind);
                if (!match5 || match5.index >= text.length) {
                  break;
                }
                var from4 = match5.index;
                var to2 = match5.index + match5[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from4 >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k3 = currentNode; k3 !== tokenList.tail && (p2 < to2 || typeof k3.value === "string"); k3 = k3.next) {
                  removeCount++;
                  p2 += k3.value.length;
                }
                removeCount--;
                str = text.slice(pos, p2);
                match5.index -= pos;
              } else {
                match5 = matchPattern(pattern, 0, str, lookbehind);
                if (!match5) {
                  continue;
                }
              }
              var from4 = match5.index;
              var matchStr = match5[0];
              var before3 = str.slice(0, from4);
              var after3 = str.slice(from4 + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before3) {
                removeFrom = addAfter(tokenList, removeFrom, before3);
                pos += before3.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token3, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after3) {
                addAfter(tokenList, currentNode, after3);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token3 + "," + j2,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node5, value) {
        var next4 = node5.next;
        var newNode = { value, prev: node5, next: next4 };
        node5.next = newNode;
        next4.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node5, count2) {
        var next4 = node5.next;
        for (var i4 = 0; i4 < count2 && next4 !== list.tail; i4++) {
          next4 = next4.next;
        }
        node5.next = next4;
        next4.prev = node5;
        list.length -= i4;
      }
      function toArray4(list) {
        var array = [];
        var node5 = list.head.next;
        while (node5 !== list.tail) {
          array.push(node5.value);
          node5 = node5.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang3 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code, _2.languages[lang3], lang3));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    }(_self);
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = Prism;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism;
    }
  }
});

// node_modules/refractor/lang/markup.js
var require_markup = __commonJS({
  "node_modules/refractor/lang/markup.js"(exports, module2) {
    "use strict";
    module2.exports = markup;
    markup.displayName = "markup";
    markup.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
    function markup(Prism) {
      Prism.languages.markup = {
        comment: {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        prolog: {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        doctype: {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            string: {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
          }
        },
        cdata: {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        tag: {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            tag: {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                punctuation: /^<\/?/,
                namespace: /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            },
            punctuation: /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                namespace: /^[^\s>\/:]+:/
              }
            }
          }
        },
        entity: [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
      Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
      Prism.hooks.add("wrap", function(env2) {
        if (env2.type === "entity") {
          env2.attributes["title"] = env2.content.value.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang2) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang2] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism.languages[lang2]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang2] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang2]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(
              /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
                /__/g,
                function() {
                  return tagName;
                }
              ),
              "i"
            ),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism.languages.insertBefore("markup", "cdata", def);
        }
      });
      Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function(attrName, lang2) {
          Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  value: {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang2, "language-" + lang2],
                    inside: Prism.languages[lang2]
                  },
                  punctuation: [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism.languages.html = Prism.languages.markup;
      Prism.languages.mathml = Prism.languages.markup;
      Prism.languages.svg = Prism.languages.markup;
      Prism.languages.xml = Prism.languages.extend("markup", {});
      Prism.languages.ssml = Prism.languages.xml;
      Prism.languages.atom = Prism.languages.xml;
      Prism.languages.rss = Prism.languages.xml;
    }
  }
});

// node_modules/refractor/lang/css.js
var require_css = __commonJS({
  "node_modules/refractor/lang/css.js"(exports, module2) {
    "use strict";
    module2.exports = css;
    css.displayName = "css";
    css.aliases = [];
    function css(Prism) {
      ;
      (function(Prism2) {
        var string4 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism2.languages.css = {
          comment: /\/\*[\s\S]*?\*\//,
          atrule: {
            pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
            inside: {
              rule: /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          url: {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp(
              "\\burl\\((?:" + string4.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
              "i"
            ),
            greedy: true,
            inside: {
              function: /^url/i,
              punctuation: /^\(|\)$/,
              string: {
                pattern: RegExp("^" + string4.source + "$"),
                alias: "url"
              }
            }
          },
          selector: {
            pattern: RegExp(
              `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string4.source + ")*(?=\\s*\\{)"
            ),
            lookbehind: true
          },
          string: {
            pattern: string4,
            greedy: true
          },
          property: {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          important: /!important\b/i,
          function: {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          punctuation: /[(){};:,]/
        };
        Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
        var markup = Prism2.languages.markup;
        if (markup) {
          markup.tag.addInlined("style", "css");
          markup.tag.addAttribute("style", "css");
        }
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/clike.js
var require_clike = __commonJS({
  "node_modules/refractor/lang/clike.js"(exports, module2) {
    "use strict";
    module2.exports = clike;
    clike.displayName = "clike";
    clike.aliases = [];
    function clike(Prism) {
      Prism.languages.clike = {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b\w+(?=\()/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        punctuation: /[{}[\];(),.:]/
      };
    }
  }
});

// node_modules/refractor/core.js
var require_core = __commonJS({
  "node_modules/refractor/core.js"(exports, module2) {
    "use strict";
    var ctx = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
    var restore = capture();
    ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
    var h3 = require_hastscript();
    var decode = require_parse_entities();
    var Prism = require_prism_core();
    var markup = require_markup();
    var css = require_css();
    var clike = require_clike();
    var js = require_javascript();
    restore();
    var own = {}.hasOwnProperty;
    function Refractor() {
    }
    Refractor.prototype = Prism;
    var refract = new Refractor();
    module2.exports = refract;
    refract.highlight = highlight;
    refract.register = register;
    refract.alias = alias;
    refract.registered = registered;
    refract.listLanguages = listLanguages;
    register(markup);
    register(css);
    register(clike);
    register(js);
    refract.util.encode = encode;
    refract.Token.stringify = stringify3;
    function register(grammar) {
      if (typeof grammar !== "function" || !grammar.displayName) {
        throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
      }
      if (refract.languages[grammar.displayName] === void 0) {
        grammar(refract);
      }
    }
    function alias(name, alias2) {
      var languages = refract.languages;
      var map3 = name;
      var key2;
      var list;
      var length2;
      var index3;
      if (alias2) {
        map3 = {};
        map3[name] = alias2;
      }
      for (key2 in map3) {
        list = map3[key2];
        list = typeof list === "string" ? [list] : list;
        length2 = list.length;
        index3 = -1;
        while (++index3 < length2) {
          languages[list[index3]] = languages[key2];
        }
      }
    }
    function highlight(value, name) {
      var sup = Prism.highlight;
      var grammar;
      if (typeof value !== "string") {
        throw new Error("Expected `string` for `value`, got `" + value + "`");
      }
      if (refract.util.type(name) === "Object") {
        grammar = name;
        name = null;
      } else {
        if (typeof name !== "string") {
          throw new Error("Expected `string` for `name`, got `" + name + "`");
        }
        if (own.call(refract.languages, name)) {
          grammar = refract.languages[name];
        } else {
          throw new Error("Unknown language: `" + name + "` is not registered");
        }
      }
      return sup.call(this, value, grammar, name);
    }
    function registered(language) {
      if (typeof language !== "string") {
        throw new Error("Expected `string` for `language`, got `" + language + "`");
      }
      return own.call(refract.languages, language);
    }
    function listLanguages() {
      var languages = refract.languages;
      var list = [];
      var language;
      for (language in languages) {
        if (own.call(languages, language) && typeof languages[language] === "object") {
          list.push(language);
        }
      }
      return list;
    }
    function stringify3(value, language, parent3) {
      var env2;
      if (typeof value === "string") {
        return { type: "text", value };
      }
      if (refract.util.type(value) === "Array") {
        return stringifyAll(value, language);
      }
      env2 = {
        type: value.type,
        content: refract.Token.stringify(value.content, language, parent3),
        tag: "span",
        classes: ["token", value.type],
        attributes: {},
        language,
        parent: parent3
      };
      if (value.alias) {
        env2.classes = env2.classes.concat(value.alias);
      }
      refract.hooks.run("wrap", env2);
      return h3(
        env2.tag + "." + env2.classes.join("."),
        attributes(env2.attributes),
        env2.content
      );
    }
    function stringifyAll(values, language) {
      var result = [];
      var length2 = values.length;
      var index3 = -1;
      var value;
      while (++index3 < length2) {
        value = values[index3];
        if (value !== "" && value !== null && value !== void 0) {
          result.push(value);
        }
      }
      index3 = -1;
      length2 = result.length;
      while (++index3 < length2) {
        value = result[index3];
        result[index3] = refract.Token.stringify(value, language, result);
      }
      return result;
    }
    function encode(tokens2) {
      return tokens2;
    }
    function attributes(attrs) {
      var key2;
      for (key2 in attrs) {
        attrs[key2] = decode(attrs[key2]);
      }
      return attrs;
    }
    function capture() {
      var defined = "Prism" in ctx;
      var current2 = defined ? ctx.Prism : void 0;
      return restore2;
      function restore2() {
        if (defined) {
          ctx.Prism = current2;
        } else {
          delete ctx.Prism;
        }
        defined = void 0;
        current2 = void 0;
      }
    }
  }
});

// node_modules/react-refractor/lib/mapChildren.js
var require_mapChildren = __commonJS({
  "node_modules/react-refractor/lib/mapChildren.js"(exports) {
    "use strict";
    var React18 = require_react();
    function mapChild(child, i4, depth) {
      if (child.tagName) {
        var className = child.properties && Array.isArray(child.properties.className) ? child.properties.className.join(" ") : child.properties.className;
        return React18.createElement(child.tagName, Object.assign({
          key: "fract-".concat(depth, "-").concat(i4)
        }, child.properties, {
          className
        }), child.children && child.children.map(mapWithDepth(depth + 1)));
      }
      return child.value;
    }
    function mapWithDepth(depth) {
      return function mapChildrenWithDepth(child, i4) {
        return mapChild(child, i4, depth);
      };
    }
    exports.depth = mapWithDepth;
  }
});

// node_modules/unist-util-is/convert.js
var require_convert = __commonJS({
  "node_modules/unist-util-is/convert.js"(exports, module2) {
    "use strict";
    module2.exports = convert;
    function convert(test) {
      if (test == null) {
        return ok;
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (typeof test === "object") {
        return "length" in test ? anyFactory(test) : allFactory(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function allFactory(test) {
      return all;
      function all(node5) {
        var key2;
        for (key2 in test) {
          if (node5[key2] !== test[key2])
            return false;
        }
        return true;
      }
    }
    function anyFactory(tests) {
      var checks = [];
      var index3 = -1;
      while (++index3 < tests.length) {
        checks[index3] = convert(tests[index3]);
      }
      return any2;
      function any2() {
        var index4 = -1;
        while (++index4 < checks.length) {
          if (checks[index4].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory(test) {
      return type;
      function type(node5) {
        return Boolean(node5 && node5.type === test);
      }
    }
    function ok() {
      return true;
    }
  }
});

// node_modules/unist-util-filter/index.js
var require_unist_util_filter = __commonJS({
  "node_modules/unist-util-filter/index.js"(exports, module2) {
    "use strict";
    var convert = require_convert();
    module2.exports = filter3;
    var own = {}.hasOwnProperty;
    function filter3(tree, options, test) {
      var is2 = convert(test || options);
      var cascade = options.cascade == null ? true : options.cascade;
      return preorder(tree, null, null);
      function preorder(node5, index3, parent3) {
        var children;
        var childIndex;
        var result;
        var next4;
        var key2;
        if (!is2(node5, index3, parent3))
          return null;
        if (node5.children) {
          children = [];
          childIndex = -1;
          while (++childIndex < node5.children.length) {
            result = preorder(node5.children[childIndex], childIndex, node5);
            if (result) {
              children.push(result);
            }
          }
          if (cascade && node5.children.length && !children.length)
            return null;
        }
        next4 = {};
        for (key2 in node5) {
          if (own.call(node5, key2)) {
            next4[key2] = key2 === "children" ? children : node5[key2];
          }
        }
        return next4;
      }
    }
  }
});

// node_modules/unist-util-visit-parents/color.browser.js
var require_color_browser = __commonJS({
  "node_modules/unist-util-visit-parents/color.browser.js"(exports, module2) {
    module2.exports = identity2;
    function identity2(d3) {
      return d3;
    }
  }
});

// node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents = __commonJS({
  "node_modules/unist-util-visit-parents/index.js"(exports, module2) {
    "use strict";
    module2.exports = visitParents;
    var convert = require_convert();
    var color = require_color_browser();
    var CONTINUE = true;
    var SKIP = "skip";
    var EXIT = false;
    visitParents.CONTINUE = CONTINUE;
    visitParents.SKIP = SKIP;
    visitParents.EXIT = EXIT;
    function visitParents(tree, test, visitor, reverse) {
      var step;
      var is2;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      is2 = convert(test);
      step = reverse ? -1 : 1;
      factory(tree, null, [])();
      function factory(node5, index3, parents) {
        var value = typeof node5 === "object" && node5 !== null ? node5 : {};
        var name;
        if (typeof value.type === "string") {
          name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
          visit.displayName = "node (" + color(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit;
        function visit() {
          var grandparents = parents.concat(node5);
          var result = [];
          var subresult;
          var offset3;
          if (!test || is2(node5, index3, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node5, parents));
            if (result[0] === EXIT) {
              return result;
            }
          }
          if (node5.children && result[0] !== SKIP) {
            offset3 = (reverse ? node5.children.length : -1) + step;
            while (offset3 > -1 && offset3 < node5.children.length) {
              subresult = factory(node5.children[offset3], offset3, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset3 = typeof subresult[1] === "number" ? subresult[1] : offset3 + step;
            }
          }
          return result;
        }
      }
    }
    function toResult(value) {
      if (value !== null && typeof value === "object" && "length" in value) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE, value];
      }
      return [value];
    }
  }
});

// node_modules/react-refractor/lib/map.js
var require_map = __commonJS({
  "node_modules/react-refractor/lib/map.js"(exports, module2) {
    "use strict";
    module2.exports = typeof WeakMap === "function" ? HappyMap : SadMap;
    function HappyMap() {
      this.map = /* @__PURE__ */ new WeakMap();
    }
    HappyMap.prototype.has = function(key2) {
      return this.map.has(key2);
    };
    HappyMap.prototype.set = function(key2, value) {
      this.map.set(key2, value);
      return this;
    };
    HappyMap.prototype.get = function(key2) {
      return this.map.get(key2);
    };
    HappyMap.prototype.clear = function() {
    };
    function SadMap() {
      this.keys = [];
      this.values = [];
    }
    SadMap.prototype.has = function(key2) {
      return this.keys.indexOf(key2) !== -1;
    };
    SadMap.prototype.set = function(key2, value) {
      var index3 = this.keys.indexOf(key2);
      if (index3 === -1) {
        this.keys.push(key2);
        this.values.push(value);
      } else {
        this.values[index3] = value;
      }
      return this;
    };
    SadMap.prototype.get = function(key2) {
      var index3 = this.keys.indexOf(key2);
      return index3 === -1 ? void 0 : this.values[index3];
    };
    SadMap.prototype.clear = function() {
      this.keys = [];
      this.values = [];
    };
  }
});

// node_modules/react-refractor/lib/addMarkers.js
var require_addMarkers = __commonJS({
  "node_modules/react-refractor/lib/addMarkers.js"(exports, module2) {
    "use strict";
    var filter3 = require_unist_util_filter();
    var visit = require_unist_util_visit_parents();
    var NodeMap = require_map();
    function lineNumberify(ast) {
      var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        lineNumber: 1
      };
      return ast.reduce(function(result, node5) {
        var lineStart = context2.lineNumber;
        if (node5.type === "text") {
          if (node5.value.indexOf("\n") === -1) {
            node5.lineStart = lineStart;
            node5.lineEnd = lineStart;
            result.nodes.push(node5);
            return result;
          }
          var lines = node5.value.split("\n");
          for (var i4 = 0; i4 < lines.length; i4++) {
            var lineNum = i4 === 0 ? context2.lineNumber : ++context2.lineNumber;
            result.nodes.push({
              type: "text",
              value: i4 === lines.length - 1 ? lines[i4] : "".concat(lines[i4], "\n"),
              lineStart: lineNum,
              lineEnd: lineNum
            });
          }
          result.lineNumber = context2.lineNumber;
          return result;
        }
        if (node5.children) {
          var processed = lineNumberify(node5.children, context2);
          var firstChild = processed.nodes[0];
          var lastChild = processed.nodes[processed.nodes.length - 1];
          node5.lineStart = firstChild ? firstChild.lineStart : lineStart;
          node5.lineEnd = lastChild ? lastChild.lineEnd : lineStart;
          node5.children = processed.nodes;
          result.lineNumber = processed.lineNumber;
          result.nodes.push(node5);
          return result;
        }
        result.nodes.push(node5);
        return result;
      }, {
        nodes: [],
        lineNumber: context2.lineNumber
      });
    }
    function unwrapLine(markerLine, nodes2) {
      var tree = {
        type: "root",
        children: nodes2
      };
      var headMap = new NodeMap();
      var lineMap = new NodeMap();
      var tailMap = new NodeMap();
      var cloned = [];
      function addCopy(map3, node5, ancestors) {
        cloned.push(node5);
        ancestors.forEach(function(ancestor2) {
          if (!map3.has(ancestor2)) {
            map3.set(ancestor2, Object.assign({}, ancestor2, {
              children: []
            }));
            if (ancestor2 !== tree) {
              cloned.push(ancestor2);
            }
          }
        });
        var i4 = ancestors.length;
        while (i4--) {
          var ancestor = map3.get(ancestors[i4]);
          var child = ancestors[i4 + 1];
          var leaf3 = map3.get(child) || node5;
          if (ancestor.children.indexOf(leaf3) === -1) {
            ancestor.children.push(leaf3);
          }
        }
      }
      visit(tree, function(node5, ancestors) {
        if (node5.children) {
          return;
        }
        if (node5.lineStart < markerLine) {
          addCopy(headMap, node5, ancestors);
          return;
        }
        if (node5.lineStart === markerLine) {
          addCopy(lineMap, node5, ancestors);
          return;
        }
        if (node5.lineEnd > markerLine && cloned.some(function(clone2) {
          return ancestors.indexOf(clone2) !== -1;
        })) {
          addCopy(tailMap, node5, ancestors);
        }
      });
      var filtered = filter3(tree, function(node5) {
        return cloned.indexOf(node5) === -1;
      });
      var getChildren2 = function getChildren3(map3) {
        var rootNode = map3.get(tree);
        if (!rootNode) {
          return [];
        }
        visit(rootNode, function(leaf3, ancestors) {
          if (leaf3.children) {
            leaf3.lineStart = 0;
            leaf3.lineEnd = 0;
            return;
          }
          ancestors.forEach(function(ancestor) {
            ancestor.lineStart = Math.max(ancestor.lineStart, leaf3.lineStart);
            ancestor.lineEnd = Math.max(ancestor.lineEnd, leaf3.lineEnd);
          });
        });
        return rootNode.children;
      };
      var merged = [].concat(getChildren2(headMap), getChildren2(lineMap), getChildren2(tailMap), filtered ? filtered.children : []);
      headMap.clear();
      lineMap.clear();
      tailMap.clear();
      return merged;
    }
    function wrapBatch(children, marker, options) {
      var className = marker.className || "refractor-marker";
      return {
        type: "element",
        tagName: marker.component || "div",
        properties: marker.component ? Object.assign({}, options, {
          className
        }) : {
          className
        },
        children,
        lineStart: marker.line,
        lineEnd: children[children.length - 1].lineEnd,
        isMarker: true
      };
    }
    function wrapLines(treeNodes, markers, options) {
      if (markers.length === 0 || treeNodes.length === 0) {
        return treeNodes;
      }
      var ast = markers.reduce(function(acc, marker2) {
        return unwrapLine(marker2.line, acc);
      }, treeNodes);
      var wrapped = [];
      var astIndex = 0;
      for (var m4 = 0; m4 < markers.length; m4++) {
        var marker = markers[m4];
        for (var node5 = ast[astIndex]; node5 && node5.lineEnd < marker.line; node5 = ast[++astIndex]) {
          wrapped.push(node5);
        }
        var batch = [];
        for (var _node = ast[astIndex]; _node && _node.lineEnd === marker.line; _node = ast[++astIndex]) {
          batch.push(_node);
        }
        if (batch.length > 0) {
          wrapped.push(wrapBatch(batch, marker, options));
        }
      }
      while (astIndex < ast.length) {
        wrapped.push(ast[astIndex++]);
      }
      return wrapped;
    }
    function addMarkers(ast, options) {
      var markers = options.markers.map(function(marker) {
        return marker.line ? marker : {
          line: marker
        };
      }).sort(function(nodeA, nodeB) {
        return nodeA.line - nodeB.line;
      });
      var numbered = lineNumberify(ast).nodes;
      return wrapLines(numbered, markers, options);
    }
    module2.exports = addMarkers;
  }
});

// node_modules/react-refractor/lib/Refractor.js
var require_Refractor = __commonJS({
  "node_modules/react-refractor/lib/Refractor.js"(exports, module2) {
    "use strict";
    var React18 = require_react();
    var PropTypes6 = require_prop_types();
    var fract = require_core();
    var mapChildren = require_mapChildren();
    var addMarkers = require_addMarkers();
    var h3 = React18.createElement;
    function Refractor(props) {
      if (true) {
        if (!fract.registered(props.language)) {
          console.warn('No language definitions for "'.concat(props.language, '" seems to be registered, did you forget to call `Refractor.registerLanguage()`?'));
        }
      }
      var langClassName = "language-".concat(props.language);
      var codeProps = {
        className: langClassName
      };
      var preProps = {
        className: [props.className, langClassName].filter(Boolean).join(" ")
      };
      if (props.inline) {
        codeProps.style = {
          display: "inline"
        };
        codeProps.className = props.className;
      }
      var ast = fract.highlight(props.value, props.language);
      if (props.markers && props.markers.length > 0) {
        ast = addMarkers(ast, {
          markers: props.markers
        });
      }
      var value = ast.length === 0 ? props.value : ast.map(mapChildren.depth(0));
      var code = h3("code", codeProps, value);
      return props.inline ? code : h3("pre", preProps, code);
    }
    Refractor.propTypes = {
      className: PropTypes6.string,
      inline: PropTypes6.bool,
      language: PropTypes6.string.isRequired,
      value: PropTypes6.string.isRequired,
      markers: PropTypes6.arrayOf(PropTypes6.oneOfType([PropTypes6.number, PropTypes6.shape({
        line: PropTypes6.number.isRequired,
        className: PropTypes6.string,
        component: PropTypes6.oneOfType([PropTypes6.node, PropTypes6.func])
      })]))
    };
    Refractor.defaultProps = {
      className: "refractor",
      inline: false
    };
    Refractor.registerLanguage = function(lang2) {
      return fract.register(lang2);
    };
    Refractor.hasLanguage = function(lang2) {
      return fract.registered(lang2);
    };
    module2.exports = Refractor;
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isFunction.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var init_createErrorClass = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js"() {
    init_createErrorClass();
    UnsubscriptionError = createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors2) {
        _super(this);
        this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i4) {
          return i4 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors2;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index3 = arr.indexOf(item);
    0 <= index3 && arr.splice(index3, 1);
  }
}
var init_arrRemove = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/arrRemove.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/Subscription.js
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var Subscription, EMPTY_SUBSCRIPTION;
var init_Subscription = __esm({
  "node_modules/rxjs/dist/esm5/internal/Subscription.js"() {
    init_tslib_es6();
    init_isFunction();
    init_UnsubscriptionError();
    init_arrRemove();
    Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors2;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e5) {
              errors2 = e5 instanceof UnsubscriptionError ? e5.errors : [e5];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
                  if (err instanceof UnsubscriptionError) {
                    errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
                  } else {
                    errors2.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors2) {
            throw new UnsubscriptionError(errors2);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent3) {
        var _parentage = this._parentage;
        return _parentage === parent3 || Array.isArray(_parentage) && _parentage.includes(parent3);
      };
      Subscription2.prototype._addParent = function(parent3) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent3), _parentage) : _parentage ? [_parentage, parent3] : parent3;
      };
      Subscription2.prototype._removeParent = function(parent3) {
        var _parentage = this._parentage;
        if (_parentage === parent3) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent3);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty2 = new Subscription2();
        empty2.closed = true;
        return empty2;
      }();
      return Subscription2;
    }();
    EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  }
});

// node_modules/rxjs/dist/esm5/internal/config.js
var config;
var init_config = __esm({
  "node_modules/rxjs/dist/esm5/internal/config.js"() {
    config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider;
var init_timeoutProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js"() {
    init_tslib_es6();
    timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
var init_reportUnhandledError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js"() {
    init_config();
    init_timeoutProvider();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/noop.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
var COMPLETE_NOTIFICATION;
var init_NotificationFactories = __esm({
  "node_modules/rxjs/dist/esm5/internal/NotificationFactories.js"() {
    COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
var context;
var init_errorContext = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/errorContext.js"() {
    init_config();
    context = null;
  }
});

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER;
var init_Subscriber = __esm({
  "node_modules/rxjs/dist/esm5/internal/Subscriber.js"() {
    init_tslib_es6();
    init_isFunction();
    init_Subscription();
    init_config();
    init_reportUnhandledError();
    init_noop();
    init_NotificationFactories();
    init_timeoutProvider();
    init_errorContext();
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next4, error, complete) {
        return new SafeSubscriber(next4, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription);
    _bind = Function.prototype.bind;
    ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/dist/esm5/internal/symbol/observable.js"() {
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x3) {
  return x3;
}
var init_identity = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/identity.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn) {
      return fn(prev2);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/pipe.js"() {
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/dist/esm5/internal/Observable.js"() {
    init_Subscriber();
    init_Subscription();
    init_observable();
    init_pipe();
    init_config();
    init_isFunction();
    init_errorContext();
    Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next4, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new SafeSubscriber({
            next: function(value) {
              try {
                next4(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x3) {
            return value = x3;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
var init_lift = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/lift.js"() {
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber;
var init_OperatorSubscriber = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber3, _super);
      function OperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber3.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
var init_refCount = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/refCount.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js"() {
    init_createErrorClass();
    ObjectUnsubscribedError = createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/dist/esm5/internal/Subject.js"() {
    init_tslib_es6();
    init_Observable();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_arrRemove();
    init_errorContext();
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription(function() {
          _this.currentObservers = null;
          arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"() {
    init_tslib_es6();
    init_Subject();
    BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider;
var init_dateTimestampProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js"() {
    dateTimestampProvider = {
      now: function() {
        return (dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/dist/esm5/internal/ReplaySubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_dateTimestampProvider();
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy2 = _buffer.slice();
        for (var i4 = 0; i4 < copy2.length && !subscriber.closed; i4 += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy2[i4]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now2 = _timestampProvider.now();
          var last5 = 0;
          for (var i4 = 1; i4 < _buffer.length && _buffer[i4] <= now2; i4 += 2) {
            last5 = i4;
          }
          last5 && _buffer.splice(0, last5 + 1);
        }
      };
      return ReplaySubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/Action.js"() {
    init_tslib_es6();
    init_Subscription();
    Action = function(_super) {
      __extends(Action4, _super);
      function Action4(scheduler2, work) {
        return _super.call(this) || this;
      }
      Action4.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action4;
    }(Subscription);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider;
var init_intervalProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js"() {
    init_tslib_es6();
    intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js"() {
    init_tslib_es6();
    init_Action();
    init_intervalProvider();
    init_arrRemove();
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler2, work) {
        var _this = _super.call(this, scheduler2, work) || this;
        _this.scheduler = scheduler2;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        var _a;
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id2 = this.id;
        var scheduler2 = this.scheduler;
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler2, id2, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler2, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler2, _id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return intervalProvider.setInterval(scheduler2.flush.bind(scheduler2, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && this.delay === delay2 && this.pending === false) {
          return id2;
        }
        if (id2 != null) {
          intervalProvider.clearInterval(id2);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay2);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e5) {
          errored = true;
          errorValue = e5 ? e5 : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id2 = _a.id, scheduler2 = _a.scheduler;
          var actions = scheduler2.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove(actions, this);
          if (id2 != null) {
            this.id = this.recycleAsyncId(scheduler2, id2, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/Scheduler.js"() {
    init_dateTimestampProvider();
    Scheduler = function() {
      function Scheduler3(schedulerActionCtor, now2) {
        if (now2 === void 0) {
          now2 = Scheduler3.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now2;
      }
      Scheduler3.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay2);
      };
      Scheduler3.now = dateTimestampProvider.now;
      return Scheduler3;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js"() {
    init_tslib_es6();
    init_Scheduler();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now2) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/async.js"() {
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
function empty(scheduler2) {
  return scheduler2 ? emptyScheduled(scheduler2) : EMPTY;
}
function emptyScheduled(scheduler2) {
  return new Observable(function(subscriber) {
    return scheduler2.schedule(function() {
      return subscriber.complete();
    });
  });
}
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/empty.js"() {
    init_Observable();
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js"() {
    isArrayLike = function(x3) {
      return x3 && typeof x3.length === "number" && typeof x3 !== "function";
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
var init_isPromise = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isPromise.js"() {
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js"() {
    init_observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
var init_isAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js"() {
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
var init_throwUnobservableError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/dist/esm5/internal/symbol/iterator.js"() {
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
var init_isIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isIterable.js"() {
    init_iterator();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
var init_isReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js"() {
    init_tslib_es6();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i4 = 0; i4 < array.length && !subscriber.closed; i4++) {
      subscriber.next(array[i4]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
var init_innerFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js"() {
    init_tslib_es6();
    init_isArrayLike();
    init_isPromise();
    init_Observable();
    init_isInteropObservable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isIterable();
    init_isReadableStreamLike();
    init_isFunction();
    init_reportUnhandledError();
    init_observable();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler2, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler2.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
var init_executeSchedule = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
var init_observeOn = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/observeOn.js"() {
    init_executeSchedule();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler2.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
var init_subscribeOn = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js"() {
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler2) {
  return innerFrom(input).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js"() {
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler2) {
  return innerFrom(input).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js"() {
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler2) {
  return new Observable(function(subscriber) {
    var i4 = 0;
    return scheduler2.schedule(function() {
      if (i4 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i4++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler2) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler2, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler2, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js"() {
    init_Observable();
    init_iterator();
    init_isFunction();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler2, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler2, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
var init_scheduleAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js"() {
    init_Observable();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler2) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler2);
}
var init_scheduleReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js"() {
    init_scheduleAsyncIterable();
    init_isReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler2);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler2);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler2);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler2);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler2);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler2);
    }
  }
  throw createInvalidObservableTypeError(input);
}
var init_scheduled = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js"() {
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_scheduleAsyncIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isReadableStreamLike();
    init_scheduleReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from2(input, scheduler2) {
  return scheduler2 ? scheduled(input, scheduler2) : innerFrom(input);
}
var init_from = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/from.js"() {
    init_scheduled();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
var init_isScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isScheduler.js"() {
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue2) {
  return typeof last(args) === "number" ? args.pop() : defaultValue2;
}
var init_args = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/args.js"() {
    init_isFunction();
    init_isScheduler();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args);
  return from2(args, scheduler2);
}
var init_of = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/of.js"() {
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler2) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler2 ? function(subscriber) {
    return scheduler2.schedule(init, 0, subscriber);
  } : init);
}
var init_throwError = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/throwError.js"() {
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}
var init_isObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isObservable.js"() {
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/EmptyError.js"() {
    init_createErrorClass();
    EmptyError = createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}
var init_lastValueFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/lastValueFrom.js"() {
    init_EmptyError();
  }
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
var init_firstValueFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/firstValueFrom.js"() {
    init_EmptyError();
    init_Subscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index3++));
    }));
  });
}
var init_map = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/map.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key2) {
          return first_1[key2];
        }),
        keys: keys2
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
var isArray, getPrototypeOf, objectProto, getKeys;
var init_argsArgArrayOrObject = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js"() {
    isArray = Array.isArray;
    getPrototypeOf = Object.getPrototypeOf;
    objectProto = Object.prototype;
    getKeys = Object.keys;
  }
});

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
function callOrApply(fn, args) {
  return isArray2(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
var isArray2;
var init_mapOneOrManyArgs = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js"() {
    init_tslib_es6();
    init_map();
    isArray2 = Array.isArray;
  }
});

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys2, values) {
  return keys2.reduce(function(result, key2, i4) {
    return result[key2] = values[i4], result;
  }, {});
}
var init_createObject = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/createObject.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from2([], scheduler2);
  }
  var result = new Observable(combineLatestInit(observables, scheduler2, keys2 ? function(values) {
    return createObject(keys2, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler2, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler2, function() {
      var length2 = observables.length;
      var values = new Array(length2);
      var active = length2;
      var remainingFirstValues = length2;
      var _loop_1 = function(i5) {
        maybeSchedule(scheduler2, function() {
          var source = from2(observables[i5], scheduler2);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i5] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i4 = 0; i4 < length2; i4++) {
        _loop_1(i4);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler2, execute, subscription) {
  if (scheduler2) {
    executeSchedule(subscription, scheduler2, execute);
  } else {
    execute();
  }
}
var init_combineLatest = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js"() {
    init_Observable();
    init_argsArgArrayOrObject();
    init_from();
    init_identity();
    init_mapOneOrManyArgs();
    init_args();
    init_createObject();
    init_OperatorSubscriber();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index3 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index3++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
var init_mergeInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js"() {
    init_innerFrom();
    init_executeSchedule();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a5, i4) {
      return map(function(b3, ii) {
        return resultSelector(a5, b3, i4, ii);
      })(innerFrom(project(a5, i4)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
var init_mergeMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js"() {
    init_map();
    init_innerFrom();
    init_lift();
    init_mergeInternals();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js"() {
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatAll.js"() {
    init_mergeAll();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from2(args, popScheduler(args)));
}
var init_concat = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/concat.js"() {
    init_concatAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/defer.js"() {
    init_Observable();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add4 = _a[0], remove = _a[1];
  if (!add4) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add4) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add4(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
var nodeEventEmitterMethods, eventTargetMethods, jqueryMethods;
var init_fromEvent = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js"() {
    init_tslib_es6();
    init_innerFrom();
    init_Observable();
    init_mergeMap();
    init_isArrayLike();
    init_isFunction();
    init_mapOneOrManyArgs();
    nodeEventEmitterMethods = ["addListener", "removeListener"];
    eventTargetMethods = ["addEventListener", "removeEventListener"];
    jqueryMethods = ["on", "off"];
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
var init_iif = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/iif.js"() {
    init_defer();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
var init_isDate = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isDate.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler2) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler2 = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler2.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n4 = 0;
    return scheduler2.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n4++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
var init_timer = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/timer.js"() {
    init_Observable();
    init_async();
    init_isScheduler();
    init_isDate();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from2(sources, scheduler2));
}
var init_merge = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/merge.js"() {
    init_mergeAll();
    init_innerFrom();
    init_empty();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER;
var init_never = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/never.js"() {
    init_Observable();
    init_noop();
    NEVER = new Observable(noop);
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter2(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index3++) && subscriber.next(value);
    }));
  });
}
var init_filter = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/filter.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/not.js
function not(pred, thisArg) {
  return function(value, index3) {
    return !pred.call(thisArg, value, index3);
  };
}
var init_not = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/not.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [filter2(predicate, thisArg)(innerFrom(source)), filter2(not(predicate, thisArg))(innerFrom(source))];
}
var init_partition = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/partition.js"() {
    init_not();
    init_filter();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/audit.js
function audit(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
var init_audit = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/audit.js"() {
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = asyncScheduler;
  }
  return audit(function() {
    return timer(duration, scheduler2);
  });
}
var init_auditTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/auditTime.js"() {
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
var init_catchError = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/catchError.js"() {
    init_innerFrom();
    init_OperatorSubscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i4 = index3++;
      state = hasState ? accumulator(state, value, i4) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
var init_scanInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js"() {
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}
var init_reduce = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/reduce.js"() {
    init_scanInternals();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/toArray.js
function toArray() {
  return operate(function(source, subscriber) {
    reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
var arrReducer;
var init_toArray = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/toArray.js"() {
    init_reduce();
    init_lift();
    arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatMap.js"() {
    init_mergeMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var emit = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      hasValue = true;
      lastValue = value;
      durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
      innerFrom(durationSelector(value)).subscribe(durationSubscriber);
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = durationSubscriber = null;
    }));
  });
}
var init_debounce = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/debounce.js"() {
    init_lift();
    init_noop();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now2 = scheduler2.now();
      if (now2 < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now2);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler2.now();
      if (!activeTask) {
        activeTask = scheduler2.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
var init_debounceTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js"() {
    init_async();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
var init_take = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/take.js"() {
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value) {
  return map(function() {
    return value;
  });
}
var init_mapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mapTo.js"() {
    init_map();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}
var init_ignoreElements = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index3) {
    return innerFrom(delayDurationSelector(value, index3)).pipe(take(1), mapTo(value));
  });
}
var init_delayWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js"() {
    init_concat();
    init_take();
    init_ignoreElements();
    init_mapTo();
    init_mergeMap();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/delay.js
function delay(due, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = asyncScheduler;
  }
  var duration = timer(due, scheduler2);
  return delayWhen(function() {
    return duration;
  });
}
var init_delay = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/delay.js"() {
    init_async();
    init_delayWhen();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var key2 = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key2)) {
        distinctKeys.add(key2);
        subscriber.next(value);
      }
    }));
    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop));
  });
}
var init_distinct = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/distinct.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_noop();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first3 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first3 || !comparator(previousKey, currentKey)) {
        first3 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a5, b3) {
  return a5 === b3;
}
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js"() {
    init_identity();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue2) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue2);
      }
      subscriber.complete();
    }));
  });
}
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js"() {
    init_EmptyError();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/first.js
function first(predicate, defaultValue2) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter2(function(v2, i4) {
      return predicate(v2, i4, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue2) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/first.js"() {
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementOrOptions, duration, connector) {
  return operate(function(source, subscriber) {
    var element;
    if (!elementOrOptions || typeof elementOrOptions === "function") {
      element = elementOrOptions;
    } else {
      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
    }
    var groups = /* @__PURE__ */ new Map();
    var notify2 = function(cb) {
      groups.forEach(cb);
      cb(subscriber);
    };
    var handleError = function(err) {
      return notify2(function(consumer) {
        return consumer.error(err);
      });
    };
    var activeGroups = 0;
    var teardownAttempted = false;
    var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function(value) {
      try {
        var key_1 = keySelector(value);
        var group_1 = groups.get(key_1);
        if (!group_1) {
          groups.set(key_1, group_1 = connector ? connector() : new Subject());
          var grouped = createGroupedObservable(key_1, group_1);
          subscriber.next(grouped);
          if (duration) {
            var durationSubscriber_1 = createOperatorSubscriber(group_1, function() {
              group_1.complete();
              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
            }, void 0, void 0, function() {
              return groups.delete(key_1);
            });
            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
          }
        }
        group_1.next(element ? element(value) : value);
      } catch (err) {
        handleError(err);
      }
    }, function() {
      return notify2(function(consumer) {
        return consumer.complete();
      });
    }, handleError, function() {
      return groups.clear();
    }, function() {
      teardownAttempted = true;
      return activeGroups === 0;
    });
    source.subscribe(groupBySourceSubscriber);
    function createGroupedObservable(key2, groupSubject) {
      var result = new Observable(function(groupSubscriber) {
        activeGroups++;
        var innerSub = groupSubject.subscribe(groupSubscriber);
        return function() {
          innerSub.unsubscribe();
          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
        };
      });
      result.key = key2;
      return result;
    }
  });
}
var init_groupBy = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/groupBy.js"() {
    init_Observable();
    init_innerFrom();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var buffer2 = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      buffer2.push(value);
      count2 < buffer2.length && buffer2.shift();
    }, function() {
      var e_1, _a;
      try {
        for (var buffer_1 = __values(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
          var value = buffer_1_1.value;
          subscriber.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
            _a.call(buffer_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffer2 = null;
    }));
  });
}
var init_takeLast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/takeLast.js"() {
    init_tslib_es6();
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/last.js
function last2(predicate, defaultValue2) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter2(function(v2, i4) {
      return predicate(v2, i4, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue2) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/last.js"() {
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/flatMap.js
var flatMap;
var init_flatMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/flatMap.js"() {
    init_mergeMap();
    flatMap = mergeMap;
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js"() {
    init_mergeMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
function pairwise() {
  return operate(function(source, subscriber) {
    var prev2;
    var hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var p2 = prev2;
      prev2 = value;
      hasPrev && subscriber.next([p2, value]);
      hasPrev = true;
    }));
  });
}
var init_pairwise = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/pairwise.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js"() {
    init_tslib_es6();
    init_Observable();
    init_Subscription();
    init_refCount();
    init_OperatorSubscriber();
    init_lift();
    ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
function fromSubscribable(subscribable) {
  return new Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}
var init_fromSubscribable = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/connect.js
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return operate(function(source, subscriber) {
    var subject = connector();
    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}
var DEFAULT_CONFIG;
var init_connect = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/connect.js"() {
    init_Subject();
    init_innerFrom();
    init_lift();
    init_fromSubscribable();
    DEFAULT_CONFIG = {
      connector: function() {
        return new Subject();
      }
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction(selector)) {
    return connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable(source, subjectFactory);
  };
}
var init_multicast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/multicast.js"() {
    init_ConnectableObservable();
    init_isFunction();
    init_connect();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast(new ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js"() {
    init_ReplaySubject();
    init_multicast();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}
var init_scan = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/scan.js"() {
    init_lift();
    init_scanInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}
var init_share = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/share.js"() {
    init_tslib_es6();
    init_innerFrom();
    init_Subject();
    init_Subscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler2) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler2 = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler2);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
var init_shareReplay = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"() {
    init_ReplaySubject();
    init_share();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skip.js
function skip(count2) {
  return filter2(function(_2, index3) {
    return count2 <= index3;
  });
}
var init_skip = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skip.js"() {
    init_filter();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler2 ? concat(values, source, scheduler2) : concat(values, source)).subscribe(subscriber);
  });
}
var init_startWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/startWith.js"() {
    init_concat();
    init_args();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index3 = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index3++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
var init_switchMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchMap.js"() {
    init_innerFrom();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return isFunction(resultSelector) ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js"() {
    init_switchMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
var init_takeUntil = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
var init_tap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/tap.js"() {
    init_isFunction();
    init_lift();
    init_OperatorSubscriber();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  return operate(function(source, subscriber) {
    var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
var init_throttle = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/throttle.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler2, config2) {
  if (scheduler2 === void 0) {
    scheduler2 = asyncScheduler;
  }
  var duration$ = timer(duration, scheduler2);
  return throttle(function() {
    return duration$;
  }, config2);
}
var init_throttleTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js"() {
    init_async();
    init_throttle();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i5) {
      innerFrom(inputs[i5]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i5] = value;
        if (!ready && !hasValue[i5]) {
          hasValue[i5] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i4 = 0; i4 < len; i4++) {
      _loop_1(i4);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}
var init_withLatestFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js"() {
    init_tslib_es6();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_identity();
    init_noop();
    init_args();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider;
var init_performanceTimestampProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js"() {
    performanceTimestampProvider = {
      now: function() {
        return (performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider;
var init_animationFrameProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js"() {
    init_tslib_es6();
    init_Subscription();
    animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp2) {
          cancel = void 0;
          callback(timestamp2);
        });
        return new Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start2 = provider.now();
    var id2 = 0;
    var run = function() {
      if (!subscriber.closed) {
        id2 = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id2 = 0;
          var now2 = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now2 : timestamp2,
            elapsed: now2 - start2
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id2) {
        animationFrameProvider.cancelAnimationFrame(id2);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES;
var init_animationFrames = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js"() {
    init_Observable();
    init_performanceTimestampProvider();
    init_animationFrameProvider();
    DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/rxjs/dist/esm5/internal/AsyncSubject.js"() {
    init_tslib_es6();
    init_Subject();
    AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, resolved, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/Immediate.js"() {
    nextHandle = 1;
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate2, clearImmediate, immediateProvider;
var init_immediateProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js"() {
    init_tslib_es6();
    init_Immediate();
    setImmediate2 = Immediate.setImmediate;
    clearImmediate = Immediate.clearImmediate;
    immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_immediateProvider();
    AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler2, work) {
        var _this = _super.call(this, scheduler2, work) || this;
        _this.scheduler = scheduler2;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
        }
        scheduler2.actions.push(this);
        return scheduler2._scheduled || (scheduler2._scheduled = immediateProvider.setImmediate(scheduler2.flush.bind(scheduler2, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
        var _a;
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null ? delay2 > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
        }
        var actions = scheduler2.actions;
        if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
          immediateProvider.clearImmediate(id2);
          if (scheduler2._scheduled === id2) {
            scheduler2._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler;
var init_asap = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/asap.js"() {
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler2, work) {
        var _this = _super.call(this, scheduler2, work) || this;
        _this.scheduler = scheduler2;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
        }
        scheduler2.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler;
var init_queue = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/queue.js"() {
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = new QueueScheduler(QueueAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_animationFrameProvider();
    AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler2, work) {
        var _this = _super.call(this, scheduler2, work) || this;
        _this.scheduler = scheduler2;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
        }
        scheduler2.actions.push(this);
        return scheduler2._scheduled || (scheduler2._scheduled = animationFrameProvider.requestAnimationFrame(function() {
          return scheduler2.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
        var _a;
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null ? delay2 > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
        }
        var actions = scheduler2.actions;
        if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
          animationFrameProvider.cancelAnimationFrame(id2);
          scheduler2._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler;
var init_animationFrame = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js"() {
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_Subscription();
    init_AsyncScheduler();
    VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler2, work, index3) {
        if (index3 === void 0) {
          index3 = scheduler2.index += 1;
        }
        var _this = _super.call(this, scheduler2, work) || this;
        _this.scheduler = scheduler2;
        _this.work = work;
        _this.index = index3;
        _this.active = true;
        _this.index = scheduler2.index = index3;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (Number.isFinite(delay2)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay2);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay2);
        } else {
          return Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler2.frame + delay2;
        var actions = scheduler2.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction2.sortActions = function(a5, b3) {
        if (a5.delay === b3.delay) {
          if (a5.index === b3.index) {
            return 0;
          } else if (a5.index > b3.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a5.delay > b3.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/Notification.js
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/rxjs/dist/esm5/internal/Notification.js"() {
    init_empty();
    init_of();
    init_throwError();
    init_isFunction();
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
          return error;
        }) : kind === "C" ? EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js"() {
    init_createErrorClass();
    ArgumentOutOfRangeError = createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError;
var init_NotFoundError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js"() {
    init_createErrorClass();
    NotFoundError = createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError;
var init_SequenceError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/SequenceError.js"() {
    init_createErrorClass();
    SequenceError = createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError;
var init_timeout = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timeout.js"() {
    init_async();
    init_isDate();
    init_lift();
    init_innerFrom();
    init_createErrorClass();
    init_OperatorSubscriber();
    init_executeSchedule();
    TimeoutError = createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js
var init_bindCallbackInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js"() {
    init_tslib_es6();
    init_isScheduler();
    init_Observable();
    init_subscribeOn();
    init_mapOneOrManyArgs();
    init_observeOn();
    init_AsyncSubject();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js
var init_bindCallback = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js"() {
    init_bindCallbackInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js
var init_bindNodeCallback = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js"() {
    init_bindCallbackInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/connectable.js
var init_connectable = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/connectable.js"() {
    init_Subject();
    init_Observable();
    init_defer();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys2 = _a.keys;
  var result = new Observable(function(subscriber) {
    var length2 = sources.length;
    if (!length2) {
      subscriber.complete();
      return;
    }
    var values = new Array(length2);
    var remainingCompletions = length2;
    var remainingEmissions = length2;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys2 ? createObject(keys2, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length2; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
var init_forkJoin = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js"() {
    init_Observable();
    init_argsArgArrayOrObject();
    init_innerFrom();
    init_args();
    init_OperatorSubscriber();
    init_mapOneOrManyArgs();
    init_createObject();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
var init_fromEventPattern = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js"() {
    init_Observable();
    init_isFunction();
    init_mapOneOrManyArgs();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/generate.js
var init_generate = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/generate.js"() {
    init_tslib_es6();
    init_identity();
    init_isScheduler();
    init_defer();
    init_scheduleIterable();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/interval.js
var init_interval = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/interval.js"() {
    init_async();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}
var isArray3;
var init_argsOrArgArray = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js"() {
    isArray3 = Array.isArray;
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js
var init_onErrorResumeNext = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js"() {
    init_Observable();
    init_argsOrArgArray();
    init_OperatorSubscriber();
    init_noop();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/pairs.js
var init_pairs = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/pairs.js"() {
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i5) {
      subscriptions.push(innerFrom(sources[i5]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s5 = 0; s5 < subscriptions.length; s5++) {
            s5 !== i5 && subscriptions[s5].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i4 = 0; subscriptions && !subscriber.closed && i4 < sources.length; i4++) {
      _loop_1(i4);
    }
  };
}
var init_race = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/race.js"() {
    init_Observable();
    init_innerFrom();
    init_argsOrArgArray();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/range.js
var init_range = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/range.js"() {
    init_Observable();
    init_empty();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource = resourceFactory();
    var result = observableFactory(resource);
    var source = result ? innerFrom(result) : EMPTY;
    source.subscribe(subscriber);
    return function() {
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
var init_using = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/using.js"() {
    init_Observable();
    init_innerFrom();
    init_empty();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/zip.js
var init_zip = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/zip.js"() {
    init_tslib_es6();
    init_Observable();
    init_innerFrom();
    init_argsOrArgArray();
    init_empty();
    init_OperatorSubscriber();
    init_args();
  }
});

// node_modules/rxjs/dist/esm5/internal/types.js
var init_types = __esm({
  "node_modules/rxjs/dist/esm5/internal/types.js"() {
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, function() {
      var b3 = currentBuffer;
      currentBuffer = [];
      subscriber.next(b3);
    }, noop));
    return function() {
      currentBuffer = null;
    };
  });
}
var init_buffer = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/buffer.js"() {
    init_lift();
    init_noop();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js
var init_bufferCount = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js"() {
    init_tslib_es6();
    init_lift();
    init_OperatorSubscriber();
    init_arrRemove();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
var init_bufferTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js"() {
    init_tslib_es6();
    init_Subscription();
    init_lift();
    init_OperatorSubscriber();
    init_arrRemove();
    init_async();
    init_args();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return operate(function(source, subscriber) {
    var buffers = [];
    innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function(openValue) {
      var buffer2 = [];
      buffers.push(buffer2);
      var closingSubscription = new Subscription();
      var emitBuffer = function() {
        arrRemove(buffers, buffer2);
        subscriber.next(buffer2);
        closingSubscription.unsubscribe();
      };
      closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));
    }, noop));
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (buffers.length > 0) {
        subscriber.next(buffers.shift());
      }
      subscriber.complete();
    }));
  });
}
var init_bufferToggle = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js"() {
    init_tslib_es6();
    init_Subscription();
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
    init_noop();
    init_arrRemove();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b3 = buffer2;
      buffer2 = [];
      b3 && subscriber.next(b3);
      innerFrom(closingSelector()).subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop));
    };
    openBuffer();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}
var init_bufferWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js"() {
    init_lift();
    init_noop();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js
var init_joinAllInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js"() {
    init_identity();
    init_mapOneOrManyArgs();
    init_pipe();
    init_mergeMap();
    init_toArray();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js
var init_combineLatestAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js"() {
    init_combineLatest();
    init_joinAllInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineAll.js
var init_combineAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineAll.js"() {
    init_combineLatestAll();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
var init_combineLatest2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js"() {
    init_tslib_es6();
    init_combineLatest();
    init_lift();
    init_argsOrArgArray();
    init_mapOneOrManyArgs();
    init_pipe();
    init_args();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
var init_combineLatestWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js"() {
    init_tslib_es6();
    init_combineLatest2();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js
var init_concatMapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js"() {
    init_concatMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concat.js
function concat2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args);
  return operate(function(source, subscriber) {
    concatAll()(from2(__spreadArray([source], __read(args)), scheduler2)).subscribe(subscriber);
  });
}
var init_concat2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concat.js"() {
    init_tslib_es6();
    init_lift();
    init_concatAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatWith.js
var init_concatWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatWith.js"() {
    init_tslib_es6();
    init_concat2();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/count.js
var init_count = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/count.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js
function dematerialize() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(notification) {
      return observeNotification(notification, subscriber);
    }));
  });
}
var init_dematerialize = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js"() {
    init_Notification();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
var init_distinctUntilKeyChanged = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_distinctUntilChanged();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/elementAt.js
var init_elementAt = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/elementAt.js"() {
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/endWith.js
var init_endWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/endWith.js"() {
    init_tslib_es6();
    init_concat();
    init_of();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/every.js
var init_every = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/every.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a5, i4) {
        return innerFrom(project(a5, i4)).pipe(map(function(b3, ii) {
          return resultSelector(a5, b3, i4, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index3 = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index3++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}
var init_exhaustMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js"() {
    init_map();
    init_innerFrom();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js
var init_exhaustAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js"() {
    init_exhaustMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/exhaust.js
var init_exhaust = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/exhaust.js"() {
    init_exhaustAll();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/expand.js
var init_expand = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/expand.js"() {
    init_lift();
    init_mergeInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
var init_finalize = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/finalize.js"() {
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/find.js
var init_find = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/find.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/findIndex.js
var init_findIndex = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/findIndex.js"() {
    init_lift();
    init_find();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js
function isEmpty() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function() {
      subscriber.next(false);
      subscriber.complete();
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
var init_isEmpty = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/materialize.js
function materialize() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(Notification.createNext(value));
    }, function() {
      subscriber.next(Notification.createComplete());
      subscriber.complete();
    }, function(err) {
      subscriber.next(Notification.createError(err));
      subscriber.complete();
    }));
  });
}
var init_materialize = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/materialize.js"() {
    init_Notification();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/max.js
var init_max = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/max.js"() {
    init_reduce();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js
var init_mergeScan = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js"() {
    init_lift();
    init_mergeInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/merge.js
var init_merge2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/merge.js"() {
    init_tslib_es6();
    init_lift();
    init_argsOrArgArray();
    init_mergeAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
var init_mergeWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js"() {
    init_tslib_es6();
    init_merge2();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/min.js
var init_min = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/min.js"() {
    init_reduce();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNextWith.js
var init_onErrorResumeNextWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNextWith.js"() {
    init_tslib_es6();
    init_argsOrArgArray();
    init_onErrorResumeNext();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/pluck.js
function pluck() {
  var properties2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties2[_i] = arguments[_i];
  }
  var length2 = properties2.length;
  if (length2 === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map(function(x3) {
    var currentProp = x3;
    for (var i4 = 0; i4 < length2; i4++) {
      var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties2[i4]];
      if (typeof p2 !== "undefined") {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}
var init_pluck = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/pluck.js"() {
    init_map();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? function(source) {
    return connect(selector)(source);
  } : function(source) {
    return multicast(new Subject())(source);
  };
}
var init_publish = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publish.js"() {
    init_Subject();
    init_multicast();
    init_connect();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js
var init_publishBehavior = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js"() {
    init_BehaviorSubject();
    init_ConnectableObservable();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publishLast.js
var init_publishLast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publishLast.js"() {
    init_AsyncSubject();
    init_ConnectableObservable();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
var init_raceWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/raceWith.js"() {
    init_tslib_es6();
    init_race();
    init_lift();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/repeat.js
var init_repeat = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/repeat.js"() {
    init_empty();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js
var init_repeatWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js"() {
    init_innerFrom();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
var init_retry = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/retry.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_identity();
    init_timer();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js
var init_retryWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js"() {
    init_innerFrom();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/sample.js
var init_sample = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/sample.js"() {
    init_innerFrom();
    init_lift();
    init_noop();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js
var init_sampleTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js"() {
    init_async();
    init_sample();
    init_interval();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js
var init_sequenceEqual = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/single.js
var init_single = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/single.js"() {
    init_EmptyError();
    init_SequenceError();
    init_NotFoundError();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skipLast.js
var init_skipLast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skipLast.js"() {
    init_identity();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js
var init_skipUntil = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js"() {
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js
var init_skipWhile = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchAll.js
var init_switchAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchAll.js"() {
    init_switchMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchScan.js
var init_switchScan = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchScan.js"() {
    init_switchMap();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index3++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}
var init_takeWhile = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js"() {
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js"() {
    init_async();
    init_lift();
    init_OperatorSubscriber();
    TimeInterval = function() {
      function TimeInterval2(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js
var init_timeoutWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js"() {
    init_async();
    init_isDate();
    init_timeout();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timestamp.js
var init_timestamp = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timestamp.js"() {
    init_dateTimestampProvider();
    init_map();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/window.js
var init_window = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/window.js"() {
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
    init_noop();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowCount.js
var init_windowCount = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowCount.js"() {
    init_tslib_es6();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowTime.js
var init_windowTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowTime.js"() {
    init_Subject();
    init_async();
    init_Subscription();
    init_lift();
    init_OperatorSubscriber();
    init_arrRemove();
    init_args();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js
var init_windowToggle = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
    init_noop();
    init_arrRemove();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js
var init_windowWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js"() {
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/zipAll.js
var init_zipAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/zipAll.js"() {
    init_zip();
    init_joinAllInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/zip.js
var init_zip2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/zip.js"() {
    init_tslib_es6();
    init_zip();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/zipWith.js
var init_zipWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/zipWith.js"() {
    init_tslib_es6();
    init_zip2();
  }
});

// node_modules/rxjs/dist/esm5/index.js
var init_esm5 = __esm({
  "node_modules/rxjs/dist/esm5/index.js"() {
    init_Observable();
    init_ConnectableObservable();
    init_observable();
    init_animationFrames();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_lastValueFrom();
    init_firstValueFrom();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_NotFoundError();
    init_ObjectUnsubscribedError();
    init_SequenceError();
    init_timeout();
    init_UnsubscriptionError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_connectable();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_types();
    init_config();
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatestAll();
    init_combineLatestWith();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_concatWith();
    init_connect();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustAll();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_mergeAll();
    init_flatMap();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_mergeWith();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNextWith();
    init_pairwise();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_raceWith();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_switchScan();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zipAll();
    init_zipWith();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/partition.js
var init_partition2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/partition.js"() {
    init_not();
    init_filter();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/race.js
var init_race2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/race.js"() {
    init_tslib_es6();
    init_argsOrArgArray();
    init_raceWith();
  }
});

// node_modules/rxjs/dist/esm5/operators/index.js
var init_operators = __esm({
  "node_modules/rxjs/dist/esm5/operators/index.js"() {
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatestAll();
    init_combineLatest2();
    init_combineLatestWith();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_concatWith();
    init_connect();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustAll();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_flatMap();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_mergeWith();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNextWith();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_raceWith();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_switchScan();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
    init_zipWith();
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React18 = require_react();
        var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format4) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format4, args);
            }
          }
        }
        function printWarning(level, format4, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format4 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format4);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is2(x3, y4) {
          return x3 === y4 && (x3 !== 0 || 1 / x3 === 1 / y4) || x3 !== x3 && y4 !== y4;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useState13 = React18.useState, useEffect16 = React18.useEffect, useLayoutEffect5 = React18.useLayoutEffect, useDebugValue = React18.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React18.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState13({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect5(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect16(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM2;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React18.useSyncExternalStore !== void 0 ? React18.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/react-rx/dist/esm/useObservable.js
function getValue(value) {
  return typeof value === "function" ? value() : value;
}
function getOrCreateStore(inputObservable, initialValue) {
  if (!cache.has(inputObservable)) {
    var entry_1 = { currentValue: initialValue };
    entry_1.observable = inputObservable.pipe(shareReplay({ refCount: true, bufferSize: 1 }), tap(function(value) {
      return entry_1.currentValue = value;
    }));
    entry_1.subscription = entry_1.observable.subscribe();
    cache.set(inputObservable, entry_1);
  }
  return cache.get(inputObservable);
}
function useObservable(observable2, initialValue) {
  var _a = (0, import_react2.useMemo)(function() {
    var store = getOrCreateStore(observable2, getValue(initialValue));
    if (store.subscription.closed) {
      store.subscription = store.observable.subscribe();
    }
    return [
      function getSnapshot2() {
        return store.currentValue;
      },
      function subscribe2(callback) {
        var sub2 = store.observable.subscribe(callback);
        return function() {
          sub2.unsubscribe();
        };
      }
    ];
  }, [observable2]), getSnapshot = _a[0], subscribe = _a[1];
  var shouldRestoreSubscriptionRef = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(function() {
    var store = getOrCreateStore(observable2, getValue(initialValue));
    if (shouldRestoreSubscriptionRef.current) {
      if (store.subscription.closed) {
        store.subscription = store.observable.subscribe();
      }
      shouldRestoreSubscriptionRef.current = false;
    }
    return function() {
      shouldRestoreSubscriptionRef.current = !store.subscription.closed;
      store.subscription.unsubscribe();
    };
  }, [observable2]);
  return (0, import_shim.useSyncExternalStore)(subscribe, getSnapshot);
}
function useMemoObservable(observableOrFactory, deps, initialValue) {
  return useObservable((0, import_react2.useMemo)(function() {
    return getValue(observableOrFactory);
  }, deps), initialValue);
}
var import_react2, import_shim, cache;
var init_useObservable = __esm({
  "node_modules/react-rx/dist/esm/useObservable.js"() {
    import_react2 = __toESM(require_react());
    import_shim = __toESM(require_shim());
    init_operators();
    cache = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/observable-callback/dist/esm/observableCallback.js
var observableCallback_exports = {};
__export(observableCallback_exports, {
  observableCallback: () => observableCallback
});
function observableCallback(operator) {
  if (operator === void 0) {
    operator = pass;
  }
  var subject = new Subject();
  return [subject.pipe(operator), function(arg) {
    return subject.next(arg);
  }];
}
var pass;
var init_observableCallback = __esm({
  "node_modules/observable-callback/dist/esm/observableCallback.js"() {
    init_esm5();
    pass = function(input$) {
      return input$;
    };
  }
});

// node_modules/react-rx/dist/esm/useObservableCallback.js
function useObservableCallback(fn, dependencies) {
  if (dependencies === void 0) {
    dependencies = EMPTY_DEPS;
  }
  var callbackRef = (0, import_react3.useRef)();
  if (!callbackRef.current) {
    callbackRef.current = observableCallback();
  }
  var _a = callbackRef.current, calls$ = _a[0], call = _a[1];
  var callback = (0, import_react3.useCallback)(fn, dependencies);
  (0, import_react3.useEffect)(function() {
    var subscription = calls$.pipe(callback).subscribe();
    return function() {
      subscription.unsubscribe();
    };
  }, [calls$, call, callback]);
  return call;
}
var import_react3, EMPTY_DEPS;
var init_useObservableCallback = __esm({
  "node_modules/react-rx/dist/esm/useObservableCallback.js"() {
    import_react3 = __toESM(require_react());
    init_observableCallback();
    EMPTY_DEPS = [];
  }
});

// node_modules/react-rx/dist/esm/displayName.js
var getDisplayName, wrapDisplayName;
var init_displayName = __esm({
  "node_modules/react-rx/dist/esm/displayName.js"() {
    getDisplayName = function(Component2) {
      if (typeof Component2 === "string") {
        return Component2;
      }
      return Component2 && (Component2.displayName || Component2.name) || "Unknown";
    };
    wrapDisplayName = function(BaseComponent, wrapperName) {
      return "".concat(wrapperName, "(").concat(getDisplayName(BaseComponent), ")");
    };
  }
});

// node_modules/react-rx/dist/esm/useAsObservable.js
function useAsObservable(value, operator) {
  var setup = (0, import_react4.useCallback)(function() {
    var subject = new BehaviorSubject(value);
    var observable3 = subject.asObservable().pipe(distinctUntilChanged());
    return [operator ? observable3.pipe(operator) : observable3, subject];
  }, []);
  var ref = (0, import_react4.useRef)();
  if (!ref.current) {
    ref.current = setup();
  }
  var observable2 = ref.current[0];
  (0, import_react4.useEffect)(function() {
    if (!ref.current) {
      return;
    }
    var _a = ref.current, subject = _a[1];
    subject.next(value);
  }, [value, ref]);
  var shouldRestoreSubscriptionRef = (0, import_react4.useRef)(false);
  (0, import_react4.useEffect)(function() {
    if (shouldRestoreSubscriptionRef.current) {
      if (!ref.current) {
        ref.current = setup();
      }
      shouldRestoreSubscriptionRef.current = false;
    }
    return function() {
      if (!ref.current) {
        return;
      }
      shouldRestoreSubscriptionRef.current = true;
      var _a = ref.current, subject = _a[1];
      subject.complete();
      ref.current = void 0;
    };
  }, []);
  return observable2;
}
var import_react4;
var init_useAsObservable = __esm({
  "node_modules/react-rx/dist/esm/useAsObservable.js"() {
    init_esm5();
    import_react4 = __toESM(require_react());
    init_operators();
  }
});

// node_modules/react-rx/dist/esm/reactiveComponent.js
function fromComponent(component) {
  var wrappedComponent = function(props) {
    return (0, import_react5.createElement)(import_react5.Fragment, null, useObservable((0, import_react5.useRef)(component(useAsObservable(props))).current));
  };
  wrappedComponent.displayName = wrapDisplayName(component, "reactiveComponent");
  return wrappedComponent;
}
function fromObservable(input$) {
  return function ReactiveComponent() {
    return (0, import_react5.createElement)(import_react5.Fragment, null, useObservable(input$));
  };
}
function reactiveComponent(observableOrComponent) {
  return typeof observableOrComponent === "function" ? fromComponent(observableOrComponent) : fromObservable(observableOrComponent);
}
function forwardRef(component) {
  var wrappedComponent = (0, import_react5.forwardRef)(function(props, ref) {
    return (0, import_react5.createElement)(import_react5.Fragment, null, useObservable((0, import_react5.useRef)(component(useAsObservable(props), ref)).current));
  });
  wrappedComponent.displayName = wrapDisplayName(component, "reactiveComponent");
  return wrappedComponent;
}
var import_react5;
var init_reactiveComponent = __esm({
  "node_modules/react-rx/dist/esm/reactiveComponent.js"() {
    init_displayName();
    init_useAsObservable();
    init_useObservable();
    import_react5 = __toESM(require_react());
  }
});

// node_modules/react-rx/dist/esm/utils.js
function observeState(initial2) {
  var _a = (0, import_react6.useState)(initial2), value = _a[0], update = _a[1];
  return [useAsObservable(value), update];
}
function observeCallback(operator) {
  var ref = (0, import_react6.useRef)();
  if (!ref.current) {
    ref.current = operator ? observableCallback(operator) : observableCallback();
  }
  return ref.current;
}
function observeContext(context2) {
  return useAsObservable((0, import_react6.useContext)(context2));
}
function observeElement() {
  var ref = (0, import_react6.useRef)();
  if (!ref.current) {
    ref.current = createState(null);
  }
  return ref.current;
}
var import_react6, createState;
var init_utils = __esm({
  "node_modules/react-rx/dist/esm/utils.js"() {
    init_useAsObservable();
    init_observableCallback();
    init_operators();
    import_react6 = __toESM(require_react());
    createState = function(initialState) {
      return observableCallback(startWith(initialState));
    };
  }
});

// node_modules/react-rx/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  context: () => observeContext,
  elementRef: () => observeElement,
  forwardRef: () => forwardRef,
  handler: () => observeCallback,
  observableCallback: () => observableCallback,
  observeCallback: () => observeCallback,
  observeContext: () => observeContext,
  observeElement: () => observeElement,
  observeState: () => observeState,
  reactiveComponent: () => reactiveComponent,
  rxComponent: () => reactiveComponent,
  state: () => observeState,
  useAsObservable: () => useAsObservable,
  useMemoObservable: () => useMemoObservable,
  useObservable: () => useObservable,
  useObservableCallback: () => useObservableCallback
});
var init_esm2 = __esm({
  "node_modules/react-rx/dist/esm/index.js"() {
    init_reactiveComponent();
    init_utils();
    init_utils();
    init_observableCallback();
    init_useObservable();
    init_useAsObservable();
    init_useObservableCallback();
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key2) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key2)) {
          return length2;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data = this.__data__, index3 = assocIndexOf(data, key2);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key2) {
      var data = this.__data__, index3 = assocIndexOf(data, key2);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key2, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key2);
      if (index3 < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module2) {
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module2) {
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    module2.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module2) {
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    module2.exports = stackHas;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject4 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject4(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction3;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e5) {
        }
        try {
          return func2 + "";
        } catch (e5) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module2) {
    var isFunction3 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject4 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject4(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module2) {
    function getValue2(object2, key2) {
      return object2 == null ? void 0 : object2[key2];
    }
    module2.exports = getValue2;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue2 = require_getValue();
    function getNative(object2, key2) {
      var value = getValue2(object2, key2);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module2) {
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map3, key2) {
      var data = map3.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size4 = data.size;
      data.set(key2, value);
      this.size += data.size == size4 ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index3 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index3 < length2) {
        this.add(values[index3]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module2) {
    function arraySome(array, predicate) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      while (++index3 < length2) {
        if (predicate(array[index3], index3, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module2) {
    function cacheHas(cache3, key2) {
      return cache3.has(key2);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index3 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index3 < arrLength) {
        var arrValue = array[index3], othValue = other[index3];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index3, other, array, stack) : customizer(arrValue, othValue, index3, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module2) {
    function mapToArray(map3) {
      var index3 = -1, result = Array(map3.size);
      map3.forEach(function(value, key2) {
        result[++index3] = [key2, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module2) {
    function setToArray(set4) {
      var index3 = -1, result = Array(set4.size);
      set4.forEach(function(value) {
        result[++index3] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module2) {
    function arrayPush(array, values) {
      var index3 = -1, length2 = values.length, offset3 = array.length;
      while (++index3 < length2) {
        array[offset3 + index3] = values[index3];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module2) {
    var isArray5 = Array.isArray;
    module2.exports = isArray5;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isArray5 = require_isArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray5(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module2) {
    function arrayFilter(array, predicate) {
      var index3 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index3 < length2) {
        var value = array[index3];
        if (predicate(value, index3, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto2 = Object.prototype;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module2) {
    function baseTimes(n4, iteratee) {
      var index3 = -1, result = Array(n4);
      while (++index3 < n4) {
        result[index3] = iteratee(index3);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    module2.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module2) {
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e5) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray5 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray5(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module2) {
    var objectProto2 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto2;
    }
    module2.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module2) {
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key2 in Object(object2)) {
        if (hasOwnProperty.call(object2, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module2) {
    var isFunction3 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    module2.exports = isArrayLike2;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike2 = require_isArrayLike();
    function keys2(object2) {
      return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module2.exports = keys2;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys2 = require_keys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index3 = objLength;
      while (index3--) {
        var key2 = objProps[index3];
        if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index3 < objLength) {
        key2 = objProps[index3];
        var objValue = object2[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray5 = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray5(object2), othIsArr = isArray5(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual2;
  }
});

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers;
var init_resizeObservers = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"() {
    resizeObservers = [];
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations;
var init_hasActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js"() {
    init_resizeObservers();
    hasActiveObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.activeTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations;
var init_hasSkippedObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js"() {
    init_resizeObservers();
    hasSkippedObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.skippedTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg, deliverResizeLoopError;
var init_deliverResizeLoopError = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js"() {
    msg = "ResizeObserver loop completed with undelivered notifications.";
    deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
var init_ResizeObserverBoxOptions = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js"() {
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
  }
});

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze;
var init_freeze = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/freeze.js"() {
    freeze = function(obj) {
      return Object.freeze(obj);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize;
var init_ResizeObserverSize = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js"() {
    init_freeze();
    ResizeObserverSize = function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly;
var init_DOMRectReadOnly = __esm({
  "node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js"() {
    init_freeze();
    DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x3, y4, width, height) {
        this.x = x3;
        this.y = y4;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a = this, x3 = _a.x, y4 = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x: x3, y: y4, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG, isHidden, isElement, isReplacedElement;
var init_element = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/element.js"() {
    isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    isHidden = function(target) {
      if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
      }
      var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    isElement = function(obj) {
      var _a;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global2;
var init_global = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/global.js"() {
    global2 = typeof window !== "undefined" ? window : {};
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache2, scrollRegexp, verticalRegexp, IE, parseDimension, size, zeroBoxes, calculateBoxSizes, calculateBoxSize;
var init_calculateBoxSize = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js"() {
    init_ResizeObserverBoxOptions();
    init_ResizeObserverSize();
    init_DOMRectReadOnly();
    init_element();
    init_freeze();
    init_global();
    cache2 = /* @__PURE__ */ new WeakMap();
    scrollRegexp = /auto|scroll/;
    verticalRegexp = /^tb|vertical/;
    IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
    parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache2.has(target) && !forceRecalculation) {
        return cache2.get(target);
      }
      if (isHidden(target)) {
        cache2.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache2.set(target, boxes);
      return boxes;
    };
    calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry;
var init_ResizeObserverEntry = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js"() {
    init_calculateBoxSize();
    init_freeze();
    ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode;
var init_calculateDepthForNode = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js"() {
    init_element();
    calculateDepthForNode = function(node5) {
      if (isHidden(node5)) {
        return Infinity;
      }
      var depth = 0;
      var parent3 = node5.parentNode;
      while (parent3) {
        depth += 1;
        parent3 = parent3.parentNode;
      }
      return depth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations;
var init_broadcastActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js"() {
    init_resizeObservers();
    init_ResizeObserverEntry();
    init_calculateDepthForNode();
    init_calculateBoxSize();
    broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot2) {
          var entry = new ResizeObserverEntry(ot2.target);
          var targetDepth = calculateDepthForNode(ot2.target);
          entries.push(entry);
          ot2.lastReportedSize = calculateBoxSize(ot2.target, ot2.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
      });
      for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
      }
      return shallowestDepth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth;
var init_gatherActiveObservationsAtDepth = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js"() {
    init_resizeObservers();
    init_calculateDepthForNode();
    gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot2) {
          if (ot2.isActive()) {
            if (calculateDepthForNode(ot2.target) > depth) {
              ro.activeTargets.push(ot2);
            } else {
              ro.skippedTargets.push(ot2);
            }
          }
        });
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process3;
var init_process = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/process.js"() {
    init_hasActiveObservations();
    init_hasSkippedObservations();
    init_deliverResizeLoopError();
    init_broadcastActiveObservations();
    init_gatherActiveObservationsAtDepth();
    process3 = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger, callbacks, notify, queueMicroTask;
var init_queueMicroTask = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js"() {
    callbacks = [];
    notify = function() {
      return callbacks.splice(0).forEach(function(cb) {
        return cb();
      });
    };
    queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config2 = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config2);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver;
var init_queueResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js"() {
    init_queueMicroTask();
    queueResizeObserver = function(cb) {
      queueMicroTask(function ResizeObserver3() {
        requestAnimationFrame(cb);
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching, isWatching, CATCH_PERIOD, observerConfig, events, time, scheduled2, Scheduler2, scheduler, updateCount;
var init_scheduler = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/scheduler.js"() {
    init_process();
    init_global();
    init_queueResizeObserver();
    watching = 0;
    isWatching = function() {
      return !!watching;
    };
    CATCH_PERIOD = 250;
    observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    time = function(timeout2) {
      if (timeout2 === void 0) {
        timeout2 = 0;
      }
      return Date.now() + timeout2;
    };
    scheduled2 = false;
    Scheduler2 = function() {
      function Scheduler3() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler3.prototype.run = function(timeout2) {
        var _this = this;
        if (timeout2 === void 0) {
          timeout2 = CATCH_PERIOD;
        }
        if (scheduled2) {
          return;
        }
        scheduled2 = true;
        var until = time(timeout2);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process3();
          } finally {
            scheduled2 = false;
            timeout2 = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout2 > 0) {
              _this.run(timeout2);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler3.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler3.prototype.observe = function() {
        var _this = this;
        var cb = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
      };
      Scheduler3.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global2.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler3.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global2.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler3;
    }();
    scheduler = new Scheduler2();
    updateCount = function(n4) {
      !watching && n4 > 0 && scheduler.start();
      watching += n4;
      !watching && scheduler.stop();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement, ResizeObservation;
var init_ResizeObservation = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObservation.js"() {
    init_ResizeObserverBoxOptions();
    init_calculateBoxSize();
    init_element();
    skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size4 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size4;
        }
        if (this.lastReportedSize.inlineSize !== size4.inlineSize || this.lastReportedSize.blockSize !== size4.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail;
var init_ResizeObserverDetail = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js"() {
    ResizeObserverDetail = function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap, getObservationIndex, ResizeObserverController;
var init_ResizeObserverController = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverController.js"() {
    init_scheduler();
    init_ResizeObservation();
    init_ResizeObserverDetail();
    init_resizeObservers();
    observerMap = /* @__PURE__ */ new WeakMap();
    getObservationIndex = function(observationTargets, target) {
      for (var i4 = 0; i4 < observationTargets.length; i4 += 1) {
        if (observationTargets[i4].target === target) {
          return i4;
        }
      }
      return -1;
    };
    ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index3 = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index3 >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index3, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot2) {
          return _this.unobserve(resizeObserver, ot2.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver2;
var init_ResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserver.js"() {
    init_ResizeObserverController();
    init_element();
    ResizeObserver2 = function() {
      function ResizeObserver3(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver3.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver3.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver3.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver3.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver3;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/exports/resize-observer.js
var resize_observer_exports = {};
__export(resize_observer_exports, {
  ResizeObserver: () => ResizeObserver2,
  ResizeObserverEntry: () => ResizeObserverEntry,
  ResizeObserverSize: () => ResizeObserverSize
});
var init_resize_observer = __esm({
  "node_modules/@juggle/resize-observer/lib/exports/resize-observer.js"() {
    init_ResizeObserver();
    init_ResizeObserverEntry();
    init_ResizeObserverSize();
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module2) {
    var debounce3 = require_debounce();
    var isObject4 = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle3(func2, wait, options) {
      var leading = true, trailing = true;
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject4(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce3(func2, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module2.exports = throttle3;
  }
});

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity, htmlEntities, unescapeHtmlEntity, unescape2;
var init_unescape = __esm({
  "node_modules/react-i18next/dist/es/unescape.js"() {
    matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
    htmlEntities = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "",
      "&#169;": "",
      "&reg;": "",
      "&#174;": "",
      "&hellip;": "",
      "&#8230;": "",
      "&#x2F;": "/",
      "&#47;": "/"
    };
    unescapeHtmlEntity = (m4) => htmlEntities[m4];
    unescape2 = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
  }
});

// node_modules/react-i18next/dist/es/defaults.js
function setDefaults() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
}
function getDefaults() {
  return defaultOptions;
}
var defaultOptions;
var init_defaults = __esm({
  "node_modules/react-i18next/dist/es/defaults.js"() {
    init_unescape();
    defaultOptions = {
      bindI18n: "languageChanged",
      bindI18nStore: "",
      transEmptyNodeValue: "",
      transSupportBasicHtmlNodes: true,
      transWrapTextNodes: "",
      transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
      useSuspense: true,
      unescape: unescape2
    };
  }
});

// node_modules/react-i18next/dist/es/i18nInstance.js
function setI18n(instance) {
  i18nInstance = instance;
}
function getI18n() {
  return i18nInstance;
}
var i18nInstance;
var init_i18nInstance = __esm({
  "node_modules/react-i18next/dist/es/i18nInstance.js"() {
  }
});

// node_modules/react-i18next/dist/es/initReactI18next.js
var initReactI18next;
var init_initReactI18next = __esm({
  "node_modules/react-i18next/dist/es/initReactI18next.js"() {
    init_defaults();
    init_i18nInstance();
    initReactI18next = {
      type: "3rdParty",
      init(instance) {
        setDefaults(instance.options.react);
        setI18n(instance);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/context.js
function composeInitialProps(ForComponent) {
  return (ctx) => new Promise((resolve) => {
    const i18nInitialProps = getInitialProps();
    if (ForComponent.getInitialProps) {
      ForComponent.getInitialProps(ctx).then((componentsInitialProps) => {
        resolve({
          ...componentsInitialProps,
          ...i18nInitialProps
        });
      });
    } else {
      resolve(i18nInitialProps);
    }
  });
}
function getInitialProps() {
  const i18n = getI18n();
  const namespaces = i18n.reportNamespaces ? i18n.reportNamespaces.getUsedNamespaces() : [];
  const ret = {};
  const initialI18nStore = {};
  i18n.languages.forEach((l3) => {
    initialI18nStore[l3] = {};
    namespaces.forEach((ns) => {
      initialI18nStore[l3][ns] = i18n.getResourceBundle(l3, ns) || {};
    });
  });
  ret.initialI18nStore = initialI18nStore;
  ret.initialLanguage = i18n.language;
  return ret;
}
var import_react7, I18nContext, ReportNamespaces;
var init_context = __esm({
  "node_modules/react-i18next/dist/es/context.js"() {
    import_react7 = __toESM(require_react(), 1);
    init_defaults();
    init_i18nInstance();
    init_initReactI18next();
    I18nContext = (0, import_react7.createContext)();
    ReportNamespaces = class {
      constructor() {
        this.usedNamespaces = {};
      }
      addUsedNamespaces(namespaces) {
        namespaces.forEach((ns) => {
          if (!this.usedNamespaces[ns])
            this.usedNamespaces[ns] = true;
        });
      }
      getUsedNamespaces() {
        return Object.keys(this.usedNamespaces);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/utils.js
function warn() {
  if (console && console.warn) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = `react-i18next:: ${args[0]}`;
    console.warn(...args);
  }
}
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn(...args);
}
function loadNamespaces(i18n, ns, cb) {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
}
function loadLanguages(i18n, lng, ns, cb) {
  if (typeof ns === "string")
    ns = [ns];
  ns.forEach((n4) => {
    if (i18n.options.ns.indexOf(n4) < 0)
      i18n.options.ns.push(n4);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const lng = i18n.languages[0];
  const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  const lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  const loadNotPending = (l3, n4) => {
    const loadState = i18n.services.backendConnector.state[`${l3}|${n4}`];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
function hasLoadedNamespace(ns, i18n) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  const isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options);
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return false;
    }
  });
}
function getDisplayName2(Component2) {
  return Component2.displayName || Component2.name || (typeof Component2 === "string" && Component2.length > 0 ? Component2 : "Unknown");
}
var alreadyWarned, loadedClb;
var init_utils2 = __esm({
  "node_modules/react-i18next/dist/es/utils.js"() {
    alreadyWarned = {};
    loadedClb = (i18n, cb) => () => {
      if (i18n.isInitialized) {
        cb();
      } else {
        const initialized = () => {
          setTimeout(() => {
            i18n.off("initialized", initialized);
          }, 0);
          cb();
        };
        i18n.on("initialized", initialized);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/useTranslation.js
function useTranslation(ns) {
  let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react8.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k3, optsOrDefaultValue) => {
      if (typeof optsOrDefaultValue === "string")
        return optsOrDefaultValue;
      if (optsOrDefaultValue && typeof optsOrDefaultValue === "object" && typeof optsOrDefaultValue.defaultValue === "string")
        return optsOrDefaultValue.defaultValue;
      return Array.isArray(k3) ? k3[k3.length - 1] : k3;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n4) => hasLoadedNamespace(n4, i18n, i18nOptions));
  function getT() {
    return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  const [t4, setT] = (0, import_react8.useState)(getT);
  let joinedNS = namespaces.join();
  if (props.lng)
    joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = (0, import_react8.useRef)(true);
  (0, import_react8.useEffect)(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      } else {
        loadNamespaces(i18n, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getT);
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach((e5) => i18n.off(e5, boundReset));
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach((e5) => i18n.store.off(e5, boundReset));
    };
  }, [i18n, joinedNS]);
  const isInitial = (0, import_react8.useRef)(true);
  (0, import_react8.useEffect)(() => {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n, keyPrefix]);
  const ret = [t4, i18n, ready];
  ret.t = t4;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise((resolve) => {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, () => resolve());
    } else {
      loadNamespaces(i18n, namespaces, () => resolve());
    }
  });
}
var import_react8, usePrevious;
var init_useTranslation = __esm({
  "node_modules/react-i18next/dist/es/useTranslation.js"() {
    import_react8 = __toESM(require_react(), 1);
    init_context();
    init_utils2();
    usePrevious = (value, ignore) => {
      const ref = (0, import_react8.useRef)();
      (0, import_react8.useEffect)(() => {
        ref.current = ignore ? ref.current : value;
      }, [value, ignore]);
      return ref.current;
    };
  }
});

// node_modules/react-i18next/dist/es/I18nextProvider.js
function I18nextProvider(_ref2) {
  let {
    i18n,
    defaultNS,
    children
  } = _ref2;
  const value = (0, import_react9.useMemo)(() => ({
    i18n,
    defaultNS
  }), [i18n, defaultNS]);
  return (0, import_react9.createElement)(I18nContext.Provider, {
    value
  }, children);
}
var import_react9;
var init_I18nextProvider = __esm({
  "node_modules/react-i18next/dist/es/I18nextProvider.js"() {
    import_react9 = __toESM(require_react(), 1);
    init_context();
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/void-elements/index.js"(exports, module2) {
    module2.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
function n(n4) {
  var r4 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i4 = n4.match(/<\/?([^\s]+?)[/\s>]/);
  if (i4 && (r4.name = i4[1], (import_void_elements.default[i4[1]] || "/" === n4.charAt(n4.length - 2)) && (r4.voidElement = true), r4.name.startsWith("!--"))) {
    var s5 = n4.indexOf("-->");
    return { type: "comment", comment: -1 !== s5 ? n4.slice(4, s5) : "" };
  }
  for (var a5 = new RegExp(t), c4 = null; null !== (c4 = a5.exec(n4)); )
    if (c4[0].trim())
      if (c4[1]) {
        var o4 = c4[1].trim(), l3 = [o4, ""];
        o4.indexOf("=") > -1 && (l3 = o4.split("=")), r4.attrs[l3[0]] = l3[1], a5.lastIndex--;
      } else
        c4[2] && (r4.attrs[c4[2]] = c4[3].trim().substring(1, c4[3].length - 1));
  return r4;
}
function a2(e5, t4) {
  switch (t4.type) {
    case "text":
      return e5 + t4.content;
    case "tag":
      return e5 += "<" + t4.name + (t4.attrs ? function(e6) {
        var t5 = [];
        for (var n4 in e6)
          t5.push(n4 + '="' + e6[n4] + '"');
        return t5.length ? " " + t5.join(" ") : "";
      }(t4.attrs) : "") + (t4.voidElement ? "/>" : ">"), t4.voidElement ? e5 : e5 + t4.children.reduce(a2, "") + "</" + t4.name + ">";
    case "comment":
      return e5 + "<!--" + t4.comment + "-->";
  }
}
var import_void_elements, t, r2, i2, s2, c2, html_parse_stringify_module_default;
var init_html_parse_stringify_module = __esm({
  "node_modules/html-parse-stringify/dist/html-parse-stringify.module.js"() {
    import_void_elements = __toESM(require_void_elements());
    t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
    r2 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g;
    i2 = /^\s*$/;
    s2 = /* @__PURE__ */ Object.create(null);
    c2 = { parse: function(e5, t4) {
      t4 || (t4 = {}), t4.components || (t4.components = s2);
      var a5, c4 = [], o4 = [], l3 = -1, m4 = false;
      if (0 !== e5.indexOf("<")) {
        var u3 = e5.indexOf("<");
        c4.push({ type: "text", content: -1 === u3 ? e5 : e5.substring(0, u3) });
      }
      return e5.replace(r2, function(r4, s5) {
        if (m4) {
          if (r4 !== "</" + a5.name + ">")
            return;
          m4 = false;
        }
        var u4, f3 = "/" !== r4.charAt(1), h3 = r4.startsWith("<!--"), p2 = s5 + r4.length, d3 = e5.charAt(p2);
        if (h3) {
          var v2 = n(r4);
          return l3 < 0 ? (c4.push(v2), c4) : ((u4 = o4[l3]).children.push(v2), c4);
        }
        if (f3 && (l3++, "tag" === (a5 = n(r4)).type && t4.components[a5.name] && (a5.type = "component", m4 = true), a5.voidElement || m4 || !d3 || "<" === d3 || a5.children.push({ type: "text", content: e5.slice(p2, e5.indexOf("<", p2)) }), 0 === l3 && c4.push(a5), (u4 = o4[l3 - 1]) && u4.children.push(a5), o4[l3] = a5), (!f3 || a5.voidElement) && (l3 > -1 && (a5.voidElement || a5.name === r4.slice(2, -1)) && (l3--, a5 = -1 === l3 ? c4 : o4[l3]), !m4 && "<" !== d3 && d3)) {
          u4 = -1 === l3 ? c4 : o4[l3].children;
          var x3 = e5.indexOf("<", p2), g2 = e5.slice(p2, -1 === x3 ? void 0 : x3);
          i2.test(g2) && (g2 = " "), (x3 > -1 && l3 + u4.length >= 0 || " " !== g2) && u4.push({ type: "text", content: g2 });
        }
      }), c4;
    }, stringify: function(e5) {
      return e5.reduce(function(e6, t4) {
        return e6 + a2("", t4);
      }, "");
    } };
    html_parse_stringify_module_default = c2;
  }
});

// node_modules/react-i18next/dist/es/TransWithoutContext.js
function hasChildren(node5, checkLength) {
  if (!node5)
    return false;
  const base = node5.props ? node5.props.children : node5.children;
  if (checkLength)
    return base.length > 0;
  return !!base;
}
function getChildren(node5) {
  if (!node5)
    return [];
  const children = node5.props ? node5.props.children : node5.children;
  return node5.props && node5.props.i18nIsDynamicList ? getAsArray(children) : children;
}
function hasValidReactChildren(children) {
  if (Object.prototype.toString.call(children) !== "[object Array]")
    return false;
  return children.every((child) => (0, import_react10.isValidElement)(child));
}
function getAsArray(data) {
  return Array.isArray(data) ? data : [data];
}
function mergeProps(source, target) {
  const newTarget = {
    ...target
  };
  newTarget.props = Object.assign(source.props, target.props);
  return newTarget;
}
function nodesToString(children, i18nOptions) {
  if (!children)
    return "";
  let stringNode = "";
  const childrenArray = getAsArray(children);
  const keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
  childrenArray.forEach((child, childIndex) => {
    if (typeof child === "string") {
      stringNode += `${child}`;
    } else if ((0, import_react10.isValidElement)(child)) {
      const childPropsCount = Object.keys(child.props).length;
      const shouldKeepChild = keepArray.indexOf(child.type) > -1;
      const childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0) {
        stringNode += `<${child.type}/>`;
      } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
        stringNode += `<${childIndex}></${childIndex}>`;
      } else if (child.props.i18nIsDynamicList) {
        stringNode += `<${childIndex}></${childIndex}>`;
      } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
        stringNode += `<${child.type}>${childChildren}</${child.type}>`;
      } else {
        const content = nodesToString(childChildren, i18nOptions);
        stringNode += `<${childIndex}>${content}</${childIndex}>`;
      }
    } else if (child === null) {
      warn(`Trans: the passed in value is invalid - seems you passed in a null child.`);
    } else if (typeof child === "object") {
      const {
        format: format4,
        ...clone2
      } = child;
      const keys2 = Object.keys(clone2);
      if (keys2.length === 1) {
        const value = format4 ? `${keys2[0]}, ${format4}` : keys2[0];
        stringNode += `{{${value}}}`;
      } else {
        warn(`react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`, child);
      }
    } else {
      warn(`Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.`, child);
    }
  });
  return stringNode;
}
function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
  if (targetString === "")
    return [];
  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map((keep) => `<${keep}`).join("|")).test(targetString);
  if (!children && !emptyChildrenButNeedsHandling && !shouldUnescape)
    return [targetString];
  const data = {};
  function getData(childs) {
    const childrenArray = getAsArray(childs);
    childrenArray.forEach((child) => {
      if (typeof child === "string")
        return;
      if (hasChildren(child))
        getData(getChildren(child));
      else if (typeof child === "object" && !(0, import_react10.isValidElement)(child))
        Object.assign(data, child);
    });
  }
  getData(children);
  const ast = html_parse_stringify_module_default.parse(`<0>${targetString}</0>`);
  const opts = {
    ...data,
    ...combinedTOpts
  };
  function renderInner(child, node5, rootReactNode) {
    const childs = getChildren(child);
    const mappedChildren = mapAST(childs, node5.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props && child.props.i18nIsDynamicList ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner, mem, i4, isVoid) {
    if (child.dummy) {
      child.children = inner;
      mem.push((0, import_react10.cloneElement)(child, {
        key: i4
      }, isVoid ? void 0 : inner));
    } else {
      mem.push(...import_react10.Children.map([child], (c4) => {
        const props = {
          ...c4.props
        };
        delete props.i18nIsDynamicList;
        return import_react10.default.createElement(c4.type, _extends({}, props, {
          key: i4,
          ref: c4.ref
        }, isVoid ? {} : {
          children: inner
        }));
      }));
    }
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    const reactNodes = getAsArray(reactNode);
    const astNodes = getAsArray(astNode);
    return astNodes.reduce((mem, node5, i4) => {
      const translationContent = node5.children && node5.children[0] && node5.children[0].content && i18n.services.interpolator.interpolate(node5.children[0].content, opts, i18n.language);
      if (node5.type === "tag") {
        let tmp = reactNodes[parseInt(node5.name, 10)];
        if (rootReactNode.length === 1 && !tmp)
          tmp = rootReactNode[0][node5.name];
        if (!tmp)
          tmp = {};
        const child = Object.keys(node5.attrs).length !== 0 ? mergeProps({
          props: node5.attrs
        }, tmp) : tmp;
        const isElement4 = (0, import_react10.isValidElement)(child);
        const isValidTranslationWithChildren = isElement4 && hasChildren(node5, true) && !node5.voidElement;
        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && typeof child === "object" && child.dummy && !isElement4;
        const isKnownComponent = typeof children === "object" && children !== null && Object.hasOwnProperty.call(children, node5.name);
        if (typeof child === "string") {
          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
          mem.push(value);
        } else if (hasChildren(child) || isValidTranslationWithChildren) {
          const inner = renderInner(child, node5, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i4);
        } else if (isEmptyTransWithHTML) {
          const inner = mapAST(reactNodes, node5.children, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i4);
        } else if (Number.isNaN(parseFloat(node5.name))) {
          if (isKnownComponent) {
            const inner = renderInner(child, node5, rootReactNode);
            pushTranslatedJSX(child, inner, mem, i4, node5.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node5.name) > -1) {
            if (node5.voidElement) {
              mem.push((0, import_react10.createElement)(node5.name, {
                key: `${node5.name}-${i4}`
              }));
            } else {
              const inner = mapAST(reactNodes, node5.children, rootReactNode);
              mem.push((0, import_react10.createElement)(node5.name, {
                key: `${node5.name}-${i4}`
              }, inner));
            }
          } else if (node5.voidElement) {
            mem.push(`<${node5.name} />`);
          } else {
            const inner = mapAST(reactNodes, node5.children, rootReactNode);
            mem.push(`<${node5.name}>${inner}</${node5.name}>`);
          }
        } else if (typeof child === "object" && !isElement4) {
          const content = node5.children[0] ? translationContent : null;
          if (content)
            mem.push(content);
        } else {
          pushTranslatedJSX(child, translationContent, mem, i4, node5.children.length !== 1 || !translationContent);
        }
      } else if (node5.type === "text") {
        const wrapTextNodes = i18nOptions.transWrapTextNodes;
        const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node5.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node5.content, opts, i18n.language);
        if (wrapTextNodes) {
          mem.push((0, import_react10.createElement)(wrapTextNodes, {
            key: `${node5.name}-${i4}`
          }, content));
        } else {
          mem.push(content);
        }
      }
      return mem;
    }, []);
  }
  const result = mapAST([{
    dummy: true,
    children: children || []
  }], ast, getAsArray(children || []));
  return getChildren(result[0]);
}
function Trans(_ref2) {
  let {
    children,
    count: count2,
    parent: parent3,
    i18nKey,
    context: context2,
    tOptions = {},
    values,
    defaults: defaults2,
    components,
    ns,
    i18n: i18nFromProps,
    t: tFromProps,
    shouldUnescape,
    ...additionalProps
  } = _ref2;
  const i18n = i18nFromProps || getI18n();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
    return children;
  }
  const t4 = tFromProps || i18n.t.bind(i18n) || ((k3) => k3);
  if (context2)
    tOptions.context = context2;
  const reactI18nextOptions = {
    ...getDefaults(),
    ...i18n.options && i18n.options.react
  };
  let namespaces = ns || t4.ns || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  const nodeAsString = nodesToString(children, reactI18nextOptions);
  const defaultValue2 = defaults2 || nodeAsString || reactI18nextOptions.transEmptyNodeValue || i18nKey;
  const {
    hashTransKey
  } = reactI18nextOptions;
  const key2 = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue2) : nodeAsString || defaultValue2);
  if (i18n.options && i18n.options.interpolation && i18n.options.interpolation.defaultVariables) {
    values = values && Object.keys(values).length > 0 ? {
      ...values,
      ...i18n.options.interpolation.defaultVariables
    } : {
      ...i18n.options.interpolation.defaultVariables
    };
  }
  const interpolationOverride = values ? tOptions.interpolation : {
    interpolation: {
      ...tOptions.interpolation,
      prefix: "#$?",
      suffix: "?$#"
    }
  };
  const combinedTOpts = {
    ...tOptions,
    count: count2,
    ...values,
    ...interpolationOverride,
    defaultValue: defaultValue2,
    ns: namespaces
  };
  const translation = key2 ? t4(key2, combinedTOpts) : defaultValue2;
  if (components) {
    Object.keys(components).forEach((c4) => {
      const comp = components[c4];
      if (typeof comp.type === "function" || !comp.props || !comp.props.children || translation.indexOf(`${c4}/>`) < 0 && translation.indexOf(`${c4} />`) < 0)
        return;
      function Componentized() {
        return import_react10.default.createElement(import_react10.default.Fragment, null, comp);
      }
      components[c4] = import_react10.default.createElement(Componentized, null);
    });
  }
  const content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
  const useAsParent = parent3 !== void 0 ? parent3 : reactI18nextOptions.defaultTransParent;
  return useAsParent ? (0, import_react10.createElement)(useAsParent, additionalProps, content) : content;
}
var import_react10;
var init_TransWithoutContext = __esm({
  "node_modules/react-i18next/dist/es/TransWithoutContext.js"() {
    init_extends();
    import_react10 = __toESM(require_react(), 1);
    init_html_parse_stringify_module();
    init_utils2();
    init_defaults();
    init_i18nInstance();
  }
});

// node_modules/react-i18next/dist/es/Trans.js
function Trans2(_ref2) {
  let {
    children,
    count: count2,
    parent: parent3,
    i18nKey,
    context: context2,
    tOptions = {},
    values,
    defaults: defaults2,
    components,
    ns,
    i18n: i18nFromProps,
    t: tFromProps,
    shouldUnescape,
    ...additionalProps
  } = _ref2;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react11.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  const t4 = tFromProps || i18n && i18n.t.bind(i18n);
  return Trans({
    children,
    count: count2,
    parent: parent3,
    i18nKey,
    context: context2,
    tOptions,
    values,
    defaults: defaults2,
    components,
    ns: ns || t4 && t4.ns || defaultNSFromContext || i18n && i18n.options && i18n.options.defaultNS,
    i18n,
    t: tFromProps,
    shouldUnescape,
    ...additionalProps
  });
}
var import_react11;
var init_Trans = __esm({
  "node_modules/react-i18next/dist/es/Trans.js"() {
    import_react11 = __toESM(require_react(), 1);
    init_TransWithoutContext();
    init_context();
  }
});

// node_modules/react-i18next/dist/es/withTranslation.js
function withTranslation(ns) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function Extend(WrappedComponent) {
    function I18nextWithTranslation(_ref2) {
      let {
        forwardedRef,
        ...rest
      } = _ref2;
      const [t4, i18n, ready] = useTranslation(ns, {
        ...rest,
        keyPrefix: options.keyPrefix
      });
      const passDownProps = {
        ...rest,
        t: t4,
        i18n,
        tReady: ready
      };
      if (options.withRef && forwardedRef) {
        passDownProps.ref = forwardedRef;
      } else if (!options.withRef && forwardedRef) {
        passDownProps.forwardedRef = forwardedRef;
      }
      return (0, import_react12.createElement)(WrappedComponent, passDownProps);
    }
    I18nextWithTranslation.displayName = `withI18nextTranslation(${getDisplayName2(WrappedComponent)})`;
    I18nextWithTranslation.WrappedComponent = WrappedComponent;
    const forwardRef6 = (props, ref) => (0, import_react12.createElement)(I18nextWithTranslation, Object.assign({}, props, {
      forwardedRef: ref
    }));
    return options.withRef ? (0, import_react12.forwardRef)(forwardRef6) : I18nextWithTranslation;
  };
}
var import_react12;
var init_withTranslation = __esm({
  "node_modules/react-i18next/dist/es/withTranslation.js"() {
    import_react12 = __toESM(require_react(), 1);
    init_useTranslation();
    init_utils2();
  }
});

// node_modules/react-i18next/dist/es/Translation.js
function Translation(props) {
  const {
    ns,
    children,
    ...options
  } = props;
  const [t4, i18n, ready] = useTranslation(ns, options);
  return children(t4, {
    i18n,
    lng: i18n.language
  }, ready);
}
var init_Translation = __esm({
  "node_modules/react-i18next/dist/es/Translation.js"() {
    init_useTranslation();
  }
});

// node_modules/react-i18next/dist/es/useSSR.js
function useSSR(initialI18nStore, initialLanguage) {
  let props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext
  } = (0, import_react13.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n.options && i18n.options.isClone)
    return;
  if (initialI18nStore && !i18n.initializedStoreOnce) {
    i18n.services.resourceStore.data = initialI18nStore;
    i18n.options.ns = Object.values(initialI18nStore).reduce((mem, lngResources) => {
      Object.keys(lngResources).forEach((ns) => {
        if (mem.indexOf(ns) < 0)
          mem.push(ns);
      });
      return mem;
    }, i18n.options.ns);
    i18n.initializedStoreOnce = true;
    i18n.isInitialized = true;
  }
  if (initialLanguage && !i18n.initializedLanguageOnce) {
    i18n.changeLanguage(initialLanguage);
    i18n.initializedLanguageOnce = true;
  }
}
var import_react13;
var init_useSSR = __esm({
  "node_modules/react-i18next/dist/es/useSSR.js"() {
    import_react13 = __toESM(require_react(), 1);
    init_context();
  }
});

// node_modules/react-i18next/dist/es/withSSR.js
function withSSR() {
  return function Extend(WrappedComponent) {
    function I18nextWithSSR(_ref2) {
      let {
        initialI18nStore,
        initialLanguage,
        ...rest
      } = _ref2;
      useSSR(initialI18nStore, initialLanguage);
      return (0, import_react14.createElement)(WrappedComponent, {
        ...rest
      });
    }
    I18nextWithSSR.getInitialProps = composeInitialProps(WrappedComponent);
    I18nextWithSSR.displayName = `withI18nextSSR(${getDisplayName2(WrappedComponent)})`;
    I18nextWithSSR.WrappedComponent = WrappedComponent;
    return I18nextWithSSR;
  };
}
var import_react14;
var init_withSSR = __esm({
  "node_modules/react-i18next/dist/es/withSSR.js"() {
    import_react14 = __toESM(require_react(), 1);
    init_useSSR();
    init_context();
    init_utils2();
  }
});

// node_modules/react-i18next/dist/es/index.js
var es_exports = {};
__export(es_exports, {
  I18nContext: () => I18nContext,
  I18nextProvider: () => I18nextProvider,
  Trans: () => Trans2,
  TransWithoutContext: () => Trans,
  Translation: () => Translation,
  composeInitialProps: () => composeInitialProps,
  date: () => date,
  getDefaults: () => getDefaults,
  getI18n: () => getI18n,
  getInitialProps: () => getInitialProps,
  initReactI18next: () => initReactI18next,
  number: () => number,
  plural: () => plural,
  select: () => select,
  selectOrdinal: () => selectOrdinal,
  setDefaults: () => setDefaults,
  setI18n: () => setI18n,
  time: () => time2,
  useSSR: () => useSSR,
  useTranslation: () => useTranslation,
  withSSR: () => withSSR,
  withTranslation: () => withTranslation
});
var date, time2, number, select, plural, selectOrdinal;
var init_es = __esm({
  "node_modules/react-i18next/dist/es/index.js"() {
    init_Trans();
    init_TransWithoutContext();
    init_useTranslation();
    init_withTranslation();
    init_Translation();
    init_I18nextProvider();
    init_withSSR();
    init_useSSR();
    init_initReactI18next();
    init_defaults();
    init_i18nInstance();
    init_context();
    date = () => "";
    time2 = () => "";
    number = () => "";
    select = () => "";
    plural = () => "";
    selectOrdinal = () => "";
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize3(func2, resolver) {
      if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
        if (cache3.has(key2)) {
          return cache3.get(key2);
        }
        var result = func2.apply(this, args);
        memoized.cache = cache3.set(key2, result) || cache3;
        return result;
      };
      memoized.cache = new (memoize3.Cache || MapCache)();
      return memoized;
    }
    memoize3.Cache = MapCache;
    module2.exports = memoize3;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module2) {
    var isArray5 = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray5(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    module2.exports = isKey;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module2) {
    var memoize3 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func2) {
      var result = memoize3(func2, function(key2) {
        if (cache3.size === MAX_MEMOIZE_SIZE) {
          cache3.clear();
        }
        return key2;
      });
      var cache3 = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string4) {
      var result = [];
      if (string4.charCodeAt(0) === 46) {
        result.push("");
      }
      string4.replace(rePropName, function(match5, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match5);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module2) {
    function arrayMap(array, iteratee) {
      var index3 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index3 < length2) {
        result[index3] = iteratee(array[index3], index3, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray5 = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray5(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module2) {
    var baseToString = require_baseToString();
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString2;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module2) {
    var isArray5 = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString2 = require_toString();
    function castPath(value, object2) {
      if (isArray5(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString2(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object2, path3) {
      path3 = castPath(path3, object2);
      var index3 = 0, length2 = path3.length;
      while (object2 != null && index3 < length2) {
        object2 = object2[toKey(path3[index3++])];
      }
      return index3 && index3 == length2 ? object2 : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module2) {
    var baseGet = require_baseGet();
    function get2(object2, path3, defaultValue2) {
      var result = object2 == null ? void 0 : baseGet(object2, path3);
      return result === void 0 ? defaultValue2 : result;
    }
    module2.exports = get2;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module2) {
    function identity2(value) {
      return value;
    }
    module2.exports = identity2;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray5 = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray5(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index3 = -1, length2 = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index3 < length2) {
        var value = array[index3];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index3 = matchData.length, length2 = index3, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index3--) {
        var data = matchData[index3];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index3 < length2) {
        data = matchData[index3];
        var key2 = data[0], objValue = object2[key2], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key2 in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key2, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module2) {
    var isObject4 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject4(value);
    }
    module2.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys2 = require_keys();
    function getMatchData(object2) {
      var result = keys2(object2), length2 = result.length;
      while (length2--) {
        var key2 = result[length2], value = object2[key2];
        result[length2] = [key2, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module2) {
    function matchesStrictComparable(key2, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object2));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module2) {
    function baseHasIn(object2, key2) {
      return object2 != null && key2 in Object(object2);
    }
    module2.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray5 = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath3(object2, path3, hasFunc) {
      path3 = castPath(path3, object2);
      var index3 = -1, length2 = path3.length, result = false;
      while (++index3 < length2) {
        var key2 = toKey(path3[index3]);
        if (!(result = object2 != null && hasFunc(object2, key2))) {
          break;
        }
        object2 = object2[key2];
      }
      if (result || ++index3 != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray5(object2) || isArguments(object2));
    }
    module2.exports = hasPath3;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath3 = require_hasPath();
    function hasIn(object2, path3) {
      return object2 != null && hasPath3(object2, path3, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get2 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path3, srcValue) {
      if (isKey(path3) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path3), srcValue);
      }
      return function(object2) {
        var objValue = get2(object2, path3);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path3) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module2) {
    function baseProperty(key2) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key2];
      };
    }
    module2.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path3) {
      return function(object2) {
        return baseGet(object2, path3);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path3) {
      return isKey(path3) ? baseProperty(toKey(path3)) : basePropertyDeep(path3);
    }
    module2.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity2 = require_identity();
    var isArray5 = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity2;
      }
      if (typeof value == "object") {
        return isArray5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module2) {
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index3 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
        while (length2--) {
          var key2 = props[fromRight ? length2 : ++index3];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module2.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports, module2) {
    var baseFor = require_baseFor();
    var keys2 = require_keys();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys2);
    }
    module2.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports, module2) {
    var isArrayLike2 = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike2(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length2 = collection.length, index3 = fromRight ? length2 : -1, iterable = Object(collection);
        while (fromRight ? index3-- : ++index3 < length2) {
          if (iteratee(iterable[index3], index3, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports, module2) {
    var baseEach = require_baseEach();
    var isArrayLike2 = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index3 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key2, collection2) {
        result[++index3] = iteratee(value, key2, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module2) {
    function baseSortBy(array, comparer) {
      var length2 = array.length;
      array.sort(comparer);
      while (length2--) {
        array[length2] = array[length2].value;
      }
      return array;
    }
    module2.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module2) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module2.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module2) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object2, other, orders) {
      var index3 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
      while (++index3 < length2) {
        var result = compareAscending(objCriteria[index3], othCriteria[index3]);
        if (result) {
          if (index3 >= ordersLength) {
            return result;
          }
          var order = orders[index3];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object2.index - other.index;
    }
    module2.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity2 = require_identity();
    var isArray5 = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray5(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity2];
      }
      var index3 = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key2, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index3, "value": value };
      });
      return baseSortBy(result, function(object2, other) {
        return compareMultiple(object2, other, orders);
      });
    }
    module2.exports = baseOrderBy;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module2) {
    function apply2(func2, thisArg, args) {
      switch (args.length) {
        case 0:
          return func2.call(thisArg);
        case 1:
          return func2.call(thisArg, args[0]);
        case 2:
          return func2.call(thisArg, args[0], args[1]);
        case 3:
          return func2.call(thisArg, args[0], args[1], args[2]);
      }
      return func2.apply(thisArg, args);
    }
    module2.exports = apply2;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module2) {
    var apply2 = require_apply();
    var nativeMax = Math.max;
    function overRest(func2, start2, transform) {
      start2 = nativeMax(start2 === void 0 ? func2.length - 1 : start2, 0);
      return function() {
        var args = arguments, index3 = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
        while (++index3 < length2) {
          array[index3] = args[start2 + index3];
        }
        index3 = -1;
        var otherArgs = Array(start2 + 1);
        while (++index3 < start2) {
          otherArgs[index3] = args[index3];
        }
        otherArgs[start2] = transform(array);
        return apply2(func2, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func2 = getNative(Object, "defineProperty");
        func2({}, "", {});
        return func2;
      } catch (e5) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity2 = require_identity();
    var baseSetToString = !defineProperty ? identity2 : function(func2, string4) {
      return defineProperty(func2, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string4),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func2) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func2.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module2) {
    var identity2 = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func2, start2) {
      return setToString(overRest(func2, start2, identity2), func2 + "");
    }
    module2.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module2) {
    var eq = require_eq();
    var isArrayLike2 = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject4 = require_isObject();
    function isIterateeCall(value, index3, object2) {
      if (!isObject4(object2)) {
        return false;
      }
      var type = typeof index3;
      if (type == "number" ? isArrayLike2(object2) && isIndex(index3, object2.length) : type == "string" && index3 in object2) {
        return eq(object2[index3], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length2 = iteratees.length;
      if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module2.exports = sortBy;
  }
});

// node_modules/shallow-equals/index.js
var require_shallow_equals = __commonJS({
  "node_modules/shallow-equals/index.js"(exports, module2) {
    module2.exports = shallow;
    function shallow(a5, b3, compare) {
      var aIsNull = a5 === null;
      var bIsNull = b3 === null;
      if (aIsNull !== bIsNull)
        return false;
      var aIsArray = Array.isArray(a5);
      var bIsArray = Array.isArray(b3);
      if (aIsArray !== bIsArray)
        return false;
      var aTypeof = typeof a5;
      var bTypeof = typeof b3;
      if (aTypeof !== bTypeof)
        return false;
      if (flat(aTypeof))
        return compare ? compare(a5, b3) : a5 === b3;
      return aIsArray ? shallowArray(a5, b3, compare) : shallowObject(a5, b3, compare);
    }
    function shallowArray(a5, b3, compare) {
      var l3 = a5.length;
      if (l3 !== b3.length)
        return false;
      if (compare) {
        for (var i4 = 0; i4 < l3; i4++)
          if (!compare(a5[i4], b3[i4]))
            return false;
      } else {
        for (var i4 = 0; i4 < l3; i4++) {
          if (a5[i4] !== b3[i4])
            return false;
        }
      }
      return true;
    }
    function shallowObject(a5, b3, compare) {
      var ka = 0;
      var kb = 0;
      if (compare) {
        for (var key2 in a5) {
          if (a5.hasOwnProperty(key2) && !compare(a5[key2], b3[key2]))
            return false;
          ka++;
        }
      } else {
        for (var key2 in a5) {
          if (a5.hasOwnProperty(key2) && a5[key2] !== b3[key2])
            return false;
          ka++;
        }
      }
      for (var key2 in b3) {
        if (b3.hasOwnProperty(key2))
          kb++;
      }
      return ka === kb;
    }
    function flat(type) {
      return type !== "function" && type !== "object";
    }
  }
});

// node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "node_modules/lodash/_asciiWords.js"(exports, module2) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string4) {
      return string4.match(reAsciiWord) || [];
    }
    module2.exports = asciiWords;
  }
});

// node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "node_modules/lodash/_hasUnicodeWord.js"(exports, module2) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string4) {
      return reHasUnicodeWord.test(string4);
    }
    module2.exports = hasUnicodeWord;
  }
});

// node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "node_modules/lodash/_unicodeWords.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string4) {
      return string4.match(reUnicodeWord) || [];
    }
    module2.exports = unicodeWords;
  }
});

// node_modules/lodash/words.js
var require_words = __commonJS({
  "node_modules/lodash/words.js"(exports, module2) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString2 = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string4, pattern, guard3) {
      string4 = toString2(string4);
      pattern = guard3 ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string4) ? unicodeWords(string4) : asciiWords(string4);
      }
      return string4.match(pattern) || [];
    }
    module2.exports = words;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module2) {
    function baseSlice(array, start2, end2) {
      var index3 = -1, length2 = array.length;
      if (start2 < 0) {
        start2 = -start2 > length2 ? 0 : length2 + start2;
      }
      end2 = end2 > length2 ? length2 : end2;
      if (end2 < 0) {
        end2 += length2;
      }
      length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
      start2 >>>= 0;
      var result = Array(length2);
      while (++index3 < length2) {
        result[index3] = array[index3 + start2];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start2, end2) {
      var length2 = array.length;
      end2 = end2 === void 0 ? length2 : end2;
      return !start2 && end2 >= length2 ? array : baseSlice(array, start2, end2);
    }
    module2.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string4) {
      return reHasUnicode.test(string4);
    }
    module2.exports = hasUnicode;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports, module2) {
    function asciiToArray(string4) {
      return string4.split("");
    }
    module2.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string4) {
      return string4.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string4) {
      return hasUnicode(string4) ? unicodeToArray(string4) : asciiToArray(string4);
    }
    module2.exports = stringToArray;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString2 = require_toString();
    function createCaseFirst(methodName) {
      return function(string4) {
        string4 = toString2(string4);
        var strSymbols = hasUnicode(string4) ? stringToArray(string4) : void 0;
        var chr = strSymbols ? strSymbols[0] : string4.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string4.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[++index3];
      }
      while (++index3 < length2) {
        accumulator = iteratee(accumulator, array[index3], index3, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports, module2) {
    function basePropertyOf(object2) {
      return function(key2) {
        return object2 == null ? void 0 : object2[key2];
      };
    }
    module2.exports = basePropertyOf;
  }
});

// node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "node_modules/lodash/_deburrLetter.js"(exports, module2) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module2.exports = deburrLetter;
  }
});

// node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "node_modules/lodash/deburr.js"(exports, module2) {
    var deburrLetter = require_deburrLetter();
    var toString2 = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string4) {
      string4 = toString2(string4);
      return string4 && string4.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module2.exports = deburr;
  }
});

// node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "node_modules/lodash/_createCompounder.js"(exports, module2) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "[']";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string4) {
        return arrayReduce(words(deburr(string4).replace(reApos, "")), callback, "");
      };
    }
    module2.exports = createCompounder;
  }
});

// node_modules/lodash/startCase.js
var require_startCase = __commonJS({
  "node_modules/lodash/startCase.js"(exports, module2) {
    var createCompounder = require_createCompounder();
    var upperFirst = require_upperFirst();
    var startCase = createCompounder(function(result, word, index3) {
      return result + (index3 ? " " : "") + upperFirst(word);
    });
    module2.exports = startCase;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s5 = 1e3;
    var m4 = s5 * 60;
    var h3 = m4 * 60;
    var d3 = h3 * 24;
    var w3 = d3 * 7;
    var y4 = d3 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match5 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match5) {
        return;
      }
      var n4 = parseFloat(match5[1]);
      var type = (match5[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n4 * y4;
        case "weeks":
        case "week":
        case "w":
          return n4 * w3;
        case "days":
        case "day":
        case "d":
          return n4 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n4 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n4 * m4;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n4 * s5;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n4;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m4) {
        return Math.round(ms / m4) + "m";
      }
      if (msAbs >= s5) {
        return Math.round(ms / s5) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural2(ms, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural2(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m4) {
        return plural2(ms, msAbs, m4, "minute");
      }
      if (msAbs >= s5) {
        return plural2(ms, msAbs, s5, "second");
      }
      return ms + " ms";
    }
    function plural2(ms, msAbs, n4, name) {
      var isPlural = msAbs >= n4 * 1.5;
      return Math.round(ms / n4) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/sanity/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/sanity/node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env2).forEach(function(key2) {
        createDebug[key2] = env2[key2];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        var hash2 = 0;
        for (var i4 = 0; i4 < namespace.length; i4++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i4);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        var prevTime;
        function debug3() {
          if (!debug3.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug3;
          var curr = Number(/* @__PURE__ */ new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index3 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match5, format4) {
            if (match5 === "%%") {
              return match5;
            }
            index3++;
            var formatter = createDebug.formatters[format4];
            if (typeof formatter === "function") {
              var val = args[index3];
              match5 = formatter.call(self2, val);
              args.splice(index3, 1);
              index3--;
            }
            return match5;
          });
          createDebug.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.enabled = createDebug.enabled(namespace);
        debug3.useColors = createDebug.useColors();
        debug3.color = selectColor(namespace);
        debug3.destroy = destroy;
        debug3.extend = extend2;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        createDebug.instances.push(debug3);
        return debug3;
      }
      function destroy() {
        var index3 = createDebug.instances.indexOf(this);
        if (index3 !== -1) {
          createDebug.instances.splice(index3, 1);
          return true;
        }
        return false;
      }
      function extend2(namespace, delimiter2) {
        return createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i4;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i4 = 0; i4 < createDebug.instances.length; i4++) {
          var instance = createDebug.instances[i4];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i4;
        var len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/sanity/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/sanity/node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    function _typeof4(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof4 = function _typeof5(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof4 = function _typeof5(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof4(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      var index3 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match5) {
        if (match5 === "%%") {
          return;
        }
        index3++;
        if (match5 === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c4);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof4(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r4;
      try {
        r4 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r4 && typeof process !== "undefined" && "env" in process) {
        r4 = process.env.DEBUG;
      }
      return r4;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var formatters3 = module2.exports.formatters;
    formatters3.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index3 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index3-- : ++index3 < length2) {
        if (predicate(array[index3], index3, array)) {
          return index3;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index3 = fromIndex - 1, length2 = array.length;
      while (++index3 < length2) {
        if (array[index3] === value) {
          return index3;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length2 = array == null ? 0 : array.length;
      return !!length2 && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      while (++index3 < length2) {
        if (comparator(value, array[index3])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index3 = -1, includes = arrayIncludes, isCommon = true, length2 = array.length, result = [], valuesLength = values.length;
      if (!length2) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index3 < length2) {
          var value = array[index3], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module2) {
    var isArrayLike2 = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/difference.js
var require_difference = __commonJS({
  "node_modules/lodash/difference.js"(exports, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// node_modules/lodash/_baseIntersection.js
var require_baseIntersection = __commonJS({
  "node_modules/lodash/_baseIntersection.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var nativeMin = Math.min;
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
      }
      array = arrays[0];
      var index3 = -1, seen = caches[0];
      outer:
        while (++index3 < length2 && result.length < maxLength) {
          var value = array[index3], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache3 = caches[othIndex];
              if (!(cache3 ? cacheHas(cache3, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseIntersection;
  }
});

// node_modules/lodash/_castArrayLikeObject.js
var require_castArrayLikeObject = __commonJS({
  "node_modules/lodash/_castArrayLikeObject.js"(exports, module2) {
    var isArrayLikeObject = require_isArrayLikeObject();
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    module2.exports = castArrayLikeObject;
  }
});

// node_modules/lodash/intersection.js
var require_intersection = __commonJS({
  "node_modules/lodash/intersection.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    module2.exports = intersection;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var objectCtorString2 = funcToString.call(Object);
    function isPlainObject3(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto2 = getPrototype(value);
      if (proto2 === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString2;
    }
    module2.exports = isPlainObject3;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object2, key2, value) {
      if (key2 == "__proto__" && defineProperty) {
        defineProperty(object2, key2, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key2] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function assignValue(object2, key2, value) {
      var objValue = object2[key2];
      if (!(hasOwnProperty.call(object2, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object2)) {
        baseAssignValue(object2, key2, value);
      }
    }
    module2.exports = assignValue;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject4 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object2, path3, value, customizer) {
      if (!isObject4(object2)) {
        return object2;
      }
      path3 = castPath(path3, object2);
      var index3 = -1, length2 = path3.length, lastIndex = length2 - 1, nested = object2;
      while (nested != null && ++index3 < length2) {
        var key2 = toKey(path3[index3]), newValue = value;
        if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
          return object2;
        }
        if (index3 != lastIndex) {
          var objValue = nested[key2];
          newValue = customizer ? customizer(objValue, key2, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject4(objValue) ? objValue : isIndex(path3[index3 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key2, newValue);
        nested = nested[key2];
      }
      return object2;
    }
    module2.exports = baseSet;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object2, paths, predicate) {
      var index3 = -1, length2 = paths.length, result = {};
      while (++index3 < length2) {
        var path3 = paths[index3], value = baseGet(object2, path3);
        if (predicate(value, path3)) {
          baseSet(result, castPath(path3, object2), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module2) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object2, paths) {
      return basePickBy(object2, paths, function(value, path3) {
        return hasIn(object2, path3);
      });
    }
    module2.exports = basePick;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module2) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func2) {
      return setToString(overRest(func2, void 0, flatten), func2 + "");
    }
    module2.exports = flatRest;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module2) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object2, paths) {
      return object2 == null ? {} : basePick(object2, paths);
    });
    module2.exports = pick;
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key2 = sourceKeys[i4];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var init_objectWithoutPropertiesLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
  }
});

// node_modules/focus-lock/dist/es2015/constants.js
var FOCUS_GROUP, FOCUS_DISABLED, FOCUS_ALLOW, FOCUS_AUTO, FOCUS_NO_AUTOFOCUS;
var init_constants = __esm({
  "node_modules/focus-lock/dist/es2015/constants.js"() {
    FOCUS_GROUP = "data-focus-lock";
    FOCUS_DISABLED = "data-focus-lock-disabled";
    FOCUS_ALLOW = "data-no-focus-lock";
    FOCUS_AUTO = "data-autofocus-inside";
    FOCUS_NO_AUTOFOCUS = "data-no-autofocus";
  }
});

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
var init_assignRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/assignRef.js"() {
  }
});

// node_modules/use-callback-ref/dist/es2015/useRef.js
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react15.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last5 = ref.value;
          if (last5 !== value) {
            ref.value = value;
            ref.callback(value, last5);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var import_react15;
var init_useRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/useRef.js"() {
    import_react15 = __toESM(require_react());
  }
});

// node_modules/use-callback-ref/dist/es2015/createRef.js
var init_createRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/createRef.js"() {
  }
});

// node_modules/use-callback-ref/dist/es2015/mergeRef.js
var init_mergeRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/mergeRef.js"() {
    init_assignRef();
    init_createRef();
  }
});

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
function useMergeRefs(refs, defaultValue2) {
  return useCallbackRef(defaultValue2 || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
var init_useMergeRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/useMergeRef.js"() {
    init_assignRef();
    init_useRef();
  }
});

// node_modules/use-callback-ref/dist/es2015/useTransformRef.js
var init_useTransformRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/useTransformRef.js"() {
    init_assignRef();
    init_useRef();
  }
});

// node_modules/use-callback-ref/dist/es2015/transformRef.js
var init_transformRef = __esm({
  "node_modules/use-callback-ref/dist/es2015/transformRef.js"() {
    init_assignRef();
    init_createRef();
  }
});

// node_modules/use-callback-ref/dist/es2015/refToCallback.js
var init_refToCallback = __esm({
  "node_modules/use-callback-ref/dist/es2015/refToCallback.js"() {
  }
});

// node_modules/use-callback-ref/dist/es2015/index.js
var init_es2015 = __esm({
  "node_modules/use-callback-ref/dist/es2015/index.js"() {
    init_assignRef();
    init_useRef();
    init_createRef();
    init_mergeRef();
    init_useMergeRef();
    init_useTransformRef();
    init_transformRef();
    init_refToCallback();
  }
});

// node_modules/react-focus-lock/dist/es2015/FocusGuard.js
var React2, import_prop_types, hiddenGuard, InFocusGuard, FocusGuard_default;
var init_FocusGuard = __esm({
  "node_modules/react-focus-lock/dist/es2015/FocusGuard.js"() {
    React2 = __toESM(require_react());
    import_prop_types = __toESM(require_prop_types());
    hiddenGuard = {
      width: "1px",
      height: "0px",
      padding: 0,
      overflow: "hidden",
      position: "fixed",
      top: "1px",
      left: "1px"
    };
    InFocusGuard = function InFocusGuard2(_ref2) {
      var children = _ref2.children;
      return React2.createElement(React2.Fragment, null, React2.createElement("div", {
        key: "guard-first",
        "data-focus-guard": true,
        "data-focus-auto-guard": true,
        style: hiddenGuard
      }), children, children && React2.createElement("div", {
        key: "guard-last",
        "data-focus-guard": true,
        "data-focus-auto-guard": true,
        style: hiddenGuard
      }));
    };
    InFocusGuard.propTypes = true ? {
      children: import_prop_types.default.node
    } : {};
    InFocusGuard.defaultProps = {
      children: null
    };
    FocusGuard_default = InFocusGuard;
  }
});

// node_modules/detect-node-es/esm/browser.js
var init_browser = __esm({
  "node_modules/detect-node-es/esm/browser.js"() {
  }
});

// node_modules/use-sidecar/dist/es2015/env.js
var init_env = __esm({
  "node_modules/use-sidecar/dist/es2015/env.js"() {
    init_browser();
  }
});

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react16;
var init_hook = __esm({
  "node_modules/use-sidecar/dist/es2015/hook.js"() {
    import_react16 = __toESM(require_react());
    init_env();
  }
});

// node_modules/use-sidecar/dist/es2015/hoc.js
var React3;
var init_hoc = __esm({
  "node_modules/use-sidecar/dist/es2015/hoc.js"() {
    init_tslib_es6();
    React3 = __toESM(require_react());
    init_hook();
  }
});

// node_modules/use-sidecar/dist/es2015/config.js
var init_config2 = __esm({
  "node_modules/use-sidecar/dist/es2015/config.js"() {
  }
});

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a5) {
  return a5;
}
function innerCreateMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer2.push(item);
      return function() {
        buffer2 = buffer2.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
      }
      buffer2 = {
        push: function(x3) {
          return cb(x3);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter3) {
          pendingQueue = pendingQueue.filter(filter3);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  return innerCreateMedium(defaults2, middleware2);
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var init_medium = __esm({
  "node_modules/use-sidecar/dist/es2015/medium.js"() {
    init_tslib_es6();
  }
});

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React4, import_react17;
var init_renderProp = __esm({
  "node_modules/use-sidecar/dist/es2015/renderProp.js"() {
    init_tslib_es6();
    React4 = __toESM(require_react());
    import_react17 = __toESM(require_react());
  }
});

// node_modules/use-sidecar/dist/es2015/exports.js
var React5, SideCar;
var init_exports = __esm({
  "node_modules/use-sidecar/dist/es2015/exports.js"() {
    init_tslib_es6();
    React5 = __toESM(require_react());
    SideCar = function(_a) {
      var sideCar2 = _a.sideCar, rest = __rest(_a, ["sideCar"]);
      if (!sideCar2) {
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
      }
      var Target = sideCar2.read();
      if (!Target) {
        throw new Error("Sidecar medium not found");
      }
      return React5.createElement(Target, __assign({}, rest));
    };
    SideCar.isSideCarExport = true;
  }
});

// node_modules/use-sidecar/dist/es2015/index.js
var init_es20152 = __esm({
  "node_modules/use-sidecar/dist/es2015/index.js"() {
    init_hoc();
    init_hook();
    init_config2();
    init_medium();
    init_renderProp();
    init_exports();
  }
});

// node_modules/react-focus-lock/dist/es2015/medium.js
var mediumFocus, mediumBlur, mediumEffect, mediumSidecar;
var init_medium2 = __esm({
  "node_modules/react-focus-lock/dist/es2015/medium.js"() {
    init_es20152();
    mediumFocus = createMedium({}, function(_ref2) {
      var target = _ref2.target, currentTarget = _ref2.currentTarget;
      return {
        target,
        currentTarget
      };
    });
    mediumBlur = createMedium();
    mediumEffect = createMedium();
    mediumSidecar = createSidecarMedium({
      async: true
      // focus-lock sidecar is not required on the server
      // however, it might be required for JSDOM tests
      // ssr: true,
    });
  }
});

// node_modules/react-focus-lock/dist/es2015/Lock.js
var React6, import_prop_types2, import_react18, emptyArray, FocusLock, Lock_default;
var init_Lock = __esm({
  "node_modules/react-focus-lock/dist/es2015/Lock.js"() {
    init_extends();
    React6 = __toESM(require_react());
    import_prop_types2 = __toESM(require_prop_types());
    init_constants();
    init_es2015();
    import_react18 = __toESM(require_react());
    init_FocusGuard();
    init_medium2();
    emptyArray = [];
    FocusLock = React6.forwardRef(function FocusLockUI(props, parentRef) {
      var _extends22;
      var _React$useState = React6.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
      var observed = React6.useRef();
      var isActive = React6.useRef(false);
      var originalFocusedElement = React6.useRef(null);
      var children = props.children, disabled = props.disabled, noFocusGuards = props.noFocusGuards, persistentFocus = props.persistentFocus, crossFrame = props.crossFrame, autoFocus = props.autoFocus, allowTextSelection = props.allowTextSelection, group = props.group, className = props.className, whiteList = props.whiteList, hasPositiveIndices = props.hasPositiveIndices, _props$shards = props.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props.as, Container = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar2 = props.sideCar, shouldReturnFocus = props.returnFocus, focusOptions = props.focusOptions, onActivationCallback = props.onActivation, onDeactivationCallback = props.onDeactivation;
      var _React$useState2 = React6.useState({}), id2 = _React$useState2[0];
      var onActivation = React6.useCallback(function() {
        originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
        if (observed.current && onActivationCallback) {
          onActivationCallback(observed.current);
        }
        isActive.current = true;
      }, [onActivationCallback]);
      var onDeactivation = React6.useCallback(function() {
        isActive.current = false;
        if (onDeactivationCallback) {
          onDeactivationCallback(observed.current);
        }
      }, [onDeactivationCallback]);
      (0, import_react18.useEffect)(function() {
        if (!disabled) {
          originalFocusedElement.current = null;
        }
      }, []);
      var returnFocus = React6.useCallback(function(allowDefer) {
        var returnFocusTo = originalFocusedElement.current;
        if (returnFocusTo && returnFocusTo.focus) {
          var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
          if (howToReturnFocus) {
            var returnFocusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
            originalFocusedElement.current = null;
            if (allowDefer) {
              Promise.resolve().then(function() {
                return returnFocusTo.focus(returnFocusOptions);
              });
            } else {
              returnFocusTo.focus(returnFocusOptions);
            }
          }
        }
      }, [shouldReturnFocus]);
      var onFocus3 = React6.useCallback(function(event) {
        if (isActive.current) {
          mediumFocus.useMedium(event);
        }
      }, []);
      var onBlur3 = mediumBlur.useMedium;
      var setObserveNode = React6.useCallback(function(newObserved) {
        if (observed.current !== newObserved) {
          observed.current = newObserved;
          setObserved(newObserved);
        }
      }, []);
      if (true) {
        if (typeof allowTextSelection !== "undefined") {
          console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default");
        }
        React6.useEffect(function() {
          if (!observed.current && typeof Container !== "string") {
            console.error("FocusLock: could not obtain ref to internal node");
          }
        }, []);
      }
      var lockProps = _extends((_extends22 = {}, _extends22[FOCUS_DISABLED] = disabled && "disabled", _extends22[FOCUS_GROUP] = group, _extends22), containerProps);
      var hasLeadingGuards = noFocusGuards !== true;
      var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
      var mergedRef = useMergeRefs([parentRef, setObserveNode]);
      return React6.createElement(React6.Fragment, null, hasLeadingGuards && [
        // nearest focus guard
        React6.createElement("div", {
          key: "guard-first",
          "data-focus-guard": true,
          tabIndex: disabled ? -1 : 0,
          style: hiddenGuard
        }),
        // first tabbed element guard
        hasPositiveIndices ? React6.createElement("div", {
          key: "guard-nearest",
          "data-focus-guard": true,
          tabIndex: disabled ? -1 : 1,
          style: hiddenGuard
        }) : null
      ], !disabled && React6.createElement(SideCar2, {
        id: id2,
        sideCar: mediumSidecar,
        observed: realObserved,
        disabled,
        persistentFocus,
        crossFrame,
        autoFocus,
        whiteList,
        shards,
        onActivation,
        onDeactivation,
        returnFocus,
        focusOptions
      }), React6.createElement(Container, _extends({
        ref: mergedRef
      }, lockProps, {
        className,
        onBlur: onBlur3,
        onFocus: onFocus3
      }), children), hasTailingGuards && React6.createElement("div", {
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hiddenGuard
      }));
    });
    FocusLock.propTypes = true ? {
      children: import_prop_types2.node,
      disabled: import_prop_types2.bool,
      returnFocus: (0, import_prop_types2.oneOfType)([import_prop_types2.bool, import_prop_types2.object, import_prop_types2.func]),
      focusOptions: import_prop_types2.object,
      noFocusGuards: import_prop_types2.bool,
      hasPositiveIndices: import_prop_types2.bool,
      allowTextSelection: import_prop_types2.bool,
      autoFocus: import_prop_types2.bool,
      persistentFocus: import_prop_types2.bool,
      crossFrame: import_prop_types2.bool,
      group: import_prop_types2.string,
      className: import_prop_types2.string,
      whiteList: import_prop_types2.func,
      shards: (0, import_prop_types2.arrayOf)(import_prop_types2.any),
      as: (0, import_prop_types2.oneOfType)([import_prop_types2.string, import_prop_types2.func, import_prop_types2.object]),
      lockProps: import_prop_types2.object,
      onActivation: import_prop_types2.func,
      onDeactivation: import_prop_types2.func,
      sideCar: import_prop_types2.any.isRequired
    } : {};
    FocusLock.defaultProps = {
      children: void 0,
      disabled: false,
      returnFocus: false,
      focusOptions: void 0,
      noFocusGuards: false,
      autoFocus: true,
      persistentFocus: false,
      crossFrame: true,
      hasPositiveIndices: void 0,
      allowTextSelection: void 0,
      group: void 0,
      className: void 0,
      whiteList: void 0,
      shards: void 0,
      as: "div",
      lockProps: {},
      onActivation: void 0,
      onDeactivation: void 0
    };
    Lock_default = FocusLock;
  }
});

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o4, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p3) {
    o5.__proto__ = p3;
    return o5;
  };
  return _setPrototypeOf(o4, p2);
}
var init_setPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var init_inheritsLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/inheritsLoose.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o4) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof(o4);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return _typeof(key2) === "symbol" ? key2 : String(key2);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/react-clientside-effect/lib/index.es.js
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  if (true) {
    if (typeof reducePropsToState2 !== "function") {
      throw new Error("Expected reducePropsToState to be a function.");
    }
    if (typeof handleStateChangeOnClient2 !== "function") {
      throw new Error("Expected handleStateChangeOnClient to be a function.");
    }
  }
  function getDisplayName3(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap(WrappedComponent) {
    if (true) {
      if (typeof WrappedComponent !== "function") {
        throw new Error("Expected WrappedComponent to be a React component.");
      }
    }
    var mountedInstances = [];
    var state;
    function emitChange() {
      state = reducePropsToState2(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      handleStateChangeOnClient2(state);
    }
    var SideEffect = function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek3() {
        return state;
      };
      var _proto = SideEffect2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index3 = mountedInstances.indexOf(this);
        mountedInstances.splice(index3, 1);
        emitChange();
      };
      _proto.render = function render() {
        return import_react19.default.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(import_react19.PureComponent);
    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName3(WrappedComponent) + ")");
    return SideEffect;
  };
}
var import_react19, index_es_default;
var init_index_es = __esm({
  "node_modules/react-clientside-effect/lib/index.es.js"() {
    init_inheritsLoose();
    init_defineProperty();
    import_react19 = __toESM(require_react());
    index_es_default = withSideEffect;
  }
});

// node_modules/focus-lock/dist/es2015/utils/array.js
var toArray2, asArray, getFirst;
var init_array = __esm({
  "node_modules/focus-lock/dist/es2015/utils/array.js"() {
    toArray2 = function(a5) {
      var ret = Array(a5.length);
      for (var i4 = 0; i4 < a5.length; ++i4) {
        ret[i4] = a5[i4];
      }
      return ret;
    };
    asArray = function(a5) {
      return Array.isArray(a5) ? a5 : [a5];
    };
    getFirst = function(a5) {
      return Array.isArray(a5) ? a5[0] : a5;
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/is.js
var isElementHidden, getParentNode, isTopNode, isVisibleUncached, isVisibleCached, isAutoFocusAllowedUncached, isAutoFocusAllowedCached, getDataset, isHTMLButtonElement, isHTMLInputElement, isRadioElement, notHiddenInput, isAutoFocusAllowed, isGuard, isNotAGuard, isDefined;
var init_is = __esm({
  "node_modules/focus-lock/dist/es2015/utils/is.js"() {
    init_constants();
    isElementHidden = function(node5) {
      if (node5.nodeType !== Node.ELEMENT_NODE) {
        return false;
      }
      var computedStyle = window.getComputedStyle(node5, null);
      if (!computedStyle || !computedStyle.getPropertyValue) {
        return false;
      }
      return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
    };
    getParentNode = function(node5) {
      return node5.parentNode && node5.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        node5.parentNode.host
      ) : node5.parentNode;
    };
    isTopNode = function(node5) {
      return node5 === document || node5 && node5.nodeType === Node.DOCUMENT_NODE;
    };
    isVisibleUncached = function(node5, checkParent) {
      return !node5 || isTopNode(node5) || !isElementHidden(node5) && checkParent(getParentNode(node5));
    };
    isVisibleCached = function(visibilityCache, node5) {
      var cached = visibilityCache.get(node5);
      if (cached !== void 0) {
        return cached;
      }
      var result = isVisibleUncached(node5, isVisibleCached.bind(void 0, visibilityCache));
      visibilityCache.set(node5, result);
      return result;
    };
    isAutoFocusAllowedUncached = function(node5, checkParent) {
      return node5 && !isTopNode(node5) ? isAutoFocusAllowed(node5) ? checkParent(getParentNode(node5)) : false : true;
    };
    isAutoFocusAllowedCached = function(cache3, node5) {
      var cached = cache3.get(node5);
      if (cached !== void 0) {
        return cached;
      }
      var result = isAutoFocusAllowedUncached(node5, isAutoFocusAllowedCached.bind(void 0, cache3));
      cache3.set(node5, result);
      return result;
    };
    getDataset = function(node5) {
      return node5.dataset;
    };
    isHTMLButtonElement = function(node5) {
      return node5.tagName === "BUTTON";
    };
    isHTMLInputElement = function(node5) {
      return node5.tagName === "INPUT";
    };
    isRadioElement = function(node5) {
      return isHTMLInputElement(node5) && node5.type === "radio";
    };
    notHiddenInput = function(node5) {
      return !((isHTMLInputElement(node5) || isHTMLButtonElement(node5)) && (node5.type === "hidden" || node5.disabled));
    };
    isAutoFocusAllowed = function(node5) {
      var attribute = node5.getAttribute(FOCUS_NO_AUTOFOCUS);
      return ![true, "true", ""].includes(attribute);
    };
    isGuard = function(node5) {
      var _a;
      return Boolean(node5 && ((_a = getDataset(node5)) === null || _a === void 0 ? void 0 : _a.focusGuard));
    };
    isNotAGuard = function(node5) {
      return !isGuard(node5);
    };
    isDefined = function(x3) {
      return Boolean(x3);
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/tabOrder.js
var tabSort, orderByTabIndex;
var init_tabOrder = __esm({
  "node_modules/focus-lock/dist/es2015/utils/tabOrder.js"() {
    init_array();
    tabSort = function(a5, b3) {
      var tabDiff = a5.tabIndex - b3.tabIndex;
      var indexDiff = a5.index - b3.index;
      if (tabDiff) {
        if (!a5.tabIndex) {
          return 1;
        }
        if (!b3.tabIndex) {
          return -1;
        }
      }
      return tabDiff || indexDiff;
    };
    orderByTabIndex = function(nodes2, filterNegative, keepGuards) {
      return toArray2(nodes2).map(function(node5, index3) {
        return {
          node: node5,
          index: index3,
          tabIndex: keepGuards && node5.tabIndex === -1 ? (node5.dataset || {}).focusGuard ? 0 : -1 : node5.tabIndex
        };
      }).filter(function(data) {
        return !filterNegative || data.tabIndex >= 0;
      }).sort(tabSort);
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/tabbables.js
var tabbables;
var init_tabbables = __esm({
  "node_modules/focus-lock/dist/es2015/utils/tabbables.js"() {
    tabbables = [
      "button:enabled",
      "select:enabled",
      "textarea:enabled",
      "input:enabled",
      // elements with explicit roles will also use explicit tabindex
      // '[role="button"]',
      "a[href]",
      "area[href]",
      "summary",
      "iframe",
      "object",
      "embed",
      "audio[controls]",
      "video[controls]",
      "[tabindex]",
      "[contenteditable]",
      "[autofocus]"
    ];
  }
});

// node_modules/focus-lock/dist/es2015/utils/tabUtils.js
var queryTabbables, queryGuardTabbables, getFocusablesWithShadowDom, getFocusablesWithIFrame, getFocusables, getParentAutofocusables;
var init_tabUtils = __esm({
  "node_modules/focus-lock/dist/es2015/utils/tabUtils.js"() {
    init_constants();
    init_array();
    init_tabbables();
    queryTabbables = tabbables.join(",");
    queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
    getFocusablesWithShadowDom = function(parent3, withGuards) {
      return toArray2((parent3.shadowRoot || parent3).children).reduce(function(acc, child) {
        return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
      }, []);
    };
    getFocusablesWithIFrame = function(parent3, withGuards) {
      var _a;
      if (parent3 instanceof HTMLIFrameElement && ((_a = parent3.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
        return getFocusables([parent3.contentDocument.body], withGuards);
      }
      return [parent3];
    };
    getFocusables = function(parents, withGuards) {
      return parents.reduce(function(acc, parent3) {
        var _a;
        var focusableWithShadowDom = getFocusablesWithShadowDom(parent3, withGuards);
        var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function(node5) {
          return getFocusablesWithIFrame(node5, withGuards);
        }));
        return acc.concat(
          // add all tabbables inside and within shadow DOMs in DOM order
          focusableWithIframes,
          // add if node is tabbable itself
          parent3.parentNode ? toArray2(parent3.parentNode.querySelectorAll(queryTabbables)).filter(function(node5) {
            return node5 === parent3;
          }) : []
        );
      }, []);
    };
    getParentAutofocusables = function(parent3) {
      var parentFocus = parent3.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
      return toArray2(parentFocus).map(function(node5) {
        return getFocusables([node5]);
      }).reduce(function(acc, nodes2) {
        return acc.concat(nodes2);
      }, []);
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/DOMutils.js
var filterFocusable, filterAutoFocusable, getTabbableNodes, getFocusableNodes, parentAutofocusables, contains;
var init_DOMutils = __esm({
  "node_modules/focus-lock/dist/es2015/utils/DOMutils.js"() {
    init_array();
    init_is();
    init_tabOrder();
    init_tabUtils();
    filterFocusable = function(nodes2, visibilityCache) {
      return toArray2(nodes2).filter(function(node5) {
        return isVisibleCached(visibilityCache, node5);
      }).filter(function(node5) {
        return notHiddenInput(node5);
      });
    };
    filterAutoFocusable = function(nodes2, cache3) {
      if (cache3 === void 0) {
        cache3 = /* @__PURE__ */ new Map();
      }
      return toArray2(nodes2).filter(function(node5) {
        return isAutoFocusAllowedCached(cache3, node5);
      });
    };
    getTabbableNodes = function(topNodes, visibilityCache, withGuards) {
      return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
    };
    getFocusableNodes = function(topNodes, visibilityCache) {
      return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
    };
    parentAutofocusables = function(topNode, visibilityCache) {
      return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
    };
    contains = function(scope, element) {
      if (scope.shadowRoot) {
        return contains(scope.shadowRoot, element);
      } else {
        if (Object.getPrototypeOf(scope).contains !== void 0 && Object.getPrototypeOf(scope).contains.call(scope, element)) {
          return true;
        }
        return toArray2(scope.children).some(function(child) {
          var _a;
          if (child instanceof HTMLIFrameElement) {
            var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;
            if (iframeBody) {
              return contains(iframeBody, element);
            }
            return false;
          }
          return contains(child, element);
        });
      }
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/all-affected.js
var filterNested, getTopParent, getAllAffectedNodes;
var init_all_affected = __esm({
  "node_modules/focus-lock/dist/es2015/utils/all-affected.js"() {
    init_constants();
    init_array();
    filterNested = function(nodes2) {
      var contained = /* @__PURE__ */ new Set();
      var l3 = nodes2.length;
      for (var i4 = 0; i4 < l3; i4 += 1) {
        for (var j2 = i4 + 1; j2 < l3; j2 += 1) {
          var position3 = nodes2[i4].compareDocumentPosition(nodes2[j2]);
          if ((position3 & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
            contained.add(j2);
          }
          if ((position3 & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
            contained.add(i4);
          }
        }
      }
      return nodes2.filter(function(_2, index3) {
        return !contained.has(index3);
      });
    };
    getTopParent = function(node5) {
      return node5.parentNode ? getTopParent(node5.parentNode) : node5;
    };
    getAllAffectedNodes = function(node5) {
      var nodes2 = asArray(node5);
      return nodes2.filter(Boolean).reduce(function(acc, currentNode) {
        var group = currentNode.getAttribute(FOCUS_GROUP);
        acc.push.apply(acc, group ? filterNested(toArray2(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, '="').concat(group, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')))) : [currentNode]);
        return acc;
      }, []);
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/safe.js
var safeProbe;
var init_safe = __esm({
  "node_modules/focus-lock/dist/es2015/utils/safe.js"() {
    safeProbe = function(cb) {
      try {
        return cb();
      } catch (e5) {
        return void 0;
      }
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/getActiveElement.js
var getActiveElement;
var init_getActiveElement = __esm({
  "node_modules/focus-lock/dist/es2015/utils/getActiveElement.js"() {
    init_safe();
    getActiveElement = function(inDocument) {
      if (inDocument === void 0) {
        inDocument = document;
      }
      if (!inDocument || !inDocument.activeElement) {
        return void 0;
      }
      var activeElement = inDocument.activeElement;
      return activeElement.shadowRoot ? getActiveElement(activeElement.shadowRoot) : activeElement instanceof HTMLIFrameElement && safeProbe(function() {
        return activeElement.contentWindow.document;
      }) ? getActiveElement(activeElement.contentWindow.document) : activeElement;
    };
  }
});

// node_modules/focus-lock/dist/es2015/focusInside.js
var focusInFrame, focusInsideIframe, focusInside;
var init_focusInside = __esm({
  "node_modules/focus-lock/dist/es2015/focusInside.js"() {
    init_DOMutils();
    init_all_affected();
    init_array();
    init_getActiveElement();
    focusInFrame = function(frame, activeElement) {
      return frame === activeElement;
    };
    focusInsideIframe = function(topNode, activeElement) {
      return Boolean(toArray2(topNode.querySelectorAll("iframe")).some(function(node5) {
        return focusInFrame(node5, activeElement);
      }));
    };
    focusInside = function(topNode, activeElement) {
      if (activeElement === void 0) {
        activeElement = getActiveElement(getFirst(topNode).ownerDocument);
      }
      if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
        return false;
      }
      return getAllAffectedNodes(topNode).some(function(node5) {
        return contains(node5, activeElement) || focusInsideIframe(node5, activeElement);
      });
    };
  }
});

// node_modules/focus-lock/dist/es2015/focusIsHidden.js
var focusIsHidden;
var init_focusIsHidden = __esm({
  "node_modules/focus-lock/dist/es2015/focusIsHidden.js"() {
    init_constants();
    init_DOMutils();
    init_array();
    init_getActiveElement();
    focusIsHidden = function(inDocument) {
      if (inDocument === void 0) {
        inDocument = document;
      }
      var activeElement = getActiveElement(inDocument);
      if (!activeElement) {
        return false;
      }
      return toArray2(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function(node5) {
        return contains(node5, activeElement);
      });
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/correctFocus.js
var findSelectedRadio, correctNode, correctNodes;
var init_correctFocus = __esm({
  "node_modules/focus-lock/dist/es2015/utils/correctFocus.js"() {
    init_is();
    findSelectedRadio = function(node5, nodes2) {
      return nodes2.filter(isRadioElement).filter(function(el) {
        return el.name === node5.name;
      }).filter(function(el) {
        return el.checked;
      })[0] || node5;
    };
    correctNode = function(node5, nodes2) {
      if (isRadioElement(node5) && node5.name) {
        return findSelectedRadio(node5, nodes2);
      }
      return node5;
    };
    correctNodes = function(nodes2) {
      var resultSet = /* @__PURE__ */ new Set();
      nodes2.forEach(function(node5) {
        return resultSet.add(correctNode(node5, nodes2));
      });
      return nodes2.filter(function(node5) {
        return resultSet.has(node5);
      });
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/firstFocus.js
var pickFirstFocus, pickFocusable;
var init_firstFocus = __esm({
  "node_modules/focus-lock/dist/es2015/utils/firstFocus.js"() {
    init_correctFocus();
    pickFirstFocus = function(nodes2) {
      if (nodes2[0] && nodes2.length > 1) {
        return correctNode(nodes2[0], nodes2);
      }
      return nodes2[0];
    };
    pickFocusable = function(nodes2, index3) {
      if (nodes2.length > 1) {
        return nodes2.indexOf(correctNode(nodes2[index3], nodes2));
      }
      return index3;
    };
  }
});

// node_modules/focus-lock/dist/es2015/solver.js
var NEW_FOCUS, newFocus;
var init_solver = __esm({
  "node_modules/focus-lock/dist/es2015/solver.js"() {
    init_correctFocus();
    init_firstFocus();
    init_is();
    NEW_FOCUS = "NEW_FOCUS";
    newFocus = function(innerNodes, outerNodes, activeElement, lastNode) {
      var cnt = innerNodes.length;
      var firstFocus = innerNodes[0];
      var lastFocus = innerNodes[cnt - 1];
      var isOnGuard = isGuard(activeElement);
      if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
        return void 0;
      }
      var activeIndex = activeElement !== void 0 ? outerNodes.indexOf(activeElement) : -1;
      var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
      var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
      var indexDiff = activeIndex - lastIndex;
      var firstNodeIndex = outerNodes.indexOf(firstFocus);
      var lastNodeIndex = outerNodes.indexOf(lastFocus);
      var correctedNodes = correctNodes(outerNodes);
      var correctedIndex = activeElement !== void 0 ? correctedNodes.indexOf(activeElement) : -1;
      var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
      var returnFirstNode = pickFocusable(innerNodes, 0);
      var returnLastNode = pickFocusable(innerNodes, cnt - 1);
      if (activeIndex === -1 || lastNodeInside === -1) {
        return NEW_FOCUS;
      }
      if (!indexDiff && lastNodeInside >= 0) {
        return lastNodeInside;
      }
      if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
        return returnLastNode;
      }
      if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
        return returnFirstNode;
      }
      if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
        return lastNodeInside;
      }
      if (activeIndex <= firstNodeIndex) {
        return returnLastNode;
      }
      if (activeIndex > lastNodeIndex) {
        return returnFirstNode;
      }
      if (indexDiff) {
        if (Math.abs(indexDiff) > 1) {
          return lastNodeInside;
        }
        return (cnt + lastNodeInside + indexDiff) % cnt;
      }
      return void 0;
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/auto-focus.js
var findAutoFocused, pickAutofocus;
var init_auto_focus = __esm({
  "node_modules/focus-lock/dist/es2015/utils/auto-focus.js"() {
    init_DOMutils();
    init_firstFocus();
    init_is();
    findAutoFocused = function(autoFocusables) {
      return function(node5) {
        var _a;
        var autofocus = (_a = getDataset(node5)) === null || _a === void 0 ? void 0 : _a.autofocus;
        return (
          // @ts-expect-error
          node5.autofocus || //
          autofocus !== void 0 && autofocus !== "false" || //
          autoFocusables.indexOf(node5) >= 0
        );
      };
    };
    pickAutofocus = function(nodesIndexes, orderedNodes, groups) {
      var nodes2 = nodesIndexes.map(function(_a) {
        var node5 = _a.node;
        return node5;
      });
      var autoFocusable = filterAutoFocusable(nodes2.filter(findAutoFocused(groups)));
      if (autoFocusable && autoFocusable.length) {
        return pickFirstFocus(autoFocusable);
      }
      return pickFirstFocus(filterAutoFocusable(orderedNodes));
    };
  }
});

// node_modules/focus-lock/dist/es2015/utils/parenting.js
var getParents, getCommonParent, getTopCommonParent, allParentAutofocusables;
var init_parenting = __esm({
  "node_modules/focus-lock/dist/es2015/utils/parenting.js"() {
    init_DOMutils();
    init_DOMutils();
    init_array();
    getParents = function(node5, parents) {
      if (parents === void 0) {
        parents = [];
      }
      parents.push(node5);
      if (node5.parentNode) {
        getParents(node5.parentNode.host || node5.parentNode, parents);
      }
      return parents;
    };
    getCommonParent = function(nodeA, nodeB) {
      var parentsA = getParents(nodeA);
      var parentsB = getParents(nodeB);
      for (var i4 = 0; i4 < parentsA.length; i4 += 1) {
        var currentParent = parentsA[i4];
        if (parentsB.indexOf(currentParent) >= 0) {
          return currentParent;
        }
      }
      return false;
    };
    getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
      var activeElements = asArray(baseActiveElement);
      var leftEntries = asArray(leftEntry);
      var activeElement = activeElements[0];
      var topCommon = false;
      leftEntries.filter(Boolean).forEach(function(entry) {
        topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
        rightEntries.filter(Boolean).forEach(function(subEntry) {
          var common = getCommonParent(activeElement, subEntry);
          if (common) {
            if (!topCommon || contains(common, topCommon)) {
              topCommon = common;
            } else {
              topCommon = getCommonParent(common, topCommon);
            }
          }
        });
      });
      return topCommon;
    };
    allParentAutofocusables = function(entries, visibilityCache) {
      return entries.reduce(function(acc, node5) {
        return acc.concat(parentAutofocusables(node5, visibilityCache));
      }, []);
    };
  }
});

// node_modules/focus-lock/dist/es2015/focusSolver.js
var reorderNodes, focusSolver;
var init_focusSolver = __esm({
  "node_modules/focus-lock/dist/es2015/focusSolver.js"() {
    init_solver();
    init_DOMutils();
    init_all_affected();
    init_array();
    init_auto_focus();
    init_getActiveElement();
    init_is();
    init_parenting();
    reorderNodes = function(srcNodes, dstNodes) {
      var remap = /* @__PURE__ */ new Map();
      dstNodes.forEach(function(entity) {
        return remap.set(entity.node, entity);
      });
      return srcNodes.map(function(node5) {
        return remap.get(node5);
      }).filter(isDefined);
    };
    focusSolver = function(topNode, lastNode) {
      var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
      var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
      var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
      var visibilityCache = /* @__PURE__ */ new Map();
      var anyFocusable = getFocusableNodes(entries, visibilityCache);
      var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a) {
        var node5 = _a.node;
        return isNotAGuard(node5);
      });
      if (!innerElements[0]) {
        innerElements = anyFocusable;
        if (!innerElements[0]) {
          return void 0;
        }
      }
      var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function(_a) {
        var node5 = _a.node;
        return node5;
      });
      var orderedInnerElements = reorderNodes(outerNodes, innerElements);
      var innerNodes = orderedInnerElements.map(function(_a) {
        var node5 = _a.node;
        return node5;
      });
      var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);
      if (newId === NEW_FOCUS) {
        var focusNode = pickAutofocus(anyFocusable, innerNodes, allParentAutofocusables(entries, visibilityCache));
        if (focusNode) {
          return { node: focusNode };
        } else {
          console.warn("focus-lock: cannot find any node to move focus into");
          return void 0;
        }
      }
      if (newId === void 0) {
        return newId;
      }
      return orderedInnerElements[newId];
    };
  }
});

// node_modules/focus-lock/dist/es2015/focusables.js
var expandFocusableNodes;
var init_focusables = __esm({
  "node_modules/focus-lock/dist/es2015/focusables.js"() {
    init_DOMutils();
    init_all_affected();
    init_is();
    init_parenting();
    expandFocusableNodes = function(topNode) {
      var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
      var commonParent = getTopCommonParent(topNode, topNode, entries);
      var visibilityCache = /* @__PURE__ */ new Map();
      var outerNodes = getTabbableNodes([commonParent], visibilityCache, true);
      var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a) {
        var node5 = _a.node;
        return isNotAGuard(node5);
      }).map(function(_a) {
        var node5 = _a.node;
        return node5;
      });
      return outerNodes.map(function(_a) {
        var node5 = _a.node, index3 = _a.index;
        return {
          node: node5,
          index: index3,
          lockItem: innerElements.indexOf(node5) >= 0,
          guard: isGuard(node5)
        };
      });
    };
  }
});

// node_modules/focus-lock/dist/es2015/commands.js
var focusOn;
var init_commands = __esm({
  "node_modules/focus-lock/dist/es2015/commands.js"() {
    focusOn = function(target, focusOptions) {
      if ("focus" in target) {
        target.focus(focusOptions);
      }
      if ("contentWindow" in target && target.contentWindow) {
        target.contentWindow.focus();
      }
    };
  }
});

// node_modules/focus-lock/dist/es2015/moveFocusInside.js
var guardCount, lockDisabled, moveFocusInside;
var init_moveFocusInside = __esm({
  "node_modules/focus-lock/dist/es2015/moveFocusInside.js"() {
    init_commands();
    init_focusSolver();
    guardCount = 0;
    lockDisabled = false;
    moveFocusInside = function(topNode, lastNode, options) {
      if (options === void 0) {
        options = {};
      }
      var focusable = focusSolver(topNode, lastNode);
      if (lockDisabled) {
        return;
      }
      if (focusable) {
        if (guardCount > 2) {
          console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
          lockDisabled = true;
          setTimeout(function() {
            lockDisabled = false;
          }, 1);
          return;
        }
        guardCount++;
        focusOn(focusable.node, options.focusOptions);
        guardCount--;
      }
    };
  }
});

// node_modules/focus-lock/dist/es2015/sibling.js
var init_sibling = __esm({
  "node_modules/focus-lock/dist/es2015/sibling.js"() {
    init_commands();
    init_DOMutils();
  }
});

// node_modules/focus-lock/dist/es2015/index.js
var init_es20153 = __esm({
  "node_modules/focus-lock/dist/es2015/index.js"() {
    init_constants();
    init_focusInside();
    init_focusIsHidden();
    init_focusSolver();
    init_focusables();
    init_moveFocusInside();
    init_sibling();
    init_DOMutils();
  }
});

// node_modules/react-focus-lock/dist/es2015/util.js
function deferAction(action) {
  setTimeout(action, 1);
}
var inlineProp;
var init_util = __esm({
  "node_modules/react-focus-lock/dist/es2015/util.js"() {
    inlineProp = function inlineProp2(name, value) {
      var obj = {};
      obj[name] = value;
      return obj;
    };
  }
});

// node_modules/react-focus-lock/dist/es2015/Trap.js
function autoGuard(startIndex, end2, step, allNodes) {
  var lastGuard = null;
  var i4 = startIndex;
  do {
    var item = allNodes[i4];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i4 !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i4 += step) !== end2);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref6) {
      var id2 = _ref6.id;
      return id2 === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap(true);
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
var React8, import_prop_types3, focusOnBody, isFreeFocus, lastActiveTrap, lastActiveFocus, lastPortaledElement, focusWasOutsideWindow, defaultWhitelist, focusWhitelisted, recordPortal, focusIsPortaledPair, extractRef, focusWasOutside, checkInHost, withinHost, activateTrap, onTrap, onBlur, onFocus, FocusWatcher, FocusTrap, onWindowBlur, attachHandler, detachHandler, Trap_default;
var init_Trap = __esm({
  "node_modules/react-focus-lock/dist/es2015/Trap.js"() {
    React8 = __toESM(require_react());
    import_prop_types3 = __toESM(require_prop_types());
    init_index_es();
    init_es20153();
    init_util();
    init_medium2();
    focusOnBody = function focusOnBody2() {
      return document && document.activeElement === document.body;
    };
    isFreeFocus = function isFreeFocus2() {
      return focusOnBody() || focusIsHidden();
    };
    lastActiveTrap = null;
    lastActiveFocus = null;
    lastPortaledElement = null;
    focusWasOutsideWindow = false;
    defaultWhitelist = function defaultWhitelist2() {
      return true;
    };
    focusWhitelisted = function focusWhitelisted2(activeElement) {
      return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
    };
    recordPortal = function recordPortal2(observerNode, portaledElement) {
      lastPortaledElement = {
        observerNode,
        portaledElement
      };
    };
    focusIsPortaledPair = function focusIsPortaledPair2(element) {
      return lastPortaledElement && lastPortaledElement.portaledElement === element;
    };
    extractRef = function extractRef2(ref) {
      return ref && "current" in ref ? ref.current : ref;
    };
    focusWasOutside = function focusWasOutside2(crossFrameOption) {
      if (crossFrameOption) {
        return Boolean(focusWasOutsideWindow);
      }
      return focusWasOutsideWindow === "meanwhile";
    };
    checkInHost = function checkInHost2(check, el, boundary) {
      return el && // find host equal to active element and check nested active element
      (el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) || el.parentNode && checkInHost2(check, el.parentNode, boundary));
    };
    withinHost = function withinHost2(activeElement, workingArea) {
      return workingArea.some(function(area) {
        return checkInHost(activeElement, area, area);
      });
    };
    activateTrap = function activateTrap2() {
      var result = false;
      if (lastActiveTrap) {
        var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame, focusOptions = _lastActiveTrap.focusOptions;
        var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
        var activeElement = document && document.activeElement;
        if (workingNode) {
          var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));
          if (!activeElement || focusWhitelisted(activeElement)) {
            if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
              if (workingNode && !// active element is "inside" working area
              (focusInside(workingArea) || // check for shadow-dom contained elements
              activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement, workingNode))) {
                if (document && !lastActiveFocus && activeElement && !autoFocus) {
                  if (activeElement.blur) {
                    activeElement.blur();
                  }
                  document.body.focus();
                } else {
                  result = moveFocusInside(workingArea, lastActiveFocus, {
                    focusOptions
                  });
                  lastPortaledElement = {};
                }
              }
              focusWasOutsideWindow = false;
              lastActiveFocus = document && document.activeElement;
            }
          }
          if (document) {
            var newActiveElement = document && document.activeElement;
            var allNodes = expandFocusableNodes(workingArea);
            var focusedIndex = allNodes.map(function(_ref2) {
              var node5 = _ref2.node;
              return node5;
            }).indexOf(newActiveElement);
            if (focusedIndex > -1) {
              allNodes.filter(function(_ref2) {
                var guard3 = _ref2.guard, node5 = _ref2.node;
                return guard3 && node5.dataset.focusAutoGuard;
              }).forEach(function(_ref3) {
                var node5 = _ref3.node;
                return node5.removeAttribute("tabIndex");
              });
              autoGuard(focusedIndex, allNodes.length, 1, allNodes);
              autoGuard(focusedIndex, -1, -1, allNodes);
            }
          }
        }
      }
      return result;
    };
    onTrap = function onTrap2(event) {
      if (activateTrap() && event) {
        event.stopPropagation();
        event.preventDefault();
      }
    };
    onBlur = function onBlur2() {
      return deferAction(activateTrap);
    };
    onFocus = function onFocus2(event) {
      var source = event.target;
      var currentNode = event.currentTarget;
      if (!currentNode.contains(source)) {
        recordPortal(currentNode, source);
      }
    };
    FocusWatcher = function FocusWatcher2() {
      return null;
    };
    FocusTrap = function FocusTrap2(_ref4) {
      var children = _ref4.children;
      return React8.createElement("div", {
        onBlur,
        onFocus
      }, children);
    };
    FocusTrap.propTypes = true ? {
      children: import_prop_types3.default.node.isRequired
    } : {};
    onWindowBlur = function onWindowBlur2() {
      focusWasOutsideWindow = "just";
      deferAction(function() {
        focusWasOutsideWindow = "meanwhile";
      });
    };
    attachHandler = function attachHandler2() {
      document.addEventListener("focusin", onTrap);
      document.addEventListener("focusout", onBlur);
      window.addEventListener("blur", onWindowBlur);
    };
    detachHandler = function detachHandler2() {
      document.removeEventListener("focusin", onTrap);
      document.removeEventListener("focusout", onBlur);
      window.removeEventListener("blur", onWindowBlur);
    };
    mediumFocus.assignSyncMedium(onFocus);
    mediumBlur.assignMedium(onBlur);
    mediumEffect.assignMedium(function(cb) {
      return cb({
        moveFocusInside,
        focusInside
      });
    });
    Trap_default = index_es_default(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
  }
});

// node_modules/react-focus-lock/dist/es2015/Combination.js
var React9, FocusLockCombination, _ref, sideCar, propTypes, Combination_default;
var init_Combination = __esm({
  "node_modules/react-focus-lock/dist/es2015/Combination.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React9 = __toESM(require_react());
    init_Lock();
    init_Trap();
    FocusLockCombination = React9.forwardRef(function FocusLockUICombination(props, ref) {
      return React9.createElement(Lock_default, _extends({
        sideCar: Trap_default,
        ref
      }, props));
    });
    _ref = Lock_default.propTypes || {};
    sideCar = _ref.sideCar;
    propTypes = _objectWithoutPropertiesLoose(_ref, ["sideCar"]);
    FocusLockCombination.propTypes = true ? propTypes : {};
    Combination_default = FocusLockCombination;
  }
});

// node_modules/react-focus-lock/dist/es2015/AutoFocusInside.js
var React10, import_prop_types4, AutoFocusInside, AutoFocusInside_default;
var init_AutoFocusInside = __esm({
  "node_modules/react-focus-lock/dist/es2015/AutoFocusInside.js"() {
    init_extends();
    React10 = __toESM(require_react());
    import_prop_types4 = __toESM(require_prop_types());
    init_constants();
    init_util();
    AutoFocusInside = function AutoFocusInside2(_ref2) {
      var _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, children = _ref2.children, _ref$className = _ref2.className, className = _ref$className === void 0 ? void 0 : _ref$className;
      return React10.createElement("div", _extends({}, inlineProp(FOCUS_AUTO, !disabled), {
        className
      }), children);
    };
    AutoFocusInside.propTypes = true ? {
      children: import_prop_types4.default.node.isRequired,
      disabled: import_prop_types4.default.bool,
      className: import_prop_types4.default.string
    } : {};
    AutoFocusInside_default = AutoFocusInside;
  }
});

// node_modules/react-focus-lock/dist/es2015/MoveFocusInside.js
function MoveFocusInside(_ref2) {
  var isDisabled = _ref2.disabled, className = _ref2.className, children = _ref2.children;
  var ref = React11.useRef(null);
  useFocusInside(isDisabled ? void 0 : ref);
  return React11.createElement("div", _extends({}, inlineProp(FOCUS_AUTO, !isDisabled), {
    ref,
    className
  }), children);
}
var React11, import_prop_types5, useFocusInside, MoveFocusInside_default;
var init_MoveFocusInside = __esm({
  "node_modules/react-focus-lock/dist/es2015/MoveFocusInside.js"() {
    init_extends();
    React11 = __toESM(require_react());
    import_prop_types5 = __toESM(require_prop_types());
    init_constants();
    init_util();
    init_medium2();
    useFocusInside = function useFocusInside2(observedRef) {
      React11.useEffect(function() {
        var enabled = true;
        mediumEffect.useMedium(function(car) {
          var observed = observedRef && observedRef.current;
          if (enabled && observed) {
            if (!car.focusInside(observed)) {
              car.moveFocusInside(observed, null);
            }
          }
        });
        return function() {
          enabled = false;
        };
      }, [observedRef]);
    };
    MoveFocusInside.propTypes = true ? {
      children: import_prop_types5.default.node.isRequired,
      disabled: import_prop_types5.default.bool,
      className: import_prop_types5.default.string
    } : {};
    MoveFocusInside.defaultProps = {
      disabled: false,
      className: void 0
    };
    MoveFocusInside_default = MoveFocusInside;
  }
});

// node_modules/react-focus-lock/dist/es2015/FreeFocusInside.js
var React12, import_prop_types6, FreeFocusInside, FreeFocusInside_default;
var init_FreeFocusInside = __esm({
  "node_modules/react-focus-lock/dist/es2015/FreeFocusInside.js"() {
    init_extends();
    React12 = __toESM(require_react());
    import_prop_types6 = __toESM(require_prop_types());
    init_constants();
    init_util();
    FreeFocusInside = function FreeFocusInside2(_ref2) {
      var children = _ref2.children, className = _ref2.className;
      return React12.createElement("div", _extends({}, inlineProp(FOCUS_ALLOW, true), {
        className
      }), children);
    };
    FreeFocusInside.propTypes = true ? {
      children: import_prop_types6.default.node.isRequired,
      className: import_prop_types6.default.string
    } : {};
    FreeFocusInside.defaultProps = {
      className: void 0
    };
    FreeFocusInside_default = FreeFocusInside;
  }
});

// node_modules/react-focus-lock/dist/es2015/UI.js
var init_UI = __esm({
  "node_modules/react-focus-lock/dist/es2015/UI.js"() {
    init_Lock();
    init_AutoFocusInside();
    init_MoveFocusInside();
    init_FreeFocusInside();
    init_FocusGuard();
  }
});

// node_modules/react-focus-lock/dist/es2015/index.js
var es2015_exports = {};
__export(es2015_exports, {
  AutoFocusInside: () => AutoFocusInside_default,
  FocusLockUI: () => Lock_default,
  FreeFocusInside: () => FreeFocusInside_default,
  InFocusGuard: () => FocusGuard_default,
  MoveFocusInside: () => MoveFocusInside_default,
  default: () => es2015_default,
  useFocusInside: () => useFocusInside
});
var es2015_default;
var init_es20154 = __esm({
  "node_modules/react-focus-lock/dist/es2015/index.js"() {
    init_Combination();
    init_UI();
    es2015_default = Combination_default;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames() {
        var classes = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          var arg = arguments[i4];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key2 in arg) {
              if (hasOwn.call(arg, key2) && arg[key2]) {
                classes.push(key2);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames.default = classNames;
        module2.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/use-device-pixel-ratio/dist/index.module.js
var index_module_exports = {};
__export(index_module_exports, {
  getDevicePixelRatio: () => getDevicePixelRatio,
  useDevicePixelRatio: () => useDevicePixelRatio
});
function useDevicePixelRatio(options) {
  const dpr = getDevicePixelRatio(options);
  const [currentDpr, setCurrentDpr] = (0, import_react20.useState)(dpr);
  const {
    defaultDpr,
    maxDpr,
    round: round3
  } = options || {};
  (0, import_react20.useEffect)(() => {
    const canListen = typeof window !== "undefined" && "matchMedia" in window;
    if (!canListen) {
      return;
    }
    const updateDpr = () => setCurrentDpr(getDevicePixelRatio({
      defaultDpr,
      maxDpr,
      round: round3
    }));
    const mediaMatcher = window.matchMedia(`screen and (resolution: ${currentDpr}dppx)`);
    if (mediaMatcher.addEventListener) {
      mediaMatcher.addEventListener("change", updateDpr);
    } else {
      mediaMatcher.addListener(updateDpr);
    }
    return () => {
      if (mediaMatcher.removeEventListener) {
        mediaMatcher.removeEventListener("change", updateDpr);
      } else {
        mediaMatcher.removeListener(updateDpr);
      }
    };
  }, [currentDpr, defaultDpr, maxDpr, round3]);
  return currentDpr;
}
function getDevicePixelRatio(options) {
  const {
    defaultDpr = 1,
    maxDpr = 3,
    round: round3 = true
  } = options || {};
  const hasDprProp = typeof window !== "undefined" && typeof window.devicePixelRatio === "number";
  const dpr = hasDprProp ? window.devicePixelRatio : defaultDpr;
  const rounded = Math.min(Math.max(1, round3 ? Math.floor(dpr) : dpr), maxDpr);
  return rounded;
}
var import_react20;
var init_index_module = __esm({
  "node_modules/use-device-pixel-ratio/dist/index.module.js"() {
    import_react20 = __toESM(require_react());
  }
});

// node_modules/refractor/lang/bash.js
var require_bash = __commonJS({
  "node_modules/refractor/lang/bash.js"(exports, module2) {
    "use strict";
    module2.exports = bash;
    bash.displayName = "bash";
    bash.aliases = ["shell"];
    function bash(Prism) {
      ;
      (function(Prism2) {
        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
        var commandAfterHeredoc = {
          pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
          lookbehind: true,
          alias: "punctuation",
          // this looks reasonably well in all themes
          inside: null
          // see below
        };
        var insideString = {
          bash: commandAfterHeredoc,
          environment: {
            pattern: RegExp("\\$" + envVars),
            alias: "constant"
          },
          variable: [
            // [0]: Arithmetic Environment
            {
              pattern: /\$?\(\([\s\S]+?\)\)/,
              greedy: true,
              inside: {
                // If there is a $ sign at the beginning highlight $(( and )) as variable
                variable: [
                  {
                    pattern: /(^\$\(\([\s\S]+)\)\)/,
                    lookbehind: true
                  },
                  /^\$\(\(/
                ],
                number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                // If there is no $ sign at the beginning highlight (( and )) as punctuation
                punctuation: /\(\(?|\)\)?|,|;/
              }
            },
            // [1]: Command Substitution
            {
              pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
              greedy: true,
              inside: {
                variable: /^\$\(|^`|\)$|`$/
              }
            },
            // [2]: Brace expansion
            {
              pattern: /\$\{[^}]+\}/,
              greedy: true,
              inside: {
                operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                punctuation: /[\[\]]/,
                environment: {
                  pattern: RegExp("(\\{)" + envVars),
                  lookbehind: true,
                  alias: "constant"
                }
              }
            },
            /\$(?:\w+|[#?*!@$])/
          ],
          // Escape sequences from echo and printf's manuals, and escaped quotes.
          entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
        };
        Prism2.languages.bash = {
          shebang: {
            pattern: /^#!\s*\/.*/,
            alias: "important"
          },
          comment: {
            pattern: /(^|[^"{\\$])#.*/,
            lookbehind: true
          },
          "function-name": [
            // a) function foo {
            // b) foo() {
            // c) function foo() {
            // but not foo {
            {
              // a) and c)
              pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
              lookbehind: true,
              alias: "function"
            },
            {
              // b)
              pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
              alias: "function"
            }
          ],
          // Highlight variable names as variables in for and select beginnings.
          "for-or-select": {
            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
            alias: "variable",
            lookbehind: true
          },
          // Highlight variable names as variables in the left-hand part
          // of assignments (= and +=).
          "assign-left": {
            pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
            inside: {
              environment: {
                pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                lookbehind: true,
                alias: "constant"
              }
            },
            alias: "variable",
            lookbehind: true
          },
          string: [
            // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
            {
              pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            // Here-document with quotes around the tag
            //  No expansion (so no inside).
            {
              pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
              lookbehind: true,
              greedy: true,
              inside: {
                bash: commandAfterHeredoc
              }
            },
            // Normal string
            {
              // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
              pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            {
              // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
              pattern: /(^|[^$\\])'[^']*'/,
              lookbehind: true,
              greedy: true
            },
            {
              // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
              pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
              greedy: true,
              inside: {
                entity: insideString.entity
              }
            }
          ],
          environment: {
            pattern: RegExp("\\$?" + envVars),
            alias: "constant"
          },
          variable: insideString.variable,
          function: {
            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          keyword: {
            pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
          builtin: {
            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
            lookbehind: true,
            // Alias added to make those easier to distinguish from strings.
            alias: "class-name"
          },
          boolean: {
            pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          "file-descriptor": {
            pattern: /\B&\d\b/,
            alias: "important"
          },
          operator: {
            // Lots of redirections here, but not just that.
            pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
            inside: {
              "file-descriptor": {
                pattern: /^\d/,
                alias: "important"
              }
            }
          },
          punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
          number: {
            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
            lookbehind: true
          }
        };
        commandAfterHeredoc.inside = Prism2.languages.bash;
        var toBeCopied = [
          "comment",
          "function-name",
          "for-or-select",
          "assign-left",
          "string",
          "environment",
          "function",
          "keyword",
          "builtin",
          "boolean",
          "file-descriptor",
          "operator",
          "punctuation",
          "number"
        ];
        var inside = insideString.variable[1].inside;
        for (var i4 = 0; i4 < toBeCopied.length; i4++) {
          inside[toBeCopied[i4]] = Prism2.languages.bash[toBeCopied[i4]];
        }
        Prism2.languages.shell = Prism2.languages.bash;
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/json.js
var require_json = __commonJS({
  "node_modules/refractor/lang/json.js"(exports, module2) {
    "use strict";
    module2.exports = json;
    json.displayName = "json";
    json.aliases = ["webmanifest"];
    function json(Prism) {
      Prism.languages.json = {
        property: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
          lookbehind: true,
          greedy: true
        },
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
          lookbehind: true,
          greedy: true
        },
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
          greedy: true
        },
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\],]/,
        operator: /:/,
        boolean: /\b(?:false|true)\b/,
        null: {
          pattern: /\bnull\b/,
          alias: "keyword"
        }
      };
      Prism.languages.webmanifest = Prism.languages.json;
    }
  }
});

// node_modules/refractor/lang/jsx.js
var require_jsx = __commonJS({
  "node_modules/refractor/lang/jsx.js"(exports, module2) {
    "use strict";
    module2.exports = jsx;
    jsx.displayName = "jsx";
    jsx.aliases = [];
    function jsx(Prism) {
      ;
      (function(Prism2) {
        var javascript = Prism2.util.clone(Prism2.languages.javascript);
        var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
        var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
        var spread2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
        function re2(source, flags) {
          source = source.replace(/<S>/g, function() {
            return space;
          }).replace(/<BRACES>/g, function() {
            return braces;
          }).replace(/<SPREAD>/g, function() {
            return spread2;
          });
          return RegExp(source, flags);
        }
        spread2 = re2(spread2).source;
        Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
        Prism2.languages.jsx.tag.pattern = re2(
          /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
        );
        Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
        Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
        Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
        Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
        Prism2.languages.insertBefore(
          "inside",
          "attr-name",
          {
            spread: {
              pattern: re2(/<SPREAD>/.source),
              inside: Prism2.languages.jsx
            }
          },
          Prism2.languages.jsx.tag
        );
        Prism2.languages.insertBefore(
          "inside",
          "special-attr",
          {
            script: {
              // Allow for two levels of nesting
              pattern: re2(/=<BRACES>/.source),
              alias: "language-javascript",
              inside: {
                "script-punctuation": {
                  pattern: /^=(?=\{)/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.jsx
              }
            }
          },
          Prism2.languages.jsx.tag
        );
        var stringifyToken = function(token3) {
          if (!token3) {
            return "";
          }
          if (typeof token3 === "string") {
            return token3;
          }
          if (typeof token3.content === "string") {
            return token3.content;
          }
          return token3.content.map(stringifyToken).join("");
        };
        var walkTokens = function(tokens2) {
          var openedTags = [];
          for (var i4 = 0; i4 < tokens2.length; i4++) {
            var token3 = tokens2[i4];
            var notTagNorBrace = false;
            if (typeof token3 !== "string") {
              if (token3.type === "tag" && token3.content[0] && token3.content[0].type === "tag") {
                if (token3.content[0].content[0].content === "</") {
                  if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token3.content[0].content[1])) {
                    openedTags.pop();
                  }
                } else {
                  if (token3.content[token3.content.length - 1].content === "/>") {
                  } else {
                    openedTags.push({
                      tagName: stringifyToken(token3.content[0].content[1]),
                      openedBraces: 0
                    });
                  }
                }
              } else if (openedTags.length > 0 && token3.type === "punctuation" && token3.content === "{") {
                openedTags[openedTags.length - 1].openedBraces++;
              } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token3.type === "punctuation" && token3.content === "}") {
                openedTags[openedTags.length - 1].openedBraces--;
              } else {
                notTagNorBrace = true;
              }
            }
            if (notTagNorBrace || typeof token3 === "string") {
              if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                var plainText = stringifyToken(token3);
                if (i4 < tokens2.length - 1 && (typeof tokens2[i4 + 1] === "string" || tokens2[i4 + 1].type === "plain-text")) {
                  plainText += stringifyToken(tokens2[i4 + 1]);
                  tokens2.splice(i4 + 1, 1);
                }
                if (i4 > 0 && (typeof tokens2[i4 - 1] === "string" || tokens2[i4 - 1].type === "plain-text")) {
                  plainText = stringifyToken(tokens2[i4 - 1]) + plainText;
                  tokens2.splice(i4 - 1, 1);
                  i4--;
                }
                tokens2[i4] = new Prism2.Token(
                  "plain-text",
                  plainText,
                  null,
                  plainText
                );
              }
            }
            if (token3.content && typeof token3.content !== "string") {
              walkTokens(token3.content);
            }
          }
        };
        Prism2.hooks.add("after-tokenize", function(env2) {
          if (env2.language !== "jsx" && env2.language !== "tsx") {
            return;
          }
          walkTokens(env2.tokens);
        });
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/typescript.js
var require_typescript = __commonJS({
  "node_modules/refractor/lang/typescript.js"(exports, module2) {
    "use strict";
    module2.exports = typescript;
    typescript.displayName = "typescript";
    typescript.aliases = ["ts"];
    function typescript(Prism) {
      ;
      (function(Prism2) {
        Prism2.languages.typescript = Prism2.languages.extend("javascript", {
          "class-name": {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
        });
        Prism2.languages.typescript.keyword.push(
          /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
          // keywords that have to be followed by an identifier
          /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
          // This is for `import type *, {}`
          /\btype\b(?=\s*(?:[\{*]|$))/
        );
        delete Prism2.languages.typescript["parameter"];
        delete Prism2.languages.typescript["literal-property"];
        var typeInside = Prism2.languages.extend("typescript", {});
        delete typeInside["class-name"];
        Prism2.languages.typescript["class-name"].inside = typeInside;
        Prism2.languages.insertBefore("typescript", "function", {
          decorator: {
            pattern: /@[$\w\xA0-\uFFFF]+/,
            inside: {
              at: {
                pattern: /^@/,
                alias: "operator"
              },
              function: /^[\s\S]+/
            }
          },
          "generic-function": {
            // e.g. foo<T extends "bar" | "baz">( ...
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
            greedy: true,
            inside: {
              function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
              generic: {
                pattern: /<[\s\S]+/,
                // everything after the first <
                alias: "class-name",
                inside: typeInside
              }
            }
          }
        });
        Prism2.languages.ts = Prism2.languages.typescript;
      })(Prism);
    }
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray5 = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString2(value) {
      return typeof value == "string" || !isArray5(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString2;
  }
});

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/nanoid/url-alphabet/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/nanoid/index.browser.js
var index_browser_exports = {};
__export(index_browser_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_browser = __esm({
  "node_modules/nanoid/index.browser.js"() {
    init_url_alphabet();
    random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size4 = defaultSize) => {
        let id2 = "";
        while (true) {
          let bytes = getRandom(step);
          let j2 = step;
          while (j2--) {
            id2 += alphabet[bytes[j2] & mask] || "";
            if (id2.length === size4)
              return id2;
          }
        }
      };
    };
    customAlphabet = (alphabet, size4 = 21) => customRandom(alphabet, size4, random);
    nanoid = (size4 = 21) => crypto.getRandomValues(new Uint8Array(size4)).reduce((id2, byte) => {
      byte &= 63;
      if (byte < 36) {
        id2 += byte.toString(36);
      } else if (byte < 62) {
        id2 += (byte - 26).toString(36).toUpperCase();
      } else if (byte > 62) {
        id2 += "-";
      } else {
        id2 += "_";
      }
      return id2;
    }, "");
  }
});

// node_modules/@sanity/bifur-client/dist/esm/methods.js
var SUBSCRIBE_METHODS;
var init_methods = __esm({
  "node_modules/@sanity/bifur-client/dist/esm/methods.js"() {
    SUBSCRIBE_METHODS = ["presence", "listen"];
  }
});

// node_modules/@sanity/bifur-client/dist/esm/createClient.js
function formatRequest(method, params, id2) {
  return JSON.stringify({
    jsonrpc: "2.0",
    method,
    params: addApiVersion(params, "v1"),
    id: id2
  });
}
function tryParse(input) {
  try {
    return [null, JSON.parse(input)];
  } catch (error) {
    return error instanceof Error ? [error] : [new Error("".concat(error))];
  }
}
function addApiVersion(params, v2) {
  return __assign2(__assign2({}, params), { apiVersion: v2 });
}
function isSubscribeMethod(method) {
  return SUBSCRIBE_METHODS.includes(method);
}
var __assign2, defaultGetNextRequestId, HEARTBEAT, createClient;
var init_createClient = __esm({
  "node_modules/@sanity/bifur-client/dist/esm/createClient.js"() {
    init_operators();
    init_esm5();
    init_index_browser();
    init_methods();
    __assign2 = function() {
      __assign2 = Object.assign || function(t4) {
        for (var s5, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
          s5 = arguments[i4];
          for (var p2 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p2))
              t4[p2] = s5[p2];
        }
        return t4;
      };
      return __assign2.apply(this, arguments);
    };
    defaultGetNextRequestId = customAlphabet("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-", 20);
    HEARTBEAT = "";
    createClient = function(connection$, options) {
      if (options === void 0) {
        options = {};
      }
      var token$ = options.token$, _a = options.getNextRequestId, getNextRequestId = _a === void 0 ? defaultGetNextRequestId : _a;
      var _b = partition(connection$.pipe(switchMap(function(connection) {
        return fromEvent(connection, "message");
      })), function(event) {
        return event.data === HEARTBEAT;
      }), heartbeats$ = _b[0], responses$ = _b[1];
      var parsedResponses$ = responses$.pipe(mergeMap(function(response) {
        var _a2 = tryParse(response.data), err = _a2[0], msg2 = _a2[1];
        if (err) {
          console.warn("Unable to parse message: %s", err.message);
          return EMPTY;
        }
        if (!msg2 || !msg2.jsonrpc) {
          console.warn("Received empty or non-jsonrpc message: %s", msg2);
          return EMPTY;
        }
        return of(msg2);
      }), share());
      var authedConnection$ = token$ ? combineLatest([token$, connection$]).pipe(distinctUntilChanged(function(_a2, _b2) {
        var oldToken = _a2[0], oldSocket = _a2[1];
        var newToken = _b2[0], newSocket = _b2[1];
        return oldToken === newToken && oldSocket === newSocket;
      }), switchMap(function(_a2) {
        var token3 = _a2[0], ws = _a2[1];
        return token3 ? call(ws, "authorization", {
          authorization: "Bearer ".concat(token3)
        }).pipe(take(1), mapTo(ws)) : of(ws);
      }), shareReplay({ refCount: true, bufferSize: 1 })) : connection$;
      function call(ws, method, params) {
        if (params === void 0) {
          params = {};
        }
        var requestId = getNextRequestId();
        return merge(parsedResponses$.pipe(filter2(function(rpcResult) {
          return rpcResult.id === requestId;
        }), map(function(rpcResult) {
          return rpcResult.result;
        })), defer(function() {
          ws.send(formatRequest(method, params, requestId));
          return EMPTY;
        }));
      }
      function requestMethod(method, params) {
        return authedConnection$.pipe(take(1), mergeMap(function(ws) {
          return call(ws, method, params).pipe(take(1));
        }));
      }
      function requestSubscribe(method, params) {
        return authedConnection$.pipe(take(1), mergeMap(function(ws) {
          return call(ws, "".concat(method, "_subscribe"), params).pipe(take(1), mergeMap(function(subscriptionId) {
            return parsedResponses$.pipe(filter2(function(message) {
              return message.method === "".concat(method, "_subscription") && message.params.subscription === subscriptionId;
            }), map(function(message) {
              return message.params.result;
            }), finalize(function() {
              if (ws.readyState !== ws.CLOSED && ws.readyState !== ws.CLOSING) {
                ws.send(formatRequest("".concat(method, "_unsubscribe"), { subscriptionId }, getNextRequestId()));
              }
            }));
          }));
        }));
      }
      return {
        // heartbeat$ is a stream of date objects representing when the "last message was received"
        // it will keep the connection open until it is unsubscribed and can therefore be used to keep connection alive
        // between requests
        heartbeats: merge(authedConnection$, heartbeats$, responses$).pipe(map(function() {
          return /* @__PURE__ */ new Date();
        })),
        request: function(method, params) {
          return isSubscribeMethod(method) ? requestSubscribe(method, params) : requestMethod(method, params);
        }
      };
    };
  }
});

// node_modules/@sanity/bifur-client/dist/esm/createConnect.js
function createConnect(getWebsocketInstance) {
  return function(url) {
    return new Observable(function(subscriber) {
      var ws = getWebsocketInstance(url);
      var didUnsubscribe = false;
      var onOpen = function() {
        subscriber.next(ws);
      };
      var onError = function() {
        subscriber.error(new WebSocketError("WebSocket connection error", "CONNECTION_ERROR"));
      };
      var onClose = function(ev) {
        if (!didUnsubscribe) {
          subscriber.error(new WebSocketError("WebSocket connection error", "CONNECTION_CLOSED", ev.code, ev.reason));
        } else {
          subscriber.complete();
        }
      };
      ws.onopen = onOpen;
      ws.onclose = onClose;
      ws.onerror = onError;
      return function() {
        didUnsubscribe = true;
        ws.close(1e3, "WebSockets connection closed by client");
      };
    });
  };
}
var __extends2, WebSocketError;
var init_createConnect = __esm({
  "node_modules/@sanity/bifur-client/dist/esm/createConnect.js"() {
    init_esm5();
    __extends2 = function() {
      var extendStatics2 = function(d3, b3) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d4[p2] = b4[p2];
        };
        return extendStatics2(d3, b3);
      };
      return function(d3, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics2(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    WebSocketError = /** @class */
    function(_super) {
      __extends2(WebSocketError2, _super);
      function WebSocketError2(message, type, code, reason) {
        var _this = _super.call(this, message) || this;
        _this.type = type;
        _this.code = code;
        _this.reason = reason;
        return _this;
      }
      return WebSocketError2;
    }(Error);
  }
});

// node_modules/@sanity/bifur-client/dist/esm/operators.js
var timeoutFirstWith;
var init_operators2 = __esm({
  "node_modules/@sanity/bifur-client/dist/esm/operators.js"() {
    init_esm5();
    init_operators();
    timeoutFirstWith = function(due, withObservable) {
      return function(input$) {
        return race(input$, timer(due).pipe(mergeMap(function() {
          return withObservable;
        })));
      };
    };
  }
});

// node_modules/@sanity/bifur-client/dist/esm/errorCodes.js
var ERROR_CODES;
var init_errorCodes = __esm({
  "node_modules/@sanity/bifur-client/dist/esm/errorCodes.js"() {
    (function(ERROR_CODES2) {
      ERROR_CODES2[ERROR_CODES2["BAD_REQUEST"] = 4e3] = "BAD_REQUEST";
      ERROR_CODES2[ERROR_CODES2["UNAUTHORIZED"] = 4001] = "UNAUTHORIZED";
      ERROR_CODES2[ERROR_CODES2["NOT_FOUND"] = 4004] = "NOT_FOUND";
      ERROR_CODES2[ERROR_CODES2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
      ERROR_CODES2[ERROR_CODES2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
      ERROR_CODES2[ERROR_CODES2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
      ERROR_CODES2[ERROR_CODES2["SUBSCRIPTION_NOT_FOUND"] = -32602] = "SUBSCRIPTION_NOT_FOUND";
      ERROR_CODES2[ERROR_CODES2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
    })(ERROR_CODES || (ERROR_CODES = {}));
  }
});

// node_modules/@sanity/bifur-client/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  ERROR_CODES: () => ERROR_CODES,
  fromSanityClient: () => fromSanityClient,
  fromUrl: () => fromUrl
});
function fromUrl(url, options) {
  if (options === void 0) {
    options = {};
  }
  var timeout2 = options.timeout, token$ = options.token$;
  var connect2 = createConnect(function(url2, protocols) {
    return new window.WebSocket(url2, protocols);
  });
  return createClient(connect2(url).pipe(timeout2 ? timeoutFirstWith(timeout2, throwError(function() {
    return new Error("Timeout after ".concat(timeout2, " while establishing WebSockets connection"));
  })) : id, shareReplay({ refCount: true }), takeUntil(fromEvent(window, "beforeunload"))), { token$ });
}
function fromSanityClient(client) {
  var _a = client.config(), dataset = _a.dataset, token3 = _a.token;
  return fromUrl(client.getUrl("/socket/".concat(dataset)).replace(/^http/, "ws"), token3 ? { token$: of(token3) } : {});
}
var id;
var init_esm3 = __esm({
  "node_modules/@sanity/bifur-client/dist/esm/index.js"() {
    init_createClient();
    init_createConnect();
    init_operators2();
    init_operators();
    init_esm5();
    init_errorCodes();
    id = function(arg) {
      return arg;
    };
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module2) {
    function arrayEach(array, iteratee) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      while (++index3 < length2) {
        if (iteratee(array[index3], index3, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index3 = -1, length2 = props.length;
      while (++index3 < length2) {
        var key2 = props[index3];
        var newValue = customizer ? customizer(object2[key2], source[key2], key2, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key2];
        }
        if (isNew) {
          baseAssignValue(object2, key2, newValue);
        } else {
          assignValue(object2, key2, newValue);
        }
      }
      return object2;
    }
    module2.exports = copyObject;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module2) {
    var copyObject = require_copyObject();
    var keys2 = require_keys();
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys2(source), object2);
    }
    module2.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module2) {
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key2 in Object(object2)) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module2) {
    var isObject4 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject4(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key2 in object2) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object2, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike2 = require_isArrayLike();
    function keysIn(object2) {
      return isArrayLike2(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    module2.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    module2.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module2) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
      buffer2.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module2) {
    function copyArray(source, array) {
      var index3 = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index3 < length2) {
        array[index3] = source[index3];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    module2.exports = copySymbols;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    module2.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module2) {
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function initCloneArray(array) {
      var length2 = array.length, result = new array.constructor(length2);
      if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object2);
        case boolTag:
        case dateTag:
          return new Ctor(+object2);
        case dataViewTag:
          return cloneDataView(object2, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object2, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object2);
        case regexpTag:
          return cloneRegExp(object2);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object2);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module2) {
    var isObject4 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto2) {
        if (!isObject4(proto2)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto2);
        }
        object2.prototype = proto2;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap2;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet2;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray5 = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap2 = require_isMap();
    var isObject4 = require_isObject();
    var isSet2 = require_isSet();
    var keys2 = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key2, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object2 ? customizer(value, key2, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject4(value)) {
        return value;
      }
      var isArr = isArray5(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet2(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap2(value)) {
        value.forEach(function(subValue, key3) {
          result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module2) {
    function last5(array) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? array[length2 - 1] : void 0;
    }
    module2.exports = last5;
  }
});

// node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "node_modules/lodash/_parent.js"(exports, module2) {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent3(object2, path3) {
      return path3.length < 2 ? object2 : baseGet(object2, baseSlice(path3, 0, -1));
    }
    module2.exports = parent3;
  }
});

// node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "node_modules/lodash/_baseUnset.js"(exports, module2) {
    var castPath = require_castPath();
    var last5 = require_last();
    var parent3 = require_parent();
    var toKey = require_toKey();
    function baseUnset(object2, path3) {
      path3 = castPath(path3, object2);
      object2 = parent3(object2, path3);
      return object2 == null || delete object2[toKey(last5(path3))];
    }
    module2.exports = baseUnset;
  }
});

// node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "node_modules/lodash/_customOmitClone.js"(exports, module2) {
    var isPlainObject3 = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject3(value) ? void 0 : value;
    }
    module2.exports = customOmitClone;
  }
});

// node_modules/lodash/omit.js
var require_omit = __commonJS({
  "node_modules/lodash/omit.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit = flatRest(function(object2, paths) {
      var result = {};
      if (object2 == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path3) {
        path3 = castPath(path3, object2);
        isDeep || (isDeep = path3.length > 1);
        return path3;
      });
      copyObject(object2, getAllKeysIn(object2), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length2 = paths.length;
      while (length2--) {
        baseUnset(result, paths[length2]);
      }
      return result;
    });
    module2.exports = omit;
  }
});

// node_modules/lodash/castArray.js
var require_castArray = __commonJS({
  "node_modules/lodash/castArray.js"(exports, module2) {
    var isArray5 = require_isArray();
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray5(value) ? value : [value];
    }
    module2.exports = castArray;
  }
});

// node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/lodash/capitalize.js"(exports, module2) {
    var toString2 = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string4) {
      return upperFirst(toString2(string4).toLowerCase());
    }
    module2.exports = capitalize;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module2) {
    function noop3() {
    }
    module2.exports = noop3;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module2) {
    var Set2 = require_Set();
    var noop3 = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index3 = -1, includes = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length2 >= LARGE_ARRAY_SIZE) {
        var set4 = iteratee ? null : createSet(array);
        if (set4) {
          return setToArray(set4);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index3 < length2) {
          var value = array[index3], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniqBy.js
var require_uniqBy = __commonJS({
  "node_modules/lodash/uniqBy.js"(exports, module2) {
    var baseIteratee = require_baseIteratee();
    var baseUniq = require_baseUniq();
    function uniqBy(array, iteratee) {
      return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
    }
    module2.exports = uniqBy;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "node_modules/lodash/_arrayAggregator.js"(exports, module2) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index3 = -1, length2 = array == null ? 0 : array.length;
      while (++index3 < length2) {
        var value = array[index3];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module2.exports = arrayAggregator;
  }
});

// node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "node_modules/lodash/_baseAggregator.js"(exports, module2) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key2, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module2.exports = baseAggregator;
  }
});

// node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "node_modules/lodash/_createAggregator.js"(exports, module2) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray5 = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func2 = isArray5(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func2(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module2.exports = createAggregator;
  }
});

// node_modules/lodash/partition.js
var require_partition = __commonJS({
  "node_modules/lodash/partition.js"(exports, module2) {
    var createAggregator = require_createAggregator();
    var partition3 = createAggregator(function(result, value, key2) {
      result[key2 ? 0 : 1].push(value);
    }, function() {
      return [[], []];
    });
    module2.exports = partition3;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep;
  }
});

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
var init_requiredArgs = __esm({
  "node_modules/date-fns/esm/_lib/requiredArgs/index.js"() {
  }
});

// node_modules/date-fns/esm/isDate/index.js
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
var init_isDate2 = __esm({
  "node_modules/date-fns/esm/isDate/index.js"() {
    init_typeof();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
var init_toDate = __esm({
  "node_modules/date-fns/esm/toDate/index.js"() {
    init_typeof();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isValid/index.js
var isValid_exports = {};
__export(isValid_exports, {
  default: () => isValid
});
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date2 = toDate(dirtyDate);
  return !isNaN(Number(date2));
}
var init_isValid = __esm({
  "node_modules/date-fns/esm/isValid/index.js"() {
    init_isDate2();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number2 = Number(dirtyNumber);
  if (isNaN(number2)) {
    return number2;
  }
  return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
}
var init_toInteger = __esm({
  "node_modules/date-fns/esm/_lib/toInteger/index.js"() {
  }
});

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp2 = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp2 + amount);
}
var init_addMilliseconds = __esm({
  "node_modules/date-fns/esm/addMilliseconds/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var init_subMilliseconds = __esm({
  "node_modules/date-fns/esm/subMilliseconds/index.js"() {
    init_addMilliseconds();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var timestamp2 = date2.getTime();
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date2.getTime();
  var difference = timestamp2 - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
var MILLISECONDS_IN_DAY;
var init_getUTCDayOfYear = __esm({
  "node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
    MILLISECONDS_IN_DAY = 864e5;
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date2 = toDate(dirtyDate);
  var day = date2.getUTCDay();
  var diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff2);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
var init_startOfUTCISOWeek = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getUTCISOWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_startOfUTCISOWeek();
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCISOWeek(fourthOfJanuary);
  return date2;
}
var init_startOfUTCISOWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js"() {
    init_getUTCISOWeekYear();
    init_startOfUTCISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff2 = startOfUTCISOWeek(date2).getTime() - startOfUTCISOWeekYear(date2).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK) + 1;
}
var MILLISECONDS_IN_WEEK;
var init_getUTCISOWeek = __esm({
  "node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js"() {
    init_toDate();
    init_startOfUTCISOWeek();
    init_startOfUTCISOWeekYear();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK = 6048e5;
  }
});

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
function getDefaultOptions() {
  return defaultOptions2;
}
function setDefaultOptions(newOptions) {
  defaultOptions2 = newOptions;
}
var defaultOptions2;
var init_defaultOptions = __esm({
  "node_modules/date-fns/esm/_lib/defaultOptions/index.js"() {
    defaultOptions2 = {};
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = date2.getUTCDay();
  var diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff2);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
var init_startOfUTCWeek = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getUTCFullYear();
  var defaultOptions4 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getUTCWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_startOfUTCWeek();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCWeek(firstWeek, options);
  return date2;
}
var init_startOfUTCWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js"() {
    init_getUTCWeekYear();
    init_requiredArgs();
    init_startOfUTCWeek();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff2 = startOfUTCWeek(date2, options).getTime() - startOfUTCWeekYear(date2, options).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK2) + 1;
}
var MILLISECONDS_IN_WEEK2;
var init_getUTCWeek = __esm({
  "node_modules/date-fns/esm/_lib/getUTCWeek/index.js"() {
    init_toDate();
    init_startOfUTCWeek();
    init_startOfUTCWeekYear();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK2 = 6048e5;
  }
});

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number2, targetLength) {
  var sign2 = number2 < 0 ? "-" : "";
  var output = Math.abs(number2).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}
var init_addLeadingZeros = __esm({
  "node_modules/date-fns/esm/_lib/addLeadingZeros/index.js"() {
  }
});

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters, lightFormatters_default;
var init_lightFormatters = __esm({
  "node_modules/date-fns/esm/_lib/format/lightFormatters/index.js"() {
    init_addLeadingZeros();
    formatters = {
      // Year
      y: function y2(date2, token3) {
        var signedYear = date2.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token3 === "yy" ? year % 100 : year, token3.length);
      },
      // Month
      M: function M2(date2, token3) {
        var month = date2.getUTCMonth();
        return token3 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function d(date2, token3) {
        return addLeadingZeros(date2.getUTCDate(), token3.length);
      },
      // AM or PM
      a: function a3(date2, token3) {
        var dayPeriodEnumValue = date2.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (token3) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h: function h(date2, token3) {
        return addLeadingZeros(date2.getUTCHours() % 12 || 12, token3.length);
      },
      // Hour [0-23]
      H: function H2(date2, token3) {
        return addLeadingZeros(date2.getUTCHours(), token3.length);
      },
      // Minute
      m: function m2(date2, token3) {
        return addLeadingZeros(date2.getUTCMinutes(), token3.length);
      },
      // Second
      s: function s3(date2, token3) {
        return addLeadingZeros(date2.getUTCSeconds(), token3.length);
      },
      // Fraction of second
      S: function S2(date2, token3) {
        var numberOfDigits = token3.length;
        var milliseconds3 = date2.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds3 * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token3.length);
      }
    };
    lightFormatters_default = formatters;
  }
});

// node_modules/date-fns/esm/_lib/format/formatters/index.js
function formatTimezoneShort(offset3, dirtyDelimiter) {
  var sign2 = offset3 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset3);
  var hours2 = Math.floor(absOffset / 60);
  var minutes2 = absOffset % 60;
  if (minutes2 === 0) {
    return sign2 + String(hours2);
  }
  var delimiter2 = dirtyDelimiter || "";
  return sign2 + String(hours2) + delimiter2 + addLeadingZeros(minutes2, 2);
}
function formatTimezoneWithOptionalMinutes(offset3, dirtyDelimiter) {
  if (offset3 % 60 === 0) {
    var sign2 = offset3 > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset3) / 60, 2);
  }
  return formatTimezone(offset3, dirtyDelimiter);
}
function formatTimezone(offset3, dirtyDelimiter) {
  var delimiter2 = dirtyDelimiter || "";
  var sign2 = offset3 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset3);
  var hours2 = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes2 = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours2 + delimiter2 + minutes2;
}
var dayPeriodEnum, formatters2, formatters_default;
var init_formatters = __esm({
  "node_modules/date-fns/esm/_lib/format/formatters/index.js"() {
    init_getUTCDayOfYear();
    init_getUTCISOWeek();
    init_getUTCISOWeekYear();
    init_getUTCWeek();
    init_getUTCWeekYear();
    init_addLeadingZeros();
    init_lightFormatters();
    dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    formatters2 = {
      // Era
      G: function G2(date2, token3, localize2) {
        var era = date2.getUTCFullYear() > 0 ? 1 : 0;
        switch (token3) {
          case "G":
          case "GG":
          case "GGG":
            return localize2.era(era, {
              width: "abbreviated"
            });
          case "GGGGG":
            return localize2.era(era, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return localize2.era(era, {
              width: "wide"
            });
        }
      },
      // Year
      y: function y3(date2, token3, localize2) {
        if (token3 === "yo") {
          var signedYear = date2.getUTCFullYear();
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize2.ordinalNumber(year, {
            unit: "year"
          });
        }
        return lightFormatters_default.y(date2, token3);
      },
      // Local week-numbering year
      Y: function Y2(date2, token3, localize2, options) {
        var signedWeekYear = getUTCWeekYear(date2, options);
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token3 === "YY") {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }
        if (token3 === "Yo") {
          return localize2.ordinalNumber(weekYear, {
            unit: "year"
          });
        }
        return addLeadingZeros(weekYear, token3.length);
      },
      // ISO week-numbering year
      R: function R2(date2, token3) {
        var isoWeekYear = getUTCISOWeekYear(date2);
        return addLeadingZeros(isoWeekYear, token3.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function u2(date2, token3) {
        var year = date2.getUTCFullYear();
        return addLeadingZeros(year, token3.length);
      },
      // Quarter
      Q: function Q2(date2, token3, localize2) {
        var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
        switch (token3) {
          case "Q":
            return String(quarter);
          case "QQ":
            return addLeadingZeros(quarter, 2);
          case "Qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "QQQ":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function q2(date2, token3, localize2) {
        var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
        switch (token3) {
          case "q":
            return String(quarter);
          case "qq":
            return addLeadingZeros(quarter, 2);
          case "qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "qqq":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function M3(date2, token3, localize2) {
        var month = date2.getUTCMonth();
        switch (token3) {
          case "M":
          case "MM":
            return lightFormatters_default.M(date2, token3);
          case "Mo":
            return localize2.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "MMM":
            return localize2.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize2.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize2.month(month, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone month
      L: function L2(date2, token3, localize2) {
        var month = date2.getUTCMonth();
        switch (token3) {
          case "L":
            return String(month + 1);
          case "LL":
            return addLeadingZeros(month + 1, 2);
          case "Lo":
            return localize2.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "LLL":
            return localize2.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize2.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize2.month(month, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Local week of year
      w: function w2(date2, token3, localize2, options) {
        var week = getUTCWeek(date2, options);
        if (token3 === "wo") {
          return localize2.ordinalNumber(week, {
            unit: "week"
          });
        }
        return addLeadingZeros(week, token3.length);
      },
      // ISO week of year
      I: function I2(date2, token3, localize2) {
        var isoWeek = getUTCISOWeek(date2);
        if (token3 === "Io") {
          return localize2.ordinalNumber(isoWeek, {
            unit: "week"
          });
        }
        return addLeadingZeros(isoWeek, token3.length);
      },
      // Day of the month
      d: function d2(date2, token3, localize2) {
        if (token3 === "do") {
          return localize2.ordinalNumber(date2.getUTCDate(), {
            unit: "date"
          });
        }
        return lightFormatters_default.d(date2, token3);
      },
      // Day of year
      D: function D2(date2, token3, localize2) {
        var dayOfYear = getUTCDayOfYear(date2);
        if (token3 === "Do") {
          return localize2.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
          });
        }
        return addLeadingZeros(dayOfYear, token3.length);
      },
      // Day of week
      E: function E2(date2, token3, localize2) {
        var dayOfWeek = date2.getUTCDay();
        switch (token3) {
          case "E":
          case "EE":
          case "EEE":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function e2(date2, token3, localize2, options) {
        var dayOfWeek = date2.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token3) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return addLeadingZeros(localDayOfWeek, 2);
          case "eo":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "eee":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function c3(date2, token3, localize2, options) {
        var dayOfWeek = date2.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token3) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return addLeadingZeros(localDayOfWeek, token3.length);
          case "co":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "ccc":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function i3(date2, token3, localize2) {
        var dayOfWeek = date2.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token3) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return addLeadingZeros(isoDayOfWeek, token3.length);
          case "io":
            return localize2.ordinalNumber(isoDayOfWeek, {
              unit: "day"
            });
          case "iii":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function a4(date2, token3, localize2) {
        var hours2 = date2.getUTCHours();
        var dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
        switch (token3) {
          case "a":
          case "aa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function b2(date2, token3, localize2) {
        var hours2 = date2.getUTCHours();
        var dayPeriodEnumValue;
        if (hours2 === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours2 === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
        }
        switch (token3) {
          case "b":
          case "bb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function B2(date2, token3, localize2) {
        var hours2 = date2.getUTCHours();
        var dayPeriodEnumValue;
        if (hours2 >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours2 >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours2 >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token3) {
          case "B":
          case "BB":
          case "BBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function h2(date2, token3, localize2) {
        if (token3 === "ho") {
          var hours2 = date2.getUTCHours() % 12;
          if (hours2 === 0)
            hours2 = 12;
          return localize2.ordinalNumber(hours2, {
            unit: "hour"
          });
        }
        return lightFormatters_default.h(date2, token3);
      },
      // Hour [0-23]
      H: function H3(date2, token3, localize2) {
        if (token3 === "Ho") {
          return localize2.ordinalNumber(date2.getUTCHours(), {
            unit: "hour"
          });
        }
        return lightFormatters_default.H(date2, token3);
      },
      // Hour [0-11]
      K: function K2(date2, token3, localize2) {
        var hours2 = date2.getUTCHours() % 12;
        if (token3 === "Ko") {
          return localize2.ordinalNumber(hours2, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours2, token3.length);
      },
      // Hour [1-24]
      k: function k2(date2, token3, localize2) {
        var hours2 = date2.getUTCHours();
        if (hours2 === 0)
          hours2 = 24;
        if (token3 === "ko") {
          return localize2.ordinalNumber(hours2, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours2, token3.length);
      },
      // Minute
      m: function m3(date2, token3, localize2) {
        if (token3 === "mo") {
          return localize2.ordinalNumber(date2.getUTCMinutes(), {
            unit: "minute"
          });
        }
        return lightFormatters_default.m(date2, token3);
      },
      // Second
      s: function s4(date2, token3, localize2) {
        if (token3 === "so") {
          return localize2.ordinalNumber(date2.getUTCSeconds(), {
            unit: "second"
          });
        }
        return lightFormatters_default.s(date2, token3);
      },
      // Fraction of second
      S: function S3(date2, token3) {
        return lightFormatters_default.S(date2, token3);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function X2(date2, token3, _localize, options) {
        var originalDate = options._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token3) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function x2(date2, token3, _localize, options) {
        var originalDate = options._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token3) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function O2(date2, token3, _localize, options) {
        var originalDate = options._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token3) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function z2(date2, token3, _localize, options) {
        var originalDate = options._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token3) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function t2(date2, token3, _localize, options) {
        var originalDate = options._originalDate || date2;
        var timestamp2 = Math.floor(originalDate.getTime() / 1e3);
        return addLeadingZeros(timestamp2, token3.length);
      },
      // Milliseconds timestamp
      T: function T2(date2, token3, _localize, options) {
        var originalDate = options._originalDate || date2;
        var timestamp2 = originalDate.getTime();
        return addLeadingZeros(timestamp2, token3.length);
      }
    };
    formatters_default = formatters2;
  }
});

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter, timeLongFormatter, dateTimeLongFormatter, longFormatters, longFormatters_default;
var init_longFormatters = __esm({
  "node_modules/date-fns/esm/_lib/format/longFormatters/index.js"() {
    dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
      switch (pattern) {
        case "P":
          return formatLong2.date({
            width: "short"
          });
        case "PP":
          return formatLong2.date({
            width: "medium"
          });
        case "PPP":
          return formatLong2.date({
            width: "long"
          });
        case "PPPP":
        default:
          return formatLong2.date({
            width: "full"
          });
      }
    };
    timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
      switch (pattern) {
        case "p":
          return formatLong2.time({
            width: "short"
          });
        case "pp":
          return formatLong2.time({
            width: "medium"
          });
        case "ppp":
          return formatLong2.time({
            width: "long"
          });
        case "pppp":
        default:
          return formatLong2.time({
            width: "full"
          });
      }
    };
    dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong2);
      }
      var dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong2.dateTime({
            width: "short"
          });
          break;
        case "PP":
          dateTimeFormat = formatLong2.dateTime({
            width: "medium"
          });
          break;
        case "PPP":
          dateTimeFormat = formatLong2.dateTime({
            width: "long"
          });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong2.dateTime({
            width: "full"
          });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
    };
    longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    longFormatters_default = longFormatters;
  }
});

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date2) {
  var utcDate = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
  utcDate.setUTCFullYear(date2.getFullYear());
  return date2.getTime() - utcDate.getTime();
}
var init_getTimezoneOffsetInMilliseconds = __esm({
  "node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js"() {
  }
});

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
function isProtectedDayOfYearToken(token3) {
  return protectedDayOfYearTokens.indexOf(token3) !== -1;
}
function isProtectedWeekYearToken(token3) {
  return protectedWeekYearTokens.indexOf(token3) !== -1;
}
function throwProtectedError(token3, format4, input) {
  if (token3 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format4, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token3 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format4, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token3 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format4, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token3 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format4, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var protectedDayOfYearTokens, protectedWeekYearTokens;
var init_protectedTokens = __esm({
  "node_modules/date-fns/esm/_lib/protectedTokens/index.js"() {
    protectedDayOfYearTokens = ["D", "DD"];
    protectedWeekYearTokens = ["YY", "YYYY"];
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale, formatDistance, formatDistance_default;
var init_formatDistance = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js"() {
    formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    formatDistance = function formatDistance2(token3, count2, options) {
      var result;
      var tokenValue = formatDistanceLocale[token3];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count2 === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count2.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    formatDistance_default = formatDistance;
  }
});

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format4 = args.formats[width] || args.formats[args.defaultWidth];
    return format4;
  };
}
var init_buildFormatLongFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats, timeFormats, dateTimeFormats, formatLong, formatLong_default;
var init_formatLong = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js"() {
    init_buildFormatLongFn();
    dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    formatLong_default = formatLong;
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale, formatRelative, formatRelative_default;
var init_formatRelative = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js"() {
    formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    formatRelative = function formatRelative2(token3, _date, _baseDate, _options) {
      return formatRelativeLocale[token3];
    };
    formatRelative_default = formatRelative;
  }
});

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context2 = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context2 === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index3 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index3];
  };
}
var init_buildLocalizeFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues, quarterValues, monthValues, dayValues, dayPeriodValues, formattingDayPeriodValues, ordinalNumber, localize, localize_default;
var init_localize = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js"() {
    init_buildLocalizeFn();
    eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
      var number2 = Number(dirtyNumber);
      var rem100 = number2 % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number2 + "st";
          case 2:
            return number2 + "nd";
          case 3:
            return number2 + "rd";
        }
      }
      return number2 + "th";
    };
    localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    localize_default = localize;
  }
});

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string4) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string4.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key2 = Array.isArray(parsePatterns) ? findIndex2(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key2) : key2;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string4.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object2, predicate) {
  for (var key2 in object2) {
    if (object2.hasOwnProperty(key2) && predicate(object2[key2])) {
      return key2;
    }
  }
  return void 0;
}
function findIndex2(array, predicate) {
  for (var key2 = 0; key2 < array.length; key2++) {
    if (predicate(array[key2])) {
      return key2;
    }
  }
  return void 0;
}
var init_buildMatchFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string4) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string4.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string4.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string4.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var init_buildMatchPatternFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern, parseOrdinalNumberPattern, matchEraPatterns, parseEraPatterns, matchQuarterPatterns, parseQuarterPatterns, matchMonthPatterns, parseMonthPatterns, matchDayPatterns, parseDayPatterns, matchDayPeriodPatterns, parseDayPeriodPatterns, match2, match_default;
var init_match = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/match/index.js"() {
    init_buildMatchFn();
    init_buildMatchPatternFn();
    matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    parseOrdinalNumberPattern = /\d+/i;
    matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    match2 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback2(index3) {
          return index3 + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    match_default = match2;
  }
});

// node_modules/date-fns/esm/locale/en-US/index.js
var locale, en_US_default;
var init_en_US = __esm({
  "node_modules/date-fns/esm/locale/en-US/index.js"() {
    init_formatDistance();
    init_formatLong();
    init_formatRelative();
    init_localize();
    init_match();
    locale = {
      code: "en-US",
      formatDistance: formatDistance_default,
      formatLong: formatLong_default,
      formatRelative: formatRelative_default,
      localize: localize_default,
      match: match_default,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    en_US_default = locale;
  }
});

// node_modules/date-fns/esm/_lib/defaultLocale/index.js
var defaultLocale_default;
var init_defaultLocale = __esm({
  "node_modules/date-fns/esm/_lib/defaultLocale/index.js"() {
    init_en_US();
    defaultLocale_default = en_US_default;
  }
});

// node_modules/date-fns/esm/format/index.js
var format_exports = {};
__export(format_exports, {
  default: () => format
});
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions4 = getDefaultOptions();
  var locale3 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale_default;
  var firstWeekContainsDate = toInteger((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions4.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions4.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions4.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale3.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale3.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale3,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale3.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale3.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
var formattingTokensRegExp, longFormattingTokensRegExp, escapedStringRegExp, doubleQuoteRegExp, unescapedLatinCharacterRegExp;
var init_format = __esm({
  "node_modules/date-fns/esm/format/index.js"() {
    init_isValid();
    init_subMilliseconds();
    init_toDate();
    init_formatters();
    init_longFormatters();
    init_getTimezoneOffsetInMilliseconds();
    init_protectedTokens();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
    init_defaultLocale();
    formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp = /^'([^]*?)'?$/;
    doubleQuoteRegExp = /''/g;
    unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  }
});

// node_modules/history/index.js
var history_exports = {};
__export(history_exports, {
  Action: () => Action2,
  createBrowserHistory: () => createBrowserHistory,
  createHashHistory: () => createHashHistory,
  createMemoryHistory: () => createMemoryHistory,
  createPath: () => createPath,
  parsePath: () => parsePath
});
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e5) {
    }
  }
}
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$window = _options.window, window3 = _options$window === void 0 ? document.defaultView : _options$window;
  var globalHistory = window3.history;
  function getIndexAndLocation() {
    var _window$location = window3.location, pathname = _window$location.pathname, search = _window$location.search, hash2 = _window$location.hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname,
      search,
      hash: hash2,
      state: state.usr || null,
      key: state.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action2.Pop;
      var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index3 - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry2() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          true ? warning(
            false,
            // TODO: Write up a doc that explains our blocking strategy in
            // detail and link to it here so people can understand better what
            // is going on and how to avoid it.
            "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."
          ) : void 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window3.addEventListener(PopStateEventType, handlePop);
  var action = Action2.Pop;
  var _getIndexAndLocation2 = getIndexAndLocation(), index3 = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];
  var listeners = createEvents();
  var blockers = createEvents();
  if (index3 == null) {
    index3 = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index3
    }), "");
  }
  function createHref(to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  function getNextLocation(to2, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location.pathname,
      hash: "",
      search: ""
    }, typeof to2 === "string" ? parsePath(to2) : to2, {
      state,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index4) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index4
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location2, retry2) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location2,
      retry: retry2
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation3 = getIndexAndLocation();
    index3 = _getIndexAndLocation3[0];
    location = _getIndexAndLocation3[1];
    listeners.call({
      action,
      location
    });
  }
  function push(to2, state) {
    var nextAction = Action2.Push;
    var nextLocation = getNextLocation(to2, state);
    function retry2() {
      push(to2, state);
    }
    if (allowTx(nextAction, nextLocation, retry2)) {
      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index3 + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window3.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace2(to2, state) {
    var nextAction = Action2.Replace;
    var nextLocation = getNextLocation(to2, state);
    function retry2() {
      replace2(to2, state);
    }
    if (allowTx(nextAction, nextLocation, retry2)) {
      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index3), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history = {
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace: replace2,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window3.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window3.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, _options2$window = _options2.window, window3 = _options2$window === void 0 ? document.defaultView : _options2$window;
  var globalHistory = window3.history;
  function getIndexAndLocation() {
    var _parsePath = parsePath(window3.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash2 = _parsePath$hash === void 0 ? "" : _parsePath$hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname,
      search,
      hash: hash2,
      state: state.usr || null,
      key: state.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action2.Pop;
      var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index3 - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry2() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          true ? warning(
            false,
            // TODO: Write up a doc that explains our blocking strategy in
            // detail and link to it here so people can understand better
            // what is going on and how to avoid it.
            "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."
          ) : void 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window3.addEventListener(PopStateEventType, handlePop);
  window3.addEventListener(HashChangeEventType, function() {
    var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
    if (createPath(nextLocation) !== createPath(location)) {
      handlePop();
    }
  });
  var action = Action2.Pop;
  var _getIndexAndLocation6 = getIndexAndLocation(), index3 = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];
  var listeners = createEvents();
  var blockers = createEvents();
  if (index3 == null) {
    index3 = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index3
    }), "");
  }
  function getBaseHref() {
    var base = document.querySelector("base");
    var href = "";
    if (base && base.getAttribute("href")) {
      var url = window3.location.href;
      var hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href;
  }
  function createHref(to2) {
    return getBaseHref() + "#" + (typeof to2 === "string" ? to2 : createPath(to2));
  }
  function getNextLocation(to2, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location.pathname,
      hash: "",
      search: ""
    }, typeof to2 === "string" ? parsePath(to2) : to2, {
      state,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index4) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index4
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location2, retry2) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location2,
      retry: retry2
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation7 = getIndexAndLocation();
    index3 = _getIndexAndLocation7[0];
    location = _getIndexAndLocation7[1];
    listeners.call({
      action,
      location
    });
  }
  function push(to2, state) {
    var nextAction = Action2.Push;
    var nextLocation = getNextLocation(to2, state);
    function retry2() {
      push(to2, state);
    }
    true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to2) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry2)) {
      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index3 + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window3.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace2(to2, state) {
    var nextAction = Action2.Replace;
    var nextLocation = getNextLocation(to2, state);
    function retry2() {
      replace2(to2, state);
    }
    true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to2) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry2)) {
      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index3), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history = {
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace: replace2,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window3.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window3.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? ["/"] : _options3$initialEntr, initialIndex = _options3.initialIndex;
  var entries = initialEntries.map(function(entry) {
    var location2 = readOnly(_extends({
      pathname: "/",
      search: "",
      hash: "",
      state: null,
      key: createKey()
    }, typeof entry === "string" ? parsePath(entry) : entry));
    true ? warning(location2.pathname.charAt(0) === "/", "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(entry) + ")") : void 0;
    return location2;
  });
  var index3 = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
  var action = Action2.Pop;
  var location = entries[index3];
  var listeners = createEvents();
  var blockers = createEvents();
  function createHref(to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  function getNextLocation(to2, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location.pathname,
      search: "",
      hash: ""
    }, typeof to2 === "string" ? parsePath(to2) : to2, {
      state,
      key: createKey()
    }));
  }
  function allowTx(action2, location2, retry2) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location2,
      retry: retry2
    }), false);
  }
  function applyTx(nextAction, nextLocation) {
    action = nextAction;
    location = nextLocation;
    listeners.call({
      action,
      location
    });
  }
  function push(to2, state) {
    var nextAction = Action2.Push;
    var nextLocation = getNextLocation(to2, state);
    function retry2() {
      push(to2, state);
    }
    true ? warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.push(" + JSON.stringify(to2) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry2)) {
      index3 += 1;
      entries.splice(index3, entries.length, nextLocation);
      applyTx(nextAction, nextLocation);
    }
  }
  function replace2(to2, state) {
    var nextAction = Action2.Replace;
    var nextLocation = getNextLocation(to2, state);
    function retry2() {
      replace2(to2, state);
    }
    true ? warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(to2) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry2)) {
      entries[index3] = nextLocation;
      applyTx(nextAction, nextLocation);
    }
  }
  function go(delta) {
    var nextIndex = clamp(index3 + delta, 0, entries.length - 1);
    var nextAction = Action2.Pop;
    var nextLocation = entries[nextIndex];
    function retry2() {
      go(delta);
    }
    if (allowTx(nextAction, nextLocation, retry2)) {
      index3 = nextIndex;
      applyTx(nextAction, nextLocation);
    }
  }
  var history = {
    get index() {
      return index3;
    },
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace: replace2,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      return blockers.push(blocker);
    }
  };
  return history;
}
function clamp(n4, lowerBound, upperBound) {
  return Math.min(Math.max(n4, lowerBound), upperBound);
}
function promptBeforeUnload(event) {
  event.preventDefault();
  event.returnValue = "";
}
function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },
    push: function push(fn) {
      handlers.push(fn);
      return function() {
        handlers = handlers.filter(function(handler) {
          return handler !== fn;
        });
      };
    },
    call: function call(arg) {
      handlers.forEach(function(fn) {
        return fn && fn(arg);
      });
    }
  };
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref2) {
  var _ref$pathname = _ref2.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref2.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref2.hash, hash2 = _ref$hash === void 0 ? "" : _ref$hash;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path3) {
  var parsedPath = {};
  if (path3) {
    var hashIndex = path3.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path3.substr(hashIndex);
      path3 = path3.substr(0, hashIndex);
    }
    var searchIndex = path3.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path3.substr(searchIndex);
      path3 = path3.substr(0, searchIndex);
    }
    if (path3) {
      parsedPath.pathname = path3;
    }
  }
  return parsedPath;
}
var Action2, readOnly, BeforeUnloadEventType, HashChangeEventType, PopStateEventType;
var init_history = __esm({
  "node_modules/history/index.js"() {
    init_extends();
    (function(Action4) {
      Action4["Pop"] = "POP";
      Action4["Push"] = "PUSH";
      Action4["Replace"] = "REPLACE";
    })(Action2 || (Action2 = {}));
    readOnly = true ? function(obj) {
      return Object.freeze(obj);
    } : function(obj) {
      return obj;
    };
    BeforeUnloadEventType = "beforeunload";
    HashChangeEventType = "hashchange";
    PopStateEventType = "popstate";
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React18 = require_react();
        function is2(x3, y4) {
          return x3 === y4 && (x3 !== 0 || 1 / x3 === 1 / y4) || x3 !== x3 && y4 !== y4;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useSyncExternalStore2 = React18.useSyncExternalStore;
        var useRef15 = React18.useRef, useEffect16 = React18.useEffect, useMemo8 = React18.useMemo, useDebugValue = React18.useDebugValue;
        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
          var instRef = useRef15(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo8(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual2 !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual2(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore2(subscribe, getSelection, getServerSelection);
          useEffect16(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/with-selector.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// node_modules/lodash/escapeRegExp.js
var require_escapeRegExp = __commonJS({
  "node_modules/lodash/escapeRegExp.js"(exports, module2) {
    var toString2 = require_toString();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(string4) {
      string4 = toString2(string4);
      return string4 && reHasRegExpChar.test(string4) ? string4.replace(reRegExpChar, "\\$&") : string4;
    }
    module2.exports = escapeRegExp;
  }
});

// node_modules/date-fns/esm/addDays/index.js
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date2;
  }
  date2.setDate(date2.getDate() + amount);
  return date2;
}
var init_addDays = __esm({
  "node_modules/date-fns/esm/addDays/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addMonths/index.js
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date2;
  }
  var dayOfMonth = date2.getDate();
  var endOfDesiredMonth = new Date(date2.getTime());
  endOfDesiredMonth.setMonth(date2.getMonth() + amount + 1, 0);
  var daysInMonth2 = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth2) {
    return endOfDesiredMonth;
  } else {
    date2.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date2;
  }
}
var init_addMonths = __esm({
  "node_modules/date-fns/esm/addMonths/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfDay = __esm({
  "node_modules/date-fns/esm/startOfDay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameDay/index.js
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
var init_isSameDay = __esm({
  "node_modules/date-fns/esm/isSameDay/index.js"() {
    init_startOfDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarDays/index.js
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY2);
}
var MILLISECONDS_IN_DAY2;
var init_differenceInCalendarDays = __esm({
  "node_modules/date-fns/esm/differenceInCalendarDays/index.js"() {
    init_getTimezoneOffsetInMilliseconds();
    init_startOfDay();
    init_requiredArgs();
    MILLISECONDS_IN_DAY2 = 864e5;
  }
});

// node_modules/date-fns/esm/differenceInDays/index.js
function compareLocalAsc(dateLeft, dateRight) {
  var diff2 = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
  if (diff2 < 0) {
    return -1;
  } else if (diff2 > 0) {
    return 1;
  } else {
    return diff2;
  }
}
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign2 * difference);
  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign2);
  var result = sign2 * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
var init_differenceInDays = __esm({
  "node_modules/date-fns/esm/differenceInDays/index.js"() {
    init_toDate();
    init_differenceInCalendarDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/constants/index.js
var daysInWeek, daysInYear, maxTime, millisecondsInMinute, millisecondsInHour, millisecondsInSecond, minTime, minutesInHour, monthsInQuarter, monthsInYear, quartersInYear, secondsInHour, secondsInMinute, secondsInDay, secondsInWeek, secondsInYear, secondsInMonth, secondsInQuarter;
var init_constants2 = __esm({
  "node_modules/date-fns/esm/constants/index.js"() {
    daysInWeek = 7;
    daysInYear = 365.2425;
    maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
    millisecondsInMinute = 6e4;
    millisecondsInHour = 36e5;
    millisecondsInSecond = 1e3;
    minTime = -maxTime;
    minutesInHour = 60;
    monthsInQuarter = 3;
    monthsInYear = 12;
    quartersInYear = 4;
    secondsInHour = 3600;
    secondsInMinute = 60;
    secondsInDay = secondsInHour * 24;
    secondsInWeek = secondsInDay * 7;
    secondsInYear = secondsInDay * daysInYear;
    secondsInMonth = secondsInYear / 12;
    secondsInQuarter = secondsInMonth * 3;
  }
});

// node_modules/date-fns/esm/differenceInMilliseconds/index.js
function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}
var init_differenceInMilliseconds = __esm({
  "node_modules/date-fns/esm/differenceInMilliseconds/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/roundingMethods/index.js
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}
var roundingMap, defaultRoundingMethod;
var init_roundingMethods = __esm({
  "node_modules/date-fns/esm/_lib/roundingMethods/index.js"() {
    roundingMap = {
      ceil: Math.ceil,
      round: Math.round,
      floor: Math.floor,
      trunc: function trunc(value) {
        return value < 0 ? Math.ceil(value) : Math.floor(value);
      }
      // Math.trunc is not supported by IE
    };
    defaultRoundingMethod = "trunc";
  }
});

// node_modules/date-fns/esm/differenceInHours/index.js
function differenceInHours(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff2 = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff2);
}
var init_differenceInHours = __esm({
  "node_modules/date-fns/esm/differenceInHours/index.js"() {
    init_constants2();
    init_differenceInMilliseconds();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/differenceInMinutes/index.js
function differenceInMinutes(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff2 = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff2);
}
var init_differenceInMinutes = __esm({
  "node_modules/date-fns/esm/differenceInMinutes/index.js"() {
    init_constants2();
    init_differenceInMilliseconds();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/endOfDay/index.js
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfDay = __esm({
  "node_modules/date-fns/esm/endOfDay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarMonths/index.js
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff2 = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff2;
}
var init_differenceInCalendarMonths = __esm({
  "node_modules/date-fns/esm/differenceInCalendarMonths/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/compareAsc/index.js
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff2 = dateLeft.getTime() - dateRight.getTime();
  if (diff2 < 0) {
    return -1;
  } else if (diff2 > 0) {
    return 1;
  } else {
    return diff2;
  }
}
var init_compareAsc = __esm({
  "node_modules/date-fns/esm/compareAsc/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfMonth/index.js
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var month = date2.getMonth();
  date2.setFullYear(date2.getFullYear(), month + 1, 0);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfMonth = __esm({
  "node_modules/date-fns/esm/endOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isLastDayOfMonth/index.js
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  return endOfDay(date2).getTime() === endOfMonth(date2).getTime();
}
var init_isLastDayOfMonth = __esm({
  "node_modules/date-fns/esm/isLastDayOfMonth/index.js"() {
    init_toDate();
    init_endOfDay();
    init_endOfMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInMonths/index.js
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result;
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign2 * difference);
    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign2;
    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign2 * (difference - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
var init_differenceInMonths = __esm({
  "node_modules/date-fns/esm/differenceInMonths/index.js"() {
    init_toDate();
    init_differenceInCalendarMonths();
    init_compareAsc();
    init_requiredArgs();
    init_isLastDayOfMonth();
  }
});

// node_modules/date-fns/esm/differenceInSeconds/index.js
function differenceInSeconds(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff2 = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff2);
}
var init_differenceInSeconds = __esm({
  "node_modules/date-fns/esm/differenceInSeconds/index.js"() {
    init_differenceInMilliseconds();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/differenceInWeeks/index.js
function differenceInWeeks(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff2 = differenceInDays(dateLeft, dateRight) / 7;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff2);
}
var init_differenceInWeeks = __esm({
  "node_modules/date-fns/esm/differenceInWeeks/index.js"() {
    init_differenceInDays();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/differenceInCalendarYears/index.js
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
var init_differenceInCalendarYears = __esm({
  "node_modules/date-fns/esm/differenceInCalendarYears/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInYears/index.js
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
  dateLeft.setFullYear(1584);
  dateRight.setFullYear(1584);
  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - Number(isLastYearNotFull));
  return result === 0 ? 0 : result;
}
var init_differenceInYears = __esm({
  "node_modules/date-fns/esm/differenceInYears/index.js"() {
    init_toDate();
    init_differenceInCalendarYears();
    init_compareAsc();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfMinute/index.js
function startOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setSeconds(0, 0);
  return date2;
}
var init_startOfMinute = __esm({
  "node_modules/date-fns/esm/startOfMinute/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addWeeks/index.js
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days3 = amount * 7;
  return addDays(dirtyDate, days3);
}
var init_addWeeks = __esm({
  "node_modules/date-fns/esm/addWeeks/index.js"() {
    init_toInteger();
    init_addDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfWeek/index.js
function startOfWeek(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  var diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date2.setDate(date2.getDate() - diff2);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfWeek = __esm({
  "node_modules/date-fns/esm/startOfWeek/index.js"() {
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/eachWeekOfInterval/index.js
function eachWeekOfInterval(dirtyInterval, options) {
  requiredArgs(1, arguments);
  var interval2 = dirtyInterval || {};
  var startDate = toDate(interval2.start);
  var endDate = toDate(interval2.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var startDateWeek = startOfWeek(startDate, options);
  var endDateWeek = startOfWeek(endDate, options);
  startDateWeek.setHours(15);
  endDateWeek.setHours(15);
  endTime = endDateWeek.getTime();
  var weeks2 = [];
  var currentWeek = startDateWeek;
  while (currentWeek.getTime() <= endTime) {
    currentWeek.setHours(0);
    weeks2.push(toDate(currentWeek));
    currentWeek = addWeeks(currentWeek, 1);
    currentWeek.setHours(15);
  }
  return weeks2;
}
var init_eachWeekOfInterval = __esm({
  "node_modules/date-fns/esm/eachWeekOfInterval/index.js"() {
    init_addWeeks();
    init_startOfWeek();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfMonth/index.js
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfMonth = __esm({
  "node_modules/date-fns/esm/startOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfMinute/index.js
function endOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setSeconds(59, 999);
  return date2;
}
var init_endOfMinute = __esm({
  "node_modules/date-fns/esm/endOfMinute/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getMinutes/index.js
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var minutes2 = date2.getMinutes();
  return minutes2;
}
var init_getMinutes = __esm({
  "node_modules/date-fns/esm/getMinutes/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getWeekYear/index.js
function getWeekYear(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var defaultOptions4 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getWeekYear = __esm({
  "node_modules/date-fns/esm/getWeekYear/index.js"() {
    init_startOfWeek();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/startOfWeekYear/index.js
function startOfWeekYear(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  var year = getWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date2 = startOfWeek(firstWeek, options);
  return date2;
}
var init_startOfWeekYear = __esm({
  "node_modules/date-fns/esm/startOfWeekYear/index.js"() {
    init_getWeekYear();
    init_startOfWeek();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/getWeek/index.js
function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff2 = startOfWeek(date2, options).getTime() - startOfWeekYear(date2, options).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK3) + 1;
}
var MILLISECONDS_IN_WEEK3;
var init_getWeek = __esm({
  "node_modules/date-fns/esm/getWeek/index.js"() {
    init_startOfWeek();
    init_startOfWeekYear();
    init_toDate();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK3 = 6048e5;
  }
});

// node_modules/date-fns/esm/lastDayOfMonth/index.js
function lastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var month = date2.getMonth();
  date2.setFullYear(date2.getFullYear(), month + 1, 0);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_lastDayOfMonth = __esm({
  "node_modules/date-fns/esm/lastDayOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isAfter/index.js
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date2.getTime() > dateToCompare.getTime();
}
var init_isAfter = __esm({
  "node_modules/date-fns/esm/isAfter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date2.getTime() < dateToCompare.getTime();
}
var init_isBefore = __esm({
  "node_modules/date-fns/esm/isBefore/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++)
    arr2[i4] = arr[i4];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o4, minLen) {
  if (!o4)
    return;
  if (typeof o4 === "string")
    return _arrayLikeToArray(o4, minLen);
  var n4 = Object.prototype.toString.call(o4).slice(8, -1);
  if (n4 === "Object" && o4.constructor)
    n4 = o4.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o4);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray(o4, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(o4, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o4[Symbol.iterator] || o4["@@iterator"];
  if (!it2) {
    if (Array.isArray(o4) || (it2 = _unsupportedIterableToArray(o4)) || allowArrayLike && o4 && typeof o4.length === "number") {
      if (it2)
        o4 = it2;
      var i4 = 0;
      var F2 = function F3() {
      };
      return {
        s: F2,
        n: function n4() {
          if (i4 >= o4.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o4[i4++]
          };
        },
        e: function e5(_e2) {
          throw _e2;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s5() {
      it2 = it2.call(o4);
    },
    n: function n4() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e5(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f3() {
      try {
        if (!normalCompletion && it2["return"] != null)
          it2["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var init_createForOfIteratorHelper = __esm({
  "node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"() {
    init_unsupportedIterableToArray();
  }
});

// node_modules/date-fns/esm/_lib/assign/index.js
function assign2(target, object2) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, property)) {
      ;
      target[property] = object2[property];
    }
  }
  return target;
}
var init_assign = __esm({
  "node_modules/date-fns/esm/_lib/assign/index.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o4) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf3(o5) {
    return o5.__proto__ || Object.getPrototypeOf(o5);
  };
  return _getPrototypeOf(o4);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e5) {
    return false;
  }
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var init_createSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/createSuper.js"() {
    init_getPrototypeOf();
    init_isNativeReflectConstruct();
    init_possibleConstructorReturn();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i4 = 0; i4 < props.length; i4++) {
    var descriptor = props[i4];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/date-fns/esm/parse/_lib/Setter.js
var TIMEZONE_UNIT_PRIORITY, Setter, ValueSetter, DateToSystemTimezoneSetter;
var init_Setter = __esm({
  "node_modules/date-fns/esm/parse/_lib/Setter.js"() {
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    TIMEZONE_UNIT_PRIORITY = 10;
    Setter = function() {
      function Setter2() {
        _classCallCheck(this, Setter2);
        _defineProperty(this, "priority", void 0);
        _defineProperty(this, "subPriority", 0);
      }
      _createClass(Setter2, [{
        key: "validate",
        value: function validate2(_utcDate, _options) {
          return true;
        }
      }]);
      return Setter2;
    }();
    ValueSetter = function(_Setter) {
      _inherits(ValueSetter2, _Setter);
      var _super = _createSuper(ValueSetter2);
      function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
        var _this;
        _classCallCheck(this, ValueSetter2);
        _this = _super.call(this);
        _this.value = value;
        _this.validateValue = validateValue;
        _this.setValue = setValue;
        _this.priority = priority;
        if (subPriority) {
          _this.subPriority = subPriority;
        }
        return _this;
      }
      _createClass(ValueSetter2, [{
        key: "validate",
        value: function validate2(utcDate, options) {
          return this.validateValue(utcDate, this.value, options);
        }
      }, {
        key: "set",
        value: function set4(utcDate, flags, options) {
          return this.setValue(utcDate, flags, this.value, options);
        }
      }]);
      return ValueSetter2;
    }(Setter);
    DateToSystemTimezoneSetter = function(_Setter2) {
      _inherits(DateToSystemTimezoneSetter2, _Setter2);
      var _super2 = _createSuper(DateToSystemTimezoneSetter2);
      function DateToSystemTimezoneSetter2() {
        var _this2;
        _classCallCheck(this, DateToSystemTimezoneSetter2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
        _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
        return _this2;
      }
      _createClass(DateToSystemTimezoneSetter2, [{
        key: "set",
        value: function set4(date2, flags) {
          if (flags.timestampIsSet) {
            return date2;
          }
          var convertedDate = /* @__PURE__ */ new Date(0);
          convertedDate.setFullYear(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate());
          convertedDate.setHours(date2.getUTCHours(), date2.getUTCMinutes(), date2.getUTCSeconds(), date2.getUTCMilliseconds());
          return convertedDate;
        }
      }]);
      return DateToSystemTimezoneSetter2;
    }(Setter);
  }
});

// node_modules/date-fns/esm/parse/_lib/Parser.js
var Parser;
var init_Parser2 = __esm({
  "node_modules/date-fns/esm/parse/_lib/Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    init_Setter();
    Parser = function() {
      function Parser2() {
        _classCallCheck(this, Parser2);
        _defineProperty(this, "incompatibleTokens", void 0);
        _defineProperty(this, "priority", void 0);
        _defineProperty(this, "subPriority", void 0);
      }
      _createClass(Parser2, [{
        key: "run",
        value: function run(dateString, token3, match5, options) {
          var result = this.parse(dateString, token3, match5, options);
          if (!result) {
            return null;
          }
          return {
            setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
            rest: result.rest
          };
        }
      }, {
        key: "validate",
        value: function validate2(_utcDate, _value, _options) {
          return true;
        }
      }]);
      return Parser2;
    }();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js
var EraParser;
var init_EraParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    EraParser = function(_Parser) {
      _inherits(EraParser2, _Parser);
      var _super = _createSuper(EraParser2);
      function EraParser2() {
        var _this;
        _classCallCheck(this, EraParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 140);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
        return _this;
      }
      _createClass(EraParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "G":
            case "GG":
            case "GGG":
              return match5.era(dateString, {
                width: "abbreviated"
              }) || match5.era(dateString, {
                width: "narrow"
              });
            case "GGGGG":
              return match5.era(dateString, {
                width: "narrow"
              });
            case "GGGG":
            default:
              return match5.era(dateString, {
                width: "wide"
              }) || match5.era(dateString, {
                width: "abbreviated"
              }) || match5.era(dateString, {
                width: "narrow"
              });
          }
        }
      }, {
        key: "set",
        value: function set4(date2, flags, value) {
          flags.era = value;
          date2.setUTCFullYear(value, 0, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return EraParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/constants.js
var numericPatterns, timezonePatterns;
var init_constants3 = __esm({
  "node_modules/date-fns/esm/parse/_lib/constants.js"() {
    numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59
      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/
      // 0 to 9999, -0 to -9999
    };
    timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };
  }
});

// node_modules/date-fns/esm/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign2 = matchResult[1] === "+" ? 1 : -1;
  var hours2 = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes2 = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds2 = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign2 * (hours2 * millisecondsInHour + minutes2 * millisecondsInMinute + seconds2 * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n4, dateString) {
  switch (n4) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n4 + "}"), dateString);
  }
}
function parseNDigitsSigned(n4, dateString) {
  switch (n4) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n4 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var init_utils3 = __esm({
  "node_modules/date-fns/esm/parse/_lib/utils.js"() {
    init_constants2();
    init_constants3();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js
var YearParser;
var init_YearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    YearParser = function(_Parser) {
      _inherits(YearParser2, _Parser);
      var _super = _createSuper(YearParser2);
      function YearParser2() {
        var _this;
        _classCallCheck(this, YearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(YearParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          var valueCallback3 = function valueCallback4(year) {
            return {
              year,
              isTwoDigitYear: token3 === "yy"
            };
          };
          switch (token3) {
            case "y":
              return mapValue(parseNDigits(4, dateString), valueCallback3);
            case "yo":
              return mapValue(match5.ordinalNumber(dateString, {
                unit: "year"
              }), valueCallback3);
            default:
              return mapValue(parseNDigits(token3.length, dateString), valueCallback3);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set4(date2, flags, value) {
          var currentYear = date2.getUTCFullYear();
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date2.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
          var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date2.setUTCFullYear(year, 0, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return YearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser;
var init_LocalWeekYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    init_getUTCWeekYear();
    init_startOfUTCWeek();
    LocalWeekYearParser = function(_Parser) {
      _inherits(LocalWeekYearParser2, _Parser);
      var _super = _createSuper(LocalWeekYearParser2);
      function LocalWeekYearParser2() {
        var _this;
        _classCallCheck(this, LocalWeekYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
        return _this;
      }
      _createClass(LocalWeekYearParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          var valueCallback3 = function valueCallback4(year) {
            return {
              year,
              isTwoDigitYear: token3 === "YY"
            };
          };
          switch (token3) {
            case "Y":
              return mapValue(parseNDigits(4, dateString), valueCallback3);
            case "Yo":
              return mapValue(match5.ordinalNumber(dateString, {
                unit: "year"
              }), valueCallback3);
            default:
              return mapValue(parseNDigits(token3.length, dateString), valueCallback3);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set4(date2, flags, value, options) {
          var currentYear = getUTCWeekYear(date2, options);
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date2.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
            date2.setUTCHours(0, 0, 0, 0);
            return startOfUTCWeek(date2, options);
          }
          var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date2.setUTCFullYear(year, 0, options.firstWeekContainsDate);
          date2.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date2, options);
        }
      }]);
      return LocalWeekYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser;
var init_ISOWeekYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    init_startOfUTCISOWeek();
    ISOWeekYearParser = function(_Parser) {
      _inherits(ISOWeekYearParser2, _Parser);
      var _super = _createSuper(ISOWeekYearParser2);
      function ISOWeekYearParser2() {
        var _this;
        _classCallCheck(this, ISOWeekYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ISOWeekYearParser2, [{
        key: "parse",
        value: function parse4(dateString, token3) {
          if (token3 === "R") {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token3.length, dateString);
        }
      }, {
        key: "set",
        value: function set4(_date, _flags, value) {
          var firstWeekOfYear = /* @__PURE__ */ new Date(0);
          firstWeekOfYear.setUTCFullYear(value, 0, 4);
          firstWeekOfYear.setUTCHours(0, 0, 0, 0);
          return startOfUTCISOWeek(firstWeekOfYear);
        }
      }]);
      return ISOWeekYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser;
var init_ExtendedYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    ExtendedYearParser = function(_Parser) {
      _inherits(ExtendedYearParser2, _Parser);
      var _super = _createSuper(ExtendedYearParser2);
      function ExtendedYearParser2() {
        var _this;
        _classCallCheck(this, ExtendedYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ExtendedYearParser2, [{
        key: "parse",
        value: function parse4(dateString, token3) {
          if (token3 === "u") {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token3.length, dateString);
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCFullYear(value, 0, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return ExtendedYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js
var QuarterParser;
var init_QuarterParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    QuarterParser = function(_Parser) {
      _inherits(QuarterParser2, _Parser);
      var _super = _createSuper(QuarterParser2);
      function QuarterParser2() {
        var _this;
        _classCallCheck(this, QuarterParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(QuarterParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "Q":
            case "QQ":
              return parseNDigits(token3.length, dateString);
            case "Qo":
              return match5.ordinalNumber(dateString, {
                unit: "quarter"
              });
            case "QQQ":
              return match5.quarter(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQQ":
              return match5.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQ":
            default:
              return match5.quarter(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.quarter(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMonth((value - 1) * 3, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return QuarterParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser;
var init_StandAloneQuarterParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    StandAloneQuarterParser = function(_Parser) {
      _inherits(StandAloneQuarterParser2, _Parser);
      var _super = _createSuper(StandAloneQuarterParser2);
      function StandAloneQuarterParser2() {
        var _this;
        _classCallCheck(this, StandAloneQuarterParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(StandAloneQuarterParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "q":
            case "qq":
              return parseNDigits(token3.length, dateString);
            case "qo":
              return match5.ordinalNumber(dateString, {
                unit: "quarter"
              });
            case "qqq":
              return match5.quarter(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match5.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqqq":
              return match5.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqq":
            default:
              return match5.quarter(dateString, {
                width: "wide",
                context: "standalone"
              }) || match5.quarter(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match5.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMonth((value - 1) * 3, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return StandAloneQuarterParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js
var MonthParser;
var init_MonthParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_utils3();
    init_Parser2();
    init_constants3();
    MonthParser = function(_Parser) {
      _inherits(MonthParser2, _Parser);
      var _super = _createSuper(MonthParser2);
      function MonthParser2() {
        var _this;
        _classCallCheck(this, MonthParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        return _this;
      }
      _createClass(MonthParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          var valueCallback3 = function valueCallback4(value) {
            return value - 1;
          };
          switch (token3) {
            case "M":
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
            case "MM":
              return mapValue(parseNDigits(2, dateString), valueCallback3);
            case "Mo":
              return mapValue(match5.ordinalNumber(dateString, {
                unit: "month"
              }), valueCallback3);
            case "MMM":
              return match5.month(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMMM":
              return match5.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMM":
            default:
              return match5.month(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.month(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMonth(value, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return MonthParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser;
var init_StandAloneMonthParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    StandAloneMonthParser = function(_Parser) {
      _inherits(StandAloneMonthParser2, _Parser);
      var _super = _createSuper(StandAloneMonthParser2);
      function StandAloneMonthParser2() {
        var _this;
        _classCallCheck(this, StandAloneMonthParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(StandAloneMonthParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          var valueCallback3 = function valueCallback4(value) {
            return value - 1;
          };
          switch (token3) {
            case "L":
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
            case "LL":
              return mapValue(parseNDigits(2, dateString), valueCallback3);
            case "Lo":
              return mapValue(match5.ordinalNumber(dateString, {
                unit: "month"
              }), valueCallback3);
            case "LLL":
              return match5.month(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match5.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLLL":
              return match5.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLL":
            default:
              return match5.month(dateString, {
                width: "wide",
                context: "standalone"
              }) || match5.month(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match5.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMonth(value, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return StandAloneMonthParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCWeek/index.js
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff2 = getUTCWeek(date2, options) - week;
  date2.setUTCDate(date2.getUTCDate() - diff2 * 7);
  return date2;
}
var init_setUTCWeek = __esm({
  "node_modules/date-fns/esm/_lib/setUTCWeek/index.js"() {
    init_toInteger();
    init_toDate();
    init_getUTCWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser;
var init_LocalWeekParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    init_setUTCWeek();
    init_startOfUTCWeek();
    LocalWeekParser = function(_Parser) {
      _inherits(LocalWeekParser2, _Parser);
      var _super = _createSuper(LocalWeekParser2);
      function LocalWeekParser2() {
        var _this;
        _classCallCheck(this, LocalWeekParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
        return _this;
      }
      _createClass(LocalWeekParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "w":
              return parseNumericPattern(numericPatterns.week, dateString);
            case "wo":
              return match5.ordinalNumber(dateString, {
                unit: "week"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value, options) {
          return startOfUTCWeek(setUTCWeek(date2, value, options), options);
        }
      }]);
      return LocalWeekParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff2 = getUTCISOWeek(date2) - isoWeek;
  date2.setUTCDate(date2.getUTCDate() - diff2 * 7);
  return date2;
}
var init_setUTCISOWeek = __esm({
  "node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js"() {
    init_toInteger();
    init_toDate();
    init_getUTCISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser;
var init_ISOWeekParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    init_setUTCISOWeek();
    init_startOfUTCISOWeek();
    ISOWeekParser = function(_Parser) {
      _inherits(ISOWeekParser2, _Parser);
      var _super = _createSuper(ISOWeekParser2);
      function ISOWeekParser2() {
        var _this;
        _classCallCheck(this, ISOWeekParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ISOWeekParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "I":
              return parseNumericPattern(numericPatterns.week, dateString);
            case "Io":
              return match5.ordinalNumber(dateString, {
                unit: "week"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          return startOfUTCISOWeek(setUTCISOWeek(date2, value));
        }
      }]);
      return ISOWeekParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH, DAYS_IN_MONTH_LEAP_YEAR, DateParser;
var init_DateParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_utils3();
    init_Parser2();
    init_constants3();
    DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    DateParser = function(_Parser) {
      _inherits(DateParser2, _Parser);
      var _super = _createSuper(DateParser2);
      function DateParser2() {
        var _this;
        _classCallCheck(this, DateParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(DateParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "d":
              return parseNumericPattern(numericPatterns.date, dateString);
            case "do":
              return match5.ordinalNumber(dateString, {
                unit: "date"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(date2, value) {
          var year = date2.getUTCFullYear();
          var isLeapYear3 = isLeapYearIndex(year);
          var month = date2.getUTCMonth();
          if (isLeapYear3) {
            return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
          } else {
            return value >= 1 && value <= DAYS_IN_MONTH[month];
          }
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCDate(value);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return DateParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser;
var init_DayOfYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    DayOfYearParser = function(_Parser) {
      _inherits(DayOfYearParser2, _Parser);
      var _super = _createSuper(DayOfYearParser2);
      function DayOfYearParser2() {
        var _this;
        _classCallCheck(this, DayOfYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(DayOfYearParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "D":
            case "DD":
              return parseNumericPattern(numericPatterns.dayOfYear, dateString);
            case "Do":
              return match5.ordinalNumber(dateString, {
                unit: "date"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(date2, value) {
          var year = date2.getUTCFullYear();
          var isLeapYear3 = isLeapYearIndex(year);
          if (isLeapYear3) {
            return value >= 1 && value <= 366;
          } else {
            return value >= 1 && value <= 365;
          }
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMonth(0, value);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return DayOfYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCDay/index.js
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date2.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff2 = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date2.setUTCDate(date2.getUTCDate() + diff2);
  return date2;
}
var init_setUTCDay = __esm({
  "node_modules/date-fns/esm/_lib/setUTCDay/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js
var DayParser;
var init_DayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_setUTCDay();
    DayParser = function(_Parser) {
      _inherits(DayParser2, _Parser);
      var _super = _createSuper(DayParser2);
      function DayParser2() {
        var _this;
        _classCallCheck(this, DayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(DayParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "E":
            case "EE":
            case "EEE":
              return match5.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEE":
              return match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEEE":
              return match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEE":
            default:
              return match5.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value, options) {
          date2 = setUTCDay(date2, value, options);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return DayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser;
var init_LocalDayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    init_setUTCDay();
    LocalDayParser = function(_Parser) {
      _inherits(LocalDayParser2, _Parser);
      var _super = _createSuper(LocalDayParser2);
      function LocalDayParser2() {
        var _this;
        _classCallCheck(this, LocalDayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
        return _this;
      }
      _createClass(LocalDayParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5, options) {
          var valueCallback3 = function valueCallback4(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token3) {
            case "e":
            case "ee":
              return mapValue(parseNDigits(token3.length, dateString), valueCallback3);
            case "eo":
              return mapValue(match5.ordinalNumber(dateString, {
                unit: "day"
              }), valueCallback3);
            case "eee":
              return match5.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeee":
              return match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeeee":
              return match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeee":
            default:
              return match5.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value, options) {
          date2 = setUTCDay(date2, value, options);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return LocalDayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser;
var init_StandAloneLocalDayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    init_setUTCDay();
    StandAloneLocalDayParser = function(_Parser) {
      _inherits(StandAloneLocalDayParser2, _Parser);
      var _super = _createSuper(StandAloneLocalDayParser2);
      function StandAloneLocalDayParser2() {
        var _this;
        _classCallCheck(this, StandAloneLocalDayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
        return _this;
      }
      _createClass(StandAloneLocalDayParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5, options) {
          var valueCallback3 = function valueCallback4(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token3) {
            case "c":
            case "cc":
              return mapValue(parseNDigits(token3.length, dateString), valueCallback3);
            case "co":
              return mapValue(match5.ordinalNumber(dateString, {
                unit: "day"
              }), valueCallback3);
            case "ccc":
              return match5.day(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match5.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "ccccc":
              return match5.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "cccccc":
              return match5.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "cccc":
            default:
              return match5.day(dateString, {
                width: "wide",
                context: "standalone"
              }) || match5.day(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match5.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value, options) {
          date2 = setUTCDay(date2, value, options);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return StandAloneLocalDayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCISODay/index.js
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date2 = toDate(dirtyDate);
  var currentDay = date2.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff2 = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date2.setUTCDate(date2.getUTCDate() + diff2);
  return date2;
}
var init_setUTCISODay = __esm({
  "node_modules/date-fns/esm/_lib/setUTCISODay/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js
var ISODayParser;
var init_ISODayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    init_setUTCISODay();
    ISODayParser = function(_Parser) {
      _inherits(ISODayParser2, _Parser);
      var _super = _createSuper(ISODayParser2);
      function ISODayParser2() {
        var _this;
        _classCallCheck(this, ISODayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ISODayParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          var valueCallback3 = function valueCallback4(value) {
            if (value === 0) {
              return 7;
            }
            return value;
          };
          switch (token3) {
            case "i":
            case "ii":
              return parseNDigits(token3.length, dateString);
            case "io":
              return match5.ordinalNumber(dateString, {
                unit: "day"
              });
            case "iii":
              return mapValue(match5.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
            case "iiiii":
              return mapValue(match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
            case "iiiiii":
              return mapValue(match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
            case "iiii":
            default:
              return mapValue(match5.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match5.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 7;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2 = setUTCISODay(date2, value);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
      }]);
      return ISODayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js
var AMPMParser;
var init_AMPMParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    AMPMParser = function(_Parser) {
      _inherits(AMPMParser2, _Parser);
      var _super = _createSuper(AMPMParser2);
      function AMPMParser2() {
        var _this;
        _classCallCheck(this, AMPMParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass(AMPMParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "a":
            case "aa":
            case "aaa":
              return match5.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaaa":
              return match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaa":
            default:
              return match5.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date2;
        }
      }]);
      return AMPMParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser;
var init_AMPMMidnightParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    AMPMMidnightParser = function(_Parser) {
      _inherits(AMPMMidnightParser2, _Parser);
      var _super = _createSuper(AMPMMidnightParser2);
      function AMPMMidnightParser2() {
        var _this;
        _classCallCheck(this, AMPMMidnightParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass(AMPMMidnightParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "b":
            case "bb":
            case "bbb":
              return match5.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbbb":
              return match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbb":
            default:
              return match5.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date2;
        }
      }]);
      return AMPMMidnightParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser;
var init_DayPeriodParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    DayPeriodParser = function(_Parser) {
      _inherits(DayPeriodParser2, _Parser);
      var _super = _createSuper(DayPeriodParser2);
      function DayPeriodParser2() {
        var _this;
        _classCallCheck(this, DayPeriodParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
        return _this;
      }
      _createClass(DayPeriodParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "B":
            case "BB":
            case "BBB":
              return match5.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBBB":
              return match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBB":
            default:
              return match5.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match5.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date2;
        }
      }]);
      return DayPeriodParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser;
var init_Hour1to12Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    Hour1to12Parser = function(_Parser) {
      _inherits(Hour1to12Parser2, _Parser);
      var _super = _createSuper(Hour1to12Parser2);
      function Hour1to12Parser2() {
        var _this;
        _classCallCheck(this, Hour1to12Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
        return _this;
      }
      _createClass(Hour1to12Parser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "h":
              return parseNumericPattern(numericPatterns.hour12h, dateString);
            case "ho":
              return match5.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 12;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          var isPM = date2.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date2.setUTCHours(value + 12, 0, 0, 0);
          } else if (!isPM && value === 12) {
            date2.setUTCHours(0, 0, 0, 0);
          } else {
            date2.setUTCHours(value, 0, 0, 0);
          }
          return date2;
        }
      }]);
      return Hour1to12Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser;
var init_Hour0to23Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    Hour0to23Parser = function(_Parser) {
      _inherits(Hour0to23Parser2, _Parser);
      var _super = _createSuper(Hour0to23Parser2);
      function Hour0to23Parser2() {
        var _this;
        _classCallCheck(this, Hour0to23Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
        return _this;
      }
      _createClass(Hour0to23Parser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "H":
              return parseNumericPattern(numericPatterns.hour23h, dateString);
            case "Ho":
              return match5.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 23;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCHours(value, 0, 0, 0);
          return date2;
        }
      }]);
      return Hour0to23Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser;
var init_Hour0To11Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    Hour0To11Parser = function(_Parser) {
      _inherits(Hour0To11Parser2, _Parser);
      var _super = _createSuper(Hour0To11Parser2);
      function Hour0To11Parser2() {
        var _this;
        _classCallCheck(this, Hour0To11Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass(Hour0To11Parser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "K":
              return parseNumericPattern(numericPatterns.hour11h, dateString);
            case "Ko":
              return match5.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          var isPM = date2.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date2.setUTCHours(value + 12, 0, 0, 0);
          } else {
            date2.setUTCHours(value, 0, 0, 0);
          }
          return date2;
        }
      }]);
      return Hour0To11Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser;
var init_Hour1To24Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    Hour1To24Parser = function(_Parser) {
      _inherits(Hour1To24Parser2, _Parser);
      var _super = _createSuper(Hour1To24Parser2);
      function Hour1To24Parser2() {
        var _this;
        _classCallCheck(this, Hour1To24Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
        return _this;
      }
      _createClass(Hour1To24Parser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "k":
              return parseNumericPattern(numericPatterns.hour24h, dateString);
            case "ko":
              return match5.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 1 && value <= 24;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          var hours2 = value <= 24 ? value % 24 : value;
          date2.setUTCHours(hours2, 0, 0, 0);
          return date2;
        }
      }]);
      return Hour1To24Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js
var MinuteParser;
var init_MinuteParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    MinuteParser = function(_Parser) {
      _inherits(MinuteParser2, _Parser);
      var _super = _createSuper(MinuteParser2);
      function MinuteParser2() {
        var _this;
        _classCallCheck(this, MinuteParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 60);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass(MinuteParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "m":
              return parseNumericPattern(numericPatterns.minute, dateString);
            case "mo":
              return match5.ordinalNumber(dateString, {
                unit: "minute"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMinutes(value, 0, 0);
          return date2;
        }
      }]);
      return MinuteParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js
var SecondParser;
var init_SecondParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    SecondParser = function(_Parser) {
      _inherits(SecondParser2, _Parser);
      var _super = _createSuper(SecondParser2);
      function SecondParser2() {
        var _this;
        _classCallCheck(this, SecondParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 50);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass(SecondParser2, [{
        key: "parse",
        value: function parse4(dateString, token3, match5) {
          switch (token3) {
            case "s":
              return parseNumericPattern(numericPatterns.second, dateString);
            case "so":
              return match5.ordinalNumber(dateString, {
                unit: "second"
              });
            default:
              return parseNDigits(token3.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate2(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCSeconds(value, 0);
          return date2;
        }
      }]);
      return SecondParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser;
var init_FractionOfSecondParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    FractionOfSecondParser = function(_Parser) {
      _inherits(FractionOfSecondParser2, _Parser);
      var _super = _createSuper(FractionOfSecondParser2);
      function FractionOfSecondParser2() {
        var _this;
        _classCallCheck(this, FractionOfSecondParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 30);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass(FractionOfSecondParser2, [{
        key: "parse",
        value: function parse4(dateString, token3) {
          var valueCallback3 = function valueCallback4(value) {
            return Math.floor(value * Math.pow(10, -token3.length + 3));
          };
          return mapValue(parseNDigits(token3.length, dateString), valueCallback3);
        }
      }, {
        key: "set",
        value: function set4(date2, _flags, value) {
          date2.setUTCMilliseconds(value);
          return date2;
        }
      }]);
      return FractionOfSecondParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser;
var init_ISOTimezoneWithZParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    ISOTimezoneWithZParser = function(_Parser) {
      _inherits(ISOTimezoneWithZParser2, _Parser);
      var _super = _createSuper(ISOTimezoneWithZParser2);
      function ISOTimezoneWithZParser2() {
        var _this;
        _classCallCheck(this, ISOTimezoneWithZParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
        return _this;
      }
      _createClass(ISOTimezoneWithZParser2, [{
        key: "parse",
        value: function parse4(dateString, token3) {
          switch (token3) {
            case "X":
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "XX":
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "XXXX":
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "XXXXX":
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "XXX":
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set4(date2, flags, value) {
          if (flags.timestampIsSet) {
            return date2;
          }
          return new Date(date2.getTime() - value);
        }
      }]);
      return ISOTimezoneWithZParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser;
var init_ISOTimezoneParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_constants3();
    init_utils3();
    ISOTimezoneParser = function(_Parser) {
      _inherits(ISOTimezoneParser2, _Parser);
      var _super = _createSuper(ISOTimezoneParser2);
      function ISOTimezoneParser2() {
        var _this;
        _classCallCheck(this, ISOTimezoneParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
        return _this;
      }
      _createClass(ISOTimezoneParser2, [{
        key: "parse",
        value: function parse4(dateString, token3) {
          switch (token3) {
            case "x":
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "xx":
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "xxxx":
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "xxxxx":
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "xxx":
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set4(date2, flags, value) {
          if (flags.timestampIsSet) {
            return date2;
          }
          return new Date(date2.getTime() - value);
        }
      }]);
      return ISOTimezoneParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser;
var init_TimestampSecondsParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    TimestampSecondsParser = function(_Parser) {
      _inherits(TimestampSecondsParser2, _Parser);
      var _super = _createSuper(TimestampSecondsParser2);
      function TimestampSecondsParser2() {
        var _this;
        _classCallCheck(this, TimestampSecondsParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 40);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
      }
      _createClass(TimestampSecondsParser2, [{
        key: "parse",
        value: function parse4(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set4(_date, _flags, value) {
          return [new Date(value * 1e3), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampSecondsParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser;
var init_TimestampMillisecondsParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser2();
    init_utils3();
    TimestampMillisecondsParser = function(_Parser) {
      _inherits(TimestampMillisecondsParser2, _Parser);
      var _super = _createSuper(TimestampMillisecondsParser2);
      function TimestampMillisecondsParser2() {
        var _this;
        _classCallCheck(this, TimestampMillisecondsParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 20);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
      }
      _createClass(TimestampMillisecondsParser2, [{
        key: "parse",
        value: function parse4(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set4(_date, _flags, value) {
          return [new Date(value), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampMillisecondsParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/index.js
var parsers;
var init_parsers = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/index.js"() {
    init_EraParser();
    init_YearParser();
    init_LocalWeekYearParser();
    init_ISOWeekYearParser();
    init_ExtendedYearParser();
    init_QuarterParser();
    init_StandAloneQuarterParser();
    init_MonthParser();
    init_StandAloneMonthParser();
    init_LocalWeekParser();
    init_ISOWeekParser();
    init_DateParser();
    init_DayOfYearParser();
    init_DayParser();
    init_LocalDayParser();
    init_StandAloneLocalDayParser();
    init_ISODayParser();
    init_AMPMParser();
    init_AMPMMidnightParser();
    init_DayPeriodParser();
    init_Hour1to12Parser();
    init_Hour0to23Parser();
    init_Hour0To11Parser();
    init_Hour1To24Parser();
    init_MinuteParser();
    init_SecondParser();
    init_FractionOfSecondParser();
    init_ISOTimezoneWithZParser();
    init_ISOTimezoneParser();
    init_TimestampSecondsParser();
    init_TimestampMillisecondsParser();
    parsers = {
      G: new EraParser(),
      y: new YearParser(),
      Y: new LocalWeekYearParser(),
      R: new ISOWeekYearParser(),
      u: new ExtendedYearParser(),
      Q: new QuarterParser(),
      q: new StandAloneQuarterParser(),
      M: new MonthParser(),
      L: new StandAloneMonthParser(),
      w: new LocalWeekParser(),
      I: new ISOWeekParser(),
      d: new DateParser(),
      D: new DayOfYearParser(),
      E: new DayParser(),
      e: new LocalDayParser(),
      c: new StandAloneLocalDayParser(),
      i: new ISODayParser(),
      a: new AMPMParser(),
      b: new AMPMMidnightParser(),
      B: new DayPeriodParser(),
      h: new Hour1to12Parser(),
      H: new Hour0to23Parser(),
      K: new Hour0To11Parser(),
      k: new Hour1To24Parser(),
      m: new MinuteParser(),
      s: new SecondParser(),
      S: new FractionOfSecondParser(),
      X: new ISOTimezoneWithZParser(),
      x: new ISOTimezoneParser(),
      t: new TimestampSecondsParser(),
      T: new TimestampMillisecondsParser()
    };
  }
});

// node_modules/date-fns/esm/parse/index.js
function parse2(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions4 = getDefaultOptions();
  var locale3 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale_default;
  if (!locale3.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions4.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions4.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions4.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale3
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens2 = formatString.match(longFormattingTokensRegExp2).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters_default) {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale3.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp2);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens2), _step;
  try {
    var _loop = function _loop2() {
      var token3 = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token3)) {
        throwProtectedError(token3, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token3)) {
        throwProtectedError(token3, formatString, dirtyDateString);
      }
      var firstCharacter = token3[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token3, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token3, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token3
        });
        var parseResult = parser.run(dateString, token3, locale3.match, subFnOptions);
        if (!parseResult) {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token3 === "''") {
          token3 = "'";
        } else if (firstCharacter === "'") {
          token3 = cleanEscapedString2(token3);
        }
        if (dateString.indexOf(token3) === 0) {
          dateString = dateString.slice(token3.length);
        } else {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a5, b3) {
    return b3 - a5;
  }).filter(function(priority, index3, array) {
    return array.indexOf(priority) === index3;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a5, b3) {
      return b3.subPriority - a5.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date2 = toDate(dirtyReferenceDate);
  if (isNaN(date2.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date2, getTimezoneOffsetInMilliseconds(date2));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign2(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString2(input) {
  return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
}
var formattingTokensRegExp2, longFormattingTokensRegExp2, escapedStringRegExp2, doubleQuoteRegExp2, notWhitespaceRegExp, unescapedLatinCharacterRegExp2;
var init_parse = __esm({
  "node_modules/date-fns/esm/parse/index.js"() {
    init_typeof();
    init_createForOfIteratorHelper();
    init_defaultLocale();
    init_subMilliseconds();
    init_toDate();
    init_assign();
    init_longFormatters();
    init_getTimezoneOffsetInMilliseconds();
    init_protectedTokens();
    init_toInteger();
    init_requiredArgs();
    init_Setter();
    init_parsers();
    init_defaultOptions();
    formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp2 = /^'([^]*?)'?$/;
    doubleQuoteRegExp2 = /''/g;
    notWhitespaceRegExp = /\S/;
    unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
  }
});

// node_modules/date-fns/esm/isSameMonth/index.js
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
var init_isSameMonth = __esm({
  "node_modules/date-fns/esm/isSameMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parseISO/index.js
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date2;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date2 = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date2 || isNaN(date2.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var timestamp2 = date2.getTime();
  var time3 = 0;
  var offset3;
  if (dateStrings.time) {
    time3 = parseTime(dateStrings.time);
    if (isNaN(time3)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset3 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset3)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp2 + time3);
    var result = /* @__PURE__ */ new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp2 + time3 + offset3);
}
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token3 = patterns.timezone.exec(timeString);
    if (token3) {
      dateStrings.time = timeString.replace(token3[1], "");
      dateStrings.timezone = token3[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return /* @__PURE__ */ new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return /* @__PURE__ */ new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date2 = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date2;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours2 = parseTimeUnit(captures[1]);
  var minutes2 = parseTimeUnit(captures[2]);
  var seconds2 = parseTimeUnit(captures[3]);
  if (!validateTime(hours2, minutes2, seconds2)) {
    return NaN;
  }
  return hours2 * millisecondsInHour + minutes2 * millisecondsInMinute + seconds2 * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign2 = captures[1] === "+" ? -1 : 1;
  var hours2 = parseInt(captures[2]);
  var minutes2 = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours2, minutes2)) {
    return NaN;
  }
  return sign2 * (hours2 * millisecondsInHour + minutes2 * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date2.getUTCDay() || 7;
  var diff2 = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff2);
  return date2;
}
function isLeapYearIndex2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date2) {
  return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex2(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex2(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours2, minutes2, seconds2) {
  if (hours2 === 24) {
    return minutes2 === 0 && seconds2 === 0;
  }
  return seconds2 >= 0 && seconds2 < 60 && minutes2 >= 0 && minutes2 < 60 && hours2 >= 0 && hours2 < 25;
}
function validateTimezone(_hours, minutes2) {
  return minutes2 >= 0 && minutes2 <= 59;
}
var patterns, dateRegex, timeRegex, timezoneRegex, daysInMonths;
var init_parseISO = __esm({
  "node_modules/date-fns/esm/parseISO/index.js"() {
    init_constants2();
    init_requiredArgs();
    init_toInteger();
    patterns = {
      dateTimeDelimiter: /[T ]/,
      timeZoneDelimiter: /[Z ]/i,
      timezone: /([Z+-].*)$/
    };
    dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
    timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
    timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
    daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  }
});

// node_modules/date-fns/esm/getDaysInMonth/index.js
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var monthIndex = date2.getMonth();
  var lastDayOfMonth2 = /* @__PURE__ */ new Date(0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}
var init_getDaysInMonth = __esm({
  "node_modules/date-fns/esm/getDaysInMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setMonth/index.js
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date2.getFullYear();
  var day = date2.getDate();
  var dateWithDesiredMonth = /* @__PURE__ */ new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth2 = getDaysInMonth(dateWithDesiredMonth);
  date2.setMonth(month, Math.min(day, daysInMonth2));
  return date2;
}
var init_setMonth = __esm({
  "node_modules/date-fns/esm/setMonth/index.js"() {
    init_toInteger();
    init_toDate();
    init_getDaysInMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/set/index.js
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (_typeof(values) !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date2 = toDate(dirtyDate);
  if (isNaN(date2.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (values.year != null) {
    date2.setFullYear(values.year);
  }
  if (values.month != null) {
    date2 = setMonth(date2, values.month);
  }
  if (values.date != null) {
    date2.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date2.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date2.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date2.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date2.setMilliseconds(toInteger(values.milliseconds));
  }
  return date2;
}
var init_set = __esm({
  "node_modules/date-fns/esm/set/index.js"() {
    init_typeof();
    init_toDate();
    init_setMonth();
    init_toInteger();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setDate/index.js
function setDate(dirtyDate, dirtyDayOfMonth) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var dayOfMonth = toInteger(dirtyDayOfMonth);
  date2.setDate(dayOfMonth);
  return date2;
}
var init_setDate = __esm({
  "node_modules/date-fns/esm/setDate/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setHours/index.js
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var hours2 = toInteger(dirtyHours);
  date2.setHours(hours2);
  return date2;
}
var init_setHours = __esm({
  "node_modules/date-fns/esm/setHours/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setMinutes/index.js
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var minutes2 = toInteger(dirtyMinutes);
  date2.setMinutes(minutes2);
  return date2;
}
var init_setMinutes = __esm({
  "node_modules/date-fns/esm/setMinutes/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setYear/index.js
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date2.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  date2.setFullYear(year);
  return date2;
}
var init_setYear = __esm({
  "node_modules/date-fns/esm/setYear/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfToday/index.js
function startOfToday() {
  return startOfDay(Date.now());
}
var init_startOfToday = __esm({
  "node_modules/date-fns/esm/startOfToday/index.js"() {
    init_startOfDay();
  }
});

// node_modules/date-fns/esm/subDays/index.js
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
var init_subDays = __esm({
  "node_modules/date-fns/esm/subDays/index.js"() {
    init_addDays();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subMonths/index.js
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
var init_subMonths = __esm({
  "node_modules/date-fns/esm/subMonths/index.js"() {
    init_toInteger();
    init_addMonths();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/sub/index.js
function sub(date2, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof(duration) !== "object")
    return /* @__PURE__ */ new Date(NaN);
  var years2 = duration.years ? toInteger(duration.years) : 0;
  var months3 = duration.months ? toInteger(duration.months) : 0;
  var weeks2 = duration.weeks ? toInteger(duration.weeks) : 0;
  var days3 = duration.days ? toInteger(duration.days) : 0;
  var hours2 = duration.hours ? toInteger(duration.hours) : 0;
  var minutes2 = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds2 = duration.seconds ? toInteger(duration.seconds) : 0;
  var dateWithoutMonths = subMonths(date2, months3 + years2 * 12);
  var dateWithoutDays = subDays(dateWithoutMonths, days3 + weeks2 * 7);
  var minutestoSub = minutes2 + hours2 * 60;
  var secondstoSub = seconds2 + minutestoSub * 60;
  var mstoSub = secondstoSub * 1e3;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}
var init_sub = __esm({
  "node_modules/date-fns/esm/sub/index.js"() {
    init_typeof();
    init_subDays();
    init_subMonths();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/add/index.js
function add(dirtyDate, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof(duration) !== "object")
    return /* @__PURE__ */ new Date(NaN);
  var years2 = duration.years ? toInteger(duration.years) : 0;
  var months3 = duration.months ? toInteger(duration.months) : 0;
  var weeks2 = duration.weeks ? toInteger(duration.weeks) : 0;
  var days3 = duration.days ? toInteger(duration.days) : 0;
  var hours2 = duration.hours ? toInteger(duration.hours) : 0;
  var minutes2 = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds2 = duration.seconds ? toInteger(duration.seconds) : 0;
  var date2 = toDate(dirtyDate);
  var dateWithMonths = months3 || years2 ? addMonths(date2, months3 + years2 * 12) : date2;
  var dateWithDays = days3 || weeks2 ? addDays(dateWithMonths, days3 + weeks2 * 7) : dateWithMonths;
  var minutesToAdd = minutes2 + hours2 * 60;
  var secondsToAdd = seconds2 + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1e3;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}
var init_add = __esm({
  "node_modules/date-fns/esm/add/index.js"() {
    init_typeof();
    init_addDays();
    init_addMonths();
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/isWeekend/index.js
function isWeekend(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  return day === 0 || day === 6;
}
var init_isWeekend = __esm({
  "node_modules/date-fns/esm/isWeekend/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSunday/index.js
function isSunday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 0;
}
var init_isSunday = __esm({
  "node_modules/date-fns/esm/isSunday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSaturday/index.js
function isSaturday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 6;
}
var init_isSaturday = __esm({
  "node_modules/date-fns/esm/isSaturday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addBusinessDays/index.js
function addBusinessDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var startedOnWeekend = isWeekend(date2);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount))
    return /* @__PURE__ */ new Date(NaN);
  var hours2 = date2.getHours();
  var sign2 = amount < 0 ? -1 : 1;
  var fullWeeks = toInteger(amount / 5);
  date2.setDate(date2.getDate() + fullWeeks * 7);
  var restDays = Math.abs(amount % 5);
  while (restDays > 0) {
    date2.setDate(date2.getDate() + sign2);
    if (!isWeekend(date2))
      restDays -= 1;
  }
  if (startedOnWeekend && isWeekend(date2) && amount !== 0) {
    if (isSaturday(date2))
      date2.setDate(date2.getDate() + (sign2 < 0 ? 2 : -1));
    if (isSunday(date2))
      date2.setDate(date2.getDate() + (sign2 < 0 ? 1 : -2));
  }
  date2.setHours(hours2);
  return date2;
}
var init_addBusinessDays = __esm({
  "node_modules/date-fns/esm/addBusinessDays/index.js"() {
    init_isWeekend();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_isSunday();
    init_isSaturday();
  }
});

// node_modules/date-fns/esm/addHours/index.js
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
var MILLISECONDS_IN_HOUR;
var init_addHours = __esm({
  "node_modules/date-fns/esm/addHours/index.js"() {
    init_toInteger();
    init_addMilliseconds();
    init_requiredArgs();
    MILLISECONDS_IN_HOUR = 36e5;
  }
});

// node_modules/date-fns/esm/startOfISOWeek/index.js
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
var init_startOfISOWeek = __esm({
  "node_modules/date-fns/esm/startOfISOWeek/index.js"() {
    init_startOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getISOWeekYear/index.js
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getISOWeekYear = __esm({
  "node_modules/date-fns/esm/getISOWeekYear/index.js"() {
    init_toDate();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfISOWeekYear/index.js
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date2 = startOfISOWeek(fourthOfJanuary);
  return date2;
}
var init_startOfISOWeekYear = __esm({
  "node_modules/date-fns/esm/startOfISOWeekYear/index.js"() {
    init_getISOWeekYear();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setISOWeekYear/index.js
function setISOWeekYear(dirtyDate, dirtyISOWeekYear) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var isoWeekYear = toInteger(dirtyISOWeekYear);
  var diff2 = differenceInCalendarDays(date2, startOfISOWeekYear(date2));
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setFullYear(isoWeekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  date2 = startOfISOWeekYear(fourthOfJanuary);
  date2.setDate(date2.getDate() + diff2);
  return date2;
}
var init_setISOWeekYear = __esm({
  "node_modules/date-fns/esm/setISOWeekYear/index.js"() {
    init_toInteger();
    init_toDate();
    init_startOfISOWeekYear();
    init_differenceInCalendarDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addISOWeekYears/index.js
function addISOWeekYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return setISOWeekYear(dirtyDate, getISOWeekYear(dirtyDate) + amount);
}
var init_addISOWeekYears = __esm({
  "node_modules/date-fns/esm/addISOWeekYears/index.js"() {
    init_toInteger();
    init_getISOWeekYear();
    init_setISOWeekYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addMinutes/index.js
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
var MILLISECONDS_IN_MINUTE;
var init_addMinutes = __esm({
  "node_modules/date-fns/esm/addMinutes/index.js"() {
    init_toInteger();
    init_addMilliseconds();
    init_requiredArgs();
    MILLISECONDS_IN_MINUTE = 6e4;
  }
});

// node_modules/date-fns/esm/addQuarters/index.js
function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var months3 = amount * 3;
  return addMonths(dirtyDate, months3);
}
var init_addQuarters = __esm({
  "node_modules/date-fns/esm/addQuarters/index.js"() {
    init_toInteger();
    init_addMonths();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addSeconds/index.js
function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
var init_addSeconds = __esm({
  "node_modules/date-fns/esm/addSeconds/index.js"() {
    init_toInteger();
    init_addMilliseconds();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addYears/index.js
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
var init_addYears = __esm({
  "node_modules/date-fns/esm/addYears/index.js"() {
    init_toInteger();
    init_addMonths();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/areIntervalsOverlapping/index.js
function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
  requiredArgs(2, arguments);
  var leftStartTime = toDate(intervalLeft === null || intervalLeft === void 0 ? void 0 : intervalLeft.start).getTime();
  var leftEndTime = toDate(intervalLeft === null || intervalLeft === void 0 ? void 0 : intervalLeft.end).getTime();
  var rightStartTime = toDate(intervalRight === null || intervalRight === void 0 ? void 0 : intervalRight.start).getTime();
  var rightEndTime = toDate(intervalRight === null || intervalRight === void 0 ? void 0 : intervalRight.end).getTime();
  if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
    throw new RangeError("Invalid interval");
  }
  if (options !== null && options !== void 0 && options.inclusive) {
    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;
  }
  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
}
var init_areIntervalsOverlapping = __esm({
  "node_modules/date-fns/esm/areIntervalsOverlapping/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/max/index.js
function max2(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}
var init_max2 = __esm({
  "node_modules/date-fns/esm/max/index.js"() {
    init_typeof();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/min/index.js
function min2(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result > currentDate || isNaN(currentDate.getDate())) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}
var init_min2 = __esm({
  "node_modules/date-fns/esm/min/index.js"() {
    init_typeof();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/clamp/index.js
function clamp2(date2, _ref2) {
  var start2 = _ref2.start, end2 = _ref2.end;
  requiredArgs(2, arguments);
  return min2([max2([date2, start2]), end2]);
}
var init_clamp = __esm({
  "node_modules/date-fns/esm/clamp/index.js"() {
    init_max2();
    init_min2();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/closestIndexTo/index.js
function closestIndexTo(dirtyDateToCompare, dirtyDatesArray) {
  requiredArgs(2, arguments);
  var dateToCompare = toDate(dirtyDateToCompare);
  if (isNaN(Number(dateToCompare)))
    return NaN;
  var timeToCompare = dateToCompare.getTime();
  var datesArray;
  if (dirtyDatesArray == null) {
    datesArray = [];
  } else if (typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  }
  var result;
  var minDistance;
  datesArray.forEach(function(dirtyDate, index3) {
    var currentDate = toDate(dirtyDate);
    if (isNaN(Number(currentDate))) {
      result = NaN;
      minDistance = NaN;
      return;
    }
    var distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < Number(minDistance)) {
      result = index3;
      minDistance = distance;
    }
  });
  return result;
}
var init_closestIndexTo = __esm({
  "node_modules/date-fns/esm/closestIndexTo/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/closestTo/index.js
function closestTo(dirtyDateToCompare, dirtyDatesArray) {
  requiredArgs(2, arguments);
  var dateToCompare = toDate(dirtyDateToCompare);
  if (isNaN(Number(dateToCompare)))
    return /* @__PURE__ */ new Date(NaN);
  var timeToCompare = dateToCompare.getTime();
  var datesArray;
  if (dirtyDatesArray == null) {
    datesArray = [];
  } else if (typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  }
  var result;
  var minDistance;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (isNaN(Number(currentDate))) {
      result = /* @__PURE__ */ new Date(NaN);
      minDistance = NaN;
      return;
    }
    var distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < Number(minDistance)) {
      result = currentDate;
      minDistance = distance;
    }
  });
  return result;
}
var init_closestTo = __esm({
  "node_modules/date-fns/esm/closestTo/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/compareDesc/index.js
function compareDesc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff2 = dateLeft.getTime() - dateRight.getTime();
  if (diff2 > 0) {
    return -1;
  } else if (diff2 < 0) {
    return 1;
  } else {
    return diff2;
  }
}
var init_compareDesc = __esm({
  "node_modules/date-fns/esm/compareDesc/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/daysToWeeks/index.js
function daysToWeeks(days3) {
  requiredArgs(1, arguments);
  var weeks2 = days3 / daysInWeek;
  return Math.floor(weeks2);
}
var init_daysToWeeks = __esm({
  "node_modules/date-fns/esm/daysToWeeks/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/differenceInBusinessDays/index.js
function differenceInBusinessDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  if (!isValid(dateLeft) || !isValid(dateRight))
    return NaN;
  var calendarDifference = differenceInCalendarDays(dateLeft, dateRight);
  var sign2 = calendarDifference < 0 ? -1 : 1;
  var weeks2 = toInteger(calendarDifference / 7);
  var result = weeks2 * 5;
  dateRight = addDays(dateRight, weeks2 * 7);
  while (!isSameDay(dateLeft, dateRight)) {
    result += isWeekend(dateRight) ? 0 : sign2;
    dateRight = addDays(dateRight, sign2);
  }
  return result === 0 ? 0 : result;
}
var init_differenceInBusinessDays = __esm({
  "node_modules/date-fns/esm/differenceInBusinessDays/index.js"() {
    init_addDays();
    init_differenceInCalendarDays();
    init_isSameDay();
    init_isValid();
    init_isWeekend();
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/differenceInCalendarISOWeekYears/index.js
function differenceInCalendarISOWeekYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  return getISOWeekYear(dirtyDateLeft) - getISOWeekYear(dirtyDateRight);
}
var init_differenceInCalendarISOWeekYears = __esm({
  "node_modules/date-fns/esm/differenceInCalendarISOWeekYears/index.js"() {
    init_getISOWeekYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarISOWeeks/index.js
function differenceInCalendarISOWeeks(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfISOWeekLeft = startOfISOWeek(dirtyDateLeft);
  var startOfISOWeekRight = startOfISOWeek(dirtyDateRight);
  var timestampLeft = startOfISOWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfISOWeekLeft);
  var timestampRight = startOfISOWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfISOWeekRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK4);
}
var MILLISECONDS_IN_WEEK4;
var init_differenceInCalendarISOWeeks = __esm({
  "node_modules/date-fns/esm/differenceInCalendarISOWeeks/index.js"() {
    init_getTimezoneOffsetInMilliseconds();
    init_startOfISOWeek();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK4 = 6048e5;
  }
});

// node_modules/date-fns/esm/getQuarter/index.js
function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var quarter = Math.floor(date2.getMonth() / 3) + 1;
  return quarter;
}
var init_getQuarter = __esm({
  "node_modules/date-fns/esm/getQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarQuarters/index.js
function differenceInCalendarQuarters(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var quarterDiff = getQuarter(dateLeft) - getQuarter(dateRight);
  return yearDiff * 4 + quarterDiff;
}
var init_differenceInCalendarQuarters = __esm({
  "node_modules/date-fns/esm/differenceInCalendarQuarters/index.js"() {
    init_getQuarter();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarWeeks/index.js
function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var startOfWeekLeft = startOfWeek(dirtyDateLeft, options);
  var startOfWeekRight = startOfWeek(dirtyDateRight, options);
  var timestampLeft = startOfWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  var timestampRight = startOfWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK5);
}
var MILLISECONDS_IN_WEEK5;
var init_differenceInCalendarWeeks = __esm({
  "node_modules/date-fns/esm/differenceInCalendarWeeks/index.js"() {
    init_startOfWeek();
    init_getTimezoneOffsetInMilliseconds();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK5 = 6048e5;
  }
});

// node_modules/date-fns/esm/subISOWeekYears/index.js
function subISOWeekYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addISOWeekYears(dirtyDate, -amount);
}
var init_subISOWeekYears = __esm({
  "node_modules/date-fns/esm/subISOWeekYears/index.js"() {
    init_addISOWeekYears();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/differenceInISOWeekYears/index.js
function differenceInISOWeekYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarISOWeekYears(dateLeft, dateRight));
  dateLeft = subISOWeekYears(dateLeft, sign2 * difference);
  var isLastISOWeekYearNotFull = Number(compareAsc(dateLeft, dateRight) === -sign2);
  var result = sign2 * (difference - isLastISOWeekYearNotFull);
  return result === 0 ? 0 : result;
}
var init_differenceInISOWeekYears = __esm({
  "node_modules/date-fns/esm/differenceInISOWeekYears/index.js"() {
    init_toDate();
    init_differenceInCalendarISOWeekYears();
    init_compareAsc();
    init_subISOWeekYears();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInQuarters/index.js
function differenceInQuarters(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff2 = differenceInMonths(dateLeft, dateRight) / 3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff2);
}
var init_differenceInQuarters = __esm({
  "node_modules/date-fns/esm/differenceInQuarters/index.js"() {
    init_differenceInMonths();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/eachDayOfInterval/index.js
function eachDayOfInterval(dirtyInterval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var interval2 = dirtyInterval || {};
  var startDate = toDate(interval2.start);
  var endDate = toDate(interval2.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}
var init_eachDayOfInterval = __esm({
  "node_modules/date-fns/esm/eachDayOfInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachHourOfInterval/index.js
function eachHourOfInterval(dirtyInterval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var interval2 = dirtyInterval || {};
  var startDate = toDate(interval2.start);
  var endDate = toDate(interval2.end);
  var startTime = startDate.getTime();
  var endTime = endDate.getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setMinutes(0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate = addHours(currentDate, step);
  }
  return dates;
}
var init_eachHourOfInterval = __esm({
  "node_modules/date-fns/esm/eachHourOfInterval/index.js"() {
    init_addHours();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachMinuteOfInterval/index.js
function eachMinuteOfInterval(interval2, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var startDate = startOfMinute(toDate(interval2.start));
  var endDate = toDate(interval2.end);
  var startTime = startDate.getTime();
  var endTime = endDate.getTime();
  if (startTime >= endTime) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number equal to or greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate = addMinutes(currentDate, step);
  }
  return dates;
}
var init_eachMinuteOfInterval = __esm({
  "node_modules/date-fns/esm/eachMinuteOfInterval/index.js"() {
    init_addMinutes();
    init_toDate();
    init_startOfMinute();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachMonthOfInterval/index.js
function eachMonthOfInterval(dirtyInterval) {
  requiredArgs(1, arguments);
  var interval2 = dirtyInterval || {};
  var startDate = toDate(interval2.start);
  var endDate = toDate(interval2.end);
  var endTime = endDate.getTime();
  var dates = [];
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setDate(1);
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setMonth(currentDate.getMonth() + 1);
  }
  return dates;
}
var init_eachMonthOfInterval = __esm({
  "node_modules/date-fns/esm/eachMonthOfInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfQuarter/index.js
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var currentMonth = date2.getMonth();
  var month = currentMonth - currentMonth % 3;
  date2.setMonth(month, 1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfQuarter = __esm({
  "node_modules/date-fns/esm/startOfQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachQuarterOfInterval/index.js
function eachQuarterOfInterval(dirtyInterval) {
  requiredArgs(1, arguments);
  var interval2 = dirtyInterval || {};
  var startDate = toDate(interval2.start);
  var endDate = toDate(interval2.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var startDateQuarter = startOfQuarter(startDate);
  var endDateQuarter = startOfQuarter(endDate);
  endTime = endDateQuarter.getTime();
  var quarters = [];
  var currentQuarter = startDateQuarter;
  while (currentQuarter.getTime() <= endTime) {
    quarters.push(toDate(currentQuarter));
    currentQuarter = addQuarters(currentQuarter, 1);
  }
  return quarters;
}
var init_eachQuarterOfInterval = __esm({
  "node_modules/date-fns/esm/eachQuarterOfInterval/index.js"() {
    init_addQuarters();
    init_startOfQuarter();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekendOfInterval/index.js
function eachWeekendOfInterval(interval2) {
  requiredArgs(1, arguments);
  var dateInterval = eachDayOfInterval(interval2);
  var weekends = [];
  var index3 = 0;
  while (index3 < dateInterval.length) {
    var date2 = dateInterval[index3++];
    if (isWeekend(date2)) {
      weekends.push(date2);
      if (isSunday(date2))
        index3 = index3 + 5;
    }
  }
  return weekends;
}
var init_eachWeekendOfInterval = __esm({
  "node_modules/date-fns/esm/eachWeekendOfInterval/index.js"() {
    init_eachDayOfInterval();
    init_isSunday();
    init_isWeekend();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekendOfMonth/index.js
function eachWeekendOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var startDate = startOfMonth(dirtyDate);
  if (isNaN(startDate.getTime()))
    throw new RangeError("The passed date is invalid");
  var endDate = endOfMonth(dirtyDate);
  return eachWeekendOfInterval({
    start: startDate,
    end: endDate
  });
}
var init_eachWeekendOfMonth = __esm({
  "node_modules/date-fns/esm/eachWeekendOfMonth/index.js"() {
    init_eachWeekendOfInterval();
    init_startOfMonth();
    init_endOfMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfYear/index.js
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  date2.setFullYear(year + 1, 0, 0);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfYear = __esm({
  "node_modules/date-fns/esm/endOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfYear/index.js
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setFullYear(cleanDate.getFullYear(), 0, 1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfYear = __esm({
  "node_modules/date-fns/esm/startOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekendOfYear/index.js
function eachWeekendOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var startDate = startOfYear(dirtyDate);
  var endDate = endOfYear(dirtyDate);
  return eachWeekendOfInterval({
    start: startDate,
    end: endDate
  });
}
var init_eachWeekendOfYear = __esm({
  "node_modules/date-fns/esm/eachWeekendOfYear/index.js"() {
    init_eachWeekendOfInterval();
    init_endOfYear();
    init_startOfYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachYearOfInterval/index.js
function eachYearOfInterval(dirtyInterval) {
  requiredArgs(1, arguments);
  var interval2 = dirtyInterval || {};
  var startDate = toDate(interval2.start);
  var endDate = toDate(interval2.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setMonth(0, 1);
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setFullYear(currentDate.getFullYear() + 1);
  }
  return dates;
}
var init_eachYearOfInterval = __esm({
  "node_modules/date-fns/esm/eachYearOfInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfDecade/index.js
function endOfDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var decade = 9 + Math.floor(year / 10) * 10;
  date2.setFullYear(decade, 11, 31);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfDecade = __esm({
  "node_modules/date-fns/esm/endOfDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfHour/index.js
function endOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setMinutes(59, 59, 999);
  return date2;
}
var init_endOfHour = __esm({
  "node_modules/date-fns/esm/endOfHour/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfWeek/index.js
function endOfWeek(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  var diff2 = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date2.setDate(date2.getDate() + diff2);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfWeek = __esm({
  "node_modules/date-fns/esm/endOfWeek/index.js"() {
    init_defaultOptions();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfISOWeek/index.js
function endOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return endOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
var init_endOfISOWeek = __esm({
  "node_modules/date-fns/esm/endOfISOWeek/index.js"() {
    init_endOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfISOWeekYear/index.js
function endOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var date2 = startOfISOWeek(fourthOfJanuaryOfNextYear);
  date2.setMilliseconds(date2.getMilliseconds() - 1);
  return date2;
}
var init_endOfISOWeekYear = __esm({
  "node_modules/date-fns/esm/endOfISOWeekYear/index.js"() {
    init_getISOWeekYear();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfQuarter/index.js
function endOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var currentMonth = date2.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date2.setMonth(month, 0);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfQuarter = __esm({
  "node_modules/date-fns/esm/endOfQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfSecond/index.js
function endOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setMilliseconds(999);
  return date2;
}
var init_endOfSecond = __esm({
  "node_modules/date-fns/esm/endOfSecond/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfToday/index.js
function endOfToday() {
  return endOfDay(Date.now());
}
var init_endOfToday = __esm({
  "node_modules/date-fns/esm/endOfToday/index.js"() {
    init_endOfDay();
  }
});

// node_modules/date-fns/esm/endOfTomorrow/index.js
function endOfTomorrow() {
  var now2 = /* @__PURE__ */ new Date();
  var year = now2.getFullYear();
  var month = now2.getMonth();
  var day = now2.getDate();
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setFullYear(year, month, day + 1);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfTomorrow = __esm({
  "node_modules/date-fns/esm/endOfTomorrow/index.js"() {
  }
});

// node_modules/date-fns/esm/endOfYesterday/index.js
function endOfYesterday() {
  var now2 = /* @__PURE__ */ new Date();
  var year = now2.getFullYear();
  var month = now2.getMonth();
  var day = now2.getDate();
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setFullYear(year, month, day - 1);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
var init_endOfYesterday = __esm({
  "node_modules/date-fns/esm/endOfYesterday/index.js"() {
  }
});

// node_modules/date-fns/esm/_lib/cloneObject/index.js
function cloneObject(object2) {
  return assign2({}, object2);
}
var init_cloneObject = __esm({
  "node_modules/date-fns/esm/_lib/cloneObject/index.js"() {
    init_assign();
  }
});

// node_modules/date-fns/esm/formatDistance/index.js
function formatDistance3(dirtyDate, dirtyBaseDate, options) {
  var _ref2, _options$locale;
  requiredArgs(2, arguments);
  var defaultOptions4 = getDefaultOptions();
  var locale3 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale_default;
  if (!locale3.formatDistance) {
    throw new RangeError("locale must contain formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign2(cloneObject(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var seconds2 = differenceInSeconds(dateRight, dateLeft);
  var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
  var minutes2 = Math.round((seconds2 - offsetInSeconds) / 60);
  var months3;
  if (minutes2 < 2) {
    if (options !== null && options !== void 0 && options.includeSeconds) {
      if (seconds2 < 5) {
        return locale3.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds2 < 10) {
        return locale3.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds2 < 20) {
        return locale3.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds2 < 40) {
        return locale3.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds2 < 60) {
        return locale3.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale3.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes2 === 0) {
        return locale3.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale3.formatDistance("xMinutes", minutes2, localizeOptions);
      }
    }
  } else if (minutes2 < 45) {
    return locale3.formatDistance("xMinutes", minutes2, localizeOptions);
  } else if (minutes2 < 90) {
    return locale3.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes2 < MINUTES_IN_DAY) {
    var hours2 = Math.round(minutes2 / 60);
    return locale3.formatDistance("aboutXHours", hours2, localizeOptions);
  } else if (minutes2 < MINUTES_IN_ALMOST_TWO_DAYS) {
    return locale3.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes2 < MINUTES_IN_MONTH) {
    var days3 = Math.round(minutes2 / MINUTES_IN_DAY);
    return locale3.formatDistance("xDays", days3, localizeOptions);
  } else if (minutes2 < MINUTES_IN_TWO_MONTHS) {
    months3 = Math.round(minutes2 / MINUTES_IN_MONTH);
    return locale3.formatDistance("aboutXMonths", months3, localizeOptions);
  }
  months3 = differenceInMonths(dateRight, dateLeft);
  if (months3 < 12) {
    var nearestMonth = Math.round(minutes2 / MINUTES_IN_MONTH);
    return locale3.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    var monthsSinceStartOfYear = months3 % 12;
    var years2 = Math.floor(months3 / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale3.formatDistance("aboutXYears", years2, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale3.formatDistance("overXYears", years2, localizeOptions);
    } else {
      return locale3.formatDistance("almostXYears", years2 + 1, localizeOptions);
    }
  }
}
var MINUTES_IN_DAY, MINUTES_IN_ALMOST_TWO_DAYS, MINUTES_IN_MONTH, MINUTES_IN_TWO_MONTHS;
var init_formatDistance2 = __esm({
  "node_modules/date-fns/esm/formatDistance/index.js"() {
    init_defaultOptions();
    init_compareAsc();
    init_differenceInMonths();
    init_differenceInSeconds();
    init_defaultLocale();
    init_toDate();
    init_cloneObject();
    init_assign();
    init_getTimezoneOffsetInMilliseconds();
    init_requiredArgs();
    MINUTES_IN_DAY = 1440;
    MINUTES_IN_ALMOST_TWO_DAYS = 2520;
    MINUTES_IN_MONTH = 43200;
    MINUTES_IN_TWO_MONTHS = 86400;
  }
});

// node_modules/date-fns/esm/formatDistanceStrict/index.js
function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
  var _ref2, _options$locale, _options$roundingMeth;
  requiredArgs(2, arguments);
  var defaultOptions4 = getDefaultOptions();
  var locale3 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale_default;
  if (!locale3.formatDistance) {
    throw new RangeError("locale must contain localize.formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign2(cloneObject(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : "round");
  var roundingMethodFn;
  if (roundingMethod === "floor") {
    roundingMethodFn = Math.floor;
  } else if (roundingMethod === "ceil") {
    roundingMethodFn = Math.ceil;
  } else if (roundingMethod === "round") {
    roundingMethodFn = Math.round;
  } else {
    throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
  }
  var milliseconds3 = dateRight.getTime() - dateLeft.getTime();
  var minutes2 = milliseconds3 / MILLISECONDS_IN_MINUTE2;
  var timezoneOffset = getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft);
  var dstNormalizedMinutes = (milliseconds3 - timezoneOffset) / MILLISECONDS_IN_MINUTE2;
  var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
  var unit;
  if (!defaultUnit) {
    if (minutes2 < 1) {
      unit = "second";
    } else if (minutes2 < 60) {
      unit = "minute";
    } else if (minutes2 < MINUTES_IN_DAY2) {
      unit = "hour";
    } else if (dstNormalizedMinutes < MINUTES_IN_MONTH2) {
      unit = "day";
    } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
      unit = "month";
    } else {
      unit = "year";
    }
  } else {
    unit = String(defaultUnit);
  }
  if (unit === "second") {
    var seconds2 = roundingMethodFn(milliseconds3 / 1e3);
    return locale3.formatDistance("xSeconds", seconds2, localizeOptions);
  } else if (unit === "minute") {
    var roundedMinutes = roundingMethodFn(minutes2);
    return locale3.formatDistance("xMinutes", roundedMinutes, localizeOptions);
  } else if (unit === "hour") {
    var hours2 = roundingMethodFn(minutes2 / 60);
    return locale3.formatDistance("xHours", hours2, localizeOptions);
  } else if (unit === "day") {
    var days3 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY2);
    return locale3.formatDistance("xDays", days3, localizeOptions);
  } else if (unit === "month") {
    var months3 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH2);
    return months3 === 12 && defaultUnit !== "month" ? locale3.formatDistance("xYears", 1, localizeOptions) : locale3.formatDistance("xMonths", months3, localizeOptions);
  } else if (unit === "year") {
    var years2 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
    return locale3.formatDistance("xYears", years2, localizeOptions);
  }
  throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
}
var MILLISECONDS_IN_MINUTE2, MINUTES_IN_DAY2, MINUTES_IN_MONTH2, MINUTES_IN_YEAR;
var init_formatDistanceStrict = __esm({
  "node_modules/date-fns/esm/formatDistanceStrict/index.js"() {
    init_defaultOptions();
    init_getTimezoneOffsetInMilliseconds();
    init_compareAsc();
    init_toDate();
    init_cloneObject();
    init_assign();
    init_defaultLocale();
    init_requiredArgs();
    MILLISECONDS_IN_MINUTE2 = 1e3 * 60;
    MINUTES_IN_DAY2 = 60 * 24;
    MINUTES_IN_MONTH2 = MINUTES_IN_DAY2 * 30;
    MINUTES_IN_YEAR = MINUTES_IN_DAY2 * 365;
  }
});

// node_modules/date-fns/esm/formatDistanceToNow/index.js
function formatDistanceToNow(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistance3(dirtyDate, Date.now(), options);
}
var init_formatDistanceToNow = __esm({
  "node_modules/date-fns/esm/formatDistanceToNow/index.js"() {
    init_formatDistance2();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatDistanceToNowStrict/index.js
function formatDistanceToNowStrict(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistanceStrict(dirtyDate, Date.now(), options);
}
var init_formatDistanceToNowStrict = __esm({
  "node_modules/date-fns/esm/formatDistanceToNowStrict/index.js"() {
    init_formatDistanceStrict();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatDuration/index.js
function formatDuration(duration, options) {
  var _ref2, _options$locale, _options$format, _options$zero, _options$delimiter;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }
  var defaultOptions4 = getDefaultOptions();
  var locale3 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale_default;
  var format4 = (_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : defaultFormat;
  var zero = (_options$zero = options === null || options === void 0 ? void 0 : options.zero) !== null && _options$zero !== void 0 ? _options$zero : false;
  var delimiter2 = (_options$delimiter = options === null || options === void 0 ? void 0 : options.delimiter) !== null && _options$delimiter !== void 0 ? _options$delimiter : " ";
  if (!locale3.formatDistance) {
    return "";
  }
  var result = format4.reduce(function(acc, unit) {
    var token3 = "x".concat(unit.replace(/(^.)/, function(m4) {
      return m4.toUpperCase();
    }));
    var value = duration[unit];
    if (typeof value === "number" && (zero || duration[unit])) {
      return acc.concat(locale3.formatDistance(token3, value));
    }
    return acc;
  }, []).join(delimiter2);
  return result;
}
var defaultFormat;
var init_formatDuration = __esm({
  "node_modules/date-fns/esm/formatDuration/index.js"() {
    init_defaultOptions();
    init_defaultLocale();
    defaultFormat = ["years", "months", "weeks", "days", "hours", "minutes", "seconds"];
  }
});

// node_modules/date-fns/esm/formatISO/index.js
function formatISO(date2, options) {
  var _options$format, _options$representati;
  requiredArgs(1, arguments);
  var originalDate = toDate(date2);
  if (isNaN(originalDate.getTime())) {
    throw new RangeError("Invalid time value");
  }
  var format4 = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : "extended");
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : "complete");
  if (format4 !== "extended" && format4 !== "basic") {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== "date" && representation !== "time" && representation !== "complete") {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = "";
  var tzOffset = "";
  var dateDelimiter = format4 === "extended" ? "-" : "";
  var timeDelimiter = format4 === "extended" ? ":" : "";
  if (representation !== "time") {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4);
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }
  if (representation !== "date") {
    var offset3 = originalDate.getTimezoneOffset();
    if (offset3 !== 0) {
      var absoluteOffset = Math.abs(offset3);
      var hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
      var sign2 = offset3 < 0 ? "+" : "-";
      tzOffset = "".concat(sign2).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = "Z";
    }
    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2);
    var separator = result === "" ? "" : "T";
    var time3 = [hour, minute, second].join(timeDelimiter);
    result = "".concat(result).concat(separator).concat(time3).concat(tzOffset);
  }
  return result;
}
var init_formatISO = __esm({
  "node_modules/date-fns/esm/formatISO/index.js"() {
    init_toDate();
    init_addLeadingZeros();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatISO9075/index.js
function formatISO9075(dirtyDate, options) {
  var _options$format, _options$representati;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var format4 = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : "extended");
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : "complete");
  if (format4 !== "extended" && format4 !== "basic") {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== "date" && representation !== "time" && representation !== "complete") {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = "";
  var dateDelimiter = format4 === "extended" ? "-" : "";
  var timeDelimiter = format4 === "extended" ? ":" : "";
  if (representation !== "time") {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4);
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }
  if (representation !== "date") {
    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2);
    var separator = result === "" ? "" : " ";
    result = "".concat(result).concat(separator).concat(hour).concat(timeDelimiter).concat(minute).concat(timeDelimiter).concat(second);
  }
  return result;
}
var init_formatISO9075 = __esm({
  "node_modules/date-fns/esm/formatISO9075/index.js"() {
    init_toDate();
    init_isValid();
    init_addLeadingZeros();
  }
});

// node_modules/date-fns/esm/formatISODuration/index.js
function formatISODuration(duration) {
  requiredArgs(1, arguments);
  if (_typeof(duration) !== "object")
    throw new Error("Duration must be an object");
  var _duration$years = duration.years, years2 = _duration$years === void 0 ? 0 : _duration$years, _duration$months = duration.months, months3 = _duration$months === void 0 ? 0 : _duration$months, _duration$days = duration.days, days3 = _duration$days === void 0 ? 0 : _duration$days, _duration$hours = duration.hours, hours2 = _duration$hours === void 0 ? 0 : _duration$hours, _duration$minutes = duration.minutes, minutes2 = _duration$minutes === void 0 ? 0 : _duration$minutes, _duration$seconds = duration.seconds, seconds2 = _duration$seconds === void 0 ? 0 : _duration$seconds;
  return "P".concat(years2, "Y").concat(months3, "M").concat(days3, "DT").concat(hours2, "H").concat(minutes2, "M").concat(seconds2, "S");
}
var init_formatISODuration = __esm({
  "node_modules/date-fns/esm/formatISODuration/index.js"() {
    init_typeof();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatRFC3339/index.js
function formatRFC3339(dirtyDate, options) {
  var _options$fractionDigi;
  if (arguments.length < 1) {
    throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var fractionDigits = Number((_options$fractionDigi = options === null || options === void 0 ? void 0 : options.fractionDigits) !== null && _options$fractionDigi !== void 0 ? _options$fractionDigi : 0);
  if (!(fractionDigits >= 0 && fractionDigits <= 3)) {
    throw new RangeError("fractionDigits must be between 0 and 3 inclusively");
  }
  var day = addLeadingZeros(originalDate.getDate(), 2);
  var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
  var year = originalDate.getFullYear();
  var hour = addLeadingZeros(originalDate.getHours(), 2);
  var minute = addLeadingZeros(originalDate.getMinutes(), 2);
  var second = addLeadingZeros(originalDate.getSeconds(), 2);
  var fractionalSecond = "";
  if (fractionDigits > 0) {
    var milliseconds3 = originalDate.getMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds3 * Math.pow(10, fractionDigits - 3));
    fractionalSecond = "." + addLeadingZeros(fractionalSeconds, fractionDigits);
  }
  var offset3 = "";
  var tzOffset = originalDate.getTimezoneOffset();
  if (tzOffset !== 0) {
    var absoluteOffset = Math.abs(tzOffset);
    var hourOffset = addLeadingZeros(toInteger(absoluteOffset / 60), 2);
    var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
    var sign2 = tzOffset < 0 ? "+" : "-";
    offset3 = "".concat(sign2).concat(hourOffset, ":").concat(minuteOffset);
  } else {
    offset3 = "Z";
  }
  return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond).concat(offset3);
}
var init_formatRFC3339 = __esm({
  "node_modules/date-fns/esm/formatRFC3339/index.js"() {
    init_toDate();
    init_isValid();
    init_addLeadingZeros();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/formatRFC7231/index.js
function formatRFC7231(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var dayName = days[originalDate.getUTCDay()];
  var dayOfMonth = addLeadingZeros(originalDate.getUTCDate(), 2);
  var monthName = months[originalDate.getUTCMonth()];
  var year = originalDate.getUTCFullYear();
  var hour = addLeadingZeros(originalDate.getUTCHours(), 2);
  var minute = addLeadingZeros(originalDate.getUTCMinutes(), 2);
  var second = addLeadingZeros(originalDate.getUTCSeconds(), 2);
  return "".concat(dayName, ", ").concat(dayOfMonth, " ").concat(monthName, " ").concat(year, " ").concat(hour, ":").concat(minute, ":").concat(second, " GMT");
}
var days, months;
var init_formatRFC7231 = __esm({
  "node_modules/date-fns/esm/formatRFC7231/index.js"() {
    init_toDate();
    init_isValid();
    init_addLeadingZeros();
    days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  }
});

// node_modules/date-fns/esm/formatRelative/index.js
function formatRelative3(dirtyDate, dirtyBaseDate, options) {
  var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$weekStartsOn, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var baseDate = toDate(dirtyBaseDate);
  var defaultOptions4 = getDefaultOptions();
  var locale3 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale_default;
  var weekStartsOn = toInteger((_ref22 = (_ref3 = (_ref4 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions4.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : 0);
  if (!locale3.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale3.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  if (!locale3.formatRelative) {
    throw new RangeError("locale must contain formatRelative property");
  }
  var diff2 = differenceInCalendarDays(date2, baseDate);
  if (isNaN(diff2)) {
    throw new RangeError("Invalid time value");
  }
  var token3;
  if (diff2 < -6) {
    token3 = "other";
  } else if (diff2 < -1) {
    token3 = "lastWeek";
  } else if (diff2 < 0) {
    token3 = "yesterday";
  } else if (diff2 < 1) {
    token3 = "today";
  } else if (diff2 < 2) {
    token3 = "tomorrow";
  } else if (diff2 < 7) {
    token3 = "nextWeek";
  } else {
    token3 = "other";
  }
  var utcDate = subMilliseconds(date2, getTimezoneOffsetInMilliseconds(date2));
  var utcBaseDate = subMilliseconds(baseDate, getTimezoneOffsetInMilliseconds(baseDate));
  var formatStr = locale3.formatRelative(token3, utcDate, utcBaseDate, {
    locale: locale3,
    weekStartsOn
  });
  return format(date2, formatStr, {
    locale: locale3,
    weekStartsOn
  });
}
var init_formatRelative2 = __esm({
  "node_modules/date-fns/esm/formatRelative/index.js"() {
    init_defaultOptions();
    init_differenceInCalendarDays();
    init_format();
    init_defaultLocale();
    init_subMilliseconds();
    init_toDate();
    init_getTimezoneOffsetInMilliseconds();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/fromUnixTime/index.js
function fromUnixTime(dirtyUnixTime) {
  requiredArgs(1, arguments);
  var unixTime = toInteger(dirtyUnixTime);
  return toDate(unixTime * 1e3);
}
var init_fromUnixTime = __esm({
  "node_modules/date-fns/esm/fromUnixTime/index.js"() {
    init_toDate();
    init_toInteger();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDate/index.js
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var dayOfMonth = date2.getDate();
  return dayOfMonth;
}
var init_getDate = __esm({
  "node_modules/date-fns/esm/getDate/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDay/index.js
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  return day;
}
var init_getDay = __esm({
  "node_modules/date-fns/esm/getDay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDayOfYear/index.js
function getDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff2 = differenceInCalendarDays(date2, startOfYear(date2));
  var dayOfYear = diff2 + 1;
  return dayOfYear;
}
var init_getDayOfYear = __esm({
  "node_modules/date-fns/esm/getDayOfYear/index.js"() {
    init_toDate();
    init_startOfYear();
    init_differenceInCalendarDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isLeapYear/index.js
function isLeapYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var init_isLeapYear = __esm({
  "node_modules/date-fns/esm/isLeapYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDaysInYear/index.js
function getDaysInYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  if (String(new Date(date2)) === "Invalid Date") {
    return NaN;
  }
  return isLeapYear(date2) ? 366 : 365;
}
var init_getDaysInYear = __esm({
  "node_modules/date-fns/esm/getDaysInYear/index.js"() {
    init_toDate();
    init_isLeapYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDecade/index.js
function getDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var decade = Math.floor(year / 10) * 10;
  return decade;
}
var init_getDecade = __esm({
  "node_modules/date-fns/esm/getDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDefaultOptions/index.js
function getDefaultOptions2() {
  return assign2({}, getDefaultOptions());
}
var init_getDefaultOptions = __esm({
  "node_modules/date-fns/esm/getDefaultOptions/index.js"() {
    init_defaultOptions();
    init_assign();
  }
});

// node_modules/date-fns/esm/getHours/index.js
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var hours2 = date2.getHours();
  return hours2;
}
var init_getHours = __esm({
  "node_modules/date-fns/esm/getHours/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getISODay/index.js
function getISODay(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}
var init_getISODay = __esm({
  "node_modules/date-fns/esm/getISODay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getISOWeek/index.js
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff2 = startOfISOWeek(date2).getTime() - startOfISOWeekYear(date2).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK6) + 1;
}
var MILLISECONDS_IN_WEEK6;
var init_getISOWeek = __esm({
  "node_modules/date-fns/esm/getISOWeek/index.js"() {
    init_toDate();
    init_startOfISOWeek();
    init_startOfISOWeekYear();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK6 = 6048e5;
  }
});

// node_modules/date-fns/esm/getISOWeeksInYear/index.js
function getISOWeeksInYear(dirtyDate) {
  requiredArgs(1, arguments);
  var thisYear = startOfISOWeekYear(dirtyDate);
  var nextYear = startOfISOWeekYear(addWeeks(thisYear, 60));
  var diff2 = nextYear.valueOf() - thisYear.valueOf();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK7);
}
var MILLISECONDS_IN_WEEK7;
var init_getISOWeeksInYear = __esm({
  "node_modules/date-fns/esm/getISOWeeksInYear/index.js"() {
    init_startOfISOWeekYear();
    init_addWeeks();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK7 = 6048e5;
  }
});

// node_modules/date-fns/esm/getMilliseconds/index.js
function getMilliseconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var milliseconds3 = date2.getMilliseconds();
  return milliseconds3;
}
var init_getMilliseconds = __esm({
  "node_modules/date-fns/esm/getMilliseconds/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getMonth/index.js
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var month = date2.getMonth();
  return month;
}
var init_getMonth = __esm({
  "node_modules/date-fns/esm/getMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
function getOverlappingDaysInIntervals(dirtyIntervalLeft, dirtyIntervalRight) {
  requiredArgs(2, arguments);
  var intervalLeft = dirtyIntervalLeft || {};
  var intervalRight = dirtyIntervalRight || {};
  var leftStartTime = toDate(intervalLeft.start).getTime();
  var leftEndTime = toDate(intervalLeft.end).getTime();
  var rightStartTime = toDate(intervalRight.start).getTime();
  var rightEndTime = toDate(intervalRight.end).getTime();
  if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
    throw new RangeError("Invalid interval");
  }
  var isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
  if (!isOverlapping) {
    return 0;
  }
  var overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime;
  var overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime;
  var differenceInMs = overlapEndDate - overlapStartDate;
  return Math.ceil(differenceInMs / MILLISECONDS_IN_DAY3);
}
var MILLISECONDS_IN_DAY3;
var init_getOverlappingDaysInIntervals = __esm({
  "node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js"() {
    init_toDate();
    init_requiredArgs();
    MILLISECONDS_IN_DAY3 = 24 * 60 * 60 * 1e3;
  }
});

// node_modules/date-fns/esm/getSeconds/index.js
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var seconds2 = date2.getSeconds();
  return seconds2;
}
var init_getSeconds = __esm({
  "node_modules/date-fns/esm/getSeconds/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getTime/index.js
function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var timestamp2 = date2.getTime();
  return timestamp2;
}
var init_getTime = __esm({
  "node_modules/date-fns/esm/getTime/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getUnixTime/index.js
function getUnixTime(dirtyDate) {
  requiredArgs(1, arguments);
  return Math.floor(getTime(dirtyDate) / 1e3);
}
var init_getUnixTime = __esm({
  "node_modules/date-fns/esm/getUnixTime/index.js"() {
    init_getTime();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getWeekOfMonth/index.js
function getWeekOfMonth(date2, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var currentDayOfMonth = getDate(date2);
  if (isNaN(currentDayOfMonth))
    return NaN;
  var startWeekDay = getDay(startOfMonth(date2));
  var lastDayOfFirstWeek = weekStartsOn - startWeekDay;
  if (lastDayOfFirstWeek <= 0)
    lastDayOfFirstWeek += 7;
  var remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
  return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
}
var init_getWeekOfMonth = __esm({
  "node_modules/date-fns/esm/getWeekOfMonth/index.js"() {
    init_defaultOptions();
    init_getDate();
    init_getDay();
    init_startOfMonth();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/getWeeksInMonth/index.js
function getWeeksInMonth(date2, options) {
  requiredArgs(1, arguments);
  return differenceInCalendarWeeks(lastDayOfMonth(date2), startOfMonth(date2), options) + 1;
}
var init_getWeeksInMonth = __esm({
  "node_modules/date-fns/esm/getWeeksInMonth/index.js"() {
    init_differenceInCalendarWeeks();
    init_lastDayOfMonth();
    init_startOfMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getYear/index.js
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
var init_getYear = __esm({
  "node_modules/date-fns/esm/getYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/hoursToMilliseconds/index.js
function hoursToMilliseconds(hours2) {
  requiredArgs(1, arguments);
  return Math.floor(hours2 * millisecondsInHour);
}
var init_hoursToMilliseconds = __esm({
  "node_modules/date-fns/esm/hoursToMilliseconds/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/hoursToMinutes/index.js
function hoursToMinutes(hours2) {
  requiredArgs(1, arguments);
  return Math.floor(hours2 * minutesInHour);
}
var init_hoursToMinutes = __esm({
  "node_modules/date-fns/esm/hoursToMinutes/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/hoursToSeconds/index.js
function hoursToSeconds(hours2) {
  requiredArgs(1, arguments);
  return Math.floor(hours2 * secondsInHour);
}
var init_hoursToSeconds = __esm({
  "node_modules/date-fns/esm/hoursToSeconds/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/intervalToDuration/index.js
function intervalToDuration(interval2) {
  requiredArgs(1, arguments);
  var start2 = toDate(interval2.start);
  var end2 = toDate(interval2.end);
  if (isNaN(start2.getTime()))
    throw new RangeError("Start Date is invalid");
  if (isNaN(end2.getTime()))
    throw new RangeError("End Date is invalid");
  var duration = {};
  duration.years = Math.abs(differenceInYears(end2, start2));
  var sign2 = compareAsc(end2, start2);
  var remainingMonths = add(start2, {
    years: sign2 * duration.years
  });
  duration.months = Math.abs(differenceInMonths(end2, remainingMonths));
  var remainingDays = add(remainingMonths, {
    months: sign2 * duration.months
  });
  duration.days = Math.abs(differenceInDays(end2, remainingDays));
  var remainingHours = add(remainingDays, {
    days: sign2 * duration.days
  });
  duration.hours = Math.abs(differenceInHours(end2, remainingHours));
  var remainingMinutes = add(remainingHours, {
    hours: sign2 * duration.hours
  });
  duration.minutes = Math.abs(differenceInMinutes(end2, remainingMinutes));
  var remainingSeconds = add(remainingMinutes, {
    minutes: sign2 * duration.minutes
  });
  duration.seconds = Math.abs(differenceInSeconds(end2, remainingSeconds));
  return duration;
}
var init_intervalToDuration = __esm({
  "node_modules/date-fns/esm/intervalToDuration/index.js"() {
    init_compareAsc();
    init_add();
    init_differenceInDays();
    init_differenceInHours();
    init_differenceInMinutes();
    init_differenceInMonths();
    init_differenceInSeconds();
    init_differenceInYears();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/intlFormat/index.js
function intlFormat(date2, formatOrLocale, localeOptions) {
  var _localeOptions;
  requiredArgs(1, arguments);
  var formatOptions;
  if (isFormatOptions(formatOrLocale)) {
    formatOptions = formatOrLocale;
  } else {
    localeOptions = formatOrLocale;
  }
  return new Intl.DateTimeFormat((_localeOptions = localeOptions) === null || _localeOptions === void 0 ? void 0 : _localeOptions.locale, formatOptions).format(date2);
}
function isFormatOptions(opts) {
  return opts !== void 0 && !("locale" in opts);
}
var init_intlFormat = __esm({
  "node_modules/date-fns/esm/intlFormat/index.js"() {
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/intlFormatDistance/index.js
function intlFormatDistance(date2, baseDate, options) {
  requiredArgs(2, arguments);
  var value = 0;
  var unit;
  var dateLeft = toDate(date2);
  var dateRight = toDate(baseDate);
  if (!(options !== null && options !== void 0 && options.unit)) {
    var diffInSeconds = differenceInSeconds(dateLeft, dateRight);
    if (Math.abs(diffInSeconds) < secondsInMinute) {
      value = differenceInSeconds(dateLeft, dateRight);
      unit = "second";
    } else if (Math.abs(diffInSeconds) < secondsInHour) {
      value = differenceInMinutes(dateLeft, dateRight);
      unit = "minute";
    } else if (Math.abs(diffInSeconds) < secondsInDay && Math.abs(differenceInCalendarDays(dateLeft, dateRight)) < 1) {
      value = differenceInHours(dateLeft, dateRight);
      unit = "hour";
    } else if (Math.abs(diffInSeconds) < secondsInWeek && (value = differenceInCalendarDays(dateLeft, dateRight)) && Math.abs(value) < 7) {
      unit = "day";
    } else if (Math.abs(diffInSeconds) < secondsInMonth) {
      value = differenceInCalendarWeeks(dateLeft, dateRight);
      unit = "week";
    } else if (Math.abs(diffInSeconds) < secondsInQuarter) {
      value = differenceInCalendarMonths(dateLeft, dateRight);
      unit = "month";
    } else if (Math.abs(diffInSeconds) < secondsInYear) {
      if (differenceInCalendarQuarters(dateLeft, dateRight) < 4) {
        value = differenceInCalendarQuarters(dateLeft, dateRight);
        unit = "quarter";
      } else {
        value = differenceInCalendarYears(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      value = differenceInCalendarYears(dateLeft, dateRight);
      unit = "year";
    }
  } else {
    unit = options === null || options === void 0 ? void 0 : options.unit;
    if (unit === "second") {
      value = differenceInSeconds(dateLeft, dateRight);
    } else if (unit === "minute") {
      value = differenceInMinutes(dateLeft, dateRight);
    } else if (unit === "hour") {
      value = differenceInHours(dateLeft, dateRight);
    } else if (unit === "day") {
      value = differenceInCalendarDays(dateLeft, dateRight);
    } else if (unit === "week") {
      value = differenceInCalendarWeeks(dateLeft, dateRight);
    } else if (unit === "month") {
      value = differenceInCalendarMonths(dateLeft, dateRight);
    } else if (unit === "quarter") {
      value = differenceInCalendarQuarters(dateLeft, dateRight);
    } else if (unit === "year") {
      value = differenceInCalendarYears(dateLeft, dateRight);
    }
  }
  var rtf = new Intl.RelativeTimeFormat(options === null || options === void 0 ? void 0 : options.locale, {
    localeMatcher: options === null || options === void 0 ? void 0 : options.localeMatcher,
    numeric: (options === null || options === void 0 ? void 0 : options.numeric) || "auto",
    style: options === null || options === void 0 ? void 0 : options.style
  });
  return rtf.format(value, unit);
}
var init_intlFormatDistance = __esm({
  "node_modules/date-fns/esm/intlFormatDistance/index.js"() {
    init_constants2();
    init_differenceInCalendarDays();
    init_differenceInCalendarMonths();
    init_differenceInCalendarQuarters();
    init_differenceInCalendarWeeks();
    init_differenceInCalendarYears();
    init_differenceInHours();
    init_differenceInMinutes();
    init_differenceInSeconds();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isEqual/index.js
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
var init_isEqual = __esm({
  "node_modules/date-fns/esm/isEqual/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isExists/index.js
function isExists(year, month, day) {
  if (arguments.length < 3) {
    throw new TypeError("3 argument required, but only " + arguments.length + " present");
  }
  var date2 = new Date(year, month, day);
  return date2.getFullYear() === year && date2.getMonth() === month && date2.getDate() === day;
}
var init_isExists = __esm({
  "node_modules/date-fns/esm/isExists/index.js"() {
  }
});

// node_modules/date-fns/esm/isFirstDayOfMonth/index.js
function isFirstDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDate() === 1;
}
var init_isFirstDayOfMonth = __esm({
  "node_modules/date-fns/esm/isFirstDayOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isFriday/index.js
function isFriday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 5;
}
var init_isFriday = __esm({
  "node_modules/date-fns/esm/isFriday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isFuture/index.js
function isFuture(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getTime() > Date.now();
}
var init_isFuture = __esm({
  "node_modules/date-fns/esm/isFuture/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isMatch/index.js
function isMatch(dateString, formatString, options) {
  requiredArgs(2, arguments);
  return isValid(parse2(dateString, formatString, /* @__PURE__ */ new Date(), options));
}
var init_isMatch = __esm({
  "node_modules/date-fns/esm/isMatch/index.js"() {
    init_parse();
    init_isValid();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isMonday/index.js
function isMonday(date2) {
  requiredArgs(1, arguments);
  return toDate(date2).getDay() === 1;
}
var init_isMonday = __esm({
  "node_modules/date-fns/esm/isMonday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isPast/index.js
function isPast(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getTime() < Date.now();
}
var init_isPast = __esm({
  "node_modules/date-fns/esm/isPast/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfHour/index.js
function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setMinutes(0, 0, 0);
  return date2;
}
var init_startOfHour = __esm({
  "node_modules/date-fns/esm/startOfHour/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameHour/index.js
function isSameHour(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfHour = startOfHour(dirtyDateLeft);
  var dateRightStartOfHour = startOfHour(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}
var init_isSameHour = __esm({
  "node_modules/date-fns/esm/isSameHour/index.js"() {
    init_startOfHour();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameWeek/index.js
function isSameWeek(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfWeek(dirtyDateLeft, options);
  var dateRightStartOfWeek = startOfWeek(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}
var init_isSameWeek = __esm({
  "node_modules/date-fns/esm/isSameWeek/index.js"() {
    init_startOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameISOWeek/index.js
function isSameISOWeek(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  return isSameWeek(dirtyDateLeft, dirtyDateRight, {
    weekStartsOn: 1
  });
}
var init_isSameISOWeek = __esm({
  "node_modules/date-fns/esm/isSameISOWeek/index.js"() {
    init_isSameWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameISOWeekYear/index.js
function isSameISOWeekYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfYear = startOfISOWeekYear(dirtyDateLeft);
  var dateRightStartOfYear = startOfISOWeekYear(dirtyDateRight);
  return dateLeftStartOfYear.getTime() === dateRightStartOfYear.getTime();
}
var init_isSameISOWeekYear = __esm({
  "node_modules/date-fns/esm/isSameISOWeekYear/index.js"() {
    init_startOfISOWeekYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameMinute/index.js
function isSameMinute(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfMinute = startOfMinute(dirtyDateLeft);
  var dateRightStartOfMinute = startOfMinute(dirtyDateRight);
  return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
}
var init_isSameMinute = __esm({
  "node_modules/date-fns/esm/isSameMinute/index.js"() {
    init_startOfMinute();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameQuarter/index.js
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}
var init_isSameQuarter = __esm({
  "node_modules/date-fns/esm/isSameQuarter/index.js"() {
    init_startOfQuarter();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfSecond/index.js
function startOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setMilliseconds(0);
  return date2;
}
var init_startOfSecond = __esm({
  "node_modules/date-fns/esm/startOfSecond/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameSecond/index.js
function isSameSecond(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfSecond = startOfSecond(dirtyDateLeft);
  var dateRightStartOfSecond = startOfSecond(dirtyDateRight);
  return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
}
var init_isSameSecond = __esm({
  "node_modules/date-fns/esm/isSameSecond/index.js"() {
    init_startOfSecond();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameYear/index.js
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
var init_isSameYear = __esm({
  "node_modules/date-fns/esm/isSameYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisHour/index.js
function isThisHour(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameHour(Date.now(), dirtyDate);
}
var init_isThisHour = __esm({
  "node_modules/date-fns/esm/isThisHour/index.js"() {
    init_isSameHour();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisISOWeek/index.js
function isThisISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameISOWeek(dirtyDate, Date.now());
}
var init_isThisISOWeek = __esm({
  "node_modules/date-fns/esm/isThisISOWeek/index.js"() {
    init_isSameISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisMinute/index.js
function isThisMinute(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameMinute(Date.now(), dirtyDate);
}
var init_isThisMinute = __esm({
  "node_modules/date-fns/esm/isThisMinute/index.js"() {
    init_isSameMinute();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisMonth/index.js
function isThisMonth(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameMonth(Date.now(), dirtyDate);
}
var init_isThisMonth = __esm({
  "node_modules/date-fns/esm/isThisMonth/index.js"() {
    init_isSameMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisQuarter/index.js
function isThisQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameQuarter(Date.now(), dirtyDate);
}
var init_isThisQuarter = __esm({
  "node_modules/date-fns/esm/isThisQuarter/index.js"() {
    init_isSameQuarter();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisSecond/index.js
function isThisSecond(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameSecond(Date.now(), dirtyDate);
}
var init_isThisSecond = __esm({
  "node_modules/date-fns/esm/isThisSecond/index.js"() {
    init_isSameSecond();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisWeek/index.js
function isThisWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  return isSameWeek(dirtyDate, Date.now(), options);
}
var init_isThisWeek = __esm({
  "node_modules/date-fns/esm/isThisWeek/index.js"() {
    init_isSameWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisYear/index.js
function isThisYear(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameYear(dirtyDate, Date.now());
}
var init_isThisYear = __esm({
  "node_modules/date-fns/esm/isThisYear/index.js"() {
    init_isSameYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThursday/index.js
function isThursday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 4;
}
var init_isThursday = __esm({
  "node_modules/date-fns/esm/isThursday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isToday/index.js
function isToday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, Date.now());
}
var init_isToday = __esm({
  "node_modules/date-fns/esm/isToday/index.js"() {
    init_isSameDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isTomorrow/index.js
function isTomorrow(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, addDays(Date.now(), 1));
}
var init_isTomorrow = __esm({
  "node_modules/date-fns/esm/isTomorrow/index.js"() {
    init_addDays();
    init_isSameDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isTuesday/index.js
function isTuesday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 2;
}
var init_isTuesday = __esm({
  "node_modules/date-fns/esm/isTuesday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isWednesday/index.js
function isWednesday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 3;
}
var init_isWednesday = __esm({
  "node_modules/date-fns/esm/isWednesday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isWithinInterval/index.js
function isWithinInterval(dirtyDate, interval2) {
  requiredArgs(2, arguments);
  var time3 = toDate(dirtyDate).getTime();
  var startTime = toDate(interval2.start).getTime();
  var endTime = toDate(interval2.end).getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  return time3 >= startTime && time3 <= endTime;
}
var init_isWithinInterval = __esm({
  "node_modules/date-fns/esm/isWithinInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isYesterday/index.js
function isYesterday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, subDays(Date.now(), 1));
}
var init_isYesterday = __esm({
  "node_modules/date-fns/esm/isYesterday/index.js"() {
    init_isSameDay();
    init_subDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfDecade/index.js
function lastDayOfDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var decade = 9 + Math.floor(year / 10) * 10;
  date2.setFullYear(decade + 1, 0, 0);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_lastDayOfDecade = __esm({
  "node_modules/date-fns/esm/lastDayOfDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfWeek/index.js
function lastDayOfWeek(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6");
  }
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  var diff2 = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date2.setHours(0, 0, 0, 0);
  date2.setDate(date2.getDate() + diff2);
  return date2;
}
var init_lastDayOfWeek = __esm({
  "node_modules/date-fns/esm/lastDayOfWeek/index.js"() {
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/lastDayOfISOWeek/index.js
function lastDayOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return lastDayOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
var init_lastDayOfISOWeek = __esm({
  "node_modules/date-fns/esm/lastDayOfISOWeek/index.js"() {
    init_lastDayOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfISOWeekYear/index.js
function lastDayOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setFullYear(year + 1, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date2 = startOfISOWeek(fourthOfJanuary);
  date2.setDate(date2.getDate() - 1);
  return date2;
}
var init_lastDayOfISOWeekYear = __esm({
  "node_modules/date-fns/esm/lastDayOfISOWeekYear/index.js"() {
    init_getISOWeekYear();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfQuarter/index.js
function lastDayOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var currentMonth = date2.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date2.setMonth(month, 0);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_lastDayOfQuarter = __esm({
  "node_modules/date-fns/esm/lastDayOfQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfYear/index.js
function lastDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  date2.setFullYear(year + 1, 0, 0);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_lastDayOfYear = __esm({
  "node_modules/date-fns/esm/lastDayOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lightFormat/index.js
function lightFormat(dirtyDate, formatStr) {
  requiredArgs(2, arguments);
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var tokens2 = formatStr.match(formattingTokensRegExp3);
  if (!tokens2)
    return "";
  var result = tokens2.map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString3(substring);
    }
    var formatter = lightFormatters_default[firstCharacter];
    if (formatter) {
      return formatter(utcDate, substring);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp3)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString3(input) {
  var matches = input.match(escapedStringRegExp3);
  if (!matches) {
    return input;
  }
  return matches[1].replace(doubleQuoteRegExp3, "'");
}
var formattingTokensRegExp3, escapedStringRegExp3, doubleQuoteRegExp3, unescapedLatinCharacterRegExp3;
var init_lightFormat = __esm({
  "node_modules/date-fns/esm/lightFormat/index.js"() {
    init_toDate();
    init_lightFormatters();
    init_getTimezoneOffsetInMilliseconds();
    init_isValid();
    init_subMilliseconds();
    init_requiredArgs();
    formattingTokensRegExp3 = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp3 = /^'([^]*?)'?$/;
    doubleQuoteRegExp3 = /''/g;
    unescapedLatinCharacterRegExp3 = /[a-zA-Z]/;
  }
});

// node_modules/date-fns/esm/milliseconds/index.js
function milliseconds(_ref2) {
  var years2 = _ref2.years, months3 = _ref2.months, weeks2 = _ref2.weeks, days3 = _ref2.days, hours2 = _ref2.hours, minutes2 = _ref2.minutes, seconds2 = _ref2.seconds;
  requiredArgs(1, arguments);
  var totalDays = 0;
  if (years2)
    totalDays += years2 * daysInYear2;
  if (months3)
    totalDays += months3 * (daysInYear2 / 12);
  if (weeks2)
    totalDays += weeks2 * 7;
  if (days3)
    totalDays += days3;
  var totalSeconds = totalDays * 24 * 60 * 60;
  if (hours2)
    totalSeconds += hours2 * 60 * 60;
  if (minutes2)
    totalSeconds += minutes2 * 60;
  if (seconds2)
    totalSeconds += seconds2;
  return Math.round(totalSeconds * 1e3);
}
var daysInYear2;
var init_milliseconds = __esm({
  "node_modules/date-fns/esm/milliseconds/index.js"() {
    init_requiredArgs();
    daysInYear2 = 365.2425;
  }
});

// node_modules/date-fns/esm/millisecondsToHours/index.js
function millisecondsToHours(milliseconds3) {
  requiredArgs(1, arguments);
  var hours2 = milliseconds3 / millisecondsInHour;
  return Math.floor(hours2);
}
var init_millisecondsToHours = __esm({
  "node_modules/date-fns/esm/millisecondsToHours/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/millisecondsToMinutes/index.js
function millisecondsToMinutes(milliseconds3) {
  requiredArgs(1, arguments);
  var minutes2 = milliseconds3 / millisecondsInMinute;
  return Math.floor(minutes2);
}
var init_millisecondsToMinutes = __esm({
  "node_modules/date-fns/esm/millisecondsToMinutes/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/millisecondsToSeconds/index.js
function millisecondsToSeconds(milliseconds3) {
  requiredArgs(1, arguments);
  var seconds2 = milliseconds3 / millisecondsInSecond;
  return Math.floor(seconds2);
}
var init_millisecondsToSeconds = __esm({
  "node_modules/date-fns/esm/millisecondsToSeconds/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/minutesToHours/index.js
function minutesToHours(minutes2) {
  requiredArgs(1, arguments);
  var hours2 = minutes2 / minutesInHour;
  return Math.floor(hours2);
}
var init_minutesToHours = __esm({
  "node_modules/date-fns/esm/minutesToHours/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/minutesToMilliseconds/index.js
function minutesToMilliseconds(minutes2) {
  requiredArgs(1, arguments);
  return Math.floor(minutes2 * millisecondsInMinute);
}
var init_minutesToMilliseconds = __esm({
  "node_modules/date-fns/esm/minutesToMilliseconds/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/minutesToSeconds/index.js
function minutesToSeconds(minutes2) {
  requiredArgs(1, arguments);
  return Math.floor(minutes2 * secondsInMinute);
}
var init_minutesToSeconds = __esm({
  "node_modules/date-fns/esm/minutesToSeconds/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/monthsToQuarters/index.js
function monthsToQuarters(months3) {
  requiredArgs(1, arguments);
  var quarters = months3 / monthsInQuarter;
  return Math.floor(quarters);
}
var init_monthsToQuarters = __esm({
  "node_modules/date-fns/esm/monthsToQuarters/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/monthsToYears/index.js
function monthsToYears(months3) {
  requiredArgs(1, arguments);
  var years2 = months3 / monthsInYear;
  return Math.floor(years2);
}
var init_monthsToYears = __esm({
  "node_modules/date-fns/esm/monthsToYears/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/nextDay/index.js
function nextDay(date2, day) {
  requiredArgs(2, arguments);
  var delta = day - getDay(date2);
  if (delta <= 0)
    delta += 7;
  return addDays(date2, delta);
}
var init_nextDay = __esm({
  "node_modules/date-fns/esm/nextDay/index.js"() {
    init_addDays();
    init_getDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextFriday/index.js
function nextFriday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 5);
}
var init_nextFriday = __esm({
  "node_modules/date-fns/esm/nextFriday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextMonday/index.js
function nextMonday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 1);
}
var init_nextMonday = __esm({
  "node_modules/date-fns/esm/nextMonday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextSaturday/index.js
function nextSaturday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 6);
}
var init_nextSaturday = __esm({
  "node_modules/date-fns/esm/nextSaturday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextSunday/index.js
function nextSunday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 0);
}
var init_nextSunday = __esm({
  "node_modules/date-fns/esm/nextSunday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextThursday/index.js
function nextThursday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 4);
}
var init_nextThursday = __esm({
  "node_modules/date-fns/esm/nextThursday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextTuesday/index.js
function nextTuesday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 2);
}
var init_nextTuesday = __esm({
  "node_modules/date-fns/esm/nextTuesday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextWednesday/index.js
function nextWednesday(date2) {
  requiredArgs(1, arguments);
  return nextDay(date2, 3);
}
var init_nextWednesday = __esm({
  "node_modules/date-fns/esm/nextWednesday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parseJSON/index.js
function parseJSON(argument) {
  requiredArgs(1, arguments);
  if (typeof argument === "string") {
    var parts = argument.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1), +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1), +parts[6], +((parts[7] || "0") + "00").substring(0, 3)));
    }
    return /* @__PURE__ */ new Date(NaN);
  }
  return toDate(argument);
}
var init_parseJSON = __esm({
  "node_modules/date-fns/esm/parseJSON/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/previousDay/index.js
function previousDay(date2, day) {
  requiredArgs(2, arguments);
  var delta = getDay(date2) - day;
  if (delta <= 0)
    delta += 7;
  return subDays(date2, delta);
}
var init_previousDay = __esm({
  "node_modules/date-fns/esm/previousDay/index.js"() {
    init_requiredArgs();
    init_getDay();
    init_subDays();
  }
});

// node_modules/date-fns/esm/previousFriday/index.js
function previousFriday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 5);
}
var init_previousFriday = __esm({
  "node_modules/date-fns/esm/previousFriday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousMonday/index.js
function previousMonday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 1);
}
var init_previousMonday = __esm({
  "node_modules/date-fns/esm/previousMonday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousSaturday/index.js
function previousSaturday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 6);
}
var init_previousSaturday = __esm({
  "node_modules/date-fns/esm/previousSaturday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousSunday/index.js
function previousSunday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 0);
}
var init_previousSunday = __esm({
  "node_modules/date-fns/esm/previousSunday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousThursday/index.js
function previousThursday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 4);
}
var init_previousThursday = __esm({
  "node_modules/date-fns/esm/previousThursday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousTuesday/index.js
function previousTuesday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 2);
}
var init_previousTuesday = __esm({
  "node_modules/date-fns/esm/previousTuesday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousWednesday/index.js
function previousWednesday(date2) {
  requiredArgs(1, arguments);
  return previousDay(date2, 3);
}
var init_previousWednesday = __esm({
  "node_modules/date-fns/esm/previousWednesday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/quartersToMonths/index.js
function quartersToMonths(quarters) {
  requiredArgs(1, arguments);
  return Math.floor(quarters * monthsInQuarter);
}
var init_quartersToMonths = __esm({
  "node_modules/date-fns/esm/quartersToMonths/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/quartersToYears/index.js
function quartersToYears(quarters) {
  requiredArgs(1, arguments);
  var years2 = quarters / quartersInYear;
  return Math.floor(years2);
}
var init_quartersToYears = __esm({
  "node_modules/date-fns/esm/quartersToYears/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/roundToNearestMinutes/index.js
function roundToNearestMinutes(dirtyDate, options) {
  var _options$nearestTo;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only none provided present");
  }
  var nearestTo = toInteger((_options$nearestTo = options === null || options === void 0 ? void 0 : options.nearestTo) !== null && _options$nearestTo !== void 0 ? _options$nearestTo : 1);
  if (nearestTo < 1 || nearestTo > 30) {
    throw new RangeError("`options.nearestTo` must be between 1 and 30");
  }
  var date2 = toDate(dirtyDate);
  var seconds2 = date2.getSeconds();
  var minutes2 = date2.getMinutes() + seconds2 / 60;
  var roundingMethod = getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod);
  var roundedMinutes = roundingMethod(minutes2 / nearestTo) * nearestTo;
  var remainderMinutes = minutes2 % nearestTo;
  var addedMinutes = Math.round(remainderMinutes / nearestTo) * nearestTo;
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), roundedMinutes + addedMinutes);
}
var init_roundToNearestMinutes = __esm({
  "node_modules/date-fns/esm/roundToNearestMinutes/index.js"() {
    init_toDate();
    init_roundingMethods();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/secondsToHours/index.js
function secondsToHours(seconds2) {
  requiredArgs(1, arguments);
  var hours2 = seconds2 / secondsInHour;
  return Math.floor(hours2);
}
var init_secondsToHours = __esm({
  "node_modules/date-fns/esm/secondsToHours/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/secondsToMilliseconds/index.js
function secondsToMilliseconds(seconds2) {
  requiredArgs(1, arguments);
  return seconds2 * millisecondsInSecond;
}
var init_secondsToMilliseconds = __esm({
  "node_modules/date-fns/esm/secondsToMilliseconds/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/secondsToMinutes/index.js
function secondsToMinutes(seconds2) {
  requiredArgs(1, arguments);
  var minutes2 = seconds2 / secondsInMinute;
  return Math.floor(minutes2);
}
var init_secondsToMinutes = __esm({
  "node_modules/date-fns/esm/secondsToMinutes/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/setDay/index.js
function setDay(dirtyDate, dirtyDay, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions4 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date2.getDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var delta = 7 - weekStartsOn;
  var diff2 = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date2, diff2);
}
var init_setDay = __esm({
  "node_modules/date-fns/esm/setDay/index.js"() {
    init_addDays();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/setDayOfYear/index.js
function setDayOfYear(dirtyDate, dirtyDayOfYear) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var dayOfYear = toInteger(dirtyDayOfYear);
  date2.setMonth(0);
  date2.setDate(dayOfYear);
  return date2;
}
var init_setDayOfYear = __esm({
  "node_modules/date-fns/esm/setDayOfYear/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setDefaultOptions/index.js
function setDefaultOptions2(newOptions) {
  requiredArgs(1, arguments);
  var result = {};
  var defaultOptions4 = getDefaultOptions();
  for (var property in defaultOptions4) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions4, property)) {
      ;
      result[property] = defaultOptions4[property];
    }
  }
  for (var _property in newOptions) {
    if (Object.prototype.hasOwnProperty.call(newOptions, _property)) {
      if (newOptions[_property] === void 0) {
        delete result[_property];
      } else {
        ;
        result[_property] = newOptions[_property];
      }
    }
  }
  setDefaultOptions(result);
}
var init_setDefaultOptions = __esm({
  "node_modules/date-fns/esm/setDefaultOptions/index.js"() {
    init_defaultOptions();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setISODay/index.js
function setISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = getISODay(date2);
  var diff2 = day - currentDay;
  return addDays(date2, diff2);
}
var init_setISODay = __esm({
  "node_modules/date-fns/esm/setISODay/index.js"() {
    init_toInteger();
    init_toDate();
    init_addDays();
    init_getISODay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setISOWeek/index.js
function setISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff2 = getISOWeek(date2) - isoWeek;
  date2.setDate(date2.getDate() - diff2 * 7);
  return date2;
}
var init_setISOWeek = __esm({
  "node_modules/date-fns/esm/setISOWeek/index.js"() {
    init_toInteger();
    init_toDate();
    init_getISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setMilliseconds/index.js
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var milliseconds3 = toInteger(dirtyMilliseconds);
  date2.setMilliseconds(milliseconds3);
  return date2;
}
var init_setMilliseconds = __esm({
  "node_modules/date-fns/esm/setMilliseconds/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setQuarter/index.js
function setQuarter(dirtyDate, dirtyQuarter) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var quarter = toInteger(dirtyQuarter);
  var oldQuarter = Math.floor(date2.getMonth() / 3) + 1;
  var diff2 = quarter - oldQuarter;
  return setMonth(date2, date2.getMonth() + diff2 * 3);
}
var init_setQuarter = __esm({
  "node_modules/date-fns/esm/setQuarter/index.js"() {
    init_toInteger();
    init_toDate();
    init_setMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setSeconds/index.js
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var seconds2 = toInteger(dirtySeconds);
  date2.setSeconds(seconds2);
  return date2;
}
var init_setSeconds = __esm({
  "node_modules/date-fns/esm/setSeconds/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setWeek/index.js
function setWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff2 = getWeek(date2, options) - week;
  date2.setDate(date2.getDate() - diff2 * 7);
  return date2;
}
var init_setWeek = __esm({
  "node_modules/date-fns/esm/setWeek/index.js"() {
    init_getWeek();
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/setWeekYear/index.js
function setWeekYear(dirtyDate, dirtyWeekYear, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions4 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  var date2 = toDate(dirtyDate);
  var weekYear = toInteger(dirtyWeekYear);
  var diff2 = differenceInCalendarDays(date2, startOfWeekYear(date2, options));
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  date2 = startOfWeekYear(firstWeek, options);
  date2.setDate(date2.getDate() + diff2);
  return date2;
}
var init_setWeekYear = __esm({
  "node_modules/date-fns/esm/setWeekYear/index.js"() {
    init_differenceInCalendarDays();
    init_startOfWeekYear();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/startOfDecade/index.js
function startOfDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getFullYear();
  var decade = Math.floor(year / 10) * 10;
  date2.setFullYear(decade, 0, 1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfDecade = __esm({
  "node_modules/date-fns/esm/startOfDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfTomorrow/index.js
function startOfTomorrow() {
  var now2 = /* @__PURE__ */ new Date();
  var year = now2.getFullYear();
  var month = now2.getMonth();
  var day = now2.getDate();
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setFullYear(year, month, day + 1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfTomorrow = __esm({
  "node_modules/date-fns/esm/startOfTomorrow/index.js"() {
  }
});

// node_modules/date-fns/esm/startOfYesterday/index.js
function startOfYesterday() {
  var now2 = /* @__PURE__ */ new Date();
  var year = now2.getFullYear();
  var month = now2.getMonth();
  var day = now2.getDate();
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setFullYear(year, month, day - 1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var init_startOfYesterday = __esm({
  "node_modules/date-fns/esm/startOfYesterday/index.js"() {
  }
});

// node_modules/date-fns/esm/subBusinessDays/index.js
function subBusinessDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addBusinessDays(dirtyDate, -amount);
}
var init_subBusinessDays = __esm({
  "node_modules/date-fns/esm/subBusinessDays/index.js"() {
    init_addBusinessDays();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subHours/index.js
function subHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addHours(dirtyDate, -amount);
}
var init_subHours = __esm({
  "node_modules/date-fns/esm/subHours/index.js"() {
    init_addHours();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subMinutes/index.js
function subMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMinutes(dirtyDate, -amount);
}
var init_subMinutes = __esm({
  "node_modules/date-fns/esm/subMinutes/index.js"() {
    init_addMinutes();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subQuarters/index.js
function subQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addQuarters(dirtyDate, -amount);
}
var init_subQuarters = __esm({
  "node_modules/date-fns/esm/subQuarters/index.js"() {
    init_toInteger();
    init_addQuarters();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subSeconds/index.js
function subSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addSeconds(dirtyDate, -amount);
}
var init_subSeconds = __esm({
  "node_modules/date-fns/esm/subSeconds/index.js"() {
    init_toInteger();
    init_addSeconds();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subWeeks/index.js
function subWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addWeeks(dirtyDate, -amount);
}
var init_subWeeks = __esm({
  "node_modules/date-fns/esm/subWeeks/index.js"() {
    init_toInteger();
    init_addWeeks();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subYears/index.js
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
var init_subYears = __esm({
  "node_modules/date-fns/esm/subYears/index.js"() {
    init_toInteger();
    init_addYears();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/weeksToDays/index.js
function weeksToDays(weeks2) {
  requiredArgs(1, arguments);
  return Math.floor(weeks2 * daysInWeek);
}
var init_weeksToDays = __esm({
  "node_modules/date-fns/esm/weeksToDays/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/yearsToMonths/index.js
function yearsToMonths(years2) {
  requiredArgs(1, arguments);
  return Math.floor(years2 * monthsInYear);
}
var init_yearsToMonths = __esm({
  "node_modules/date-fns/esm/yearsToMonths/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/yearsToQuarters/index.js
function yearsToQuarters(years2) {
  requiredArgs(1, arguments);
  return Math.floor(years2 * quartersInYear);
}
var init_yearsToQuarters = __esm({
  "node_modules/date-fns/esm/yearsToQuarters/index.js"() {
    init_requiredArgs();
    init_constants2();
  }
});

// node_modules/date-fns/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  add: () => add,
  addBusinessDays: () => addBusinessDays,
  addDays: () => addDays,
  addHours: () => addHours,
  addISOWeekYears: () => addISOWeekYears,
  addMilliseconds: () => addMilliseconds,
  addMinutes: () => addMinutes,
  addMonths: () => addMonths,
  addQuarters: () => addQuarters,
  addSeconds: () => addSeconds,
  addWeeks: () => addWeeks,
  addYears: () => addYears,
  areIntervalsOverlapping: () => areIntervalsOverlapping,
  clamp: () => clamp2,
  closestIndexTo: () => closestIndexTo,
  closestTo: () => closestTo,
  compareAsc: () => compareAsc,
  compareDesc: () => compareDesc,
  daysInWeek: () => daysInWeek,
  daysInYear: () => daysInYear,
  daysToWeeks: () => daysToWeeks,
  differenceInBusinessDays: () => differenceInBusinessDays,
  differenceInCalendarDays: () => differenceInCalendarDays,
  differenceInCalendarISOWeekYears: () => differenceInCalendarISOWeekYears,
  differenceInCalendarISOWeeks: () => differenceInCalendarISOWeeks,
  differenceInCalendarMonths: () => differenceInCalendarMonths,
  differenceInCalendarQuarters: () => differenceInCalendarQuarters,
  differenceInCalendarWeeks: () => differenceInCalendarWeeks,
  differenceInCalendarYears: () => differenceInCalendarYears,
  differenceInDays: () => differenceInDays,
  differenceInHours: () => differenceInHours,
  differenceInISOWeekYears: () => differenceInISOWeekYears,
  differenceInMilliseconds: () => differenceInMilliseconds,
  differenceInMinutes: () => differenceInMinutes,
  differenceInMonths: () => differenceInMonths,
  differenceInQuarters: () => differenceInQuarters,
  differenceInSeconds: () => differenceInSeconds,
  differenceInWeeks: () => differenceInWeeks,
  differenceInYears: () => differenceInYears,
  eachDayOfInterval: () => eachDayOfInterval,
  eachHourOfInterval: () => eachHourOfInterval,
  eachMinuteOfInterval: () => eachMinuteOfInterval,
  eachMonthOfInterval: () => eachMonthOfInterval,
  eachQuarterOfInterval: () => eachQuarterOfInterval,
  eachWeekOfInterval: () => eachWeekOfInterval,
  eachWeekendOfInterval: () => eachWeekendOfInterval,
  eachWeekendOfMonth: () => eachWeekendOfMonth,
  eachWeekendOfYear: () => eachWeekendOfYear,
  eachYearOfInterval: () => eachYearOfInterval,
  endOfDay: () => endOfDay,
  endOfDecade: () => endOfDecade,
  endOfHour: () => endOfHour,
  endOfISOWeek: () => endOfISOWeek,
  endOfISOWeekYear: () => endOfISOWeekYear,
  endOfMinute: () => endOfMinute,
  endOfMonth: () => endOfMonth,
  endOfQuarter: () => endOfQuarter,
  endOfSecond: () => endOfSecond,
  endOfToday: () => endOfToday,
  endOfTomorrow: () => endOfTomorrow,
  endOfWeek: () => endOfWeek,
  endOfYear: () => endOfYear,
  endOfYesterday: () => endOfYesterday,
  format: () => format,
  formatDistance: () => formatDistance3,
  formatDistanceStrict: () => formatDistanceStrict,
  formatDistanceToNow: () => formatDistanceToNow,
  formatDistanceToNowStrict: () => formatDistanceToNowStrict,
  formatDuration: () => formatDuration,
  formatISO: () => formatISO,
  formatISO9075: () => formatISO9075,
  formatISODuration: () => formatISODuration,
  formatRFC3339: () => formatRFC3339,
  formatRFC7231: () => formatRFC7231,
  formatRelative: () => formatRelative3,
  fromUnixTime: () => fromUnixTime,
  getDate: () => getDate,
  getDay: () => getDay,
  getDayOfYear: () => getDayOfYear,
  getDaysInMonth: () => getDaysInMonth,
  getDaysInYear: () => getDaysInYear,
  getDecade: () => getDecade,
  getDefaultOptions: () => getDefaultOptions2,
  getHours: () => getHours,
  getISODay: () => getISODay,
  getISOWeek: () => getISOWeek,
  getISOWeekYear: () => getISOWeekYear,
  getISOWeeksInYear: () => getISOWeeksInYear,
  getMilliseconds: () => getMilliseconds,
  getMinutes: () => getMinutes,
  getMonth: () => getMonth,
  getOverlappingDaysInIntervals: () => getOverlappingDaysInIntervals,
  getQuarter: () => getQuarter,
  getSeconds: () => getSeconds,
  getTime: () => getTime,
  getUnixTime: () => getUnixTime,
  getWeek: () => getWeek,
  getWeekOfMonth: () => getWeekOfMonth,
  getWeekYear: () => getWeekYear,
  getWeeksInMonth: () => getWeeksInMonth,
  getYear: () => getYear,
  hoursToMilliseconds: () => hoursToMilliseconds,
  hoursToMinutes: () => hoursToMinutes,
  hoursToSeconds: () => hoursToSeconds,
  intervalToDuration: () => intervalToDuration,
  intlFormat: () => intlFormat,
  intlFormatDistance: () => intlFormatDistance,
  isAfter: () => isAfter,
  isBefore: () => isBefore,
  isDate: () => isDate,
  isEqual: () => isEqual,
  isExists: () => isExists,
  isFirstDayOfMonth: () => isFirstDayOfMonth,
  isFriday: () => isFriday,
  isFuture: () => isFuture,
  isLastDayOfMonth: () => isLastDayOfMonth,
  isLeapYear: () => isLeapYear,
  isMatch: () => isMatch,
  isMonday: () => isMonday,
  isPast: () => isPast,
  isSameDay: () => isSameDay,
  isSameHour: () => isSameHour,
  isSameISOWeek: () => isSameISOWeek,
  isSameISOWeekYear: () => isSameISOWeekYear,
  isSameMinute: () => isSameMinute,
  isSameMonth: () => isSameMonth,
  isSameQuarter: () => isSameQuarter,
  isSameSecond: () => isSameSecond,
  isSameWeek: () => isSameWeek,
  isSameYear: () => isSameYear,
  isSaturday: () => isSaturday,
  isSunday: () => isSunday,
  isThisHour: () => isThisHour,
  isThisISOWeek: () => isThisISOWeek,
  isThisMinute: () => isThisMinute,
  isThisMonth: () => isThisMonth,
  isThisQuarter: () => isThisQuarter,
  isThisSecond: () => isThisSecond,
  isThisWeek: () => isThisWeek,
  isThisYear: () => isThisYear,
  isThursday: () => isThursday,
  isToday: () => isToday,
  isTomorrow: () => isTomorrow,
  isTuesday: () => isTuesday,
  isValid: () => isValid,
  isWednesday: () => isWednesday,
  isWeekend: () => isWeekend,
  isWithinInterval: () => isWithinInterval,
  isYesterday: () => isYesterday,
  lastDayOfDecade: () => lastDayOfDecade,
  lastDayOfISOWeek: () => lastDayOfISOWeek,
  lastDayOfISOWeekYear: () => lastDayOfISOWeekYear,
  lastDayOfMonth: () => lastDayOfMonth,
  lastDayOfQuarter: () => lastDayOfQuarter,
  lastDayOfWeek: () => lastDayOfWeek,
  lastDayOfYear: () => lastDayOfYear,
  lightFormat: () => lightFormat,
  max: () => max2,
  maxTime: () => maxTime,
  milliseconds: () => milliseconds,
  millisecondsInHour: () => millisecondsInHour,
  millisecondsInMinute: () => millisecondsInMinute,
  millisecondsInSecond: () => millisecondsInSecond,
  millisecondsToHours: () => millisecondsToHours,
  millisecondsToMinutes: () => millisecondsToMinutes,
  millisecondsToSeconds: () => millisecondsToSeconds,
  min: () => min2,
  minTime: () => minTime,
  minutesInHour: () => minutesInHour,
  minutesToHours: () => minutesToHours,
  minutesToMilliseconds: () => minutesToMilliseconds,
  minutesToSeconds: () => minutesToSeconds,
  monthsInQuarter: () => monthsInQuarter,
  monthsInYear: () => monthsInYear,
  monthsToQuarters: () => monthsToQuarters,
  monthsToYears: () => monthsToYears,
  nextDay: () => nextDay,
  nextFriday: () => nextFriday,
  nextMonday: () => nextMonday,
  nextSaturday: () => nextSaturday,
  nextSunday: () => nextSunday,
  nextThursday: () => nextThursday,
  nextTuesday: () => nextTuesday,
  nextWednesday: () => nextWednesday,
  parse: () => parse2,
  parseISO: () => parseISO,
  parseJSON: () => parseJSON,
  previousDay: () => previousDay,
  previousFriday: () => previousFriday,
  previousMonday: () => previousMonday,
  previousSaturday: () => previousSaturday,
  previousSunday: () => previousSunday,
  previousThursday: () => previousThursday,
  previousTuesday: () => previousTuesday,
  previousWednesday: () => previousWednesday,
  quartersInYear: () => quartersInYear,
  quartersToMonths: () => quartersToMonths,
  quartersToYears: () => quartersToYears,
  roundToNearestMinutes: () => roundToNearestMinutes,
  secondsInDay: () => secondsInDay,
  secondsInHour: () => secondsInHour,
  secondsInMinute: () => secondsInMinute,
  secondsInMonth: () => secondsInMonth,
  secondsInQuarter: () => secondsInQuarter,
  secondsInWeek: () => secondsInWeek,
  secondsInYear: () => secondsInYear,
  secondsToHours: () => secondsToHours,
  secondsToMilliseconds: () => secondsToMilliseconds,
  secondsToMinutes: () => secondsToMinutes,
  set: () => set,
  setDate: () => setDate,
  setDay: () => setDay,
  setDayOfYear: () => setDayOfYear,
  setDefaultOptions: () => setDefaultOptions2,
  setHours: () => setHours,
  setISODay: () => setISODay,
  setISOWeek: () => setISOWeek,
  setISOWeekYear: () => setISOWeekYear,
  setMilliseconds: () => setMilliseconds,
  setMinutes: () => setMinutes,
  setMonth: () => setMonth,
  setQuarter: () => setQuarter,
  setSeconds: () => setSeconds,
  setWeek: () => setWeek,
  setWeekYear: () => setWeekYear,
  setYear: () => setYear,
  startOfDay: () => startOfDay,
  startOfDecade: () => startOfDecade,
  startOfHour: () => startOfHour,
  startOfISOWeek: () => startOfISOWeek,
  startOfISOWeekYear: () => startOfISOWeekYear,
  startOfMinute: () => startOfMinute,
  startOfMonth: () => startOfMonth,
  startOfQuarter: () => startOfQuarter,
  startOfSecond: () => startOfSecond,
  startOfToday: () => startOfToday,
  startOfTomorrow: () => startOfTomorrow,
  startOfWeek: () => startOfWeek,
  startOfWeekYear: () => startOfWeekYear,
  startOfYear: () => startOfYear,
  startOfYesterday: () => startOfYesterday,
  sub: () => sub,
  subBusinessDays: () => subBusinessDays,
  subDays: () => subDays,
  subHours: () => subHours,
  subISOWeekYears: () => subISOWeekYears,
  subMilliseconds: () => subMilliseconds,
  subMinutes: () => subMinutes,
  subMonths: () => subMonths,
  subQuarters: () => subQuarters,
  subSeconds: () => subSeconds,
  subWeeks: () => subWeeks,
  subYears: () => subYears,
  toDate: () => toDate,
  weeksToDays: () => weeksToDays,
  yearsToMonths: () => yearsToMonths,
  yearsToQuarters: () => yearsToQuarters
});
var init_esm4 = __esm({
  "node_modules/date-fns/esm/index.js"() {
    init_add();
    init_addBusinessDays();
    init_addDays();
    init_addHours();
    init_addISOWeekYears();
    init_addMilliseconds();
    init_addMinutes();
    init_addMonths();
    init_addQuarters();
    init_addSeconds();
    init_addWeeks();
    init_addYears();
    init_areIntervalsOverlapping();
    init_clamp();
    init_closestIndexTo();
    init_closestTo();
    init_compareAsc();
    init_compareDesc();
    init_daysToWeeks();
    init_differenceInBusinessDays();
    init_differenceInCalendarDays();
    init_differenceInCalendarISOWeekYears();
    init_differenceInCalendarISOWeeks();
    init_differenceInCalendarMonths();
    init_differenceInCalendarQuarters();
    init_differenceInCalendarWeeks();
    init_differenceInCalendarYears();
    init_differenceInDays();
    init_differenceInHours();
    init_differenceInISOWeekYears();
    init_differenceInMilliseconds();
    init_differenceInMinutes();
    init_differenceInMonths();
    init_differenceInQuarters();
    init_differenceInSeconds();
    init_differenceInWeeks();
    init_differenceInYears();
    init_eachDayOfInterval();
    init_eachHourOfInterval();
    init_eachMinuteOfInterval();
    init_eachMonthOfInterval();
    init_eachQuarterOfInterval();
    init_eachWeekOfInterval();
    init_eachWeekendOfInterval();
    init_eachWeekendOfMonth();
    init_eachWeekendOfYear();
    init_eachYearOfInterval();
    init_endOfDay();
    init_endOfDecade();
    init_endOfHour();
    init_endOfISOWeek();
    init_endOfISOWeekYear();
    init_endOfMinute();
    init_endOfMonth();
    init_endOfQuarter();
    init_endOfSecond();
    init_endOfToday();
    init_endOfTomorrow();
    init_endOfWeek();
    init_endOfYear();
    init_endOfYesterday();
    init_format();
    init_formatDistance2();
    init_formatDistanceStrict();
    init_formatDistanceToNow();
    init_formatDistanceToNowStrict();
    init_formatDuration();
    init_formatISO();
    init_formatISO9075();
    init_formatISODuration();
    init_formatRFC3339();
    init_formatRFC7231();
    init_formatRelative2();
    init_fromUnixTime();
    init_getDate();
    init_getDay();
    init_getDayOfYear();
    init_getDaysInMonth();
    init_getDaysInYear();
    init_getDecade();
    init_getDefaultOptions();
    init_getHours();
    init_getISODay();
    init_getISOWeek();
    init_getISOWeekYear();
    init_getISOWeeksInYear();
    init_getMilliseconds();
    init_getMinutes();
    init_getMonth();
    init_getOverlappingDaysInIntervals();
    init_getQuarter();
    init_getSeconds();
    init_getTime();
    init_getUnixTime();
    init_getWeek();
    init_getWeekOfMonth();
    init_getWeekYear();
    init_getWeeksInMonth();
    init_getYear();
    init_hoursToMilliseconds();
    init_hoursToMinutes();
    init_hoursToSeconds();
    init_intervalToDuration();
    init_intlFormat();
    init_intlFormatDistance();
    init_isAfter();
    init_isBefore();
    init_isDate2();
    init_isEqual();
    init_isExists();
    init_isFirstDayOfMonth();
    init_isFriday();
    init_isFuture();
    init_isLastDayOfMonth();
    init_isLeapYear();
    init_isMatch();
    init_isMonday();
    init_isPast();
    init_isSameDay();
    init_isSameHour();
    init_isSameISOWeek();
    init_isSameISOWeekYear();
    init_isSameMinute();
    init_isSameMonth();
    init_isSameQuarter();
    init_isSameSecond();
    init_isSameWeek();
    init_isSameYear();
    init_isSaturday();
    init_isSunday();
    init_isThisHour();
    init_isThisISOWeek();
    init_isThisMinute();
    init_isThisMonth();
    init_isThisQuarter();
    init_isThisSecond();
    init_isThisWeek();
    init_isThisYear();
    init_isThursday();
    init_isToday();
    init_isTomorrow();
    init_isTuesday();
    init_isValid();
    init_isWednesday();
    init_isWeekend();
    init_isWithinInterval();
    init_isYesterday();
    init_lastDayOfDecade();
    init_lastDayOfISOWeek();
    init_lastDayOfISOWeekYear();
    init_lastDayOfMonth();
    init_lastDayOfQuarter();
    init_lastDayOfWeek();
    init_lastDayOfYear();
    init_lightFormat();
    init_max2();
    init_milliseconds();
    init_millisecondsToHours();
    init_millisecondsToMinutes();
    init_millisecondsToSeconds();
    init_min2();
    init_minutesToHours();
    init_minutesToMilliseconds();
    init_minutesToSeconds();
    init_monthsToQuarters();
    init_monthsToYears();
    init_nextDay();
    init_nextFriday();
    init_nextMonday();
    init_nextSaturday();
    init_nextSunday();
    init_nextThursday();
    init_nextTuesday();
    init_nextWednesday();
    init_parse();
    init_parseISO();
    init_parseJSON();
    init_previousDay();
    init_previousFriday();
    init_previousMonday();
    init_previousSaturday();
    init_previousSunday();
    init_previousThursday();
    init_previousTuesday();
    init_previousWednesday();
    init_quartersToMonths();
    init_quartersToYears();
    init_roundToNearestMinutes();
    init_secondsToHours();
    init_secondsToMilliseconds();
    init_secondsToMinutes();
    init_set();
    init_setDate();
    init_setDay();
    init_setDayOfYear();
    init_setDefaultOptions();
    init_setHours();
    init_setISODay();
    init_setISOWeek();
    init_setISOWeekYear();
    init_setMilliseconds();
    init_setMinutes();
    init_setMonth();
    init_setQuarter();
    init_setSeconds();
    init_setWeek();
    init_setWeekYear();
    init_setYear();
    init_startOfDay();
    init_startOfDecade();
    init_startOfHour();
    init_startOfISOWeek();
    init_startOfISOWeekYear();
    init_startOfMinute();
    init_startOfMonth();
    init_startOfQuarter();
    init_startOfSecond();
    init_startOfToday();
    init_startOfTomorrow();
    init_startOfWeek();
    init_startOfWeekYear();
    init_startOfYear();
    init_startOfYesterday();
    init_sub();
    init_subBusinessDays();
    init_subDays();
    init_subHours();
    init_subISOWeekYears();
    init_subMilliseconds();
    init_subMinutes();
    init_subMonths();
    init_subQuarters();
    init_subSeconds();
    init_subWeeks();
    init_subYears();
    init_toDate();
    init_weeksToDays();
    init_yearsToMonths();
    init_yearsToQuarters();
    init_constants2();
  }
});

// node_modules/@sanity/image-url/lib/browser/image-url.umd.js
var require_image_url_umd = __commonJS({
  "node_modules/@sanity/image-url/lib/browser/image-url.umd.js"(exports, module2) {
    (function(global3, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global3 = global3 || self, global3.SanityImageUrlBuilder = factory());
    })(exports, function() {
      function _extends3() {
        _extends3 = Object.assign || function(target) {
          for (var i4 = 1; i4 < arguments.length; i4++) {
            var source = arguments[i4];
            for (var key2 in source) {
              if (Object.prototype.hasOwnProperty.call(source, key2)) {
                target[key2] = source[key2];
              }
            }
          }
          return target;
        };
        return _extends3.apply(this, arguments);
      }
      function _unsupportedIterableToArray3(o4, minLen) {
        if (!o4)
          return;
        if (typeof o4 === "string")
          return _arrayLikeToArray3(o4, minLen);
        var n4 = Object.prototype.toString.call(o4).slice(8, -1);
        if (n4 === "Object" && o4.constructor)
          n4 = o4.constructor.name;
        if (n4 === "Map" || n4 === "Set")
          return Array.from(o4);
        if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
          return _arrayLikeToArray3(o4, minLen);
      }
      function _arrayLikeToArray3(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++)
          arr2[i4] = arr[i4];
        return arr2;
      }
      function _createForOfIteratorHelperLoose2(o4, allowArrayLike) {
        var it2 = typeof Symbol !== "undefined" && o4[Symbol.iterator] || o4["@@iterator"];
        if (it2)
          return (it2 = it2.call(o4)).next.bind(it2);
        if (Array.isArray(o4) || (it2 = _unsupportedIterableToArray3(o4)) || allowArrayLike && o4 && typeof o4.length === "number") {
          if (it2)
            o4 = it2;
          var i4 = 0;
          return function() {
            if (i4 >= o4.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o4[i4++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var example = "image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg";
      function parseAssetId2(ref) {
        var _ref$split = ref.split("-"), id2 = _ref$split[1], dimensionString = _ref$split[2], format4 = _ref$split[3];
        if (!id2 || !dimensionString || !format4) {
          throw new Error("Malformed asset _ref '" + ref + `'. Expected an id like "` + example + '".');
        }
        var _dimensionString$spli = dimensionString.split("x"), imgWidthStr = _dimensionString$spli[0], imgHeightStr = _dimensionString$spli[1];
        var width = +imgWidthStr;
        var height = +imgHeightStr;
        var isValidAssetId = isFinite(width) && isFinite(height);
        if (!isValidAssetId) {
          throw new Error("Malformed asset _ref '" + ref + `'. Expected an id like "` + example + '".');
        }
        return {
          id: id2,
          width,
          height,
          format: format4
        };
      }
      var isRef = function isRef2(src) {
        var source = src;
        return source ? typeof source._ref === "string" : false;
      };
      var isAsset = function isAsset2(src) {
        var source = src;
        return source ? typeof source._id === "string" : false;
      };
      var isAssetStub = function isAssetStub2(src) {
        var source = src;
        return source && source.asset ? typeof source.asset.url === "string" : false;
      };
      function parseSource(source) {
        if (!source) {
          return null;
        }
        var image;
        if (typeof source === "string" && isUrl(source)) {
          image = {
            asset: {
              _ref: urlToId(source)
            }
          };
        } else if (typeof source === "string") {
          image = {
            asset: {
              _ref: source
            }
          };
        } else if (isRef(source)) {
          image = {
            asset: source
          };
        } else if (isAsset(source)) {
          image = {
            asset: {
              _ref: source._id || ""
            }
          };
        } else if (isAssetStub(source)) {
          image = {
            asset: {
              _ref: urlToId(source.asset.url)
            }
          };
        } else if (typeof source.asset === "object") {
          image = _extends3({}, source);
        } else {
          return null;
        }
        var img = source;
        if (img.crop) {
          image.crop = img.crop;
        }
        if (img.hotspot) {
          image.hotspot = img.hotspot;
        }
        return applyDefaults(image);
      }
      function isUrl(url) {
        return /^https?:\/\//.test("" + url);
      }
      function urlToId(url) {
        var parts = url.split("/").slice(-1);
        return ("image-" + parts[0]).replace(/\.([a-z]+)$/, "-$1");
      }
      function applyDefaults(image) {
        if (image.crop && image.hotspot) {
          return image;
        }
        var result = _extends3({}, image);
        if (!result.crop) {
          result.crop = {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0
          };
        }
        if (!result.hotspot) {
          result.hotspot = {
            x: 0.5,
            y: 0.5,
            height: 1,
            width: 1
          };
        }
        return result;
      }
      var SPEC_NAME_TO_URL_NAME_MAPPINGS = [["width", "w"], ["height", "h"], ["format", "fm"], ["download", "dl"], ["blur", "blur"], ["sharpen", "sharp"], ["invert", "invert"], ["orientation", "or"], ["minHeight", "min-h"], ["maxHeight", "max-h"], ["minWidth", "min-w"], ["maxWidth", "max-w"], ["quality", "q"], ["fit", "fit"], ["crop", "crop"], ["saturation", "sat"], ["auto", "auto"], ["dpr", "dpr"], ["pad", "pad"]];
      function urlForImage(options) {
        var spec = _extends3({}, options || {});
        var source = spec.source;
        delete spec.source;
        var image = parseSource(source);
        if (!image) {
          throw new Error("Unable to resolve image URL from source (" + JSON.stringify(source) + ")");
        }
        var id2 = image.asset._ref || image.asset._id || "";
        var asset = parseAssetId2(id2);
        var cropLeft = Math.round(image.crop.left * asset.width);
        var cropTop = Math.round(image.crop.top * asset.height);
        var crop = {
          left: cropLeft,
          top: cropTop,
          width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
          height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
        };
        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
        var hotSpotCenterX = image.hotspot.x * asset.width;
        var hotSpotCenterY = image.hotspot.y * asset.height;
        var hotspot = {
          left: hotSpotCenterX - hotSpotHorizontalRadius,
          top: hotSpotCenterY - hotSpotVerticalRadius,
          right: hotSpotCenterX + hotSpotHorizontalRadius,
          bottom: hotSpotCenterY + hotSpotVerticalRadius
        };
        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
          spec = _extends3({}, spec, fit({
            crop,
            hotspot
          }, spec));
        }
        return specToImageUrl(_extends3({}, spec, {
          asset
        }));
      }
      function specToImageUrl(spec) {
        var cdnUrl2 = (spec.baseUrl || "https://cdn.sanity.io").replace(/\/+$/, "");
        var filename = spec.asset.id + "-" + spec.asset.width + "x" + spec.asset.height + "." + spec.asset.format;
        var baseUrl = cdnUrl2 + "/images/" + spec.projectId + "/" + spec.dataset + "/" + filename;
        var params = [];
        if (spec.rect) {
          var _spec$rect = spec.rect, left = _spec$rect.left, top = _spec$rect.top, width = _spec$rect.width, height = _spec$rect.height;
          var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;
          if (isEffectiveCrop) {
            params.push("rect=" + left + "," + top + "," + width + "," + height);
          }
        }
        if (spec.bg) {
          params.push("bg=" + spec.bg);
        }
        if (spec.focalPoint) {
          params.push("fp-x=" + spec.focalPoint.x);
          params.push("fp-y=" + spec.focalPoint.y);
        }
        var flip2 = [spec.flipHorizontal && "h", spec.flipVertical && "v"].filter(Boolean).join("");
        if (flip2) {
          params.push("flip=" + flip2);
        }
        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {
          var specName = mapping[0], param = mapping[1];
          if (typeof spec[specName] !== "undefined") {
            params.push(param + "=" + encodeURIComponent(spec[specName]));
          } else if (typeof spec[param] !== "undefined") {
            params.push(param + "=" + encodeURIComponent(spec[param]));
          }
        });
        if (params.length === 0) {
          return baseUrl;
        }
        return baseUrl + "?" + params.join("&");
      }
      function fit(source, spec) {
        var cropRect;
        var imgWidth = spec.width;
        var imgHeight = spec.height;
        if (!(imgWidth && imgHeight)) {
          return {
            width: imgWidth,
            height: imgHeight,
            rect: source.crop
          };
        }
        var crop = source.crop;
        var hotspot = source.hotspot;
        var desiredAspectRatio = imgWidth / imgHeight;
        var cropAspectRatio = crop.width / crop.height;
        if (cropAspectRatio > desiredAspectRatio) {
          var height = Math.round(crop.height);
          var width = Math.round(height * desiredAspectRatio);
          var top = Math.max(0, Math.round(crop.top));
          var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);
          var left = Math.max(0, Math.round(hotspotXCenter - width / 2));
          if (left < crop.left) {
            left = crop.left;
          } else if (left + width > crop.left + crop.width) {
            left = crop.left + crop.width - width;
          }
          cropRect = {
            left,
            top,
            width,
            height
          };
        } else {
          var _width = crop.width;
          var _height = Math.round(_width / desiredAspectRatio);
          var _left = Math.max(0, Math.round(crop.left));
          var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);
          var _top = Math.max(0, Math.round(hotspotYCenter - _height / 2));
          if (_top < crop.top) {
            _top = crop.top;
          } else if (_top + _height > crop.top + crop.height) {
            _top = crop.top + crop.height - _height;
          }
          cropRect = {
            left: _left,
            top: _top,
            width: _width,
            height: _height
          };
        }
        return {
          width: imgWidth,
          height: imgHeight,
          rect: cropRect
        };
      }
      var validFits = ["clip", "crop", "fill", "fillmax", "max", "scale", "min"];
      var validCrops = ["top", "bottom", "left", "right", "center", "focalpoint", "entropy"];
      var validAutoModes = ["format"];
      function isSanityModernClientLike(client) {
        return client && "config" in client ? typeof client.config === "function" : false;
      }
      function isSanityClientLike(client) {
        return client && "clientConfig" in client ? typeof client.clientConfig === "object" : false;
      }
      function rewriteSpecName(key2) {
        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;
        for (var _iterator = _createForOfIteratorHelperLoose2(specs), _step; !(_step = _iterator()).done; ) {
          var entry = _step.value;
          var specName = entry[0], param = entry[1];
          if (key2 === specName || key2 === param) {
            return specName;
          }
        }
        return key2;
      }
      function urlBuilder(options) {
        if (isSanityModernClientLike(options)) {
          var _options$config = options.config(), apiUrl = _options$config.apiHost, projectId = _options$config.projectId, dataset = _options$config.dataset;
          var apiHost = apiUrl || "https://api.sanity.io";
          return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, "https://cdn."),
            projectId,
            dataset
          });
        }
        var client = options;
        if (isSanityClientLike(client)) {
          var _client$clientConfig = client.clientConfig, _apiUrl = _client$clientConfig.apiHost, _projectId = _client$clientConfig.projectId, _dataset = _client$clientConfig.dataset;
          var _apiHost = _apiUrl || "https://api.sanity.io";
          return new ImageUrlBuilder(null, {
            baseUrl: _apiHost.replace(/^https:\/\/api\./, "https://cdn."),
            projectId: _projectId,
            dataset: _dataset
          });
        }
        return new ImageUrlBuilder(null, options);
      }
      var ImageUrlBuilder = function() {
        function ImageUrlBuilder2(parent3, options) {
          this.options = void 0;
          this.options = parent3 ? _extends3({}, parent3.options || {}, options || {}) : _extends3({}, options || {});
        }
        var _proto = ImageUrlBuilder2.prototype;
        _proto.withOptions = function withOptions(options) {
          var baseUrl = options.baseUrl || this.options.baseUrl;
          var newOptions = {
            baseUrl
          };
          for (var key2 in options) {
            if (options.hasOwnProperty(key2)) {
              var specKey = rewriteSpecName(key2);
              newOptions[specKey] = options[key2];
            }
          }
          return new ImageUrlBuilder2(this, _extends3({
            baseUrl
          }, newOptions));
        };
        _proto.image = function image(source) {
          return this.withOptions({
            source
          });
        };
        _proto.dataset = function dataset(_dataset2) {
          return this.withOptions({
            dataset: _dataset2
          });
        };
        _proto.projectId = function projectId(_projectId2) {
          return this.withOptions({
            projectId: _projectId2
          });
        };
        _proto.bg = function bg(_bg) {
          return this.withOptions({
            bg: _bg
          });
        };
        _proto.dpr = function dpr(_dpr) {
          return this.withOptions(_dpr && _dpr !== 1 ? {
            dpr: _dpr
          } : {});
        };
        _proto.width = function width(_width) {
          return this.withOptions({
            width: _width
          });
        };
        _proto.height = function height(_height) {
          return this.withOptions({
            height: _height
          });
        };
        _proto.focalPoint = function focalPoint(x3, y4) {
          return this.withOptions({
            focalPoint: {
              x: x3,
              y: y4
            }
          });
        };
        _proto.maxWidth = function maxWidth(_maxWidth) {
          return this.withOptions({
            maxWidth: _maxWidth
          });
        };
        _proto.minWidth = function minWidth(_minWidth) {
          return this.withOptions({
            minWidth: _minWidth
          });
        };
        _proto.maxHeight = function maxHeight(_maxHeight) {
          return this.withOptions({
            maxHeight: _maxHeight
          });
        };
        _proto.minHeight = function minHeight(_minHeight) {
          return this.withOptions({
            minHeight: _minHeight
          });
        };
        _proto.size = function size4(width, height) {
          return this.withOptions({
            width,
            height
          });
        };
        _proto.blur = function blur(_blur) {
          return this.withOptions({
            blur: _blur
          });
        };
        _proto.sharpen = function sharpen(_sharpen) {
          return this.withOptions({
            sharpen: _sharpen
          });
        };
        _proto.rect = function rect(left, top, width, height) {
          return this.withOptions({
            rect: {
              left,
              top,
              width,
              height
            }
          });
        };
        _proto.format = function format4(_format) {
          return this.withOptions({
            format: _format
          });
        };
        _proto.invert = function invert2(_invert) {
          return this.withOptions({
            invert: _invert
          });
        };
        _proto.orientation = function orientation(_orientation) {
          return this.withOptions({
            orientation: _orientation
          });
        };
        _proto.quality = function quality(_quality) {
          return this.withOptions({
            quality: _quality
          });
        };
        _proto.forceDownload = function forceDownload(download) {
          return this.withOptions({
            download
          });
        };
        _proto.flipHorizontal = function flipHorizontal() {
          return this.withOptions({
            flipHorizontal: true
          });
        };
        _proto.flipVertical = function flipVertical() {
          return this.withOptions({
            flipVertical: true
          });
        };
        _proto.ignoreImageParams = function ignoreImageParams() {
          return this.withOptions({
            ignoreImageParams: true
          });
        };
        _proto.fit = function fit2(value) {
          if (validFits.indexOf(value) === -1) {
            throw new Error('Invalid fit mode "' + value + '"');
          }
          return this.withOptions({
            fit: value
          });
        };
        _proto.crop = function crop(value) {
          if (validCrops.indexOf(value) === -1) {
            throw new Error('Invalid crop mode "' + value + '"');
          }
          return this.withOptions({
            crop: value
          });
        };
        _proto.saturation = function saturation(_saturation) {
          return this.withOptions({
            saturation: _saturation
          });
        };
        _proto.auto = function auto(value) {
          if (validAutoModes.indexOf(value) === -1) {
            throw new Error('Invalid auto mode "' + value + '"');
          }
          return this.withOptions({
            auto: value
          });
        };
        _proto.pad = function pad(_pad) {
          return this.withOptions({
            pad: _pad
          });
        };
        _proto.url = function url() {
          return urlForImage(this.options);
        };
        _proto.toString = function toString2() {
          return this.url();
        };
        return ImageUrlBuilder2;
      }();
      return urlBuilder;
    });
  }
});

// node_modules/@sanity/asset-utils/dist/asset-utils.esm.js
var asset_utils_esm_exports = {};
__export(asset_utils_esm_exports, {
  DEFAULT_CROP: () => DEFAULT_CROP,
  DEFAULT_HOTSPOT: () => DEFAULT_HOTSPOT,
  buildFilePath: () => buildFilePath,
  buildFileUrl: () => buildFileUrl,
  buildImagePath: () => buildImagePath,
  buildImageUrl: () => buildImageUrl,
  getAssetDocumentId: () => getAssetDocumentId,
  getAssetUrlType: () => getAssetUrlType,
  getDefaultCrop: () => getDefaultCrop,
  getDefaultHotspot: () => getDefaultHotspot,
  getExtension: () => getExtension,
  getFile: () => getFile,
  getFileAsset: () => getFileAsset,
  getIdFromString: () => getIdFromString,
  getImage: () => getImage,
  getImageAsset: () => getImageAsset,
  getImageDimensions: () => getImageDimensions,
  getProject: () => getProject,
  getUrlFilename: () => getUrlFilename,
  getUrlPath: () => getUrlPath,
  isAssetFilename: () => isAssetFilename,
  isAssetId: () => isAssetId,
  isAssetIdStub: () => isAssetIdStub,
  isAssetObjectStub: () => isAssetObjectStub,
  isAssetPathStub: () => isAssetPathStub,
  isAssetUrlStub: () => isAssetUrlStub,
  isDefaultCrop: () => isDefaultCrop,
  isDefaultHotspot: () => isDefaultHotspot,
  isFileAssetFilename: () => isFileAssetFilename,
  isFileAssetId: () => isFileAssetId,
  isFileSource: () => isFileSource,
  isImageAssetFilename: () => isImageAssetFilename,
  isImageAssetId: () => isImageAssetId,
  isImageSource: () => isImageSource,
  isObject: () => isObject,
  isReference: () => isReference,
  isSanityAssetUrl: () => isSanityAssetUrl,
  isSanityFileAsset: () => isSanityFileAsset,
  isSanityFileUrl: () => isSanityFileUrl,
  isSanityImageAsset: () => isSanityImageAsset,
  isSanityImageUrl: () => isSanityImageUrl,
  isValidFilename: () => isValidFilename,
  parseAssetFilename: () => parseAssetFilename,
  parseAssetId: () => parseAssetId,
  parseAssetUrl: () => parseAssetUrl,
  parseFileAssetId: () => parseFileAssetId,
  parseFileAssetUrl: () => parseFileAssetUrl,
  parseImageAssetId: () => parseImageAssetId,
  parseImageAssetUrl: () => parseImageAssetUrl,
  tryGetAssetDocumentId: () => tryGetAssetDocumentId,
  tryGetAssetPath: () => tryGetAssetPath,
  tryGetExtension: () => tryGetExtension,
  tryGetFile: () => tryGetFile,
  tryGetFileAsset: () => tryGetFileAsset,
  tryGetIdFromString: () => tryGetIdFromString,
  tryGetImage: () => tryGetImage,
  tryGetImageAsset: () => tryGetImageAsset,
  tryGetImageDimensions: () => tryGetImageDimensions,
  tryGetProject: () => tryGetProject,
  tryGetUrlFilename: () => tryGetUrlFilename,
  tryGetUrlPath: () => tryGetUrlPath
});
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _getPrototypeOf2(o4) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf3(o5) {
    return o5.__proto__ || Object.getPrototypeOf(o5);
  };
  return _getPrototypeOf2(o4);
}
function _setPrototypeOf2(o4, p2) {
  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o5, p3) {
    o5.__proto__ = p3;
    return o5;
  };
  return _setPrototypeOf2(o4, p2);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e5) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct3(Parent2, args2, Class2) {
      var a5 = [null];
      a5.push.apply(a5, args2);
      var Constructor = Function.bind.apply(Parent2, a5);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf2(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function isUnresolvableError(err) {
  var error = err;
  return Boolean(error.unresolvable && "input" in error);
}
function getForgivingResolver(method) {
  return function() {
    try {
      return method.apply(void 0, arguments);
    } catch (err) {
      if (isUnresolvableError(err)) {
        return void 0;
      }
      throw err;
    }
  };
}
function isReference(ref) {
  return isObject(ref) && typeof ref._ref === "string";
}
function isAssetIdStub(stub) {
  return isObject(stub) && typeof stub._id === "string";
}
function isAssetPathStub(stub) {
  return isObject(stub) && typeof stub.path === "string";
}
function isAssetUrlStub(stub) {
  return isObject(stub) && typeof stub.url === "string";
}
function isSanityFileAsset(src) {
  return isObject(src) && src._type === "sanity.fileAsset";
}
function isSanityImageAsset(src) {
  return isObject(src) && src._type === "sanity.imageAsset";
}
function isImageAssetId(documentId) {
  return imageAssetIdPattern.test(documentId);
}
function isFileAssetId(documentId) {
  return fileAssetIdPattern.test(documentId);
}
function isAssetId(documentId) {
  return isImageAssetId(documentId) || isFileAssetId(documentId);
}
function isAssetObjectStub(stub) {
  var item = stub;
  return isObject(item) && item.asset && typeof item.asset === "object";
}
function isObject(obj) {
  return obj !== null && !Array.isArray(obj) && typeof obj === "object";
}
function buildImagePath(asset, options) {
  var projectId = (options == null ? void 0 : options.projectId) || asset.projectId;
  var dataset = (options == null ? void 0 : options.dataset) || asset.dataset;
  if (!projectId || !dataset) {
    throw new Error("Project details (projectId and dataset) required to resolve path for image");
  }
  var dimensions = "metadata" in asset ? asset.metadata.dimensions : {
    width: asset.width,
    height: asset.height
  };
  var originalFilename = "originalFilename" in asset ? asset.originalFilename : void 0;
  var assetId = asset.assetId, extension = asset.extension, vanityFilename = asset.vanityFilename;
  var width = dimensions.width, height = dimensions.height;
  var vanity = getVanityStub(originalFilename, vanityFilename, options);
  return "images/" + projectId + "/" + dataset + "/" + assetId + "-" + width + "x" + height + "." + extension + vanity;
}
function buildImageUrl(asset, options) {
  return cdnUrl + "/" + buildImagePath(asset, options);
}
function buildFilePath(asset, options) {
  var projectId = (options == null ? void 0 : options.projectId) || asset.projectId;
  var dataset = (options == null ? void 0 : options.dataset) || asset.dataset;
  if (!projectId || !dataset) {
    throw new Error("Project details (projectId and dataset) required to resolve path for file");
  }
  var originalFilename = "originalFilename" in asset ? asset.originalFilename : void 0;
  var assetId = asset.assetId, extension = asset.extension, vanityFilename = asset.vanityFilename;
  var vanity = getVanityStub(originalFilename, vanityFilename, options);
  return "files/" + projectId + "/" + dataset + "/" + assetId + "." + extension + vanity;
}
function buildFileUrl(asset, project) {
  return cdnUrl + "/" + buildFilePath(asset, project);
}
function hasPath(urlOrPath) {
  return pathPattern.test(tryGetUrlPath(urlOrPath) || "");
}
function tryGetAssetPath(src) {
  if (isAssetObjectStub(src)) {
    return tryGetAssetPath(src.asset);
  }
  if (isReference(src)) {
    return void 0;
  }
  if (typeof src === "string") {
    return hasPath(src) ? getUrlPath(src) : void 0;
  }
  if (isAssetPathStub(src)) {
    return src.path;
  }
  if (isAssetUrlStub(src)) {
    return getUrlPath(src.url);
  }
  return void 0;
}
function getUrlPath(url) {
  if (pathPattern.test(url)) {
    return url;
  }
  if (!url.startsWith(cdnUrl + "/")) {
    throw new UnresolvableError('Failed to resolve path from URL "' + url + '"');
  }
  var qsPos = url.indexOf("?");
  var toIndex = qsPos === -1 ? void 0 : qsPos;
  return url.slice(cdnUrl.length + 1, toIndex);
}
function getUrlFilename(url) {
  var path3 = tryGetUrlPath(url) || url;
  var filename = path3.replace(/^(images|files)\/[a-z0-9]+\/[a-z0-9][-\w]\/*/, "");
  if (!isValidFilename(filename)) {
    throw new UnresolvableError('Failed to resolve filename from URL "' + url + '"');
  }
  return filename;
}
function isValidFilename(filename) {
  return fileAssetFilenamePattern.test(filename) || imageAssetFilenamePattern.test(filename);
}
function getVanityStub(originalFilename, vanityFilename, options) {
  var vanity = vanityFilename || originalFilename;
  return (options == null ? void 0 : options.useVanityName) === false || !vanity ? "" : "/" + vanity;
}
function parseAssetId(documentId) {
  if (imageAssetIdPattern.test(documentId)) {
    return parseImageAssetId(documentId);
  }
  if (fileAssetIdPattern.test(documentId)) {
    return parseFileAssetId(documentId);
  }
  throw new Error("Invalid image/file asset ID: " + documentId);
}
function parseFileAssetId(documentId) {
  if (!fileAssetIdPattern.test(documentId)) {
    throw new Error("Malformed file asset ID '" + documentId + `'. Expected an id like "` + exampleFileId + '"');
  }
  var _documentId$split = documentId.split("-"), assetId = _documentId$split[1], extension = _documentId$split[2];
  return {
    type: "file",
    assetId,
    extension
  };
}
function parseImageAssetId(documentId) {
  var _documentId$split2 = documentId.split("-"), assetId = _documentId$split2[1], dimensionString = _documentId$split2[2], extension = _documentId$split2[3];
  var _split$map = (dimensionString || "").split("x").map(Number), width = _split$map[0], height = _split$map[1];
  if (!assetId || !dimensionString || !extension || !(width > 0) || !(height > 0)) {
    throw new Error("Malformed asset ID '" + documentId + `'. Expected an id like "` + exampleImageId + '".');
  }
  return {
    type: "image",
    assetId,
    width,
    height,
    extension
  };
}
function parseAssetFilename(filename) {
  var file = tryGetUrlFilename(filename) || "";
  if (!isValidFilename(file)) {
    throw new Error("Invalid image/file asset filename: " + filename);
  }
  try {
    var type = imageAssetFilenamePattern.test(file) ? "image" : "file";
    var assetId = file.replace(/\.([a-z0-9+]+)$/i, "-$1");
    return parseAssetId(type + "-" + assetId);
  } catch (err) {
    throw new Error("Invalid image/file asset filename: " + filename);
  }
}
function parseAssetUrl(url) {
  if (!url.startsWith(cdnUrl)) {
    throw new Error("URL is not a valid Sanity asset URL: " + url);
  }
  var path3 = url.slice(cdnUrl.length).replace(/^\/+/, "");
  var _ref2 = path3.match(pathPattern) || [], projectPath = _ref2[0], projectId = _ref2[2], dataset = _ref2[3];
  if (!projectId || !dataset) {
    throw new Error("URL is not a valid Sanity asset URL: " + url);
  }
  var _path$slice$split = path3.slice(projectPath.length).split("/"), filename = _path$slice$split[0], vanityFilename = _path$slice$split[1];
  var parsed = parseAssetFilename(filename);
  return _extends2({}, parsed, {
    projectId,
    dataset,
    vanityFilename
  });
}
function parseImageAssetUrl(url) {
  var parsed = parseAssetUrl(url);
  if (parsed.type !== "image") {
    throw new Error("URL is not a valid Sanity image asset URL: " + url);
  }
  return parsed;
}
function parseFileAssetUrl(url) {
  var parsed = parseAssetUrl(url);
  if (parsed.type !== "file") {
    throw new Error("URL is not a valid Sanity file asset URL: " + url);
  }
  return parsed;
}
function getAssetUrlType(url) {
  try {
    return parseAssetUrl(url).type;
  } catch (err) {
    return false;
  }
}
function getImageDimensions(src) {
  var imageId = getAssetDocumentId(src);
  var _parseImageAssetId = parseImageAssetId(imageId), width = _parseImageAssetId.width, height = _parseImageAssetId.height;
  var aspectRatio = width / height;
  return {
    width,
    height,
    aspectRatio
  };
}
function getExtension(src) {
  return isFileSource(src) ? getFile(src, dummyProject).asset.extension : getImage(src, dummyProject).asset.extension;
}
function getImage(src, project) {
  var projectDetails = project || tryGetProject(src);
  var asset = getImageAsset(src, projectDetails);
  var img = src;
  return {
    asset,
    crop: img.crop || getDefaultCrop(),
    hotspot: img.hotspot || getDefaultHotspot()
  };
}
function getImageAsset(src, project) {
  var projectDetails = project || getProject(src);
  var pathOptions = _extends2({}, projectDetails, {
    useVanityName: false
  });
  var _id = getAssetDocumentId(src);
  var sourceObj = src;
  var source = sourceObj.asset || src;
  var metadata = source.metadata || {};
  var _parseImageAssetId2 = parseImageAssetId(_id), assetId = _parseImageAssetId2.assetId, width = _parseImageAssetId2.width, height = _parseImageAssetId2.height, extension = _parseImageAssetId2.extension;
  var aspectRatio = width / height;
  var baseAsset = _extends2({}, isSanityImageAsset(src) ? src : {}, {
    _id,
    _type: "sanity.imageAsset",
    assetId,
    extension,
    metadata: _extends2({}, metadata, {
      dimensions: {
        width,
        height,
        aspectRatio
      }
    }),
    // Placeholders, overwritten below
    url: "",
    path: ""
  });
  return _extends2({}, baseAsset, {
    path: buildImagePath(baseAsset, pathOptions),
    url: buildImageUrl(baseAsset, pathOptions)
  });
}
function getFile(src, project) {
  var projectDetails = project || tryGetProject(src);
  var asset = getFileAsset(src, projectDetails);
  return {
    asset
  };
}
function getFileAsset(src, options) {
  var projectDetails = _extends2({}, options || getProject(src), {
    useVanityName: false
  });
  var _id = getAssetDocumentId(src);
  var sourceObj = src;
  var source = sourceObj.asset || src;
  var _parseFileAssetId = parseFileAssetId(_id), assetId = _parseFileAssetId.assetId, extension = _parseFileAssetId.extension;
  var baseAsset = _extends2({}, isSanityFileAsset(src) ? src : {}, {
    _id,
    _type: "sanity.fileAsset",
    assetId,
    extension,
    metadata: source.metadata || {},
    // Placeholders, overwritten below
    url: "",
    path: ""
  });
  return _extends2({}, baseAsset, {
    path: buildFilePath(baseAsset, projectDetails),
    url: buildFileUrl(baseAsset, projectDetails)
  });
}
function getAssetDocumentId(src) {
  var source = isAssetObjectStub(src) ? src.asset : src;
  var id2 = "";
  if (typeof source === "string") {
    id2 = getIdFromString(source);
  } else if (isReference(source)) {
    id2 = source._ref;
  } else if (isAssetIdStub(source)) {
    id2 = source._id;
  } else if (isAssetPathStub(source)) {
    id2 = idFromUrl(cdnUrl + "/" + source.path);
  } else if (isAssetUrlStub(source)) {
    id2 = idFromUrl(source.url);
  }
  var hasId = id2 && idPattern.test(id2);
  if (!hasId) {
    throw new UnresolvableError(src);
  }
  return id2;
}
function getIdFromString(str) {
  if (idPattern.test(str)) {
    return str;
  }
  if (str.indexOf(cdnUrl + "/images") === 0 || str.indexOf(cdnUrl + "/files") === 0) {
    return idFromUrl(str);
  }
  if (pathPattern.test(str)) {
    return idFromUrl(cdnUrl + "/" + str);
  }
  if (isFileAssetFilename(str)) {
    return idFromUrl(cdnUrl + "/files/a/b/" + str);
  }
  if (isImageAssetFilename(str)) {
    return idFromUrl(cdnUrl + "/images/a/b/" + str);
  }
  throw new UnresolvableError(str);
}
function idFromUrl(url) {
  var path3 = getUrlPath(url);
  var _path$split = path3.split("/"), type = _path$split[0], fileName = _path$split[3];
  var prefix2 = type.replace(/s$/, "");
  return prefix2 + "-" + fileName.replace(/\./g, "-");
}
function getProject(src) {
  var path3 = tryGetAssetPath(src);
  if (!path3) {
    throw new UnresolvableError(src, "Failed to resolve project ID and dataset from source");
  }
  var _ref2 = path3.match(pathPattern) || [], projectId = _ref2[2], dataset = _ref2[3];
  if (!projectId || !dataset) {
    throw new UnresolvableError(src, "Failed to resolve project ID and dataset from source");
  }
  return {
    projectId,
    dataset
  };
}
function isImageAssetFilename(filename) {
  return imageAssetFilenamePattern.test(filename);
}
function isFileAssetFilename(filename) {
  return fileAssetFilenamePattern.test(filename);
}
function isAssetFilename(filename) {
  return isImageAssetFilename(filename) || isFileAssetFilename(filename);
}
function isFileSource(src) {
  var assetId = tryGetAssetDocumentId(src);
  return assetId ? assetId.startsWith("file-") : false;
}
function isImageSource(src) {
  var assetId = tryGetAssetDocumentId(src);
  return assetId ? assetId.startsWith("image-") : false;
}
function isSanityAssetUrl(url) {
  return getAssetUrlType(url) !== false;
}
function isSanityImageUrl(url) {
  return getAssetUrlType(url) === "image";
}
function isSanityFileUrl(url) {
  return getAssetUrlType(url) === "file";
}
var DEFAULT_CROP, DEFAULT_HOTSPOT, getDefaultCrop, getDefaultHotspot, isDefaultCrop, isDefaultHotspot, UnresolvableError, cdnUrl, fileAssetFilenamePattern, fileAssetIdPattern, imageAssetFilenamePattern, imageAssetIdPattern, pathPattern, idPattern, dummyProject, tryGetUrlPath, tryGetUrlFilename, exampleFileId, exampleImageId, tryGetImageDimensions, tryGetExtension, tryGetImage, tryGetImageAsset, tryGetFile, tryGetFileAsset, tryGetAssetDocumentId, tryGetIdFromString, tryGetProject;
var init_asset_utils_esm = __esm({
  "node_modules/@sanity/asset-utils/dist/asset-utils.esm.js"() {
    DEFAULT_CROP = Object.freeze({
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    });
    DEFAULT_HOTSPOT = Object.freeze({
      x: 0.5,
      y: 0.5,
      height: 1,
      width: 1
    });
    getDefaultCrop = function getDefaultCrop2() {
      return _extends2({}, DEFAULT_CROP);
    };
    getDefaultHotspot = function getDefaultHotspot2() {
      return _extends2({}, DEFAULT_HOTSPOT);
    };
    isDefaultCrop = function isDefaultCrop2(crop) {
      var top = crop.top, bottom = crop.bottom, left = crop.left, right = crop.right;
      var defaultTop = DEFAULT_CROP.top, defaultBottom = DEFAULT_CROP.bottom, defaultLeft = DEFAULT_CROP.left, defaultRight = DEFAULT_CROP.right;
      return top === defaultTop && bottom === defaultBottom && left === defaultLeft && right === defaultRight;
    };
    isDefaultHotspot = function isDefaultHotspot2(hotspot) {
      var x3 = hotspot.x, y4 = hotspot.y, width = hotspot.width, height = hotspot.height;
      var defaultX = DEFAULT_HOTSPOT.x, defaultY = DEFAULT_HOTSPOT.y, defaultWidth = DEFAULT_HOTSPOT.width, defaultHeight = DEFAULT_HOTSPOT.height;
      return x3 === defaultX && y4 === defaultY && width === defaultWidth && height === defaultHeight;
    };
    UnresolvableError = function(_Error) {
      _inheritsLoose2(UnresolvableError2, _Error);
      function UnresolvableError2(inputSource, message) {
        var _this;
        if (message === void 0) {
          message = "Failed to resolve asset ID from source";
        }
        _this = _Error.call(this, message) || this;
        _this.unresolvable = true;
        _this.input = inputSource;
        return _this;
      }
      return UnresolvableError2;
    }(_wrapNativeSuper(Error));
    cdnUrl = "https://cdn.sanity.io";
    fileAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+\.[a-z0-9]+$/;
    fileAssetIdPattern = /^file-([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-[a-z0-9]+$/;
    imageAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})-\d+x\d+\.[a-z0-9]+$/;
    imageAssetIdPattern = /^image-([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-\d+x\d+-[a-z0-9]+$/;
    pathPattern = /^(images|files)\/([a-z0-9]+)\/([a-z0-9][-\w]*)\//;
    idPattern = /^(?:image-(?:[a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-\d+x\d+-[a-z0-9]+|file-(?:[a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-[a-z0-9]+)$/;
    dummyProject = {
      projectId: "a",
      dataset: "b"
    };
    tryGetUrlPath = getForgivingResolver(getUrlPath);
    tryGetUrlFilename = getForgivingResolver(getUrlFilename);
    exampleFileId = "file-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-pdf";
    exampleImageId = "image-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-2000x3000-jpg";
    tryGetImageDimensions = getForgivingResolver(getImageDimensions);
    tryGetExtension = getForgivingResolver(getExtension);
    tryGetImage = getForgivingResolver(getImage);
    tryGetImageAsset = getForgivingResolver(getImageAsset);
    tryGetFile = getForgivingResolver(getFile);
    tryGetFileAsset = getForgivingResolver(getFileAsset);
    tryGetAssetDocumentId = getForgivingResolver(getAssetDocumentId);
    tryGetIdFromString = getForgivingResolver(getIdFromString);
    tryGetProject = getForgivingResolver(getProject);
  }
});

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module2) {
    var toString2 = require_toString();
    var idCounter = 0;
    function uniqueId(prefix2) {
      var id2 = ++idCounter;
      return toString2(prefix2) + id2;
    }
    module2.exports = uniqueId;
  }
});

// node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/lodash/compact.js"(exports, module2) {
    function compact(array) {
      var index3 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index3 < length2) {
        var value = array[index3];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = compact;
  }
});

// node_modules/lodash/keyBy.js
var require_keyBy = __commonJS({
  "node_modules/lodash/keyBy.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var keyBy = createAggregator(function(result, value, key2) {
      baseAssignValue(result, key2, value);
    });
    module2.exports = keyBy;
  }
});

// node_modules/lodash/toLower.js
var require_toLower = __commonJS({
  "node_modules/lodash/toLower.js"(exports, module2) {
    var toString2 = require_toString();
    function toLower(value) {
      return toString2(value).toLowerCase();
    }
    module2.exports = toLower;
  }
});

// node_modules/lodash/union.js
var require_union = __commonJS({
  "node_modules/lodash/union.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module2.exports = union;
  }
});

// node_modules/lodash/_baseLodash.js
var require_baseLodash = __commonJS({
  "node_modules/lodash/_baseLodash.js"(exports, module2) {
    function baseLodash() {
    }
    module2.exports = baseLodash;
  }
});

// node_modules/lodash/_LodashWrapper.js
var require_LodashWrapper = __commonJS({
  "node_modules/lodash/_LodashWrapper.js"(exports, module2) {
    var baseCreate = require_baseCreate();
    var baseLodash = require_baseLodash();
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = void 0;
    }
    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;
    module2.exports = LodashWrapper;
  }
});

// node_modules/lodash/_metaMap.js
var require_metaMap = __commonJS({
  "node_modules/lodash/_metaMap.js"(exports, module2) {
    var WeakMap2 = require_WeakMap();
    var metaMap = WeakMap2 && new WeakMap2();
    module2.exports = metaMap;
  }
});

// node_modules/lodash/_getData.js
var require_getData = __commonJS({
  "node_modules/lodash/_getData.js"(exports, module2) {
    var metaMap = require_metaMap();
    var noop3 = require_noop();
    var getData = !metaMap ? noop3 : function(func2) {
      return metaMap.get(func2);
    };
    module2.exports = getData;
  }
});

// node_modules/lodash/_realNames.js
var require_realNames = __commonJS({
  "node_modules/lodash/_realNames.js"(exports, module2) {
    var realNames = {};
    module2.exports = realNames;
  }
});

// node_modules/lodash/_getFuncName.js
var require_getFuncName = __commonJS({
  "node_modules/lodash/_getFuncName.js"(exports, module2) {
    var realNames = require_realNames();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function getFuncName(func2) {
      var result = func2.name + "", array = realNames[result], length2 = hasOwnProperty.call(realNames, result) ? array.length : 0;
      while (length2--) {
        var data = array[length2], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func2) {
          return data.name;
        }
      }
      return result;
    }
    module2.exports = getFuncName;
  }
});

// node_modules/lodash/_LazyWrapper.js
var require_LazyWrapper = __commonJS({
  "node_modules/lodash/_LazyWrapper.js"(exports, module2) {
    var baseCreate = require_baseCreate();
    var baseLodash = require_baseLodash();
    var MAX_ARRAY_LENGTH = 4294967295;
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;
    module2.exports = LazyWrapper;
  }
});

// node_modules/lodash/_wrapperClone.js
var require_wrapperClone = __commonJS({
  "node_modules/lodash/_wrapperClone.js"(exports, module2) {
    var LazyWrapper = require_LazyWrapper();
    var LodashWrapper = require_LodashWrapper();
    var copyArray = require_copyArray();
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__ = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }
    module2.exports = wrapperClone;
  }
});

// node_modules/lodash/wrapperLodash.js
var require_wrapperLodash = __commonJS({
  "node_modules/lodash/wrapperLodash.js"(exports, module2) {
    var LazyWrapper = require_LazyWrapper();
    var LodashWrapper = require_LodashWrapper();
    var baseLodash = require_baseLodash();
    var isArray5 = require_isArray();
    var isObjectLike = require_isObjectLike();
    var wrapperClone = require_wrapperClone();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function lodash(value) {
      if (isObjectLike(value) && !isArray5(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, "__wrapped__")) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;
    module2.exports = lodash;
  }
});

// node_modules/lodash/_isLaziable.js
var require_isLaziable = __commonJS({
  "node_modules/lodash/_isLaziable.js"(exports, module2) {
    var LazyWrapper = require_LazyWrapper();
    var getData = require_getData();
    var getFuncName = require_getFuncName();
    var lodash = require_wrapperLodash();
    function isLaziable(func2) {
      var funcName = getFuncName(func2), other = lodash[funcName];
      if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func2 === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func2 === data[0];
    }
    module2.exports = isLaziable;
  }
});

// node_modules/lodash/_createFlow.js
var require_createFlow = __commonJS({
  "node_modules/lodash/_createFlow.js"(exports, module2) {
    var LodashWrapper = require_LodashWrapper();
    var flatRest = require_flatRest();
    var getData = require_getData();
    var getFuncName = require_getFuncName();
    var isArray5 = require_isArray();
    var isLaziable = require_isLaziable();
    var FUNC_ERROR_TEXT = "Expected a function";
    var WRAP_CURRY_FLAG = 8;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_ARY_FLAG = 128;
    var WRAP_REARG_FLAG = 256;
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length2 = funcs.length, index3 = length2, prereq = LodashWrapper.prototype.thru;
        if (fromRight) {
          funcs.reverse();
        }
        while (index3--) {
          var func2 = funcs[index3];
          if (typeof func2 != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index3 = wrapper ? index3 : length2;
        while (++index3 < length2) {
          func2 = funcs[index3];
          var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : void 0;
          if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
          }
        }
        return function() {
          var args = arguments, value = args[0];
          if (wrapper && args.length == 1 && isArray5(value)) {
            return wrapper.plant(value).value();
          }
          var index4 = 0, result = length2 ? funcs[index4].apply(this, args) : value;
          while (++index4 < length2) {
            result = funcs[index4].call(this, result);
          }
          return result;
        };
      });
    }
    module2.exports = createFlow;
  }
});

// node_modules/lodash/flow.js
var require_flow = __commonJS({
  "node_modules/lodash/flow.js"(exports, module2) {
    var createFlow = require_createFlow();
    var flow = createFlow();
    module2.exports = flow;
  }
});

// node_modules/lodash/_charsEndIndex.js
var require_charsEndIndex = __commonJS({
  "node_modules/lodash/_charsEndIndex.js"(exports, module2) {
    var baseIndexOf = require_baseIndexOf();
    function charsEndIndex(strSymbols, chrSymbols) {
      var index3 = strSymbols.length;
      while (index3-- && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
      }
      return index3;
    }
    module2.exports = charsEndIndex;
  }
});

// node_modules/lodash/_charsStartIndex.js
var require_charsStartIndex = __commonJS({
  "node_modules/lodash/_charsStartIndex.js"(exports, module2) {
    var baseIndexOf = require_baseIndexOf();
    function charsStartIndex(strSymbols, chrSymbols) {
      var index3 = -1, length2 = strSymbols.length;
      while (++index3 < length2 && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
      }
      return index3;
    }
    module2.exports = charsStartIndex;
  }
});

// node_modules/lodash/trim.js
var require_trim = __commonJS({
  "node_modules/lodash/trim.js"(exports, module2) {
    var baseToString = require_baseToString();
    var baseTrim = require_baseTrim();
    var castSlice = require_castSlice();
    var charsEndIndex = require_charsEndIndex();
    var charsStartIndex = require_charsStartIndex();
    var stringToArray = require_stringToArray();
    var toString2 = require_toString();
    function trim2(string4, chars, guard3) {
      string4 = toString2(string4);
      if (string4 && (guard3 || chars === void 0)) {
        return baseTrim(string4);
      }
      if (!string4 || !(chars = baseToString(chars))) {
        return string4;
      }
      var strSymbols = stringToArray(string4), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
      return castSlice(strSymbols, start2, end2).join("");
    }
    module2.exports = trim2;
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify2(arr) {
  var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset3 + 0]] + byteToHex[arr[offset3 + 1]] + byteToHex[arr[offset3 + 2]] + byteToHex[arr[offset3 + 3]] + "-" + byteToHex[arr[offset3 + 4]] + byteToHex[arr[offset3 + 5]] + "-" + byteToHex[arr[offset3 + 6]] + byteToHex[arr[offset3 + 7]] + "-" + byteToHex[arr[offset3 + 8]] + byteToHex[arr[offset3 + 9]] + "-" + byteToHex[arr[offset3 + 10]] + byteToHex[arr[offset3 + 11]] + byteToHex[arr[offset3 + 12]] + byteToHex[arr[offset3 + 13]] + byteToHex[arr[offset3 + 14]] + byteToHex[arr[offset3 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i4, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i4 = 0; i4 < 256; ++i4) {
      byteToHex.push((i4 + 256).toString(16).substr(1));
    }
    stringify_default = stringify2;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset3) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset3 = offset3 || 0;
    for (var i4 = 0; i4 < 16; ++i4) {
      buf[offset3 + i4] = rnds[i4];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse3(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default;
var init_parse2 = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse3;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    bytes.push(str.charCodeAt(i4));
  }
  return bytes;
}
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset3) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset3 = offset3 || 0;
      for (var i4 = 0; i4 < 16; ++i4) {
        buf[offset3 + i4] = bytes[i4];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse2();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg2 = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg2.length);
    for (var i4 = 0; i4 < msg2.length; ++i4) {
      bytes[i4] = msg2.charCodeAt(i4);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i4 = 0; i4 < length32; i4 += 8) {
    var x3 = input[i4 >> 5] >>> i4 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x3, len) {
  x3[len >> 5] |= 128 << len % 32;
  x3[getOutputLength(len) - 1] = len;
  var a5 = 1732584193;
  var b3 = -271733879;
  var c4 = -1732584194;
  var d3 = 271733878;
  for (var i4 = 0; i4 < x3.length; i4 += 16) {
    var olda = a5;
    var oldb = b3;
    var oldc = c4;
    var oldd = d3;
    a5 = md5ff(a5, b3, c4, d3, x3[i4], 7, -680876936);
    d3 = md5ff(d3, a5, b3, c4, x3[i4 + 1], 12, -389564586);
    c4 = md5ff(c4, d3, a5, b3, x3[i4 + 2], 17, 606105819);
    b3 = md5ff(b3, c4, d3, a5, x3[i4 + 3], 22, -1044525330);
    a5 = md5ff(a5, b3, c4, d3, x3[i4 + 4], 7, -176418897);
    d3 = md5ff(d3, a5, b3, c4, x3[i4 + 5], 12, 1200080426);
    c4 = md5ff(c4, d3, a5, b3, x3[i4 + 6], 17, -1473231341);
    b3 = md5ff(b3, c4, d3, a5, x3[i4 + 7], 22, -45705983);
    a5 = md5ff(a5, b3, c4, d3, x3[i4 + 8], 7, 1770035416);
    d3 = md5ff(d3, a5, b3, c4, x3[i4 + 9], 12, -1958414417);
    c4 = md5ff(c4, d3, a5, b3, x3[i4 + 10], 17, -42063);
    b3 = md5ff(b3, c4, d3, a5, x3[i4 + 11], 22, -1990404162);
    a5 = md5ff(a5, b3, c4, d3, x3[i4 + 12], 7, 1804603682);
    d3 = md5ff(d3, a5, b3, c4, x3[i4 + 13], 12, -40341101);
    c4 = md5ff(c4, d3, a5, b3, x3[i4 + 14], 17, -1502002290);
    b3 = md5ff(b3, c4, d3, a5, x3[i4 + 15], 22, 1236535329);
    a5 = md5gg(a5, b3, c4, d3, x3[i4 + 1], 5, -165796510);
    d3 = md5gg(d3, a5, b3, c4, x3[i4 + 6], 9, -1069501632);
    c4 = md5gg(c4, d3, a5, b3, x3[i4 + 11], 14, 643717713);
    b3 = md5gg(b3, c4, d3, a5, x3[i4], 20, -373897302);
    a5 = md5gg(a5, b3, c4, d3, x3[i4 + 5], 5, -701558691);
    d3 = md5gg(d3, a5, b3, c4, x3[i4 + 10], 9, 38016083);
    c4 = md5gg(c4, d3, a5, b3, x3[i4 + 15], 14, -660478335);
    b3 = md5gg(b3, c4, d3, a5, x3[i4 + 4], 20, -405537848);
    a5 = md5gg(a5, b3, c4, d3, x3[i4 + 9], 5, 568446438);
    d3 = md5gg(d3, a5, b3, c4, x3[i4 + 14], 9, -1019803690);
    c4 = md5gg(c4, d3, a5, b3, x3[i4 + 3], 14, -187363961);
    b3 = md5gg(b3, c4, d3, a5, x3[i4 + 8], 20, 1163531501);
    a5 = md5gg(a5, b3, c4, d3, x3[i4 + 13], 5, -1444681467);
    d3 = md5gg(d3, a5, b3, c4, x3[i4 + 2], 9, -51403784);
    c4 = md5gg(c4, d3, a5, b3, x3[i4 + 7], 14, 1735328473);
    b3 = md5gg(b3, c4, d3, a5, x3[i4 + 12], 20, -1926607734);
    a5 = md5hh(a5, b3, c4, d3, x3[i4 + 5], 4, -378558);
    d3 = md5hh(d3, a5, b3, c4, x3[i4 + 8], 11, -2022574463);
    c4 = md5hh(c4, d3, a5, b3, x3[i4 + 11], 16, 1839030562);
    b3 = md5hh(b3, c4, d3, a5, x3[i4 + 14], 23, -35309556);
    a5 = md5hh(a5, b3, c4, d3, x3[i4 + 1], 4, -1530992060);
    d3 = md5hh(d3, a5, b3, c4, x3[i4 + 4], 11, 1272893353);
    c4 = md5hh(c4, d3, a5, b3, x3[i4 + 7], 16, -155497632);
    b3 = md5hh(b3, c4, d3, a5, x3[i4 + 10], 23, -1094730640);
    a5 = md5hh(a5, b3, c4, d3, x3[i4 + 13], 4, 681279174);
    d3 = md5hh(d3, a5, b3, c4, x3[i4], 11, -358537222);
    c4 = md5hh(c4, d3, a5, b3, x3[i4 + 3], 16, -722521979);
    b3 = md5hh(b3, c4, d3, a5, x3[i4 + 6], 23, 76029189);
    a5 = md5hh(a5, b3, c4, d3, x3[i4 + 9], 4, -640364487);
    d3 = md5hh(d3, a5, b3, c4, x3[i4 + 12], 11, -421815835);
    c4 = md5hh(c4, d3, a5, b3, x3[i4 + 15], 16, 530742520);
    b3 = md5hh(b3, c4, d3, a5, x3[i4 + 2], 23, -995338651);
    a5 = md5ii(a5, b3, c4, d3, x3[i4], 6, -198630844);
    d3 = md5ii(d3, a5, b3, c4, x3[i4 + 7], 10, 1126891415);
    c4 = md5ii(c4, d3, a5, b3, x3[i4 + 14], 15, -1416354905);
    b3 = md5ii(b3, c4, d3, a5, x3[i4 + 5], 21, -57434055);
    a5 = md5ii(a5, b3, c4, d3, x3[i4 + 12], 6, 1700485571);
    d3 = md5ii(d3, a5, b3, c4, x3[i4 + 3], 10, -1894986606);
    c4 = md5ii(c4, d3, a5, b3, x3[i4 + 10], 15, -1051523);
    b3 = md5ii(b3, c4, d3, a5, x3[i4 + 1], 21, -2054922799);
    a5 = md5ii(a5, b3, c4, d3, x3[i4 + 8], 6, 1873313359);
    d3 = md5ii(d3, a5, b3, c4, x3[i4 + 15], 10, -30611744);
    c4 = md5ii(c4, d3, a5, b3, x3[i4 + 6], 15, -1560198380);
    b3 = md5ii(b3, c4, d3, a5, x3[i4 + 13], 21, 1309151649);
    a5 = md5ii(a5, b3, c4, d3, x3[i4 + 4], 6, -145523070);
    d3 = md5ii(d3, a5, b3, c4, x3[i4 + 11], 10, -1120210379);
    c4 = md5ii(c4, d3, a5, b3, x3[i4 + 2], 15, 718787259);
    b3 = md5ii(b3, c4, d3, a5, x3[i4 + 9], 21, -343485551);
    a5 = safeAdd(a5, olda);
    b3 = safeAdd(b3, oldb);
    c4 = safeAdd(c4, oldc);
    d3 = safeAdd(d3, oldd);
  }
  return [a5, b3, c4, d3];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i4 = 0; i4 < length8; i4 += 8) {
    output[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
  }
  return output;
}
function safeAdd(x3, y4) {
  var lsw = (x3 & 65535) + (y4 & 65535);
  var msw = (x3 >> 16) + (y4 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a5, b3, x3, s5, t4) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a5, q3), safeAdd(x3, t4)), s5), b3);
}
function md5ff(a5, b3, c4, d3, x3, s5, t4) {
  return md5cmn(b3 & c4 | ~b3 & d3, a5, b3, x3, s5, t4);
}
function md5gg(a5, b3, c4, d3, x3, s5, t4) {
  return md5cmn(b3 & d3 | c4 & ~d3, a5, b3, x3, s5, t4);
}
function md5hh(a5, b3, c4, d3, x3, s5, t4) {
  return md5cmn(b3 ^ c4 ^ d3, a5, b3, x3, s5, t4);
}
function md5ii(a5, b3, c4, d3, x3, s5, t4) {
  return md5cmn(c4 ^ (b3 | ~d3), a5, b3, x3, s5, t4);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s5, x3, y4, z3) {
  switch (s5) {
    case 0:
      return x3 & y4 ^ ~x3 & z3;
    case 1:
      return x3 ^ y4 ^ z3;
    case 2:
      return x3 & y4 ^ x3 & z3 ^ y4 & z3;
    case 3:
      return x3 ^ y4 ^ z3;
  }
}
function ROTL(x3, n4) {
  return x3 << n4 | x3 >>> 32 - n4;
}
function sha1(bytes) {
  var K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg2 = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i4 = 0; i4 < msg2.length; ++i4) {
      bytes.push(msg2.charCodeAt(i4));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l3 = bytes.length / 4 + 2;
  var N2 = Math.ceil(l3 / 16);
  var M4 = new Array(N2);
  for (var _i = 0; _i < N2; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
    }
    M4[_i] = arr;
  }
  M4[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M4[N2 - 1][14] = Math.floor(M4[N2 - 1][14]);
  M4[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var W2 = new Uint32Array(80);
    for (var t4 = 0; t4 < 16; ++t4) {
      W2[t4] = M4[_i2][t4];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W2[_t] = ROTL(W2[_t - 3] ^ W2[_t - 8] ^ W2[_t - 14] ^ W2[_t - 16], 1);
    }
    var a5 = H4[0];
    var b3 = H4[1];
    var c4 = H4[2];
    var d3 = H4[3];
    var e5 = H4[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s5 = Math.floor(_t2 / 20);
      var T3 = ROTL(a5, 5) + f2(s5, b3, c4, d3) + e5 + K3[s5] + W2[_t2] >>> 0;
      e5 = d3;
      d3 = c4;
      c4 = ROTL(b3, 30) >>> 0;
      b3 = a5;
      a5 = T3;
    }
    H4[0] = H4[0] + a5 >>> 0;
    H4[1] = H4[1] + b3 >>> 0;
    H4[2] = H4[2] + c4 >>> 0;
    H4[3] = H4[3] + d3 >>> 0;
    H4[4] = H4[4] + e5 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
  }
});

// node_modules/uuid/dist/esm-browser/version.js
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse2();
  }
});

// node_modules/@sanity/uuid/lib/esm/uuid.js
var uuid_exports = {};
__export(uuid_exports, {
  uuid: () => v4_default
});
var init_uuid = __esm({
  "node_modules/@sanity/uuid/lib/esm/uuid.js"() {
    init_esm_browser();
  }
});

// node_modules/get-random-values-esm/index.mjs
var get_random_values_esm_exports = {};
__export(get_random_values_esm_exports, {
  default: () => getRandomValues2
});
function getRandomValues2(typedArray) {
  return window.crypto.getRandomValues(typedArray);
}
var init_get_random_values_esm = __esm({
  "node_modules/get-random-values-esm/index.mjs"() {
  }
});

// node_modules/compute-scroll-into-view/dist/index.js
var t3, e3, n2, o2, l2, r3;
var init_dist = __esm({
  "node_modules/compute-scroll-into-view/dist/index.js"() {
    t3 = (t4) => "object" == typeof t4 && null != t4 && 1 === t4.nodeType;
    e3 = (t4, e5) => (!e5 || "hidden" !== t4) && ("visible" !== t4 && "clip" !== t4);
    n2 = (t4, n4) => {
      if (t4.clientHeight < t4.scrollHeight || t4.clientWidth < t4.scrollWidth) {
        const o4 = getComputedStyle(t4, null);
        return e3(o4.overflowY, n4) || e3(o4.overflowX, n4) || ((t5) => {
          const e5 = ((t6) => {
            if (!t6.ownerDocument || !t6.ownerDocument.defaultView)
              return null;
            try {
              return t6.ownerDocument.defaultView.frameElement;
            } catch (t7) {
              return null;
            }
          })(t5);
          return !!e5 && (e5.clientHeight < t5.scrollHeight || e5.clientWidth < t5.scrollWidth);
        })(t4);
      }
      return false;
    };
    o2 = (t4, e5, n4, o4, l3, r4, i4, s5) => r4 < t4 && i4 > e5 || r4 > t4 && i4 < e5 ? 0 : r4 <= t4 && s5 <= n4 || i4 >= e5 && s5 >= n4 ? r4 - t4 - o4 : i4 > e5 && s5 < n4 || r4 < t4 && s5 > n4 ? i4 - e5 + l3 : 0;
    l2 = (t4) => {
      const e5 = t4.parentElement;
      return null == e5 ? t4.getRootNode().host || null : e5;
    };
    r3 = (e5, r4) => {
      var i4, s5, d3, h3;
      if ("undefined" == typeof document)
        return [];
      const { scrollMode: c4, block: f3, inline: u3, boundary: a5, skipOverflowHiddenElements: g2 } = r4, p2 = "function" == typeof a5 ? a5 : (t4) => t4 !== a5;
      if (!t3(e5))
        throw new TypeError("Invalid target");
      const m4 = document.scrollingElement || document.documentElement, w3 = [];
      let W2 = e5;
      for (; t3(W2) && p2(W2); ) {
        if (W2 = l2(W2), W2 === m4) {
          w3.push(W2);
          break;
        }
        null != W2 && W2 === document.body && n2(W2) && !n2(document.documentElement) || null != W2 && n2(W2, g2) && w3.push(W2);
      }
      const b3 = null != (s5 = null == (i4 = window.visualViewport) ? void 0 : i4.width) ? s5 : innerWidth, H4 = null != (h3 = null == (d3 = window.visualViewport) ? void 0 : d3.height) ? h3 : innerHeight, { scrollX: y4, scrollY: M4 } = window, { height: v2, width: E3, top: x3, right: C2, bottom: I3, left: R3 } = e5.getBoundingClientRect(), { top: T3, right: B3, bottom: F2, left: V2 } = ((t4) => {
        const e6 = window.getComputedStyle(t4);
        return { top: parseFloat(e6.scrollMarginTop) || 0, right: parseFloat(e6.scrollMarginRight) || 0, bottom: parseFloat(e6.scrollMarginBottom) || 0, left: parseFloat(e6.scrollMarginLeft) || 0 };
      })(e5);
      let k3 = "start" === f3 || "nearest" === f3 ? x3 - T3 : "end" === f3 ? I3 + F2 : x3 + v2 / 2 - T3 + F2, D3 = "center" === u3 ? R3 + E3 / 2 - V2 + B3 : "end" === u3 ? C2 + B3 : R3 - V2;
      const L3 = [];
      for (let t4 = 0; t4 < w3.length; t4++) {
        const e6 = w3[t4], { height: n4, width: l3, top: r5, right: i5, bottom: s6, left: d4 } = e6.getBoundingClientRect();
        if ("if-needed" === c4 && x3 >= 0 && R3 >= 0 && I3 <= H4 && C2 <= b3 && x3 >= r5 && I3 <= s6 && R3 >= d4 && C2 <= i5)
          return L3;
        const h4 = getComputedStyle(e6), a6 = parseInt(h4.borderLeftWidth, 10), g3 = parseInt(h4.borderTopWidth, 10), p3 = parseInt(h4.borderRightWidth, 10), W3 = parseInt(h4.borderBottomWidth, 10);
        let T4 = 0, B4 = 0;
        const F3 = "offsetWidth" in e6 ? e6.offsetWidth - e6.clientWidth - a6 - p3 : 0, V3 = "offsetHeight" in e6 ? e6.offsetHeight - e6.clientHeight - g3 - W3 : 0, S4 = "offsetWidth" in e6 ? 0 === e6.offsetWidth ? 0 : l3 / e6.offsetWidth : 0, X3 = "offsetHeight" in e6 ? 0 === e6.offsetHeight ? 0 : n4 / e6.offsetHeight : 0;
        if (m4 === e6)
          T4 = "start" === f3 ? k3 : "end" === f3 ? k3 - H4 : "nearest" === f3 ? o2(M4, M4 + H4, H4, g3, W3, M4 + k3, M4 + k3 + v2, v2) : k3 - H4 / 2, B4 = "start" === u3 ? D3 : "center" === u3 ? D3 - b3 / 2 : "end" === u3 ? D3 - b3 : o2(y4, y4 + b3, b3, a6, p3, y4 + D3, y4 + D3 + E3, E3), T4 = Math.max(0, T4 + M4), B4 = Math.max(0, B4 + y4);
        else {
          T4 = "start" === f3 ? k3 - r5 - g3 : "end" === f3 ? k3 - s6 + W3 + V3 : "nearest" === f3 ? o2(r5, s6, n4, g3, W3 + V3, k3, k3 + v2, v2) : k3 - (r5 + n4 / 2) + V3 / 2, B4 = "start" === u3 ? D3 - d4 - a6 : "center" === u3 ? D3 - (d4 + l3 / 2) + F3 / 2 : "end" === u3 ? D3 - i5 + p3 + F3 : o2(d4, i5, l3, a6, p3 + F3, D3, D3 + E3, E3);
          const { scrollLeft: t5, scrollTop: h5 } = e6;
          T4 = 0 === X3 ? 0 : Math.max(0, Math.min(h5 + T4 / X3, e6.scrollHeight - n4 / X3 + V3)), B4 = 0 === S4 ? 0 : Math.max(0, Math.min(t5 + B4 / S4, e6.scrollWidth - l3 / S4 + F3)), k3 += h5 - T4, D3 += t5 - B4;
        }
        L3.push({ el: e6, top: T4, left: B4 });
      }
      return L3;
    };
  }
});

// node_modules/scroll-into-view-if-needed/dist/index.js
function e4(e5, r4) {
  if (!e5.isConnected || !((t4) => {
    let o4 = t4;
    for (; o4 && o4.parentNode; ) {
      if (o4.parentNode === document)
        return true;
      o4 = o4.parentNode instanceof ShadowRoot ? o4.parentNode.host : o4.parentNode;
    }
    return false;
  })(e5))
    return;
  const n4 = ((t4) => {
    const o4 = window.getComputedStyle(t4);
    return { top: parseFloat(o4.scrollMarginTop) || 0, right: parseFloat(o4.scrollMarginRight) || 0, bottom: parseFloat(o4.scrollMarginBottom) || 0, left: parseFloat(o4.scrollMarginLeft) || 0 };
  })(e5);
  if (((t4) => "object" == typeof t4 && "function" == typeof t4.behavior)(r4))
    return r4.behavior(r3(e5, r4));
  const l3 = "boolean" == typeof r4 || null == r4 ? void 0 : r4.behavior;
  for (const { el: a5, top: i4, left: s5 } of r3(e5, o3(r4))) {
    const t4 = i4 - n4.top + n4.bottom, o4 = s5 - n4.left + n4.right;
    a5.scroll({ top: t4, left: o4, behavior: l3 });
  }
}
var o3;
var init_dist2 = __esm({
  "node_modules/scroll-into-view-if-needed/dist/index.js"() {
    init_dist();
    o3 = (t4) => false === t4 ? { block: "end", inline: "nearest" } : ((t5) => t5 === Object(t5) && 0 !== Object.keys(t5).length)(t4) ? t4 : { block: "start", inline: "nearest" };
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module2) {
    var toFinite = require_toFinite();
    function toInteger2(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger2;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger2 = require_toInteger();
    var nativeMax = Math.max;
    function findIndex3(array, predicate, fromIndex) {
      var length2 = array == null ? 0 : array.length;
      if (!length2) {
        return -1;
      }
      var index3 = fromIndex == null ? 0 : toInteger2(fromIndex);
      if (index3 < 0) {
        index3 = nativeMax(length2 + index3, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index3);
    }
    module2.exports = findIndex3;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone2(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module2.exports = clone2;
  }
});

// node_modules/is-hotkey/lib/index.js
var require_lib = __commonJS({
  "node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f3 = 1; f3 < 20; f3++) {
      CODES["f" + f3] = 111 + f3;
    }
    var f3;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string4) {
        return parseHotkey(string4, options);
      });
      var check = function check2(e5) {
        return array.some(function(object2) {
          return compareHotkey(object2, e5);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values = hotkey.split("+");
      var length2 = values.length;
      for (var k3 in MODIFIERS) {
        ret[MODIFIERS[k3]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var optional = value.endsWith("?") && value.length > 1;
          if (optional) {
            value = value.slice(0, -1);
          }
          var name = toKeyName(value);
          var modifier = MODIFIERS[name];
          if (length2 === 1 || !modifier) {
            if (byKey) {
              ret.key = name;
            } else {
              ret.which = toKeyCode(value);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key2 in object2) {
        var expected = object2[key2];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key2 === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key2 === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key2];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name) {
      name = toKeyName(name);
      var code = CODES[name] || name.toUpperCase().charCodeAt(0);
      return code;
    }
    function toKeyName(name) {
      name = name.toLowerCase();
      name = ALIASES[name] || name;
      return name;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/lodash/orderBy.js
var require_orderBy = __commonJS({
  "node_modules/lodash/orderBy.js"(exports, module2) {
    var baseOrderBy = require_baseOrderBy();
    var isArray5 = require_isArray();
    function orderBy(collection, iteratees, orders, guard3) {
      if (collection == null) {
        return [];
      }
      if (!isArray5(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard3 ? void 0 : orders;
      if (!isArray5(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }
    module2.exports = orderBy;
  }
});

// node_modules/lodash/_baseXor.js
var require_baseXor = __commonJS({
  "node_modules/lodash/_baseXor.js"(exports, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseUniq = require_baseUniq();
    function baseXor(arrays, iteratee, comparator) {
      var length2 = arrays.length;
      if (length2 < 2) {
        return length2 ? baseUniq(arrays[0]) : [];
      }
      var index3 = -1, result = Array(length2);
      while (++index3 < length2) {
        var array = arrays[index3], othIndex = -1;
        while (++othIndex < length2) {
          if (othIndex != index3) {
            result[index3] = baseDifference(result[index3] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }
    module2.exports = baseXor;
  }
});

// node_modules/lodash/xor.js
var require_xor = __commonJS({
  "node_modules/lodash/xor.js"(exports, module2) {
    var arrayFilter = require_arrayFilter();
    var baseRest = require_baseRest();
    var baseXor = require_baseXor();
    var isArrayLikeObject = require_isArrayLikeObject();
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });
    module2.exports = xor;
  }
});

// node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/lodash/groupBy.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var groupBy2 = createAggregator(function(result, value, key2) {
      if (hasOwnProperty.call(result, key2)) {
        result[key2].push(value);
      } else {
        baseAssignValue(result, key2, [value]);
      }
    });
    module2.exports = groupBy2;
  }
});

// node_modules/@dnd-kit/utilities/dist/utilities.esm.js
var utilities_esm_exports = {};
__export(utilities_esm_exports, {
  CSS: () => CSS2,
  add: () => add2,
  canUseDOM: () => canUseDOM,
  findFirstFocusableNode: () => findFirstFocusableNode,
  getEventCoordinates: () => getEventCoordinates,
  getOwnerDocument: () => getOwnerDocument,
  getWindow: () => getWindow,
  hasViewportRelativeCoordinates: () => hasViewportRelativeCoordinates,
  isDocument: () => isDocument,
  isHTMLElement: () => isHTMLElement,
  isKeyboardEvent: () => isKeyboardEvent,
  isNode: () => isNode2,
  isSVGElement: () => isSVGElement,
  isTouchEvent: () => isTouchEvent,
  isWindow: () => isWindow,
  subtract: () => subtract,
  useCombinedRefs: () => useCombinedRefs,
  useEvent: () => useEvent,
  useInterval: () => useInterval,
  useIsomorphicLayoutEffect: () => useIsomorphicLayoutEffect,
  useLatestValue: () => useLatestValue,
  useLazyMemo: () => useLazyMemo,
  useNodeRef: () => useNodeRef,
  usePrevious: () => usePrevious2,
  useUniqueId: () => useUniqueId
});
function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return (0, import_react21.useMemo)(
    () => (node5) => {
      refs.forEach((ref) => ref(node5));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
  elementString === "[object global]";
}
function isNode2(node5) {
  return "nodeType" in node5;
}
function getWindow(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode2(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node5) {
  const {
    Document: Document2
  } = getWindow(node5);
  return node5 instanceof Document2;
}
function isHTMLElement(node5) {
  if (isWindow(node5)) {
    return false;
  }
  return node5 instanceof getWindow(node5).HTMLElement;
}
function isSVGElement(node5) {
  return node5 instanceof getWindow(node5).SVGElement;
}
function getOwnerDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode2(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target) || isSVGElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
function useEvent(handler) {
  const handlerRef = (0, import_react21.useRef)(handler);
  useIsomorphicLayoutEffect(() => {
    handlerRef.current = handler;
  });
  return (0, import_react21.useCallback)(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = (0, import_react21.useRef)(null);
  const set4 = (0, import_react21.useCallback)((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = (0, import_react21.useCallback)(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set4, clear];
}
function useLatestValue(value, dependencies) {
  if (dependencies === void 0) {
    dependencies = [value];
  }
  const valueRef = (0, import_react21.useRef)(value);
  useIsomorphicLayoutEffect(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = (0, import_react21.useRef)();
  return (0, import_react21.useMemo)(
    () => {
      const newValue = callback(valueRef.current);
      valueRef.current = newValue;
      return newValue;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...dependencies]
  );
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node5 = (0, import_react21.useRef)(null);
  const setNodeRef = (0, import_react21.useCallback)(
    (element) => {
      if (element !== node5.current) {
        onChangeHandler == null ? void 0 : onChangeHandler(element, node5.current);
      }
      node5.current = element;
    },
    //eslint-disable-next-line
    []
  );
  return [node5, setNodeRef];
}
function usePrevious2(value) {
  const ref = (0, import_react21.useRef)();
  (0, import_react21.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function useUniqueId(prefix2, value) {
  return (0, import_react21.useMemo)(() => {
    if (value) {
      return value;
    }
    const id2 = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
    ids[prefix2] = id2;
    return prefix2 + "-" + id2;
  }, [prefix2, value]);
}
function createAdjustmentFn(modifier) {
  return function(object2) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key2, valueAdjustment] of entries) {
        const value = accumulator[key2];
        if (value != null) {
          accumulator[key2] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object2
    });
  };
}
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent
  } = getWindow(event.target);
  return KeyboardEvent && event instanceof KeyboardEvent;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x3,
        clientY: y4
      } = event.touches[0];
      return {
        x: x3,
        y: y4
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x3,
        clientY: y4
      } = event.changedTouches[0];
      return {
        x: x3,
        y: y4
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }
  return element.querySelector(SELECTOR);
}
var import_react21, canUseDOM, useIsomorphicLayoutEffect, ids, add2, subtract, CSS2, SELECTOR;
var init_utilities_esm = __esm({
  "node_modules/@dnd-kit/utilities/dist/utilities.esm.js"() {
    import_react21 = __toESM(require_react());
    canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    useIsomorphicLayoutEffect = canUseDOM ? import_react21.useLayoutEffect : import_react21.useEffect;
    ids = {};
    add2 = createAdjustmentFn(1);
    subtract = createAdjustmentFn(-1);
    CSS2 = Object.freeze({
      Translate: {
        toString(transform) {
          if (!transform) {
            return;
          }
          const {
            x: x3,
            y: y4
          } = transform;
          return "translate3d(" + (x3 ? Math.round(x3) : 0) + "px, " + (y4 ? Math.round(y4) : 0) + "px, 0)";
        }
      },
      Scale: {
        toString(transform) {
          if (!transform) {
            return;
          }
          const {
            scaleX,
            scaleY
          } = transform;
          return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
        }
      },
      Transform: {
        toString(transform) {
          if (!transform) {
            return;
          }
          return [CSS2.Translate.toString(transform), CSS2.Scale.toString(transform)].join(" ");
        }
      },
      Transition: {
        toString(_ref2) {
          let {
            property,
            duration,
            easing
          } = _ref2;
          return property + " " + duration + "ms " + easing;
        }
      }
    });
    SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node5) {
          var index3 = heap.length;
          heap.push(node5);
          siftUp(heap, node5, index3);
        }
        function peek3(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first3 = heap[0];
          var last5 = heap.pop();
          if (last5 !== first3) {
            heap[0] = last5;
            siftDown(heap, last5, 0);
          }
          return first3;
        }
        function siftUp(heap, node5, i4) {
          var index3 = i4;
          while (index3 > 0) {
            var parentIndex = index3 - 1 >>> 1;
            var parent3 = heap[parentIndex];
            if (compare(parent3, node5) > 0) {
              heap[parentIndex] = node5;
              heap[index3] = parent3;
              index3 = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node5, i4) {
          var index3 = i4;
          var length2 = heap.length;
          var halfLength = length2 >>> 1;
          while (index3 < halfLength) {
            var leftIndex = (index3 + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node5) < 0) {
              if (rightIndex < length2 && compare(right, left) < 0) {
                heap[index3] = right;
                heap[rightIndex] = node5;
                index3 = rightIndex;
              } else {
                heap[index3] = left;
                heap[leftIndex] = node5;
                index3 = leftIndex;
              }
            } else if (rightIndex < length2 && compare(right, node5) < 0) {
              heap[index3] = right;
              heap[rightIndex] = node5;
              index3 = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a5, b3) {
          var diff2 = a5.sortIndex - b3.sortIndex;
          return diff2 !== 0 ? diff2 : a5.id - b3.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer2 = peek3(timerQueue);
          while (timer2 !== null) {
            if (timer2.callback === null) {
              pop(timerQueue);
            } else if (timer2.startTime <= currentTime) {
              pop(timerQueue);
              timer2.sortIndex = timer2.expirationTime;
              push(taskQueue, timer2);
            } else {
              return;
            }
            timer2 = peek3(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek3(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek3(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek3(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek3(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek3(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek3(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay2 = options.delay;
            if (typeof delay2 === "number" && delay2 > 0) {
              startTime2 = currentTime + delay2;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout2;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout2 = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout2 = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout2 = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout2 = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout2 = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout2;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek3(taskQueue) === null && newTask === peek3(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek3(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React18 = require_react();
        var Scheduler3 = require_scheduler();
        var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn3(format4) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format4, args);
            }
          }
        }
        function error(format4) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format4, args);
            }
          }
        }
        function printWarning(level, format4, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format4 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format4);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment5 = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = false;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i4 = 0; i4 < dependencies.length; i4++) {
            allNativeEvents.add(dependencies[i4]);
          }
        }
        var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkPropStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix3 = name.toLowerCase().slice(0, 5);
                return prefix3 !== "data-" && prefix3 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties2.hasOwnProperty(name) ? properties2[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties2 = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref2) {
          var name = _ref2[0], attributeName = _ref2[1];
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token3) {
          return token3[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties2[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties2[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties2[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node5, name, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node5[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node5.hasAttribute(attributeName)) {
                  var value = node5.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node5.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return node5.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node5.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node5, name, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name)) {
              return;
            }
            if (!node5.hasAttribute(name)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node5.getAttribute(name);
            {
              checkAttributeStringCoercion(expected, name);
            }
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node5, name, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name);
          if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
              var _attributeName = name;
              if (value === null) {
                node5.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value, name);
                }
                node5.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type = propertyInfo.type;
              node5[propertyName] = type === BOOLEAN ? false : "";
            } else {
              node5[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node5.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node5.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node5.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign3 = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign3({}, props, {
                  value: prevLog
                }),
                info: assign3({}, props, {
                  value: prevInfo
                }),
                warn: assign3({}, props, {
                  value: prevWarn
                }),
                error: assign3({}, props, {
                  value: prevError
                }),
                group: assign3({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign3({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign3({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix2;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix2 === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match5 = x3.stack.trim().match(/\n( *(at )?)/);
                prefix2 = match5 && match5[1] || "";
              }
            }
            return "\n" + prefix2 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample2) {
            if (sample2 && control && typeof sample2.stack === "string") {
              var sampleLines = sample2.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s5 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s5 >= 1 && c4 >= 0 && sampleLines[s5] !== controlLines[c4]) {
                c4--;
              }
              for (; s5 >= 1 && c4 >= 0; s5--, c4--) {
                if (sampleLines[s5] !== controlLines[c4]) {
                  if (s5 !== 1 || c4 !== 1) {
                    do {
                      s5--;
                      c4--;
                      if (c4 < 0 || sampleLines[s5] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s5].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s5 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node5 = workInProgress2;
            do {
              info += describeFiber(node5);
              node5 = node5.return;
            } while (node5);
            return info;
          } catch (x3) {
            return "\nError generating stack: " + x3.message + "\n" + x3.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context2 = type;
              return getContextName$1(context2) + ".Consumer";
            case ContextProvider:
              var provider = type;
              return getContextName$1(provider._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef:
              return getWrappedName$1(type, type.render, "ForwardRef");
            case Fragment5:
              return "Fragment";
            case HostComponent:
              return type;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type);
            case Mode:
              if (type === REACT_STRICT_MODE_TYPE) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type === "function") {
                return type.displayName || type.name || null;
              }
              if (typeof type === "string") {
                return type;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current2 = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current2 === null) {
              return null;
            }
            var owner = current2._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current2 === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current2);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current2 = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current2 = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current2;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString2(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              {
                checkFormFieldValueStringCoercion(value);
              }
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
        }
        function getTracker(node5) {
          return node5._valueTracker;
        }
        function detachTracker(node5) {
          node5._valueTracker = null;
        }
        function getValueFromNode(node5) {
          var value = "";
          if (!node5) {
            return value;
          }
          if (isCheckable(node5)) {
            value = node5.checked ? "true" : "false";
          } else {
            value = node5.value;
          }
          return value;
        }
        function trackValueOnNode(node5) {
          var valueField = isCheckable(node5) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node5.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node5[valueField]);
          }
          var currentValue = "" + node5[valueField];
          if (node5.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get3 = descriptor.get, set5 = descriptor.set;
          Object.defineProperty(node5, valueField, {
            configurable: true,
            get: function() {
              return get3.call(this);
            },
            set: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
              set5.call(this, value);
            }
          });
          Object.defineProperty(node5, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node5);
              delete node5[valueField];
            }
          };
          return tracker;
        }
        function track(node5) {
          if (getTracker(node5)) {
            return;
          }
          node5._valueTracker = trackValueOnNode(node5);
        }
        function updateValueIfChanged(node5) {
          if (!node5) {
            return false;
          }
          var tracker = getTracker(node5);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node5);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement2(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e5) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
          var usesChecked = props.type === "checkbox" || props.type === "radio";
          return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element, props) {
          var node5 = element;
          var checked = props.checked;
          var hostProps = assign3({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node5._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node5 = element;
          var defaultValue2 = props.defaultValue == null ? "" : props.defaultValue;
          node5._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue2),
            controlled: isControlled(props)
          };
        }
        function updateChecked(element, props) {
          var node5 = element;
          var checked = props.checked;
          if (checked != null) {
            setValueForProperty(node5, "checked", checked, false);
          }
        }
        function updateWrapper(element, props) {
          var node5 = element;
          {
            var controlled = isControlled(props);
            if (!node5._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node5._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props);
          var value = getToStringValue(props.value);
          var type = props.type;
          if (value != null) {
            if (type === "number") {
              if (value === 0 && node5.value === "" || // We explicitly want to coerce to number here if possible.
              // eslint-disable-next-line
              node5.value != value) {
                node5.value = toString2(value);
              }
            } else if (node5.value !== toString2(value)) {
              node5.value = toString2(value);
            }
          } else if (type === "submit" || type === "reset") {
            node5.removeAttribute("value");
            return;
          }
          {
            if (props.hasOwnProperty("value")) {
              setDefaultValue(node5, props.type, value);
            } else if (props.hasOwnProperty("defaultValue")) {
              setDefaultValue(node5, props.type, getToStringValue(props.defaultValue));
            }
          }
          {
            if (props.checked == null && props.defaultChecked != null) {
              node5.defaultChecked = !!props.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props, isHydrating2) {
          var node5 = element;
          if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
            var type = props.type;
            var isButton = type === "submit" || type === "reset";
            if (isButton && (props.value === void 0 || props.value === null)) {
              return;
            }
            var initialValue = toString2(node5._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node5.value) {
                  node5.value = initialValue;
                }
              }
            }
            {
              node5.defaultValue = initialValue;
            }
          }
          var name = node5.name;
          if (name !== "") {
            node5.name = "";
          }
          {
            node5.defaultChecked = !node5.defaultChecked;
            node5.defaultChecked = !!node5._wrapperState.initialChecked;
          }
          if (name !== "") {
            node5.name = name;
          }
        }
        function restoreControlledState(element, props) {
          var node5 = element;
          updateWrapper(node5, props);
          updateNamedCousins(node5, props);
        }
        function updateNamedCousins(rootNode, props) {
          var name = props.name;
          if (props.type === "radio" && name != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
            for (var i4 = 0; i4 < group.length; i4++) {
              var otherNode = group[i4];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node5, type, value) {
          if (
            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
            type !== "number" || getActiveElement2(node5.ownerDocument) !== node5
          ) {
            if (value == null) {
              node5.defaultValue = toString2(node5._wrapperState.initialValue);
            } else if (node5.defaultValue !== toString2(value)) {
              node5.defaultValue = toString2(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props) {
          {
            if (props.value == null) {
              if (typeof props.children === "object" && props.children !== null) {
                React18.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props.selected != null && !didWarnSelectedSetOnOption) {
              error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props) {
          if (props.value != null) {
            element.setAttribute("value", toString2(getToStringValue(props.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray5(a5) {
          return isArrayImpl(a5);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props) {
          {
            checkControlledValueProps("select", props);
            for (var i4 = 0; i4 < valuePropNames.length; i4++) {
              var propName = valuePropNames[i4];
              if (props[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray5(props[propName]);
              if (props.multiple && !propNameIsArray) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props.multiple && propNameIsArray) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node5, multiple, propValue, setDefaultSelected) {
          var options2 = node5.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i4 = 0; i4 < selectedValues.length; i4++) {
              selectedValue["$" + selectedValues[i4]] = true;
            }
            for (var _i = 0; _i < options2.length; _i++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
              if (options2[_i].selected !== selected) {
                options2[_i].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString2(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              if (options2[_i2].value === _selectedValue) {
                options2[_i2].selected = true;
                if (setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i2].disabled) {
                defaultSelected = options2[_i2];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element, props) {
          return assign3({}, props, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props) {
          var node5 = element;
          {
            checkSelectPropTypes(props);
          }
          node5._wrapperState = {
            wasMultiple: !!props.multiple
          };
          {
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props) {
          var node5 = element;
          node5.multiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node5, !!props.multiple, value, false);
          } else if (props.defaultValue != null) {
            updateOptions(node5, !!props.multiple, props.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props) {
          var node5 = element;
          var wasMultiple = node5._wrapperState.wasMultiple;
          node5._wrapperState.wasMultiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node5, !!props.multiple, value, false);
          } else if (wasMultiple !== !!props.multiple) {
            if (props.defaultValue != null) {
              updateOptions(node5, !!props.multiple, props.defaultValue, true);
            } else {
              updateOptions(node5, !!props.multiple, props.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props) {
          var node5 = element;
          var value = props.value;
          if (value != null) {
            updateOptions(node5, !!props.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props) {
          var node5 = element;
          if (props.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign3({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString2(node5._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props) {
          var node5 = element;
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props.value;
          if (initialValue == null) {
            var children = props.children, defaultValue2 = props.defaultValue;
            if (children != null) {
              {
                error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue2 != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray5(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue2 = children;
              }
            }
            if (defaultValue2 == null) {
              defaultValue2 = "";
            }
            initialValue = defaultValue2;
          }
          node5._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props) {
          var node5 = element;
          var value = getToStringValue(props.value);
          var defaultValue2 = getToStringValue(props.defaultValue);
          if (value != null) {
            var newValue = toString2(value);
            if (newValue !== node5.value) {
              node5.value = newValue;
            }
            if (props.defaultValue == null && node5.defaultValue !== newValue) {
              node5.defaultValue = newValue;
            }
          }
          if (defaultValue2 != null) {
            node5.defaultValue = toString2(defaultValue2);
          }
        }
        function postMountWrapper$3(element, props) {
          var node5 = element;
          var textContent = node5.textContent;
          if (textContent === node5._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node5.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props) {
          updateWrapper$1(element, props);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func2) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func2(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func2;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node5, html) {
          if (node5.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node5)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node5.firstChild) {
                node5.removeChild(node5.firstChild);
              }
              while (svgNode.firstChild) {
                node5.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node5.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node5, text) {
          if (text) {
            var firstChild = node5.firstChild;
            if (firstChild && firstChild === node5.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node5.textContent = text;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix3, key2) {
          return prefix3 + key2.charAt(0).toUpperCase() + key2.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix3) {
            isUnitlessNumber[prefixKey(prefix3, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty3 = value == null || typeof value === "boolean" || value === "";
          if (isEmpty3) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          {
            checkCSSPropertyStringCoercion(value, name);
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string4) {
            return string4.replace(hyphenPattern, function(_2, character2) {
              return character2.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter2 = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter2 + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter2 = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node5, styles) {
          var style2 = node5.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key2 in styles) {
            var longhands = shorthandToLonghand[key2] || [key2];
            for (var i4 = 0; i4 < longhands.length; i4++) {
              expanded[longhands[i4]] = key2;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key2 in expandedUpdates) {
              var originalKey = expandedUpdates[key2];
              var correctOriginalKey = expandedStyles[key2];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
          // NOTE: menuitem's close tag should be omitted, but that causes problems.
        };
        var voidElementTags = assign3({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props.children != null || props.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props.style != null && typeof props.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key2 in props) {
              var isValid3 = validateProperty(type, key2);
              if (!isValid3) {
                invalidProps.push(key2);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key2 in props) {
              var isValid3 = validateProperty$1(type, key2, props[key2], eventRegistry);
              if (!isValid3) {
                unknownProps.push(key2);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i4 = 0; i4 < queuedTargets.length; i4++) {
              restoreStateOfTarget(queuedTargets[i4]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn, bookkeeping) {
          return fn(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn, a5, b3) {
          if (isInsideEventHandler) {
            return fn(a5, b3);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn, a5, b3);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name, type, props) {
          switch (name) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props.disabled && isInteractive(type));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (props === null) {
            return null;
          }
          var listener = props[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
            return null;
          }
          if (listener && typeof listener !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM2) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e5) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name, func2, context2, a5, b3, c4, d3, e5, f3) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func2.apply(context2, funcArgs);
          } catch (error2) {
            this.onError(error2);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func2, context2, a5, b3, c4, d3, e5, f3) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func2.apply(context2, funcArgs);
                didError = false;
              }
              var error2;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error2 = event.error;
                didSetError = true;
                if (error2 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error2 != null && typeof error2 === "object") {
                    try {
                      error2._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name ? name : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error2);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error2) {
            hasError = true;
            caughtError = error2;
          }
        };
        function invokeGuardedCallback(name, func2, context2, a5, b3, c4, d3, e5, f3) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name, func2, context2, a5, b3, c4, d3, e5, f3) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error2 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error2;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error2 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error2;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error2 = caughtError;
            hasError = false;
            caughtError = null;
            return error2;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get2(key2) {
          return key2._reactInternals;
        }
        function has2(key2) {
          return key2._reactInternals !== void 0;
        }
        function set4(key2, value) {
          key2._reactInternals = value;
        }
        var NoFlags = (
          /*                      */
          0
        );
        var PerformedWork = (
          /*                */
          1
        );
        var Placement = (
          /*                    */
          2
        );
        var Update = (
          /*                       */
          4
        );
        var ChildDeletion = (
          /*                */
          16
        );
        var ContentReset = (
          /*                 */
          32
        );
        var Callback = (
          /*                     */
          64
        );
        var DidCapture = (
          /*                   */
          128
        );
        var ForceClientRender = (
          /*            */
          256
        );
        var Ref = (
          /*                          */
          512
        );
        var Snapshot = (
          /*                     */
          1024
        );
        var Passive = (
          /*                      */
          2048
        );
        var Hydrating = (
          /*                    */
          4096
        );
        var Visibility = (
          /*                   */
          8192
        );
        var StoreConsistency = (
          /*             */
          16384
        );
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = (
          /*               */
          32767
        );
        var Incomplete = (
          /*                   */
          32768
        );
        var ShouldCapture = (
          /*                */
          65536
        );
        var ForceUpdateForLegacySuspense = (
          /* */
          131072
        );
        var Forked = (
          /*                       */
          1048576
        );
        var RefStatic = (
          /*                    */
          2097152
        );
        var LayoutStatic = (
          /*                 */
          4194304
        );
        var PassiveStatic = (
          /*                */
          8388608
        );
        var MountLayoutDev = (
          /*               */
          16777216
        );
        var MountPassiveDev = (
          /*              */
          33554432
        );
        var BeforeMutationMask = (
          // TODO: Remove Update flag from before mutation phase by re-landing Visibility
          // flag logic (see #20043)
          Update | Snapshot | 0
        );
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node5 = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node5;
            do {
              node5 = nextNode;
              if ((node5.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node5.return;
              }
              nextNode = node5.return;
            } while (nextNode);
          } else {
            while (node5.return) {
              node5 = node5.return;
            }
          }
          if (node5.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current3 = fiber.alternate;
              if (current3 !== null) {
                suspenseState = current3.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance = ownerFiber.stateNode;
              if (!instance._warnedAboutRefsInRender) {
                error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get2(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a5 = fiber;
          var b3 = alternate;
          while (true) {
            var parentA = a5.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a5 = b3 = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a5) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b3) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a5.return !== b3.return) {
              a5 = parentA;
              b3 = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a5) {
                  didFindChild = true;
                  a5 = parentA;
                  b3 = parentB;
                  break;
                }
                if (_child === b3) {
                  didFindChild = true;
                  b3 = parentA;
                  a5 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a5) {
                    didFindChild = true;
                    a5 = parentB;
                    b3 = parentA;
                    break;
                  }
                  if (_child === b3) {
                    didFindChild = true;
                    b3 = parentB;
                    a5 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a5.alternate !== b3) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a5.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a5.stateNode.current === a5) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent3) {
          var currentParent = findCurrentFiberUsingSlowPath(parent3);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node5) {
          if (node5.tag === HostComponent || node5.tag === HostText) {
            return node5;
          }
          var child = node5.child;
          while (child !== null) {
            var match5 = findCurrentHostFiberImpl(child);
            if (match5 !== null) {
              return match5;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent3) {
          var currentParent = findCurrentFiberUsingSlowPath(parent3);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node5) {
          if (node5.tag === HostComponent || node5.tag === HostText) {
            return node5;
          }
          var child = node5.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match5 = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match5 !== null) {
                return match5;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler3.unstable_scheduleCallback;
        var cancelCallback = Scheduler3.unstable_cancelCallback;
        var shouldYield = Scheduler3.unstable_shouldYield;
        var requestPaint = Scheduler3.unstable_requestPaint;
        var now2 = Scheduler3.unstable_now;
        var getCurrentPriorityLevel = Scheduler3.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler3.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler3.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler3.unstable_NormalPriority;
        var LowPriority = Scheduler3.unstable_LowPriority;
        var IdlePriority = Scheduler3.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler3.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler3.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign3({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error("React instrumentation encountered an error: %s.", err);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root2, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root2, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root2, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root2.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root2) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root2);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map3 = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index4 = 0; index4 < TotalLanes; index4++) {
              var label = getLabelForLane(lane);
              map3.set(lane, label);
              lane *= 2;
            }
            return map3;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = (
          /*                         */
          0
        );
        var ConcurrentMode = (
          /*                 */
          1
        );
        var ProfileMode = (
          /*                    */
          2
        );
        var StrictLegacyMode = (
          /*               */
          8
        );
        var StrictEffectsMode = (
          /*              */
          16
        );
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x3) {
          var asUint = x3 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = (
          /*                        */
          0
        );
        var NoLane = (
          /*                          */
          0
        );
        var SyncLane = (
          /*                        */
          1
        );
        var InputContinuousHydrationLane = (
          /*    */
          2
        );
        var InputContinuousLane = (
          /*             */
          4
        );
        var DefaultHydrationLane = (
          /*            */
          8
        );
        var DefaultLane = (
          /*                     */
          16
        );
        var TransitionHydrationLane = (
          /*                */
          32
        );
        var TransitionLanes = (
          /*                       */
          4194240
        );
        var TransitionLane1 = (
          /*                        */
          64
        );
        var TransitionLane2 = (
          /*                        */
          128
        );
        var TransitionLane3 = (
          /*                        */
          256
        );
        var TransitionLane4 = (
          /*                        */
          512
        );
        var TransitionLane5 = (
          /*                        */
          1024
        );
        var TransitionLane6 = (
          /*                        */
          2048
        );
        var TransitionLane7 = (
          /*                        */
          4096
        );
        var TransitionLane8 = (
          /*                        */
          8192
        );
        var TransitionLane9 = (
          /*                        */
          16384
        );
        var TransitionLane10 = (
          /*                       */
          32768
        );
        var TransitionLane11 = (
          /*                       */
          65536
        );
        var TransitionLane12 = (
          /*                       */
          131072
        );
        var TransitionLane13 = (
          /*                       */
          262144
        );
        var TransitionLane14 = (
          /*                       */
          524288
        );
        var TransitionLane15 = (
          /*                       */
          1048576
        );
        var TransitionLane16 = (
          /*                       */
          2097152
        );
        var RetryLanes = (
          /*                            */
          130023424
        );
        var RetryLane1 = (
          /*                             */
          4194304
        );
        var RetryLane2 = (
          /*                             */
          8388608
        );
        var RetryLane3 = (
          /*                             */
          16777216
        );
        var RetryLane4 = (
          /*                             */
          33554432
        );
        var RetryLane5 = (
          /*                             */
          67108864
        );
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = (
          /*          */
          134217728
        );
        var NonIdleLanes = (
          /*                          */
          268435455
        );
        var IdleHydrationLane = (
          /*               */
          268435456
        );
        var IdleLane = (
          /*                        */
          536870912
        );
        var OffscreenLane = (
          /*                   */
          1073741824
        );
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root2, wipLanes) {
          var pendingLanes = root2.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
          // bother waiting until the root is complete.
          (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (
              // Tests whether the next lane is equal or lower priority than the wip
              // one. This works because the bits decrease in priority as you go left.
              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
              // only difference between default updates and transition updates is that
              // default updates do not support refresh transitions.
              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
            ) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root2.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root2.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index4 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index4;
              nextLanes |= entanglements[index4];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root2, lanes) {
          var eventTimes = root2.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index4 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index4;
            var eventTime = eventTimes[index4];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root2, currentTime) {
          var pendingLanes = root2.pendingLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index4 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index4;
            var expirationTime = expirationTimes[index4];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index4] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root2.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root2) {
          return getHighestPriorityLanes(root2.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root2) {
          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root2, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root2, lanes) {
          return (lanes & root2.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a5, b3) {
          return (a5 & b3) !== NoLanes;
        }
        function isSubsetOfLanes(set5, subset) {
          return (set5 & subset) === subset;
        }
        function mergeLanes(a5, b3) {
          return a5 | b3;
        }
        function removeLanes(set5, subset) {
          return set5 & ~subset;
        }
        function intersectLanes(a5, b3) {
          return a5 & b3;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a5, b3) {
          return a5 !== NoLane && a5 < b3 ? a5 : b3;
        }
        function createLaneMap(initial2) {
          var laneMap = [];
          for (var i4 = 0; i4 < TotalLanes; i4++) {
            laneMap.push(initial2);
          }
          return laneMap;
        }
        function markRootUpdated(root2, updateLane, eventTime) {
          root2.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
          }
          var eventTimes = root2.eventTimes;
          var index4 = laneToIndex(updateLane);
          eventTimes[index4] = eventTime;
        }
        function markRootSuspended(root2, suspendedLanes) {
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index4 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index4;
            expirationTimes[index4] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root2, pingedLanes, eventTime) {
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root2, remainingLanes) {
          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = NoLanes;
          root2.pingedLanes = NoLanes;
          root2.expiredLanes &= remainingLanes;
          root2.mutableReadLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          var entanglements = root2.entanglements;
          var eventTimes = root2.eventTimes;
          var expirationTimes = root2.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index4 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index4;
            entanglements[index4] = NoLanes;
            eventTimes[index4] = NoTimestamp;
            expirationTimes[index4] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          var entanglements = root2.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index4 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index4;
            if (
              // Is this one of the newly entangled lanes?
              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
              entanglements[index4] & entangledLanes
            ) {
              entanglements[index4] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index4 = laneToIndex(lanes);
            var lane = 1 << index4;
            var updaters = pendingUpdatersLaneMap[index4];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          var memoizedUpdaters = root2.memoizedUpdaters;
          while (lanes > 0) {
            var index4 = laneToIndex(lanes);
            var lane = 1 << index4;
            var updaters = pendingUpdatersLaneMap[index4];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root2, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a5, b3) {
          return a5 !== 0 && a5 < b3 ? a5 : b3;
        }
        function lowerEventPriority(a5, b3) {
          return a5 === 0 || a5 > b3 ? a5 : b3;
        }
        function isHigherEventPriority(a5, b3) {
          return a5 !== 0 && a5 < b3;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root2) {
          var currentState = root2.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn) {
          _attemptSynchronousHydration = fn;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn) {
          attemptContinuousHydration = fn;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn) {
          attemptHydrationAtCurrentPriority = fn;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn) {
          getCurrentUpdatePriority$1 = fn;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn) {
          attemptHydrationAtPriority = fn;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          // Intentionally camelCase
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  queuedTarget.blockedOn = instance;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i4 = 0;
          for (; i4 < queuedExplicitHydrationTargets.length; i4++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i4].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i4, 0, queuedTarget);
          if (i4 === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key2, map3) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map3.delete(key2);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler3.unstable_scheduleCallback(Scheduler3.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i4 = 1; i4 < queuedDiscreteEvents.length; i4++) {
              var queuedEvent = queuedDiscreteEvents[i4];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  return instance;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start2;
          var startValue = startText;
          var startLength = startValue.length;
          var end2;
          var endValue = getText();
          var endLength = endValue.length;
          for (start2 = 0; start2 < startLength; start2++) {
            if (startValue[start2] !== endValue[start2]) {
              break;
            }
          }
          var minEnd = startLength - start2;
          for (end2 = 1; end2 <= minEnd; end2++) {
            if (startValue[startLength - end2] !== endValue[endLength - end2]) {
              break;
            }
          }
          var sliceTail = end2 > 1 ? 1 - end2 : void 0;
          fallbackText = endValue.slice(start2, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root) {
            return root.value;
          }
          return root.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize4 = Interface[_propName];
              if (normalize4) {
                this[_propName] = normalize4(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign3(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
             * We release all dispatched `SyntheticEvent`s after each event loop, adding
             * them back into the pool. This allows a way to hold onto a reference that
             * won't be added back into the pool.
             */
            persist: function() {
            },
            /**
             * Checks if this event should be released back into the pool.
             *
             * @return {boolean} True if this should not be released, false otherwise.
             */
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign3({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign3({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0)
              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign3({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign3({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign3({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign3({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign3({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key2 = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key2 !== "Unidentified") {
              return key2;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign3({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          // Legacy Interface
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign3({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign3({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign3({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign3({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : (
              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
              "wheelDeltaX" in event ? -event.wheelDeltaX : 0
            );
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : (
              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
              "wheelDeltaY" in event ? -event.wheelDeltaY : (
                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                "wheelDelta" in event ? -event.wheelDelta : 0
              )
            );
          },
          deltaZ: 0,
          // Browsers without "deltaMode" is reporting in raw wheel delta where one
          // notch on the scroll is always +/- 120, roughly equivalent to pixels.
          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM2 && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
          !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars = nativeEvent.data;
              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars = getData();
              reset();
              isComposing = false;
              return chars;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM2) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM2) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node5) {
          var state = node5._wrapperState;
          if (!state || !state.controlled || node5.type !== "number") {
            return;
          }
          {
            setDefaultValue(node5, "number", node5.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from4;
          var to2;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from4 = targetInst;
            to2 = _related ? getClosestInstanceFromNode(_related) : null;
            if (to2 !== null) {
              var nearestMounted = getNearestMountedFiber(to2);
              if (to2 !== nearestMounted || to2.tag !== HostComponent && to2.tag !== HostText) {
                to2 = null;
              }
            }
          } else {
            from4 = null;
            to2 = targetInst;
          }
          if (from4 === to2) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from4 == null ? win : getNodeFromInstance(from4);
          var toNode = to2 == null ? win : getNodeFromInstance(to2);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from4, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to2, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from4, to2);
        }
        function is2(x3, y4) {
          return x3 === y4 && (x3 !== 0 || 1 / x3 === 1 / y4) || x3 !== x3 && y4 !== y4;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i4 = 0; i4 < keysA.length; i4++) {
            var currentKey = keysA[i4];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node5) {
          while (node5 && node5.firstChild) {
            node5 = node5.firstChild;
          }
          return node5;
        }
        function getSiblingNode(node5) {
          while (node5) {
            if (node5.nextSibling) {
              return node5.nextSibling;
            }
            node5 = node5.parentNode;
          }
        }
        function getNodeForCharacterOffset(root2, offset3) {
          var node5 = getLeafNode(root2);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node5) {
            if (node5.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node5.textContent.length;
              if (nodeStart <= offset3 && nodeEnd >= offset3) {
                return {
                  node: node5,
                  offset: offset3 - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node5 = getLeafNode(getSiblingNode(node5));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e5) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length2 = 0;
          var start2 = -1;
          var end2 = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node5 = outerNode;
          var parentNode = null;
          outer:
            while (true) {
              var next4 = null;
              while (true) {
                if (node5 === anchorNode && (anchorOffset === 0 || node5.nodeType === TEXT_NODE)) {
                  start2 = length2 + anchorOffset;
                }
                if (node5 === focusNode && (focusOffset === 0 || node5.nodeType === TEXT_NODE)) {
                  end2 = length2 + focusOffset;
                }
                if (node5.nodeType === TEXT_NODE) {
                  length2 += node5.nodeValue.length;
                }
                if ((next4 = node5.firstChild) === null) {
                  break;
                }
                parentNode = node5;
                node5 = next4;
              }
              while (true) {
                if (node5 === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start2 = length2;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end2 = length2;
                }
                if ((next4 = node5.nextSibling) !== null) {
                  break;
                }
                node5 = parentNode;
                parentNode = node5.parentNode;
              }
              node5 = next4;
            }
          if (start2 === -1 || end2 === -1) {
            return null;
          }
          return {
            start: start2,
            end: end2
          };
        }
        function setOffsets(node5, offsets) {
          var doc = node5.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length2 = node5.textContent.length;
          var start2 = Math.min(offsets.start, length2);
          var end2 = offsets.end === void 0 ? start2 : Math.min(offsets.end, length2);
          if (!selection.extend && start2 > end2) {
            var temp = end2;
            end2 = start2;
            start2 = temp;
          }
          var startMarker = getNodeForCharacterOffset(node5, start2);
          var endMarker = getNodeForCharacterOffset(node5, end2);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range3 = doc.createRange();
            range3.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start2 > end2) {
              selection.addRange(range3);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range3.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range3);
            }
          }
        }
        function isTextNode(node5) {
          return node5 && node5.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node5) {
          return node5 && node5.ownerDocument && containsNode(node5.ownerDocument.documentElement, node5);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement2();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement2(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection2(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i4 = 0; i4 < ancestors.length; i4++) {
              var info = ancestors[i4];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection2(input, offsets) {
          var start2 = offsets.start;
          var end2 = offsets.end;
          if (end2 === void 0) {
            end2 = start2;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start2;
            input.selectionEnd = Math.min(end2, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node5) {
          if ("selectionStart" in node5 && hasSelectionCapabilities(node5)) {
            return {
              start: node5.selectionStart,
              end: node5.selectionEnd
            };
          } else {
            var win = node5.ownerDocument && node5.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement2(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM2) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i4 = 0; i4 < simpleEventPluginEvents.length; i4++) {
            var eventName = simpleEventPluginEvents[i4];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
            // nonDelegatedEvents list in DOMPluginEventSystem.
            // Then we can remove this special list.
            // This is a breaking change that can wait until React 18.
            domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i4 = dispatchListeners.length - 1; i4 >= 0; i4--) {
              var _dispatchListeners$i = dispatchListeners[i4], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance;
            }
          } else {
            for (var _i = 0; _i < dispatchListeners.length; _i++) {
              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i4 = 0; i4 < dispatchQueue.length; i4++) {
            var _dispatchQueue$i = dispatchQueue[i4], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node5 = targetInst;
              mainLoop:
                while (true) {
                  if (node5 === null) {
                    return;
                  }
                  var nodeTag = node5.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container = node5.stateNode.containerInfo;
                    if (isMatchingRootContainer(container, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node5.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container !== null) {
                      var parentNode = getClosestInstanceFromNode(container);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node5 = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container = container.parentNode;
                    }
                  }
                  node5 = node5.return;
                }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance = targetFiber;
          var lastHostComponent = null;
          while (instance !== null) {
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance, reactEventName);
                if (listener != null) {
                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance = instance.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance = targetFiber;
          while (instance !== null) {
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
            instance = instance.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance = target;
          while (instance !== null) {
            if (instance === common) {
              break;
            }
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
            }
            instance = instance.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from4, to2) {
          var common = from4 && to2 ? getLowestCommonAncestor(from4, to2) : null;
          if (from4 !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from4, common, false);
          }
          if (to2 !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to2, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            // There are working polyfills for <dialog>. Let people use it.
            dialog: true,
            // Electron ships a custom <webview> tag to display external web content in
            // an isolated frame and process.
            // This tag is not present in non Electron environments such as JSDom which
            // is often used for testing purposes.
            // @see https://electronjs.org/docs/api/webview-tag
            webview: true
          };
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name) {
              names.push(name);
            });
            error("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent3, html) {
            var testElement = parent3.namespaceURI === HTML_NAMESPACE ? parent3.ownerDocument.createElement(parent3.tagName) : parent3.ownerDocument.createElementNS(parent3.namespaceURI, parent3.tagName);
            testElement.innerHTML = html;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop3() {
        }
        function trapClickOnNonInteractiveElement(node5) {
          node5.onclick = noop3;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i4 = 0; i4 < updatePayload.length; i4 += 2) {
            var propKey = updatePayload[i4];
            var propValue = updatePayload[i4 + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement16(type, props, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type, props);
              if (!isCustomComponentTag && type !== type.toLowerCase()) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
            if (type === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props.is === "string") {
              domElement = ownerDocument.createElement(type, {
                is: props.is
              });
            } else {
              domElement = ownerDocument.createElement(type);
              if (type === "select") {
                var node5 = domElement;
                if (props.multiple) {
                  node5.multiple = true;
                } else if (props.size) {
                  node5.size = props.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
                warnedUnknownTags[type] = true;
                error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "video":
            case "audio":
              for (var i4 = 0; i4 < mediaEventTypes.length; i4++) {
                listenToNonDelegatedEvent(mediaEventTypes[i4], domElement);
              }
              props = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props = rawProps;
          }
          assertValidProps(tag, props);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i4 = 0; i4 < mediaEventTypes.length; i4++) {
                listenToNonDelegatedEvent(mediaEventTypes[i4], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes = domElement.attributes;
            for (var _i = 0; _i < attributes.length; _i++) {
              var name = attributes[_i].name.toLowerCase();
              switch (name) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
            typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              propKey === "value" || propKey === "checked" || propKey === "selected")
                ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (
                // $FlowFixMe - Should be inferred as not undefined.
                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
              ) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text) {
          {
            if (text === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props);
              return;
            case "select":
              restoreControlledState$1(domElement, props);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
            // TODO: Distinguish by namespace here -- for <title>, including it here
            // errs on the side of fewer warnings
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign3({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type;
          var namespace;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root2 = rootContainerInstance.documentElement;
              namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container.namespaceURI || null;
              type = container.tagName;
              namespace = getChildNamespace(ownNamespace, type);
              break;
            }
          }
          {
            var validatedTag = type.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace = getChildNamespace(parentHostContextDev.namespace, type);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance) {
          return instance;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type, null, hostContextDev.ancestorInfo);
            if (typeof props.children === "string" || typeof props.children === "number") {
              var string4 = "" + props.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string4, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement16(type, props, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type, props, rootContainerInstance);
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string4 = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string4, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type, oldProps, newProps);
        }
        function shouldSetTextContent(type, props) {
          return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error2) {
          setTimeout(function() {
            throw error2;
          });
        }
        function commitMount(domElement, type, newProps, internalInstanceHandle) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
          var parentNode;
          if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
          } else {
            parentNode = container;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.insertBefore(child, beforeChild);
          } else {
            container.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.removeChild(child);
          } else {
            container.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node5 = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node5.nextSibling;
            parentInstance.removeChild(node5);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node5 = nextNode;
          } while (node5);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
          if (container.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container.parentNode, suspenseInstance);
          } else if (container.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container, suspenseInstance);
          }
          retryIfBlockedOn(container);
        }
        function hideInstance(instance) {
          instance = instance;
          var style2 = instance.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          instance = instance;
          var styleProp = props[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainer(container) {
          if (container.nodeType === ELEMENT_NODE) {
            container.textContent = "";
          } else if (container.nodeType === DOCUMENT_NODE) {
            if (container.documentElement) {
              container.removeChild(container.documentElement);
            }
          }
        }
        function canHydrateInstance(instance, type, props) {
          if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
            return null;
          }
          return instance;
        }
        function canHydrateTextInstance(instance, text) {
          if (text === "" || instance.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance;
        }
        function canHydrateSuspenseInstance(instance) {
          if (instance.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance) {
          var dataset = instance.nextSibling && instance.nextSibling.dataset;
          var digest, message, stack;
          if (dataset) {
            digest = dataset.dgst;
            {
              message = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message,
              digest,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          instance._reactRetry = callback;
        }
        function getNextHydratable(node5) {
          for (; node5 != null; node5 = node5.nextSibling) {
            var nodeType = node5.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node5.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node5;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance);
          updateFiberProps(instance, props);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node5 = suspenseInstance.nextSibling;
          var depth = 0;
          while (node5) {
            if (node5.nodeType === COMMENT_NODE) {
              var data = node5.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node5);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node5 = node5.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node5 = targetInstance.previousSibling;
          var depth = 0;
          while (node5) {
            if (node5.nodeType === COMMENT_NODE) {
              var data = node5.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node5;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node5 = node5.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
          {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentContainer, instance);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentNode, instance);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
          {
            warnForInsertedHydratedElement(parentContainer, type);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
          {
            warnForInsertedHydratedText(parentContainer, text);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedElement(parentNode, type);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedText(parentNode, text);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node5) {
          delete node5[internalInstanceKey];
          delete node5[internalPropsKey];
          delete node5[internalEventHandlersKey];
          delete node5[internalEventHandlerListenersKey];
          delete node5[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node5) {
          node5[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node5) {
          node5[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node5) {
          node5[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node5) {
          return !!node5[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node5) {
          var inst = node5[internalInstanceKey] || node5[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node5) {
          return node5[internalPropsKey] || null;
        }
        function updateFiberProps(node5, props) {
          node5[internalPropsKey] = props;
        }
        function getEventListenerSet(node5) {
          var elementListenerSet = node5[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node5[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has3 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has3(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index3 = -1;
        function createCursor(defaultValue2) {
          return {
            current: defaultValue2
          };
        }
        function pop(cursor, fiber) {
          if (index3 < 0) {
            {
              error("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index3]) {
              error("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index3];
          valueStack[index3] = null;
          {
            fiberStack[index3] = null;
          }
          index3--;
        }
        function push(cursor, value, fiber) {
          index3++;
          valueStack[index3] = cursor.current;
          {
            fiberStack[index3] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance = workInProgress2.stateNode;
            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type = workInProgress2.type;
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance = workInProgress2.stateNode;
            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance.__reactInternalMemoizedMaskedChildContext;
            }
            var context2 = {};
            for (var key2 in contextTypes) {
              context2[key2] = unmaskedContext[key2];
            }
            {
              var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name);
            }
            if (instance) {
              cacheContext(workInProgress2, unmaskedContext, context2);
            }
            return context2;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type) {
          {
            var childContextTypes = type.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context2, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push(contextStackCursor, context2, fiber);
            push(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type, parentContext) {
          {
            var instance = fiber.stateNode;
            var childContextTypes = type.childContextTypes;
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign3({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type, didChange) {
          {
            var instance = workInProgress2.stateNode;
            if (!instance) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type, previousContext);
              instance.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push(contextStackCursor, mergedContext, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node5 = fiber;
            do {
              switch (node5.tag) {
                case HostRoot:
                  return node5.stateNode.context;
                case ClassComponent: {
                  var Component2 = node5.type;
                  if (isContextProvider(Component2)) {
                    return node5.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node5 = node5.return;
            } while (node5 !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i4 = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue2 = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i4 < queue2.length; i4++) {
                var callback = queue2[i4];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error2) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i4 + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error2;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id2.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index4) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index4 + 1;
          var length2 = getBitLength(totalChildren) + baseLength;
          if (length2 > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id2 = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id2;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length2 | _id;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id2) {
          return 1 << getBitLength(id2) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(
                  returnFiber.type,
                  returnFiber.memoizedProps,
                  returnFiber.stateNode,
                  instance,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null)
                  didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance) {
          warnUnhydratedInstance(returnFiber, instance);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                    break;
                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _type,
                      _props,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _text,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode
                    );
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null)
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type);
              if (instance !== null) {
                fiber.stateNode = instance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance);
                return true;
              }
              return false;
            }
            case HostText: {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(
                    parentContainer,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode2
                  );
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent3 = fiber.return;
          while (parent3 !== null && parent3.tag !== HostComponent && parent3.tag !== HostRoot && parent3.tag !== SuspenseComponent) {
            parent3 = parent3.return;
          }
          hydrationParentFiber = parent3;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error2) {
          if (hydrationErrors === null) {
            hydrationErrors = [error2];
          } else {
            hydrationErrors.push(error2);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node5 = fiber;
            while (node5 !== null) {
              if (node5.mode & StrictLegacyMode) {
                maybeStrictRoot = node5;
              }
              node5 = node5.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set5) {
            var array = [];
            set5.forEach(function(value) {
              array.push(value);
            });
            return array.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
            instance.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn3("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn3("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn3("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        function resolveDefaultProps(Component2, baseProps) {
          if (Component2 && Component2.defaultProps) {
            var props = assign3({}, baseProps);
            var defaultProps = Component2.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context2, nextValue) {
          {
            push(valueCursor, context2._currentValue, providerFiber);
            context2._currentValue = nextValue;
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context2, providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          {
            {
              context2._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent3, renderLanes2, propagationRoot) {
          var node5 = parent3;
          while (node5 !== null) {
            var alternate = node5.alternate;
            if (!isSubsetOfLanes(node5.childLanes, renderLanes2)) {
              node5.childLanes = mergeLanes(node5.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node5 === propagationRoot) {
              break;
            }
            node5 = node5.return;
          }
          {
            if (node5 !== propagationRoot) {
              error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context2, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context2, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context2, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list = fiber.dependencies;
            if (list !== null) {
              nextFiber = fiber.child;
              var dependency = list.firstContext;
              while (dependency !== null) {
                if (dependency.context === context2) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update = createUpdate(NoTimestamp, lane);
                    update.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null)
                      ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update.next = update;
                      } else {
                        update.next = pending.next;
                        pending.next = update;
                      }
                      sharedQueue.pending = update;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list.lanes = mergeLanes(list.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context2) {
          {
            if (isDisallowedContextReadInDEV) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value = context2._currentValue;
          if (lastFullyObservedContext === context2)
            ;
          else {
            var contextItem = {
              context: context2,
              memoizedValue: value,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue2) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue2];
          } else {
            concurrentQueues.push(queue2);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i4 = 0; i4 < concurrentQueues.length; i4++) {
              var queue2 = concurrentQueues[i4];
              var lastInterleavedUpdate = queue2.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue2.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue2.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue2.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue2, update, lane) {
          var interleaved = queue2.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue2);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue2.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue2, update, lane) {
          var interleaved = queue2.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue2);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue2.interleaved = update;
        }
        function enqueueConcurrentClassUpdate(fiber, queue2, update, lane) {
          var interleaved = queue2.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue2);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue2.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node5 = sourceFiber;
          var parent3 = sourceFiber.return;
          while (parent3 !== null) {
            parent3.childLanes = mergeLanes(parent3.childLanes, lane);
            alternate = parent3.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent3.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node5 = parent3;
            parent3 = parent3.return;
          }
          if (node5.tag === HostRoot) {
            var root2 = node5.stateNode;
            return root2;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue2 = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue2;
        }
        function cloneUpdateQueue(current3, workInProgress2) {
          var queue2 = workInProgress2.updateQueue;
          var currentQueue = current3.updateQueue;
          if (queue2 === currentQueue) {
            var clone2 = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone2;
          }
        }
        function createUpdate(eventTime, lane) {
          var update = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update;
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
          }
        }
        function entangleTransitions(root2, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue2 = workInProgress2.updateQueue;
          var current3 = workInProgress2.alternate;
          if (current3 !== null) {
            var currentQueue = current3.updateQueue;
            if (queue2 === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue2.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update = firstBaseUpdate;
                do {
                  var clone2 = {
                    eventTime: update.eventTime,
                    lane: update.lane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone2;
                  } else {
                    newLast.next = clone2;
                    newLast = clone2;
                  }
                  update = update.next;
                } while (update !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue2 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue2;
              return;
            }
          }
          var lastBaseUpdate = queue2.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue2.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue2.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue2, update, prevState, nextProps, instance) {
          switch (update.tag) {
            case ReplaceState: {
              var payload = update.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign3({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
          var queue2 = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue2.shared;
          }
          var firstBaseUpdate = queue2.firstBaseUpdate;
          var lastBaseUpdate = queue2.lastBaseUpdate;
          var pendingQueue = queue2.shared.pending;
          if (pendingQueue !== null) {
            queue2.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current3 = workInProgress2.alternate;
            if (current3 !== null) {
              var currentQueue = current3.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue2.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
              var updateLane = update.lane;
              var updateEventTime = update.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone2 = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone2;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone2;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue2, update, newState, props, instance);
                var callback = update.callback;
                if (callback !== null && // If the update was already committed, we should not queue its
                // callback again.
                update.lane !== NoLane) {
                  workInProgress2.flags |= Callback;
                  var effects = queue2.effects;
                  if (effects === null) {
                    queue2.effects = [update];
                  } else {
                    effects.push(update);
                  }
                }
              }
              update = update.next;
              if (update === null) {
                pendingQueue = queue2.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update = _firstPendingUpdate;
                  queue2.lastBaseUpdate = _lastPendingUpdate;
                  queue2.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue2.baseState = newBaseState;
            queue2.firstBaseUpdate = newFirstBaseUpdate;
            queue2.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue2.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue2.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context2) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context2);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i4 = 0; i4 < effects.length; i4++) {
              var effect = effects[i4];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
              }
            }
          }
        }
        var fakeInternalInstance = {};
        var emptyRefsObject = new React18.Component().refs;
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key2 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key2)) {
              didWarnOnInvalidCallback.add(key2);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign3({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get2(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get2(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get2(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if (typeof instance.shouldComponentUpdate === "function") {
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance = workInProgress2.stateNode;
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray5(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance) {
          instance.updater = classComponentUpdater;
          workInProgress2.stateNode = instance;
          set4(instance, workInProgress2);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid3 = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid3 && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context2 = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance = new ctor(props, context2);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance = new ctor(props, context2);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
          adoptClassInstance(workInProgress2, instance);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context2);
          }
          return instance;
        }
        function callComponentWillMount(workInProgress2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (typeof instance.componentWillReceiveProps === "function") {
            instance.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance = workInProgress2.stateNode;
          instance.props = newProps;
          instance.state = workInProgress2.memoizedState;
          instance.refs = emptyRefsObject;
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
            }
          }
          instance.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance);
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance.props = oldProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              if (typeof instance.componentWillMount === "function") {
                instance.componentWillMount();
              }
              if (typeof instance.UNSAFE_componentWillMount === "function") {
                instance.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current3, workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          cloneUpdateQueue(current3, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
          // both before and after `shouldComponentUpdate` has been called. Not ideal,
          // but I'm loath to refactor this function. This only happens for memoized
          // components so it's not that common.
          enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
              if (typeof instance.componentWillUpdate === "function") {
                instance.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function coerceRef(returnFiber, current3, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
              // because these cannot be automatically converted to an arrow function
              // using a codemod. Therefore, we don't have to warn about string refs again.
              !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current3 !== null && current3.ref !== null && typeof current3.ref === "function" && current3.ref._stringRef === stringRef) {
                return current3.ref;
              }
              var ref = function(value) {
                var refs = resolvedInst.refs;
                if (refs === emptyRefsObject) {
                  refs = resolvedInst.refs = {};
                }
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init = lazyType._init;
          return init(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone2 = createWorkInProgress(fiber, pendingProps);
            clone2.index = 0;
            clone2.sibling = null;
            return clone2;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current3 = newFiber.alternate;
            if (current3 !== null) {
              var oldIndex = current3.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current3, textContent, lanes) {
            if (current3 === null || current3.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current3, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current3, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              return updateFragment2(returnFiber, current3, element.props.children, lanes, element.key);
            }
            if (current3 !== null) {
              if (current3.elementType === elementType || // Keep this check inline so it only runs on the false path:
              isCompatibleFamilyForHotReloading(current3, element) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current3.type) {
                var existing = useFiber(current3, element.props);
                existing.ref = coerceRef(returnFiber, current3, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current3, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current3, portal, lanes) {
            if (current3 === null || current3.tag !== HostPortal || current3.stateNode.containerInfo !== portal.containerInfo || current3.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current3, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current3, fragment2, lanes, key2) {
            if (current3 === null || current3.tag !== Fragment5) {
              var created = createFiberFromFragment(fragment2, returnFiber.mode, lanes, key2);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current3, fragment2);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return createChild(returnFiber, init(payload), lanes);
                }
              }
              if (isArray5(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key2 = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key2 !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key2) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key2) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                }
              }
              if (isArray5(newChild) || getIteratorFn(newChild)) {
                if (key2 !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
              }
              if (isArray5(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key2 = child.key;
                  if (typeof key2 !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key2);
                    break;
                  }
                  if (!knownKeys.has(key2)) {
                    knownKeys.add(key2);
                    break;
                  }
                  error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key2);
                  break;
                case REACT_LAZY_TYPE:
                  var payload = child._payload;
                  var init = child._init;
                  warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i4 = 0; i4 < newChildren.length; i4++) {
                var child = newChildren[i4];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
              newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key2 = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key2) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                  if (child.tag === Fragment5) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                  // We need to do this after the Hot Reloading check above,
                  // because hot reloading has different semantics than prod because
                  // it doesn't resuspend. So we can't let the call below suspend.
                  typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element.props);
                    _existing.ref = coerceRef(returnFiber, child, element);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element._source;
                      _existing._debugOwner = element._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key2 = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key2) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
              }
              if (isArray5(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current3, workInProgress2) {
          if (current3 !== null && workInProgress2.child !== current3.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c4) {
          if (c4 === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c4;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context2 = requiredContext(contextStackCursor$1.current);
          return context2;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context2 = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context2, fiber.type);
          if (context2 === nextContext) {
            return;
          }
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node5 = row;
          while (node5 !== null) {
            if (node5.tag === SuspenseComponent) {
              var state = node5.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node5;
                }
              }
            } else if (node5.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
            // keep track of whether it suspended or not.
            node5.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node5.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node5;
              }
            } else if (node5.child !== null) {
              node5.child.return = node5;
              node5 = node5.child;
              continue;
            }
            if (node5 === row) {
              return null;
            }
            while (node5.sibling === null) {
              if (node5.return === null || node5.return === row) {
                return null;
              }
              node5 = node5.return;
            }
            node5.sibling.return = node5.return;
            node5 = node5.sibling;
          }
          return null;
        }
        var NoFlags$1 = (
          /*   */
          0
        );
        var HasEffect = (
          /* */
          1
        );
        var Insertion = (
          /*  */
          2
        );
        var Layout = (
          /*    */
          4
        );
        var Passive$1 = (
          /*   */
          8
        );
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i4 = 0; i4 < workInProgressSources.length; i4++) {
            var mutableSource = workInProgressSources[i4];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root2, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version = getVersion(mutableSource._source);
          if (root2.mutableSourceEagerHydrationData == null) {
            root2.mutableSourceEagerHydrationData = [mutableSource, version];
          } else {
            root2.mutableSourceEagerHydrationData.push(mutableSource, version);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray5(deps)) {
              error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table = "";
                var secondColumnStart = 30;
                for (var i4 = 0; i4 <= hookTypesUpdateIndexDev; i4++) {
                  var oldHookName = hookTypesDev[i4];
                  var newHookName = i4 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i4 + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table += row;
                }
                error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i4 = 0; i4 < prevDeps.length && i4 < nextDeps.length; i4++) {
            if (objectIs(nextDeps[i4], prevDeps[i4])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current3, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current3 !== null ? current3._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current3 !== null && current3.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current3 !== null && current3.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component2(props, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component2(props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current3 !== null && (current3.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
            // and creates false positives. To make this work in legacy mode, we'd
            // need to mark fibers that commit in an incomplete state, somehow. For
            // now I'll disable the warning that most of the bugs that would trigger
            // it are either exclusive to concurrent mode or exist in both.
            (current3.mode & ConcurrentMode) !== NoMode) {
              error("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current3, workInProgress2, lanes) {
          workInProgress2.updateQueue = current3.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current3.lanes = removeLanes(current3.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue2 = hook.queue;
              if (queue2 !== null) {
                queue2.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current3 = currentlyRenderingFiber$1.alternate;
            if (current3 !== null) {
              nextCurrentHook = current3.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer2, initialArg, init) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init !== void 0) {
            initialState = init(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue2 = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer2,
            lastRenderedState: initialState
          };
          hook.queue = queue2;
          var dispatch = queue2.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue2);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer2, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue2 = hook.queue;
          if (queue2 === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue2.lastRenderedReducer = reducer2;
          var current3 = currentHook;
          var baseQueue = current3.baseQueue;
          var pendingQueue = queue2.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current3.baseQueue !== baseQueue) {
                error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current3.baseQueue = baseQueue = pendingQueue;
            queue2.pending = null;
          }
          if (baseQueue !== null) {
            var first3 = baseQueue.next;
            var newState = current3.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first3;
            do {
              var updateLane = update.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone2 = {
                  lane: updateLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone2;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone2;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update.hasEagerState) {
                  newState = update.eagerState;
                } else {
                  var action = update.action;
                  newState = reducer2(newState, action);
                }
              }
              update = update.next;
            } while (update !== null && update !== first3);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue2.lastRenderedState = newState;
          }
          var lastInterleaved = queue2.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue2.lanes = NoLanes;
          }
          var dispatch = queue2.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer2, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue2 = hook.queue;
          if (queue2 === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue2.lastRenderedReducer = reducer2;
          var dispatch = queue2.dispatch;
          var lastRenderPhaseUpdate = queue2.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue2.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
              var action = update.action;
              newState = reducer2(newState, action);
              update = update.next;
            } while (update !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue2.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
          // checking whether we scheduled a subscription effect above.
          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check];
            } else {
              stores.push(check);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue2 = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue2;
          var dispatch = queue2.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue2);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create2, destroy, deps) {
          var effect = {
            tag,
            create: create2,
            destroy,
            deps,
            // Circular
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create2, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, destroy, nextDeps);
        }
        function mountEffect(create2, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create2, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create2, deps);
          }
        }
        function updateEffect(create2, deps) {
          return updateEffectImpl(Passive, Passive$1, create2, deps);
        }
        function mountInsertionEffect(create2, deps) {
          return mountEffectImpl(Update, Insertion, create2, deps);
        }
        function updateInsertionEffect(create2, deps) {
          return updateEffectImpl(Update, Insertion, create2, deps);
        }
        function mountLayoutEffect(create2, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, create2, deps);
        }
        function updateLayoutEffect(create2, deps) {
          return updateEffectImpl(Update, Layout, create2, deps);
        }
        function imperativeHandleEffect(create2, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create2();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create2();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create2, deps) {
          {
            if (typeof create2 !== "function") {
              error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create2, deps) {
          {
            if (typeof create2 !== "function") {
              error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value;
          return value;
        }
        function updateDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value;
            return value;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value;
            return value;
          }
        }
        function startTransition(setPending, callback, options2) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn3("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start2 = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start2;
          return [isPending, start2];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start2 = hook.memoizedState;
          return [isPending, start2];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start2 = hook.memoizedState;
          return [isPending, start2];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root2 = getWorkInProgressRoot();
          var identifierPrefix = root2.identifierPrefix;
          var id2;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id2 = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id2 += "H" + localId.toString(32);
            }
            id2 += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id2 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id2;
          return id2;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id2 = hook.memoizedState;
          return id2;
        }
        function dispatchReducerAction(fiber, queue2, action) {
          {
            if (typeof arguments[3] === "function") {
              error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue2, update);
          } else {
            var root2 = enqueueConcurrentHookUpdate(fiber, queue2, update, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue2, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue2, action) {
          {
            if (typeof arguments[3] === "function") {
              error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue2, update);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue2.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue2.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update.hasEagerState = true;
                  update.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue2, update, lane);
                    return;
                  }
                } catch (error2) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root2 = enqueueConcurrentHookUpdate(fiber, queue2, update, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue2, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue2, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue2.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          queue2.pending = update;
        }
        function entangleTransitionUpdate(root2, queue2, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue2.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue2.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer2, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler3.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  root2.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  if (root2 !== null) {
                    root2.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function createCapturedValueAtFiber(value, source) {
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source),
            digest: null
          };
        }
        function createCapturedValue(value, digest, stack) {
          return {
            value,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest != null ? digest : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error2 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error2 != null && error2._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error2);
              }
              var componentName = source ? getComponentNameFromFiber(source) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error2);
            }
          } catch (e5) {
            setTimeout(function() {
              throw e5;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          update.payload = {
            element: null
          };
          var error2 = errorInfo.value;
          update.callback = function() {
            onUncaughtError(error2);
            logCapturedError(fiber, errorInfo);
          };
          return update;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update;
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root2.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node5 = returnFiber;
          do {
            if (node5.tag === SuspenseComponent && shouldCaptureSuspense(node5)) {
              return node5;
            }
            node5 = node5.return;
          } while (node5 !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update = createUpdate(NoTimestamp, SyncLane);
                  update.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root2, rootRenderLanes);
            }
          }
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root2, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root2, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root2, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                return;
              }
            }
          }
          value = createCapturedValueAtFiber(value, sourceFiber);
          renderDidError(value);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
        }
        function reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2) {
          if (current3 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current3.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current3, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component2)
                );
              }
            }
          }
          var render2 = Component2.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current3, workInProgress2, render2, nextProps, ref, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current3, workInProgress2, render2, nextProps, ref, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current3 !== null && !didReceiveUpdate) {
            bailoutHooks(current3, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          if (current3 === null) {
            var type = Component2.type;
            if (isSimpleFunctionComponent(type) && Component2.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
            Component2.defaultProps === void 0) {
              var resolvedType = type;
              {
                resolvedType = resolveFunctionForHotReloading(type);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type);
              }
              return updateSimpleMemoComponent(current3, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(type)
                );
              }
            }
            var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component2.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(
                _innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(_type)
              );
            }
          }
          var currentChild = current3.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current3, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare = Component2.compare;
            compare = compare !== null ? compare : shallowEqual;
            if (compare(prevProps, nextProps) && current3.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  outerMemoType = init(payload);
                } catch (x3) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    nextProps,
                    // Resolved (SimpleMemoComponent has no defaultProps)
                    "prop",
                    getComponentNameFromType(outerMemoType)
                  );
                }
              }
            }
          }
          if (current3 !== null) {
            var prevProps = current3.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current3.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
            workInProgress2.type === current3.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current3, renderLanes2)) {
                workInProgress2.lanes = current3.lanes;
                return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
              } else if ((current3.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current3, workInProgress2, Component2, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current3 !== null ? current3.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current3, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current3, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current3, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current3, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current3 === null && ref !== null || current3 !== null && current3.ref !== ref) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component2)
                );
              }
            }
          }
          var context2;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
            context2 = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current3, workInProgress2, Component2, nextProps, context2, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current3, workInProgress2, Component2, nextProps, context2, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current3 !== null && !didReceiveUpdate) {
            bailoutHooks(current3, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component2)
                );
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component2)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current3, workInProgress2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current3 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current3, workInProgress2, Component2, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current3, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current3, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
          markRef(current3, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, false);
            }
            return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          var instance = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current3 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current3, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component2, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root2 = workInProgress2.stateNode;
          if (root2.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
          } else if (root2.context) {
            pushTopLevelContextObject(workInProgress2, root2.context, false);
          }
          pushHostContainer(workInProgress2, root2.containerInfo);
        }
        function updateHostRoot(current3, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current3 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current3, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root2 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node5 = child;
              while (node5) {
                node5.flags = node5.flags & ~Placement | Hydrating;
                node5 = node5.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
            }
            reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current3, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current3 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current3 !== null ? current3.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current3, workInProgress2);
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current3, workInProgress2) {
          if (current3 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component2 = init(payload);
          workInProgress2.type = Component2;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
          var resolvedProps = resolveDefaultProps(Component2, props);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
                workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
              }
              child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
              }
              child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
              }
              child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      resolvedProps,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(Component2)
                    );
                  }
                }
              }
              child = updateMemoComponent(
                null,
                workInProgress2,
                Component2,
                resolveDefaultProps(Component2.type, resolvedProps),
                // The inner type can have defaults too
                renderLanes2
              );
              return child;
            }
          }
          var hint = "";
          {
            if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component2)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component2, nextProps);
          mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var context2;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
            context2 = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component2.prototype && typeof Component2.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component2, props, context2, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component2, props, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value = renderWithHooks(null, workInProgress2, Component2, props, context2, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component2);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component2) {
          {
            if (Component2) {
              if (Component2.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (typeof Component2.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current3, workInProgress2, renderLanes2) {
          if (current3 !== null) {
            var suspenseState = current3.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current3, renderLanes2) {
          return removeLanes(current3.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current3)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current3 === null || current3.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current3 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current3.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current3, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current3, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current3.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current3, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current3, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current3, offscreenProps) {
          return createWorkInProgress(current3, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current3, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current3.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current3, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current3.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if (
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
            // already cloned. In legacy mode, the only case where this isn't true is
            // when DevTools forces us to display a fallback; we skip the first render
            // pass entirely and go straight to rendering the fallback. (In Concurrent
            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
            // only codepath.)
            workInProgress2.child !== currentPrimaryChildFragment
          ) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current3, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current3, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(
                current3,
                workInProgress2,
                renderLanes2,
                // TODO: When we delete legacy mode, we should make this error argument
                // required  every concurrent mode path that causes hydration to
                // de-opt to client rendering should have an error message.
                null
              );
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest, message, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest = _getSuspenseInstanceF.digest;
                message = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error2;
              if (message) {
                error2 = new Error(message);
              } else {
                error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error2, digest, stack);
              return retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current3.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root2 = getWorkInProgressRoot();
              if (root2 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current3, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root2, current3, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current3.child;
              var retry2 = retryDehydratedSuspenseBoundary.bind(null, current3);
              registerSuspenseInstanceRetry(suspenseInstance, retry2);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current3.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current3, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node5 = firstChild;
          while (node5 !== null) {
            if (node5.tag === SuspenseComponent) {
              var state = node5.memoizedState;
              if (state !== null) {
                scheduleSuspenseWorkOnFiber(node5, renderLanes2, workInProgress2);
              }
            } else if (node5.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node5, renderLanes2, workInProgress2);
            } else if (node5.child !== null) {
              node5.child.return = node5;
              node5 = node5.child;
              continue;
            }
            if (node5 === workInProgress2) {
              return;
            }
            while (node5.sibling === null) {
              if (node5.return === null || node5.return === workInProgress2) {
                return;
              }
              node5 = node5.return;
            }
            node5.sibling.return = node5.return;
            node5 = node5.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index4) {
          {
            var isAnArray = isArray5(childSlot);
            var isIterable2 = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable2) {
              var type = isAnArray ? "array" : "iterable";
              error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index4, type);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray5(children)) {
                for (var i4 = 0; i4 < children.length; i4++) {
                  if (!validateSuspenseListNestedChild(children[i4], i4)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i)) {
                        return;
                      }
                      _i++;
                    }
                  }
                } else {
                  error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current3, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current3 !== null && (current3.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  tail,
                  lastContentRow,
                  tailMode
                );
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  // isBackwards
                  _tail,
                  null,
                  // last
                  tailMode
                );
                break;
              }
              case "together": {
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  null,
                  // tail
                  null,
                  // last
                  void 0
                );
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current3, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current3 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current3, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context2 = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context2, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context2, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current3, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current3, workInProgress2, renderLanes2) {
          var context2 = workInProgress2.type;
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render2 = newProps.children;
          {
            if (typeof render2 !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render2(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current3, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current3, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current3 !== null) {
              current3.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2) {
          if (current3 !== null) {
            workInProgress2.dependencies = current3.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current3, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current3, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current3.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current3];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current3);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current3, renderLanes2) {
          var updateLanes = current3.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current3, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root2 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component2 = workInProgress2.type;
              if (isContextProvider(Component2)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context2 = workInProgress2.type._context;
              pushProvider(workInProgress2, context2, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state = workInProgress2.memoizedState;
              if (state !== null) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current3, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current3.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current3, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current3, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
        }
        function beginWork(current3, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current3 !== null) {
              return remountFiber(current3, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current3 !== null) {
            var oldProps = current3.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
            workInProgress2.type !== current3.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current3, renderLanes2);
              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
              // may not be work scheduled on `current`, so we check for this flag.
              (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current3, workInProgress2, renderLanes2);
              }
              if ((current3.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current3, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current3, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component2 = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultProps(Component2, unresolvedProps);
              return updateFunctionComponent(current3, workInProgress2, Component2, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current3, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current3, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current3, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current3, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current3, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current3, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
              return updateForwardRef(current3, workInProgress2, type, _resolvedProps2, renderLanes2);
            }
            case Fragment5:
              return updateFragment(current3, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current3, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current3, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current3, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current3, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      _resolvedProps3,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(_type2)
                    );
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current3, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current3, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current3, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current3, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current3, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent3, workInProgress2, needsVisibilityToggle, isHidden2) {
            var node5 = workInProgress2.child;
            while (node5 !== null) {
              if (node5.tag === HostComponent || node5.tag === HostText) {
                appendInitialChild(parent3, node5.stateNode);
              } else if (node5.tag === HostPortal)
                ;
              else if (node5.child !== null) {
                node5.child.return = node5;
                node5 = node5.child;
                continue;
              }
              if (node5 === workInProgress2) {
                return;
              }
              while (node5.sibling === null) {
                if (node5.return === null || node5.return === workInProgress2) {
                  return;
                }
                node5 = node5.return;
              }
              node5.sibling.return = node5.return;
              node5 = node5.sibling;
            }
          };
          updateHostContainer = function(current3, workInProgress2) {
          };
          updateHostComponent$1 = function(current3, workInProgress2, type, newProps, rootContainerInstance) {
            var oldProps = current3.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current3, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current3, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current3 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current3, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment5:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component2 = workInProgress2.type;
              if (isContextProvider(Component2)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current3 === null || current3.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current3 !== null) {
                    var prevState = current3.memoizedState;
                    if (
                      // Check if this is a client root
                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                      (workInProgress2.flags & ForceClientRender) !== NoFlags
                    ) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current3, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress2.type;
              if (current3 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current3, workInProgress2, type, newProps, rootContainerInstance);
                if (current3.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance, workInProgress2, false, false);
                  workInProgress2.stateNode = instance;
                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current3 && workInProgress2.stateNode != null) {
                var oldText = current3.memoizedProps;
                updateHostText$1(current3, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current3 === null || current3.memoizedState !== null && current3.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current3, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current3 !== null && current3.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current3 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current3, workInProgress2);
              if (current3 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context2 = workInProgress2.type._context;
              popProvider(context2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current3 === null || (current3.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (
                    // The time it took to render last row is greater than the remaining
                    // time we have to render. So rendering one more row would likely
                    // exceed it.
                    now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                  ) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next4 = renderState.tail;
                renderState.rendering = next4;
                renderState.tail = next4.sibling;
                renderState.renderingStartTime = now2();
                next4.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next4;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current3 !== null) {
                var _prevState = current3.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current3, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component2 = workInProgress2.type;
              if (isContextProvider(Component2)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root2 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context2 = workInProgress2.type._context;
              popProvider(context2, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current3, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root2 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context2 = interruptedWork.type._context;
              popProvider(context2, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error2) {
          {
            invokeGuardedCallback(null, function() {
              throw error2;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current3, instance) {
          instance.props = current3.memoizedProps;
          instance.state = current3.memoizedState;
          if (current3.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current3);
            }
          } else {
            instance.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current3, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout, current3);
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyCallComponentWillUnmount(current3, nearestMountedAncestor, instance) {
          try {
            callComponentWillUnmountWithTimer(current3, instance);
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyCallComponentDidMount(current3, nearestMountedAncestor, instance) {
          try {
            instance.componentDidMount();
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyAttachRef(current3, nearestMountedAncestor) {
          try {
            commitAttachRef(current3);
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyDetachRef(current3, nearestMountedAncestor) {
          var ref = current3.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current3.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(null);
                  } finally {
                    recordLayoutEffectDuration(current3);
                  }
                } else {
                  retVal = ref(null);
                }
              } catch (error2) {
                captureCommitPhaseError(current3, nearestMountedAncestor, error2);
              }
              {
                if (typeof retVal === "function") {
                  error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current3));
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current3, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root2, firstChild) {
          focusedInstanceHandle = prepareForCommit(root2.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current3 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current3 !== null) {
                  var prevProps = current3.memoizedProps;
                  var prevState = current3.memoizedState;
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root2 = finishedWork.stateNode;
                  clearContainer(root2.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create2 = effect.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect.destroy = create2();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect.tag & Layout) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id2 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id2, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer:
                    while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root2 = parentFiber.stateNode;
                          root2.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current3, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current3 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current3.memoizedProps : resolveDefaultProps(finishedWork.type, current3.memoizedProps);
                      var prevState = current3.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current3 === null && finishedWork.flags & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current3 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root2 = parentFiber.stateNode;
                            root2.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node5) {
          switch (node5.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (node5.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node5, node5.return);
                } finally {
                  recordLayoutEffectDuration(node5);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node5, node5.return);
              }
              break;
            }
            case ClassComponent: {
              var instance = node5.stateNode;
              if (typeof instance.componentDidMount === "function") {
                safelyCallComponentDidMount(node5, node5.return, instance);
              }
              safelyAttachRef(node5, node5.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node5, node5.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden2) {
          var hostSubtreeRoot = null;
          {
            var node5 = finishedWork;
            while (true) {
              if (node5.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node5;
                  try {
                    var instance = node5.stateNode;
                    if (isHidden2) {
                      hideInstance(instance);
                    } else {
                      unhideInstance(node5.stateNode, node5.memoizedProps);
                    }
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              } else if (node5.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node5.stateNode;
                    if (isHidden2) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node5.memoizedProps);
                    }
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              } else if ((node5.tag === OffscreenComponent || node5.tag === LegacyHiddenComponent) && node5.memoizedState !== null && node5 !== finishedWork)
                ;
              else if (node5.child !== null) {
                node5.child.return = node5;
                node5 = node5.child;
                continue;
              }
              if (node5 === finishedWork) {
                return;
              }
              while (node5.sibling === null) {
                if (node5.return === null || node5.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node5) {
                  hostSubtreeRoot = null;
                }
                node5 = node5.return;
              }
              if (hostSubtreeRoot === node5) {
                hostSubtreeRoot = null;
              }
              node5.sibling.return = node5.return;
              node5 = node5.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance);
                break;
              default:
                instanceToUse = instance;
            }
            if (typeof ref === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent3 = fiber.return;
          while (parent3 !== null) {
            if (isHostParent(parent3)) {
              return parent3;
            }
            parent3 = parent3.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node5 = fiber;
          siblings:
            while (true) {
              while (node5.sibling === null) {
                if (node5.return === null || isHostParent(node5.return)) {
                  return null;
                }
                node5 = node5.return;
              }
              node5.sibling.return = node5.return;
              node5 = node5.sibling;
              while (node5.tag !== HostComponent && node5.tag !== HostText && node5.tag !== DehydratedFragment) {
                if (node5.flags & Placement) {
                  continue siblings;
                }
                if (node5.child === null || node5.tag === HostPortal) {
                  continue siblings;
                } else {
                  node5.child.return = node5;
                  node5 = node5.child;
                }
              }
              if (!(node5.flags & Placement)) {
                return node5.stateNode;
              }
            }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent3 = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent3);
                parentFiber.flags &= ~ContentReset;
              }
              var before3 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before3, parent3);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node5, before3, parent3) {
          var tag = node5.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node5.stateNode;
            if (before3) {
              insertInContainerBefore(parent3, stateNode, before3);
            } else {
              appendChildToContainer(parent3, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node5.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before3, parent3);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before3, parent3);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node5, before3, parent3) {
          var tag = node5.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node5.stateNode;
            if (before3) {
              insertBefore(parent3, stateNode, before3);
            } else {
              appendChild(parent3, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node5.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before3, parent3);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before3, parent3);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root2, returnFiber, deletedFiber) {
          {
            var parent3 = returnFiber;
            findParent:
              while (parent3 !== null) {
                switch (parent3.tag) {
                  case HostComponent: {
                    hostParent = parent3.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent3.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent3.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent3 = parent3.return;
              }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent3) {
          var child = parent3.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance = deletedFiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (
                // TODO: Remove this dead flag
                deletedFiber.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current3 = finishedWork.alternate;
            if (current3 !== null) {
              var prevState = current3.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry2 = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry2, retry2);
              }
            });
          }
        }
        function commitMutationEffects(root2, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root2);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i4 = 0; i4 < deletions.length; i4++) {
              var childToDelete = deletions[i4];
              try {
                commitDeletionEffects(root2, parentFiber, childToDelete);
              } catch (error2) {
                captureCommitPhaseError(childToDelete, parentFiber, error2);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root2);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
          var current3 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current3 !== null) {
                  safelyDetachRef(current3, current3.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current3 !== null) {
                  safelyDetachRef(current3, current3.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance = finishedWork.stateNode;
                  try {
                    resetTextContent(instance);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current3 !== null ? current3.memoizedProps : newProps;
                    var type = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                      } catch (error2) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current3 !== null ? current3.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current3 !== null) {
                    var prevRootState = current3.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root2.containerInfo);
                      } catch (error2) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden2 = newState !== null;
                offscreenInstance.isHidden = isHidden2;
                if (isHidden2) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current3 !== null && current3.memoizedState !== null;
              if (
                // TODO: Remove this dead flag
                finishedWork.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root2, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root2, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root2, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root2, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden2 = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden2 || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              } else {
                var current3 = fiber.alternate;
                var wasHidden = current3 !== null && current3.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(
                    child,
                    // New root; bubble back up to here and stop.
                    root2,
                    committedLanes
                  );
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current3 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root2, current3, fiber, committedLanes);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden2 = fiber.memoizedState !== null;
                if (isHidden2) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden2 = fiber.memoizedState !== null;
              if (isHidden2) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i4 = 0; i4 < deletions.length; i4++) {
                  var fiberToDelete = deletions[i4];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current3, nearestMountedAncestor) {
          switch (current3.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (current3.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current3, nearestMountedAncestor);
                recordPassiveEffectDuration(current3);
              } else {
                commitHookEffectListUnmount(Passive$1, current3, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout | HasEffect, fiber);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                try {
                  instance.componentDidMount();
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = (
          /*             */
          0
        );
        var BatchedContext = (
          /*               */
          1
        );
        var RenderContext = (
          /*                */
          2
        );
        var CommitContext = (
          /*                */
          4
        );
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now2();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now2();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root2, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root2, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root2 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
          var current3 = root2.current;
          current3.lanes = lane;
          markRootUpdated(root2, lane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (
            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
            // decided not to enable it.
            (executionContext & RenderContext) !== NoContext
          );
        }
        function ensureRootIsScheduled(root2, currentTime) {
          var existingCallbackNode = root2.callbackNode;
          markStarvedLanesAsExpired(root2, currentTime);
          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root2.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
          // Scheduler task, rather than an `act` task, cancel it and re-scheduled
          // on the `act` queue.
          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root2.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
          }
          root2.callbackPriority = newCallbackPriority;
          root2.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root2, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root2.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root2.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now2());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root2, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root2, lanes);
              var finishedWork = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root2, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root2, NoLanes);
                  markRootSuspended$1(root2, lanes);
                  ensureRootIsScheduled(root2, now2());
                  throw _fatalError;
                }
              }
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root2, now2());
          if (root2.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root2);
          }
          return null;
        }
        function recoverFromConcurrentError(root2, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root2)) {
            var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root2.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root2, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors2) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors2;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors2);
          }
        }
        function finishConcurrentRender(root2, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            case RootErrored: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
              !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root2, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root2.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root2, suspendedLanes);
                    break;
                  }
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now2() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node5 = finishedWork;
          while (true) {
            if (node5.flags & StoreConsistency) {
              var updateQueue = node5.updateQueue;
              if (updateQueue !== null) {
                var checks = updateQueue.stores;
                if (checks !== null) {
                  for (var i4 = 0; i4 < checks.length; i4++) {
                    var check = checks[i4];
                    var getSnapshot = check.getSnapshot;
                    var renderedValue = check.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error2) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node5.child;
            if (node5.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node5;
              node5 = child;
              continue;
            }
            if (node5 === finishedWork) {
              return true;
            }
            while (node5.sibling === null) {
              if (node5.return === null || node5.return === finishedWork) {
                return true;
              }
              node5 = node5.return;
            }
            node5.sibling.return = node5.return;
            node5 = node5.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root2, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root2, suspendedLanes);
        }
        function performSyncWorkOnRoot(root2) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root2, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root2, now2());
            return null;
          }
          var exitStatus = renderRootSync(root2, lanes);
          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now2());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root2.current.alternate;
          root2.finishedWork = finishedWork;
          root2.finishedLanes = lanes;
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root2, now2());
          return null;
        }
        function flushRoot(root2, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root2, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root2, now2());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn, a5) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn(a5);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn, a5, b3, c4, d3) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn(a5, b3, c4, d3);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync2(fn) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn) {
              return fn();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root2, lanes) {
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          var timeoutHandle = root2.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root2.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current3 = interruptedWork.alternate;
              unwindInterruptedWork(current3, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root2;
          var rootWorkInProgress = createWorkInProgress(root2.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root2, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now2();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error2) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error2];
          } else {
            workInProgressRootConcurrentErrors.push(error2);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current3 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next4;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next4 = beginWork$1(current3, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next4 = beginWork$1(current3, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next4 === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next4;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current3 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next4 = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next4 = completeWork(current3, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next4 = completeWork(current3, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next4 !== null) {
                workInProgress = next4;
                return;
              }
            } else {
              var _next = unwindWork(current3, completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root2, recoverableErrors, transitions2) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root2, recoverableErrors, transitions2, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root2, recoverableErrors, transitions2, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root2.finishedWork;
          var lanes = root2.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          if (finishedWork === root2.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root2.callbackNode = null;
          root2.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root2, remainingLanes);
          if (root2 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions2;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root2, finishedWork, lanes);
            resetAfterCommit(root2.containerInfo);
            root2.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root2, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root2.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root2;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root2.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root2.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root2.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root2, now2());
          if (recoverableErrors !== null) {
            var onRecoverableError = root2.onRecoverableError;
            for (var i4 = 0; i4 < recoverableErrors.length; i4++) {
              var recoverableError = recoverableErrors[i4];
              var componentStack = recoverableError.stack;
              var digest = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root2.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root2 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root2;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions2 = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root2 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root2.current);
          commitPassiveMountEffects(root2, root2.current, lanes, transitions2);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i4 = 0; i4 < profilerEffects.length; i4++) {
              var _fiber = profilerEffects[i4];
              commitPassiveEffectDurations(root2, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root2.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root2 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root2;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root2);
          {
            var stateNode = root2.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance);
          }
        }
        function prepareToThrowUncaughtError(error2) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error2;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
          var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root2 = enqueueUpdate(rootFiber, update, SyncLane);
          var eventTime = requestEventTime();
          if (root2 !== null) {
            markRootUpdated(root2, SyncLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root2 = enqueueUpdate(fiber, update, SyncLane);
                var eventTime = requestEventTime();
                if (root2 !== null) {
                  markRootUpdated(root2, SyncLane, eventTime);
                  ensureRootIsScheduled(root2, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root2, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root2, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root2 !== null) {
            markRootUpdated(root2, retryLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current3 = firstChild;
            var subtreeRoot = null;
            while (current3 !== null) {
              var primarySubtreeFlag = current3.subtreeFlags & fiberFlags;
              if (current3 !== subtreeRoot && current3.child !== null && primarySubtreeFlag !== NoFlags) {
                current3 = current3.child;
              } else {
                if ((current3.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current3);
                }
                if (current3.sibling !== null) {
                  current3 = current3.sibling;
                } else {
                  current3 = subtreeRoot = current3.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current2;
            try {
              setCurrentFiber(fiber);
              error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current3, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current3, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current3, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current3, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root2, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current2;
              try {
                setCurrentFiber(fiber);
                error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
          {
            if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              return type;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type) {
          return resolveFunctionForHotReloading(type);
        }
        function resolveForwardRefForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              if (type !== null && type !== void 0 && typeof type.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type.render);
                if (type.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type.displayName !== void 0) {
                    syntheticType.displayName = type.displayName;
                  }
                  return syntheticType;
                }
              }
              return type;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root2, update) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
            flushPassiveEffects();
            flushSync2(function() {
              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root2, element) {
          {
            if (root2.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync2(function() {
              updateContainer(element, root2, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root2, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node5 = fiber;
            while (true) {
              switch (node5.tag) {
                case HostComponent:
                  hostInstances.add(node5.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node5.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node5.stateNode.containerInfo);
                  return;
              }
              if (node5.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node5 = node5.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node5 = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node5.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node5.stateNode);
              } else if (node5.child !== null) {
                node5.child.return = node5;
                node5 = node5.child;
                continue;
              }
              if (node5 === fiber) {
                return foundHostInstances;
              }
              while (node5.sibling === null) {
                if (node5.return === null || node5.return === fiber) {
                  return foundHostInstances;
                }
                node5 = node5.return;
              }
              node5.sibling.return = node5.return;
              node5 = node5.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e5) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key2, mode) {
          this.tag = tag;
          this.key = key2;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key2, mode) {
          return new FiberNode(tag, pendingProps, key2, mode);
        };
        function shouldConstruct$1(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type) {
          return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component2) {
          if (typeof Component2 === "function") {
            return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
          } else if (Component2 !== void 0 && Component2 !== null) {
            var $$typeof = Component2.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current3, pendingProps) {
          var workInProgress2 = current3.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current3.tag, pendingProps, current3.key, current3.mode);
            workInProgress2.elementType = current3.elementType;
            workInProgress2.type = current3.type;
            workInProgress2.stateNode = current3.stateNode;
            {
              workInProgress2._debugSource = current3._debugSource;
              workInProgress2._debugOwner = current3._debugOwner;
              workInProgress2._debugHookTypes = current3._debugHookTypes;
            }
            workInProgress2.alternate = current3;
            current3.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current3.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current3.flags & StaticMask;
          workInProgress2.childLanes = current3.childLanes;
          workInProgress2.lanes = current3.lanes;
          workInProgress2.child = current3.child;
          workInProgress2.memoizedProps = current3.memoizedProps;
          workInProgress2.memoizedState = current3.memoizedState;
          workInProgress2.updateQueue = current3.updateQueue;
          var currentDependencies = current3.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current3.sibling;
          workInProgress2.index = current3.index;
          workInProgress2.ref = current3.ref;
          {
            workInProgress2.selfBaseDuration = current3.selfBaseDuration;
            workInProgress2.treeBaseDuration = current3.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current3._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current3.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current3.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current3.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current3 = workInProgress2.alternate;
          if (current3 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current3.childLanes;
            workInProgress2.lanes = current3.lanes;
            workInProgress2.child = current3.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current3.memoizedProps;
            workInProgress2.memoizedState = current3.memoizedState;
            workInProgress2.updateQueue = current3.updateQueue;
            workInProgress2.type = current3.type;
            var currentDependencies = current3.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current3.selfBaseDuration;
              workInProgress2.treeBaseDuration = current3.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type;
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type === "string") {
            fiberTag = HostComponent;
          } else {
            getTag:
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key2);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key2);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key2);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key2);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key2);
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_SCOPE_TYPE:
                case REACT_CACHE_TYPE:
                case REACT_TRACING_MARKER_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                default: {
                  if (typeof type === "object" && type !== null) {
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                }
              }
          }
          var fiber = createFiber(fiberTag, pendingProps, key2, mode);
          fiber.elementType = type;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type = element.type;
          var key2 = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key2) {
          var fiber = createFiber(Fragment5, elements, key2, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key2) {
          {
            if (typeof pendingProps.id !== "string") {
              error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key2, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key2) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key2, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key2) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key2, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key2) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key2, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content, mode, lanes) {
          var fiber = createFiber(HostText, content, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.subtreeFlags = source.subtreeFlags;
          target.deletions = source.deletions;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i = 0; _i < TotalLanes; _i++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root2.current = uninitializedFiber;
          uninitializedFiber.stateNode = root2;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate2,
              cache: null,
              // not enabled yet
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root2;
        }
        var ReactVersion = "18.2.0";
        function createPortal2(children, containerInfo, implementation) {
          var key2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key2);
          }
          return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE,
            key: key2 == null ? null : "" + key2,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get2(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component2 = fiber.type;
            if (isContextProvider(Component2)) {
              return processChildContext(fiber, Component2, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get2(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys2 = Object.keys(component).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys2);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current2;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = true;
          var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root2.context = getContextForSubtree(null);
          var current3 = root2.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current3);
          var update = createUpdate(eventTime, lane);
          update.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current3, update, lane);
          scheduleInitialHydrationOnRoot(root2, lane, eventTime);
          return root2;
        }
        function updateContainer(element, container, parentComponent, callback) {
          {
            onScheduleRoot(container, element);
          }
          var current$1 = container.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context2 = getContextForSubtree(parentComponent);
          if (container.context === null) {
            container.context = context2;
          } else {
            container.pendingContext = context2;
          }
          {
            if (isRendering && current2 !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current2) || "Unknown");
            }
          }
          var update = createUpdate(eventTime, lane);
          update.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(current$1, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
            entangleTransitions(root2, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root2 = fiber.stateNode;
              if (isRootDehydrated(root2)) {
                var lanes = getHighestPriorityPendingLanes(root2);
                flushRoot(root2, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync2(function() {
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path3, index4) {
            var key2 = path3[index4];
            var updated = isArray5(obj) ? obj.slice() : assign3({}, obj);
            if (index4 + 1 === path3.length) {
              if (isArray5(updated)) {
                updated.splice(key2, 1);
              } else {
                delete updated[key2];
              }
              return updated;
            }
            updated[key2] = copyWithDeleteImpl(obj[key2], path3, index4 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path3) {
            return copyWithDeleteImpl(obj, path3, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index4) {
            var oldKey = oldPath[index4];
            var updated = isArray5(obj) ? obj.slice() : assign3({}, obj);
            if (index4 + 1 === oldPath.length) {
              var newKey = newPath[index4];
              updated[newKey] = updated[oldKey];
              if (isArray5(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(
                // $FlowFixMe number or string is fine here
                obj[oldKey],
                oldPath,
                newPath,
                index4 + 1
              );
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn3("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i4 = 0; i4 < newPath.length - 1; i4++) {
                if (oldPath[i4] !== newPath[i4]) {
                  warn3("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path3, index4, value) {
            if (index4 >= path3.length) {
              return value;
            }
            var key2 = path3[index4];
            var updated = isArray5(obj) ? obj.slice() : assign3({}, obj);
            updated[key2] = copyWithSetImpl(obj[key2], path3, index4 + 1, value);
            return updated;
          };
          var copyWithSet = function(obj, path3, value) {
            return copyWithSetImpl(obj, path3, 0, value);
          };
          var findHook = function(fiber, id2) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id2 > 0) {
              currentHook2 = currentHook2.next;
              id2--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id2, path3, value) {
            var hook = findHook(fiber, id2);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path3, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign3({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id2, path3) {
            var hook = findHook(fiber, id2);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path3);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign3({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id2, oldPath, newPath) {
            var hook = findHook(fiber, id2);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign3({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path3, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path3, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path3) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path3);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current2;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools,
            // Enables DevTools to detect reconciler version rather than renderer version
            // which may not match for third party renderers.
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? (
          // In modern browsers, reportError will dispatch an error event,
          // emulating an uncaught JavaScript error.
          reportError
        ) : function(error2) {
          console["error"](error2);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (root2 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container = root2.containerInfo;
            if (container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root2.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root2 = this._internalRoot;
          if (root2 !== null) {
            this._internalRoot = null;
            var container = root2.containerInfo;
            {
              if (isAlreadyRendering()) {
                error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync2(function() {
              updateContainer(null, root2, null, null);
            });
            unmarkContainerAsRoot(container);
          }
        };
        function createRoot(container, options2) {
          if (!isValidContainer(container)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options2 !== null && options2 !== void 0) {
            {
              if (options2.hydrate) {
                warn3("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                  error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
            if (options2.transitionCallbacks !== void 0) {
              transitionCallbacks = options2.transitionCallbacks;
            }
          }
          var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root2);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container, initialChildren, options2) {
          if (!isValidContainer(container)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          {
            if (initialChildren === void 0) {
              error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options2 != null ? options2 : null;
          var mutableSources = options2 != null && options2.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options2 !== null && options2 !== void 0) {
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
          }
          var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container);
          listenToAllSupportedEvents(container);
          if (mutableSources) {
            for (var i4 = 0; i4 < mutableSources.length; i4++) {
              var mutableSource = mutableSources[i4];
              registerMutableSourceForHydration(root2, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root2);
        }
        function isValidContainer(node5) {
          return !!(node5 && (node5.nodeType === ELEMENT_NODE || node5.nodeType === DOCUMENT_NODE || node5.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node5) {
          return !!(node5 && (node5.nodeType === ELEMENT_NODE || node5.nodeType === DOCUMENT_NODE || node5.nodeType === DOCUMENT_FRAGMENT_NODE || node5.nodeType === COMMENT_NODE && node5.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container) {
          {
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container)) {
              if (container._reactRootContainer) {
                error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container) {
            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container) {
          if (!container) {
            return null;
          }
          if (container.nodeType === DOCUMENT_NODE) {
            return container.documentElement;
          } else {
            return container.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            var root2 = createHydrationContainer(
              initialChildren,
              callback,
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = root2;
            markContainerAsRoot(root2.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync2();
            return root2;
          } else {
            var rootSibling;
            while (rootSibling = container.lastChild) {
              container.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(_root);
                _originalCallback.call(instance);
              };
            }
            var _root = createContainer(
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container);
            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync2(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container._reactRootContainer;
          var root2;
          if (!maybeRoot) {
            root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
          } else {
            root2 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            updateContainer(children, root2, parentComponent, callback);
          }
          return getPublicRootInstance(root2);
        }
        function findDOMNode(componentOrElement) {
          {
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element, container, callback) {
          {
            error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
        }
        function render(element, container, callback) {
          {
            error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          {
            error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has2(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        function unmountComponentAtNode(container) {
          if (!isValidContainerLegacy(container)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync2(function() {
              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                container._reactRootContainer = null;
                unmarkContainerAsRoot(container);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
          Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
          Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync2);
        function createPortal$1(children, container) {
          var key2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal2(children, container, null, key2);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          // Keep in sync with ReactTestUtils.js.
          // This is an array for better minification.
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot(container, options2);
        }
        function hydrateRoot$1(container, initialChildren, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container, initialChildren, options2);
        }
        function flushSync$1(fn) {
          {
            if (isAlreadyRendering()) {
              error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync2(fn);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM2 && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    if (false) {
      checkDCE();
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js
function HiddenText(_ref2) {
  let {
    id: id2,
    value
  } = _ref2;
  return import_react22.default.createElement("div", {
    id: id2,
    style: hiddenStyles
  }, value);
}
function LiveRegion(_ref2) {
  let {
    id: id2,
    announcement,
    ariaLiveType = "assertive"
  } = _ref2;
  const visuallyHidden = {
    position: "fixed",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
  };
  return import_react22.default.createElement("div", {
    id: id2,
    style: visuallyHidden,
    role: "status",
    "aria-live": ariaLiveType,
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = (0, import_react22.useState)("");
  const announce = (0, import_react22.useCallback)((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}
var import_react22, hiddenStyles;
var init_accessibility_esm = __esm({
  "node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js"() {
    import_react22 = __toESM(require_react());
    hiddenStyles = {
      display: "none"
    };
  }
});

// node_modules/@dnd-kit/core/dist/core.esm.js
var core_esm_exports = {};
__export(core_esm_exports, {
  AutoScrollActivator: () => AutoScrollActivator,
  DndContext: () => DndContext,
  DragOverlay: () => DragOverlay,
  KeyboardCode: () => KeyboardCode,
  KeyboardSensor: () => KeyboardSensor,
  MeasuringFrequency: () => MeasuringFrequency,
  MeasuringStrategy: () => MeasuringStrategy,
  MouseSensor: () => MouseSensor,
  PointerSensor: () => PointerSensor,
  TouchSensor: () => TouchSensor,
  TraversalOrder: () => TraversalOrder,
  applyModifiers: () => applyModifiers,
  closestCenter: () => closestCenter,
  closestCorners: () => closestCorners,
  defaultAnnouncements: () => defaultAnnouncements,
  defaultCoordinates: () => defaultCoordinates,
  defaultDropAnimation: () => defaultDropAnimationConfiguration,
  defaultDropAnimationSideEffects: () => defaultDropAnimationSideEffects,
  defaultScreenReaderInstructions: () => defaultScreenReaderInstructions,
  getClientRect: () => getClientRect,
  getFirstCollision: () => getFirstCollision,
  getScrollableAncestors: () => getScrollableAncestors,
  pointerWithin: () => pointerWithin,
  rectIntersection: () => rectIntersection,
  useDndContext: () => useDndContext,
  useDndMonitor: () => useDndMonitor,
  useDraggable: () => useDraggable,
  useDroppable: () => useDroppable,
  useSensor: () => useSensor,
  useSensors: () => useSensors
});
function useDndMonitor(listener) {
  const registerListener = (0, import_react23.useContext)(DndMonitorContext);
  (0, import_react23.useEffect)(() => {
    if (!registerListener) {
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    }
    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}
function useDndMonitorProvider() {
  const [listeners] = (0, import_react23.useState)(() => /* @__PURE__ */ new Set());
  const registerListener = (0, import_react23.useCallback)((listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }, [listeners]);
  const dispatch = (0, import_react23.useCallback)((_ref2) => {
    let {
      type,
      event
    } = _ref2;
    listeners.forEach((listener) => {
      var _listener$type;
      return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
    });
  }, [listeners]);
  return [dispatch, registerListener];
}
function Accessibility(_ref2) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref2;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId("DndLiveRegion");
  const [mounted, setMounted] = (0, import_react23.useState)(false);
  (0, import_react23.useEffect)(() => {
    setMounted(true);
  }, []);
  useDndMonitor((0, import_react23.useMemo)(() => ({
    onDragStart(_ref22) {
      let {
        active
      } = _ref22;
      announce(announcements.onDragStart({
        active
      }));
    },
    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;
      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },
    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },
    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },
    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }
  }), [announce, announcements]));
  if (!mounted) {
    return null;
  }
  const markup = import_react23.default.createElement(import_react23.default.Fragment, null, import_react23.default.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), import_react23.default.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  }));
  return container ? (0, import_react_dom.createPortal)(markup, container) : markup;
}
function noop2() {
}
function useSensor(sensor, options) {
  return (0, import_react23.useMemo)(
    () => ({
      sensor,
      options: options != null ? options : {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [sensor, options]
  );
}
function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }
  return (0, import_react23.useMemo)(
    () => [...sensors].filter((sensor) => sensor != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...sensors]
  );
}
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function getRelativeTransformOrigin(event, rect) {
  const eventCoordinates = getEventCoordinates(event);
  if (!eventCoordinates) {
    return "0 0";
  }
  const transformOrigin = {
    x: (eventCoordinates.x - rect.left) / rect.width * 100,
    y: (eventCoordinates.y - rect.top) / rect.height * 100
  };
  return transformOrigin.x + "% " + transformOrigin.y + "%";
}
function sortCollisionsAsc(_ref2, _ref22) {
  let {
    data: {
      value: a5
    }
  } = _ref2;
  let {
    data: {
      value: b3
    }
  } = _ref22;
  return a5 - b3;
}
function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a5
    }
  } = _ref3;
  let {
    data: {
      value: b3
    }
  } = _ref4;
  return b3 - a5;
}
function cornersOfRectangle(_ref5) {
  let {
    left,
    top,
    height,
    width
  } = _ref5;
  return [{
    x: left,
    y: top
  }, {
    x: left + width,
    y: top
  }, {
    x: left,
    y: top + height
  }, {
    x: left + width,
    y: top + height
  }];
}
function getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }
  const [firstCollision] = collisions;
  return property ? firstCollision[property] : firstCollision;
}
function centerOfRectangle(rect, left, top) {
  if (left === void 0) {
    left = rect.left;
  }
  if (top === void 0) {
    top = rect.top;
  }
  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.top);
  const left = Math.max(target.left, entry.left);
  const right = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
function isPointWithinRect(point3, rect) {
  const {
    top,
    left,
    bottom,
    right
  } = rect;
  return top <= point3.y && point3.y <= bottom && left <= point3.x && point3.x <= right;
}
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), {
      ...rect
    });
  };
}
function parseTransform(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
function inverseTransform(rect, transform, transformOrigin) {
  const parsedTransform = parseTransform(transform);
  if (!parsedTransform) {
    return rect;
  }
  const {
    scaleX,
    scaleY,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x3 = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y4 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w3 = scaleX ? rect.width / scaleX : rect.width;
  const h3 = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w3,
    height: h3,
    top: y4,
    right: x3 + w3,
    bottom: y4 + h3,
    left: x3
  };
}
function getClientRect(element, options) {
  if (options === void 0) {
    options = defaultOptions3;
  }
  let rect = element.getBoundingClientRect();
  if (options.ignoreTransform) {
    const {
      transform,
      transformOrigin
    } = getWindow(element).getComputedStyle(element);
    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin);
    }
  }
  const {
    top,
    left,
    width,
    height,
    bottom,
    right
  } = rect;
  return {
    top,
    left,
    width,
    height,
    bottom,
    right
  };
}
function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}
function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isFixed(node5, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(node5).getComputedStyle(node5);
  }
  return computedStyle.position === "fixed";
}
function isScrollable(element, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(element).getComputedStyle(element);
  }
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties2 = ["overflow", "overflowX", "overflowY"];
  return properties2.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
function getScrollableAncestors(element, limit) {
  const scrollParents = [];
  function findScrollableAncestors(node5) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }
    if (!node5) {
      return scrollParents;
    }
    if (isDocument(node5) && node5.scrollingElement != null && !scrollParents.includes(node5.scrollingElement)) {
      scrollParents.push(node5.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node5) || isSVGElement(node5)) {
      return scrollParents;
    }
    if (scrollParents.includes(node5)) {
      return scrollParents;
    }
    const computedStyle = getWindow(element).getComputedStyle(node5);
    if (node5 !== element) {
      if (isScrollable(node5, computedStyle)) {
        scrollParents.push(node5);
      }
    }
    if (isFixed(node5, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node5.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node5) {
  const [firstScrollableAncestor] = getScrollableAncestors(node5, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode2(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement(element)) {
    return element;
  }
  return null;
}
function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }
  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }
  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref2, acceleration, thresholdPercentage) {
  let {
    top,
    left,
    right,
    bottom
  } = _ref2;
  if (acceleration === void 0) {
    acceleration = 10;
  }
  if (thresholdPercentage === void 0) {
    thresholdPercentage = defaultThreshold;
  }
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top <= scrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }
  if (!isRight && right >= scrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth: innerWidth2,
      innerHeight: innerHeight2
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth2,
      bottom: innerHeight2,
      width: innerWidth2,
      height: innerHeight2
    };
  }
  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node5) => {
    return add2(acc, getScrollCoordinates(node5));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node5) => {
    return acc + getScrollXCoordinate(node5);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node5) => {
    return acc + getScrollYCoordinate(node5);
  }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  if (!element) {
    return;
  }
  const {
    top,
    left,
    bottom,
    right
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);
  if (!firstScrollableAncestor) {
    return;
  }
  if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
    element.scrollIntoView({
      block: "center",
      inline: "center"
    });
  }
}
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation(event) {
  event.stopPropagation();
}
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
function useAutoScroller(_ref2) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval: interval2 = 5,
    order = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref2;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = (0, import_react23.useRef)({
    x: 0,
    y: 0
  });
  const scrollDirection = (0, import_react23.useRef)({
    x: 0,
    y: 0
  });
  const rect = (0, import_react23.useMemo)(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = (0, import_react23.useRef)(null);
  const autoScroll = (0, import_react23.useCallback)(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = (0, import_react23.useMemo)(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  (0, import_react23.useEffect)(
    () => {
      if (!enabled || !scrollableAncestors.length || !rect) {
        clearAutoScrollInterval();
        return;
      }
      for (const scrollContainer of sortedScrollableAncestors) {
        if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
          continue;
        }
        const index3 = scrollableAncestors.indexOf(scrollContainer);
        const scrollContainerRect = scrollableAncestorRects[index3];
        if (!scrollContainerRect) {
          continue;
        }
        const {
          direction,
          speed
        } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
        for (const axis of ["x", "y"]) {
          if (!scrollIntent[axis][direction[axis]]) {
            speed[axis] = 0;
            direction[axis] = 0;
          }
        }
        if (speed.x > 0 || speed.y > 0) {
          clearAutoScrollInterval();
          scrollContainerRef.current = scrollContainer;
          setAutoScrollInterval(autoScroll, interval2);
          scrollSpeed.current = speed;
          scrollDirection.current = direction;
          return;
        }
      }
      scrollSpeed.current = {
        x: 0,
        y: 0
      };
      scrollDirection.current = {
        x: 0,
        y: 0
      };
      clearAutoScrollInterval();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      acceleration,
      autoScroll,
      canScroll,
      clearAutoScrollInterval,
      enabled,
      interval2,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(rect),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(scrollIntent),
      setAutoScrollInterval,
      scrollableAncestors,
      sortedScrollableAncestors,
      scrollableAncestorRects,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(threshold)
    ]
  );
}
function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = usePrevious2(delta);
  return useLazyMemo((previousIntent) => {
    if (disabled || !previousDelta || !previousIntent) {
      return defaultScrollIntent;
    }
    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    };
    return {
      x: {
        [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
        [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
      },
      y: {
        [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
        [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}
function useCachedNode(draggableNodes, id2) {
  const draggableNode = id2 !== null ? draggableNodes.get(id2) : void 0;
  const node5 = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref2;
    if (id2 === null) {
      return null;
    }
    return (_ref2 = node5 != null ? node5 : cachedNode) != null ? _ref2 : null;
  }, [node5, id2]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return (0, import_react23.useMemo)(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
function useDroppableMeasuring(containers, _ref2) {
  let {
    dragging,
    dependencies,
    config: config2
  } = _ref2;
  const [queue2, setQueue] = (0, import_react23.useState)(null);
  const {
    frequency,
    measure,
    strategy
  } = config2;
  const containersRef = (0, import_react23.useRef)(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = (0, import_react23.useCallback)(function(ids2) {
    if (ids2 === void 0) {
      ids2 = [];
    }
    if (disabledRef.current) {
      return;
    }
    setQueue((value) => {
      if (value === null) {
        return ids2;
      }
      return value.concat(ids2.filter((id2) => !value.includes(id2)));
    });
  }, [disabledRef]);
  const timeoutId = (0, import_react23.useRef)(null);
  const droppableRects = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue2 != null) {
      const map3 = /* @__PURE__ */ new Map();
      for (let container of containers) {
        if (!container) {
          continue;
        }
        if (queue2 && queue2.length > 0 && !queue2.includes(container.id) && container.rect.current) {
          map3.set(container.id, container.rect.current);
          continue;
        }
        const node5 = container.node.current;
        const rect = node5 ? new Rect(measure(node5), node5) : null;
        container.rect.current = rect;
        if (rect) {
          map3.set(container.id, rect);
        }
      }
      return map3;
    }
    return previousValue;
  }, [containers, queue2, dragging, disabled, measure]);
  (0, import_react23.useEffect)(() => {
    containersRef.current = containers;
  }, [containers]);
  (0, import_react23.useEffect)(
    () => {
      if (disabled) {
        return;
      }
      measureDroppableContainers();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dragging, disabled]
  );
  (0, import_react23.useEffect)(
    () => {
      if (queue2 && queue2.length > 0) {
        setQueue(null);
      }
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(queue2)]
  );
  (0, import_react23.useEffect)(
    () => {
      if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
        return;
      }
      timeoutId.current = setTimeout(() => {
        measureDroppableContainers();
        timeoutId.current = null;
      }, frequency);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [frequency, disabled, measureDroppableContainers, ...dependencies]
  );
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled: queue2 != null
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function useInitialValue(value, computeFn) {
  return useLazyMemo((previousValue) => {
    if (!value) {
      return null;
    }
    if (previousValue) {
      return previousValue;
    }
    return typeof computeFn === "function" ? computeFn(value) : value;
  }, [computeFn, value]);
}
function useInitialRect(node5, measure) {
  return useInitialValue(node5, measure);
}
function useMutationObserver(_ref2) {
  let {
    callback,
    disabled
  } = _ref2;
  const handleMutations = useEvent(callback);
  const mutationObserver = (0, import_react23.useMemo)(() => {
    if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
      return void 0;
    }
    const {
      MutationObserver: MutationObserver2
    } = window;
    return new MutationObserver2(handleMutations);
  }, [handleMutations, disabled]);
  (0, import_react23.useEffect)(() => {
    return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}
function useResizeObserver(_ref2) {
  let {
    callback,
    disabled
  } = _ref2;
  const handleResize = useEvent(callback);
  const resizeObserver = (0, import_react23.useMemo)(
    () => {
      if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
        return void 0;
      }
      const {
        ResizeObserver: ResizeObserver3
      } = window;
      return new ResizeObserver3(handleResize);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [disabled]
  );
  (0, import_react23.useEffect)(() => {
    return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}
function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
  if (measure === void 0) {
    measure = defaultMeasure;
  }
  const [rect, measureRect] = (0, import_react23.useReducer)(reducer2, null);
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }
      for (const record of records) {
        const {
          type,
          target
        } = record;
        if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }
  });
  const resizeObserver = useResizeObserver({
    callback: measureRect
  });
  useIsomorphicLayoutEffect(() => {
    measureRect();
    if (element) {
      resizeObserver == null ? void 0 : resizeObserver.observe(element);
      mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }
  }, [element]);
  return rect;
  function reducer2(currentRect) {
    if (!element) {
      return null;
    }
    if (element.isConnected === false) {
      var _ref2;
      return (_ref2 = currentRect != null ? currentRect : fallbackRect) != null ? _ref2 : null;
    }
    const newRect = measure(element);
    if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
      return currentRect;
    }
    return newRect;
  }
}
function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}
function useScrollableAncestors(node5) {
  const previousNode = (0, import_react23.useRef)(node5);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node5) {
      return defaultValue$1;
    }
    if (previousValue && previousValue !== defaultValue$1 && node5 && previousNode.current && node5.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node5);
  }, [node5]);
  (0, import_react23.useEffect)(() => {
    previousNode.current = node5;
  }, [node5]);
  return ancestors;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = (0, import_react23.useState)(null);
  const prevElements = (0, import_react23.useRef)(elements);
  const handleScroll = (0, import_react23.useCallback)((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  (0, import_react23.useEffect)(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
      });
    }
  }, [handleScroll, elements]);
  return (0, import_react23.useMemo)(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add2(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }
  const initialScrollOffsets = (0, import_react23.useRef)(null);
  (0, import_react23.useEffect)(
    () => {
      initialScrollOffsets.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    dependencies
  );
  (0, import_react23.useEffect)(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }
    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
  (0, import_react23.useEffect)(
    () => {
      if (!canUseDOM) {
        return;
      }
      const teardownFns = sensors.map((_ref2) => {
        let {
          sensor
        } = _ref2;
        return sensor.setup == null ? void 0 : sensor.setup();
      });
      return () => {
        for (const teardown of teardownFns) {
          teardown == null ? void 0 : teardown();
        }
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    sensors.map((_ref2) => {
      let {
        sensor
      } = _ref2;
      return sensor;
    })
  );
}
function useSyntheticListeners(listeners, id2) {
  return (0, import_react23.useMemo)(() => {
    return listeners.reduce((acc, _ref2) => {
      let {
        eventName,
        handler
      } = _ref2;
      acc[eventName] = (event) => {
        handler(event, id2);
      };
      return acc;
    }, {});
  }, [listeners, id2]);
}
function useWindowRect(element) {
  return (0, import_react23.useMemo)(() => element ? getWindowClientRect(element) : null, [element]);
}
function useRects(elements, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
  const [rects, measureRects] = (0, import_react23.useReducer)(reducer2, defaultValue$2);
  const resizeObserver = useResizeObserver({
    callback: measureRects
  });
  if (elements.length > 0 && rects === defaultValue$2) {
    measureRects();
  }
  useIsomorphicLayoutEffect(() => {
    if (elements.length) {
      elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
    }
  }, [elements]);
  return rects;
  function reducer2() {
    if (!elements.length) {
      return defaultValue$2;
    }
    return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
  }
}
function getMeasurableNode(node5) {
  if (!node5) {
    return null;
  }
  if (node5.children.length > 1) {
    return node5;
  }
  const firstChild = node5.children[0];
  return isHTMLElement(firstChild) ? firstChild : node5;
}
function useDragOverlayMeasuring(_ref2) {
  let {
    measure
  } = _ref2;
  const [rect, setRect] = (0, import_react23.useState)(null);
  const handleResize = (0, import_react23.useCallback)((entries) => {
    for (const {
      target
    } of entries) {
      if (isHTMLElement(target)) {
        setRect((rect2) => {
          const newRect = measure(target);
          return rect2 ? {
            ...rect2,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver({
    callback: handleResize
  });
  const handleNodeChange = (0, import_react23.useCallback)((element) => {
    const node5 = getMeasurableNode(element);
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    if (node5) {
      resizeObserver == null ? void 0 : resizeObserver.observe(node5);
    }
    setRect(node5 ? measure(node5) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef] = useNodeRef(handleNodeChange);
  return (0, import_react23.useMemo)(() => ({
    nodeRef,
    rect,
    setRef
  }), [rect, nodeRef, setRef]);
}
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action3.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action3.DragMove:
      if (!state.draggable.active) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action3.DragEnd:
    case Action3.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action3.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id: id2
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action3.SetDroppableDisabled: {
      const {
        id: id2,
        key: key2,
        disabled
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key2 !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action3.UnregisterDroppable: {
      const {
        id: id2,
        key: key2
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key2 !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id2);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
function RestoreFocus(_ref2) {
  let {
    disabled
  } = _ref2;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = (0, import_react23.useContext)(InternalContext);
  const previousActivatorEvent = usePrevious2(activatorEvent);
  const previousActiveId = usePrevious2(active == null ? void 0 : active.id);
  (0, import_react23.useEffect)(() => {
    if (disabled) {
      return;
    }
    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!isKeyboardEvent(previousActivatorEvent)) {
        return;
      }
      if (document.activeElement === previousActivatorEvent.target) {
        return;
      }
      const draggableNode = draggableNodes.get(previousActiveId);
      if (!draggableNode) {
        return;
      }
      const {
        activatorNode,
        node: node5
      } = draggableNode;
      if (!activatorNode.current && !node5.current) {
        return;
      }
      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node5.current]) {
          if (!element) {
            continue;
          }
          const focusableNode = findFirstFocusableNode(element);
          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}
function applyModifiers(modifiers, _ref2) {
  let {
    transform,
    ...args
  } = _ref2;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
function useMeasuringConfiguration(config2) {
  return (0, import_react23.useMemo)(
    () => ({
      draggable: {
        ...defaultMeasuringConfiguration.draggable,
        ...config2 == null ? void 0 : config2.draggable
      },
      droppable: {
        ...defaultMeasuringConfiguration.droppable,
        ...config2 == null ? void 0 : config2.droppable
      },
      dragOverlay: {
        ...defaultMeasuringConfiguration.dragOverlay,
        ...config2 == null ? void 0 : config2.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [config2 == null ? void 0 : config2.draggable, config2 == null ? void 0 : config2.droppable, config2 == null ? void 0 : config2.dragOverlay]
  );
}
function useLayoutShiftScrollCompensation(_ref2) {
  let {
    activeNode,
    measure,
    initialRect,
    config: config2 = true
  } = _ref2;
  const initialized = (0, import_react23.useRef)(false);
  const {
    x: x3,
    y: y4
  } = typeof config2 === "boolean" ? {
    x: config2,
    y: config2
  } : config2;
  useIsomorphicLayoutEffect(() => {
    const disabled = !x3 && !y4;
    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }
    if (initialized.current || !initialRect) {
      return;
    }
    const node5 = activeNode == null ? void 0 : activeNode.node.current;
    if (!node5 || node5.isConnected === false) {
      return;
    }
    const rect = measure(node5);
    const rectDelta = getRectDelta(rect, initialRect);
    if (!x3) {
      rectDelta.x = 0;
    }
    if (!y4) {
      rectDelta.y = 0;
    }
    initialized.current = true;
    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node5);
      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x3, y4, initialRect, measure]);
}
function useDraggable(_ref2) {
  let {
    id: id2,
    data,
    disabled = false,
    attributes
  } = _ref2;
  const key2 = useUniqueId(ID_PREFIX);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = (0, import_react23.useContext)(InternalContext);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id2;
  const transform = (0, import_react23.useContext)(isDragging ? ActiveDraggableContext : NullContext);
  const [node5, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id2);
  const dataRef = useLatestValue(data);
  useIsomorphicLayoutEffect(
    () => {
      draggableNodes.set(id2, {
        id: id2,
        key: key2,
        node: node5,
        activatorNode,
        data: dataRef
      });
      return () => {
        const node6 = draggableNodes.get(id2);
        if (node6 && node6.key === key2) {
          draggableNodes.delete(id2);
        }
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [draggableNodes, id2]
  );
  const memoizedAttributes = (0, import_react23.useMemo)(() => ({
    role,
    tabIndex,
    "aria-disabled": disabled,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node: node5,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}
function useDndContext() {
  return (0, import_react23.useContext)(PublicContext);
}
function useDroppable(_ref2) {
  let {
    data,
    disabled = false,
    id: id2,
    resizeObserverConfig
  } = _ref2;
  const key2 = useUniqueId(ID_PREFIX$1);
  const {
    active,
    dispatch,
    over,
    measureDroppableContainers
  } = (0, import_react23.useContext)(InternalContext);
  const previous3 = (0, import_react23.useRef)({
    disabled
  });
  const resizeObserverConnected = (0, import_react23.useRef)(false);
  const rect = (0, import_react23.useRef)(null);
  const callbackId = (0, import_react23.useRef)(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = {
    ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id2);
  const handleResize = (0, import_react23.useCallback)(
    () => {
      if (!resizeObserverConnected.current) {
        resizeObserverConnected.current = true;
        return;
      }
      if (callbackId.current != null) {
        clearTimeout(callbackId.current);
      }
      callbackId.current = setTimeout(() => {
        measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
        callbackId.current = null;
      }, resizeObserverTimeout);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [resizeObserverTimeout]
  );
  const resizeObserver = useResizeObserver({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = (0, import_react23.useCallback)((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }
    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }
    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  (0, import_react23.useEffect)(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }
    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  useIsomorphicLayoutEffect(
    () => {
      dispatch({
        type: Action3.RegisterDroppable,
        element: {
          id: id2,
          key: key2,
          disabled,
          node: nodeRef,
          rect,
          data: dataRef
        }
      });
      return () => dispatch({
        type: Action3.UnregisterDroppable,
        key: key2,
        id: id2
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [id2]
  );
  (0, import_react23.useEffect)(() => {
    if (disabled !== previous3.current.disabled) {
      dispatch({
        type: Action3.SetDroppableDisabled,
        id: id2,
        key: key2,
        disabled
      });
      previous3.current.disabled = disabled;
    }
  }, [id2, key2, disabled, dispatch]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id2,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function AnimationManager(_ref2) {
  let {
    animation: animation2,
    children
  } = _ref2;
  const [clonedChildren, setClonedChildren] = (0, import_react23.useState)(null);
  const [element, setElement] = (0, import_react23.useState)(null);
  const previousChildren = usePrevious2(children);
  if (!children && !clonedChildren && previousChildren) {
    setClonedChildren(previousChildren);
  }
  useIsomorphicLayoutEffect(() => {
    if (!element) {
      return;
    }
    const key2 = clonedChildren == null ? void 0 : clonedChildren.key;
    const id2 = clonedChildren == null ? void 0 : clonedChildren.props.id;
    if (key2 == null || id2 == null) {
      setClonedChildren(null);
      return;
    }
    Promise.resolve(animation2(id2, element)).then(() => {
      setClonedChildren(null);
    });
  }, [animation2, clonedChildren, element]);
  return import_react23.default.createElement(import_react23.default.Fragment, null, children, clonedChildren ? (0, import_react23.cloneElement)(clonedChildren, {
    ref: setElement
  }) : null);
}
function NullifiedContextProvider(_ref2) {
  let {
    children
  } = _ref2;
  return import_react23.default.createElement(InternalContext.Provider, {
    value: defaultInternalContext
  }, import_react23.default.createElement(ActiveDraggableContext.Provider, {
    value: defaultTransform
  }, children));
}
function useDropAnimation(_ref3) {
  let {
    config: config2,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  } = _ref3;
  return useEvent((id2, node5) => {
    if (config2 === null) {
      return;
    }
    const activeDraggable = draggableNodes.get(id2);
    if (!activeDraggable) {
      return;
    }
    const activeNode = activeDraggable.node.current;
    if (!activeNode) {
      return;
    }
    const measurableNode = getMeasurableNode(node5);
    if (!measurableNode) {
      return;
    }
    const {
      transform
    } = getWindow(node5).getComputedStyle(node5);
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
      return;
    }
    const animation2 = typeof config2 === "function" ? config2 : createDefaultDropAnimation(config2);
    scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);
    return animation2({
      active: {
        id: id2,
        data: activeDraggable.data,
        node: activeNode,
        rect: measuringConfiguration.draggable.measure(activeNode)
      },
      draggableNodes,
      dragOverlay: {
        node: node5,
        rect: measuringConfiguration.dragOverlay.measure(measurableNode)
      },
      droppableContainers,
      measuringConfiguration,
      transform: parsedTransform
    });
  });
}
function createDefaultDropAnimation(options) {
  const {
    duration,
    easing,
    sideEffects,
    keyframes
  } = {
    ...defaultDropAnimationConfiguration,
    ...options
  };
  return (_ref4) => {
    let {
      active,
      dragOverlay,
      transform,
      ...rest
    } = _ref4;
    if (!duration) {
      return;
    }
    const delta = {
      x: dragOverlay.rect.left - active.rect.left,
      y: dragOverlay.rect.top - active.rect.top
    };
    const scale = {
      scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,
      scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1
    };
    const finalTransform = {
      x: transform.x - delta.x,
      y: transform.y - delta.y,
      ...scale
    };
    const animationKeyframes = keyframes({
      ...rest,
      active,
      dragOverlay,
      transform: {
        initial: transform,
        final: finalTransform
      }
    });
    const [firstKeyframe] = animationKeyframes;
    const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];
    if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {
      return;
    }
    const cleanup = sideEffects == null ? void 0 : sideEffects({
      active,
      dragOverlay,
      ...rest
    });
    const animation2 = dragOverlay.node.animate(animationKeyframes, {
      duration,
      easing,
      fill: "forwards"
    });
    return new Promise((resolve) => {
      animation2.onfinish = () => {
        cleanup == null ? void 0 : cleanup();
        resolve();
      };
    });
  };
}
function useKey(id2) {
  return (0, import_react23.useMemo)(() => {
    if (id2 == null) {
      return;
    }
    key++;
    return key;
  }, [id2]);
}
var import_react23, import_react_dom, DndMonitorContext, defaultScreenReaderInstructions, defaultAnnouncements, Action3, defaultCoordinates, closestCenter, closestCorners, rectIntersection, pointerWithin, getAdjustedRect, defaultOptions3, Direction, defaultThreshold, properties, Rect, Listeners, EventName, KeyboardCode, defaultKeyboardCodes, defaultKeyboardCoordinateGetter, KeyboardSensor, AbstractPointerSensor, events2, PointerSensor, events$1, MouseButton, MouseSensor, events$2, TouchSensor, AutoScrollActivator, TraversalOrder, defaultScrollIntent, MeasuringStrategy, MeasuringFrequency, defaultValue, defaultValue$1, defaultValue$2, defaultSensors, defaultData, defaultMeasuringConfiguration, DroppableContainersMap, defaultPublicContext, defaultInternalContext, InternalContext, PublicContext, ActiveDraggableContext, Status, DndContext, NullContext, defaultRole, ID_PREFIX, ID_PREFIX$1, defaultResizeObserverConfig, defaultTransform, baseStyles, defaultTransition, PositionedOverlay, defaultDropAnimationSideEffects, defaultKeyframeResolver, defaultDropAnimationConfiguration, key, DragOverlay;
var init_core_esm = __esm({
  "node_modules/@dnd-kit/core/dist/core.esm.js"() {
    import_react23 = __toESM(require_react());
    import_react_dom = __toESM(require_react_dom());
    init_utilities_esm();
    init_accessibility_esm();
    DndMonitorContext = (0, import_react23.createContext)(null);
    defaultScreenReaderInstructions = {
      draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
    };
    defaultAnnouncements = {
      onDragStart(_ref2) {
        let {
          active
        } = _ref2;
        return "Picked up draggable item " + active.id + ".";
      },
      onDragOver(_ref2) {
        let {
          active,
          over
        } = _ref2;
        if (over) {
          return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
        }
        return "Draggable item " + active.id + " is no longer over a droppable area.";
      },
      onDragEnd(_ref3) {
        let {
          active,
          over
        } = _ref3;
        if (over) {
          return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
        }
        return "Draggable item " + active.id + " was dropped.";
      },
      onDragCancel(_ref4) {
        let {
          active
        } = _ref4;
        return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
      }
    };
    (function(Action4) {
      Action4["DragStart"] = "dragStart";
      Action4["DragMove"] = "dragMove";
      Action4["DragEnd"] = "dragEnd";
      Action4["DragCancel"] = "dragCancel";
      Action4["DragOver"] = "dragOver";
      Action4["RegisterDroppable"] = "registerDroppable";
      Action4["SetDroppableDisabled"] = "setDroppableDisabled";
      Action4["UnregisterDroppable"] = "unregisterDroppable";
    })(Action3 || (Action3 = {}));
    defaultCoordinates = Object.freeze({
      x: 0,
      y: 0
    });
    closestCenter = (_ref2) => {
      let {
        collisionRect,
        droppableRects,
        droppableContainers
      } = _ref2;
      const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
      const collisions = [];
      for (const droppableContainer of droppableContainers) {
        const {
          id: id2
        } = droppableContainer;
        const rect = droppableRects.get(id2);
        if (rect) {
          const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
          collisions.push({
            id: id2,
            data: {
              droppableContainer,
              value: distBetween
            }
          });
        }
      }
      return collisions.sort(sortCollisionsAsc);
    };
    closestCorners = (_ref2) => {
      let {
        collisionRect,
        droppableRects,
        droppableContainers
      } = _ref2;
      const corners = cornersOfRectangle(collisionRect);
      const collisions = [];
      for (const droppableContainer of droppableContainers) {
        const {
          id: id2
        } = droppableContainer;
        const rect = droppableRects.get(id2);
        if (rect) {
          const rectCorners = cornersOfRectangle(rect);
          const distances = corners.reduce((accumulator, corner, index3) => {
            return accumulator + distanceBetween(rectCorners[index3], corner);
          }, 0);
          const effectiveDistance = Number((distances / 4).toFixed(4));
          collisions.push({
            id: id2,
            data: {
              droppableContainer,
              value: effectiveDistance
            }
          });
        }
      }
      return collisions.sort(sortCollisionsAsc);
    };
    rectIntersection = (_ref2) => {
      let {
        collisionRect,
        droppableRects,
        droppableContainers
      } = _ref2;
      const collisions = [];
      for (const droppableContainer of droppableContainers) {
        const {
          id: id2
        } = droppableContainer;
        const rect = droppableRects.get(id2);
        if (rect) {
          const intersectionRatio = getIntersectionRatio(rect, collisionRect);
          if (intersectionRatio > 0) {
            collisions.push({
              id: id2,
              data: {
                droppableContainer,
                value: intersectionRatio
              }
            });
          }
        }
      }
      return collisions.sort(sortCollisionsDesc);
    };
    pointerWithin = (_ref2) => {
      let {
        droppableContainers,
        droppableRects,
        pointerCoordinates
      } = _ref2;
      if (!pointerCoordinates) {
        return [];
      }
      const collisions = [];
      for (const droppableContainer of droppableContainers) {
        const {
          id: id2
        } = droppableContainer;
        const rect = droppableRects.get(id2);
        if (rect && isPointWithinRect(pointerCoordinates, rect)) {
          const corners = cornersOfRectangle(rect);
          const distances = corners.reduce((accumulator, corner) => {
            return accumulator + distanceBetween(pointerCoordinates, corner);
          }, 0);
          const effectiveDistance = Number((distances / 4).toFixed(4));
          collisions.push({
            id: id2,
            data: {
              droppableContainer,
              value: effectiveDistance
            }
          });
        }
      }
      return collisions.sort(sortCollisionsAsc);
    };
    getAdjustedRect = createRectAdjustmentFn(1);
    defaultOptions3 = {
      ignoreTransform: false
    };
    (function(Direction2) {
      Direction2[Direction2["Forward"] = 1] = "Forward";
      Direction2[Direction2["Backward"] = -1] = "Backward";
    })(Direction || (Direction = {}));
    defaultThreshold = {
      x: 0.2,
      y: 0.2
    };
    properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
    Rect = class {
      constructor(rect, element) {
        this.rect = void 0;
        this.width = void 0;
        this.height = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.right = void 0;
        this.left = void 0;
        const scrollableAncestors = getScrollableAncestors(element);
        const scrollOffsets = getScrollOffsets(scrollableAncestors);
        this.rect = {
          ...rect
        };
        this.width = rect.width;
        this.height = rect.height;
        for (const [axis, keys2, getScrollOffset] of properties) {
          for (const key2 of keys2) {
            Object.defineProperty(this, key2, {
              get: () => {
                const currentOffsets = getScrollOffset(scrollableAncestors);
                const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
                return this.rect[key2] + scrollOffsetsDeltla;
              },
              enumerable: true
            });
          }
        }
        Object.defineProperty(this, "rect", {
          enumerable: false
        });
      }
    };
    Listeners = class {
      constructor(target) {
        this.target = void 0;
        this.listeners = [];
        this.removeAll = () => {
          this.listeners.forEach((listener) => {
            var _this$target;
            return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
          });
        };
        this.target = target;
      }
      add(eventName, handler, options) {
        var _this$target2;
        (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
        this.listeners.push([eventName, handler, options]);
      }
    };
    (function(EventName2) {
      EventName2["Click"] = "click";
      EventName2["DragStart"] = "dragstart";
      EventName2["Keydown"] = "keydown";
      EventName2["ContextMenu"] = "contextmenu";
      EventName2["Resize"] = "resize";
      EventName2["SelectionChange"] = "selectionchange";
      EventName2["VisibilityChange"] = "visibilitychange";
    })(EventName || (EventName = {}));
    (function(KeyboardCode2) {
      KeyboardCode2["Space"] = "Space";
      KeyboardCode2["Down"] = "ArrowDown";
      KeyboardCode2["Right"] = "ArrowRight";
      KeyboardCode2["Left"] = "ArrowLeft";
      KeyboardCode2["Up"] = "ArrowUp";
      KeyboardCode2["Esc"] = "Escape";
      KeyboardCode2["Enter"] = "Enter";
    })(KeyboardCode || (KeyboardCode = {}));
    defaultKeyboardCodes = {
      start: [KeyboardCode.Space, KeyboardCode.Enter],
      cancel: [KeyboardCode.Esc],
      end: [KeyboardCode.Space, KeyboardCode.Enter]
    };
    defaultKeyboardCoordinateGetter = (event, _ref2) => {
      let {
        currentCoordinates
      } = _ref2;
      switch (event.code) {
        case KeyboardCode.Right:
          return {
            ...currentCoordinates,
            x: currentCoordinates.x + 25
          };
        case KeyboardCode.Left:
          return {
            ...currentCoordinates,
            x: currentCoordinates.x - 25
          };
        case KeyboardCode.Down:
          return {
            ...currentCoordinates,
            y: currentCoordinates.y + 25
          };
        case KeyboardCode.Up:
          return {
            ...currentCoordinates,
            y: currentCoordinates.y - 25
          };
      }
      return void 0;
    };
    KeyboardSensor = class {
      constructor(props) {
        this.props = void 0;
        this.autoScrollEnabled = false;
        this.referenceCoordinates = void 0;
        this.listeners = void 0;
        this.windowListeners = void 0;
        this.props = props;
        const {
          event: {
            target
          }
        } = props;
        this.props = props;
        this.listeners = new Listeners(getOwnerDocument(target));
        this.windowListeners = new Listeners(getWindow(target));
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleCancel = this.handleCancel.bind(this);
        this.attach();
      }
      attach() {
        this.handleStart();
        this.windowListeners.add(EventName.Resize, this.handleCancel);
        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
        setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
      }
      handleStart() {
        const {
          activeNode,
          onStart
        } = this.props;
        const node5 = activeNode.node.current;
        if (node5) {
          scrollIntoViewIfNeeded(node5);
        }
        onStart(defaultCoordinates);
      }
      handleKeyDown(event) {
        if (isKeyboardEvent(event)) {
          const {
            active,
            context: context2,
            options
          } = this.props;
          const {
            keyboardCodes = defaultKeyboardCodes,
            coordinateGetter = defaultKeyboardCoordinateGetter,
            scrollBehavior = "smooth"
          } = options;
          const {
            code
          } = event;
          if (keyboardCodes.end.includes(code)) {
            this.handleEnd(event);
            return;
          }
          if (keyboardCodes.cancel.includes(code)) {
            this.handleCancel(event);
            return;
          }
          const {
            collisionRect
          } = context2.current;
          const currentCoordinates = collisionRect ? {
            x: collisionRect.left,
            y: collisionRect.top
          } : defaultCoordinates;
          if (!this.referenceCoordinates) {
            this.referenceCoordinates = currentCoordinates;
          }
          const newCoordinates = coordinateGetter(event, {
            active,
            context: context2.current,
            currentCoordinates
          });
          if (newCoordinates) {
            const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
            const scrollDelta = {
              x: 0,
              y: 0
            };
            const {
              scrollableAncestors
            } = context2.current;
            for (const scrollContainer of scrollableAncestors) {
              const direction = event.code;
              const {
                isTop,
                isRight,
                isLeft,
                isBottom,
                maxScroll,
                minScroll
              } = getScrollPosition(scrollContainer);
              const scrollElementRect = getScrollElementRect(scrollContainer);
              const clampedCoordinates = {
                x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
                y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
              };
              const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
              const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
              if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
                const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
                const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
                if (canScrollToNewCoordinates && !coordinatesDelta.y) {
                  scrollContainer.scrollTo({
                    left: newScrollCoordinates,
                    behavior: scrollBehavior
                  });
                  return;
                }
                if (canScrollToNewCoordinates) {
                  scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
                } else {
                  scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
                }
                if (scrollDelta.x) {
                  scrollContainer.scrollBy({
                    left: -scrollDelta.x,
                    behavior: scrollBehavior
                  });
                }
                break;
              } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
                const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
                const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
                if (canScrollToNewCoordinates && !coordinatesDelta.x) {
                  scrollContainer.scrollTo({
                    top: newScrollCoordinates,
                    behavior: scrollBehavior
                  });
                  return;
                }
                if (canScrollToNewCoordinates) {
                  scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
                } else {
                  scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
                }
                if (scrollDelta.y) {
                  scrollContainer.scrollBy({
                    top: -scrollDelta.y,
                    behavior: scrollBehavior
                  });
                }
                break;
              }
            }
            this.handleMove(event, add2(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
          }
        }
      }
      handleMove(event, coordinates) {
        const {
          onMove
        } = this.props;
        event.preventDefault();
        onMove(coordinates);
      }
      handleEnd(event) {
        const {
          onEnd
        } = this.props;
        event.preventDefault();
        this.detach();
        onEnd();
      }
      handleCancel(event) {
        const {
          onCancel
        } = this.props;
        event.preventDefault();
        this.detach();
        onCancel();
      }
      detach() {
        this.listeners.removeAll();
        this.windowListeners.removeAll();
      }
    };
    KeyboardSensor.activators = [{
      eventName: "onKeyDown",
      handler: (event, _ref2, _ref22) => {
        let {
          keyboardCodes = defaultKeyboardCodes,
          onActivation
        } = _ref2;
        let {
          active
        } = _ref22;
        const {
          code
        } = event.nativeEvent;
        if (keyboardCodes.start.includes(code)) {
          const activator = active.activatorNode.current;
          if (activator && event.target !== activator) {
            return false;
          }
          event.preventDefault();
          onActivation == null ? void 0 : onActivation({
            event: event.nativeEvent
          });
          return true;
        }
        return false;
      }
    }];
    AbstractPointerSensor = class {
      constructor(props, events3, listenerTarget) {
        var _getEventCoordinates;
        if (listenerTarget === void 0) {
          listenerTarget = getEventListenerTarget(props.event.target);
        }
        this.props = void 0;
        this.events = void 0;
        this.autoScrollEnabled = true;
        this.document = void 0;
        this.activated = false;
        this.initialCoordinates = void 0;
        this.timeoutId = null;
        this.listeners = void 0;
        this.documentListeners = void 0;
        this.windowListeners = void 0;
        this.props = props;
        this.events = events3;
        const {
          event
        } = props;
        const {
          target
        } = event;
        this.props = props;
        this.events = events3;
        this.document = getOwnerDocument(target);
        this.documentListeners = new Listeners(this.document);
        this.listeners = new Listeners(listenerTarget);
        this.windowListeners = new Listeners(getWindow(target));
        this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
        this.handleStart = this.handleStart.bind(this);
        this.handleMove = this.handleMove.bind(this);
        this.handleEnd = this.handleEnd.bind(this);
        this.handleCancel = this.handleCancel.bind(this);
        this.handleKeydown = this.handleKeydown.bind(this);
        this.removeTextSelection = this.removeTextSelection.bind(this);
        this.attach();
      }
      attach() {
        const {
          events: events3,
          props: {
            options: {
              activationConstraint,
              bypassActivationConstraint
            }
          }
        } = this;
        this.listeners.add(events3.move.name, this.handleMove, {
          passive: false
        });
        this.listeners.add(events3.end.name, this.handleEnd);
        this.windowListeners.add(EventName.Resize, this.handleCancel);
        this.windowListeners.add(EventName.DragStart, preventDefault);
        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
        this.windowListeners.add(EventName.ContextMenu, preventDefault);
        this.documentListeners.add(EventName.Keydown, this.handleKeydown);
        if (activationConstraint) {
          if (bypassActivationConstraint != null && bypassActivationConstraint({
            event: this.props.event,
            activeNode: this.props.activeNode,
            options: this.props.options
          })) {
            return this.handleStart();
          }
          if (isDelayConstraint(activationConstraint)) {
            this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
            return;
          }
          if (isDistanceConstraint(activationConstraint)) {
            return;
          }
        }
        this.handleStart();
      }
      detach() {
        this.listeners.removeAll();
        this.windowListeners.removeAll();
        setTimeout(this.documentListeners.removeAll, 50);
        if (this.timeoutId !== null) {
          clearTimeout(this.timeoutId);
          this.timeoutId = null;
        }
      }
      handleStart() {
        const {
          initialCoordinates
        } = this;
        const {
          onStart
        } = this.props;
        if (initialCoordinates) {
          this.activated = true;
          this.documentListeners.add(EventName.Click, stopPropagation, {
            capture: true
          });
          this.removeTextSelection();
          this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
          onStart(initialCoordinates);
        }
      }
      handleMove(event) {
        var _getEventCoordinates2;
        const {
          activated,
          initialCoordinates,
          props
        } = this;
        const {
          onMove,
          options: {
            activationConstraint
          }
        } = props;
        if (!initialCoordinates) {
          return;
        }
        const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
        const delta = subtract(initialCoordinates, coordinates);
        if (!activated && activationConstraint) {
          if (isDistanceConstraint(activationConstraint)) {
            if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
              return this.handleCancel();
            }
            if (hasExceededDistance(delta, activationConstraint.distance)) {
              return this.handleStart();
            }
          }
          if (isDelayConstraint(activationConstraint)) {
            if (hasExceededDistance(delta, activationConstraint.tolerance)) {
              return this.handleCancel();
            }
          }
          return;
        }
        if (event.cancelable) {
          event.preventDefault();
        }
        onMove(coordinates);
      }
      handleEnd() {
        const {
          onEnd
        } = this.props;
        this.detach();
        onEnd();
      }
      handleCancel() {
        const {
          onCancel
        } = this.props;
        this.detach();
        onCancel();
      }
      handleKeydown(event) {
        if (event.code === KeyboardCode.Esc) {
          this.handleCancel();
        }
      }
      removeTextSelection() {
        var _this$document$getSel;
        (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
      }
    };
    events2 = {
      move: {
        name: "pointermove"
      },
      end: {
        name: "pointerup"
      }
    };
    PointerSensor = class extends AbstractPointerSensor {
      constructor(props) {
        const {
          event
        } = props;
        const listenerTarget = getOwnerDocument(event.target);
        super(props, events2, listenerTarget);
      }
    };
    PointerSensor.activators = [{
      eventName: "onPointerDown",
      handler: (_ref2, _ref22) => {
        let {
          nativeEvent: event
        } = _ref2;
        let {
          onActivation
        } = _ref22;
        if (!event.isPrimary || event.button !== 0) {
          return false;
        }
        onActivation == null ? void 0 : onActivation({
          event
        });
        return true;
      }
    }];
    events$1 = {
      move: {
        name: "mousemove"
      },
      end: {
        name: "mouseup"
      }
    };
    (function(MouseButton2) {
      MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
    })(MouseButton || (MouseButton = {}));
    MouseSensor = class extends AbstractPointerSensor {
      constructor(props) {
        super(props, events$1, getOwnerDocument(props.event.target));
      }
    };
    MouseSensor.activators = [{
      eventName: "onMouseDown",
      handler: (_ref2, _ref22) => {
        let {
          nativeEvent: event
        } = _ref2;
        let {
          onActivation
        } = _ref22;
        if (event.button === MouseButton.RightClick) {
          return false;
        }
        onActivation == null ? void 0 : onActivation({
          event
        });
        return true;
      }
    }];
    events$2 = {
      move: {
        name: "touchmove"
      },
      end: {
        name: "touchend"
      }
    };
    TouchSensor = class extends AbstractPointerSensor {
      constructor(props) {
        super(props, events$2);
      }
      static setup() {
        window.addEventListener(events$2.move.name, noop3, {
          capture: false,
          passive: false
        });
        return function teardown() {
          window.removeEventListener(events$2.move.name, noop3);
        };
        function noop3() {
        }
      }
    };
    TouchSensor.activators = [{
      eventName: "onTouchStart",
      handler: (_ref2, _ref22) => {
        let {
          nativeEvent: event
        } = _ref2;
        let {
          onActivation
        } = _ref22;
        const {
          touches
        } = event;
        if (touches.length > 1) {
          return false;
        }
        onActivation == null ? void 0 : onActivation({
          event
        });
        return true;
      }
    }];
    (function(AutoScrollActivator2) {
      AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
      AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
    })(AutoScrollActivator || (AutoScrollActivator = {}));
    (function(TraversalOrder2) {
      TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
      TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
    })(TraversalOrder || (TraversalOrder = {}));
    defaultScrollIntent = {
      x: {
        [Direction.Backward]: false,
        [Direction.Forward]: false
      },
      y: {
        [Direction.Backward]: false,
        [Direction.Forward]: false
      }
    };
    (function(MeasuringStrategy2) {
      MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
      MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
      MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
    })(MeasuringStrategy || (MeasuringStrategy = {}));
    (function(MeasuringFrequency2) {
      MeasuringFrequency2["Optimized"] = "optimized";
    })(MeasuringFrequency || (MeasuringFrequency = {}));
    defaultValue = /* @__PURE__ */ new Map();
    defaultValue$1 = [];
    defaultValue$2 = [];
    defaultSensors = [{
      sensor: PointerSensor,
      options: {}
    }, {
      sensor: KeyboardSensor,
      options: {}
    }];
    defaultData = {
      current: {}
    };
    defaultMeasuringConfiguration = {
      draggable: {
        measure: getTransformAgnosticClientRect
      },
      droppable: {
        measure: getTransformAgnosticClientRect,
        strategy: MeasuringStrategy.WhileDragging,
        frequency: MeasuringFrequency.Optimized
      },
      dragOverlay: {
        measure: getClientRect
      }
    };
    DroppableContainersMap = class extends Map {
      get(id2) {
        var _super$get;
        return id2 != null ? (_super$get = super.get(id2)) != null ? _super$get : void 0 : void 0;
      }
      toArray() {
        return Array.from(this.values());
      }
      getEnabled() {
        return this.toArray().filter((_ref2) => {
          let {
            disabled
          } = _ref2;
          return !disabled;
        });
      }
      getNodeFor(id2) {
        var _this$get$node$curren, _this$get;
        return (_this$get$node$curren = (_this$get = this.get(id2)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
      }
    };
    defaultPublicContext = {
      activatorEvent: null,
      active: null,
      activeNode: null,
      activeNodeRect: null,
      collisions: null,
      containerNodeRect: null,
      draggableNodes: /* @__PURE__ */ new Map(),
      droppableRects: /* @__PURE__ */ new Map(),
      droppableContainers: new DroppableContainersMap(),
      over: null,
      dragOverlay: {
        nodeRef: {
          current: null
        },
        rect: null,
        setRef: noop2
      },
      scrollableAncestors: [],
      scrollableAncestorRects: [],
      measuringConfiguration: defaultMeasuringConfiguration,
      measureDroppableContainers: noop2,
      windowRect: null,
      measuringScheduled: false
    };
    defaultInternalContext = {
      activatorEvent: null,
      activators: [],
      active: null,
      activeNodeRect: null,
      ariaDescribedById: {
        draggable: ""
      },
      dispatch: noop2,
      draggableNodes: /* @__PURE__ */ new Map(),
      over: null,
      measureDroppableContainers: noop2
    };
    InternalContext = (0, import_react23.createContext)(defaultInternalContext);
    PublicContext = (0, import_react23.createContext)(defaultPublicContext);
    ActiveDraggableContext = (0, import_react23.createContext)({
      ...defaultCoordinates,
      scaleX: 1,
      scaleY: 1
    });
    (function(Status2) {
      Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
      Status2[Status2["Initializing"] = 1] = "Initializing";
      Status2[Status2["Initialized"] = 2] = "Initialized";
    })(Status || (Status = {}));
    DndContext = (0, import_react23.memo)(function DndContext2(_ref2) {
      var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
      let {
        id: id2,
        accessibility,
        autoScroll = true,
        children,
        sensors = defaultSensors,
        collisionDetection = rectIntersection,
        measuring,
        modifiers,
        ...props
      } = _ref2;
      const store = (0, import_react23.useReducer)(reducer, void 0, getInitialState);
      const [state, dispatch] = store;
      const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
      const [status, setStatus] = (0, import_react23.useState)(Status.Uninitialized);
      const isInitialized = status === Status.Initialized;
      const {
        draggable: {
          active: activeId,
          nodes: draggableNodes,
          translate
        },
        droppable: {
          containers: droppableContainers
        }
      } = state;
      const node5 = activeId ? draggableNodes.get(activeId) : null;
      const activeRects = (0, import_react23.useRef)({
        initial: null,
        translated: null
      });
      const active = (0, import_react23.useMemo)(() => {
        var _node$data;
        return activeId != null ? {
          id: activeId,
          // It's possible for the active node to unmount while dragging
          data: (_node$data = node5 == null ? void 0 : node5.data) != null ? _node$data : defaultData,
          rect: activeRects
        } : null;
      }, [activeId, node5]);
      const activeRef = (0, import_react23.useRef)(null);
      const [activeSensor, setActiveSensor] = (0, import_react23.useState)(null);
      const [activatorEvent, setActivatorEvent] = (0, import_react23.useState)(null);
      const latestProps = useLatestValue(props, Object.values(props));
      const draggableDescribedById = useUniqueId("DndDescribedBy", id2);
      const enabledDroppableContainers = (0, import_react23.useMemo)(() => droppableContainers.getEnabled(), [droppableContainers]);
      const measuringConfiguration = useMeasuringConfiguration(measuring);
      const {
        droppableRects,
        measureDroppableContainers,
        measuringScheduled
      } = useDroppableMeasuring(enabledDroppableContainers, {
        dragging: isInitialized,
        dependencies: [translate.x, translate.y],
        config: measuringConfiguration.droppable
      });
      const activeNode = useCachedNode(draggableNodes, activeId);
      const activationCoordinates = (0, import_react23.useMemo)(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
      const autoScrollOptions = getAutoScrollerOptions();
      const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
      useLayoutShiftScrollCompensation({
        activeNode: activeId ? draggableNodes.get(activeId) : null,
        config: autoScrollOptions.layoutShiftCompensation,
        initialRect: initialActiveNodeRect,
        measure: measuringConfiguration.draggable.measure
      });
      const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
      const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
      const sensorContext = (0, import_react23.useRef)({
        activatorEvent: null,
        active: null,
        activeNode,
        collisionRect: null,
        collisions: null,
        droppableRects,
        draggableNodes,
        draggingNode: null,
        draggingNodeRect: null,
        droppableContainers,
        over: null,
        scrollableAncestors: [],
        scrollAdjustedTranslate: null
      });
      const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
      const dragOverlay = useDragOverlayMeasuring({
        measure: measuringConfiguration.dragOverlay.measure
      });
      const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
      const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
      const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
      const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
      const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
      const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
      const scrollableAncestorRects = useRects(scrollableAncestors);
      const modifiedTranslate = applyModifiers(modifiers, {
        transform: {
          x: translate.x - nodeRectDelta.x,
          y: translate.y - nodeRectDelta.y,
          scaleX: 1,
          scaleY: 1
        },
        activatorEvent,
        active,
        activeNodeRect,
        containerNodeRect,
        draggingNodeRect,
        over: sensorContext.current.over,
        overlayNodeRect: dragOverlay.rect,
        scrollableAncestors,
        scrollableAncestorRects,
        windowRect
      });
      const pointerCoordinates = activationCoordinates ? add2(activationCoordinates, translate) : null;
      const scrollOffsets = useScrollOffsets(scrollableAncestors);
      const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
      const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
      const scrollAdjustedTranslate = add2(modifiedTranslate, scrollAdjustment);
      const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
      const collisions = active && collisionRect ? collisionDetection({
        active,
        collisionRect,
        droppableRects,
        droppableContainers: enabledDroppableContainers,
        pointerCoordinates
      }) : null;
      const overId = getFirstCollision(collisions, "id");
      const [over, setOver] = (0, import_react23.useState)(null);
      const appliedTranslate = usesDragOverlay ? modifiedTranslate : add2(modifiedTranslate, activeNodeScrollDelta);
      const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
      const instantiateSensor = (0, import_react23.useCallback)(
        (event, _ref22) => {
          let {
            sensor: Sensor,
            options
          } = _ref22;
          if (activeRef.current == null) {
            return;
          }
          const activeNode2 = draggableNodes.get(activeRef.current);
          if (!activeNode2) {
            return;
          }
          const activatorEvent2 = event.nativeEvent;
          const sensorInstance = new Sensor({
            active: activeRef.current,
            activeNode: activeNode2,
            event: activatorEvent2,
            options,
            // Sensors need to be instantiated with refs for arguments that change over time
            // otherwise they are frozen in time with the stale arguments
            context: sensorContext,
            onStart(initialCoordinates) {
              const id3 = activeRef.current;
              if (id3 == null) {
                return;
              }
              const draggableNode = draggableNodes.get(id3);
              if (!draggableNode) {
                return;
              }
              const {
                onDragStart
              } = latestProps.current;
              const event2 = {
                active: {
                  id: id3,
                  data: draggableNode.data,
                  rect: activeRects
                }
              };
              (0, import_react_dom.unstable_batchedUpdates)(() => {
                onDragStart == null ? void 0 : onDragStart(event2);
                setStatus(Status.Initializing);
                dispatch({
                  type: Action3.DragStart,
                  initialCoordinates,
                  active: id3
                });
                dispatchMonitorEvent({
                  type: "onDragStart",
                  event: event2
                });
              });
            },
            onMove(coordinates) {
              dispatch({
                type: Action3.DragMove,
                coordinates
              });
            },
            onEnd: createHandler(Action3.DragEnd),
            onCancel: createHandler(Action3.DragCancel)
          });
          (0, import_react_dom.unstable_batchedUpdates)(() => {
            setActiveSensor(sensorInstance);
            setActivatorEvent(event.nativeEvent);
          });
          function createHandler(type) {
            return async function handler() {
              const {
                active: active2,
                collisions: collisions2,
                over: over2,
                scrollAdjustedTranslate: scrollAdjustedTranslate2
              } = sensorContext.current;
              let event2 = null;
              if (active2 && scrollAdjustedTranslate2) {
                const {
                  cancelDrop
                } = latestProps.current;
                event2 = {
                  activatorEvent: activatorEvent2,
                  active: active2,
                  collisions: collisions2,
                  delta: scrollAdjustedTranslate2,
                  over: over2
                };
                if (type === Action3.DragEnd && typeof cancelDrop === "function") {
                  const shouldCancel = await Promise.resolve(cancelDrop(event2));
                  if (shouldCancel) {
                    type = Action3.DragCancel;
                  }
                }
              }
              activeRef.current = null;
              (0, import_react_dom.unstable_batchedUpdates)(() => {
                dispatch({
                  type
                });
                setStatus(Status.Uninitialized);
                setOver(null);
                setActiveSensor(null);
                setActivatorEvent(null);
                const eventName = type === Action3.DragEnd ? "onDragEnd" : "onDragCancel";
                if (event2) {
                  const handler2 = latestProps.current[eventName];
                  handler2 == null ? void 0 : handler2(event2);
                  dispatchMonitorEvent({
                    type: eventName,
                    event: event2
                  });
                }
              });
            };
          }
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [draggableNodes]
      );
      const bindActivatorToSensorInstantiator = (0, import_react23.useCallback)((handler, sensor) => {
        return (event, active2) => {
          const nativeEvent = event.nativeEvent;
          const activeDraggableNode = draggableNodes.get(active2);
          if (
            // Another sensor is already instantiating
            activeRef.current !== null || // No active draggable
            !activeDraggableNode || // Event has already been captured
            nativeEvent.dndKit || nativeEvent.defaultPrevented
          ) {
            return;
          }
          const activationContext = {
            active: activeDraggableNode
          };
          const shouldActivate = handler(event, sensor.options, activationContext);
          if (shouldActivate === true) {
            nativeEvent.dndKit = {
              capturedBy: sensor.sensor
            };
            activeRef.current = active2;
            instantiateSensor(event, sensor);
          }
        };
      }, [draggableNodes, instantiateSensor]);
      const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
      useSensorSetup(sensors);
      useIsomorphicLayoutEffect(() => {
        if (activeNodeRect && status === Status.Initializing) {
          setStatus(Status.Initialized);
        }
      }, [activeNodeRect, status]);
      (0, import_react23.useEffect)(
        () => {
          const {
            onDragMove
          } = latestProps.current;
          const {
            active: active2,
            activatorEvent: activatorEvent2,
            collisions: collisions2,
            over: over2
          } = sensorContext.current;
          if (!active2 || !activatorEvent2) {
            return;
          }
          const event = {
            active: active2,
            activatorEvent: activatorEvent2,
            collisions: collisions2,
            delta: {
              x: scrollAdjustedTranslate.x,
              y: scrollAdjustedTranslate.y
            },
            over: over2
          };
          (0, import_react_dom.unstable_batchedUpdates)(() => {
            onDragMove == null ? void 0 : onDragMove(event);
            dispatchMonitorEvent({
              type: "onDragMove",
              event
            });
          });
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
      );
      (0, import_react23.useEffect)(
        () => {
          const {
            active: active2,
            activatorEvent: activatorEvent2,
            collisions: collisions2,
            droppableContainers: droppableContainers2,
            scrollAdjustedTranslate: scrollAdjustedTranslate2
          } = sensorContext.current;
          if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
            return;
          }
          const {
            onDragOver
          } = latestProps.current;
          const overContainer = droppableContainers2.get(overId);
          const over2 = overContainer && overContainer.rect.current ? {
            id: overContainer.id,
            rect: overContainer.rect.current,
            data: overContainer.data,
            disabled: overContainer.disabled
          } : null;
          const event = {
            active: active2,
            activatorEvent: activatorEvent2,
            collisions: collisions2,
            delta: {
              x: scrollAdjustedTranslate2.x,
              y: scrollAdjustedTranslate2.y
            },
            over: over2
          };
          (0, import_react_dom.unstable_batchedUpdates)(() => {
            setOver(over2);
            onDragOver == null ? void 0 : onDragOver(event);
            dispatchMonitorEvent({
              type: "onDragOver",
              event
            });
          });
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [overId]
      );
      useIsomorphicLayoutEffect(() => {
        sensorContext.current = {
          activatorEvent,
          active,
          activeNode,
          collisionRect,
          collisions,
          droppableRects,
          draggableNodes,
          draggingNode,
          draggingNodeRect,
          droppableContainers,
          over,
          scrollableAncestors,
          scrollAdjustedTranslate
        };
        activeRects.current = {
          initial: draggingNodeRect,
          translated: collisionRect
        };
      }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
      useAutoScroller({
        ...autoScrollOptions,
        delta: translate,
        draggingRect: collisionRect,
        pointerCoordinates,
        scrollableAncestors,
        scrollableAncestorRects
      });
      const publicContext = (0, import_react23.useMemo)(() => {
        const context2 = {
          active,
          activeNode,
          activeNodeRect,
          activatorEvent,
          collisions,
          containerNodeRect,
          dragOverlay,
          draggableNodes,
          droppableContainers,
          droppableRects,
          over,
          measureDroppableContainers,
          scrollableAncestors,
          scrollableAncestorRects,
          measuringConfiguration,
          measuringScheduled,
          windowRect
        };
        return context2;
      }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
      const internalContext = (0, import_react23.useMemo)(() => {
        const context2 = {
          activatorEvent,
          activators,
          active,
          activeNodeRect,
          ariaDescribedById: {
            draggable: draggableDescribedById
          },
          dispatch,
          draggableNodes,
          over,
          measureDroppableContainers
        };
        return context2;
      }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
      return import_react23.default.createElement(DndMonitorContext.Provider, {
        value: registerMonitorListener
      }, import_react23.default.createElement(InternalContext.Provider, {
        value: internalContext
      }, import_react23.default.createElement(PublicContext.Provider, {
        value: publicContext
      }, import_react23.default.createElement(ActiveDraggableContext.Provider, {
        value: transform
      }, children)), import_react23.default.createElement(RestoreFocus, {
        disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
      })), import_react23.default.createElement(Accessibility, {
        ...accessibility,
        hiddenTextDescribedById: draggableDescribedById
      }));
      function getAutoScrollerOptions() {
        const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
        const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
        const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
        if (typeof autoScroll === "object") {
          return {
            ...autoScroll,
            enabled
          };
        }
        return {
          enabled
        };
      }
    });
    NullContext = (0, import_react23.createContext)(null);
    defaultRole = "button";
    ID_PREFIX = "Droppable";
    ID_PREFIX$1 = "Droppable";
    defaultResizeObserverConfig = {
      timeout: 25
    };
    defaultTransform = {
      x: 0,
      y: 0,
      scaleX: 1,
      scaleY: 1
    };
    baseStyles = {
      position: "fixed",
      touchAction: "none"
    };
    defaultTransition = (activatorEvent) => {
      const isKeyboardActivator = isKeyboardEvent(activatorEvent);
      return isKeyboardActivator ? "transform 250ms ease" : void 0;
    };
    PositionedOverlay = (0, import_react23.forwardRef)((_ref2, ref) => {
      let {
        as: as2,
        activatorEvent,
        adjustScale: adjustScale2,
        children,
        className,
        rect,
        style,
        transform,
        transition = defaultTransition
      } = _ref2;
      if (!rect) {
        return null;
      }
      const scaleAdjustedTransform = adjustScale2 ? transform : {
        ...transform,
        scaleX: 1,
        scaleY: 1
      };
      const styles = {
        ...baseStyles,
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left,
        transform: CSS2.Transform.toString(scaleAdjustedTransform),
        transformOrigin: adjustScale2 && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : void 0,
        transition: typeof transition === "function" ? transition(activatorEvent) : transition,
        ...style
      };
      return import_react23.default.createElement(as2, {
        className,
        style: styles,
        ref
      }, children);
    });
    defaultDropAnimationSideEffects = (options) => (_ref2) => {
      let {
        active,
        dragOverlay
      } = _ref2;
      const originalStyles = {};
      const {
        styles,
        className
      } = options;
      if (styles != null && styles.active) {
        for (const [key2, value] of Object.entries(styles.active)) {
          if (value === void 0) {
            continue;
          }
          originalStyles[key2] = active.node.style.getPropertyValue(key2);
          active.node.style.setProperty(key2, value);
        }
      }
      if (styles != null && styles.dragOverlay) {
        for (const [key2, value] of Object.entries(styles.dragOverlay)) {
          if (value === void 0) {
            continue;
          }
          dragOverlay.node.style.setProperty(key2, value);
        }
      }
      if (className != null && className.active) {
        active.node.classList.add(className.active);
      }
      if (className != null && className.dragOverlay) {
        dragOverlay.node.classList.add(className.dragOverlay);
      }
      return function cleanup() {
        for (const [key2, value] of Object.entries(originalStyles)) {
          active.node.style.setProperty(key2, value);
        }
        if (className != null && className.active) {
          active.node.classList.remove(className.active);
        }
      };
    };
    defaultKeyframeResolver = (_ref2) => {
      let {
        transform: {
          initial: initial2,
          final
        }
      } = _ref2;
      return [{
        transform: CSS2.Transform.toString(initial2)
      }, {
        transform: CSS2.Transform.toString(final)
      }];
    };
    defaultDropAnimationConfiguration = {
      duration: 250,
      easing: "ease",
      keyframes: defaultKeyframeResolver,
      sideEffects: defaultDropAnimationSideEffects({
        styles: {
          active: {
            opacity: "0"
          }
        }
      })
    };
    key = 0;
    DragOverlay = import_react23.default.memo((_ref2) => {
      let {
        adjustScale: adjustScale2 = false,
        children,
        dropAnimation: dropAnimationConfig,
        style,
        transition,
        modifiers,
        wrapperElement = "div",
        className,
        zIndex = 999
      } = _ref2;
      const {
        activatorEvent,
        active,
        activeNodeRect,
        containerNodeRect,
        draggableNodes,
        droppableContainers,
        dragOverlay,
        over,
        measuringConfiguration,
        scrollableAncestors,
        scrollableAncestorRects,
        windowRect
      } = useDndContext();
      const transform = (0, import_react23.useContext)(ActiveDraggableContext);
      const key2 = useKey(active == null ? void 0 : active.id);
      const modifiedTransform = applyModifiers(modifiers, {
        activatorEvent,
        active,
        activeNodeRect,
        containerNodeRect,
        draggingNodeRect: dragOverlay.rect,
        over,
        overlayNodeRect: dragOverlay.rect,
        scrollableAncestors,
        scrollableAncestorRects,
        transform,
        windowRect
      });
      const initialRect = useInitialValue(activeNodeRect);
      const dropAnimation = useDropAnimation({
        config: dropAnimationConfig,
        draggableNodes,
        droppableContainers,
        measuringConfiguration
      });
      const ref = initialRect ? dragOverlay.setRef : void 0;
      return import_react23.default.createElement(NullifiedContextProvider, null, import_react23.default.createElement(AnimationManager, {
        animation: dropAnimation
      }, active && key2 ? import_react23.default.createElement(PositionedOverlay, {
        key: key2,
        id: active.id,
        ref,
        as: wrapperElement,
        activatorEvent,
        adjustScale: adjustScale2,
        className,
        transition,
        rect: initialRect,
        style: {
          zIndex,
          ...style
        },
        transform: modifiedTransform
      }, children) : null));
    });
  }
});

// node_modules/@dnd-kit/sortable/dist/sortable.esm.js
var sortable_esm_exports = {};
__export(sortable_esm_exports, {
  SortableContext: () => SortableContext,
  arrayMove: () => arrayMove,
  arraySwap: () => arraySwap,
  defaultAnimateLayoutChanges: () => defaultAnimateLayoutChanges,
  defaultNewIndexGetter: () => defaultNewIndexGetter,
  hasSortableData: () => hasSortableData,
  horizontalListSortingStrategy: () => horizontalListSortingStrategy,
  rectSortingStrategy: () => rectSortingStrategy,
  rectSwappingStrategy: () => rectSwappingStrategy,
  sortableKeyboardCoordinates: () => sortableKeyboardCoordinates,
  useSortable: () => useSortable,
  verticalListSortingStrategy: () => verticalListSortingStrategy
});
function arrayMove(array, from4, to2) {
  const newArray = array.slice();
  newArray.splice(to2 < 0 ? newArray.length + to2 : to2, 0, newArray.splice(from4, 1)[0]);
  return newArray;
}
function arraySwap(array, from4, to2) {
  const newArray = array.slice();
  newArray[from4] = array[to2];
  newArray[to2] = array[from4];
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id2, index3) => {
    const rect = rects.get(id2);
    if (rect) {
      accumulator[index3] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index3) {
  return index3 !== null && index3 >= 0;
}
function itemsEqual(a5, b3) {
  if (a5 === b3) {
    return true;
  }
  if (a5.length !== b3.length) {
    return false;
  }
  for (let i4 = 0; i4 < a5.length; i4++) {
    if (a5[i4] !== b3[i4]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
function getItemGap(rects, index3, activeIndex) {
  const currentRect = rects[index3];
  const previousRect = rects[index3 - 1];
  const nextRect = rects[index3 + 1];
  if (!currentRect || !previousRect && !nextRect) {
    return 0;
  }
  if (activeIndex < index3) {
    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);
  }
  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);
}
function getItemGap$1(clientRects, index3, activeIndex) {
  const currentRect = clientRects[index3];
  const previousRect = clientRects[index3 - 1];
  const nextRect = clientRects[index3 + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index3) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }
  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}
function SortableContext(_ref2) {
  let {
    children,
    id: id2,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref2;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX2, id2);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = (0, import_react24.useMemo)(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = (0, import_react24.useRef)(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  (0, import_react24.useEffect)(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = (0, import_react24.useMemo)(
    () => ({
      activeIndex,
      containerId,
      disabled,
      disableTransforms,
      items,
      overIndex,
      useDragOverlay,
      sortedRects: getSortedRects(items, droppableRects),
      strategy
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
  );
  return import_react24.default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
function useDerivedTransform(_ref2) {
  let {
    disabled,
    index: index3,
    node: node5,
    rect
  } = _ref2;
  const [derivedTransform, setDerivedtransform] = (0, import_react24.useState)(null);
  const previousIndex = (0, import_react24.useRef)(index3);
  useIsomorphicLayoutEffect(() => {
    if (!disabled && index3 !== previousIndex.current && node5.current) {
      const initial2 = rect.current;
      if (initial2) {
        const current2 = getClientRect(node5.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial2.left - current2.left,
          y: initial2.top - current2.top,
          scaleX: initial2.width / current2.width,
          scaleY: initial2.height / current2.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index3 !== previousIndex.current) {
      previousIndex.current = index3;
    }
  }, [disabled, index3, node5, rect]);
  (0, import_react24.useEffect)(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref2) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id: id2,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = defaultTransition2
  } = _ref2;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = (0, import_react24.useContext)(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index3 = items.indexOf(id2);
  const data = (0, import_react24.useMemo)(() => ({
    sortable: {
      containerId,
      index: index3,
      items
    },
    ...customData
  }), [containerId, customData, index3, items]);
  const itemsAfterCurrentSortable = (0, import_react24.useMemo)(() => items.slice(items.indexOf(id2)), [items, id2]);
  const {
    rect,
    node: node5,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id: id2,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id: id2,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index: index3
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id: id2,
    items,
    activeIndex,
    overIndex
  }) : index3;
  const activeId = active == null ? void 0 : active.id;
  const previous3 = (0, import_react24.useRef)({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous3.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id: id2,
    index: index3,
    items,
    newIndex: previous3.current.newIndex,
    previousItems: previous3.current.items,
    previousContainerId: previous3.current.containerId,
    transition,
    wasDragging: previous3.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index3,
    node: node5,
    rect
  });
  (0, import_react24.useEffect)(() => {
    if (isSorting && previous3.current.newIndex !== newIndex) {
      previous3.current.newIndex = newIndex;
    }
    if (containerId !== previous3.current.containerId) {
      previous3.current.containerId = containerId;
    }
    if (items !== previous3.current.items) {
      previous3.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  (0, import_react24.useEffect)(() => {
    if (activeId === previous3.current.activeId) {
      return;
    }
    if (activeId && !previous3.current.activeId) {
      previous3.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous3.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index: index3,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node: node5,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      derivedTransform || // Or to prevent items jumping to back to their "new" position when items change
      itemsHaveChanged && previous3.current.newIndex === index3
    ) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS2.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      // Backwards compatibility
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
function hasSortableData(entry) {
  if (!entry) {
    return false;
  }
  const data = entry.data.current;
  if (data && "sortable" in data && typeof data.sortable === "object" && "containerId" in data.sortable && "items" in data.sortable && "index" in data.sortable) {
    return true;
  }
  return false;
}
function isSameContainer(a5, b3) {
  if (!hasSortableData(a5) || !hasSortableData(b3)) {
    return false;
  }
  return a5.data.current.sortable.containerId === b3.data.current.sortable.containerId;
}
function isAfter2(a5, b3) {
  if (!hasSortableData(a5) || !hasSortableData(b3)) {
    return false;
  }
  if (!isSameContainer(a5, b3)) {
    return false;
  }
  return a5.data.current.sortable.index < b3.data.current.sortable.index;
}
var import_react24, defaultScale, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, defaultScale$1, verticalListSortingStrategy, ID_PREFIX2, Context, defaultNewIndexGetter, defaultAnimateLayoutChanges, defaultTransition2, transitionProperty, disabledTransition, defaultAttributes, directions, sortableKeyboardCoordinates;
var init_sortable_esm = __esm({
  "node_modules/@dnd-kit/sortable/dist/sortable.esm.js"() {
    import_react24 = __toESM(require_react());
    init_core_esm();
    init_utilities_esm();
    defaultScale = {
      scaleX: 1,
      scaleY: 1
    };
    horizontalListSortingStrategy = (_ref2) => {
      var _rects$activeIndex;
      let {
        rects,
        activeNodeRect: fallbackActiveRect,
        activeIndex,
        overIndex,
        index: index3
      } = _ref2;
      const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
      if (!activeNodeRect) {
        return null;
      }
      const itemGap = getItemGap(rects, index3, activeIndex);
      if (index3 === activeIndex) {
        const newIndexRect = rects[overIndex];
        if (!newIndexRect) {
          return null;
        }
        return {
          x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,
          y: 0,
          ...defaultScale
        };
      }
      if (index3 > activeIndex && index3 <= overIndex) {
        return {
          x: -activeNodeRect.width - itemGap,
          y: 0,
          ...defaultScale
        };
      }
      if (index3 < activeIndex && index3 >= overIndex) {
        return {
          x: activeNodeRect.width + itemGap,
          y: 0,
          ...defaultScale
        };
      }
      return {
        x: 0,
        y: 0,
        ...defaultScale
      };
    };
    rectSortingStrategy = (_ref2) => {
      let {
        rects,
        activeIndex,
        overIndex,
        index: index3
      } = _ref2;
      const newRects = arrayMove(rects, overIndex, activeIndex);
      const oldRect = rects[index3];
      const newRect = newRects[index3];
      if (!newRect || !oldRect) {
        return null;
      }
      return {
        x: newRect.left - oldRect.left,
        y: newRect.top - oldRect.top,
        scaleX: newRect.width / oldRect.width,
        scaleY: newRect.height / oldRect.height
      };
    };
    rectSwappingStrategy = (_ref2) => {
      let {
        activeIndex,
        index: index3,
        rects,
        overIndex
      } = _ref2;
      let oldRect;
      let newRect;
      if (index3 === activeIndex) {
        oldRect = rects[index3];
        newRect = rects[overIndex];
      }
      if (index3 === overIndex) {
        oldRect = rects[index3];
        newRect = rects[activeIndex];
      }
      if (!newRect || !oldRect) {
        return null;
      }
      return {
        x: newRect.left - oldRect.left,
        y: newRect.top - oldRect.top,
        scaleX: newRect.width / oldRect.width,
        scaleY: newRect.height / oldRect.height
      };
    };
    defaultScale$1 = {
      scaleX: 1,
      scaleY: 1
    };
    verticalListSortingStrategy = (_ref2) => {
      var _rects$activeIndex;
      let {
        activeIndex,
        activeNodeRect: fallbackActiveRect,
        index: index3,
        rects,
        overIndex
      } = _ref2;
      const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
      if (!activeNodeRect) {
        return null;
      }
      if (index3 === activeIndex) {
        const overIndexRect = rects[overIndex];
        if (!overIndexRect) {
          return null;
        }
        return {
          x: 0,
          y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
          ...defaultScale$1
        };
      }
      const itemGap = getItemGap$1(rects, index3, activeIndex);
      if (index3 > activeIndex && index3 <= overIndex) {
        return {
          x: 0,
          y: -activeNodeRect.height - itemGap,
          ...defaultScale$1
        };
      }
      if (index3 < activeIndex && index3 >= overIndex) {
        return {
          x: 0,
          y: activeNodeRect.height + itemGap,
          ...defaultScale$1
        };
      }
      return {
        x: 0,
        y: 0,
        ...defaultScale$1
      };
    };
    ID_PREFIX2 = "Sortable";
    Context = import_react24.default.createContext({
      activeIndex: -1,
      containerId: ID_PREFIX2,
      disableTransforms: false,
      items: [],
      overIndex: -1,
      useDragOverlay: false,
      sortedRects: [],
      strategy: rectSortingStrategy,
      disabled: {
        draggable: false,
        droppable: false
      }
    });
    defaultNewIndexGetter = (_ref2) => {
      let {
        id: id2,
        items,
        activeIndex,
        overIndex
      } = _ref2;
      return arrayMove(items, activeIndex, overIndex).indexOf(id2);
    };
    defaultAnimateLayoutChanges = (_ref2) => {
      let {
        containerId,
        isSorting,
        wasDragging,
        index: index3,
        items,
        newIndex,
        previousItems,
        previousContainerId,
        transition
      } = _ref2;
      if (!transition || !wasDragging) {
        return false;
      }
      if (previousItems !== items && index3 === newIndex) {
        return false;
      }
      if (isSorting) {
        return true;
      }
      return newIndex !== index3 && containerId === previousContainerId;
    };
    defaultTransition2 = {
      duration: 200,
      easing: "ease"
    };
    transitionProperty = "transform";
    disabledTransition = CSS2.Transition.toString({
      property: transitionProperty,
      duration: 0,
      easing: "linear"
    });
    defaultAttributes = {
      roleDescription: "sortable"
    };
    directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
    sortableKeyboardCoordinates = (event, _ref2) => {
      let {
        context: {
          active,
          collisionRect,
          droppableRects,
          droppableContainers,
          over,
          scrollableAncestors
        }
      } = _ref2;
      if (directions.includes(event.code)) {
        event.preventDefault();
        if (!active || !collisionRect) {
          return;
        }
        const filteredContainers = [];
        droppableContainers.getEnabled().forEach((entry) => {
          if (!entry || entry != null && entry.disabled) {
            return;
          }
          const rect = droppableRects.get(entry.id);
          if (!rect) {
            return;
          }
          switch (event.code) {
            case KeyboardCode.Down:
              if (collisionRect.top < rect.top) {
                filteredContainers.push(entry);
              }
              break;
            case KeyboardCode.Up:
              if (collisionRect.top > rect.top) {
                filteredContainers.push(entry);
              }
              break;
            case KeyboardCode.Left:
              if (collisionRect.left > rect.left) {
                filteredContainers.push(entry);
              }
              break;
            case KeyboardCode.Right:
              if (collisionRect.left < rect.left) {
                filteredContainers.push(entry);
              }
              break;
          }
        });
        const collisions = closestCorners({
          active,
          collisionRect,
          droppableRects,
          droppableContainers: filteredContainers,
          pointerCoordinates: null
        });
        let closestId = getFirstCollision(collisions, "id");
        if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {
          closestId = collisions[1].id;
        }
        if (closestId != null) {
          const activeDroppable = droppableContainers.get(active.id);
          const newDroppable = droppableContainers.get(closestId);
          const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
          const newNode = newDroppable == null ? void 0 : newDroppable.node.current;
          if (newNode && newRect && activeDroppable && newDroppable) {
            const newScrollAncestors = getScrollableAncestors(newNode);
            const hasDifferentScrollAncestors = newScrollAncestors.some((element, index3) => scrollableAncestors[index3] !== element);
            const hasSameContainer = isSameContainer(activeDroppable, newDroppable);
            const isAfterActive = isAfter2(activeDroppable, newDroppable);
            const offset3 = hasDifferentScrollAncestors || !hasSameContainer ? {
              x: 0,
              y: 0
            } : {
              x: isAfterActive ? collisionRect.width - newRect.width : 0,
              y: isAfterActive ? collisionRect.height - newRect.height : 0
            };
            const rectCoordinates = {
              x: newRect.left,
              y: newRect.top
            };
            const newCoordinates = offset3.x && offset3.y ? rectCoordinates : subtract(rectCoordinates, offset3);
            return newCoordinates;
          }
        }
      }
      return void 0;
    };
  }
});

// node_modules/@dnd-kit/modifiers/dist/modifiers.esm.js
var modifiers_esm_exports = {};
__export(modifiers_esm_exports, {
  createSnapModifier: () => createSnapModifier,
  restrictToFirstScrollableAncestor: () => restrictToFirstScrollableAncestor,
  restrictToHorizontalAxis: () => restrictToHorizontalAxis,
  restrictToParentElement: () => restrictToParentElement,
  restrictToVerticalAxis: () => restrictToVerticalAxis,
  restrictToWindowEdges: () => restrictToWindowEdges,
  snapCenterToCursor: () => snapCenterToCursor
});
function createSnapModifier(gridSize) {
  return (_ref2) => {
    let {
      transform
    } = _ref2;
    return {
      ...transform,
      x: Math.ceil(transform.x / gridSize) * gridSize,
      y: Math.ceil(transform.y / gridSize) * gridSize
    };
  };
}
function restrictToBoundingRect(transform, rect, boundingRect) {
  const value = {
    ...transform
  };
  if (rect.top + transform.y <= boundingRect.top) {
    value.y = boundingRect.top - rect.top;
  } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {
    value.y = boundingRect.top + boundingRect.height - rect.bottom;
  }
  if (rect.left + transform.x <= boundingRect.left) {
    value.x = boundingRect.left - rect.left;
  } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {
    value.x = boundingRect.left + boundingRect.width - rect.right;
  }
  return value;
}
var restrictToHorizontalAxis, restrictToParentElement, restrictToFirstScrollableAncestor, restrictToVerticalAxis, restrictToWindowEdges, snapCenterToCursor;
var init_modifiers_esm = __esm({
  "node_modules/@dnd-kit/modifiers/dist/modifiers.esm.js"() {
    init_utilities_esm();
    restrictToHorizontalAxis = (_ref2) => {
      let {
        transform
      } = _ref2;
      return {
        ...transform,
        y: 0
      };
    };
    restrictToParentElement = (_ref2) => {
      let {
        containerNodeRect,
        draggingNodeRect,
        transform
      } = _ref2;
      if (!draggingNodeRect || !containerNodeRect) {
        return transform;
      }
      return restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect);
    };
    restrictToFirstScrollableAncestor = (_ref2) => {
      let {
        draggingNodeRect,
        transform,
        scrollableAncestorRects
      } = _ref2;
      const firstScrollableAncestorRect = scrollableAncestorRects[0];
      if (!draggingNodeRect || !firstScrollableAncestorRect) {
        return transform;
      }
      return restrictToBoundingRect(transform, draggingNodeRect, firstScrollableAncestorRect);
    };
    restrictToVerticalAxis = (_ref2) => {
      let {
        transform
      } = _ref2;
      return {
        ...transform,
        x: 0
      };
    };
    restrictToWindowEdges = (_ref2) => {
      let {
        transform,
        draggingNodeRect,
        windowRect
      } = _ref2;
      if (!draggingNodeRect || !windowRect) {
        return transform;
      }
      return restrictToBoundingRect(transform, draggingNodeRect, windowRect);
    };
    snapCenterToCursor = (_ref2) => {
      let {
        activatorEvent,
        draggingNodeRect,
        transform
      } = _ref2;
      if (draggingNodeRect && activatorEvent) {
        const activatorCoordinates = getEventCoordinates(activatorEvent);
        if (!activatorCoordinates) {
          return transform;
        }
        const offsetX = activatorCoordinates.x - draggingNodeRect.left;
        const offsetY = activatorCoordinates.y - draggingNodeRect.top;
        return {
          ...transform,
          x: transform.x + offsetX - draggingNodeRect.width / 2,
          y: transform.y + offsetY - draggingNodeRect.height / 2
        };
      }
      return transform;
    };
  }
});

// node_modules/exif-component/js/ExifReader.js
var require_ExifReader = __commonJS({
  "node_modules/exif-component/js/ExifReader.js"(exports) {
    (function() {
      (typeof exports !== "undefined" && exports !== null ? exports : this).ExifReader = function() {
        ExifReader.prototype._MIN_DATA_BUFFER_LENGTH = 2;
        ExifReader.prototype._JPEG_ID_SIZE = 2;
        ExifReader.prototype._JPEG_ID = 65496;
        ExifReader.prototype._APP_MARKER_SIZE = 2;
        ExifReader.prototype._APP0_MARKER = 65504;
        ExifReader.prototype._APP1_MARKER = 65505;
        ExifReader.prototype._APP15_MARKER = 65519;
        ExifReader.prototype._APP_ID_OFFSET = 4;
        ExifReader.prototype._BYTES_Exif = 1165519206;
        ExifReader.prototype._TIFF_HEADER_OFFSET = 10;
        ExifReader.prototype._BYTE_ORDER_BIG_ENDIAN = 18761;
        ExifReader.prototype._BYTE_ORDER_LITTLE_ENDIAN = 19789;
        function ExifReader() {
          var _this = this;
          this._getTagValueAt = {
            1: function(offset3) {
              return _this._getByteAt(offset3);
            },
            2: function(offset3) {
              return _this._getAsciiAt(offset3);
            },
            3: function(offset3) {
              return _this._getShortAt(offset3);
            },
            4: function(offset3) {
              return _this._getLongAt(offset3);
            },
            5: function(offset3) {
              return _this._getRationalAt(offset3);
            },
            7: function(offset3) {
              return _this._getUndefinedAt(offset3);
            },
            9: function(offset3) {
              return _this._getSlongAt(offset3);
            },
            10: function(offset3) {
              return _this._getSrationalAt(offset3);
            }
          };
          this._tiffHeaderOffset = 0;
        }
        ExifReader.prototype.load = function(data) {
          return this.loadView(new DataView(data));
        };
        ExifReader.prototype.loadView = function(_dataView) {
          this._dataView = _dataView;
          this._tags = {};
          this._checkImageHeader();
          return this._readTags();
        };
        ExifReader.prototype._checkImageHeader = function() {
          var dataView;
          dataView = this._dataView;
          if (dataView.byteLength < this._MIN_DATA_BUFFER_LENGTH || dataView.getUint16(0, false) !== this._JPEG_ID) {
            throw new Error("Invalid image format");
          }
          this._parseAppMarkers(dataView);
          if (!this._hasExifData()) {
            throw new Error("No Exif data");
          }
        };
        ExifReader.prototype._parseAppMarkers = function(dataView) {
          var appMarkerPosition, fieldLength, _results;
          appMarkerPosition = this._JPEG_ID_SIZE;
          _results = [];
          while (true) {
            if (dataView.byteLength < appMarkerPosition + this._APP_ID_OFFSET + 5) {
              break;
            }
            if (this._isApp1ExifMarker(dataView, appMarkerPosition)) {
              fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);
              this._tiffHeaderOffset = appMarkerPosition + this._TIFF_HEADER_OFFSET;
            } else if (this._isAppMarker(dataView, appMarkerPosition)) {
              fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);
            } else {
              break;
            }
            _results.push(appMarkerPosition += this._APP_MARKER_SIZE + fieldLength);
          }
          return _results;
        };
        ExifReader.prototype._isApp1ExifMarker = function(dataView, appMarkerPosition) {
          return dataView.getUint16(appMarkerPosition, false) === this._APP1_MARKER && dataView.getUint32(appMarkerPosition + this._APP_ID_OFFSET, false) === this._BYTES_Exif && dataView.getUint8(appMarkerPosition + this._APP_ID_OFFSET + 4, false) === 0;
        };
        ExifReader.prototype._isAppMarker = function(dataView, appMarkerPosition) {
          var appMarker;
          appMarker = dataView.getUint16(appMarkerPosition, false);
          return appMarker >= this._APP0_MARKER && appMarker <= this._APP15_MARKER;
        };
        ExifReader.prototype._hasExifData = function() {
          return this._tiffHeaderOffset !== 0;
        };
        ExifReader.prototype._readTags = function() {
          this._setByteOrder();
          this._read0thIfd();
          this._readExifIfd();
          this._readGpsIfd();
          return this._readInteroperabilityIfd();
        };
        ExifReader.prototype._setByteOrder = function() {
          if (this._dataView.getUint16(this._tiffHeaderOffset) === this._BYTE_ORDER_BIG_ENDIAN) {
            return this._littleEndian = true;
          } else if (this._dataView.getUint16(this._tiffHeaderOffset) === this._BYTE_ORDER_LITTLE_ENDIAN) {
            return this._littleEndian = false;
          } else {
            throw new Error("Illegal byte order value. Faulty image.");
          }
        };
        ExifReader.prototype._read0thIfd = function() {
          var ifdOffset;
          ifdOffset = this._getIfdOffset();
          return this._readIfd("0th", ifdOffset);
        };
        ExifReader.prototype._getIfdOffset = function() {
          return this._tiffHeaderOffset + this._getLongAt(this._tiffHeaderOffset + 4);
        };
        ExifReader.prototype._readExifIfd = function() {
          var ifdOffset;
          if (this._tags["Exif IFD Pointer"] != null) {
            ifdOffset = this._tiffHeaderOffset + this._tags["Exif IFD Pointer"].value;
            return this._readIfd("exif", ifdOffset);
          }
        };
        ExifReader.prototype._readGpsIfd = function() {
          var ifdOffset;
          if (this._tags["GPS Info IFD Pointer"] != null) {
            ifdOffset = this._tiffHeaderOffset + this._tags["GPS Info IFD Pointer"].value;
            return this._readIfd("gps", ifdOffset);
          }
        };
        ExifReader.prototype._readInteroperabilityIfd = function() {
          var ifdOffset;
          if (this._tags["Interoperability IFD Pointer"] != null) {
            ifdOffset = this._tiffHeaderOffset + this._tags["Interoperability IFD Pointer"].value;
            return this._readIfd("interoperability", ifdOffset);
          }
        };
        ExifReader.prototype._readIfd = function(ifdType, offset3) {
          var fieldIndex, numberOfFields, tag, _i, _results;
          numberOfFields = this._getShortAt(offset3);
          offset3 += 2;
          _results = [];
          for (fieldIndex = _i = 0; 0 <= numberOfFields ? _i < numberOfFields : _i > numberOfFields; fieldIndex = 0 <= numberOfFields ? ++_i : --_i) {
            tag = this._readTag(ifdType, offset3);
            this._tags[tag.name] = {
              "value": tag.value,
              "description": tag.description
            };
            _results.push(offset3 += 12);
          }
          return _results;
        };
        ExifReader.prototype._readTag = function(ifdType, offset3) {
          var tagCode, tagCount, tagDescription, tagName, tagType, tagValue, tagValueOffset;
          tagCode = this._getShortAt(offset3);
          tagType = this._getShortAt(offset3 + 2);
          tagCount = this._getLongAt(offset3 + 4);
          if (this._typeSizes[tagType] * tagCount <= 4) {
            tagValue = this._getTagValue(offset3 + 8, tagType, tagCount);
          } else {
            tagValueOffset = this._getLongAt(offset3 + 8);
            tagValue = this._getTagValue(this._tiffHeaderOffset + tagValueOffset, tagType, tagCount);
          }
          if (tagType === this._tagTypes["ASCII"]) {
            tagValue = this._splitNullSeparatedAsciiString(tagValue);
          }
          if (this._tagNames[ifdType][tagCode] != null) {
            if (this._tagNames[ifdType][tagCode]["name"] != null && this._tagNames[ifdType][tagCode]["description"] != null) {
              tagName = this._tagNames[ifdType][tagCode]["name"];
              tagDescription = this._tagNames[ifdType][tagCode]["description"](tagValue);
            } else {
              tagName = this._tagNames[ifdType][tagCode];
              if (tagValue instanceof Array) {
                tagDescription = tagValue.join(", ");
              } else {
                tagDescription = tagValue;
              }
            }
            return {
              "name": tagName,
              "value": tagValue,
              "description": tagDescription
            };
          } else {
            return {
              "name": "undefined-" + tagCode,
              "value": tagValue,
              "description": tagValue
            };
          }
        };
        ExifReader.prototype._getTagValue = function(offset3, type, count2) {
          var tagValue, value, valueIndex;
          value = (function() {
            var _i, _results;
            _results = [];
            for (valueIndex = _i = 0; 0 <= count2 ? _i < count2 : _i > count2; valueIndex = 0 <= count2 ? ++_i : --_i) {
              tagValue = this._getTagValueAt[type](offset3);
              offset3 += this._typeSizes[type];
              _results.push(tagValue);
            }
            return _results;
          }).call(this);
          if (value.length === 1) {
            value = value[0];
          } else if (type === this._tagTypes["ASCII"]) {
            value = this._getAsciiValue(value);
          }
          return value;
        };
        ExifReader.prototype._getAsciiValue = function(charArray) {
          var charCode, newCharArray;
          return newCharArray = function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = charArray.length; _i < _len; _i++) {
              charCode = charArray[_i];
              _results.push(String.fromCharCode(charCode));
            }
            return _results;
          }();
        };
        ExifReader.prototype._getByteAt = function(offset3) {
          return this._dataView.getUint8(offset3);
        };
        ExifReader.prototype._getAsciiAt = function(offset3) {
          return this._dataView.getUint8(offset3);
        };
        ExifReader.prototype._getShortAt = function(offset3) {
          return this._dataView.getUint16(offset3, this._littleEndian);
        };
        ExifReader.prototype._getLongAt = function(offset3) {
          return this._dataView.getUint32(offset3, this._littleEndian);
        };
        ExifReader.prototype._getRationalAt = function(offset3) {
          return this._getLongAt(offset3) / this._getLongAt(offset3 + 4);
        };
        ExifReader.prototype._getUndefinedAt = function(offset3) {
          return this._getByteAt(offset3);
        };
        ExifReader.prototype._getSlongAt = function(offset3) {
          return this._dataView.getInt32(offset3, this._littleEndian);
        };
        ExifReader.prototype._getSrationalAt = function(offset3) {
          return this._getSlongAt(offset3) / this._getSlongAt(offset3 + 4);
        };
        ExifReader.prototype._splitNullSeparatedAsciiString = function(string4) {
          var character2, i4, tagValue, _i, _len;
          tagValue = [];
          i4 = 0;
          for (_i = 0, _len = string4.length; _i < _len; _i++) {
            character2 = string4[_i];
            if (character2 === "\0") {
              i4++;
              continue;
            }
            if (tagValue[i4] == null) {
              tagValue[i4] = "";
            }
            tagValue[i4] += character2;
          }
          return tagValue;
        };
        ExifReader.prototype._typeSizes = {
          1: 1,
          2: 1,
          3: 2,
          4: 4,
          5: 8,
          7: 1,
          9: 4,
          10: 8
        };
        ExifReader.prototype._tagTypes = {
          "BYTE": 1,
          "ASCII": 2,
          "SHORT": 3,
          "LONG": 4,
          "RATIONAL": 5,
          "UNDEFINED": 7,
          "SLONG": 9,
          "SRATIONAL": 10
        };
        ExifReader.prototype._tagNames = {
          "0th": {
            256: "ImageWidth",
            257: "ImageLength",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            273: "StripOffsets",
            274: {
              "name": "Orientation",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "top-left";
                  case 2:
                    return "top-right";
                  case 3:
                    return "bottom-right";
                  case 4:
                    return "bottom-left";
                  case 5:
                    return "left-top";
                  case 6:
                    return "right-top";
                  case 7:
                    return "right-bottom";
                  case 8:
                    return "left-bottom";
                  default:
                    return "Undefined";
                }
              }
            },
            277: "SamplesPerPixel",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            282: "XResolution",
            283: "YResolution",
            284: "PlanarConfiguration",
            296: {
              "name": "ResolutionUnit",
              "description": function(value) {
                switch (value) {
                  case 2:
                    return "inches";
                  case 3:
                    return "centimeters";
                  default:
                    return "Unknown";
                }
              }
            },
            301: "TransferFunction",
            305: "Software",
            306: "DateTime",
            315: "Artist",
            318: "WhitePoint",
            319: "PrimaryChromaticities",
            513: "JPEGInterchangeFormat",
            514: "JPEGInterchangeFormatLength",
            529: "YCbCrCoefficients",
            530: "YCbCrSubSampling",
            531: {
              "name": "YCbCrPositioning",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "centered";
                  case 2:
                    return "co-sited";
                  default:
                    return "undefied " + value;
                }
              }
            },
            532: "ReferenceBlackWhite",
            33432: {
              "name": "Copyright",
              "description": function(value) {
                return value.join("; ");
              }
            },
            34665: "Exif IFD Pointer",
            34853: "GPS Info IFD Pointer"
          },
          "exif": {
            33434: "ExposureTime",
            33437: "FNumber",
            34850: {
              "name": "ExposureProgram",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Undefined";
                  case 1:
                    return "Manual";
                  case 2:
                    return "Normal program";
                  case 3:
                    return "Aperture priority";
                  case 4:
                    return "Shutter priority";
                  case 5:
                    return "Creative program";
                  case 6:
                    return "Action program";
                  case 7:
                    return "Portrait mode";
                  case 8:
                    return "Landscape mode";
                  default:
                    return "Unknown";
                }
              }
            },
            34852: "SpectralSensitivity",
            34855: "ISOSpeedRatings",
            34856: {
              "name": "OECF",
              "description": function(value) {
                return "[Raw OECF table data]";
              }
            },
            36864: {
              "name": "ExifVersion",
              "description": function(value) {
                var charCode, string4, _i, _len;
                string4 = "";
                for (_i = 0, _len = value.length; _i < _len; _i++) {
                  charCode = value[_i];
                  string4 += String.fromCharCode(charCode);
                }
                return string4;
              }
            },
            36867: "DateTimeOriginal",
            36868: "DateTimeDigitized",
            37121: {
              "name": "ComponentsConfiguration",
              "description": function(value) {
                var character2, string4, _i, _len;
                string4 = "";
                for (_i = 0, _len = value.length; _i < _len; _i++) {
                  character2 = value[_i];
                  switch (character2) {
                    case 49:
                      string4 += "Y";
                      break;
                    case 50:
                      string4 += "Cb";
                      break;
                    case 51:
                      string4 += "Cr";
                      break;
                    case 52:
                      string4 += "R";
                      break;
                    case 53:
                      string4 += "G";
                      break;
                    case 54:
                      string4 += "B";
                  }
                }
                return string4;
              }
            },
            37122: "CompressedBitsPerPixel",
            37377: "ShutterSpeedValue",
            37378: "ApertureValue",
            37379: "BrightnessValue",
            37380: "ExposureBiasValue",
            37381: "MaxApertureValue",
            37382: "SubjectDistance",
            37383: {
              "name": "MeteringMode",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "Average";
                  case 2:
                    return "CenterWeightedAverage";
                  case 3:
                    return "Spot";
                  case 4:
                    return "MultiSpot";
                  case 5:
                    return "Pattern";
                  case 6:
                    return "Partial";
                  case 255:
                    return "Other";
                  default:
                    return "Unknown";
                }
              }
            },
            37384: {
              "name": "LightSource",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "Daylight";
                  case 2:
                    return "Fluorescent";
                  case 3:
                    return "Tungsten (incandescent light)";
                  case 4:
                    return "Flash";
                  case 9:
                    return "Fine weather";
                  case 10:
                    return "Cloudy weather";
                  case 11:
                    return "Shade";
                  case 12:
                    return "Daylight fluorescent (D 5700  7100K)";
                  case 13:
                    return "Day white fluorescent (N 4600  5400K)";
                  case 14:
                    return "Cool white fluorescent (W 3900  4500K)";
                  case 15:
                    return "White fluorescent (WW 3200  3700K)";
                  case 17:
                    return "Standard light A";
                  case 18:
                    return "Standard light B";
                  case 19:
                    return "Standard light C";
                  case 20:
                    return "D55";
                  case 21:
                    return "D65";
                  case 22:
                    return "D75";
                  case 23:
                    return "D50";
                  case 24:
                    return "ISO studio tungsten";
                  case 255:
                    return "Other light source";
                  default:
                    return "Unknown";
                }
              }
            },
            37385: {
              "name": "Flash",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Flash did not fire";
                  case 1:
                    return "Flash fired";
                  case 5:
                    return "Strobe return light not detected";
                  case 7:
                    return "Strobe return light detected";
                  case 9:
                    return "Flash fired, compulsory flash mode";
                  case 13:
                    return "Flash fired, compulsory flash mode, return light not detected";
                  case 15:
                    return "Flash fired, compulsory flash mode, return light detected";
                  case 16:
                    return "Flash did not fire, compulsory flash mode";
                  case 24:
                    return "Flash did not fire, auto mode";
                  case 25:
                    return "Flash fired, auto mode";
                  case 29:
                    return "Flash fired, auto mode, return light not detected";
                  case 31:
                    return "Flash fired, auto mode, return light detected";
                  case 32:
                    return "No flash function";
                  case 65:
                    return "Flash fired, red-eye reduction mode";
                  case 69:
                    return "Flash fired, red-eye reduction mode, return light not detected";
                  case 71:
                    return "Flash fired, red-eye reduction mode, return light detected";
                  case 73:
                    return "Flash fired, compulsory flash mode, red-eye reduction mode";
                  case 77:
                    return "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected";
                  case 79:
                    return "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected";
                  case 89:
                    return "Flash fired, auto mode, red-eye reduction mode";
                  case 93:
                    return "Flash fired, auto mode, return light not detected, red-eye reduction mode";
                  case 95:
                    return "Flash fired, auto mode, return light detected, red-eye reduction mode";
                  default:
                    return "Unknown";
                }
              }
            },
            37386: "FocalLength",
            37396: {
              "name": "SubjectArea",
              "description": function(value) {
                switch (value.length) {
                  case 2:
                    return "Location; X: " + value[0] + ", Y: " + value[1];
                  case 3:
                    return "Circle; X: " + value[0] + ", Y: " + value[1] + ", diameter: " + value[2];
                  case 4:
                    return "Rectangle; X: " + value[0] + ", Y: " + value[1] + ", width: " + value[2] + ", height: " + value[3];
                  default:
                    return "Unknown";
                }
              }
            },
            37500: {
              "name": "MakerNote",
              "description": function(value) {
                return "[Raw maker note data]";
              }
            },
            37510: {
              "name": "UserComment",
              "description": function(value) {
                switch (value.slice(0, 8).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join("")) {
                  case "ASCII\0\0\0":
                    return value.slice(8, value.length).map(function(charCode) {
                      return String.fromCharCode(charCode);
                    }).join("");
                  case "JIS\0\0\0\0\0":
                    return "[JIS encoded text]";
                  case "UNICODE\0":
                    return "[Unicode encoded text]";
                  case "\0\0\0\0\0\0\0\0":
                    return "[Undefined encoding]";
                }
              }
            },
            37520: "SubSecTime",
            37521: "SubSecTimeOriginal",
            37522: "SubSecTimeDigitized",
            40960: {
              "name": "FlashpixVersion",
              "description": function(value) {
                var charCode, string4, _i, _len;
                string4 = "";
                for (_i = 0, _len = value.length; _i < _len; _i++) {
                  charCode = value[_i];
                  string4 += String.fromCharCode(charCode);
                }
                return string4;
              }
            },
            40961: {
              "name": "ColorSpace",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "sRGB";
                  case 65535:
                    return "Uncalibrated";
                  default:
                    return "Unknown";
                }
              }
            },
            40962: "PixelXDimension",
            40963: "PixelYDimension",
            40964: "RelatedSoundFile",
            40965: "Interoperability IFD Pointer",
            41483: "FlashEnergy",
            41484: {
              "name": "SpatialFrequencyResponse",
              "description": function(value) {
                return "[Raw SFR table data]";
              }
            },
            41486: "FocalPlaneXResolution",
            41487: "FocalPlaneYResolution",
            41488: {
              "name": "FocalPlaneResolutionUnit",
              "description": function(value) {
                switch (value) {
                  case 2:
                    return "inches";
                  case 3:
                    return "centimeters";
                  default:
                    return "Unknown";
                }
              }
            },
            41492: {
              "name": "SubjectLocation",
              "description": function(value) {
                return "X: " + value[0] + ", Y: " + value[1];
              }
            },
            41493: "ExposureIndex",
            41495: {
              "name": "SensingMethod",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "Undefined";
                  case 2:
                    return "One-chip color area sensor";
                  case 3:
                    return "Two-chip color area sensor";
                  case 4:
                    return "Three-chip color area sensor";
                  case 5:
                    return "Color sequential area sensor";
                  case 7:
                    return "Trilinear sensor";
                  case 8:
                    return "Color sequential linear sensor";
                  default:
                    return "Unknown";
                }
              }
            },
            41728: {
              "name": "FileSource",
              "description": function(value) {
                switch (value) {
                  case 3:
                    return "DSC";
                  default:
                    return "Unknown";
                }
              }
            },
            41729: {
              "name": "SceneType",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "A directly photographed image";
                  default:
                    return "Unknown";
                }
              }
            },
            41730: {
              "name": "CFAPattern",
              "description": function(value) {
                return "[Raw CFA pattern table data]";
              }
            },
            41985: {
              "name": "CustomRendered",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Normal process";
                  case 1:
                    return "Custom process";
                  default:
                    return "Unknown";
                }
              }
            },
            41986: {
              "name": "ExposureMode",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Auto exposure";
                  case 1:
                    return "Manual exposure";
                  case 2:
                    return "Auto bracket";
                  default:
                    return "Unknown";
                }
              }
            },
            41987: {
              "name": "WhiteBalance",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Auto white balance";
                  case 1:
                    return "Manual white balance";
                  default:
                    return "Unknown";
                }
              }
            },
            41988: {
              "name": "DigitalZoomRatio",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Digital zoom was not used";
                  default:
                    return value;
                }
              }
            },
            41989: {
              "name": "FocalLengthIn35mmFilm",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Unknown";
                  default:
                    return value;
                }
              }
            },
            41990: {
              "name": "SceneCaptureType",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Standard";
                  case 1:
                    return "Landscape";
                  case 2:
                    return "Portrait";
                  case 3:
                    return "Night scene";
                  default:
                    return "Unknown";
                }
              }
            },
            41991: {
              "name": "GainControl",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "None";
                  case 1:
                    return "Low gain up";
                  case 2:
                    return "High gain up";
                  case 3:
                    return "Low gain down";
                  case 4:
                    return "High gain down";
                  default:
                    return "Unknown";
                }
              }
            },
            41992: {
              "name": "Contrast",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Normal";
                  case 1:
                    return "Soft";
                  case 2:
                    return "Hard";
                  default:
                    return "Unknown";
                }
              }
            },
            41993: {
              "name": "Saturation",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Normal";
                  case 1:
                    return "Low saturation";
                  case 2:
                    return "High saturation";
                  default:
                    return "Unknown";
                }
              }
            },
            41994: {
              "name": "Sharpness",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Normal";
                  case 1:
                    return "Soft";
                  case 2:
                    return "Hard";
                  default:
                    return "Unknown";
                }
              }
            },
            41995: {
              "name": "DeviceSettingDescription",
              "description": function(value) {
                return "[Raw device settings table data]";
              }
            },
            41996: {
              "name": "SubjectDistanceRange",
              "description": function(value) {
                switch (value) {
                  case 1:
                    return "Macro";
                  case 2:
                    return "Close view";
                  case 3:
                    return "Distant view";
                  default:
                    return "Unknown";
                }
              }
            },
            42016: "ImageUniqueID"
          },
          "gps": {
            0: {
              "name": "GPSVersionID",
              "description": function(value) {
                var _ref2, _ref1;
                if (value[0] === (_ref2 = value[1]) && _ref2 === 2 && (value[2] === (_ref1 = value[3]) && _ref1 === 0)) {
                  return "Version 2.2";
                } else {
                  return "Unknown";
                }
              }
            },
            1: {
              "name": "GPSLatitudeRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "N":
                    return "North latitude";
                  case "S":
                    return "South latitude";
                  default:
                    return "Unknown";
                }
              }
            },
            2: {
              "name": "GPSLatitude",
              "description": function(value) {
                return value[0] + value[1] / 60 + value[2] / 3600;
              }
            },
            3: {
              "name": "GPSLongitudeRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "E":
                    return "East longitude";
                  case "W":
                    return "West longitude";
                  default:
                    return "Unknown";
                }
              }
            },
            4: {
              "name": "GPSLongitude",
              "description": function(value) {
                return value[0] + value[1] / 60 + value[2] / 3600;
              }
            },
            5: {
              "name": "GPSAltitudeRef",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Sea level";
                  case 1:
                    return "Sea level reference (negative value)";
                  default:
                    return "Unknown";
                }
              }
            },
            6: {
              "name": "GPSAltitude",
              "description": function(value) {
                return value + " m";
              }
            },
            7: {
              "name": "GPSTimeStamp",
              "description": function(value) {
                var padZero;
                padZero = function(num) {
                  var i4;
                  return function() {
                    var _i, _ref2, _results;
                    _results = [];
                    for (i4 = _i = 0, _ref2 = 2 - ("" + Math.floor(num)).length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i4 = 0 <= _ref2 ? ++_i : --_i) {
                      _results.push("0");
                    }
                    return _results;
                  }() + num;
                };
                return value.map(padZero).join(":");
              }
            },
            8: "GPSSatellites",
            9: {
              "name": "GPSStatus",
              "description": function(value) {
                switch (value.join("")) {
                  case "A":
                    return "Measurement in progress";
                  case "V":
                    return "Measurement Interoperability";
                  default:
                    return "Unknown";
                }
              }
            },
            10: {
              "name": "GPSMeasureMode",
              "description": function(value) {
                switch (value.join("")) {
                  case "2":
                    return "2-dimensional measurement";
                  case "3":
                    return "3-dimensional measurement";
                  default:
                    return "Unknown";
                }
              }
            },
            11: "GPSDOP",
            12: {
              "name": "GPSSpeedRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "K":
                    return "Kilometers per hour";
                  case "M":
                    return "Miles per hour";
                  case "N":
                    return "Knots";
                  default:
                    return "Unknown";
                }
              }
            },
            13: "GPSSpeed",
            14: {
              "name": "GPSTrackRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "T":
                    return "True direction";
                  case "M":
                    return "Magnetic direction";
                  default:
                    return "Unknown";
                }
              }
            },
            15: "GPSTrack",
            16: {
              "name": "GPSImgDirectionRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "T":
                    return "True direction";
                  case "M":
                    return "Magnetic direction";
                  default:
                    return "Unknown";
                }
              }
            },
            17: "GPSImgDirection",
            18: "GPSMapDatum",
            19: {
              "name": "GPSDestLatitudeRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "N":
                    return "North latitude";
                  case "S":
                    return "South latitude";
                  default:
                    return "Unknown";
                }
              }
            },
            20: {
              "name": "GPSDestLatitude",
              "description": function(value) {
                return value[0] + value[1] / 60 + value[2] / 3600;
              }
            },
            21: {
              "name": "GPSDestLongitudeRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "E":
                    return "East longitude";
                  case "W":
                    return "West longitude";
                  default:
                    return "Unknown";
                }
              }
            },
            22: {
              "name": "GPSDestLongitude",
              "description": function(value) {
                return value[0] + value[1] / 60 + value[2] / 3600;
              }
            },
            23: {
              "name": "GPSDestBearingRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "T":
                    return "True direction";
                  case "M":
                    return "Magnetic direction";
                  default:
                    return "Unknown";
                }
              }
            },
            24: "GPSDestBearing",
            25: {
              "name": "GPSDestDistanceRef",
              "description": function(value) {
                switch (value.join("")) {
                  case "K":
                    return "Kilometers";
                  case "M":
                    return "Miles";
                  case "N":
                    return "Knots";
                  default:
                    return "Unknown";
                }
              }
            },
            26: "GPSDestDistance",
            27: {
              "name": "GPSProcessingMethod",
              "description": function(value) {
                switch (value.slice(0, 8).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join("")) {
                  case "ASCII\0\0\0":
                    return value.slice(8, value.length).map(function(charCode) {
                      return String.fromCharCode(charCode);
                    }).join("");
                  case "JIS\0\0\0\0\0":
                    return "[JIS encoded text]";
                  case "UNICODE\0":
                    return "[Unicode encoded text]";
                  case "\0\0\0\0\0\0\0\0":
                    return "[Undefined encoding]";
                }
              }
            },
            28: {
              "name": "GPSAreaInformation",
              "description": function(value) {
                switch (value.slice(0, 8).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join("")) {
                  case "ASCII\0\0\0":
                    return value.slice(8, value.length).map(function(charCode) {
                      return String.fromCharCode(charCode);
                    }).join("");
                  case "JIS\0\0\0\0\0":
                    return "[JIS encoded text]";
                  case "UNICODE\0":
                    return "[Unicode encoded text]";
                  case "\0\0\0\0\0\0\0\0":
                    return "[Undefined encoding]";
                }
              }
            },
            29: "GPSDateStamp",
            30: {
              "name": "GPSDifferential",
              "description": function(value) {
                switch (value) {
                  case 0:
                    return "Measurement without differential correction";
                  case 1:
                    return "Differential correction applied";
                  default:
                    return "Unknown";
                }
              }
            }
          },
          "interoperability": {
            1: "InteroperabilityIndex",
            2: "UnknownInteroperabilityTag0x0002",
            4097: "UnknownInteroperabilityTag0x1001",
            4098: "UnknownInteroperabilityTag0x1002"
          }
        };
        ExifReader.prototype.getTagValue = function(name) {
          if (this._tags[name] != null) {
            return this._tags[name].value;
          } else {
            return void 0;
          }
        };
        ExifReader.prototype.getTagDescription = function(name) {
          if (this._tags[name] != null) {
            return this._tags[name].description;
          } else {
            return void 0;
          }
        };
        ExifReader.prototype.getAllTags = function() {
          return this._tags;
        };
        return ExifReader;
      }();
    }).call(exports);
  }
});

// node_modules/exif-component/index.js
var require_exif_component = __commonJS({
  "node_modules/exif-component/index.js"(exports, module2) {
    var ExifReader = require_ExifReader().ExifReader;
    module2.exports = function(buf) {
      var exif = new ExifReader();
      exif.load(buf);
      var tags = exif.getAllTags();
      var out = {};
      for (var tag in tags) {
        out[spaces(tag)] = tags[tag].description;
      }
      return out;
    };
    function spaces(str) {
      return str.replace(/([A-Z][a-z])|([a-z][A-Z])|([A-Z])/g, function(m4) {
        return 1 == m4.length ? m4.toLowerCase() : m4[0] == m4[0].toUpperCase() ? " " + m4.toLowerCase() : m4[0] + " " + m4[1].toLowerCase();
      }).replace(/^\s+|\s+$/g, "");
    }
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports, module2) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike2 = require_isArrayLike();
    var keys2 = require_keys();
    function createFind2(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike2(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys2(collection);
          predicate = function(key2) {
            return iteratee(iterable[key2], key2, iterable);
          };
        }
        var index3 = findIndexFunc(collection, predicate, fromIndex);
        return index3 > -1 ? iterable[iteratee ? collection[index3] : index3] : void 0;
      };
    }
    module2.exports = createFind2;
  }
});

// node_modules/lodash/find.js
var require_find2 = __commonJS({
  "node_modules/lodash/find.js"(exports, module2) {
    var createFind2 = require_createFind();
    var findIndex3 = require_findIndex();
    var find2 = createFind2(findIndex3);
    module2.exports = find2;
  }
});

// node_modules/lodash/_baseRange.js
var require_baseRange = __commonJS({
  "node_modules/lodash/_baseRange.js"(exports, module2) {
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function baseRange(start2, end2, step, fromRight) {
      var index3 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result = Array(length2);
      while (length2--) {
        result[fromRight ? length2 : ++index3] = start2;
        start2 += step;
      }
      return result;
    }
    module2.exports = baseRange;
  }
});

// node_modules/lodash/_createRange.js
var require_createRange = __commonJS({
  "node_modules/lodash/_createRange.js"(exports, module2) {
    var baseRange = require_baseRange();
    var isIterateeCall = require_isIterateeCall();
    var toFinite = require_toFinite();
    function createRange(fromRight) {
      return function(start2, end2, step) {
        if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
          end2 = step = void 0;
        }
        start2 = toFinite(start2);
        if (end2 === void 0) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        step = step === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step);
        return baseRange(start2, end2, step, fromRight);
      };
    }
    module2.exports = createRange;
  }
});

// node_modules/lodash/range.js
var require_range = __commonJS({
  "node_modules/lodash/range.js"(exports, module2) {
    var createRange = require_createRange();
    var range3 = createRange();
    module2.exports = range3;
  }
});

// node_modules/speakingurl/lib/speakingurl.js
var require_speakingurl = __commonJS({
  "node_modules/speakingurl/lib/speakingurl.js"(exports, module2) {
    (function(root) {
      "use strict";
      var charMap = {
        // latin
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "Ae",
        "": "A",
        "": "AE",
        "": "C",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "D",
        "": "N",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "Oe",
        "": "O",
        "": "O",
        "": "U",
        "": "U",
        "": "U",
        "": "Ue",
        "": "U",
        "": "Y",
        "": "TH",
        "": "ss",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "ae",
        "": "a",
        "": "ae",
        "": "c",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "d",
        "": "n",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "oe",
        "": "o",
        "": "o",
        "": "u",
        "": "u",
        "": "u",
        "": "ue",
        "": "u",
        "": "y",
        "": "th",
        "": "y",
        "": "SS",
        // language specific
        // Arabic
        "": "a",
        "": "a",
        "": "i",
        "": "aa",
        "": "u",
        "": "e",
        "": "a",
        "": "b",
        "": "t",
        "": "th",
        "": "j",
        "": "h",
        "": "kh",
        "": "d",
        "": "th",
        "": "r",
        "": "z",
        "": "s",
        "": "sh",
        "": "s",
        "": "dh",
        "": "t",
        "": "z",
        "": "a",
        "": "gh",
        "": "f",
        "": "q",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "h",
        "": "w",
        "": "y",
        "": "a",
        "": "h",
        "": "la",
        "": "laa",
        "": "lai",
        "": "laa",
        // Persian additional characters than Arabic
        "": "g",
        "": "ch",
        "": "p",
        "": "zh",
        "": "k",
        "": "y",
        // Arabic diactrics
        "": "a",
        "": "an",
        "": "e",
        "": "en",
        "": "u",
        "": "on",
        "": "",
        // Arabic numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Persian numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Burmese consonants
        "": "k",
        "": "kh",
        "": "g",
        "": "ga",
        "": "ng",
        "": "s",
        "": "sa",
        "": "z",
        "": "za",
        "": "ny",
        "": "t",
        "": "ta",
        "": "d",
        "": "da",
        "": "na",
        "": "t",
        "": "ta",
        "": "d",
        "": "da",
        "": "n",
        "": "p",
        "": "pa",
        "": "b",
        "": "ba",
        "": "m",
        "": "y",
        "": "ya",
        "": "l",
        "": "w",
        "": "th",
        "": "h",
        "": "la",
        "": "a",
        // consonant character combos
        "": "y",
        "": "ya",
        "": "w",
        "": "yw",
        "": "ywa",
        "": "h",
        // independent vowels
        "": "e",
        "": "-e",
        "": "i",
        "": "-i",
        "": "u",
        "": "-u",
        "": "aw",
        "": "aw",
        "": "aw",
        // numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // virama and tone marks which are silent in transliteration
        "": "",
        "": "",
        "": "",
        // Czech
        "": "c",
        "": "d",
        "": "e",
        "": "n",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "z",
        "": "C",
        "": "D",
        "": "E",
        "": "N",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "Z",
        // Dhivehi
        "": "h",
        "": "sh",
        "": "n",
        "": "r",
        "": "b",
        "": "lh",
        "": "k",
        "": "a",
        "": "v",
        "": "m",
        "": "f",
        "": "dh",
        "": "th",
        "": "l",
        "": "g",
        "": "gn",
        "": "s",
        "": "d",
        "": "z",
        "": "t",
        "": "y",
        "": "p",
        "": "j",
        "": "ch",
        "": "tt",
        "": "hh",
        "": "kh",
        "": "th",
        "": "z",
        "": "sh",
        "": "s",
        "": "d",
        "": "t",
        "": "z",
        "": "a",
        "": "gh",
        "": "q",
        "": "w",
        "": "a",
        "": "aa",
        "": "i",
        "": "ee",
        "": "u",
        "": "oo",
        "": "e",
        "": "ey",
        "": "o",
        "": "oa",
        "": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        "": "a",
        "": "b",
        "": "g",
        "": "d",
        "": "e",
        "": "v",
        "": "z",
        "": "t",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "zh",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "p",
        "": "k",
        "": "gh",
        "": "q",
        "": "sh",
        "": "ch",
        "": "ts",
        "": "dz",
        "": "ts",
        "": "ch",
        "": "kh",
        "": "j",
        "": "h",
        // Greek
        "": "a",
        "": "v",
        "": "g",
        "": "d",
        "": "e",
        "": "z",
        "": "i",
        "": "th",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "ks",
        "": "o",
        "": "p",
        "": "r",
        "": "s",
        "": "t",
        "": "y",
        "": "f",
        "": "x",
        "": "ps",
        "": "o",
        "": "a",
        "": "e",
        "": "i",
        "": "o",
        "": "y",
        "": "i",
        "": "o",
        "": "s",
        "": "i",
        "": "y",
        "": "y",
        "": "i",
        "": "A",
        "": "B",
        "": "G",
        "": "D",
        "": "E",
        "": "Z",
        "": "I",
        "": "TH",
        "": "I",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "KS",
        "": "O",
        "": "P",
        "": "R",
        "": "S",
        "": "T",
        "": "Y",
        "": "F",
        "": "X",
        "": "PS",
        "": "O",
        "": "A",
        "": "E",
        "": "I",
        "": "O",
        "": "Y",
        "": "I",
        "": "O",
        "": "I",
        "": "Y",
        // Latvian
        "": "a",
        // '': 'c', // duplicate
        "": "e",
        "": "g",
        "": "i",
        "": "k",
        "": "l",
        "": "n",
        // '': 's', // duplicate
        "": "u",
        // '': 'z', // duplicate
        "": "A",
        // '': 'C', // duplicate
        "": "E",
        "": "G",
        "": "I",
        "": "k",
        "": "L",
        "": "N",
        // '': 'S', // duplicate
        "": "U",
        // '': 'Z', // duplicate
        // Macedonian
        "": "Kj",
        "": "kj",
        "": "Lj",
        "": "lj",
        "": "Nj",
        "": "nj",
        "": "Ts",
        "": "ts",
        // Polish
        "": "a",
        "": "c",
        "": "e",
        "": "l",
        "": "n",
        // '': 'o', // duplicate
        "": "s",
        "": "z",
        "": "z",
        "": "A",
        "": "C",
        "": "E",
        "": "L",
        "": "N",
        "": "S",
        "": "Z",
        "": "Z",
        // Ukranian
        "": "Ye",
        "": "I",
        "": "Yi",
        "": "G",
        "": "ye",
        "": "i",
        "": "yi",
        "": "g",
        // Romanian
        "": "a",
        "": "A",
        "": "s",
        "": "S",
        // '': 's', // duplicate
        // '': 'S', // duplicate
        "": "t",
        "": "T",
        "": "t",
        "": "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        "": "a",
        "": "b",
        "": "v",
        "": "g",
        "": "d",
        "": "e",
        "": "yo",
        "": "zh",
        "": "z",
        "": "i",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "f",
        "": "kh",
        "": "c",
        "": "ch",
        "": "sh",
        "": "sh",
        "": "",
        "": "y",
        "": "",
        "": "e",
        "": "yu",
        "": "ya",
        "": "A",
        "": "B",
        "": "V",
        "": "G",
        "": "D",
        "": "E",
        "": "Yo",
        "": "Zh",
        "": "Z",
        "": "I",
        "": "I",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "F",
        "": "Kh",
        "": "C",
        "": "Ch",
        "": "Sh",
        "": "Sh",
        "": "",
        "": "Y",
        "": "",
        "": "E",
        "": "Yu",
        "": "Ya",
        // Serbian
        "": "dj",
        "": "j",
        // '': 'lj',  // duplicate
        // '': 'nj', // duplicate
        "": "c",
        "": "dz",
        "": "Dj",
        "": "j",
        // '': 'Lj', // duplicate
        // '': 'Nj', // duplicate
        "": "C",
        "": "Dz",
        // Slovak
        "": "l",
        "": "l",
        "": "r",
        "": "L",
        "": "L",
        "": "R",
        // Turkish
        "": "s",
        "": "S",
        "": "i",
        "": "I",
        // '': 'c', // duplicate
        // '': 'C', // duplicate
        // '': 'u', // duplicate, see langCharMap
        // '': 'U', // duplicate, see langCharMap
        // '': 'o', // duplicate, see langCharMap
        // '': 'O', // duplicate, see langCharMap
        "": "g",
        "": "G",
        // Vietnamese
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "d",
        "": "D",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "o",
        "": "i",
        "": "I",
        "": "i",
        "": "I",
        "": "i",
        "": "i",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "",
        "": "y",
        "": "y",
        "": "y",
        "": "Y",
        "": "y",
        "": "Y",
        "": "y",
        "": "Y",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        // '': 'a', // duplicate
        // '': 'A', // duplicate
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "18",
        "": "18",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "0",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "19",
        "": "20",
        "": "A",
        "": "B",
        "": "C",
        "": "D",
        "": "E",
        "": "F",
        "": "G",
        "": "H",
        "": "I",
        "": "J",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "Q",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "V",
        "": "W",
        "": "X",
        "": "Y",
        "": "Z",
        "": "a",
        "": "b",
        "": "c",
        "": "d",
        "": "e",
        "": "f",
        "": "g",
        "": "h",
        "": "i",
        "": "j",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "q",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "v",
        "": "w",
        "": "x",
        "": "y",
        "": "z",
        // symbols
        "": '"',
        "": '"',
        "": "'",
        "": "'",
        "": "d",
        "": "f",
        "": "(TM)",
        "": "(C)",
        "": "oe",
        "": "OE",
        "": "(R)",
        "": "+",
        "": "(SM)",
        "": "...",
        "": "o",
        "": "o",
        "": "a",
        "": "*",
        "": ",",
        "": ".",
        // currency
        "$": "USD",
        "": "EUR",
        "": "BRN",
        "": "FRF",
        "": "GBP",
        "": "ITL",
        "": "NGN",
        "": "ESP",
        "": "KRW",
        "": "ILS",
        "": "VND",
        "": "LAK",
        "": "MNT",
        "": "GRD",
        "": "ARS",
        "": "PYG",
        "": "ARA",
        "": "UAH",
        "": "GHS",
        "": "cent",
        "": "CNY",
        "": "CNY",
        "": "YEN",
        "": "IRR",
        "": "EWE",
        "": "THB",
        "": "INR",
        "": "INR",
        "": "PF",
        "": "TRY",
        "": "AFN",
        "": "AZN",
        "": "BGN",
        "": "KHR",
        "": "CRC",
        "": "KZT",
        "": "MKD",
        "z": "PLN",
        "": "RUB",
        "": "GEL"
      };
      var lookAheadCharArray = [
        // burmese
        "",
        // Dhivehi
        ""
      ];
      var diatricMap = {
        // Burmese
        // dependent vowels
        "": "a",
        "": "a",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "o",
        "": "u",
        "": "u",
        "": "aung",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "",
        // this is special case but the character will be converted to latin in the code
        "": "et",
        "": "aik",
        "": "auk",
        "": "in",
        "": "aing",
        "": "aung",
        "": "it",
        "": "i",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "it",
        "": "d",
        "": "ok",
        "": "ait",
        "": "an",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "nub",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "e",
        "": "ol",
        "": "in",
        "": "an",
        "": "ein",
        "": "on",
        // Dhivehi
        "": "ah",
        "": "ah"
      };
      var langCharMap = {
        "en": {},
        // default language
        "az": {
          // Azerbaijani
          "": "c",
          "": "e",
          "": "g",
          "": "i",
          "": "o",
          "": "s",
          "": "u",
          "": "C",
          "": "E",
          "": "G",
          "": "I",
          "": "O",
          "": "S",
          "": "U"
        },
        "cs": {
          // Czech
          "": "c",
          "": "d",
          "": "e",
          "": "n",
          "": "r",
          "": "s",
          "": "t",
          "": "u",
          "": "z",
          "": "C",
          "": "D",
          "": "E",
          "": "N",
          "": "R",
          "": "S",
          "": "T",
          "": "U",
          "": "Z"
        },
        "fi": {
          // Finnish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "a",
          // ok
          "": "A",
          // ok
          "": "o",
          // ok
          "": "O"
          // ok
        },
        "hu": {
          // Hungarian
          "": "a",
          // ok
          "": "A",
          // ok
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "o",
          // ok
          "": "O",
          // ok
          // '': 'o', duplicate see charMap/latin
          // '': 'O', duplicate see charMap/latin
          "": "u",
          "": "U",
          "": "u",
          "": "U"
        },
        "lt": {
          // Lithuanian
          "": "a",
          "": "c",
          "": "e",
          "": "e",
          "": "i",
          "": "s",
          "": "u",
          "": "u",
          "": "z",
          "": "A",
          "": "C",
          "": "E",
          "": "E",
          "": "I",
          "": "S",
          "": "U",
          "": "U"
        },
        "lv": {
          // Latvian
          "": "a",
          "": "c",
          "": "e",
          "": "g",
          "": "i",
          "": "k",
          "": "l",
          "": "n",
          "": "s",
          "": "u",
          "": "z",
          "": "A",
          "": "C",
          "": "E",
          "": "G",
          "": "i",
          "": "k",
          "": "L",
          "": "N",
          "": "S",
          "": "u",
          "": "Z"
        },
        "pl": {
          // Polish
          "": "a",
          "": "c",
          "": "e",
          "": "l",
          "": "n",
          "": "o",
          "": "s",
          "": "z",
          "": "z",
          "": "A",
          "": "C",
          "": "e",
          "": "L",
          "": "N",
          "": "O",
          "": "S",
          "": "Z",
          "": "Z"
        },
        "sv": {
          // Swedish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "a",
          // ok
          "": "A",
          // ok
          "": "o",
          // ok
          "": "O"
          // ok
        },
        "sk": {
          // Slovak
          "": "a",
          "": "A"
        },
        "sr": {
          // Serbian
          "": "lj",
          "": "nj",
          "": "Lj",
          "": "Nj",
          "": "dj",
          "": "Dj"
        },
        "tr": {
          // Turkish
          "": "U",
          "": "O",
          "": "u",
          "": "o"
        }
      };
      var symbolMap = {
        "ar": {
          "": "delta",
          "": "la-nihaya",
          "": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "": "majmou",
          "": "omla"
        },
        "az": {},
        "ca": {
          "": "delta",
          "": "infinit",
          "": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "": "suma dels",
          "": "moneda"
        },
        "cs": {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "": "soucet",
          "": "mena"
        },
        "de": {
          "": "delta",
          "": "unendlich",
          "": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "": "Summe von",
          "": "Waehrung"
        },
        "dv": {
          "": "delta",
          "": "kolunulaa",
          "": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "": "jumula",
          "": "faisaa"
        },
        "en": {
          "": "delta",
          "": "infinity",
          "": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "": "sum",
          "": "currency"
        },
        "es": {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "": "suma de los",
          "": "moneda"
        },
        "fa": {
          "": "delta",
          "": "bi-nahayat",
          "": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "": "majmooe",
          "": "vahed"
        },
        "fi": {
          "": "delta",
          "": "aarettomyys",
          "": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "": "summa",
          "": "valuutta"
        },
        "fr": {
          "": "delta",
          "": "infiniment",
          "": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "": "somme des",
          "": "monnaie"
        },
        "ge": {
          "": "delta",
          "": "usasruloba",
          "": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "": "jami",
          "": "valuta"
        },
        "gr": {},
        "hu": {
          "": "delta",
          "": "vegtelen",
          "": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "": "szumma",
          "": "penznem"
        },
        "it": {
          "": "delta",
          "": "infinito",
          "": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "": "somma",
          "": "moneta"
        },
        "lt": {
          "": "delta",
          "": "begalybe",
          "": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "": "suma",
          "": "valiuta"
        },
        "lv": {
          "": "delta",
          "": "bezgaliba",
          "": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "": "summa",
          "": "valuta"
        },
        "my": {
          "": "kwahkhyaet",
          "": "asaonasme",
          "": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "": "paungld",
          "": "ngwekye"
        },
        "mk": {},
        "nl": {
          "": "delta",
          "": "oneindig",
          "": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "": "som",
          "": "valuta"
        },
        "pl": {
          "": "delta",
          "": "nieskonczonosc",
          "": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "": "suma",
          "": "waluta"
        },
        "pt": {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "": "soma",
          "": "moeda"
        },
        "ro": {
          "": "delta",
          "": "infinit",
          "": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "": "suma",
          "": "valuta"
        },
        "ru": {
          "": "delta",
          "": "beskonechno",
          "": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "": "summa",
          "": "valjuta"
        },
        "sk": {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "": "sucet",
          "": "mena"
        },
        "sr": {},
        "tr": {
          "": "delta",
          "": "sonsuzluk",
          "": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "": "toplam",
          "": "para birimi"
        },
        "uk": {
          "": "delta",
          "": "bezkinechnist",
          "": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "": "suma",
          "": "valjuta"
        },
        "vn": {
          "": "delta",
          "": "vo cuc",
          "": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "": "tong",
          "": "tien te"
        }
      };
      var uricChars = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join("");
      var uricNoSlashChars = [";", "?", ":", "@", "&", "=", "+", "$", ","].join("");
      var markChars = [".", "!", "~", "*", "'", "(", ")"].join("");
      var getSlug = function getSlug2(input, opts) {
        var separator = "-";
        var result = "";
        var diatricString = "";
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i4;
        var ch;
        var l3;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = "";
        if (typeof input !== "string") {
          return "";
        }
        if (typeof opts === "string") {
          separator = opts;
        }
        symbol = symbolMap.en;
        langChar = langCharMap.en;
        if (typeof opts === "object") {
          maintainCase = opts.maintainCase || false;
          customReplacements = opts.custom && typeof opts.custom === "object" ? opts.custom : customReplacements;
          truncate = +opts.truncate > 1 && opts.truncate || false;
          uricFlag = opts.uric || false;
          uricNoSlashFlag = opts.uricNoSlash || false;
          markFlag = opts.mark || false;
          convertSymbols = opts.symbols === false || opts.lang === false ? false : true;
          separator = opts.separator || separator;
          if (uricFlag) {
            allowedChars += uricChars;
          }
          if (uricNoSlashFlag) {
            allowedChars += uricNoSlashChars;
          }
          if (markFlag) {
            allowedChars += markChars;
          }
          symbol = opts.lang && symbolMap[opts.lang] && convertSymbols ? symbolMap[opts.lang] : convertSymbols ? symbolMap.en : {};
          langChar = opts.lang && langCharMap[opts.lang] ? langCharMap[opts.lang] : opts.lang === false || opts.lang === true ? {} : langCharMap.en;
          if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {
            opts.titleCase.forEach(function(v2) {
              customReplacements[v2 + ""] = v2 + "";
            });
            titleCase = true;
          } else {
            titleCase = !!opts.titleCase;
          }
          if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {
            opts.custom.forEach(function(v2) {
              customReplacements[v2 + ""] = v2 + "";
            });
          }
          Object.keys(customReplacements).forEach(function(v2) {
            var r4;
            if (v2.length > 1) {
              r4 = new RegExp("\\b" + escapeChars(v2) + "\\b", "gi");
            } else {
              r4 = new RegExp(escapeChars(v2), "gi");
            }
            input = input.replace(r4, customReplacements[v2]);
          });
          for (ch in customReplacements) {
            allowedChars += ch;
          }
        }
        allowedChars += separator;
        allowedChars = escapeChars(allowedChars);
        input = input.replace(/(^\s+|\s+$)/g, "");
        lastCharWasSymbol = false;
        lastCharWasDiatric = false;
        for (i4 = 0, l3 = input.length; i4 < l3; i4++) {
          ch = input[i4];
          if (isReplacedCustomChar(ch, customReplacements)) {
            lastCharWasSymbol = false;
          } else if (langChar[ch]) {
            ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? " " + langChar[ch] : langChar[ch];
            lastCharWasSymbol = false;
          } else if (ch in charMap) {
            if (i4 + 1 < l3 && lookAheadCharArray.indexOf(input[i4 + 1]) >= 0) {
              diatricString += ch;
              ch = "";
            } else if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + charMap[ch];
              diatricString = "";
            } else {
              ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? " " + charMap[ch] : charMap[ch];
            }
            lastCharWasSymbol = false;
            lastCharWasDiatric = false;
          } else if (ch in diatricMap) {
            diatricString += ch;
            ch = "";
            if (i4 === l3 - 1) {
              ch = diatricMap[diatricString];
            }
            lastCharWasDiatric = true;
          } else if (
            // process symbol chars
            symbol[ch] && !(uricFlag && uricChars.indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.indexOf(ch) !== -1)
          ) {
            ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
            ch += input[i4 + 1] !== void 0 && input[i4 + 1].match(/[A-Za-z0-9]/) ? separator : "";
            lastCharWasSymbol = true;
          } else {
            if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + ch;
              diatricString = "";
              lastCharWasDiatric = false;
            } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
              ch = " " + ch;
            }
            lastCharWasSymbol = false;
          }
          result += ch.replace(new RegExp("[^\\w\\s" + allowedChars + "_-]", "g"), separator);
        }
        if (titleCase) {
          result = result.replace(/(\w)(\S*)/g, function(_2, i5, r4) {
            var j2 = i5.toUpperCase() + (r4 !== null ? r4 : "");
            return Object.keys(customReplacements).indexOf(j2.toLowerCase()) < 0 ? j2 : j2.toLowerCase();
          });
        }
        result = result.replace(/\s+/g, separator).replace(new RegExp("\\" + separator + "+", "g"), separator).replace(new RegExp("(^\\" + separator + "+|\\" + separator + "+$)", "g"), "");
        if (truncate && result.length > truncate) {
          lucky = result.charAt(truncate) === separator;
          result = result.slice(0, truncate);
          if (!lucky) {
            result = result.slice(0, result.lastIndexOf(separator));
          }
        }
        if (!maintainCase && !titleCase) {
          result = result.toLowerCase();
        }
        return result;
      };
      var createSlug = function createSlug2(opts) {
        return function getSlugWithConfig(input) {
          return getSlug(input, opts);
        };
      };
      var escapeChars = function escapeChars2(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      };
      var isReplacedCustomChar = function(ch, customReplacements) {
        for (var c4 in customReplacements) {
          if (customReplacements[c4] === ch) {
            return true;
          }
        }
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = getSlug;
        module2.exports.createSlug = createSlug;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return getSlug;
        });
      } else {
        try {
          if (root.getSlug || root.createSlug) {
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          } else {
            root.getSlug = getSlug;
            root.createSlug = createSlug;
          }
        } catch (e5) {
        }
      }
    })(exports);
  }
});

// node_modules/speakingurl/index.js
var require_speakingurl2 = __commonJS({
  "node_modules/speakingurl/index.js"(exports, module2) {
    module2.exports = require_speakingurl();
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index3 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard3 = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard3 && isIterateeCall(sources[0], sources[1], guard3)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object2 = Object(object2);
        while (++index3 < length2) {
          var source = sources[index3];
          if (source) {
            assigner(object2, source, index3, customizer);
          }
        }
        return object2;
      });
    }
    module2.exports = createAssigner;
  }
});

// node_modules/lodash/assignWith.js
var require_assignWith = __commonJS({
  "node_modules/lodash/assignWith.js"(exports, module2) {
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keys2 = require_keys();
    var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
      copyObject(source, keys2(source), object2, customizer);
    });
    module2.exports = assignWith;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object2, props) {
      return arrayMap(props, function(key2) {
        return object2[key2];
      });
    }
    module2.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports, module2) {
    var baseValues = require_baseValues();
    var keys2 = require_keys();
    function values(object2) {
      return object2 == null ? [] : baseValues(object2, keys2(object2));
    }
    module2.exports = values;
  }
});

// node_modules/json-reduce/dist/reduce.js
var require_reduce = __commonJS({
  "node_modules/json-reduce/dist/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SKIP = SKIP;
    exports.reduce = reduce2;
    exports.withCustomPathSegment = exports.SKIP_MARKER = void 0;
    function _slicedToArray(arr, i4) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit(arr, i4) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e2 = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i4 && _arr.length === i4)
            break;
        }
      } catch (err) {
        _d = true;
        _e2 = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e2;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _typeof4(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof4 = function _typeof5(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof4 = function _typeof5(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof4(obj);
    }
    function defaultCreatePathSegment(value, index3, outerValue) {
      return index3;
    }
    function getType(value) {
      if (Array.isArray(value)) {
        return "array";
      }
      return value === null ? "null" : _typeof4(value);
    }
    var SKIP_MARKER = {
      _: "SKIP_MARKER"
    };
    exports.SKIP_MARKER = SKIP_MARKER;
    function SKIP(value) {
      return [SKIP_MARKER, value];
    }
    function callReducer(acc, reducerFn, value, path3) {
      var returnVal = reducerFn(acc, value, path3);
      if (returnVal === SKIP) {
        return [true, acc];
      }
      return Array.isArray(returnVal) && returnVal[0] === SKIP_MARKER ? [true, returnVal[1]] : [false, returnVal];
    }
    function reducePrimitive(acc, reducerFn, value, path3) {
      var _callReducer = callReducer(acc, reducerFn, value, path3), _callReducer2 = _slicedToArray(_callReducer, 2), nextAcc = _callReducer2[1];
      return nextAcc;
    }
    function reduceObject(acc, reducerFn, object2, path3) {
      var createPathSegment = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : defaultCreatePathSegment;
      var _callReducer3 = callReducer(acc, reducerFn, object2, path3), _callReducer4 = _slicedToArray(_callReducer3, 2), skip2 = _callReducer4[0], nextAcc = _callReducer4[1];
      return skip2 ? nextAcc : Object.keys(object2).reduce(function(innerAcc, key2) {
        return reduceAny(innerAcc, reducerFn, object2[key2], path3.concat(createPathSegment(object2[key2], key2, object2)), createPathSegment);
      }, nextAcc);
    }
    function reduceArray(acc, reducerFn, array, path3) {
      var createPathSegment = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : defaultCreatePathSegment;
      var _callReducer5 = callReducer(acc, reducerFn, array, path3), _callReducer6 = _slicedToArray(_callReducer5, 2), skip2 = _callReducer6[0], nextAcc = _callReducer6[1];
      return skip2 ? nextAcc : array.reduce(function(innerAcc, item, index3) {
        return reduceAny(innerAcc, reducerFn, item, path3.concat(createPathSegment(item, index3, array)), createPathSegment);
      }, nextAcc);
    }
    function reduceAny(acc, reducerFn, val, path3) {
      var createPathSegment = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : defaultCreatePathSegment;
      var type = getType(val);
      if (type === "object") {
        return reduceObject(acc, reducerFn, val, path3, createPathSegment);
      }
      if (type === "array") {
        return reduceArray(acc, reducerFn, val, path3, createPathSegment);
      }
      return reducePrimitive(acc, reducerFn, val, path3);
    }
    function reduce2(value, reducerFn, initial2) {
      var createPathSegment = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultCreatePathSegment;
      return reduceAny(initial2, reducerFn, value, [], createPathSegment);
    }
    var withCustomPathSegment = function withCustomPathSegment2(createPathSegment) {
      return function(value, reducer2, initial2) {
        return reduce2(value, reducer2, initial2, createPathSegment);
      };
    };
    exports.withCustomPathSegment = withCustomPathSegment;
  }
});

// node_modules/rxjs-exhaustmap-with-trailing/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  exhaustMapToWithTrailing: () => exhaustMapToWithTrailing,
  exhaustMapWithTrailing: () => exhaustMapWithTrailing
});
function exhaustMapWithTrailing(project) {
  return (source) => defer(() => {
    const release = new Subject();
    return source.pipe(throttle(() => release, {
      leading: true,
      trailing: true
    }), exhaustMap((value, index3) => scheduled(project(value, index3), asyncScheduler).pipe(finalize(() => {
      release.next();
    }))));
  });
}
function exhaustMapToWithTrailing(innerObservable) {
  return exhaustMapWithTrailing(() => innerObservable);
}
var init_esm6 = __esm({
  "node_modules/rxjs-exhaustmap-with-trailing/dist/esm/index.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/refCountDelay.js
function refCountDelay(duration, scheduler2 = asapScheduler) {
  return (source) => {
    const connectable2 = source;
    let connectableSubscription = null;
    let connectorSubscription = null;
    const notifier = new Subject();
    const connector = notifier.pipe(scan((count2, step) => count2 + step, 0), switchMap((count2) => {
      if (count2 === 0) {
        return timer(duration, scheduler2).pipe(tap(() => {
          if (connectableSubscription) {
            connectableSubscription.unsubscribe();
            connectableSubscription = null;
          }
          if (connectorSubscription) {
            connectorSubscription.unsubscribe();
            connectorSubscription = null;
          }
        }));
      }
      if (!connectableSubscription && count2 > 0) {
        return timer(0, scheduler2).pipe(tap(() => {
          if (!connectableSubscription) {
            connectableSubscription = connectable2.connect();
          }
        }));
      }
      return NEVER;
    }));
    return using(() => {
      if (!connectorSubscription) {
        connectorSubscription = connector.subscribe();
      }
      notifier.next(1);
      return { unsubscribe: () => notifier.next(-1) };
    }, () => source);
  };
}
var refCountAuditTime;
var init_refCountDelay = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/refCountDelay.js"() {
    init_esm5();
    init_operators();
    refCountAuditTime = refCountDelay;
  }
});

// node_modules/rxjs-etc/dist/esm/operators/auditMap.js
function auditMap(project) {
  return (source) => {
    let pending = false;
    let queued = void 0;
    return source.pipe(mergeMap((value, index3) => {
      if (pending) {
        queued = [value, index3];
        return EMPTY;
      }
      pending = true;
      return from2(project(value, index3)).pipe(concat2(defer(() => {
        if (!queued) {
          return EMPTY;
        }
        const projected = project(...queued);
        queued = void 0;
        return from2(projected);
      })), last2(), tap({
        complete: () => pending = false
      }));
    }));
  };
}
var init_auditMap = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/auditMap.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/bucketBy.js
function bucketBy(count2, hashSelector, subjectSelector = () => new Subject()) {
  return (source) => source.lift(new BucketByOperator(count2, hashSelector, subjectSelector));
}
var BucketByOperator, BucketBySubscriber;
var init_bucketBy = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/bucketBy.js"() {
    init_esm5();
    BucketByOperator = class {
      constructor(count2, hashSelector, subjectSelector) {
        this.count = count2;
        this.hashSelector = hashSelector;
        this.subjectSelector = subjectSelector;
      }
      call(subscriber, source) {
        return source.subscribe(new BucketBySubscriber(subscriber, this.count, this.hashSelector, this.subjectSelector));
      }
    };
    BucketBySubscriber = class extends Subscriber {
      constructor(destination, count2, hashSelector, subjectSelector) {
        super(destination);
        this.count = count2;
        this.hashSelector = hashSelector;
        this.subjectSelector = subjectSelector;
        this.index = 0;
        const buckets = this.buckets = new Array(count2);
        for (let i4 = 0; i4 < count2; ++i4) {
          buckets[i4] = subjectSelector();
        }
        destination.next(buckets.map((subject) => subject.asObservable()));
      }
      _next(value) {
        const { buckets, closed, count: count2, hashSelector } = this;
        if (closed) {
          return;
        }
        let index3;
        try {
          const hash2 = hashSelector(value, this.index++);
          index3 = Math.abs(Math.floor(hash2)) % count2;
        } catch (error) {
          this.error(error);
          return;
        }
        buckets[index3].next(value);
      }
      _error(error) {
        const { buckets, closed, destination } = this;
        if (closed) {
          return;
        }
        buckets.forEach((bucket) => bucket.error(error));
        destination.error(error);
      }
      _complete() {
        const { buckets, closed, destination } = this;
        if (closed) {
          return;
        }
        buckets.forEach((bucket) => bucket.complete());
        destination.complete();
      }
    };
  }
});

// node_modules/rxjs-etc/dist/esm/operators/bufferRecent.js
function bufferRecent(count2) {
  if (count2 < 1) {
    return (source) => source.pipe(mapTo([]));
  }
  if (count2 === 1) {
    return (source) => source.pipe(map((value) => [value]));
  }
  return (source) => source.pipe(scan((acc, value) => [...acc.slice(1 - count2), value], []));
}
var init_bufferRecent = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/bufferRecent.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/concatIfEmpty.js
function concatIfEmpty(observable2) {
  return (source) => source.pipe(publish((sharedSource) => merge(sharedSource, sharedSource.pipe(isEmpty(), mergeMap((empty2) => empty2 ? observable2 : EMPTY)))));
}
var init_concatIfEmpty = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/concatIfEmpty.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/util.js
function isScheduler2(value) {
  return Boolean(value && typeof value["schedule"] === "function");
}
var init_util2 = __esm({
  "node_modules/rxjs-etc/dist/esm/util.js"() {
  }
});

// node_modules/rxjs-etc/dist/esm/operators/endWith.js
function endWith2(...args) {
  let scheduler2 = args[args.length - 1];
  if (isScheduler2(scheduler2)) {
    args.pop();
  } else {
    scheduler2 = null;
  }
  return (source) => concat(source, from2(args, scheduler2));
}
var init_endWith2 = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/endWith.js"() {
    init_esm5();
    init_util2();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/concatTap.js
function concatTap(next4) {
  return (source) => source.pipe(concatMap((value) => from2(next4(value)).pipe(ignoreElements(), endWith2(value))));
}
var init_concatTap = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/concatTap.js"() {
    init_esm5();
    init_operators();
    init_endWith2();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/concatMapEager.js
function concatMapEager(project, concurrency) {
  return (source) => defer(() => {
    let activeIndex = 0;
    const innersByIndex = /* @__PURE__ */ new Map();
    function flush() {
      const values = [];
      let activeInner = innersByIndex.get(activeIndex);
      while (activeInner) {
        values.push(...activeInner.values);
        activeInner.values.length = 0;
        if (activeInner.complete) {
          innersByIndex.delete(activeIndex);
          activeInner = innersByIndex.get(++activeIndex);
        } else {
          break;
        }
      }
      return values;
    }
    return source.pipe(mergeMap((value, index3) => from2(project(value, index3)).pipe(materialize(), map((notification) => ({
      index: index3,
      notification
    }))), concurrency), mergeMap(({ index: index3, notification }) => {
      let inner = innersByIndex.get(index3);
      if (!inner) {
        inner = { complete: false, index: index3, values: [] };
        innersByIndex.set(index3, inner);
      }
      switch (notification.kind) {
        case "N":
          inner.values.push(notification.value);
          break;
        case "C":
          inner.complete = true;
          break;
        case "E":
          return notification.toObservable();
        default:
          break;
      }
      if (inner.index !== activeIndex) {
        return EMPTY;
      }
      return flush();
    }));
  });
}
var init_concatMapEager = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/concatMapEager.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/debounceAfter.js
function debounceAfter(notifier, duration, scheduler2) {
  return (source) => source.pipe(publish((sharedSource) => notifier.pipe(switchMap(() => concat(of(true), of(false).pipe(delay(duration, scheduler2)))), startWith(false), distinctUntilChanged(), publish((sharedSignal) => sharedSignal.pipe(concatMap((signalled) => signalled ? sharedSource.pipe(takeUntil(sharedSignal.pipe(filter2((signalled2) => !signalled2))), takeLast(1)) : sharedSource.pipe(takeUntil(sharedSignal.pipe(filter2((signalled2) => signalled2))))))))));
}
var init_debounceAfter = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/debounceAfter.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/OperatorSubscriber.js
var defaultComplete, defaultError, defaultNext, OperatorSubscriber2;
var init_OperatorSubscriber2 = __esm({
  "node_modules/rxjs-etc/dist/esm/OperatorSubscriber.js"() {
    init_esm5();
    defaultComplete = Subscriber.prototype._complete;
    defaultError = Subscriber.prototype._error;
    defaultNext = Subscriber.prototype._next;
    OperatorSubscriber2 = class extends Subscriber {
      constructor(destination, handlers) {
        super(destination);
        const { complete, error, next: next4 } = handlers;
        this._complete = complete ? () => {
          try {
            complete();
          } catch (caught) {
            destination.error(caught);
          }
          this.unsubscribe();
        } : defaultComplete;
        this._error = error ? (received) => {
          try {
            error(received);
          } catch (caught) {
            destination.error(caught);
          }
          this.unsubscribe();
        } : defaultError;
        this._next = next4 ? (value) => {
          try {
            next4(value);
          } catch (caught) {
            destination.error(caught);
          }
        } : defaultNext;
      }
    };
  }
});

// node_modules/rxjs-etc/dist/esm/operators/debounceSync.js
function debounceSync() {
  return (source) => new Observable((subscriber) => {
    let actionSubscription;
    let actionValue;
    source.subscribe(new OperatorSubscriber2(subscriber, {
      complete: () => {
        if (actionSubscription) {
          subscriber.next(actionValue);
        }
        subscriber.complete();
      },
      error: (error) => subscriber.error(error),
      next: (value) => {
        actionValue = value;
        if (!actionSubscription) {
          actionSubscription = asapScheduler.schedule(() => {
            subscriber.next(actionValue);
            actionSubscription = void 0;
          });
          subscriber.add(actionSubscription);
        }
      }
    }));
  });
}
var init_debounceSync = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/debounceSync.js"() {
    init_esm5();
    init_OperatorSubscriber2();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/subsequent.js
function subsequent(countOrOperator, operator) {
  let count2;
  if (typeof countOrOperator === "number") {
    count2 = countOrOperator;
  } else {
    count2 = 1;
    operator = countOrOperator;
  }
  return (source) => source.pipe(publish((published) => concat(published.pipe(take(count2)), published.pipe(operator))));
}
var init_subsequent = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/subsequent.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/debounceTimeSubsequent.js
function debounceTimeSubsequent(duration, countOrScheduler, scheduler2) {
  let count2;
  if (typeof countOrScheduler === "number") {
    count2 = countOrScheduler;
  } else {
    count2 = 1;
    scheduler2 = countOrScheduler;
  }
  return subsequent(count2, debounceTime(duration, scheduler2));
}
var init_debounceTimeSubsequent = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/debounceTimeSubsequent.js"() {
    init_operators();
    init_subsequent();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/defaultObservableIfEmpty.js
var defaultObservableIfEmpty, switchIfEmpty;
var init_defaultObservableIfEmpty = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/defaultObservableIfEmpty.js"() {
    init_concatIfEmpty();
    defaultObservableIfEmpty = concatIfEmpty;
    switchIfEmpty = concatIfEmpty;
  }
});

// node_modules/rxjs-etc/dist/esm/operators/deferFinalize.js
function deferFinalize(callback) {
  return (source) => source.lift(new DeferFinalizeOperator(callback));
}
var DeferFinalizeOperator, DeferFinalizeSubscriber;
var init_deferFinalize = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/deferFinalize.js"() {
    init_esm5();
    init_operators();
    DeferFinalizeOperator = class {
      constructor(callback) {
        this.callback = callback;
      }
      call(subscriber, source) {
        return source.subscribe(new DeferFinalizeSubscriber(subscriber, this.callback));
      }
    };
    DeferFinalizeSubscriber = class extends Subscriber {
      constructor(destination, callback) {
        super(destination);
        this.callback = callback;
        this.kind = "U";
        this.subscription = void 0;
      }
      complete() {
        this.kind = "C";
        this.defer(() => super.complete());
      }
      error(error) {
        this.kind = "E";
        this.defer(() => super.error(error));
      }
      unsubscribe() {
        this.defer(() => super.unsubscribe());
      }
      defer(func2) {
        if (this.subscription) {
          this.subscription.add(func2);
          return;
        }
        const subscription = new Subscription();
        this.subscription = subscription;
        subscription.add(func2);
        const result = this.callback(this.kind);
        from2(result).pipe(finalize(() => subscription.unsubscribe())).subscribe();
      }
    };
  }
});

// node_modules/rxjs-etc/dist/esm/operators/delayUntil.js
function delayUntil(notifier) {
  return (source) => source.pipe(publish((published) => {
    const delayed = new Observable((subscriber) => {
      let buffering = true;
      const buffer2 = [];
      const subscription = new Subscription();
      subscription.add(notifier.subscribe(() => {
        buffer2.forEach((value) => subscriber.next(value));
        subscriber.complete();
      }, (error) => subscriber.error(error), () => {
        buffering = false;
        buffer2.length = 0;
      }));
      subscription.add(() => {
        buffer2.length = 0;
      });
      subscription.add(published.subscribe((value) => buffering && buffer2.push(value), (error) => subscriber.error(error)));
      return subscription;
    });
    return concat(delayed, published);
  }));
}
var init_delayUntil = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/delayUntil.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/dispose.js
function dispose(callback) {
  return (source) => source.lift(new DisposeOperator(callback));
}
var DisposeOperator;
var init_dispose = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/dispose.js"() {
    DisposeOperator = class {
      constructor(callback) {
        this.callback = callback;
      }
      call(subscriber, source) {
        const subscription = source.subscribe(subscriber);
        subscription.add(this.callback);
        return subscription;
      }
    };
  }
});

// node_modules/rxjs-etc/dist/esm/operators/equals.js
function equals(predicate) {
  return (source) => source.pipe(filter2((value) => predicate === value));
}
var init_equals = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/equals.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/exhaustTap.js
function exhaustTap(next4) {
  return (source) => source.pipe(publishReplay(1, void 0, (published) => published.pipe(exhaustMap((value) => concat(published, NEVER).pipe(takeUntil(from2(next4(value)).pipe(ignoreElements(), endWith2(null))), toArray(), mergeAll())))));
}
var init_exhaustTap = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/exhaustTap.js"() {
    init_esm5();
    init_operators();
    init_endWith2();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/finalizeWithKind.js
function finalizeWithKind(callback) {
  return (source) => defer(() => {
    let kind = "U";
    return source.pipe(tap({
      complete: () => kind = "C",
      error: () => kind = "E"
    }), finalize(() => callback(kind)));
  });
}
var init_finalizeWithKind = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/finalizeWithKind.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/guard.js
function guard(guard3, message) {
  return (source) => source.pipe(map((value) => {
    if (guard3(value)) {
      return value;
    }
    const error = new Error(message || "Guard rejection.");
    error["value"] = value;
    throw error;
  }));
}
var init_guard = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/guard.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/hold.js
function hold(releaseNotifier) {
  return (source) => source.pipe(buffer(releaseNotifier), concatAll());
}
var init_hold = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/hold.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/holdToggle.js
function holdToggle(captures, releaseSelector) {
  return (source) => source.pipe(bufferToggle(captures, releaseSelector), concatAll());
}
var init_holdToggle = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/holdToggle.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/holdWhen.js
function holdWhen(releaseSelector) {
  return (source) => source.pipe(bufferWhen(releaseSelector), concatAll());
}
var init_holdWhen = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/holdWhen.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/indexElements.js
function indexElements(project = (value, index3) => index3) {
  return map(project);
}
var init_indexElements = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/indexElements.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/inexorably.js
function inexorably(callback) {
  return (source) => source.lift(new InexorablyOperator(callback));
}
var finalize2, InexorablyOperator, InexorablySubscriber;
var init_inexorably = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/inexorably.js"() {
    init_esm5();
    finalize2 = inexorably;
    InexorablyOperator = class {
      constructor(callback) {
        this.callback = callback;
      }
      call(subscriber, source) {
        return source.subscribe(new InexorablySubscriber(subscriber, this.callback));
      }
    };
    InexorablySubscriber = class extends Subscriber {
      constructor(destination, callback) {
        super(destination);
        this.add(new Subscription(() => callback(this.notification)));
      }
      complete() {
        this.notification = new Notification("C");
        super.complete();
      }
      error(error) {
        this.notification = new Notification("E", void 0, error);
        super.error(error);
      }
    };
  }
});

// node_modules/rxjs-etc/dist/esm/operators/initial.js
function initial(countOrOperator, operator) {
  let count2;
  if (typeof countOrOperator === "number") {
    count2 = countOrOperator;
  } else {
    count2 = 1;
    operator = countOrOperator;
  }
  return (source) => source.pipe(publish((published) => merge(published.pipe(take(count2), operator), published.pipe(skip(count2)))));
}
var init_initial = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/initial.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/instanceOf.js
function instanceOf(arg) {
  return typeof arg === "function" ? filter2((value) => value instanceof arg) : filter2((value) => Object.keys(arg).some((key2) => value instanceof arg[key2]));
}
var init_instanceOf = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/instanceOf.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/materializeTap.js
function materializeTap(next4) {
  return (source) => source.pipe(tap({
    complete: () => next4(new Notification("C")),
    error: (error) => next4(new Notification("E", void 0, error)),
    next: (value) => next4(new Notification("N", value))
  }));
}
var init_materializeTap = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/materializeTap.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/materializeTo.js
function materializeTo(innerObservable) {
  return (source) => source.pipe(mergeMapTo(from2(innerObservable).pipe(materialize())), dematerialize());
}
var init_materializeTo = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/materializeTo.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/mergeTap.js
function mergeTap(next4) {
  return (source) => source.pipe(mergeMap((value) => from2(next4(value)).pipe(ignoreElements(), endWith2(value))));
}
var init_mergeTap = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/mergeTap.js"() {
    init_esm5();
    init_operators();
    init_endWith2();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/multicastWithKind.js
function multicastWithKind(factory, selector) {
  return (source) => {
    let kind = void 0;
    let subject = void 0;
    return source.pipe(finalizeWithKind((k3) => kind = k3), multicast(() => {
      subject = factory(kind, subject);
      kind = void 0;
      return subject;
    }, selector));
  };
}
var init_multicastWithKind = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/multicastWithKind.js"() {
    init_operators();
    init_finalizeWithKind();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/pairwiseStartWith.js
function pairwiseStartWith(value) {
  return (source) => source.pipe(startWith(value), pairwise());
}
var init_pairwiseStartWith = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/pairwiseStartWith.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/pause.js
function pause(notifier, initialState = "resumed") {
  return (source) => notifier.pipe(startWith(initialState), publishReplay(1, void 0, (published) => source.pipe(mergeMap((value) => published.pipe(filter2((state) => state === "resumed"), first(), map(() => value))))));
}
var init_pause = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/pause.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/percolate.js
function percolate(...sources) {
  const [first3, ...remainder] = sources;
  if (sources.length === 1 && Array.isArray(first3)) {
    return percolate(...first3);
  }
  return new Observable((subscriber) => {
    const subNext = (err) => {
      if (remainder.length === 0) {
        subscriber.error(err);
      } else {
        subscriber.add(percolate(...remainder).subscribe(subscriber));
      }
    };
    return from2(first3).subscribe({
      complete: () => {
        subscriber.complete();
      },
      next(value) {
        subscriber.next(value);
      },
      error: subNext
    });
  });
}
var init_percolate = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/percolate.js"() {
    init_esm5();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/pluck.js
function pluck2(...keys2) {
  return (source) => pluck(...keys2)(source);
}
var init_pluck2 = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/pluck.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/prioritize.js
function prioritize(selector) {
  return (source) => new Observable((observer) => {
    const published = publish()(source);
    const subjects = [];
    const subscription = new Subscription();
    const length2 = Math.max(selector.length, 2);
    for (let i4 = 0; i4 < length2; ++i4) {
      const subject = new Subject();
      subjects.push(subject);
      subscription.add(published.subscribe(subject));
    }
    const [first3, second, ...rest] = subjects;
    subscription.add(selector(first3, second, ...rest).subscribe(observer));
    subscription.add(published.connect());
    return subscription;
  });
}
var init_prioritize = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/prioritize.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/rateLimit.js
function rateLimit(period, ...args) {
  let count2 = 1;
  let scheduler2 = asapScheduler;
  if (args.length === 1) {
    if (typeof args[0] === "number") {
      count2 = args[0];
    } else {
      scheduler2 = args[0];
    }
  } else if (args.length === 2) {
    count2 = args[0];
    scheduler2 = args[1];
  }
  const definedCount = count2 || 1;
  return (source) => source.pipe(scan((emissions, value) => {
    const now2 = scheduler2.now();
    const since = now2 - period;
    emissions = emissions.filter((emission) => emission.until > since);
    if (emissions.length >= definedCount) {
      const leastRecentEmission = emissions[0];
      const mostRecentEmission = emissions[emissions.length - 1];
      const until = leastRecentEmission.until + period * Math.floor(emissions.length / definedCount);
      emissions.push({
        delay: mostRecentEmission.until < now2 ? until - now2 : until - mostRecentEmission.until,
        until,
        value
      });
    } else {
      emissions.push({
        delay: 0,
        until: now2,
        value
      });
    }
    return emissions;
  }, []), map((emissions) => emissions[emissions.length - 1]), concatMap((emission) => {
    const observable2 = of(emission.value);
    return emission.delay ? observable2.pipe(delay(emission.delay, scheduler2)) : observable2;
  }));
}
var init_rateLimit = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/rateLimit.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/refCountForever.js
function refCountForever() {
  return (source) => {
    const connectable2 = source;
    let subscription = null;
    return using(() => {
      if (!subscription) {
        subscription = connectable2.connect();
      }
      return {
        unsubscribe: () => {
        }
      };
    }, () => source);
  };
}
var init_refCountForever = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/refCountForever.js"() {
    init_esm5();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/refCountOn.js
function refCountOn(scheduler2) {
  return (source) => {
    const connectable2 = source;
    let count2 = 0;
    let subscription = null;
    return using(() => {
      ++count2;
      scheduler2.schedule(() => {
        if (!subscription && count2 > 0) {
          subscription = connectable2.connect();
        }
      });
      return {
        unsubscribe: () => {
          --count2;
          scheduler2.schedule(() => {
            if (subscription && count2 === 0) {
              subscription.unsubscribe();
              subscription = null;
            }
          });
        }
      };
    }, () => source);
  };
}
var init_refCountOn = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/refCountOn.js"() {
    init_esm5();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/reschedule.js
function reschedule(scheduler2 = asapScheduler) {
  return concatMap((value) => of(value, scheduler2));
}
var init_reschedule = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/reschedule.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/skipSync.js
function skipSync() {
  return (source) => new Observable((subscriber) => {
    let subscribed = false;
    const subscription = source.subscribe((value) => subscribed && subscriber.next(value), subscriber.error.bind(subscriber), subscriber.complete.bind(subscriber));
    subscribed = true;
    return subscription;
  });
}
var init_skipSync = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/skipSync.js"() {
    init_esm5();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/splitBy.js
function splitBy(predicate, subjectSelector = () => new Subject()) {
  return bucketBy(2, (value, index3) => predicate(value, index3) ? 0 : 1, subjectSelector);
}
var init_splitBy = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/splitBy.js"() {
    init_esm5();
    init_bucketBy();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/spread.js
function spread(...operations) {
  return (source) => operations.reduce((acc, operator) => acc.pipe(operator), source);
}
var init_spread = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/spread.js"() {
  }
});

// node_modules/rxjs-etc/dist/esm/operators/startWithDeferred.js
function startWithDeferred(factory, scheduler2) {
  return (source) => concat(defer(() => {
    const value = factory();
    return scheduler2 ? of(value, scheduler2) : of(value);
  }), source);
}
var init_startWithDeferred = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/startWithDeferred.js"() {
    init_esm5();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/startWithTimeout.js
function startWithTimeout(value, duration, scheduler2) {
  if (duration === 0 && !scheduler2) {
    return (source) => new Observable((subscriber) => {
      let nexted = false;
      const subscription = source.subscribe((value2) => {
        nexted = true;
        subscriber.next(value2);
      }, subscriber.error.bind(subscriber), subscriber.complete.bind(subscriber));
      if (!nexted) {
        subscriber.next(value);
      }
      return subscription;
    });
  }
  return (source) => source.pipe(publish((published) => race(published, concat(timer(duration, scheduler2).pipe(mapTo(value)), published))));
}
var init_startWithTimeout = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/startWithTimeout.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/switchMapUntil.js
function switchMapUntil(prelude, project) {
  return (source) => source.pipe(publish((shared) => shared.pipe(prelude, switchMap((value, index3) => project(value, index3).pipe(takeUntil(shared))))));
}
var init_switchMapUntil = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/switchMapUntil.js"() {
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/switchTap.js
function switchTap(next4) {
  return (source) => source.pipe(publish((published) => published.pipe(concatMap((value) => concat(from2(next4(value)).pipe(ignoreElements(), takeUntil(published)), of(value))))));
}
var init_switchTap = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/switchTap.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/takeSync.js
function takeSync() {
  return (source) => new Observable((subscriber) => {
    const subscription = source.subscribe(subscriber);
    subscriber.complete();
    return subscription;
  });
}
var init_takeSync = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/takeSync.js"() {
    init_esm5();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/takeWhileInclusive.js
function takeWhileInclusive(predicate) {
  return (source) => source.pipe(multicast(() => new ReplaySubject(1), (sharedSource) => concat(sharedSource.pipe(takeWhile(predicate)), sharedSource.pipe(take(1), filter2((value) => !predicate(value))))));
}
var init_takeWhileInclusive = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/takeWhileInclusive.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/tapSubscribe.js
function tapSubscribe(configOrSubscribe) {
  const { ignore = {}, subscribe = noop, unsubscribe = noop } = typeof configOrSubscribe === "function" ? { subscribe: configOrSubscribe } : configOrSubscribe;
  return (source) => defer(() => {
    let completed = false;
    let errored = false;
    subscribe();
    return source.pipe(tap({
      complete: () => completed = true,
      error: () => errored = true
    }), finalize(() => {
      if (completed && ignore.complete) {
        return;
      }
      if (errored && ignore.error) {
        return;
      }
      unsubscribe();
    }));
  });
}
var init_tapSubscribe = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/tapSubscribe.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/tapWithIndex.js
function tapWithIndex(nextOrObserver, error, complete) {
  return (source) => defer(() => {
    let index3 = -1;
    let context2;
    let handleNext;
    let handleError;
    let handleComplete;
    if (nextOrObserver && typeof nextOrObserver !== "function") {
      context2 = nextOrObserver;
      handleNext = nextOrObserver.next || noop;
      handleError = nextOrObserver.error || noop;
      handleComplete = nextOrObserver.complete || noop;
    } else {
      context2 = void 0;
      handleNext = nextOrObserver || noop;
      handleError = error || noop;
      handleComplete = complete || noop;
    }
    return source.pipe(tap((value) => handleNext.call(context2, [value, ++index3]), (error2) => handleError.call(context2, error2), () => handleComplete.call(context2)));
  });
}
var init_tapWithIndex = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/tapWithIndex.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/throttleAfter.js
function throttleAfter(notifier, duration, scheduler2) {
  return (source) => source.pipe(publish((sharedSource) => notifier.pipe(switchMap(() => concat(of(true), delay(duration, scheduler2)(of(false)))), startWith(false), distinctUntilChanged(), publish((sharedSignal) => sharedSignal.pipe(concatMap((signalled) => signalled ? sharedSource.pipe(take(1), takeUntil(sharedSignal.pipe(filter2((signalled2) => !signalled2)))) : sharedSource.pipe(takeUntil(sharedSignal.pipe(filter2((signalled2) => signalled2))))))))));
}
var init_throttleAfter = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/throttleAfter.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/withLatestFromWhen.js
function withLatestFromWhen(...args) {
  const flushSelector = args.pop();
  const observables = args;
  return (source) => new Observable((subscriber) => {
    const publishedSource = publish()(source);
    const publishedObservables = observables.map((o4) => from2(o4).pipe(publish()));
    const subscription = new Subscription();
    subscription.add(flushSelector().pipe(startWith(void 0), switchMap(() => publishedSource.pipe(withLatestFrom(...publishedObservables)))).subscribe(subscriber));
    publishedObservables.forEach((p2) => subscription.add(p2.connect()));
    subscription.add(publishedSource.connect());
    return subscription;
  });
}
var init_withLatestFromWhen = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/withLatestFromWhen.js"() {
    init_esm5();
    init_operators();
  }
});

// node_modules/rxjs-etc/dist/esm/operators/unsubscribeOn.js
function unsubscribeOn(scheduler2, delay2 = 0) {
  return (source) => source.lift(new UnsubscribeOnOperator(scheduler2, delay2));
}
var UnsubscribeOnOperator, UnsubscribeOnSubscriber;
var init_unsubscribeOn = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/unsubscribeOn.js"() {
    init_esm5();
    UnsubscribeOnOperator = class {
      constructor(scheduler2, delay2) {
        this.scheduler = scheduler2;
        this.delay = delay2;
      }
      call(subscriber, source) {
        return source.subscribe(new UnsubscribeOnSubscriber(subscriber, this.scheduler, this.delay));
      }
    };
    UnsubscribeOnSubscriber = class extends Subscriber {
      constructor(destination, scheduler2, delay2) {
        super(destination);
        this.scheduler = scheduler2;
        this.delay = delay2;
      }
      unsubscribe() {
        const { delay: delay2, scheduler: scheduler2 } = this;
        scheduler2.schedule(() => super.unsubscribe(), delay2);
      }
    };
  }
});

// node_modules/rxjs-etc/dist/esm/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  auditMap: () => auditMap,
  bucketBy: () => bucketBy,
  bufferRecent: () => bufferRecent,
  concatIfEmpty: () => concatIfEmpty,
  concatMapEager: () => concatMapEager,
  concatTap: () => concatTap,
  debounceAfter: () => debounceAfter,
  debounceSync: () => debounceSync,
  debounceTimeSubsequent: () => debounceTimeSubsequent,
  defaultObservableIfEmpty: () => defaultObservableIfEmpty,
  deferFinalize: () => deferFinalize,
  delayUntil: () => delayUntil,
  dispose: () => dispose,
  endWith: () => endWith2,
  equals: () => equals,
  exhaustTap: () => exhaustTap,
  finalize: () => finalize2,
  finalizeWithKind: () => finalizeWithKind,
  guard: () => guard,
  hold: () => hold,
  holdToggle: () => holdToggle,
  holdWhen: () => holdWhen,
  indexElements: () => indexElements,
  inexorably: () => inexorably,
  initial: () => initial,
  instanceOf: () => instanceOf,
  materializeTap: () => materializeTap,
  materializeTo: () => materializeTo,
  mergeTap: () => mergeTap,
  multicastWithKind: () => multicastWithKind,
  pairwiseStartWith: () => pairwiseStartWith,
  pause: () => pause,
  percolate: () => percolate,
  pluck: () => pluck2,
  prioritize: () => prioritize,
  rateLimit: () => rateLimit,
  refCountAuditTime: () => refCountAuditTime,
  refCountDelay: () => refCountDelay,
  refCountForever: () => refCountForever,
  refCountOn: () => refCountOn,
  reschedule: () => reschedule,
  skipSync: () => skipSync,
  splitBy: () => splitBy,
  spread: () => spread,
  startWithDeferred: () => startWithDeferred,
  startWithTimeout: () => startWithTimeout,
  subsequent: () => subsequent,
  switchIfEmpty: () => switchIfEmpty,
  switchMapUntil: () => switchMapUntil,
  switchTap: () => switchTap,
  takeSync: () => takeSync,
  takeWhileInclusive: () => takeWhileInclusive,
  tapSubscribe: () => tapSubscribe,
  tapWithIndex: () => tapWithIndex,
  throttleAfter: () => throttleAfter,
  unsubscribeOn: () => unsubscribeOn,
  withLatestFromWhen: () => withLatestFromWhen
});
var init_operators3 = __esm({
  "node_modules/rxjs-etc/dist/esm/operators/index.js"() {
    init_auditMap();
    init_bucketBy();
    init_bufferRecent();
    init_concatIfEmpty();
    init_concatTap();
    init_concatMapEager();
    init_debounceAfter();
    init_debounceSync();
    init_debounceTimeSubsequent();
    init_defaultObservableIfEmpty();
    init_deferFinalize();
    init_delayUntil();
    init_dispose();
    init_endWith2();
    init_equals();
    init_exhaustTap();
    init_finalizeWithKind();
    init_guard();
    init_hold();
    init_holdToggle();
    init_holdWhen();
    init_indexElements();
    init_inexorably();
    init_initial();
    init_instanceOf();
    init_materializeTap();
    init_materializeTo();
    init_mergeTap();
    init_multicastWithKind();
    init_pairwiseStartWith();
    init_pause();
    init_percolate();
    init_pluck2();
    init_prioritize();
    init_rateLimit();
    init_refCountDelay();
    init_refCountForever();
    init_refCountOn();
    init_reschedule();
    init_skipSync();
    init_splitBy();
    init_spread();
    init_startWithDeferred();
    init_startWithTimeout();
    init_subsequent();
    init_switchMapUntil();
    init_switchTap();
    init_takeSync();
    init_takeWhileInclusive();
    init_tapSubscribe();
    init_tapWithIndex();
    init_throttleAfter();
    init_withLatestFromWhen();
    init_unsubscribeOn();
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction2(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e5) {
    return typeof fn === "function";
  }
}
var init_isNativeFunction = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct2(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct2 = Reflect.construct.bind();
  } else {
    _construct2 = function _construct3(Parent2, args2, Class2) {
      var a5 = [null];
      a5.push.apply(a5, args2);
      var Constructor = Function.bind.apply(Parent2, a5);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct2.apply(null, arguments);
}
var init_construct = __esm({
  "node_modules/@babel/runtime/helpers/esm/construct.js"() {
    init_setPrototypeOf();
    init_isNativeReflectConstruct();
  }
});

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper2(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper2 = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction2(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct2(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper2(Class);
}
var init_wrapNativeSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js"() {
    init_getPrototypeOf();
    init_setPrototypeOf();
    init_isNativeFunction();
    init_construct();
  }
});

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}
var init_taggedTemplateLiteralLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js"() {
  }
});

// node_modules/polished/dist/polished.esm.js
var polished_esm_exports = {};
__export(polished_esm_exports, {
  adjustHue: () => curriedAdjustHue$1,
  animation: () => animation,
  backgroundImages: () => backgroundImages,
  backgrounds: () => backgrounds,
  between: () => between,
  border: () => border,
  borderColor: () => borderColor,
  borderRadius: () => borderRadius,
  borderStyle: () => borderStyle,
  borderWidth: () => borderWidth,
  buttons: () => buttons,
  clearFix: () => clearFix,
  complement: () => complement,
  cover: () => cover,
  cssVar: () => cssVar,
  darken: () => curriedDarken$1,
  desaturate: () => curriedDesaturate$1,
  directionalProperty: () => directionalProperty,
  easeIn: () => easeIn,
  easeInOut: () => easeInOut,
  easeOut: () => easeOut,
  ellipsis: () => ellipsis,
  em: () => em$1,
  fluidRange: () => fluidRange,
  fontFace: () => fontFace,
  getContrast: () => getContrast,
  getLuminance: () => getLuminance,
  getValueAndUnit: () => getValueAndUnit,
  grayscale: () => grayscale,
  hiDPI: () => hiDPI,
  hideText: () => hideText,
  hideVisually: () => hideVisually,
  hsl: () => hsl,
  hslToColorString: () => hslToColorString,
  hsla: () => hsla,
  important: () => important,
  invert: () => invert,
  lighten: () => curriedLighten$1,
  linearGradient: () => linearGradient,
  margin: () => margin,
  math: () => math,
  meetsContrastGuidelines: () => meetsContrastGuidelines,
  mix: () => mix$1,
  modularScale: () => modularScale,
  normalize: () => normalize,
  opacify: () => curriedOpacify$1,
  padding: () => padding,
  parseToHsl: () => parseToHsl,
  parseToRgb: () => parseToRgb,
  position: () => position2,
  radialGradient: () => radialGradient,
  readableColor: () => readableColor,
  rem: () => rem$1,
  remToPx: () => remToPx,
  retinaImage: () => retinaImage,
  rgb: () => rgb,
  rgbToColorString: () => rgbToColorString,
  rgba: () => rgba,
  saturate: () => curriedSaturate$1,
  setHue: () => curriedSetHue$1,
  setLightness: () => curriedSetLightness$1,
  setSaturation: () => curriedSetSaturation$1,
  shade: () => curriedShade$1,
  size: () => size2,
  stripUnit: () => stripUnit,
  textInputs: () => textInputs,
  timingFunctions: () => timingFunctions,
  tint: () => curriedTint$1,
  toColorString: () => toColorString,
  transitions: () => transitions,
  transparentize: () => curriedTransparentize$1,
  triangle: () => triangle,
  wordWrap: () => wordWrap
});
function last3() {
  var _ref2;
  return _ref2 = arguments.length - 1, _ref2 < 0 || arguments.length <= _ref2 ? void 0 : arguments[_ref2];
}
function negation(a5) {
  return -a5;
}
function addition(a5, b3) {
  return a5 + b3;
}
function subtraction(a5, b3) {
  return a5 - b3;
}
function multiplication(a5, b3) {
  return a5 * b3;
}
function division(a5, b3) {
  return a5 / b3;
}
function max3() {
  return Math.max.apply(Math, arguments);
}
function min3() {
  return Math.min.apply(Math, arguments);
}
function comma() {
  return Array.of.apply(Array, arguments);
}
function format2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var a5 = args[0];
  var b3 = [];
  var c4;
  for (c4 = 1; c4 < args.length; c4 += 1) {
    b3.push(args[c4]);
  }
  b3.forEach(function(d3) {
    a5 = a5.replace(/%[a-z]/, d3);
  });
  return a5;
}
function mergeSymbolMaps(additionalSymbols) {
  var symbolMap = {};
  symbolMap.symbols = additionalSymbols ? _extends({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : _extends({}, defaultSymbolMap.symbols);
  return symbolMap;
}
function exec(operators, values) {
  var _ref2;
  var op = operators.pop();
  values.push(op.f.apply(op, (_ref2 = []).concat.apply(_ref2, values.splice(-op.argCount))));
  return op.precedence;
}
function calculate(expression, additionalSymbols) {
  var symbolMap = mergeSymbolMaps(additionalSymbols);
  var match5;
  var operators = [symbolMap.symbols["("].prefix];
  var values = [];
  var pattern = new RegExp(
    // Pattern for numbers
    "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
    Object.keys(symbolMap.symbols).map(function(key2) {
      return symbolMap.symbols[key2];
    }).sort(function(a5, b3) {
      return b3.symbol.length - a5.symbol.length;
    }).map(function(val) {
      return val.regSymbol;
    }).join("|") + "|(\\S)",
    "g"
  );
  pattern.lastIndex = 0;
  var afterValue = false;
  do {
    match5 = pattern.exec(expression);
    var _ref2 = match5 || [")", void 0], token3 = _ref2[0], bad = _ref2[1];
    var notNumber = symbolMap.symbols[token3];
    var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;
    var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix;
    if (bad || (afterValue ? notAfterValue : notNewValue)) {
      throw new PolishedError(37, match5 ? match5.index : expression.length, expression);
    }
    if (afterValue) {
      var curr = notNumber.postfix || notNumber.infix;
      do {
        var prev2 = operators[operators.length - 1];
        if ((curr.precedence - prev2.precedence || prev2.rightToLeft) > 0)
          break;
      } while (exec(operators, values));
      afterValue = curr.notation === "postfix";
      if (curr.symbol !== ")") {
        operators.push(curr);
        if (afterValue)
          exec(operators, values);
      }
    } else if (notNumber) {
      operators.push(notNumber.prefix || notNumber.func);
      if (notNumber.func) {
        match5 = pattern.exec(expression);
        if (!match5 || match5[0] !== "(") {
          throw new PolishedError(38, match5 ? match5.index : expression.length, expression);
        }
      }
    } else {
      values.push(+token3);
      afterValue = true;
    }
  } while (match5 && operators.length);
  if (operators.length) {
    throw new PolishedError(39, match5 ? match5.index : expression.length, expression);
  } else if (match5) {
    throw new PolishedError(40, match5 ? match5.index : expression.length, expression);
  } else {
    return values.pop();
  }
}
function reverseString(str) {
  return str.split("").reverse().join("");
}
function math(formula, additionalSymbols) {
  var reversedFormula = reverseString(formula);
  var formulaMatch = reversedFormula.match(unitRegExp);
  if (formulaMatch && !formulaMatch.every(function(unit) {
    return unit === formulaMatch[0];
  })) {
    throw new PolishedError(41);
  }
  var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, ""));
  return "" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : "");
}
function cssVar(cssVariable, defaultValue2) {
  if (!cssVariable || !cssVariable.match(cssVariableRegex)) {
    throw new PolishedError(73);
  }
  var variableValue;
  if (typeof document !== "undefined" && document.documentElement !== null) {
    variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);
  }
  if (variableValue) {
    return variableValue.trim();
  } else if (defaultValue2) {
    return defaultValue2;
  }
  throw new PolishedError(74);
}
function capitalizeString(string4) {
  return string4.charAt(0).toUpperCase() + string4.slice(1);
}
function generateProperty(property, position3) {
  if (!property)
    return position3.toLowerCase();
  var splitProperty = property.split("-");
  if (splitProperty.length > 1) {
    splitProperty.splice(1, 0, position3);
    return splitProperty.reduce(function(acc, val) {
      return "" + acc + capitalizeString(val);
    });
  }
  var joinedProperty = property.replace(/([a-z])([A-Z])/g, "$1" + position3 + "$2");
  return property === joinedProperty ? "" + property + position3 : joinedProperty;
}
function generateStyles(property, valuesWithDefaults) {
  var styles = {};
  for (var i4 = 0; i4 < valuesWithDefaults.length; i4 += 1) {
    if (valuesWithDefaults[i4] || valuesWithDefaults[i4] === 0) {
      styles[generateProperty(property, positionMap$1[i4])] = valuesWithDefaults[i4];
    }
  }
  return styles;
}
function directionalProperty(property) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;
  var valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];
  return generateStyles(property, valuesWithDefaults);
}
function endsWith(string4, suffix) {
  return string4.substr(-suffix.length) === suffix;
}
function stripUnit(value) {
  if (typeof value !== "string")
    return value;
  var matchedValue = value.match(cssRegex$1);
  return matchedValue ? parseFloat(value) : value;
}
function getValueAndUnit(value) {
  if (typeof value !== "string")
    return [value, ""];
  var matchedValue = value.match(cssRegex);
  if (matchedValue)
    return [parseFloat(value), matchedValue[2]];
  return [value, void 0];
}
function important(styleBlock, rules) {
  if (typeof styleBlock !== "object" || styleBlock === null) {
    throw new PolishedError(75, typeof styleBlock);
  }
  var newStyleBlock = {};
  Object.keys(styleBlock).forEach(function(key2) {
    if (typeof styleBlock[key2] === "object" && styleBlock[key2] !== null) {
      newStyleBlock[key2] = important(styleBlock[key2], rules);
    } else if (!rules || rules && (rules === key2 || rules.indexOf(key2) >= 0)) {
      newStyleBlock[key2] = styleBlock[key2] + " !important";
    } else {
      newStyleBlock[key2] = styleBlock[key2];
    }
  });
  return newStyleBlock;
}
function getRatio(ratioName) {
  return ratioNames[ratioName];
}
function modularScale(steps, base, ratio) {
  if (base === void 0) {
    base = "1em";
  }
  if (ratio === void 0) {
    ratio = 1.333;
  }
  if (typeof steps !== "number") {
    throw new PolishedError(42);
  }
  if (typeof ratio === "string" && !ratioNames[ratio]) {
    throw new PolishedError(43);
  }
  var _ref2 = typeof base === "string" ? getValueAndUnit(base) : [base, ""], realBase = _ref2[0], unit = _ref2[1];
  var realRatio = typeof ratio === "string" ? getRatio(ratio) : ratio;
  if (typeof realBase === "string") {
    throw new PolishedError(44, base);
  }
  return "" + realBase * Math.pow(realRatio, steps) + (unit || "");
}
function convertBase(base) {
  var deconstructedValue = getValueAndUnit(base);
  if (deconstructedValue[1] === "px") {
    return parseFloat(base);
  }
  if (deconstructedValue[1] === "%") {
    return parseFloat(base) / 100 * defaultFontSize;
  }
  throw new PolishedError(78, deconstructedValue[1]);
}
function getBaseFromDoc() {
  if (typeof document !== "undefined" && document.documentElement !== null) {
    var rootFontSize = getComputedStyle(document.documentElement).fontSize;
    return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;
  }
  return defaultFontSize;
}
function remToPx(value, base) {
  var deconstructedValue = getValueAndUnit(value);
  if (deconstructedValue[1] !== "rem" && deconstructedValue[1] !== "") {
    throw new PolishedError(77, deconstructedValue[1]);
  }
  var newBase = base ? convertBase(base) : getBaseFromDoc();
  return deconstructedValue[0] * newBase + "px";
}
function easeIn(functionName) {
  return functionsMap$3[functionName.toLowerCase().trim()];
}
function easeInOut(functionName) {
  return functionsMap$2[functionName.toLowerCase().trim()];
}
function easeOut(functionName) {
  return functionsMap$1[functionName.toLowerCase().trim()];
}
function between(fromSize, toSize, minScreen, maxScreen) {
  if (minScreen === void 0) {
    minScreen = "320px";
  }
  if (maxScreen === void 0) {
    maxScreen = "1200px";
  }
  var _getValueAndUnit = getValueAndUnit(fromSize), unitlessFromSize = _getValueAndUnit[0], fromSizeUnit = _getValueAndUnit[1];
  var _getValueAndUnit2 = getValueAndUnit(toSize), unitlessToSize = _getValueAndUnit2[0], toSizeUnit = _getValueAndUnit2[1];
  var _getValueAndUnit3 = getValueAndUnit(minScreen), unitlessMinScreen = _getValueAndUnit3[0], minScreenUnit = _getValueAndUnit3[1];
  var _getValueAndUnit4 = getValueAndUnit(maxScreen), unitlessMaxScreen = _getValueAndUnit4[0], maxScreenUnit = _getValueAndUnit4[1];
  if (typeof unitlessMinScreen !== "number" || typeof unitlessMaxScreen !== "number" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {
    throw new PolishedError(47);
  }
  if (typeof unitlessFromSize !== "number" || typeof unitlessToSize !== "number" || fromSizeUnit !== toSizeUnit) {
    throw new PolishedError(48);
  }
  if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {
    throw new PolishedError(76);
  }
  var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);
  var base = unitlessToSize - slope * unitlessMaxScreen;
  return "calc(" + base.toFixed(2) + (fromSizeUnit || "") + " + " + (100 * slope).toFixed(2) + "vw)";
}
function clearFix(parent3) {
  var _ref2;
  if (parent3 === void 0) {
    parent3 = "&";
  }
  var pseudoSelector = parent3 + "::after";
  return _ref2 = {}, _ref2[pseudoSelector] = {
    clear: "both",
    content: '""',
    display: "table"
  }, _ref2;
}
function cover(offset3) {
  if (offset3 === void 0) {
    offset3 = 0;
  }
  return {
    position: "absolute",
    top: offset3,
    right: offset3,
    bottom: offset3,
    left: offset3
  };
}
function ellipsis(width, lines) {
  if (lines === void 0) {
    lines = 1;
  }
  var styles = {
    display: "inline-block",
    maxWidth: width || "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  return lines > 1 ? _extends({}, styles, {
    WebkitBoxOrient: "vertical",
    WebkitLineClamp: lines,
    display: "-webkit-box",
    whiteSpace: "normal"
  }) : styles;
}
function _createForOfIteratorHelperLoose(o4, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o4[Symbol.iterator] || o4["@@iterator"];
  if (it2)
    return (it2 = it2.call(o4)).next.bind(it2);
  if (Array.isArray(o4) || (it2 = _unsupportedIterableToArray2(o4)) || allowArrayLike && o4 && typeof o4.length === "number") {
    if (it2)
      o4 = it2;
    var i4 = 0;
    return function() {
      if (i4 >= o4.length)
        return { done: true };
      return { done: false, value: o4[i4++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o4, minLen) {
  if (!o4)
    return;
  if (typeof o4 === "string")
    return _arrayLikeToArray2(o4, minLen);
  var n4 = Object.prototype.toString.call(o4).slice(8, -1);
  if (n4 === "Object" && o4.constructor)
    n4 = o4.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o4);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray2(o4, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) {
    arr2[i4] = arr[i4];
  }
  return arr2;
}
function fluidRange(cssProp, minScreen, maxScreen) {
  if (minScreen === void 0) {
    minScreen = "320px";
  }
  if (maxScreen === void 0) {
    maxScreen = "1200px";
  }
  if (!Array.isArray(cssProp) && typeof cssProp !== "object" || cssProp === null) {
    throw new PolishedError(49);
  }
  if (Array.isArray(cssProp)) {
    var mediaQueries = {};
    var fallbacks = {};
    for (var _iterator = _createForOfIteratorHelperLoose(cssProp), _step; !(_step = _iterator()).done; ) {
      var _extends22, _extends3;
      var obj = _step.value;
      if (!obj.prop || !obj.fromSize || !obj.toSize) {
        throw new PolishedError(50);
      }
      fallbacks[obj.prop] = obj.fromSize;
      mediaQueries["@media (min-width: " + minScreen + ")"] = _extends({}, mediaQueries["@media (min-width: " + minScreen + ")"], (_extends22 = {}, _extends22[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends22));
      mediaQueries["@media (min-width: " + maxScreen + ")"] = _extends({}, mediaQueries["@media (min-width: " + maxScreen + ")"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));
    }
    return _extends({}, fallbacks, mediaQueries);
  } else {
    var _ref2, _ref22, _ref3;
    if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {
      throw new PolishedError(51);
    }
    return _ref3 = {}, _ref3[cssProp.prop] = cssProp.fromSize, _ref3["@media (min-width: " + minScreen + ")"] = (_ref2 = {}, _ref2[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref2), _ref3["@media (min-width: " + maxScreen + ")"] = (_ref22 = {}, _ref22[cssProp.prop] = cssProp.toSize, _ref22), _ref3;
  }
}
function generateFormatHint(format4, formatHint) {
  if (!formatHint)
    return "";
  return ' format("' + formatHintMap[format4] + '")';
}
function isDataURI(fontFilePath) {
  return !!fontFilePath.replace(/\s+/g, " ").match(dataURIRegex);
}
function generateFileReferences(fontFilePath, fileFormats, formatHint) {
  if (isDataURI(fontFilePath)) {
    return 'url("' + fontFilePath + '")' + generateFormatHint(fileFormats[0], formatHint);
  }
  var fileFontReferences = fileFormats.map(function(format4) {
    return 'url("' + fontFilePath + "." + format4 + '")' + generateFormatHint(format4, formatHint);
  });
  return fileFontReferences.join(", ");
}
function generateLocalReferences(localFonts) {
  var localFontReferences = localFonts.map(function(font) {
    return 'local("' + font + '")';
  });
  return localFontReferences.join(", ");
}
function generateSources(fontFilePath, localFonts, fileFormats, formatHint) {
  var fontReferences = [];
  if (localFonts)
    fontReferences.push(generateLocalReferences(localFonts));
  if (fontFilePath) {
    fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));
  }
  return fontReferences.join(", ");
}
function fontFace(_ref2) {
  var fontFamily = _ref2.fontFamily, fontFilePath = _ref2.fontFilePath, fontStretch = _ref2.fontStretch, fontStyle = _ref2.fontStyle, fontVariant = _ref2.fontVariant, fontWeight = _ref2.fontWeight, _ref$fileFormats = _ref2.fileFormats, fileFormats = _ref$fileFormats === void 0 ? ["eot", "woff2", "woff", "ttf", "svg"] : _ref$fileFormats, _ref$formatHint = _ref2.formatHint, formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint, _ref$localFonts = _ref2.localFonts, localFonts = _ref$localFonts === void 0 ? [fontFamily] : _ref$localFonts, unicodeRange = _ref2.unicodeRange, fontDisplay = _ref2.fontDisplay, fontVariationSettings = _ref2.fontVariationSettings, fontFeatureSettings = _ref2.fontFeatureSettings;
  if (!fontFamily)
    throw new PolishedError(55);
  if (!fontFilePath && !localFonts) {
    throw new PolishedError(52);
  }
  if (localFonts && !Array.isArray(localFonts)) {
    throw new PolishedError(53);
  }
  if (!Array.isArray(fileFormats)) {
    throw new PolishedError(54);
  }
  var fontFaceDeclaration = {
    "@font-face": {
      fontFamily,
      src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),
      unicodeRange,
      fontStretch,
      fontStyle,
      fontVariant,
      fontWeight,
      fontDisplay,
      fontVariationSettings,
      fontFeatureSettings
    }
  };
  return JSON.parse(JSON.stringify(fontFaceDeclaration));
}
function hideText() {
  return {
    textIndent: "101%",
    overflow: "hidden",
    whiteSpace: "nowrap"
  };
}
function hideVisually() {
  return {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
}
function hiDPI(ratio) {
  if (ratio === void 0) {
    ratio = 1.3;
  }
  return "\n    @media only screen and (-webkit-min-device-pixel-ratio: " + ratio + "),\n    only screen and (min--moz-device-pixel-ratio: " + ratio + "),\n    only screen and (-o-min-device-pixel-ratio: " + ratio + "/1),\n    only screen and (min-resolution: " + Math.round(ratio * 96) + "dpi),\n    only screen and (min-resolution: " + ratio + "dppx)\n  ";
}
function constructGradientValue(literals) {
  var template2 = "";
  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    substitutions[_key - 1] = arguments[_key];
  }
  for (var i4 = 0; i4 < literals.length; i4 += 1) {
    template2 += literals[i4];
    if (i4 === substitutions.length - 1 && substitutions[i4]) {
      var definedValues = substitutions.filter(function(substitute) {
        return !!substitute;
      });
      if (definedValues.length > 1) {
        template2 = template2.slice(0, -1);
        template2 += ", " + substitutions[i4];
      } else if (definedValues.length === 1) {
        template2 += "" + substitutions[i4];
      }
    } else if (substitutions[i4]) {
      template2 += substitutions[i4] + " ";
    }
  }
  return template2.trim();
}
function linearGradient(_ref2) {
  var colorStops = _ref2.colorStops, fallback = _ref2.fallback, _ref$toDirection = _ref2.toDirection, toDirection = _ref$toDirection === void 0 ? "" : _ref$toDirection;
  if (!colorStops || colorStops.length < 2) {
    throw new PolishedError(56);
  }
  return {
    backgroundColor: fallback || colorStops[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "),
    backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["linear-gradient(", "", ")"])), toDirection, colorStops.join(", ").replace(/,(?=\S)/g, ", "))
  };
}
function normalize() {
  var _ref2;
  return [(_ref2 = {
    html: {
      lineHeight: "1.15",
      textSizeAdjust: "100%"
    },
    body: {
      margin: "0"
    },
    main: {
      display: "block"
    },
    h1: {
      fontSize: "2em",
      margin: "0.67em 0"
    },
    hr: {
      boxSizing: "content-box",
      height: "0",
      overflow: "visible"
    },
    pre: {
      fontFamily: "monospace, monospace",
      fontSize: "1em"
    },
    a: {
      backgroundColor: "transparent"
    },
    "abbr[title]": {
      borderBottom: "none",
      textDecoration: "underline"
    }
  }, _ref2["b,\n    strong"] = {
    fontWeight: "bolder"
  }, _ref2["code,\n    kbd,\n    samp"] = {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  }, _ref2.small = {
    fontSize: "80%"
  }, _ref2["sub,\n    sup"] = {
    fontSize: "75%",
    lineHeight: "0",
    position: "relative",
    verticalAlign: "baseline"
  }, _ref2.sub = {
    bottom: "-0.25em"
  }, _ref2.sup = {
    top: "-0.5em"
  }, _ref2.img = {
    borderStyle: "none"
  }, _ref2["button,\n    input,\n    optgroup,\n    select,\n    textarea"] = {
    fontFamily: "inherit",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: "0"
  }, _ref2["button,\n    input"] = {
    overflow: "visible"
  }, _ref2["button,\n    select"] = {
    textTransform: "none"
  }, _ref2['button,\n    html [type="button"],\n    [type="reset"],\n    [type="submit"]'] = {
    WebkitAppearance: "button"
  }, _ref2['button::-moz-focus-inner,\n    [type="button"]::-moz-focus-inner,\n    [type="reset"]::-moz-focus-inner,\n    [type="submit"]::-moz-focus-inner'] = {
    borderStyle: "none",
    padding: "0"
  }, _ref2['button:-moz-focusring,\n    [type="button"]:-moz-focusring,\n    [type="reset"]:-moz-focusring,\n    [type="submit"]:-moz-focusring'] = {
    outline: "1px dotted ButtonText"
  }, _ref2.fieldset = {
    padding: "0.35em 0.625em 0.75em"
  }, _ref2.legend = {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: "0",
    whiteSpace: "normal"
  }, _ref2.progress = {
    verticalAlign: "baseline"
  }, _ref2.textarea = {
    overflow: "auto"
  }, _ref2['[type="checkbox"],\n    [type="radio"]'] = {
    boxSizing: "border-box",
    padding: "0"
  }, _ref2['[type="number"]::-webkit-inner-spin-button,\n    [type="number"]::-webkit-outer-spin-button'] = {
    height: "auto"
  }, _ref2['[type="search"]'] = {
    WebkitAppearance: "textfield",
    outlineOffset: "-2px"
  }, _ref2['[type="search"]::-webkit-search-decoration'] = {
    WebkitAppearance: "none"
  }, _ref2["::-webkit-file-upload-button"] = {
    WebkitAppearance: "button",
    font: "inherit"
  }, _ref2.details = {
    display: "block"
  }, _ref2.summary = {
    display: "list-item"
  }, _ref2.template = {
    display: "none"
  }, _ref2["[hidden]"] = {
    display: "none"
  }, _ref2), {
    "abbr[title]": {
      textDecoration: "underline dotted"
    }
  }];
}
function radialGradient(_ref2) {
  var colorStops = _ref2.colorStops, _ref$extent = _ref2.extent, extent = _ref$extent === void 0 ? "" : _ref$extent, fallback = _ref2.fallback, _ref$position = _ref2.position, position3 = _ref$position === void 0 ? "" : _ref$position, _ref$shape = _ref2.shape, shape = _ref$shape === void 0 ? "" : _ref$shape;
  if (!colorStops || colorStops.length < 2) {
    throw new PolishedError(57);
  }
  return {
    backgroundColor: fallback || colorStops[0].split(" ")[0],
    backgroundImage: constructGradientValue(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["radial-gradient(", "", "", "", ")"])), position3, shape, extent, colorStops.join(", "))
  };
}
function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {
  var _ref2;
  if (extension === void 0) {
    extension = "png";
  }
  if (retinaSuffix === void 0) {
    retinaSuffix = "_2x";
  }
  if (!filename) {
    throw new PolishedError(58);
  }
  var ext = extension.replace(/^\./, "");
  var rFilename = retinaFilename ? retinaFilename + "." + ext : "" + filename + retinaSuffix + "." + ext;
  return _ref2 = {
    backgroundImage: "url(" + filename + "." + ext + ")"
  }, _ref2[hiDPI()] = _extends({
    backgroundImage: "url(" + rFilename + ")"
  }, backgroundSize ? {
    backgroundSize
  } : {}), _ref2;
}
function getTimingFunction(functionName) {
  return functionsMap[functionName];
}
function timingFunctions(timingFunction) {
  return getTimingFunction(timingFunction);
}
function triangle(_ref2) {
  var pointingDirection = _ref2.pointingDirection, height = _ref2.height, width = _ref2.width, foregroundColor = _ref2.foregroundColor, _ref$backgroundColor = _ref2.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? "transparent" : _ref$backgroundColor;
  var widthAndUnit = getValueAndUnit(width);
  var heightAndUnit = getValueAndUnit(height);
  if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {
    throw new PolishedError(60);
  }
  return _extends({
    width: "0",
    height: "0",
    borderColor: backgroundColor
  }, getBorderColor(pointingDirection, foregroundColor), {
    borderStyle: "solid",
    borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)
  });
}
function wordWrap(wrap) {
  if (wrap === void 0) {
    wrap = "break-word";
  }
  var wordBreak = wrap === "break-word" ? "break-all" : wrap;
  return {
    overflowWrap: wrap,
    wordWrap: wrap,
    wordBreak
  };
}
function colorToInt(color) {
  return Math.round(color * 255);
}
function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}
function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0) {
    convert = convertToInt;
  }
  if (saturation === 0) {
    return convert(lightness, lightness, lightness);
  }
  var huePrime = (hue % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}
function nameToHex(color) {
  if (typeof color !== "string")
    return color;
  var normalizedColorName = color.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
}
function parseToRgb(color) {
  if (typeof color !== "string") {
    throw new PolishedError(3);
  }
  var normalizedColor = nameToHex(color);
  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }
  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha
    };
  }
  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha
    };
  }
  var rgbMatched = rgbRegex.exec(normalizedColor);
  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }
  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
    };
  }
  var hslMatched = hslRegex.exec(normalizedColor);
  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10);
    var saturation = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);
    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }
    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }
  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);
    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }
    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
    };
  }
  throw new PolishedError(5);
}
function rgbToHsl(color) {
  var red = color.red / 255;
  var green = color.green / 255;
  var blue = color.blue / 255;
  var max6 = Math.max(red, green, blue);
  var min6 = Math.min(red, green, blue);
  var lightness = (max6 + min6) / 2;
  if (max6 === min6) {
    if (color.alpha !== void 0) {
      return {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color.alpha
      };
    } else {
      return {
        hue: 0,
        saturation: 0,
        lightness
      };
    }
  }
  var hue;
  var delta = max6 - min6;
  var saturation = lightness > 0.5 ? delta / (2 - max6 - min6) : delta / (max6 + min6);
  switch (max6) {
    case red:
      hue = (green - blue) / delta + (green < blue ? 6 : 0);
      break;
    case green:
      hue = (blue - red) / delta + 2;
      break;
    default:
      hue = (red - green) / delta + 4;
      break;
  }
  hue *= 60;
  if (color.alpha !== void 0) {
    return {
      hue,
      saturation,
      lightness,
      alpha: color.alpha
    };
  }
  return {
    hue,
    saturation,
    lightness
  };
}
function parseToHsl(color) {
  return rgbToHsl(parseToRgb(color));
}
function numberToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
function colorToHex(color) {
  return numberToHex(Math.round(color * 255));
}
function convertToHex(red, green, blue) {
  return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
}
function hslToHex(hue, saturation, lightness) {
  return hslToRgb(hue, saturation, lightness, convertToHex);
}
function hsl(value, saturation, lightness) {
  if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
    return hslToHex(value, saturation, lightness);
  } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
    return hslToHex(value.hue, value.saturation, value.lightness);
  }
  throw new PolishedError(1);
}
function hsla(value, saturation, lightness, alpha) {
  if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
    return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
  } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
  }
  throw new PolishedError(2);
}
function rgb(value, green, blue) {
  if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === "object" && green === void 0 && blue === void 0) {
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }
  throw new PolishedError(6);
}
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === "string" && typeof secondValue === "number") {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }
  throw new PolishedError(7);
}
function toColorString(color) {
  if (typeof color !== "object")
    throw new PolishedError(8);
  if (isRgba(color))
    return rgba(color);
  if (isRgb(color))
    return rgb(color);
  if (isHsla(color))
    return hsla(color);
  if (isHsl(color))
    return hsl(color);
  throw new PolishedError(8);
}
function curried(f3, length2, acc) {
  return function fn() {
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length2 ? f3.apply(this, combined) : curried(f3, length2, combined);
  };
}
function curry(f3) {
  return curried(f3, f3.length, []);
}
function adjustHue(degree, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    hue: hslColor.hue + parseFloat(degree)
  }));
}
function complement(color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    hue: (hslColor.hue + 180) % 360
  }));
}
function guard2(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}
function darken(amount, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    lightness: guard2(0, 1, hslColor.lightness - parseFloat(amount))
  }));
}
function desaturate(amount, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    saturation: guard2(0, 1, hslColor.saturation - parseFloat(amount))
  }));
}
function getLuminance(color) {
  if (color === "transparent")
    return 0;
  var rgbColor = parseToRgb(color);
  var _Object$keys$map = Object.keys(rgbColor).map(function(key2) {
    var channel = rgbColor[key2] / 255;
    return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
  }), r4 = _Object$keys$map[0], g2 = _Object$keys$map[1], b3 = _Object$keys$map[2];
  return parseFloat((0.2126 * r4 + 0.7152 * g2 + 0.0722 * b3).toFixed(3));
}
function getContrast(color1, color2) {
  var luminance1 = getLuminance(color1);
  var luminance2 = getLuminance(color2);
  return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));
}
function grayscale(color) {
  if (color === "transparent")
    return color;
  return toColorString(_extends({}, parseToHsl(color), {
    saturation: 0
  }));
}
function hslToColorString(color) {
  if (typeof color === "object" && typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number") {
    if (color.alpha && typeof color.alpha === "number") {
      return hsla({
        hue: color.hue,
        saturation: color.saturation,
        lightness: color.lightness,
        alpha: color.alpha
      });
    }
    return hsl({
      hue: color.hue,
      saturation: color.saturation,
      lightness: color.lightness
    });
  }
  throw new PolishedError(45);
}
function invert(color) {
  if (color === "transparent")
    return color;
  var value = parseToRgb(color);
  return toColorString(_extends({}, value, {
    red: 255 - value.red,
    green: 255 - value.green,
    blue: 255 - value.blue
  }));
}
function lighten(amount, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    lightness: guard2(0, 1, hslColor.lightness + parseFloat(amount))
  }));
}
function meetsContrastGuidelines(color1, color2) {
  var contrastRatio = getContrast(color1, color2);
  return {
    AA: contrastRatio >= 4.5,
    AALarge: contrastRatio >= 3,
    AAA: contrastRatio >= 7,
    AAALarge: contrastRatio >= 4.5
  };
}
function mix(weight, color, otherColor) {
  if (color === "transparent")
    return otherColor;
  if (otherColor === "transparent")
    return color;
  if (weight === 0)
    return otherColor;
  var parsedColor1 = parseToRgb(color);
  var color1 = _extends({}, parsedColor1, {
    alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
  });
  var parsedColor2 = parseToRgb(otherColor);
  var color2 = _extends({}, parsedColor2, {
    alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
  });
  var alphaDelta = color1.alpha - color2.alpha;
  var x3 = parseFloat(weight) * 2 - 1;
  var y4 = x3 * alphaDelta === -1 ? x3 : x3 + alphaDelta;
  var z3 = 1 + x3 * alphaDelta;
  var weight1 = (y4 / z3 + 1) / 2;
  var weight2 = 1 - weight1;
  var mixedColor = {
    red: Math.floor(color1.red * weight1 + color2.red * weight2),
    green: Math.floor(color1.green * weight1 + color2.green * weight2),
    blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
    alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))
  };
  return rgba(mixedColor);
}
function opacify(amount, color) {
  if (color === "transparent")
    return color;
  var parsedColor = parseToRgb(color);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard2(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
  });
  return rgba(colorWithAlpha);
}
function readableColor(color, returnIfLightColor, returnIfDarkColor, strict) {
  if (returnIfLightColor === void 0) {
    returnIfLightColor = defaultReturnIfLightColor;
  }
  if (returnIfDarkColor === void 0) {
    returnIfDarkColor = defaultReturnIfDarkColor;
  }
  if (strict === void 0) {
    strict = true;
  }
  var isColorLight = getLuminance(color) > 0.179;
  var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;
  if (!strict || getContrast(color, preferredReturnColor) >= 4.5) {
    return preferredReturnColor;
  }
  return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;
}
function rgbToColorString(color) {
  if (typeof color === "object" && typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number") {
    if (typeof color.alpha === "number") {
      return rgba({
        red: color.red,
        green: color.green,
        blue: color.blue,
        alpha: color.alpha
      });
    }
    return rgb({
      red: color.red,
      green: color.green,
      blue: color.blue
    });
  }
  throw new PolishedError(46);
}
function saturate(amount, color) {
  if (color === "transparent")
    return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    saturation: guard2(0, 1, hslColor.saturation + parseFloat(amount))
  }));
}
function setHue(hue, color) {
  if (color === "transparent")
    return color;
  return toColorString(_extends({}, parseToHsl(color), {
    hue: parseFloat(hue)
  }));
}
function setLightness(lightness, color) {
  if (color === "transparent")
    return color;
  return toColorString(_extends({}, parseToHsl(color), {
    lightness: parseFloat(lightness)
  }));
}
function setSaturation(saturation, color) {
  if (color === "transparent")
    return color;
  return toColorString(_extends({}, parseToHsl(color), {
    saturation: parseFloat(saturation)
  }));
}
function shade(percentage, color) {
  if (color === "transparent")
    return color;
  return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color);
}
function tint(percentage, color) {
  if (color === "transparent")
    return color;
  return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color);
}
function transparentize(amount, color) {
  if (color === "transparent")
    return color;
  var parsedColor = parseToRgb(color);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard2(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
  });
  return rgba(colorWithAlpha);
}
function animation() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var multiMode = Array.isArray(args[0]);
  if (!multiMode && args.length > 8) {
    throw new PolishedError(64);
  }
  var code = args.map(function(arg) {
    if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {
      throw new PolishedError(65);
    }
    if (Array.isArray(arg) && arg.length > 8) {
      throw new PolishedError(66);
    }
    return Array.isArray(arg) ? arg.join(" ") : arg;
  }).join(", ");
  return {
    animation: code
  };
}
function backgroundImages() {
  for (var _len = arguments.length, properties2 = new Array(_len), _key = 0; _key < _len; _key++) {
    properties2[_key] = arguments[_key];
  }
  return {
    backgroundImage: properties2.join(", ")
  };
}
function backgrounds() {
  for (var _len = arguments.length, properties2 = new Array(_len), _key = 0; _key < _len; _key++) {
    properties2[_key] = arguments[_key];
  }
  return {
    background: properties2.join(", ")
  };
}
function border(sideKeyword) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (typeof sideKeyword === "string" && sideMap.indexOf(sideKeyword) >= 0) {
    var _ref2;
    return _ref2 = {}, _ref2["border" + capitalizeString(sideKeyword) + "Width"] = values[0], _ref2["border" + capitalizeString(sideKeyword) + "Style"] = values[1], _ref2["border" + capitalizeString(sideKeyword) + "Color"] = values[2], _ref2;
  } else {
    values.unshift(sideKeyword);
    return {
      borderWidth: values[0],
      borderStyle: values[1],
      borderColor: values[2]
    };
  }
}
function borderColor() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["borderColor"].concat(values));
}
function borderRadius(side, radius) {
  var uppercaseSide = capitalizeString(side);
  if (!radius && radius !== 0) {
    throw new PolishedError(62);
  }
  if (uppercaseSide === "Top" || uppercaseSide === "Bottom") {
    var _ref2;
    return _ref2 = {}, _ref2["border" + uppercaseSide + "RightRadius"] = radius, _ref2["border" + uppercaseSide + "LeftRadius"] = radius, _ref2;
  }
  if (uppercaseSide === "Left" || uppercaseSide === "Right") {
    var _ref22;
    return _ref22 = {}, _ref22["borderTop" + uppercaseSide + "Radius"] = radius, _ref22["borderBottom" + uppercaseSide + "Radius"] = radius, _ref22;
  }
  throw new PolishedError(63);
}
function borderStyle() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["borderStyle"].concat(values));
}
function borderWidth() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["borderWidth"].concat(values));
}
function generateSelectors(template2, state) {
  var stateSuffix = state ? ":" + state : "";
  return template2(stateSuffix);
}
function statefulSelectors(states, template2, stateMap2) {
  if (!template2)
    throw new PolishedError(67);
  if (states.length === 0)
    return generateSelectors(template2, null);
  var selectors = [];
  for (var i4 = 0; i4 < states.length; i4 += 1) {
    if (stateMap2 && stateMap2.indexOf(states[i4]) < 0) {
      throw new PolishedError(68);
    }
    selectors.push(generateSelectors(template2, states[i4]));
  }
  selectors = selectors.join(",");
  return selectors;
}
function template$1(state) {
  return "button" + state + ',\n  input[type="button"]' + state + ',\n  input[type="reset"]' + state + ',\n  input[type="submit"]' + state;
}
function buttons() {
  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
    states[_key] = arguments[_key];
  }
  return statefulSelectors(states, template$1, stateMap$1);
}
function margin() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["margin"].concat(values));
}
function padding() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["padding"].concat(values));
}
function position2(firstValue) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (positionMap.indexOf(firstValue) >= 0 && firstValue) {
    return _extends({}, directionalProperty.apply(void 0, [""].concat(values)), {
      position: firstValue
    });
  } else {
    return directionalProperty.apply(void 0, ["", firstValue].concat(values));
  }
}
function size2(height, width) {
  if (width === void 0) {
    width = height;
  }
  return {
    height,
    width
  };
}
function template(state) {
  return 'input[type="color"]' + state + ',\n    input[type="date"]' + state + ',\n    input[type="datetime"]' + state + ',\n    input[type="datetime-local"]' + state + ',\n    input[type="email"]' + state + ',\n    input[type="month"]' + state + ',\n    input[type="number"]' + state + ',\n    input[type="password"]' + state + ',\n    input[type="search"]' + state + ',\n    input[type="tel"]' + state + ',\n    input[type="text"]' + state + ',\n    input[type="time"]' + state + ',\n    input[type="url"]' + state + ',\n    input[type="week"]' + state + ",\n    input:not([type])" + state + ",\n    textarea" + state;
}
function textInputs() {
  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
    states[_key] = arguments[_key];
  }
  return statefulSelectors(states, template, stateMap);
}
function transitions() {
  for (var _len = arguments.length, properties2 = new Array(_len), _key = 0; _key < _len; _key++) {
    properties2[_key] = arguments[_key];
  }
  if (Array.isArray(properties2[0]) && properties2.length === 2) {
    var value = properties2[1];
    if (typeof value !== "string") {
      throw new PolishedError(61);
    }
    var transitionsString = properties2[0].map(function(property) {
      return property + " " + value;
    }).join(", ");
    return {
      transition: transitionsString
    };
  } else {
    return {
      transition: properties2.join(", ")
    };
  }
}
var defaultSymbols, defaultSymbolMap, ERRORS, PolishedError, unitRegExp, cssVariableRegex, positionMap$1, cssRegex$1, pxtoFactory, pixelsto, em, em$1, cssRegex, ratioNames, rem, rem$1, defaultFontSize, functionsMap$3, functionsMap$2, functionsMap$1, dataURIRegex, formatHintMap, _templateObject$1, _templateObject, functionsMap, getBorderWidth, getBorderColor, namedColorMap, hexRegex, hexRgbaRegex, reducedHexRegex, reducedRgbaHexRegex, rgbRegex, rgbaRegex, hslRegex, hslaRegex, reduceHexValue, reduceHexValue$1, isRgb, isRgba, isHsl, isHsla, curriedAdjustHue, curriedAdjustHue$1, curriedDarken, curriedDarken$1, curriedDesaturate, curriedDesaturate$1, curriedLighten, curriedLighten$1, curriedMix, mix$1, curriedOpacify, curriedOpacify$1, defaultReturnIfLightColor, defaultReturnIfDarkColor, curriedSaturate, curriedSaturate$1, curriedSetHue, curriedSetHue$1, curriedSetLightness, curriedSetLightness$1, curriedSetSaturation, curriedSetSaturation$1, curriedShade, curriedShade$1, curriedTint, curriedTint$1, curriedTransparentize, curriedTransparentize$1, sideMap, stateMap$1, positionMap, stateMap;
var init_polished_esm = __esm({
  "node_modules/polished/dist/polished.esm.js"() {
    init_extends();
    init_assertThisInitialized();
    init_inheritsLoose();
    init_wrapNativeSuper();
    init_taggedTemplateLiteralLoose();
    defaultSymbols = {
      symbols: {
        "*": {
          infix: {
            symbol: "*",
            f: multiplication,
            notation: "infix",
            precedence: 4,
            rightToLeft: 0,
            argCount: 2
          },
          symbol: "*",
          regSymbol: "\\*"
        },
        "/": {
          infix: {
            symbol: "/",
            f: division,
            notation: "infix",
            precedence: 4,
            rightToLeft: 0,
            argCount: 2
          },
          symbol: "/",
          regSymbol: "/"
        },
        "+": {
          infix: {
            symbol: "+",
            f: addition,
            notation: "infix",
            precedence: 2,
            rightToLeft: 0,
            argCount: 2
          },
          prefix: {
            symbol: "+",
            f: last3,
            notation: "prefix",
            precedence: 3,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "+",
          regSymbol: "\\+"
        },
        "-": {
          infix: {
            symbol: "-",
            f: subtraction,
            notation: "infix",
            precedence: 2,
            rightToLeft: 0,
            argCount: 2
          },
          prefix: {
            symbol: "-",
            f: negation,
            notation: "prefix",
            precedence: 3,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "-",
          regSymbol: "-"
        },
        ",": {
          infix: {
            symbol: ",",
            f: comma,
            notation: "infix",
            precedence: 1,
            rightToLeft: 0,
            argCount: 2
          },
          symbol: ",",
          regSymbol: ","
        },
        "(": {
          prefix: {
            symbol: "(",
            f: last3,
            notation: "prefix",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "(",
          regSymbol: "\\("
        },
        ")": {
          postfix: {
            symbol: ")",
            f: void 0,
            notation: "postfix",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: ")",
          regSymbol: "\\)"
        },
        min: {
          func: {
            symbol: "min",
            f: min3,
            notation: "func",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "min",
          regSymbol: "min\\b"
        },
        max: {
          func: {
            symbol: "max",
            f: max3,
            notation: "func",
            precedence: 0,
            rightToLeft: 0,
            argCount: 1
          },
          symbol: "max",
          regSymbol: "max\\b"
        }
      }
    };
    defaultSymbolMap = defaultSymbols;
    ERRORS = {
      "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
      "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
      "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
      "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
      "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
      "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
      "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
      "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
      "9": "Please provide a number of steps to the modularScale helper.\n\n",
      "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
      "11": 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n',
      "12": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n',
      "13": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n',
      "14": 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
      "15": 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
      "16": "You must provide a template to this method.\n\n",
      "17": "You passed an unsupported selector state to this method.\n\n",
      "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
      "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
      "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
      "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
      "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
      "23": "fontFace expects a name of a font-family.\n\n",
      "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
      "25": "fontFace expects localFonts to be an array.\n\n",
      "26": "fontFace expects fileFormats to be an array.\n\n",
      "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
      "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
      "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
      "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
      "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
      "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
      "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
      "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
      "35": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
      "36": "Property must be a string value.\n\n",
      "37": "Syntax Error at %s.\n\n",
      "38": "Formula contains a function that needs parentheses at %s.\n\n",
      "39": "Formula is missing closing parenthesis at %s.\n\n",
      "40": "Formula has too many closing parentheses at %s.\n\n",
      "41": "All values in a formula must have the same unit or be unitless.\n\n",
      "42": "Please provide a number of steps to the modularScale helper.\n\n",
      "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
      "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
      "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
      "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
      "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
      "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
      "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
      "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
      "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
      "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
      "53": "fontFace expects localFonts to be an array.\n\n",
      "54": "fontFace expects fileFormats to be an array.\n\n",
      "55": "fontFace expects a name of a font-family.\n\n",
      "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
      "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
      "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
      "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
      "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
      "61": "Property must be a string value.\n\n",
      "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
      "63": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
      "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
      "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
      "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
      "67": "You must provide a template to this method.\n\n",
      "68": "You passed an unsupported selector state to this method.\n\n",
      "69": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n',
      "70": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n',
      "71": 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n',
      "72": 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n',
      "73": "Please provide a valid CSS variable.\n\n",
      "74": "CSS variable not found and no default was provided.\n\n",
      "75": "important requires a valid style object, got a %s instead.\n\n",
      "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
      "77": 'remToPx expects a value in "rem" but you provided it in "%s".\n\n',
      "78": 'base must be set in "px" or "%" but you set it in "%s".\n'
    };
    PolishedError = function(_Error) {
      _inheritsLoose(PolishedError2, _Error);
      function PolishedError2(code) {
        var _this;
        if (false) {
          _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
        } else {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this = _Error.call(this, format2.apply(void 0, [ERRORS[code]].concat(args))) || this;
        }
        return _assertThisInitialized(_this);
      }
      return PolishedError2;
    }(_wrapNativeSuper2(Error));
    unitRegExp = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
    cssVariableRegex = /--[\S]*/g;
    positionMap$1 = ["Top", "Right", "Bottom", "Left"];
    cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
    pxtoFactory = function pxtoFactory2(to2) {
      return function(pxval, base) {
        if (base === void 0) {
          base = "16px";
        }
        var newPxval = pxval;
        var newBase = base;
        if (typeof pxval === "string") {
          if (!endsWith(pxval, "px")) {
            throw new PolishedError(69, to2, pxval);
          }
          newPxval = stripUnit(pxval);
        }
        if (typeof base === "string") {
          if (!endsWith(base, "px")) {
            throw new PolishedError(70, to2, base);
          }
          newBase = stripUnit(base);
        }
        if (typeof newPxval === "string") {
          throw new PolishedError(71, pxval, to2);
        }
        if (typeof newBase === "string") {
          throw new PolishedError(72, base, to2);
        }
        return "" + newPxval / newBase + to2;
      };
    };
    pixelsto = pxtoFactory;
    em = pixelsto("em");
    em$1 = em;
    cssRegex = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
    ratioNames = {
      minorSecond: 1.067,
      majorSecond: 1.125,
      minorThird: 1.2,
      majorThird: 1.25,
      perfectFourth: 1.333,
      augFourth: 1.414,
      perfectFifth: 1.5,
      minorSixth: 1.6,
      goldenSection: 1.618,
      majorSixth: 1.667,
      minorSeventh: 1.778,
      majorSeventh: 1.875,
      octave: 2,
      majorTenth: 2.5,
      majorEleventh: 2.667,
      majorTwelfth: 3,
      doubleOctave: 4
    };
    rem = pixelsto("rem");
    rem$1 = rem;
    defaultFontSize = 16;
    functionsMap$3 = {
      back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
      circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
      cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
      expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
      quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
      quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
      quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
      sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)"
    };
    functionsMap$2 = {
      back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
      circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
      cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
      expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
      quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
      quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
      quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
      sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
    };
    functionsMap$1 = {
      back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
      cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
      circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
      expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
      quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
      quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
      quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
      sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)"
    };
    dataURIRegex = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i;
    formatHintMap = {
      woff: "woff",
      woff2: "woff2",
      ttf: "truetype",
      otf: "opentype",
      eot: "embedded-opentype",
      svg: "svg",
      svgz: "svg"
    };
    functionsMap = {
      easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
      easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
      easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
      easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
      easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
      easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
      easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
      easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)",
      easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
      easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
      easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
      easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
      easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
      easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
      easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
      easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)",
      easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
      easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
      easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
      easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
      easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
      easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
      easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
      easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
    };
    getBorderWidth = function getBorderWidth2(pointingDirection, height, width) {
      var fullWidth = "" + width[0] + (width[1] || "");
      var halfWidth = "" + width[0] / 2 + (width[1] || "");
      var fullHeight = "" + height[0] + (height[1] || "");
      var halfHeight = "" + height[0] / 2 + (height[1] || "");
      switch (pointingDirection) {
        case "top":
          return "0 " + halfWidth + " " + fullHeight + " " + halfWidth;
        case "topLeft":
          return fullWidth + " " + fullHeight + " 0 0";
        case "left":
          return halfHeight + " " + fullWidth + " " + halfHeight + " 0";
        case "bottomLeft":
          return fullWidth + " 0 0 " + fullHeight;
        case "bottom":
          return fullHeight + " " + halfWidth + " 0 " + halfWidth;
        case "bottomRight":
          return "0 0 " + fullWidth + " " + fullHeight;
        case "right":
          return halfHeight + " 0 " + halfHeight + " " + fullWidth;
        case "topRight":
        default:
          return "0 " + fullWidth + " " + fullHeight + " 0";
      }
    };
    getBorderColor = function getBorderColor2(pointingDirection, foregroundColor) {
      switch (pointingDirection) {
        case "top":
        case "bottomRight":
          return {
            borderBottomColor: foregroundColor
          };
        case "right":
        case "bottomLeft":
          return {
            borderLeftColor: foregroundColor
          };
        case "bottom":
        case "topLeft":
          return {
            borderTopColor: foregroundColor
          };
        case "left":
        case "topRight":
          return {
            borderRightColor: foregroundColor
          };
        default:
          throw new PolishedError(59);
      }
    };
    namedColorMap = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "639",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    hexRegex = /^#[a-fA-F0-9]{6}$/;
    hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
    reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
    reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
    rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
    rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
    hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
    hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
    reduceHexValue = function reduceHexValue2(value) {
      if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
        return "#" + value[1] + value[3] + value[5];
      }
      return value;
    };
    reduceHexValue$1 = reduceHexValue;
    isRgb = function isRgb2(color) {
      return typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number" && (typeof color.alpha !== "number" || typeof color.alpha === "undefined");
    };
    isRgba = function isRgba2(color) {
      return typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number" && typeof color.alpha === "number";
    };
    isHsl = function isHsl2(color) {
      return typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number" && (typeof color.alpha !== "number" || typeof color.alpha === "undefined");
    };
    isHsla = function isHsla2(color) {
      return typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number" && typeof color.alpha === "number";
    };
    curriedAdjustHue = curry(adjustHue);
    curriedAdjustHue$1 = curriedAdjustHue;
    curriedDarken = curry(darken);
    curriedDarken$1 = curriedDarken;
    curriedDesaturate = curry(desaturate);
    curriedDesaturate$1 = curriedDesaturate;
    curriedLighten = curry(lighten);
    curriedLighten$1 = curriedLighten;
    curriedMix = curry(mix);
    mix$1 = curriedMix;
    curriedOpacify = curry(opacify);
    curriedOpacify$1 = curriedOpacify;
    defaultReturnIfLightColor = "#000";
    defaultReturnIfDarkColor = "#fff";
    curriedSaturate = curry(saturate);
    curriedSaturate$1 = curriedSaturate;
    curriedSetHue = curry(setHue);
    curriedSetHue$1 = curriedSetHue;
    curriedSetLightness = curry(setLightness);
    curriedSetLightness$1 = curriedSetLightness;
    curriedSetSaturation = curry(setSaturation);
    curriedSetSaturation$1 = curriedSetSaturation;
    curriedShade = curry(shade);
    curriedShade$1 = curriedShade;
    curriedTint = curry(tint);
    curriedTint$1 = curriedTint;
    curriedTransparentize = curry(transparentize);
    curriedTransparentize$1 = curriedTransparentize;
    sideMap = ["top", "right", "bottom", "left"];
    stateMap$1 = [void 0, null, "active", "focus", "hover"];
    positionMap = ["absolute", "fixed", "relative", "static", "sticky"];
    stateMap = [void 0, null, "active", "focus", "hover"];
  }
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "node_modules/dataloader/index.js"(exports, module2) {
    "use strict";
    var DataLoader = function() {
      function DataLoader2(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
      }
      var _proto = DataLoader2.prototype;
      _proto.load = function load(key2) {
        if (key2 === null || key2 === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key2) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key2);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key2);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys2) {
        if (!isArrayLike2(keys2)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys2 + "."));
        }
        var loadPromises = [];
        for (var i4 = 0; i4 < keys2.length; i4++) {
          loadPromises.push(this.load(keys2[i4])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key2) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key2);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key2, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key2);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader2;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise;
      try {
        batchPromise = loader._batchLoadFn(batch.keys);
      } catch (e5) {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e5) + ".")));
      }
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike2(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i4 = 0; i4 < batch.callbacks.length; i4++) {
          var value = values[i4];
          if (value instanceof Error) {
            batch.callbacks[i4].reject(value);
          } else {
            batch.callbacks[i4].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i4 = 0; i4 < batch.keys.length; i4++) {
        loader.clear(batch.keys[i4]);
        batch.callbacks[i4].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i4 = 0; i4 < batch.cacheHits.length; i4++) {
          batch.cacheHits[i4]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key2) {
          return key2;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function getValidName(options) {
      if (options && options.name) {
        return options.name;
      }
      return null;
    }
    function isArrayLike2(x3) {
      return typeof x3 === "object" && x3 !== null && typeof x3.length === "number" && (x3.length === 0 || x3.length > 0 && Object.prototype.hasOwnProperty.call(x3, x3.length - 1));
    }
    module2.exports = DataLoader;
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports);
  }
});

// node_modules/raf/index.js
var require_raf = __commonJS({
  "node_modules/raf/index.js"(exports, module2) {
    var now2 = require_performance_now();
    var root = typeof window === "undefined" ? global : window;
    var vendors = ["moz", "webkit"];
    var suffix = "AnimationFrame";
    var raf = root["request" + suffix];
    var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (i4 = 0; !raf && i4 < vendors.length; i4++) {
      raf = root[vendors[i4] + "Request" + suffix];
      caf = root[vendors[i4] + "Cancel" + suffix] || root[vendors[i4] + "CancelRequest" + suffix];
    }
    var i4;
    if (!raf || !caf) {
      last5 = 0, id2 = 0, queue2 = [], frameDuration = 1e3 / 60;
      raf = function(callback) {
        if (queue2.length === 0) {
          var _now = now2(), next4 = Math.max(0, frameDuration - (_now - last5));
          last5 = next4 + _now;
          setTimeout(function() {
            var cp = queue2.slice(0);
            queue2.length = 0;
            for (var i5 = 0; i5 < cp.length; i5++) {
              if (!cp[i5].cancelled) {
                try {
                  cp[i5].callback(last5);
                } catch (e5) {
                  setTimeout(function() {
                    throw e5;
                  }, 0);
                }
              }
            }
          }, Math.round(next4));
        }
        queue2.push({
          handle: ++id2,
          callback,
          cancelled: false
        });
        return id2;
      };
      caf = function(handle) {
        for (var i5 = 0; i5 < queue2.length; i5++) {
          if (queue2[i5].handle === handle) {
            queue2[i5].cancelled = true;
          }
        }
      };
    }
    var last5;
    var id2;
    var queue2;
    var frameDuration;
    module2.exports = function(fn) {
      return raf.call(root, fn);
    };
    module2.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    module2.exports.polyfill = function(object2) {
      if (!object2) {
        object2 = root;
      }
      object2.requestAnimationFrame = raf;
      object2.cancelAnimationFrame = caf;
    };
  }
});

// node_modules/lodash/_baseRandom.js
var require_baseRandom = __commonJS({
  "node_modules/lodash/_baseRandom.js"(exports, module2) {
    var nativeFloor = Math.floor;
    var nativeRandom = Math.random;
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }
    module2.exports = baseRandom;
  }
});

// node_modules/lodash/_arraySample.js
var require_arraySample = __commonJS({
  "node_modules/lodash/_arraySample.js"(exports, module2) {
    var baseRandom = require_baseRandom();
    function arraySample(array) {
      var length2 = array.length;
      return length2 ? array[baseRandom(0, length2 - 1)] : void 0;
    }
    module2.exports = arraySample;
  }
});

// node_modules/lodash/_baseSample.js
var require_baseSample = __commonJS({
  "node_modules/lodash/_baseSample.js"(exports, module2) {
    var arraySample = require_arraySample();
    var values = require_values();
    function baseSample(collection) {
      return arraySample(values(collection));
    }
    module2.exports = baseSample;
  }
});

// node_modules/lodash/sample.js
var require_sample = __commonJS({
  "node_modules/lodash/sample.js"(exports, module2) {
    var arraySample = require_arraySample();
    var baseSample = require_baseSample();
    var isArray5 = require_isArray();
    function sample2(collection) {
      var func2 = isArray5(collection) ? arraySample : baseSample;
      return func2(collection);
    }
    module2.exports = sample2;
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m4 = require_react_dom();
    if (false) {
      exports.createRoot = m4.createRoot;
      exports.hydrateRoot = m4.hydrateRoot;
    } else {
      i4 = m4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c4, o4) {
        i4.usingClientEntryPoint = true;
        try {
          return m4.createRoot(c4, o4);
        } finally {
          i4.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c4, h3, o4) {
        i4.usingClientEntryPoint = true;
        try {
          return m4.hydrateRoot(c4, h3, o4);
        } finally {
          i4.usingClientEntryPoint = false;
        }
      };
    }
    var i4;
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports, module2) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray5 = require_isArray();
    var isArrayLike2 = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function isEmpty3(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike2(value) && (isArray5(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key2 in value) {
        if (hasOwnProperty.call(value, key2)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty3;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React18 = require_react();
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn3(format4) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format4, args);
            }
          }
        }
        function error(format4) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format4, args);
            }
          }
        }
        function printWarning(level, format4, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format4 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format4);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        function beginWriting(destination) {
        }
        function writeChunk(destination, chunk) {
          writeChunkAndReturn(destination, chunk);
        }
        function writeChunkAndReturn(destination, chunk) {
          return destination.push(chunk);
        }
        function completeWriting(destination) {
        }
        function close(destination) {
          destination.push(null);
        }
        function stringToChunk(content) {
          return content;
        }
        function stringToPrecomputedChunk(content) {
          return content;
        }
        function closeWithError(destination, error2) {
          destination.destroy(error2);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix3 = name.toLowerCase().slice(0, 5);
                return prefix3 !== "data-" && prefix3 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties2.hasOwnProperty(name) ? properties2[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties2 = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref2) {
          var name = _ref2[0], attributeName = _ref2[1];
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token3) {
          return token3[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties2[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties2[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties2[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix3, key2) {
          return prefix3 + key2.charAt(0).toUpperCase() + key2.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix3) {
            isUnitlessNumber[prefixKey(prefix3, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key2 in props) {
              var isValid3 = validateProperty(type, key2);
              if (!isValid3) {
                invalidProps.push(key2);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key2 in props) {
              var isValid3 = validateProperty$1(type, key2, props[key2], eventRegistry);
              if (!isValid3) {
                unknownProps.push(key2);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string4) {
            return string4.replace(hyphenPattern, function(_2, character2) {
              return character2.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string4) {
          {
            checkHtmlStringCoercion(string4);
          }
          var str = "" + string4;
          var match5 = matchHtmlRegExp.exec(str);
          if (!match5) {
            return str;
          }
          var escape;
          var html = "";
          var index3;
          var lastIndex = 0;
          for (index3 = match5.index; index3 < str.length; index3++) {
            switch (str.charCodeAt(index3)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index3) {
              html += str.substring(lastIndex, index3);
            }
            lastIndex = index3 + 1;
            html += escape;
          }
          return lastIndex !== index3 ? html + str.substring(lastIndex, index3) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray5(a5) {
          return isArrayImpl(a5);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match5, prefix3, s5, suffix) {
          return "" + prefix3 + (s5 === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i4 = 0; i4 < bootstrapScripts.length; i4++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i4])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id2 = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id2 += "H" + localId.toString(32);
          }
          return id2 + ":";
        }
        function encodeHTMLTextNode(text) {
          return escapeTextForBrowser(text);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text, responseState, textEmbedded) {
          if (text === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix3 = name.toLowerCase().slice(0, 5);
                if (prefix3 !== "data-" && prefix3 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value = props[propName];
            if (value != null) {
              var array = isArray5(value);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React18.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray5(selectedValue)) {
              for (var i4 = 0; i4 < selectedValue.length; i4++) {
                {
                  checkAttributeStringCoercion(selectedValue[i4], "value");
                }
                var v2 = "" + selectedValue[i4];
                if (v2 === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue2 = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue2 = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue2 !== null) {
            pushAttribute(target, responseState, "value", defaultValue2);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue2 = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue2 = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue2 !== null) {
            value = defaultValue2;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray5(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i4 = 0;
          for (; i4 < bootstrapChunks.length - 1; i4++) {
            writeChunk(destination, bootstrapChunks[i4]);
          }
          if (i4 < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i4]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id2) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id2.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id2) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id2 === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id2);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id2) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match5) {
            switch (match5) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        function createResponseState$1(generateStaticMarkup, identifierPrefix) {
          var responseState = createResponseState(identifierPrefix, void 0);
          return {
            // Keep this in sync with ReactDOMServerFormatConfig
            bootstrapChunks: responseState.bootstrapChunks,
            startInlineScript: responseState.startInlineScript,
            placeholderPrefix: responseState.placeholderPrefix,
            segmentPrefix: responseState.segmentPrefix,
            boundaryPrefix: responseState.boundaryPrefix,
            idPrefix: responseState.idPrefix,
            nextSuspenseID: responseState.nextSuspenseID,
            sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
            sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
            sentClientRenderFunction: responseState.sentClientRenderFunction,
            // This is an extra field for the legacy renderer
            generateStaticMarkup
          };
        }
        function createRootFormatContext() {
          return {
            insertionMode: HTML_MODE,
            // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
            selectedValue: null
          };
        }
        function pushTextInstance$1(target, text, responseState, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            target.push(stringToChunk(escapeTextForBrowser(text)));
            return false;
          } else {
            return pushTextInstance(target, text, responseState, textEmbedded);
          }
        }
        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            return;
          } else {
            return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
          }
        }
        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartCompletedSuspenseBoundary(destination);
        }
        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
        }
        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndCompletedSuspenseBoundary(destination);
        }
        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndClientRenderedSuspenseBoundary(destination);
        }
        var assign3 = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign3({}, props, {
                  value: prevLog
                }),
                info: assign3({}, props, {
                  value: prevInfo
                }),
                warn: assign3({}, props, {
                  value: prevWarn
                }),
                error: assign3({}, props, {
                  value: prevError
                }),
                group: assign3({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign3({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign3({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix2;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix2 === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match5 = x3.stack.trim().match(/\n( *(at )?)/);
                prefix2 = match5 && match5[1] || "";
              }
            }
            return "\n" + prefix2 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample2) {
            if (sample2 && control && typeof sample2.stack === "string") {
              var sampleLines = sample2.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s5 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s5 >= 1 && c4 >= 0 && sampleLines[s5] !== controlLines[c4]) {
                c4--;
              }
              for (; s5 >= 1 && c4 >= 0; s5--, c4--) {
                if (sampleLines[s5] !== controlLines[c4]) {
                  if (s5 !== 1 || c4 !== 1) {
                    do {
                      s5--;
                      c4--;
                      if (c4 < 0 || sampleLines[s5] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s5].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s5 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context2 = {};
            for (var key2 in contextTypes) {
              context2[key2] = unmaskedContext[key2];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name);
            }
            return context2;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign3({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev2) {
          {
            prev2.context._currentValue2 = prev2.parentValue;
          }
        }
        function pushNode(next4) {
          {
            next4.context._currentValue2 = next4.value;
          }
        }
        function popToNearestCommonAncestor(prev2, next4) {
          if (prev2 === next4)
            ;
          else {
            popNode(prev2);
            var parentPrev = prev2.parent;
            var parentNext = next4.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next4);
          }
        }
        function popAllPrevious(prev2) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next4) {
          var parentNext = next4.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next4);
        }
        function popPreviousToCommonLevel(prev2, next4) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next4.depth) {
            popToNearestCommonAncestor(parentPrev, next4);
          } else {
            popPreviousToCommonLevel(parentPrev, next4);
          }
        }
        function popNextToCommonLevel(prev2, next4) {
          var parentNext = next4.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev2.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev2, parentNext);
          } else {
            popNextToCommonLevel(prev2, parentNext);
          }
          pushNode(next4);
        }
        function switchContext(newSnapshot) {
          var prev2 = currentActiveSnapshot;
          var next4 = newSnapshot;
          if (prev2 !== next4) {
            if (prev2 === null) {
              pushAllNext(next4);
            } else if (next4 === null) {
              popAllPrevious(prev2);
            } else if (prev2.depth === next4.depth) {
              popToNearestCommonAncestor(prev2, next4);
            } else if (prev2.depth > next4.depth) {
              popPreviousToCommonLevel(prev2, next4);
            } else {
              popNextToCommonLevel(prev2, next4);
            }
            currentActiveSnapshot = next4;
          }
        }
        function pushProvider(context2, nextValue) {
          var prevValue;
          {
            prevValue = context2._currentValue2;
            context2._currentValue2 = nextValue;
            {
              if (context2._currentRenderer2 !== void 0 && context2._currentRenderer2 !== null && context2._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer2 = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: context2,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context2) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context2) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var _value = prevSnapshot.parentValue;
            if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue2 = _value;
            }
            {
              if (context2._currentRenderer2 !== void 0 && context2._currentRenderer2 !== null && context2._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer2 = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context2) {
          var value = context2._currentValue2;
          return value;
        }
        function get2(key2) {
          return key2._reactInternals;
        }
        function set4(key2, value) {
          key2._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key2 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key2)) {
              didWarnOnInvalidCallback.add(key2);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get2(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get2(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get2(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign3({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid3 = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid3 && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            context2 = maskedLegacyContext;
          }
          var instance = new ctor(props, context2);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray5(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn3(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i4 = oldReplace ? 1 : 0; i4 < oldQueue.length; i4++) {
                var partial = oldQueue[i4];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign3({}, nextState, partialState);
                  } else {
                    assign3(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set4(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context2) {
          var overflow = context2.overflow;
          var idWithLeadingBit = context2.id;
          var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id2.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index3) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index3 + 1;
          var length2 = getBitLength(totalChildren) + baseLength;
          if (length2 > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id2 = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id2,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length2 | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id2) {
          return 1 << getBitLength(id2) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x3) {
          var asUint = x3 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        function is2(x3, y4) {
          return x3 === y4 && (x3 !== 0 || 1 / x3 === 1 / y4) || x3 !== x3 && y4 !== y4;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i4 = 0; i4 < prevDeps.length && i4 < nextDeps.length; i4++) {
            if (objectIs(nextDeps[i4], prevDeps[i4])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component2, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component2(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context2) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context2);
        }
        function useContext8(context2) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context2);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState13(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer3(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer3(reducer2, initialArg, init) {
          {
            if (reducer2 !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer2(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer2 === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo8(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef15(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect5(create2, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback10(callback, deps) {
          return useMemo8(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop3() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext8,
          useMemo: useMemo8,
          useReducer: useReducer3,
          useRef: useRef15,
          useState: useState13,
          useInsertionEffect: noop3,
          useLayoutEffect: useLayoutEffect5,
          useCallback: useCallback10,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop3,
          // Effects are not run in the server environment.
          useEffect: noop3,
          // Debugging effect
          useDebugValue: noop3,
          useDeferredValue,
          useTransition,
          useId,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore: useSyncExternalStore2
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node5 = componentStack;
            do {
              switch (node5.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node5.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node5.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node5.type, null, null);
                  break;
              }
              node5 = node5.parent;
            } while (node5);
            return info;
          } catch (x3) {
            return "\nError generating stack: " + x3.message + "\n" + x3.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler2(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError2 === void 0 ? defaultErrorHandler2 : onError2,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node5, blockedBoundary, blockedSegment, abortSet, legacyContext, context2, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node: node5,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context: context2,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index3, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index: index3,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component2) {
          return Component2.prototype && Component2.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component2, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component2(props, secondArg);
          return finishHooks(Component2, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component2, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component2.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component2, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component2, props) {
          pushClassComponentStackInDEV(task, Component2);
          var maskedContext = getMaskedContext(Component2, task.legacyContext);
          var instance = constructClassInstance(Component2, props, maskedContext);
          mountClassInstance(instance, Component2, props, maskedContext);
          finishClassComponent(request, task, instance, Component2, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component2, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component2, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component2);
          {
            if (Component2.prototype && typeof Component2.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request, task, Component2, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component2, props, legacyContext);
            finishClassComponent(request, task, value, Component2, props);
          } else {
            {
              validateFunctionComponentInDev(Component2);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index3 = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index3);
              try {
                renderNodeDestructive(request, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component2) {
          {
            if (Component2) {
              if (Component2.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
              }
            }
            if (typeof Component2.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component2, baseProps) {
          if (Component2 && Component2.defaultProps) {
            var props = assign3({}, baseProps);
            var defaultProps = Component2.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index3 = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index3);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context2, props) {
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var render = props.children;
          {
            if (typeof render !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context2);
          var newChildren = render(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context2 = type._context;
          var value = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context2, value);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context2);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component2 = init(payload);
          var resolvedProps = resolveDefaultProps(Component2, props);
          renderElement(request, task, Component2, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node5) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node5);
            } catch (x3) {
              if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x3;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node5) {
          task.node = node5;
          if (typeof node5 === "object" && node5 !== null) {
            switch (node5.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node5;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node5;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x3) {
                    if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x3;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray5(node5)) {
              renderChildrenArray(request, task, node5);
              return;
            }
            var iteratorFn = getIteratorFn(node5);
            if (iteratorFn) {
              {
                validateIterable(node5, iteratorFn);
              }
              var iterator2 = iteratorFn.call(node5);
              if (iterator2) {
                var step = iterator2.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator2.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node5);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node5).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node5 === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node5, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node5 === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node5, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node5 === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i4 = 0; i4 < totalChildren; i4++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i4);
            try {
              renderNode(request, task, children[i4]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x3) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x3.then(ping, ping);
        }
        function renderNode(request, task, node5) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node5);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              spawnNewSuspendedTask(request, task, x3);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x3;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              var ping = task.ping;
              x3.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x3);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i4;
            for (i4 = 0; i4 < pingedTasks.length; i4++) {
              var task = pingedTasks[i4];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i4);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r4 = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r4 = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r4 = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r4;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id2 = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id2);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i4++;
              completedSegments.splice(0, i4);
              return false;
            }
          }
          completedSegments.splice(0, i4);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i4;
            for (i4 = 0; i4 < clientRenderedBoundaries.length; i4++) {
              var boundary = clientRenderedBoundaries[i4];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i4++;
                clientRenderedBoundaries.splice(0, i4);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i4);
            var completedBoundaries = request.completedBoundaries;
            for (i4 = 0; i4 < completedBoundaries.length; i4++) {
              var _boundary = completedBoundaries[i4];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i4++;
                completedBoundaries.splice(0, i4);
                return;
              }
            }
            completedBoundaries.splice(0, i4);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i4 = 0; i4 < partialBoundaries.length; i4++) {
              var _boundary2 = partialBoundaries[i4];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i4++;
                partialBoundaries.splice(0, i4);
                return;
              }
            }
            partialBoundaries.splice(0, i4);
            var largeBoundaries = request.completedBoundaries;
            for (i4 = 0; i4 < largeBoundaries.length; i4++) {
              var _boundary3 = largeBoundaries[i4];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i4++;
                largeBoundaries.splice(0, i4);
                return;
              }
            }
            largeBoundaries.splice(0, i4);
          } finally {
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function onError() {
        }
        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
          var didFatal = false;
          var fatalError2 = null;
          var result = "";
          var destination = {
            push: function(chunk) {
              if (chunk !== null) {
                result += chunk;
              }
              return true;
            },
            destroy: function(error2) {
              didFatal = true;
              fatalError2 = error2;
            }
          };
          var readyToStream = false;
          function onShellReady() {
            readyToStream = true;
          }
          var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
          startWork(request);
          abort(request, abortReason);
          startFlowing(request, destination);
          if (didFatal) {
            throw fatalError2;
          }
          if (!readyToStream) {
            throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          }
          return result;
        }
        function renderToString(children, options) {
          return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToStaticMarkup(children, options) {
          return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToNodeStream() {
          throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
        }
        function renderToStaticNodeStream() {
          throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.browser.development.js
var require_react_dom_server_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React18 = require_react();
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn3(format4) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format4, args);
            }
          }
        }
        function error(format4) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format4, args);
            }
          }
        }
        function printWarning(level, format4, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format4 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format4);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        var VIEW_SIZE = 512;
        var currentView = null;
        var writtenBytes = 0;
        function beginWriting(destination) {
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        function writeChunk(destination, chunk) {
          if (chunk.length === 0) {
            return;
          }
          if (chunk.length > VIEW_SIZE) {
            if (writtenBytes > 0) {
              destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            destination.enqueue(chunk);
            return;
          }
          var bytesToWrite = chunk;
          var allowableBytes = currentView.length - writtenBytes;
          if (allowableBytes < bytesToWrite.length) {
            if (allowableBytes === 0) {
              destination.enqueue(currentView);
            } else {
              currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
              destination.enqueue(currentView);
              bytesToWrite = bytesToWrite.subarray(allowableBytes);
            }
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          currentView.set(bytesToWrite, writtenBytes);
          writtenBytes += bytesToWrite.length;
        }
        function writeChunkAndReturn(destination, chunk) {
          writeChunk(destination, chunk);
          return true;
        }
        function completeWriting(destination) {
          if (currentView && writtenBytes > 0) {
            destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
            currentView = null;
            writtenBytes = 0;
          }
        }
        function close(destination) {
          destination.close();
        }
        var textEncoder = new TextEncoder();
        function stringToChunk(content) {
          return textEncoder.encode(content);
        }
        function stringToPrecomputedChunk(content) {
          return textEncoder.encode(content);
        }
        function closeWithError(destination, error2) {
          if (typeof destination.error === "function") {
            destination.error(error2);
          } else {
            destination.close();
          }
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix3 = name.toLowerCase().slice(0, 5);
                return prefix3 !== "data-" && prefix3 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties2.hasOwnProperty(name) ? properties2[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties2 = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref2) {
          var name = _ref2[0], attributeName = _ref2[1];
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties2[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token3) {
          return token3[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties2[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties2[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties2[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties2[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix3, key2) {
          return prefix3 + key2.charAt(0).toUpperCase() + key2.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix3) {
            isUnitlessNumber[prefixKey(prefix3, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key2 in props) {
              var isValid3 = validateProperty(type, key2);
              if (!isValid3) {
                invalidProps.push(key2);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key2 in props) {
              var isValid3 = validateProperty$1(type, key2, props[key2], eventRegistry);
              if (!isValid3) {
                unknownProps.push(key2);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string4) {
            return string4.replace(hyphenPattern, function(_2, character2) {
              return character2.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string4) {
          {
            checkHtmlStringCoercion(string4);
          }
          var str = "" + string4;
          var match5 = matchHtmlRegExp.exec(str);
          if (!match5) {
            return str;
          }
          var escape;
          var html = "";
          var index3;
          var lastIndex = 0;
          for (index3 = match5.index; index3 < str.length; index3++) {
            switch (str.charCodeAt(index3)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index3) {
              html += str.substring(lastIndex, index3);
            }
            lastIndex = index3 + 1;
            html += escape;
          }
          return lastIndex !== index3 ? html + str.substring(lastIndex, index3) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray5(a5) {
          return isArrayImpl(a5);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match5, prefix3, s5, suffix) {
          return "" + prefix3 + (s5 === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i4 = 0; i4 < bootstrapScripts.length; i4++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i4])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function createRootFormatContext(namespaceURI) {
          var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
          return createFormatContext(insertionMode, null);
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id2 = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id2 += "H" + localId.toString(32);
          }
          return id2 + ":";
        }
        function encodeHTMLTextNode(text) {
          return escapeTextForBrowser(text);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text, responseState, textEmbedded) {
          if (text === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix3 = name.toLowerCase().slice(0, 5);
                if (prefix3 !== "data-" && prefix3 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value = props[propName];
            if (value != null) {
              var array = isArray5(value);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React18.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray5(selectedValue)) {
              for (var i4 = 0; i4 < selectedValue.length; i4++) {
                {
                  checkAttributeStringCoercion(selectedValue[i4], "value");
                }
                var v2 = "" + selectedValue[i4];
                if (v2 === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue2 = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue2 = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue2 !== null) {
            pushAttribute(target, responseState, "value", defaultValue2);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue2 = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue2 = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue2 !== null) {
            value = defaultValue2;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray5(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i4 = 0;
          for (; i4 < bootstrapChunks.length - 1; i4++) {
            writeChunk(destination, bootstrapChunks[i4]);
          }
          if (i4 < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i4]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id2) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id2.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id2) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id2 === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id2);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id2) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id2.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match5) {
            switch (match5) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        var assign3 = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign3({}, props, {
                  value: prevLog
                }),
                info: assign3({}, props, {
                  value: prevInfo
                }),
                warn: assign3({}, props, {
                  value: prevWarn
                }),
                error: assign3({}, props, {
                  value: prevError
                }),
                group: assign3({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign3({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign3({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix2;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix2 === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match5 = x3.stack.trim().match(/\n( *(at )?)/);
                prefix2 = match5 && match5[1] || "";
              }
            }
            return "\n" + prefix2 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample2) {
            if (sample2 && control && typeof sample2.stack === "string") {
              var sampleLines = sample2.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s5 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s5 >= 1 && c4 >= 0 && sampleLines[s5] !== controlLines[c4]) {
                c4--;
              }
              for (; s5 >= 1 && c4 >= 0; s5--, c4--) {
                if (sampleLines[s5] !== controlLines[c4]) {
                  if (s5 !== 1 || c4 !== 1) {
                    do {
                      s5--;
                      c4--;
                      if (c4 < 0 || sampleLines[s5] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s5].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s5 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context2 = {};
            for (var key2 in contextTypes) {
              context2[key2] = unmaskedContext[key2];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name);
            }
            return context2;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign3({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev2) {
          {
            prev2.context._currentValue = prev2.parentValue;
          }
        }
        function pushNode(next4) {
          {
            next4.context._currentValue = next4.value;
          }
        }
        function popToNearestCommonAncestor(prev2, next4) {
          if (prev2 === next4)
            ;
          else {
            popNode(prev2);
            var parentPrev = prev2.parent;
            var parentNext = next4.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next4);
          }
        }
        function popAllPrevious(prev2) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next4) {
          var parentNext = next4.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next4);
        }
        function popPreviousToCommonLevel(prev2, next4) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next4.depth) {
            popToNearestCommonAncestor(parentPrev, next4);
          } else {
            popPreviousToCommonLevel(parentPrev, next4);
          }
        }
        function popNextToCommonLevel(prev2, next4) {
          var parentNext = next4.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev2.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev2, parentNext);
          } else {
            popNextToCommonLevel(prev2, parentNext);
          }
          pushNode(next4);
        }
        function switchContext(newSnapshot) {
          var prev2 = currentActiveSnapshot;
          var next4 = newSnapshot;
          if (prev2 !== next4) {
            if (prev2 === null) {
              pushAllNext(next4);
            } else if (next4 === null) {
              popAllPrevious(prev2);
            } else if (prev2.depth === next4.depth) {
              popToNearestCommonAncestor(prev2, next4);
            } else if (prev2.depth > next4.depth) {
              popPreviousToCommonLevel(prev2, next4);
            } else {
              popNextToCommonLevel(prev2, next4);
            }
            currentActiveSnapshot = next4;
          }
        }
        function pushProvider(context2, nextValue) {
          var prevValue;
          {
            prevValue = context2._currentValue;
            context2._currentValue = nextValue;
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: context2,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context2) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context2) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var value = prevSnapshot.parentValue;
            if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue = value;
            }
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context2) {
          var value = context2._currentValue;
          return value;
        }
        function get2(key2) {
          return key2._reactInternals;
        }
        function set4(key2, value) {
          key2._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key2 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key2)) {
              didWarnOnInvalidCallback.add(key2);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get2(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get2(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get2(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign3({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid3 = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid3 && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            context2 = maskedLegacyContext;
          }
          var instance = new ctor(props, context2);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray5(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn3(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i4 = oldReplace ? 1 : 0; i4 < oldQueue.length; i4++) {
                var partial = oldQueue[i4];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign3({}, nextState, partialState);
                  } else {
                    assign3(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set4(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context2) {
          var overflow = context2.overflow;
          var idWithLeadingBit = context2.id;
          var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id2.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index3) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index3 + 1;
          var length2 = getBitLength(totalChildren) + baseLength;
          if (length2 > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id2 = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id2,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length2 | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id2) {
          return 1 << getBitLength(id2) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x3) {
          var asUint = x3 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        function is2(x3, y4) {
          return x3 === y4 && (x3 !== 0 || 1 / x3 === 1 / y4) || x3 !== x3 && y4 !== y4;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i4 = 0; i4 < prevDeps.length && i4 < nextDeps.length; i4++) {
            if (objectIs(nextDeps[i4], prevDeps[i4])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component2, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component2(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context2) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context2);
        }
        function useContext8(context2) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context2);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState13(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer3(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer3(reducer2, initialArg, init) {
          {
            if (reducer2 !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer2(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer2 === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo8(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef15(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect5(create2, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback10(callback, deps) {
          return useMemo8(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop3() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext8,
          useMemo: useMemo8,
          useReducer: useReducer3,
          useRef: useRef15,
          useState: useState13,
          useInsertionEffect: noop3,
          useLayoutEffect: useLayoutEffect5,
          useCallback: useCallback10,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop3,
          // Effects are not run in the server environment.
          useEffect: noop3,
          // Debugging effect
          useDebugValue: noop3,
          useDeferredValue,
          useTransition,
          useId,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore: useSyncExternalStore2
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node5 = componentStack;
            do {
              switch (node5.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node5.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node5.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node5.type, null, null);
                  break;
              }
              node5 = node5.parent;
            } while (node5);
            return info;
          } catch (x3) {
            return "\nError generating stack: " + x3.message + "\n" + x3.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler2(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === void 0 ? defaultErrorHandler2 : onError,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node5, blockedBoundary, blockedSegment, abortSet, legacyContext, context2, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node: node5,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context: context2,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index3, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index: index3,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component2) {
          return Component2.prototype && Component2.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component2, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component2(props, secondArg);
          return finishHooks(Component2, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component2, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component2.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component2, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component2, props) {
          pushClassComponentStackInDEV(task, Component2);
          var maskedContext = getMaskedContext(Component2, task.legacyContext);
          var instance = constructClassInstance(Component2, props, maskedContext);
          mountClassInstance(instance, Component2, props, maskedContext);
          finishClassComponent(request, task, instance, Component2, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component2, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component2, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component2);
          {
            if (Component2.prototype && typeof Component2.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request, task, Component2, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component2, props, legacyContext);
            finishClassComponent(request, task, value, Component2, props);
          } else {
            {
              validateFunctionComponentInDev(Component2);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index3 = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index3);
              try {
                renderNodeDestructive(request, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component2) {
          {
            if (Component2) {
              if (Component2.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
              }
            }
            if (typeof Component2.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component2, baseProps) {
          if (Component2 && Component2.defaultProps) {
            var props = assign3({}, baseProps);
            var defaultProps = Component2.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index3 = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index3);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context2, props) {
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var render = props.children;
          {
            if (typeof render !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context2);
          var newChildren = render(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context2 = type._context;
          var value = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context2, value);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context2);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component2 = init(payload);
          var resolvedProps = resolveDefaultProps(Component2, props);
          renderElement(request, task, Component2, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node5) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node5);
            } catch (x3) {
              if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x3;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node5) {
          task.node = node5;
          if (typeof node5 === "object" && node5 !== null) {
            switch (node5.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node5;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node5;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x3) {
                    if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x3;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray5(node5)) {
              renderChildrenArray(request, task, node5);
              return;
            }
            var iteratorFn = getIteratorFn(node5);
            if (iteratorFn) {
              {
                validateIterable(node5, iteratorFn);
              }
              var iterator2 = iteratorFn.call(node5);
              if (iterator2) {
                var step = iterator2.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator2.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node5);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node5).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node5 === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node5, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node5 === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node5, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node5 === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i4 = 0; i4 < totalChildren; i4++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i4);
            try {
              renderNode(request, task, children[i4]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x3) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x3.then(ping, ping);
        }
        function renderNode(request, task, node5) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node5);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              spawnNewSuspendedTask(request, task, x3);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x3;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              var ping = task.ping;
              x3.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x3);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i4;
            for (i4 = 0; i4 < pingedTasks.length; i4++) {
              var task = pingedTasks[i4];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i4);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r4 = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r4 = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r4 = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r4;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id2 = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id2);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i4++;
              completedSegments.splice(0, i4);
              return false;
            }
          }
          completedSegments.splice(0, i4);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          beginWriting();
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i4;
            for (i4 = 0; i4 < clientRenderedBoundaries.length; i4++) {
              var boundary = clientRenderedBoundaries[i4];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i4++;
                clientRenderedBoundaries.splice(0, i4);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i4);
            var completedBoundaries = request.completedBoundaries;
            for (i4 = 0; i4 < completedBoundaries.length; i4++) {
              var _boundary = completedBoundaries[i4];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i4++;
                completedBoundaries.splice(0, i4);
                return;
              }
            }
            completedBoundaries.splice(0, i4);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i4 = 0; i4 < partialBoundaries.length; i4++) {
              var _boundary2 = partialBoundaries[i4];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i4++;
                partialBoundaries.splice(0, i4);
                return;
              }
            }
            partialBoundaries.splice(0, i4);
            var largeBoundaries = request.completedBoundaries;
            for (i4 = 0; i4 < largeBoundaries.length; i4++) {
              var _boundary3 = largeBoundaries[i4];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i4++;
                largeBoundaries.splice(0, i4);
                return;
              }
            }
            largeBoundaries.splice(0, i4);
          } finally {
            completeWriting(destination);
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function renderToReadableStream(children, options) {
          return new Promise(function(resolve, reject) {
            var onFatalError;
            var onAllReady;
            var allReady = new Promise(function(res, rej) {
              onAllReady = res;
              onFatalError = rej;
            });
            function onShellReady() {
              var stream = new ReadableStream(
                {
                  type: "bytes",
                  pull: function(controller) {
                    startFlowing(request, controller);
                  },
                  cancel: function(reason) {
                    abort(request);
                  }
                },
                // $FlowFixMe size() methods are not allowed on byte streams.
                {
                  highWaterMark: 0
                }
              );
              stream.allReady = allReady;
              resolve(stream);
            }
            function onShellError(error2) {
              allReady.catch(function() {
              });
              reject(error2);
            }
            var request = createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
            if (options && options.signal) {
              var signal = options.signal;
              var listener = function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              };
              signal.addEventListener("abort", listener);
            }
            startWork(request);
          });
        }
        exports.renderToReadableStream = renderToReadableStream;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.browser.js
var require_server_browser = __commonJS({
  "node_modules/react-dom/server.browser.js"(exports) {
    "use strict";
    var l3;
    var s5;
    if (false) {
      l3 = null;
      s5 = null;
    } else {
      l3 = require_react_dom_server_legacy_browser_development();
      s5 = require_react_dom_server_browser_development();
    }
    exports.version = l3.version;
    exports.renderToString = l3.renderToString;
    exports.renderToStaticMarkup = l3.renderToStaticMarkup;
    exports.renderToNodeStream = l3.renderToNodeStream;
    exports.renderToStaticNodeStream = l3.renderToStaticNodeStream;
    exports.renderToReadableStream = s5.renderToReadableStream;
  }
});

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
function clamp3(start2, value, end2) {
  return max4(start2, min4(value, end2));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart2, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart2 ? rl : lr;
      return isStart2 ? lr : rl;
    case "left":
    case "right":
      return isStart2 ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
var sides, alignments, placements, min4, max4, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap;
var init_floating_ui_utils = __esm({
  "node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"() {
    sides = ["top", "right", "bottom", "left"];
    alignments = ["start", "end"];
    placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
    min4 = Math.min;
    max4 = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = (v2) => ({
      x: v2,
      y: v2
    });
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
  }
});

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref2, placement, rtl) {
  let {
    reference,
    floating
  } = _ref2;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x3,
    y: y4,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x3,
    y: y4
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
function getBoundingRect(rects) {
  const minX = min4(...rects.map((rect) => rect.left));
  const minY = min4(...rects.map((rect) => rect.top));
  const maxX = max4(...rects.map((rect) => rect.right));
  const maxY = max4(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a5, b3) => a5.y - b3.y);
  const groups = [];
  let prevRect = null;
  for (let i4 = 0; i4 < sortedRects.length; i4++) {
    const rect = sortedRects[i4];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var computePosition, arrow, autoPlacement, flip, hide, inline, offset, shift, limitShift, size3;
var init_floating_ui_core = __esm({
  "node_modules/@floating-ui/core/dist/floating-ui.core.mjs"() {
    init_floating_ui_utils();
    init_floating_ui_utils();
    computePosition = async (reference, floating, config2) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware: middleware2 = [],
        platform: platform2
      } = config2;
      const validMiddleware = middleware2.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x3,
        y: y4
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i4 = 0; i4 < validMiddleware.length; i4++) {
        const {
          name,
          fn
        } = validMiddleware[i4];
        const {
          x: nextX,
          y: nextY,
          data,
          reset
        } = await fn({
          x: x3,
          y: y4,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x3 = nextX != null ? nextX : x3;
        y4 = nextY != null ? nextY : y4;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === "object") {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects = reset.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset.rects;
            }
            ({
              x: x3,
              y: y4
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i4 = -1;
          continue;
        }
      }
      return {
        x: x3,
        y: y4,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    arrow = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const {
          x: x3,
          y: y4,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding: padding2 = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding2);
        const coords = {
          x: x3,
          y: y4
        };
        const axis = getAlignmentAxis(placement);
        const length2 = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length2];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
        const minPadding = min4(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min4(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max6 = clientSize - arrowDimensions[length2] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
        const offset3 = clamp3(min$1, center, max6);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset3 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max6 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset3,
            centerOffset: center - offset3 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    autoPlacement = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "autoPlacement",
        options,
        async fn(state) {
          var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
          const {
            rects,
            middlewareData,
            placement,
            platform: platform2,
            elements
          } = state;
          const {
            crossAxis = false,
            alignment,
            allowedPlacements = placements,
            autoAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
          const currentPlacement = placements$1[currentIndex];
          if (currentPlacement == null) {
            return {};
          }
          const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
          if (placement !== currentPlacement) {
            return {
              reset: {
                placement: placements$1[0]
              }
            };
          }
          const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
          const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
            placement: currentPlacement,
            overflows: currentOverflows
          }];
          const nextPlacement = placements$1[currentIndex + 1];
          if (nextPlacement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          const placementsSortedByMostSpace = allOverflows.map((d3) => {
            const alignment2 = getAlignment(d3.placement);
            return [d3.placement, alignment2 && crossAxis ? (
              // Check along the mainAxis and main crossAxis side.
              d3.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
            ) : (
              // Check only the mainAxis.
              d3.overflows[0]
            ), d3.overflows];
          }).sort((a5, b3) => a5[1] - b3[1]);
          const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d3) => d3[2].slice(
            0,
            // Aligned placements should not check their opposite crossAxis
            // side.
            getAlignment(d3[0]) ? 2 : 3
          ).every((v2) => v2 <= 0));
          const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
          if (resetPlacement !== placement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: resetPlacement
              }
            };
          }
          return {};
        }
      };
    };
    flip = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides2 = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a5, b3) => a5.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a5, b3) => a5[1] - b3[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    hide = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "hide",
        options,
        async fn(state) {
          const {
            rects
          } = state;
          const {
            strategy = "referenceHidden",
            ...detectOverflowOptions
          } = evaluate(options, state);
          switch (strategy) {
            case "referenceHidden": {
              const overflow = await detectOverflow(state, {
                ...detectOverflowOptions,
                elementContext: "reference"
              });
              const offsets = getSideOffsets(overflow, rects.reference);
              return {
                data: {
                  referenceHiddenOffsets: offsets,
                  referenceHidden: isAnySideFullyClipped(offsets)
                }
              };
            }
            case "escaped": {
              const overflow = await detectOverflow(state, {
                ...detectOverflowOptions,
                altBoundary: true
              });
              const offsets = getSideOffsets(overflow, rects.floating);
              return {
                data: {
                  escapedOffsets: offsets,
                  escaped: isAnySideFullyClipped(offsets)
                }
              };
            }
            default: {
              return {};
            }
          }
        }
      };
    };
    inline = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "inline",
        options,
        async fn(state) {
          const {
            placement,
            elements,
            rects,
            platform: platform2,
            strategy
          } = state;
          const {
            padding: padding2 = 2,
            x: x3,
            y: y4
          } = evaluate(options, state);
          const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
          const clientRects = getRectsByLine(nativeClientRects);
          const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
          const paddingObject = getPaddingObject(padding2);
          function getBoundingClientRect2() {
            if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x3 != null && y4 != null) {
              return clientRects.find((rect) => x3 > rect.left - paddingObject.left && x3 < rect.right + paddingObject.right && y4 > rect.top - paddingObject.top && y4 < rect.bottom + paddingObject.bottom) || fallback;
            }
            if (clientRects.length >= 2) {
              if (getSideAxis(placement) === "y") {
                const firstRect = clientRects[0];
                const lastRect = clientRects[clientRects.length - 1];
                const isTop = getSide(placement) === "top";
                const top2 = firstRect.top;
                const bottom2 = lastRect.bottom;
                const left2 = isTop ? firstRect.left : lastRect.left;
                const right2 = isTop ? firstRect.right : lastRect.right;
                const width2 = right2 - left2;
                const height2 = bottom2 - top2;
                return {
                  top: top2,
                  bottom: bottom2,
                  left: left2,
                  right: right2,
                  width: width2,
                  height: height2,
                  x: left2,
                  y: top2
                };
              }
              const isLeftSide = getSide(placement) === "left";
              const maxRight = max4(...clientRects.map((rect) => rect.right));
              const minLeft = min4(...clientRects.map((rect) => rect.left));
              const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
              const top = measureRects[0].top;
              const bottom = measureRects[measureRects.length - 1].bottom;
              const left = minLeft;
              const right = maxRight;
              const width = right - left;
              const height = bottom - top;
              return {
                top,
                bottom,
                left,
                right,
                width,
                height,
                x: left,
                y: top
              };
            }
            return fallback;
          }
          const resetRects = await platform2.getElementRects({
            reference: {
              getBoundingClientRect: getBoundingClientRect2
            },
            floating: elements.floating,
            strategy
          });
          if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
            return {
              reset: {
                rects: resetRects
              }
            };
          }
          return {};
        }
      };
    };
    offset = function(options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x3,
            y: y4,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x3 + diffCoords.x,
            y: y4 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    shift = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const {
            x: x3,
            y: y4,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref2) => {
                let {
                  x: x4,
                  y: y5
                } = _ref2;
                return {
                  x: x4,
                  y: y5
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const coords = {
            x: x3,
            y: y4
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min6 = mainAxisCoord + overflow[minSide];
            const max6 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp3(min6, mainAxisCoord, max6);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min6 = crossAxisCoord + overflow[minSide];
            const max6 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp3(min6, crossAxisCoord, max6);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x3,
              y: limitedCoords.y - y4
            }
          };
        }
      };
    };
    limitShift = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        options,
        fn(state) {
          const {
            x: x3,
            y: y4,
            placement,
            rects,
            middlewareData
          } = state;
          const {
            offset: offset3 = 0,
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true
          } = evaluate(options, state);
          const coords = {
            x: x3,
            y: y4
          };
          const crossAxis = getSideAxis(placement);
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          const rawOffset = evaluate(offset3, state);
          const computedOffset = typeof rawOffset === "number" ? {
            mainAxis: rawOffset,
            crossAxis: 0
          } : {
            mainAxis: 0,
            crossAxis: 0,
            ...rawOffset
          };
          if (checkMainAxis) {
            const len = mainAxis === "y" ? "height" : "width";
            const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
            const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
            if (mainAxisCoord < limitMin) {
              mainAxisCoord = limitMin;
            } else if (mainAxisCoord > limitMax) {
              mainAxisCoord = limitMax;
            }
          }
          if (checkCrossAxis) {
            var _middlewareData$offse, _middlewareData$offse2;
            const len = mainAxis === "y" ? "width" : "height";
            const isOriginSide = ["top", "left"].includes(getSide(placement));
            const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
            const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
            if (crossAxisCoord < limitMin) {
              crossAxisCoord = limitMin;
            } else if (crossAxisCoord > limitMax) {
              crossAxisCoord = limitMax;
            }
          }
          return {
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          };
        }
      };
    };
    size3 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(state) {
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply: apply2 = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const overflowAvailableHeight = height - overflow[heightSide];
          const overflowAvailableWidth = width - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            const maximumClippingWidth = width - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min4(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min4(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max4(overflow.left, 0);
            const xMax = max4(overflow.right, 0);
            const yMin = max4(overflow.top, 0);
            const yMax = max4(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max4(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max4(overflow.top, overflow.bottom));
            }
          }
          await apply2({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
  }
});

// node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node5) {
  if (isNode3(node5)) {
    return (node5.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node5) {
  var _node$ownerDocument;
  return (node5 == null ? void 0 : (_node$ownerDocument = node5.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node5) {
  var _ref2;
  return (_ref2 = (isNode3(node5) ? node5.ownerDocument : node5.document) || window.document) == null ? void 0 : _ref2.documentElement;
}
function isNode3(value) {
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode2(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node5) {
  return ["html", "body", "#document"].includes(getNodeName(node5));
}
function getComputedStyle2(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode2(node5) {
  if (getNodeName(node5) === "html") {
    return node5;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node5.assignedSlot || // DOM Element detected.
    node5.parentNode || // ShadowRoot detected.
    isShadowRoot(node5) && node5.host || // Fallback.
    getDocumentElement(node5)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node5) {
  const parentNode = getParentNode2(node5);
  if (isLastTraversableNode(parentNode)) {
    return node5.ownerDocument ? node5.ownerDocument.body : node5.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node5, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node5);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node5.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
var init_floating_ui_utils_dom = __esm({
  "node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs"() {
  }
});

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x3 = ($2 ? round(rect.width) : rect.width) / width;
  let y4 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x3 || !Number.isFinite(x3)) {
    x3 = 1;
  }
  if (!y4 || !Number.isFinite(y4)) {
    y4 = 1;
  }
  return {
    x: x3,
    y: y4
  };
}
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed2, floatingOffsetParent) {
  if (isFixed2 === void 0) {
    isFixed2 = false;
  }
  if (!floatingOffsetParent || isFixed2 && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed2;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x3 = (clientRect.left + visualOffsets.x) / scale.x;
  let y4 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x3 *= iframeScale.x;
      y4 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x3 += left;
      y4 += top;
      currentIFrame = getWindow2(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x3,
    y: y4
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref2) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref2;
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max4(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max4(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x3 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y4 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x3 += max4(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x3 = 0;
  let y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x3 = left * scale.x;
  const y4 = top * scale.y;
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache3) {
  const cachedResult = cache3.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache3.set(element, result);
  return result;
}
function getClippingRect(_ref2) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref2;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max4(rect.top, accRect.top);
    accRect.right = min4(rect.right, accRect.right);
    accRect.bottom = min4(rect.bottom, accRect.bottom);
    accRect.left = max4(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed2 = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed2, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed2, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window3 = getWindow2(element);
  if (!isHTMLElement2(element)) {
    return window3;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window3;
  }
  return offsetParent || getContainingBlock(element) || window3;
}
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip2, threshold) {
    if (skip2 === void 0) {
      skip2 = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip2) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max4(0, min4(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e5) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame: animationFrame2 = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref2) => {
      let [firstEntry] = _ref2;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame2) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame2 ? getBoundingClientRect(reference) : null;
  if (animationFrame2) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame2) {
      cancelAnimationFrame(frameId);
    }
  };
}
var noOffsets, getElementRects, platform, computePosition2;
var init_floating_ui_dom = __esm({
  "node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"() {
    init_floating_ui_core();
    init_floating_ui_core();
    init_floating_ui_utils();
    init_floating_ui_utils_dom();
    init_floating_ui_utils_dom();
    noOffsets = createCoords(0);
    getElementRects = async function(_ref2) {
      let {
        reference,
        floating,
        strategy
      } = _ref2;
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      return {
        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
        floating: {
          x: 0,
          y: 0,
          ...await getDimensionsFn(floating)
        }
      };
    };
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement: isElement2,
      isRTL
    };
    computePosition2 = (reference, floating, options) => {
      const cache3 = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache3
      };
      return computePosition(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
  }
});

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var floating_ui_react_dom_esm_exports = {};
__export(floating_ui_react_dom_esm_exports, {
  arrow: () => arrow2,
  autoPlacement: () => autoPlacement,
  autoUpdate: () => autoUpdate,
  computePosition: () => computePosition2,
  detectOverflow: () => detectOverflow,
  flip: () => flip,
  getOverflowAncestors: () => getOverflowAncestors,
  hide: () => hide,
  inline: () => inline,
  limitShift: () => limitShift,
  offset: () => offset,
  platform: () => platform,
  shift: () => shift,
  size: () => size3,
  useFloating: () => useFloating
});
function deepEqual(a5, b3) {
  if (a5 === b3) {
    return true;
  }
  if (typeof a5 !== typeof b3) {
    return false;
  }
  if (typeof a5 === "function" && a5.toString() === b3.toString()) {
    return true;
  }
  let length2, i4, keys2;
  if (a5 && b3 && typeof a5 == "object") {
    if (Array.isArray(a5)) {
      length2 = a5.length;
      if (length2 != b3.length)
        return false;
      for (i4 = length2; i4-- !== 0; ) {
        if (!deepEqual(a5[i4], b3[i4])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a5);
    length2 = keys2.length;
    if (length2 !== Object.keys(b3).length) {
      return false;
    }
    for (i4 = length2; i4-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b3, keys2[i4])) {
        return false;
      }
    }
    for (i4 = length2; i4-- !== 0; ) {
      const key2 = keys2[i4];
      if (key2 === "_owner" && a5.$$typeof) {
        continue;
      }
      if (!deepEqual(a5[key2], b3[key2])) {
        return false;
      }
    }
    return true;
  }
  return a5 !== a5 && b3 !== b3;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React16.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React16.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React16.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React16.useState(null);
  const [_floating, _setFloating] = React16.useState(null);
  const setReference = React16.useCallback((node5) => {
    if (node5 != referenceRef.current) {
      referenceRef.current = node5;
      _setReference(node5);
    }
  }, [_setReference]);
  const setFloating = React16.useCallback((node5) => {
    if (node5 !== floatingRef.current) {
      floatingRef.current = node5;
      _setFloating(node5);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React16.useRef(null);
  const floatingRef = React16.useRef(null);
  const dataRef = React16.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React16.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React16.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React16.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React16.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React16.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x3 = roundByDPR(elements.floating, data.x);
    const y4 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x3 + "px, " + y4 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x3,
      top: y4
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React16.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var React16, import_react25, ReactDOM, arrow2, index;
var init_floating_ui_react_dom_esm = __esm({
  "node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js"() {
    init_floating_ui_dom();
    init_floating_ui_dom();
    React16 = __toESM(require_react());
    import_react25 = __toESM(require_react());
    ReactDOM = __toESM(require_react_dom());
    arrow2 = (options) => {
      const {
        element,
        padding: padding2
      } = options;
      function isRef(value) {
        return {}.hasOwnProperty.call(value, "current");
      }
      return {
        name: "arrow",
        options,
        fn(args) {
          if (element && isRef(element)) {
            if (element.current != null) {
              return arrow({
                element: element.current,
                padding: padding2
              }).fn(args);
            }
            return {};
          } else if (element) {
            return arrow({
              element,
              padding: padding2
            }).fn(args);
          }
          return {};
        }
      };
    };
    index = typeof document !== "undefined" ? import_react25.useLayoutEffect : import_react25.useEffect;
  }
});

// node_modules/arrify/index.js
var require_arrify = __commonJS({
  "node_modules/arrify/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(val) {
      if (val === null || val === void 0) {
        return [];
      }
      return Array.isArray(val) ? val : [val];
    };
  }
});

// node_modules/lodash/map.js
var require_map2 = __commonJS({
  "node_modules/lodash/map.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray5 = require_isArray();
    function map3(collection, iteratee) {
      var func2 = isArray5(collection) ? arrayMap : baseMap;
      return func2(collection, baseIteratee(iteratee, 3));
    }
    module2.exports = map3;
  }
});

// node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/lodash/flatMap.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    var map3 = require_map2();
    function flatMap2(collection, iteratee) {
      return baseFlatten(map3(collection, iteratee), 1);
    }
    module2.exports = flatMap2;
  }
});

// node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/lodash/negate.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module2.exports = negate;
  }
});

// node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "node_modules/lodash/pickBy.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy2(object2, predicate) {
      if (object2 == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object2), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object2, props, function(value, path3) {
        return predicate(value, path3[0]);
      });
    }
    module2.exports = pickBy2;
  }
});

// node_modules/lodash/omitBy.js
var require_omitBy = __commonJS({
  "node_modules/lodash/omitBy.js"(exports, module2) {
    var baseIteratee = require_baseIteratee();
    var negate = require_negate();
    var pickBy2 = require_pickBy();
    function omitBy(object2, predicate) {
      return pickBy2(object2, negate(baseIteratee(predicate)));
    }
    module2.exports = omitBy;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports, module2) {
    function isUndefined2(value) {
      return value === void 0;
    }
    module2.exports = isUndefined2;
  }
});

// node_modules/lodash/toPath.js
var require_toPath = __commonJS({
  "node_modules/lodash/toPath.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var copyArray = require_copyArray();
    var isArray5 = require_isArray();
    var isSymbol = require_isSymbol();
    var stringToPath = require_stringToPath();
    var toKey = require_toKey();
    var toString2 = require_toString();
    function toPath(value) {
      if (isArray5(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
    }
    module2.exports = toPath;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O3) {
      return O3.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has2(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has2(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray5(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf2(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect2(value, from4, noIndent) {
        if (from4) {
          seen = $arrSlice.call(seen);
          seen.push(from4);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has2(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect2);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement4(obj)) {
        var s5 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i4 = 0; i4 < attrs.length; i4++) {
          s5 += " " + attrs[i4].name + "=" + wrapQuotes(quote(attrs[i4].value), "double", opts);
        }
        s5 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s5 += "...";
        }
        s5 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s5;
      }
      if (isArray5(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect2);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect2);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap2(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key2) {
            mapParts.push(inspect2(key2, obj, true) + " => " + inspect2(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet2(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect2(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect2(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect2(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect2(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate3(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect2);
        var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s5, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s5 + quoteChar;
    }
    function quote(s5) {
      return $replace.call(String(s5), /"/g, "&quot;");
    }
    function isArray5(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate3(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has2(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m4 = $match.call(functionToString.call(f3), /^function\s*([\w$]+)/);
      if (m4) {
        return m4[1];
      }
      return null;
    }
    function indexOf2(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i4 = 0, l3 = xs.length; i4 < l3; i4++) {
        if (xs[i4] === x3) {
          return i4;
        }
      }
      return -1;
    }
    function isMap2(x3) {
      if (!mapSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize.call(x3);
        try {
          setSize.call(x3);
        } catch (s5) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e5) {
      }
      return false;
    }
    function isWeakMap(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s5) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e5) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isSet2(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize.call(x3);
        } catch (m4) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e5) {
      }
      return false;
    }
    function isWeakSet(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s5) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e5) {
      }
      return false;
    }
    function isElement4(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s5 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s5, "single", opts);
    }
    function lowbyte(c4) {
      var n4 = c4.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n4];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n4 < 16 ? "0" : "") + $toUpperCase.call(n4.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size4, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size4 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i4 = 0; i4 < xs.length; i4++) {
        if (indexOf2(xs[i4], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect2) {
      var isArr = isArray5(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i4 = 0; i4 < obj.length; i4++) {
          xs[i4] = has2(obj, i4) ? inspect2(obj[i4], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k3 = 0; k3 < syms.length; k3++) {
          symMap["$" + syms[k3]] = syms[k3];
        }
      }
      for (var key2 in obj) {
        if (!has2(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect2(key2, obj) + ": " + inspect2(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect2(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/humanize-list/index.js
var require_humanize_list = __commonJS({
  "node_modules/humanize-list/index.js"(exports, module2) {
    "use strict";
    module2.exports = function humanizeList(list, options) {
      if (!Array.isArray(list)) {
        throw new TypeError("humanize-list expected an array");
      }
      options = options || {};
      options.conjunction = options.conjunction || "and";
      var listLength = list.length;
      if (listLength === 1) {
        return list[0];
      }
      if (options.skipConjunction) {
        return list.join(", ");
      }
      var humanizedList = "";
      for (var i4 = 0; i4 < listLength; i4++) {
        if (i4 === listLength - 1) {
          if (options.oxfordComma) {
            humanizedList += ",";
          }
          humanizedList += " " + options.conjunction + " ";
        } else if (i4 !== 0) {
          humanizedList += ", ";
        }
        humanizedList += list[i4];
      }
      return humanizedList;
    };
  }
});

// node_modules/leven/index.js
var require_leven = __commonJS({
  "node_modules/leven/index.js"(exports, module2) {
    "use strict";
    var array = [];
    var charCodeCache = [];
    var leven = (left, right) => {
      if (left === right) {
        return 0;
      }
      const swap = left;
      if (left.length > right.length) {
        left = right;
        right = swap;
      }
      let leftLength = left.length;
      let rightLength = right.length;
      while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
        leftLength--;
        rightLength--;
      }
      let start2 = 0;
      while (start2 < leftLength && left.charCodeAt(start2) === right.charCodeAt(start2)) {
        start2++;
      }
      leftLength -= start2;
      rightLength -= start2;
      if (leftLength === 0) {
        return rightLength;
      }
      let bCharCode;
      let result;
      let temp;
      let temp2;
      let i4 = 0;
      let j2 = 0;
      while (i4 < leftLength) {
        charCodeCache[i4] = left.charCodeAt(start2 + i4);
        array[i4] = ++i4;
      }
      while (j2 < rightLength) {
        bCharCode = right.charCodeAt(start2 + j2);
        temp = j2++;
        result = j2;
        for (i4 = 0; i4 < leftLength; i4++) {
          temp2 = bCharCode === charCodeCache[i4] ? temp : temp + 1;
          temp = array[i4];
          result = array[i4] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
        }
      }
      return result;
    };
    module2.exports = leven;
    module2.exports.default = leven;
  }
});

// node_modules/@sanity/portable-text-editor/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/@sanity/portable-text-editor/node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env2).forEach(function(key2) {
        createDebug[key2] = env2[key2];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        var hash2 = 0;
        for (var i4 = 0; i4 < namespace.length; i4++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i4);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        var prevTime;
        function debug3() {
          if (!debug3.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug3;
          var curr = Number(/* @__PURE__ */ new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index3 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match5, format4) {
            if (match5 === "%%") {
              return match5;
            }
            index3++;
            var formatter = createDebug.formatters[format4];
            if (typeof formatter === "function") {
              var val = args[index3];
              match5 = formatter.call(self2, val);
              args.splice(index3, 1);
              index3--;
            }
            return match5;
          });
          createDebug.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.enabled = createDebug.enabled(namespace);
        debug3.useColors = createDebug.useColors();
        debug3.color = selectColor(namespace);
        debug3.destroy = destroy;
        debug3.extend = extend2;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        createDebug.instances.push(debug3);
        return debug3;
      }
      function destroy() {
        var index3 = createDebug.instances.indexOf(this);
        if (index3 !== -1) {
          createDebug.instances.splice(index3, 1);
          return true;
        }
        return false;
      }
      function extend2(namespace, delimiter2) {
        return createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i4;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i4 = 0; i4 < createDebug.instances.length; i4++) {
          var instance = createDebug.instances[i4];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i4;
        var len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/@sanity/portable-text-editor/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/@sanity/portable-text-editor/node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    function _typeof4(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof4 = function _typeof5(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof4 = function _typeof5(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof4(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      var index3 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match5) {
        if (match5 === "%%") {
          return;
        }
        index3++;
        if (match5 === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c4);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof4(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r4;
      try {
        r4 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r4 && typeof process !== "undefined" && "env" in process) {
        r4 = process.env.DEBUG;
      }
      return r4;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports);
    var formatters3 = module2.exports.formatters;
    formatters3.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject2(o4) {
  return Object.prototype.toString.call(o4) === "[object Object]";
}
function isPlainObject(o4) {
  var ctor, prot;
  if (isObject2(o4) === false)
    return false;
  ctor = o4.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
var init_is_plain_object = __esm({
  "node_modules/is-plain-object/dist/is-plain-object.mjs"() {
  }
});

// node_modules/immer/dist/immer.mjs
function die(error, ...args) {
  if (true) {
    const e5 = errors[error];
    const msg2 = typeof e5 === "function" ? e5.apply(null, args) : e5;
    throw new Error(`[Immer] ${msg2}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  if (!value)
    return false;
  return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
}
function isPlainObject2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto2 = getPrototypeOf2(value);
  if (proto2 === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Object.entries(obj).forEach(([key2, value]) => {
      iter(key2, value, obj);
    });
  } else {
    obj.forEach((entry, index3) => iter(index3, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set2(thing, propOrOldValue, value) {
  const t4 = getArchtype(thing);
  if (t4 === 2)
    thing.set(propOrOldValue, value);
  else if (t4 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x3, y4) {
  if (x3 === y4) {
    return x3 !== 0 || 1 / x3 === 1 / y4;
  } else {
    return x3 !== x3 && y4 !== y4;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  if (!strict && isPlainObject2(base)) {
    if (!getPrototypeOf2(base)) {
      const obj = /* @__PURE__ */ Object.create(null);
      return Object.assign(obj, base);
    }
    return { ...base };
  }
  const descriptors = Object.getOwnPropertyDescriptors(base);
  delete descriptors[DRAFT_STATE];
  let keys2 = Reflect.ownKeys(descriptors);
  for (let i4 = 0; i4 < keys2.length; i4++) {
    const key2 = keys2[i4];
    const desc = descriptors[key2];
    if (desc.writable === false) {
      desc.writable = true;
      desc.configurable = true;
    }
    if (desc.get || desc.set)
      descriptors[key2] = {
        configurable: true,
        writable: true,
        // could live with !!desc.set as well here...
        enumerable: desc.enumerable,
        value: base[key2]
      };
  }
  return Object.create(getPrototypeOf2(base), descriptors);
}
function freeze2(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    each(obj, (_key, value) => freeze2(value, true), true);
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize3(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize3(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize3(rootScope, value, path3) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key2, childValue) => finalizeProperty(rootScope, state, value, key2, childValue, path3),
      true
      // See #590, don't recurse into non-enumerable of non drafted objects
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key2, childValue) => finalizeProperty(rootScope, state, result, key2, childValue, path3, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path3 && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path3,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path3 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize3(rootScope, childValue, path3);
    set2(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize3(rootScope, childValue);
    if (!parentState || !parentState.scope_.parent_)
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze2(value, deep);
  }
}
function createProxyProxy(base, parent3) {
  const isArray5 = Array.isArray(base);
  const state = {
    type_: isArray5 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent3 ? parent3.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent3,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray5) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
function peek2(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto2 = getPrototypeOf2(source);
  while (proto2) {
    const desc = Object.getOwnPropertyDescriptor(proto2, prop);
    if (desc)
      return desc;
    proto2 = getPrototypeOf2(proto2);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
function createProxy(value, parent3) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent3) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent3) : createProxyProxy(value, parent3);
  const scope = parent3 ? parent3.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy2;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy2 = shallowCopy(value, true);
  }
  each(copy2, (key2, childValue) => {
    set2(copy2, key2, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy2;
}
var NOTHING, DRAFTABLE, DRAFT_STATE, errors, getPrototypeOf2, objectCtorString, plugins, currentScope, objectTraps, arrayTraps, Immer2, immer, produce, produceWithPatches, setAutoFreeze, setUseStrictShallowCopy, applyPatches, createDraft, finishDraft;
var init_immer = __esm({
  "node_modules/immer/dist/immer.mjs"() {
    NOTHING = Symbol.for("immer-nothing");
    DRAFTABLE = Symbol.for("immer-draftable");
    DRAFT_STATE = Symbol.for("immer-state");
    errors = true ? [
      // All error codes, starting by 0:
      function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
      },
      function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
      },
      "This object has been frozen and should not be mutated",
      function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      "Immer forbids circular references",
      "The first or second argument to `produce` must be a function",
      "The third argument to `produce` must be a function or undefined",
      "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      "First argument to `finishDraft` must be a draft returned by `createDraft`",
      function(thing) {
        return `'current' expects a draft, got: ${thing}`;
      },
      "Object.defineProperty() cannot be used on an Immer draft",
      "Object.setPrototypeOf() cannot be used on an Immer draft",
      "Immer only supports deleting array indices",
      "Immer only supports setting array indices and the 'length' property",
      function(thing) {
        return `'original' expects a draft, got: ${thing}`;
      }
      // Note: if more errors are added, the errorOffset in Patches.ts should be increased
      // See Patches.ts for additional errors
    ] : [];
    getPrototypeOf2 = Object.getPrototypeOf;
    objectCtorString = Object.prototype.constructor.toString();
    plugins = {};
    objectTraps = {
      get(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek2(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop) {
        return prop in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc == null ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek2(latest(state), prop);
          const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty(state, prop) {
        if (peek2(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf2(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    arrayTraps = {};
    each(objectTraps, (key2, fn) => {
      arrayTraps[key2] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    Immer2 = class {
      constructor(config2) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base, recipe, patchListener) => {
          if (typeof base === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base;
            const self2 = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base)) {
            const scope = enterScope(this);
            const proxy = createProxy(base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze2(result, true);
            if (patchListener) {
              const p2 = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
              patchListener(p2, ip);
            }
            return result;
          } else
            die(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (typeof base === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p2, ip) => {
            patches = p2;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
          this.setAutoFreeze(config2.autoFreeze);
        if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
          this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
      }
      createDraft(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      applyPatches(base, patches) {
        let i4;
        for (i4 = patches.length - 1; i4 >= 0; i4--) {
          const patch = patches[i4];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i4 > -1) {
          patches = patches.slice(i4 + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    immer = new Immer2();
    produce = immer.produce;
    produceWithPatches = immer.produceWithPatches.bind(
      immer
    );
    setAutoFreeze = immer.setAutoFreeze.bind(immer);
    setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
    applyPatches = immer.applyPatches.bind(immer);
    createDraft = immer.createDraft.bind(immer);
    finishDraft = immer.finishDraft.bind(immer);
  }
});

// node_modules/slate/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  Editor: () => Editor,
  Element: () => Element2,
  Location: () => Location,
  Node: () => Node2,
  Operation: () => Operation,
  Path: () => Path,
  PathRef: () => PathRef,
  Point: () => Point,
  PointRef: () => PointRef,
  Range: () => Range,
  RangeRef: () => RangeRef,
  Scrubber: () => Scrubber,
  Span: () => Span,
  Text: () => Text,
  Transforms: () => Transforms,
  above: () => above,
  addMark: () => addMark,
  after: () => after,
  apply: () => apply,
  before: () => before,
  collapse: () => collapse,
  createEditor: () => createEditor,
  deleteBackward: () => deleteBackward,
  deleteForward: () => deleteForward,
  deleteFragment: () => deleteFragment,
  deleteText: () => deleteText,
  deselect: () => deselect,
  edges: () => edges,
  elementReadOnly: () => elementReadOnly,
  end: () => end,
  first: () => first2,
  fragment: () => fragment,
  getDirtyPaths: () => getDirtyPaths,
  getFragment: () => getFragment,
  getVoid: () => getVoid,
  hasBlocks: () => hasBlocks,
  hasInlines: () => hasInlines,
  hasPath: () => hasPath2,
  hasTexts: () => hasTexts,
  insertBreak: () => insertBreak,
  insertFragment: () => insertFragment,
  insertNode: () => insertNode,
  insertNodes: () => insertNodes,
  insertSoftBreak: () => insertSoftBreak,
  insertText: () => insertText,
  isBlock: () => isBlock,
  isEdge: () => isEdge,
  isEditor: () => isEditor,
  isEmpty: () => isEmpty2,
  isEnd: () => isEnd,
  isNormalizing: () => isNormalizing,
  isStart: () => isStart,
  last: () => last4,
  leaf: () => leaf,
  levels: () => levels,
  liftNodes: () => liftNodes,
  marks: () => marks,
  mergeNodes: () => mergeNodes,
  move: () => move,
  moveNodes: () => moveNodes,
  next: () => next2,
  node: () => node3,
  nodes: () => nodes,
  normalize: () => normalize2,
  normalizeNode: () => normalizeNode,
  parent: () => parent,
  path: () => path,
  pathRef: () => pathRef,
  pathRefs: () => pathRefs,
  point: () => point,
  pointRef: () => pointRef,
  pointRefs: () => pointRefs,
  positions: () => positions,
  previous: () => previous,
  range: () => range2,
  rangeRef: () => rangeRef,
  rangeRefs: () => rangeRefs,
  removeMark: () => removeMark,
  removeNodes: () => removeNodes,
  select: () => select2,
  setNodes: () => setNodes,
  setNormalizing: () => setNormalizing,
  setPoint: () => setPoint,
  setSelection: () => setSelection,
  shouldNormalize: () => shouldNormalize,
  splitNodes: () => splitNodes,
  start: () => start,
  string: () => string2,
  unhangRange: () => unhangRange,
  unsetNodes: () => unsetNodes,
  unwrapNodes: () => unwrapNodes,
  withoutNormalizing: () => withoutNormalizing,
  wrapNodes: () => wrapNodes
});
function _typeof2(o4) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof2(o4);
}
function _toPrimitive2(input, hint) {
  if (_typeof2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key2 = _toPrimitive2(arg, "string");
  return _typeof2(key2) === "symbol" ? key2 : String(key2);
}
function _defineProperty2(obj, key2, value) {
  key2 = _toPropertyKey2(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys$e(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$e(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$e(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$e(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key2 = sourceKeys[i4];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key2, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key2 = sourceSymbolKeys[i4];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function ownKeys$d(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$d(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$d(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$d(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$c(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$c(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$c(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$c(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$b(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$b(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$b(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$b(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$a(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$a(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$a(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$a(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function intersects(x3, y4) {
  return (x3 & y4) !== 0;
}
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r4) => intersects(left, r4[0]) && intersects(right, r4[1])) === -1;
}
function ownKeys$9(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$9(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$9(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$9(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$8(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$8(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$8(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$8(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$7(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$7(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$7(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$7(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$6(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$6(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$6(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$6(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$5(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$5(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$5(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$5(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$4(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$4(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$4(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$4(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$3(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$3(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$3(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$3(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function levels(editor) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: at2 = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match5
    } = options;
    if (match5 == null) {
      match5 = () => true;
    }
    if (!at2) {
      return;
    }
    var levels2 = [];
    var path3 = Editor.path(editor, at2);
    for (var [n4, p2] of Node2.levels(editor, path3)) {
      if (!match5(n4, p2)) {
        continue;
      }
      levels2.push([n4, p2]);
      if (!voids && Element2.isElement(n4) && Editor.isVoid(editor, n4)) {
        break;
      }
    }
    if (reverse) {
      levels2.reverse();
    }
    yield* levels2;
  }();
}
function nodes(editor) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: at2 = editor.selection,
      mode = "all",
      universal = false,
      reverse = false,
      voids = false,
      ignoreNonSelectable = false
    } = options;
    var {
      match: match5
    } = options;
    if (!match5) {
      match5 = () => true;
    }
    if (!at2) {
      return;
    }
    var from4;
    var to2;
    if (Span.isSpan(at2)) {
      from4 = at2[0];
      to2 = at2[1];
    } else {
      var first3 = Editor.path(editor, at2, {
        edge: "start"
      });
      var last5 = Editor.path(editor, at2, {
        edge: "end"
      });
      from4 = reverse ? last5 : first3;
      to2 = reverse ? first3 : last5;
    }
    var nodeEntries = Node2.nodes(editor, {
      reverse,
      from: from4,
      to: to2,
      pass: (_ref2) => {
        var [node6] = _ref2;
        if (!Element2.isElement(node6))
          return false;
        if (!voids && (Editor.isVoid(editor, node6) || Editor.isElementReadOnly(editor, node6)))
          return true;
        if (ignoreNonSelectable && !Editor.isSelectable(editor, node6))
          return true;
        return false;
      }
    });
    var matches = [];
    var hit;
    for (var [node5, path3] of nodeEntries) {
      if (ignoreNonSelectable && Element2.isElement(node5) && !Editor.isSelectable(editor, node5)) {
        continue;
      }
      var isLower = hit && Path.compare(path3, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match5(node5, path3)) {
        if (universal && !isLower && Text.isText(node5)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node5, path3];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node5, path3];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node5, path3];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  }();
}
function positions(editor) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: at2 = editor.selection,
      unit = "offset",
      reverse = false,
      voids = false,
      ignoreNonSelectable = false
    } = options;
    if (!at2) {
      return;
    }
    var range3 = Editor.range(editor, at2);
    var [start2, end2] = Range.edges(range3);
    var first3 = reverse ? end2 : start2;
    var isNewBlock = false;
    var blockText = "";
    var distance = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node5, path3] of Editor.nodes(editor, {
      at: at2,
      reverse,
      voids,
      ignoreNonSelectable
    })) {
      if (Element2.isElement(node5)) {
        if (!voids && (editor.isVoid(node5) || editor.isElementReadOnly(node5))) {
          yield Editor.start(editor, path3);
          continue;
        }
        if (editor.isInline(node5))
          continue;
        if (Editor.hasInlines(editor, node5)) {
          var e5 = Path.isAncestor(path3, end2.path) ? end2 : Editor.end(editor, path3);
          var s5 = Path.isAncestor(path3, start2.path) ? start2 : Editor.start(editor, path3);
          blockText = Editor.string(editor, {
            anchor: s5,
            focus: e5
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text.isText(node5)) {
        var isFirst = Path.equals(path3, first3.path);
        if (isFirst) {
          leafTextRemaining = reverse ? first3.offset : node5.text.length - first3.offset;
          leafTextOffset = first3.offset;
        } else {
          leafTextRemaining = node5.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path: path3,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance === 0) {
            if (blockText === "")
              break;
            distance = calcDistance(blockText, unit, reverse);
            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
          }
          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance;
          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          }
          distance = 0;
          yield {
            path: path3,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text, unit2, reverse2) {
      if (unit2 === "character") {
        return getCharacterDistance(text, reverse2);
      } else if (unit2 === "word") {
        return getWordDistance(text, reverse2);
      } else if (unit2 === "line" || unit2 === "block") {
        return text.length;
      }
      return 1;
    }
  }();
}
function ownKeys$2(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$2(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$2(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$2(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$1(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$1(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$1(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$1(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys(Object(t4), true).forEach(function(r5) {
      _defineProperty2(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
var PathRef, PointRef, RangeRef, DIRTY_PATHS, DIRTY_PATH_KEYS, FLUSHING, NORMALIZING, PATH_REFS, POINT_REFS, RANGE_REFS, Path, applyToDraft, GeneralTransforms, NodeTransforms, SelectionTransforms, isDeepEqual, _excluded$4, Range, isElement3, Element2, _excluded$3, _excluded2$3, IS_NODE_LIST_CACHE, Node2, Operation, IS_EDITOR_CACHE, isEditor, Editor, Location, Span, Point, _scrubber, Scrubber, _excluded$2, _excluded2$2, Text, getDefaultInsertLocation, matchPath, getCharacterDistance, SPACE, PUNCTUATION, CHAMELEON, getWordDistance, splitByCharacterDistance, isWordCharacter, codepointsIteratorRTL, isHighSurrogate, isLowSurrogate, CodepointType, reExtend, rePrepend, reSpacingMark, reL, reV, reT, reLV, reLVT, reExtPict, getCodepointType, NonBoundaryPairs, endingEmojiZWJ, endsWithEmojiZWJ, endingRIs, endsWithOddNumberOfRIs, TextTransforms, Transforms, apply, getDirtyPaths, getFragment, normalizeNode, shouldNormalize, above, addMark, after, before, deleteBackward, deleteForward, deleteFragment, edges, elementReadOnly, end, first2, fragment, getVoid, hasBlocks, hasInlines, hasPath2, hasTexts, insertBreak, insertNode, insertSoftBreak, insertText, isBlock, isEdge, isEmpty2, isEnd, isNormalizing, isStart, last4, leaf, _excluded$1, _excluded2$1, marks, next2, node3, normalize2, parent, pathRef, pathRefs, path, pointRef, pointRefs, point, previous, rangeRef, rangeRefs, range2, removeMark, setNormalizing, start, string2, unhangRange, withoutNormalizing, deleteText, insertFragment, collapse, deselect, move, select2, setPoint, setSelection, insertNodes, liftNodes, _excluded, _excluded2, hasSingleChildNest, mergeNodes, moveNodes, removeNodes, setNodes, deleteRange, splitNodes, unsetNodes, unwrapNodes, wrapNodes, createEditor;
var init_index_es2 = __esm({
  "node_modules/slate/dist/index.es.js"() {
    init_is_plain_object();
    init_immer();
    PathRef = {
      transform(ref, op) {
        var {
          current: current2,
          affinity
        } = ref;
        if (current2 == null) {
          return;
        }
        var path3 = Path.transform(current2, op, {
          affinity
        });
        ref.current = path3;
        if (path3 == null) {
          ref.unref();
        }
      }
    };
    PointRef = {
      transform(ref, op) {
        var {
          current: current2,
          affinity
        } = ref;
        if (current2 == null) {
          return;
        }
        var point3 = Point.transform(current2, op, {
          affinity
        });
        ref.current = point3;
        if (point3 == null) {
          ref.unref();
        }
      }
    };
    RangeRef = {
      transform(ref, op) {
        var {
          current: current2,
          affinity
        } = ref;
        if (current2 == null) {
          return;
        }
        var path3 = Range.transform(current2, op, {
          affinity
        });
        ref.current = path3;
        if (path3 == null) {
          ref.unref();
        }
      }
    };
    DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
    DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();
    FLUSHING = /* @__PURE__ */ new WeakMap();
    NORMALIZING = /* @__PURE__ */ new WeakMap();
    PATH_REFS = /* @__PURE__ */ new WeakMap();
    POINT_REFS = /* @__PURE__ */ new WeakMap();
    RANGE_REFS = /* @__PURE__ */ new WeakMap();
    Path = {
      ancestors(path3) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          reverse = false
        } = options;
        var paths = Path.levels(path3, options);
        if (reverse) {
          paths = paths.slice(1);
        } else {
          paths = paths.slice(0, -1);
        }
        return paths;
      },
      common(path3, another) {
        var common = [];
        for (var i4 = 0; i4 < path3.length && i4 < another.length; i4++) {
          var av = path3[i4];
          var bv = another[i4];
          if (av !== bv) {
            break;
          }
          common.push(av);
        }
        return common;
      },
      compare(path3, another) {
        var min6 = Math.min(path3.length, another.length);
        for (var i4 = 0; i4 < min6; i4++) {
          if (path3[i4] < another[i4])
            return -1;
          if (path3[i4] > another[i4])
            return 1;
        }
        return 0;
      },
      endsAfter(path3, another) {
        var i4 = path3.length - 1;
        var as2 = path3.slice(0, i4);
        var bs = another.slice(0, i4);
        var av = path3[i4];
        var bv = another[i4];
        return Path.equals(as2, bs) && av > bv;
      },
      endsAt(path3, another) {
        var i4 = path3.length;
        var as2 = path3.slice(0, i4);
        var bs = another.slice(0, i4);
        return Path.equals(as2, bs);
      },
      endsBefore(path3, another) {
        var i4 = path3.length - 1;
        var as2 = path3.slice(0, i4);
        var bs = another.slice(0, i4);
        var av = path3[i4];
        var bv = another[i4];
        return Path.equals(as2, bs) && av < bv;
      },
      equals(path3, another) {
        return path3.length === another.length && path3.every((n4, i4) => n4 === another[i4]);
      },
      hasPrevious(path3) {
        return path3[path3.length - 1] > 0;
      },
      isAfter(path3, another) {
        return Path.compare(path3, another) === 1;
      },
      isAncestor(path3, another) {
        return path3.length < another.length && Path.compare(path3, another) === 0;
      },
      isBefore(path3, another) {
        return Path.compare(path3, another) === -1;
      },
      isChild(path3, another) {
        return path3.length === another.length + 1 && Path.compare(path3, another) === 0;
      },
      isCommon(path3, another) {
        return path3.length <= another.length && Path.compare(path3, another) === 0;
      },
      isDescendant(path3, another) {
        return path3.length > another.length && Path.compare(path3, another) === 0;
      },
      isParent(path3, another) {
        return path3.length + 1 === another.length && Path.compare(path3, another) === 0;
      },
      isPath(value) {
        return Array.isArray(value) && (value.length === 0 || typeof value[0] === "number");
      },
      isSibling(path3, another) {
        if (path3.length !== another.length) {
          return false;
        }
        var as2 = path3.slice(0, -1);
        var bs = another.slice(0, -1);
        var al = path3[path3.length - 1];
        var bl = another[another.length - 1];
        return al !== bl && Path.equals(as2, bs);
      },
      levels(path3) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          reverse = false
        } = options;
        var list = [];
        for (var i4 = 0; i4 <= path3.length; i4++) {
          list.push(path3.slice(0, i4));
        }
        if (reverse) {
          list.reverse();
        }
        return list;
      },
      next(path3) {
        if (path3.length === 0) {
          throw new Error("Cannot get the next path of a root path [".concat(path3, "], because it has no next index."));
        }
        var last5 = path3[path3.length - 1];
        return path3.slice(0, -1).concat(last5 + 1);
      },
      operationCanTransformPath(operation) {
        switch (operation.type) {
          case "insert_node":
          case "remove_node":
          case "merge_node":
          case "split_node":
          case "move_node":
            return true;
          default:
            return false;
        }
      },
      parent(path3) {
        if (path3.length === 0) {
          throw new Error("Cannot get the parent path of the root path [".concat(path3, "]."));
        }
        return path3.slice(0, -1);
      },
      previous(path3) {
        if (path3.length === 0) {
          throw new Error("Cannot get the previous path of a root path [".concat(path3, "], because it has no previous index."));
        }
        var last5 = path3[path3.length - 1];
        if (last5 <= 0) {
          throw new Error("Cannot get the previous path of a first child path [".concat(path3, "] because it would result in a negative index."));
        }
        return path3.slice(0, -1).concat(last5 - 1);
      },
      relative(path3, ancestor) {
        if (!Path.isAncestor(ancestor, path3) && !Path.equals(path3, ancestor)) {
          throw new Error("Cannot get the relative path of [".concat(path3, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
        }
        return path3.slice(ancestor.length);
      },
      transform(path3, operation) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!path3)
          return null;
        var p2 = [...path3];
        var {
          affinity = "forward"
        } = options;
        if (path3.length === 0) {
          return p2;
        }
        switch (operation.type) {
          case "insert_node": {
            var {
              path: op
            } = operation;
            if (Path.equals(op, p2) || Path.endsBefore(op, p2) || Path.isAncestor(op, p2)) {
              p2[op.length - 1] += 1;
            }
            break;
          }
          case "remove_node": {
            var {
              path: _op
            } = operation;
            if (Path.equals(_op, p2) || Path.isAncestor(_op, p2)) {
              return null;
            } else if (Path.endsBefore(_op, p2)) {
              p2[_op.length - 1] -= 1;
            }
            break;
          }
          case "merge_node": {
            var {
              path: _op2,
              position: position3
            } = operation;
            if (Path.equals(_op2, p2) || Path.endsBefore(_op2, p2)) {
              p2[_op2.length - 1] -= 1;
            } else if (Path.isAncestor(_op2, p2)) {
              p2[_op2.length - 1] -= 1;
              p2[_op2.length] += position3;
            }
            break;
          }
          case "split_node": {
            var {
              path: _op3,
              position: _position
            } = operation;
            if (Path.equals(_op3, p2)) {
              if (affinity === "forward") {
                p2[p2.length - 1] += 1;
              } else if (affinity === "backward")
                ;
              else {
                return null;
              }
            } else if (Path.endsBefore(_op3, p2)) {
              p2[_op3.length - 1] += 1;
            } else if (Path.isAncestor(_op3, p2) && path3[_op3.length] >= _position) {
              p2[_op3.length - 1] += 1;
              p2[_op3.length] -= _position;
            }
            break;
          }
          case "move_node": {
            var {
              path: _op4,
              newPath: onp
            } = operation;
            if (Path.equals(_op4, onp)) {
              return p2;
            }
            if (Path.isAncestor(_op4, p2) || Path.equals(_op4, p2)) {
              var copy2 = onp.slice();
              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                copy2[_op4.length - 1] -= 1;
              }
              return copy2.concat(p2.slice(_op4.length));
            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p2) || Path.equals(onp, p2))) {
              if (Path.endsBefore(_op4, p2)) {
                p2[_op4.length - 1] -= 1;
              } else {
                p2[_op4.length - 1] += 1;
              }
            } else if (Path.endsBefore(onp, p2) || Path.equals(onp, p2) || Path.isAncestor(onp, p2)) {
              if (Path.endsBefore(_op4, p2)) {
                p2[_op4.length - 1] -= 1;
              }
              p2[onp.length - 1] += 1;
            } else if (Path.endsBefore(_op4, p2)) {
              if (Path.equals(onp, p2)) {
                p2[onp.length - 1] += 1;
              }
              p2[_op4.length - 1] -= 1;
            }
            break;
          }
        }
        return p2;
      }
    };
    applyToDraft = (editor, selection, op) => {
      switch (op.type) {
        case "insert_node": {
          var {
            path: path3,
            node: node5
          } = op;
          var parent3 = Node2.parent(editor, path3);
          var index3 = path3[path3.length - 1];
          if (index3 > parent3.children.length) {
            throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path3, "] because the destination is past the end of the node."));
          }
          parent3.children.splice(index3, 0, node5);
          if (selection) {
            for (var [point3, key2] of Range.points(selection)) {
              selection[key2] = Point.transform(point3, op);
            }
          }
          break;
        }
        case "insert_text": {
          var {
            path: _path,
            offset: offset3,
            text
          } = op;
          if (text.length === 0)
            break;
          var _node = Node2.leaf(editor, _path);
          var before3 = _node.text.slice(0, offset3);
          var after3 = _node.text.slice(offset3);
          _node.text = before3 + text + after3;
          if (selection) {
            for (var [_point, _key] of Range.points(selection)) {
              selection[_key] = Point.transform(_point, op);
            }
          }
          break;
        }
        case "merge_node": {
          var {
            path: _path2
          } = op;
          var _node2 = Node2.get(editor, _path2);
          var prevPath = Path.previous(_path2);
          var prev2 = Node2.get(editor, prevPath);
          var _parent = Node2.parent(editor, _path2);
          var _index = _path2[_path2.length - 1];
          if (Text.isText(_node2) && Text.isText(prev2)) {
            prev2.text += _node2.text;
          } else if (!Text.isText(_node2) && !Text.isText(prev2)) {
            prev2.children.push(..._node2.children);
          } else {
            throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev2)));
          }
          _parent.children.splice(_index, 1);
          if (selection) {
            for (var [_point2, _key2] of Range.points(selection)) {
              selection[_key2] = Point.transform(_point2, op);
            }
          }
          break;
        }
        case "move_node": {
          var {
            path: _path3,
            newPath
          } = op;
          if (Path.isAncestor(_path3, newPath)) {
            throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
          }
          var _node3 = Node2.get(editor, _path3);
          var _parent2 = Node2.parent(editor, _path3);
          var _index2 = _path3[_path3.length - 1];
          _parent2.children.splice(_index2, 1);
          var truePath = Path.transform(_path3, op);
          var newParent = Node2.get(editor, Path.parent(truePath));
          var newIndex = truePath[truePath.length - 1];
          newParent.children.splice(newIndex, 0, _node3);
          if (selection) {
            for (var [_point3, _key3] of Range.points(selection)) {
              selection[_key3] = Point.transform(_point3, op);
            }
          }
          break;
        }
        case "remove_node": {
          var {
            path: _path4
          } = op;
          var _index3 = _path4[_path4.length - 1];
          var _parent3 = Node2.parent(editor, _path4);
          _parent3.children.splice(_index3, 1);
          if (selection) {
            for (var [_point4, _key4] of Range.points(selection)) {
              var result = Point.transform(_point4, op);
              if (selection != null && result != null) {
                selection[_key4] = result;
              } else {
                var _prev = void 0;
                var next4 = void 0;
                for (var [n4, p2] of Node2.texts(editor)) {
                  if (Path.compare(p2, _path4) === -1) {
                    _prev = [n4, p2];
                  } else {
                    next4 = [n4, p2];
                    break;
                  }
                }
                var preferNext = false;
                if (_prev && next4) {
                  if (Path.equals(next4[1], _path4)) {
                    preferNext = !Path.hasPrevious(next4[1]);
                  } else {
                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next4[1], _path4).length;
                  }
                }
                if (_prev && !preferNext) {
                  _point4.path = _prev[1];
                  _point4.offset = _prev[0].text.length;
                } else if (next4) {
                  _point4.path = next4[1];
                  _point4.offset = 0;
                } else {
                  selection = null;
                }
              }
            }
          }
          break;
        }
        case "remove_text": {
          var {
            path: _path5,
            offset: _offset,
            text: _text
          } = op;
          if (_text.length === 0)
            break;
          var _node4 = Node2.leaf(editor, _path5);
          var _before = _node4.text.slice(0, _offset);
          var _after = _node4.text.slice(_offset + _text.length);
          _node4.text = _before + _after;
          if (selection) {
            for (var [_point5, _key5] of Range.points(selection)) {
              selection[_key5] = Point.transform(_point5, op);
            }
          }
          break;
        }
        case "set_node": {
          var {
            path: _path6,
            properties: properties2,
            newProperties
          } = op;
          if (_path6.length === 0) {
            throw new Error("Cannot set properties on the root node!");
          }
          var _node5 = Node2.get(editor, _path6);
          for (var _key6 in newProperties) {
            if (_key6 === "children" || _key6 === "text") {
              throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
            }
            var value = newProperties[_key6];
            if (value == null) {
              delete _node5[_key6];
            } else {
              _node5[_key6] = value;
            }
          }
          for (var _key7 in properties2) {
            if (!newProperties.hasOwnProperty(_key7)) {
              delete _node5[_key7];
            }
          }
          break;
        }
        case "set_selection": {
          var {
            newProperties: _newProperties
          } = op;
          if (_newProperties == null) {
            selection = _newProperties;
          } else {
            if (selection == null) {
              if (!Range.isRange(_newProperties)) {
                throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
              }
              selection = _objectSpread$e({}, _newProperties);
            }
            for (var _key8 in _newProperties) {
              var _value = _newProperties[_key8];
              if (_value == null) {
                if (_key8 === "anchor" || _key8 === "focus") {
                  throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
                }
                delete selection[_key8];
              } else {
                selection[_key8] = _value;
              }
            }
          }
          break;
        }
        case "split_node": {
          var {
            path: _path7,
            position: position3,
            properties: _properties
          } = op;
          if (_path7.length === 0) {
            throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
          }
          var _node6 = Node2.get(editor, _path7);
          var _parent4 = Node2.parent(editor, _path7);
          var _index4 = _path7[_path7.length - 1];
          var newNode;
          if (Text.isText(_node6)) {
            var _before2 = _node6.text.slice(0, position3);
            var _after2 = _node6.text.slice(position3);
            _node6.text = _before2;
            newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
              text: _after2
            });
          } else {
            var _before3 = _node6.children.slice(0, position3);
            var _after3 = _node6.children.slice(position3);
            _node6.children = _before3;
            newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
              children: _after3
            });
          }
          _parent4.children.splice(_index4 + 1, 0, newNode);
          if (selection) {
            for (var [_point6, _key9] of Range.points(selection)) {
              selection[_key9] = Point.transform(_point6, op);
            }
          }
          break;
        }
      }
      return selection;
    };
    GeneralTransforms = {
      transform(editor, op) {
        editor.children = createDraft(editor.children);
        var selection = editor.selection && createDraft(editor.selection);
        try {
          selection = applyToDraft(editor, selection, op);
        } finally {
          editor.children = finishDraft(editor.children);
          if (selection) {
            editor.selection = isDraft(selection) ? finishDraft(selection) : selection;
          } else {
            editor.selection = null;
          }
        }
      }
    };
    NodeTransforms = {
      insertNodes(editor, nodes2, options) {
        editor.insertNodes(nodes2, options);
      },
      liftNodes(editor, options) {
        editor.liftNodes(options);
      },
      mergeNodes(editor, options) {
        editor.mergeNodes(options);
      },
      moveNodes(editor, options) {
        editor.moveNodes(options);
      },
      removeNodes(editor, options) {
        editor.removeNodes(options);
      },
      setNodes(editor, props, options) {
        editor.setNodes(props, options);
      },
      splitNodes(editor, options) {
        editor.splitNodes(options);
      },
      unsetNodes(editor, props, options) {
        editor.unsetNodes(props, options);
      },
      unwrapNodes(editor, options) {
        editor.unwrapNodes(options);
      },
      wrapNodes(editor, element, options) {
        editor.wrapNodes(element, options);
      }
    };
    SelectionTransforms = {
      collapse(editor, options) {
        editor.collapse(options);
      },
      deselect(editor) {
        editor.deselect();
      },
      move(editor, options) {
        editor.move(options);
      },
      select(editor, target) {
        editor.select(target);
      },
      setPoint(editor, props, options) {
        editor.setPoint(props, options);
      },
      setSelection(editor, props) {
        editor.setSelection(props);
      }
    };
    isDeepEqual = (node5, another) => {
      for (var key2 in node5) {
        var a5 = node5[key2];
        var b3 = another[key2];
        if (isPlainObject(a5) && isPlainObject(b3)) {
          if (!isDeepEqual(a5, b3))
            return false;
        } else if (Array.isArray(a5) && Array.isArray(b3)) {
          if (a5.length !== b3.length)
            return false;
          for (var i4 = 0; i4 < a5.length; i4++) {
            if (a5[i4] !== b3[i4])
              return false;
          }
        } else if (a5 !== b3) {
          return false;
        }
      }
      for (var _key in another) {
        if (node5[_key] === void 0 && another[_key] !== void 0) {
          return false;
        }
      }
      return true;
    };
    _excluded$4 = ["anchor", "focus"];
    Range = {
      edges(range3) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          reverse = false
        } = options;
        var {
          anchor,
          focus: focus2
        } = range3;
        return Range.isBackward(range3) === reverse ? [anchor, focus2] : [focus2, anchor];
      },
      end(range3) {
        var [, end2] = Range.edges(range3);
        return end2;
      },
      equals(range3, another) {
        return Point.equals(range3.anchor, another.anchor) && Point.equals(range3.focus, another.focus);
      },
      includes(range3, target) {
        if (Range.isRange(target)) {
          if (Range.includes(range3, target.anchor) || Range.includes(range3, target.focus)) {
            return true;
          }
          var [rs, re2] = Range.edges(range3);
          var [ts, te2] = Range.edges(target);
          return Point.isBefore(rs, ts) && Point.isAfter(re2, te2);
        }
        var [start2, end2] = Range.edges(range3);
        var isAfterStart = false;
        var isBeforeEnd = false;
        if (Point.isPoint(target)) {
          isAfterStart = Point.compare(target, start2) >= 0;
          isBeforeEnd = Point.compare(target, end2) <= 0;
        } else {
          isAfterStart = Path.compare(target, start2.path) >= 0;
          isBeforeEnd = Path.compare(target, end2.path) <= 0;
        }
        return isAfterStart && isBeforeEnd;
      },
      intersection(range3, another) {
        var rest = _objectWithoutProperties(range3, _excluded$4);
        var [s1, e1] = Range.edges(range3);
        var [s22, e22] = Range.edges(another);
        var start2 = Point.isBefore(s1, s22) ? s22 : s1;
        var end2 = Point.isBefore(e1, e22) ? e1 : e22;
        if (Point.isBefore(end2, start2)) {
          return null;
        } else {
          return _objectSpread$d({
            anchor: start2,
            focus: end2
          }, rest);
        }
      },
      isBackward(range3) {
        var {
          anchor,
          focus: focus2
        } = range3;
        return Point.isAfter(anchor, focus2);
      },
      isCollapsed(range3) {
        var {
          anchor,
          focus: focus2
        } = range3;
        return Point.equals(anchor, focus2);
      },
      isExpanded(range3) {
        return !Range.isCollapsed(range3);
      },
      isForward(range3) {
        return !Range.isBackward(range3);
      },
      isRange(value) {
        return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
      },
      *points(range3) {
        yield [range3.anchor, "anchor"];
        yield [range3.focus, "focus"];
      },
      start(range3) {
        var [start2] = Range.edges(range3);
        return start2;
      },
      transform(range3, op) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return produce(range3, (r4) => {
          if (r4 === null) {
            return null;
          }
          var {
            affinity = "inward"
          } = options;
          var affinityAnchor;
          var affinityFocus;
          if (affinity === "inward") {
            var isCollapsed = Range.isCollapsed(r4);
            if (Range.isForward(r4)) {
              affinityAnchor = "forward";
              affinityFocus = isCollapsed ? affinityAnchor : "backward";
            } else {
              affinityAnchor = "backward";
              affinityFocus = isCollapsed ? affinityAnchor : "forward";
            }
          } else if (affinity === "outward") {
            if (Range.isForward(r4)) {
              affinityAnchor = "backward";
              affinityFocus = "forward";
            } else {
              affinityAnchor = "forward";
              affinityFocus = "backward";
            }
          } else {
            affinityAnchor = affinity;
            affinityFocus = affinity;
          }
          var anchor = Point.transform(r4.anchor, op, {
            affinity: affinityAnchor
          });
          var focus2 = Point.transform(r4.focus, op, {
            affinity: affinityFocus
          });
          if (!anchor || !focus2) {
            return null;
          }
          r4.anchor = anchor;
          r4.focus = focus2;
        });
      }
    };
    isElement3 = (value) => {
      return isPlainObject(value) && Node2.isNodeList(value.children) && !Editor.isEditor(value);
    };
    Element2 = {
      isAncestor(value) {
        return isPlainObject(value) && Node2.isNodeList(value.children);
      },
      isElement: isElement3,
      isElementList(value) {
        return Array.isArray(value) && value.every((val) => Element2.isElement(val));
      },
      isElementProps(props) {
        return props.children !== void 0;
      },
      isElementType: function isElementType(value, elementVal) {
        var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
        return isElement3(value) && value[elementKey] === elementVal;
      },
      matches(element, props) {
        for (var key2 in props) {
          if (key2 === "children") {
            continue;
          }
          if (element[key2] !== props[key2]) {
            return false;
          }
        }
        return true;
      }
    };
    _excluded$3 = ["children"];
    _excluded2$3 = ["text"];
    IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
    Node2 = {
      ancestor(root, path3) {
        var node5 = Node2.get(root, path3);
        if (Text.isText(node5)) {
          throw new Error("Cannot get the ancestor node at path [".concat(path3, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node5)));
        }
        return node5;
      },
      ancestors(root, path3) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function* () {
          for (var p2 of Path.ancestors(path3, options)) {
            var n4 = Node2.ancestor(root, p2);
            var entry = [n4, p2];
            yield entry;
          }
        }();
      },
      child(root, index3) {
        if (Text.isText(root)) {
          throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
        }
        var c4 = root.children[index3];
        if (c4 == null) {
          throw new Error("Cannot get child at index `".concat(index3, "` in node: ").concat(Scrubber.stringify(root)));
        }
        return c4;
      },
      children(root, path3) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function* () {
          var {
            reverse = false
          } = options;
          var ancestor = Node2.ancestor(root, path3);
          var {
            children
          } = ancestor;
          var index3 = reverse ? children.length - 1 : 0;
          while (reverse ? index3 >= 0 : index3 < children.length) {
            var child = Node2.child(ancestor, index3);
            var childPath = path3.concat(index3);
            yield [child, childPath];
            index3 = reverse ? index3 - 1 : index3 + 1;
          }
        }();
      },
      common(root, path3, another) {
        var p2 = Path.common(path3, another);
        var n4 = Node2.get(root, p2);
        return [n4, p2];
      },
      descendant(root, path3) {
        var node5 = Node2.get(root, path3);
        if (Editor.isEditor(node5)) {
          throw new Error("Cannot get the descendant node at path [".concat(path3, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node5)));
        }
        return node5;
      },
      descendants(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          for (var [node5, path3] of Node2.nodes(root, options)) {
            if (path3.length !== 0) {
              yield [node5, path3];
            }
          }
        }();
      },
      elements(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          for (var [node5, path3] of Node2.nodes(root, options)) {
            if (Element2.isElement(node5)) {
              yield [node5, path3];
            }
          }
        }();
      },
      extractProps(node5) {
        if (Element2.isAncestor(node5)) {
          var properties2 = _objectWithoutProperties(node5, _excluded$3);
          return properties2;
        } else {
          var properties2 = _objectWithoutProperties(node5, _excluded2$3);
          return properties2;
        }
      },
      first(root, path3) {
        var p2 = path3.slice();
        var n4 = Node2.get(root, p2);
        while (n4) {
          if (Text.isText(n4) || n4.children.length === 0) {
            break;
          } else {
            n4 = n4.children[0];
            p2.push(0);
          }
        }
        return [n4, p2];
      },
      fragment(root, range3) {
        if (Text.isText(root)) {
          throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
        }
        var newRoot = produce({
          children: root.children
        }, (r4) => {
          var [start2, end2] = Range.edges(range3);
          var nodeEntries = Node2.nodes(r4, {
            reverse: true,
            pass: (_ref2) => {
              var [, path4] = _ref2;
              return !Range.includes(range3, path4);
            }
          });
          for (var [, path3] of nodeEntries) {
            if (!Range.includes(range3, path3)) {
              var parent3 = Node2.parent(r4, path3);
              var index3 = path3[path3.length - 1];
              parent3.children.splice(index3, 1);
            }
            if (Path.equals(path3, end2.path)) {
              var leaf3 = Node2.leaf(r4, path3);
              leaf3.text = leaf3.text.slice(0, end2.offset);
            }
            if (Path.equals(path3, start2.path)) {
              var _leaf = Node2.leaf(r4, path3);
              _leaf.text = _leaf.text.slice(start2.offset);
            }
          }
          if (Editor.isEditor(r4)) {
            r4.selection = null;
          }
        });
        return newRoot.children;
      },
      get(root, path3) {
        var node5 = root;
        for (var i4 = 0; i4 < path3.length; i4++) {
          var p2 = path3[i4];
          if (Text.isText(node5) || !node5.children[p2]) {
            throw new Error("Cannot find a descendant at path [".concat(path3, "] in node: ").concat(Scrubber.stringify(root)));
          }
          node5 = node5.children[p2];
        }
        return node5;
      },
      has(root, path3) {
        var node5 = root;
        for (var i4 = 0; i4 < path3.length; i4++) {
          var p2 = path3[i4];
          if (Text.isText(node5) || !node5.children[p2]) {
            return false;
          }
          node5 = node5.children[p2];
        }
        return true;
      },
      isNode(value) {
        return Text.isText(value) || Element2.isElement(value) || Editor.isEditor(value);
      },
      isNodeList(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        var cachedResult = IS_NODE_LIST_CACHE.get(value);
        if (cachedResult !== void 0) {
          return cachedResult;
        }
        var isNodeList = value.every((val) => Node2.isNode(val));
        IS_NODE_LIST_CACHE.set(value, isNodeList);
        return isNodeList;
      },
      last(root, path3) {
        var p2 = path3.slice();
        var n4 = Node2.get(root, p2);
        while (n4) {
          if (Text.isText(n4) || n4.children.length === 0) {
            break;
          } else {
            var i4 = n4.children.length - 1;
            n4 = n4.children[i4];
            p2.push(i4);
          }
        }
        return [n4, p2];
      },
      leaf(root, path3) {
        var node5 = Node2.get(root, path3);
        if (!Text.isText(node5)) {
          throw new Error("Cannot get the leaf node at path [".concat(path3, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node5)));
        }
        return node5;
      },
      levels(root, path3) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function* () {
          for (var p2 of Path.levels(path3, options)) {
            var n4 = Node2.get(root, p2);
            yield [n4, p2];
          }
        }();
      },
      matches(node5, props) {
        return Element2.isElement(node5) && Element2.isElementProps(props) && Element2.matches(node5, props) || Text.isText(node5) && Text.isTextProps(props) && Text.matches(node5, props);
      },
      nodes(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          var {
            pass: pass2,
            reverse = false
          } = options;
          var {
            from: from4 = [],
            to: to2
          } = options;
          var visited = /* @__PURE__ */ new Set();
          var p2 = [];
          var n4 = root;
          while (true) {
            if (to2 && (reverse ? Path.isBefore(p2, to2) : Path.isAfter(p2, to2))) {
              break;
            }
            if (!visited.has(n4)) {
              yield [n4, p2];
            }
            if (!visited.has(n4) && !Text.isText(n4) && n4.children.length !== 0 && (pass2 == null || pass2([n4, p2]) === false)) {
              visited.add(n4);
              var nextIndex = reverse ? n4.children.length - 1 : 0;
              if (Path.isAncestor(p2, from4)) {
                nextIndex = from4[p2.length];
              }
              p2 = p2.concat(nextIndex);
              n4 = Node2.get(root, p2);
              continue;
            }
            if (p2.length === 0) {
              break;
            }
            if (!reverse) {
              var newPath = Path.next(p2);
              if (Node2.has(root, newPath)) {
                p2 = newPath;
                n4 = Node2.get(root, p2);
                continue;
              }
            }
            if (reverse && p2[p2.length - 1] !== 0) {
              var _newPath = Path.previous(p2);
              p2 = _newPath;
              n4 = Node2.get(root, p2);
              continue;
            }
            p2 = Path.parent(p2);
            n4 = Node2.get(root, p2);
            visited.add(n4);
          }
        }();
      },
      parent(root, path3) {
        var parentPath = Path.parent(path3);
        var p2 = Node2.get(root, parentPath);
        if (Text.isText(p2)) {
          throw new Error("Cannot get the parent of path [".concat(path3, "] because it does not exist in the root."));
        }
        return p2;
      },
      string(node5) {
        if (Text.isText(node5)) {
          return node5.text;
        } else {
          return node5.children.map(Node2.string).join("");
        }
      },
      texts(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          for (var [node5, path3] of Node2.nodes(root, options)) {
            if (Text.isText(node5)) {
              yield [node5, path3];
            }
          }
        }();
      }
    };
    Operation = {
      isNodeOperation(value) {
        return Operation.isOperation(value) && value.type.endsWith("_node");
      },
      isOperation(value) {
        if (!isPlainObject(value)) {
          return false;
        }
        switch (value.type) {
          case "insert_node":
            return Path.isPath(value.path) && Node2.isNode(value.node);
          case "insert_text":
            return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
          case "merge_node":
            return typeof value.position === "number" && Path.isPath(value.path) && isPlainObject(value.properties);
          case "move_node":
            return Path.isPath(value.path) && Path.isPath(value.newPath);
          case "remove_node":
            return Path.isPath(value.path) && Node2.isNode(value.node);
          case "remove_text":
            return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
          case "set_node":
            return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);
          case "set_selection":
            return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);
          case "split_node":
            return Path.isPath(value.path) && typeof value.position === "number" && isPlainObject(value.properties);
          default:
            return false;
        }
      },
      isOperationList(value) {
        return Array.isArray(value) && value.every((val) => Operation.isOperation(val));
      },
      isSelectionOperation(value) {
        return Operation.isOperation(value) && value.type.endsWith("_selection");
      },
      isTextOperation(value) {
        return Operation.isOperation(value) && value.type.endsWith("_text");
      },
      inverse(op) {
        switch (op.type) {
          case "insert_node": {
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              type: "remove_node"
            });
          }
          case "insert_text": {
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              type: "remove_text"
            });
          }
          case "merge_node": {
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              type: "split_node",
              path: Path.previous(op.path)
            });
          }
          case "move_node": {
            var {
              newPath,
              path: path3
            } = op;
            if (Path.equals(newPath, path3)) {
              return op;
            }
            if (Path.isSibling(path3, newPath)) {
              return _objectSpread$c(_objectSpread$c({}, op), {}, {
                path: newPath,
                newPath: path3
              });
            }
            var inversePath = Path.transform(path3, op);
            var inverseNewPath = Path.transform(Path.next(path3), op);
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              path: inversePath,
              newPath: inverseNewPath
            });
          }
          case "remove_node": {
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              type: "insert_node"
            });
          }
          case "remove_text": {
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              type: "insert_text"
            });
          }
          case "set_node": {
            var {
              properties: properties2,
              newProperties
            } = op;
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              properties: newProperties,
              newProperties: properties2
            });
          }
          case "set_selection": {
            var {
              properties: _properties,
              newProperties: _newProperties
            } = op;
            if (_properties == null) {
              return _objectSpread$c(_objectSpread$c({}, op), {}, {
                properties: _newProperties,
                newProperties: null
              });
            } else if (_newProperties == null) {
              return _objectSpread$c(_objectSpread$c({}, op), {}, {
                properties: null,
                newProperties: _properties
              });
            } else {
              return _objectSpread$c(_objectSpread$c({}, op), {}, {
                properties: _newProperties,
                newProperties: _properties
              });
            }
          }
          case "split_node": {
            return _objectSpread$c(_objectSpread$c({}, op), {}, {
              type: "merge_node",
              path: Path.next(op.path)
            });
          }
        }
      }
    };
    IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
    isEditor = (value) => {
      var cachedIsEditor = IS_EDITOR_CACHE.get(value);
      if (cachedIsEditor !== void 0) {
        return cachedIsEditor;
      }
      if (!isPlainObject(value)) {
        return false;
      }
      var isEditor2 = typeof value.addMark === "function" && typeof value.apply === "function" && typeof value.deleteFragment === "function" && typeof value.insertBreak === "function" && typeof value.insertSoftBreak === "function" && typeof value.insertFragment === "function" && typeof value.insertNode === "function" && typeof value.insertText === "function" && typeof value.isElementReadOnly === "function" && typeof value.isInline === "function" && typeof value.isSelectable === "function" && typeof value.isVoid === "function" && typeof value.normalizeNode === "function" && typeof value.onChange === "function" && typeof value.removeMark === "function" && typeof value.getDirtyPaths === "function" && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node2.isNodeList(value.children) && Operation.isOperationList(value.operations);
      IS_EDITOR_CACHE.set(value, isEditor2);
      return isEditor2;
    };
    Editor = {
      above(editor, options) {
        return editor.above(options);
      },
      addMark(editor, key2, value) {
        editor.addMark(key2, value);
      },
      after(editor, at2, options) {
        return editor.after(at2, options);
      },
      before(editor, at2, options) {
        return editor.before(at2, options);
      },
      deleteBackward(editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          unit = "character"
        } = options;
        editor.deleteBackward(unit);
      },
      deleteForward(editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          unit = "character"
        } = options;
        editor.deleteForward(unit);
      },
      deleteFragment(editor, options) {
        editor.deleteFragment(options);
      },
      edges(editor, at2) {
        return editor.edges(at2);
      },
      elementReadOnly(editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return editor.elementReadOnly(options);
      },
      end(editor, at2) {
        return editor.end(at2);
      },
      first(editor, at2) {
        return editor.first(at2);
      },
      fragment(editor, at2) {
        return editor.fragment(at2);
      },
      hasBlocks(editor, element) {
        return editor.hasBlocks(element);
      },
      hasInlines(editor, element) {
        return editor.hasInlines(element);
      },
      hasPath(editor, path3) {
        return editor.hasPath(path3);
      },
      hasTexts(editor, element) {
        return editor.hasTexts(element);
      },
      insertBreak(editor) {
        editor.insertBreak();
      },
      insertFragment(editor, fragment2, options) {
        editor.insertFragment(fragment2, options);
      },
      insertNode(editor, node5) {
        editor.insertNode(node5);
      },
      insertSoftBreak(editor) {
        editor.insertSoftBreak();
      },
      insertText(editor, text) {
        editor.insertText(text);
      },
      isBlock(editor, value) {
        return editor.isBlock(value);
      },
      isEdge(editor, point3, at2) {
        return editor.isEdge(point3, at2);
      },
      isEditor(value) {
        return isEditor(value);
      },
      isElementReadOnly(editor, element) {
        return editor.isElementReadOnly(element);
      },
      isEmpty(editor, element) {
        return editor.isEmpty(element);
      },
      isEnd(editor, point3, at2) {
        return editor.isEnd(point3, at2);
      },
      isInline(editor, value) {
        return editor.isInline(value);
      },
      isNormalizing(editor) {
        return editor.isNormalizing();
      },
      isSelectable(editor, value) {
        return editor.isSelectable(value);
      },
      isStart(editor, point3, at2) {
        return editor.isStart(point3, at2);
      },
      isVoid(editor, value) {
        return editor.isVoid(value);
      },
      last(editor, at2) {
        return editor.last(at2);
      },
      leaf(editor, at2, options) {
        return editor.leaf(at2, options);
      },
      levels(editor, options) {
        return editor.levels(options);
      },
      marks(editor) {
        return editor.getMarks();
      },
      next(editor, options) {
        return editor.next(options);
      },
      node(editor, at2, options) {
        return editor.node(at2, options);
      },
      nodes(editor, options) {
        return editor.nodes(options);
      },
      normalize(editor, options) {
        editor.normalize(options);
      },
      parent(editor, at2, options) {
        return editor.parent(at2, options);
      },
      path(editor, at2, options) {
        return editor.path(at2, options);
      },
      pathRef(editor, path3, options) {
        return editor.pathRef(path3, options);
      },
      pathRefs(editor) {
        return editor.pathRefs();
      },
      point(editor, at2, options) {
        return editor.point(at2, options);
      },
      pointRef(editor, point3, options) {
        return editor.pointRef(point3, options);
      },
      pointRefs(editor) {
        return editor.pointRefs();
      },
      positions(editor, options) {
        return editor.positions(options);
      },
      previous(editor, options) {
        return editor.previous(options);
      },
      range(editor, at2, to2) {
        return editor.range(at2, to2);
      },
      rangeRef(editor, range3, options) {
        return editor.rangeRef(range3, options);
      },
      rangeRefs(editor) {
        return editor.rangeRefs();
      },
      removeMark(editor, key2) {
        editor.removeMark(key2);
      },
      setNormalizing(editor, isNormalizing2) {
        editor.setNormalizing(isNormalizing2);
      },
      start(editor, at2) {
        return editor.start(at2);
      },
      string(editor, at2, options) {
        return editor.string(at2, options);
      },
      unhangRange(editor, range3, options) {
        return editor.unhangRange(range3, options);
      },
      void(editor, options) {
        return editor.void(options);
      },
      withoutNormalizing(editor, fn) {
        editor.withoutNormalizing(fn);
      }
    };
    Location = {
      isLocation(value) {
        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);
      }
    };
    Span = {
      isSpan(value) {
        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
      }
    };
    Point = {
      compare(point3, another) {
        var result = Path.compare(point3.path, another.path);
        if (result === 0) {
          if (point3.offset < another.offset)
            return -1;
          if (point3.offset > another.offset)
            return 1;
          return 0;
        }
        return result;
      },
      isAfter(point3, another) {
        return Point.compare(point3, another) === 1;
      },
      isBefore(point3, another) {
        return Point.compare(point3, another) === -1;
      },
      equals(point3, another) {
        return point3.offset === another.offset && Path.equals(point3.path, another.path);
      },
      isPoint(value) {
        return isPlainObject(value) && typeof value.offset === "number" && Path.isPath(value.path);
      },
      transform(point3, op) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return produce(point3, (p2) => {
          if (p2 === null) {
            return null;
          }
          var {
            affinity = "forward"
          } = options;
          var {
            path: path3,
            offset: offset3
          } = p2;
          switch (op.type) {
            case "insert_node":
            case "move_node": {
              p2.path = Path.transform(path3, op, options);
              break;
            }
            case "insert_text": {
              if (Path.equals(op.path, path3) && (op.offset < offset3 || op.offset === offset3 && affinity === "forward")) {
                p2.offset += op.text.length;
              }
              break;
            }
            case "merge_node": {
              if (Path.equals(op.path, path3)) {
                p2.offset += op.position;
              }
              p2.path = Path.transform(path3, op, options);
              break;
            }
            case "remove_text": {
              if (Path.equals(op.path, path3) && op.offset <= offset3) {
                p2.offset -= Math.min(offset3 - op.offset, op.text.length);
              }
              break;
            }
            case "remove_node": {
              if (Path.equals(op.path, path3) || Path.isAncestor(op.path, path3)) {
                return null;
              }
              p2.path = Path.transform(path3, op, options);
              break;
            }
            case "split_node": {
              if (Path.equals(op.path, path3)) {
                if (op.position === offset3 && affinity == null) {
                  return null;
                } else if (op.position < offset3 || op.position === offset3 && affinity === "forward") {
                  p2.offset -= op.position;
                  p2.path = Path.transform(path3, op, _objectSpread$b(_objectSpread$b({}, options), {}, {
                    affinity: "forward"
                  }));
                }
              } else {
                p2.path = Path.transform(path3, op, options);
              }
              break;
            }
          }
        });
      }
    };
    _scrubber = void 0;
    Scrubber = {
      setScrubber(scrubber) {
        _scrubber = scrubber;
      },
      stringify(value) {
        return JSON.stringify(value, _scrubber);
      }
    };
    _excluded$2 = ["text"];
    _excluded2$2 = ["anchor", "focus"];
    Text = {
      equals(text, another) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var {
          loose = false
        } = options;
        function omitText(obj) {
          var rest = _objectWithoutProperties(obj, _excluded$2);
          return rest;
        }
        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
      },
      isText(value) {
        return isPlainObject(value) && typeof value.text === "string";
      },
      isTextList(value) {
        return Array.isArray(value) && value.every((val) => Text.isText(val));
      },
      isTextProps(props) {
        return props.text !== void 0;
      },
      matches(text, props) {
        for (var key2 in props) {
          if (key2 === "text") {
            continue;
          }
          if (!text.hasOwnProperty(key2) || text[key2] !== props[key2]) {
            return false;
          }
        }
        return true;
      },
      decorations(node5, decorations) {
        var leaves = [_objectSpread$a({}, node5)];
        for (var dec of decorations) {
          var rest = _objectWithoutProperties(dec, _excluded2$2);
          var [start2, end2] = Range.edges(dec);
          var next4 = [];
          var leafEnd = 0;
          var decorationStart = start2.offset;
          var decorationEnd = end2.offset;
          for (var leaf3 of leaves) {
            var {
              length: length2
            } = leaf3.text;
            var leafStart = leafEnd;
            leafEnd += length2;
            if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
              Object.assign(leaf3, rest);
              next4.push(leaf3);
              continue;
            }
            if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
              next4.push(leaf3);
              continue;
            }
            var middle = leaf3;
            var before3 = void 0;
            var after3 = void 0;
            if (decorationEnd < leafEnd) {
              var off = decorationEnd - leafStart;
              after3 = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                text: middle.text.slice(off)
              });
              middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                text: middle.text.slice(0, off)
              });
            }
            if (decorationStart > leafStart) {
              var _off = decorationStart - leafStart;
              before3 = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                text: middle.text.slice(0, _off)
              });
              middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                text: middle.text.slice(_off)
              });
            }
            Object.assign(middle, rest);
            if (before3) {
              next4.push(before3);
            }
            next4.push(middle);
            if (after3) {
              next4.push(after3);
            }
          }
          leaves = next4;
        }
        return leaves;
      }
    };
    getDefaultInsertLocation = (editor) => {
      if (editor.selection) {
        return editor.selection;
      } else if (editor.children.length > 0) {
        return Editor.end(editor, []);
      } else {
        return [0];
      }
    };
    matchPath = (editor, path3) => {
      var [node5] = Editor.node(editor, path3);
      return (n4) => n4 === node5;
    };
    getCharacterDistance = function getCharacterDistance2(str) {
      var isRTL2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var isLTR = !isRTL2;
      var codepoints = isRTL2 ? codepointsIteratorRTL(str) : str;
      var left = CodepointType.None;
      var right = CodepointType.None;
      var distance = 0;
      var gb11 = null;
      var gb12Or13 = null;
      for (var char2 of codepoints) {
        var code = char2.codePointAt(0);
        if (!code)
          break;
        var type = getCodepointType(char2, code);
        [left, right] = isLTR ? [right, type] : [type, left];
        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
          if (isLTR) {
            gb11 = endsWithEmojiZWJ(str.substring(0, distance));
          } else {
            gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
          }
          if (!gb11)
            break;
        }
        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
          if (gb12Or13 !== null) {
            gb12Or13 = !gb12Or13;
          } else {
            if (isLTR) {
              gb12Or13 = true;
            } else {
              gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
            }
          }
          if (!gb12Or13)
            break;
        }
        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
          break;
        }
        distance += char2.length;
      }
      return distance || 1;
    };
    SPACE = /\s/;
    PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    CHAMELEON = /['\u2018\u2019]/;
    getWordDistance = function getWordDistance2(text) {
      var isRTL2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var dist = 0;
      var started = false;
      while (text.length > 0) {
        var charDist = getCharacterDistance(text, isRTL2);
        var [char2, remaining] = splitByCharacterDistance(text, charDist, isRTL2);
        if (isWordCharacter(char2, remaining, isRTL2)) {
          started = true;
          dist += charDist;
        } else if (!started) {
          dist += charDist;
        } else {
          break;
        }
        text = remaining;
      }
      return dist;
    };
    splitByCharacterDistance = (str, dist, isRTL2) => {
      if (isRTL2) {
        var at2 = str.length - dist;
        return [str.slice(at2, str.length), str.slice(0, at2)];
      }
      return [str.slice(0, dist), str.slice(dist)];
    };
    isWordCharacter = function isWordCharacter2(char2, remaining) {
      var isRTL2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (SPACE.test(char2)) {
        return false;
      }
      if (CHAMELEON.test(char2)) {
        var charDist = getCharacterDistance(remaining, isRTL2);
        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL2);
        if (isWordCharacter2(nextChar, nextRemaining, isRTL2)) {
          return true;
        }
      }
      if (PUNCTUATION.test(char2)) {
        return false;
      }
      return true;
    };
    codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
      var end2 = str.length - 1;
      for (var i4 = 0; i4 < str.length; i4++) {
        var char1 = str.charAt(end2 - i4);
        if (isLowSurrogate(char1.charCodeAt(0))) {
          var char2 = str.charAt(end2 - i4 - 1);
          if (isHighSurrogate(char2.charCodeAt(0))) {
            yield char2 + char1;
            i4++;
            continue;
          }
        }
        yield char1;
      }
    };
    isHighSurrogate = (charCode) => {
      return charCode >= 55296 && charCode <= 56319;
    };
    isLowSurrogate = (charCode) => {
      return charCode >= 56320 && charCode <= 57343;
    };
    (function(CodepointType2) {
      CodepointType2[CodepointType2["None"] = 0] = "None";
      CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
      CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
      CodepointType2[CodepointType2["RI"] = 4] = "RI";
      CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
      CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
      CodepointType2[CodepointType2["L"] = 32] = "L";
      CodepointType2[CodepointType2["V"] = 64] = "V";
      CodepointType2[CodepointType2["T"] = 128] = "T";
      CodepointType2[CodepointType2["LV"] = 256] = "LV";
      CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
      CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
      CodepointType2[CodepointType2["Any"] = 2048] = "Any";
    })(CodepointType || (CodepointType = {}));
    reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
    rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
    reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
    reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
    reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
    reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
    reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
    reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
    reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
    getCodepointType = (char2, code) => {
      var type = CodepointType.Any;
      if (char2.search(reExtend) !== -1) {
        type |= CodepointType.Extend;
      }
      if (code === 8205) {
        type |= CodepointType.ZWJ;
      }
      if (code >= 127462 && code <= 127487) {
        type |= CodepointType.RI;
      }
      if (char2.search(rePrepend) !== -1) {
        type |= CodepointType.Prepend;
      }
      if (char2.search(reSpacingMark) !== -1) {
        type |= CodepointType.SpacingMark;
      }
      if (char2.search(reL) !== -1) {
        type |= CodepointType.L;
      }
      if (char2.search(reV) !== -1) {
        type |= CodepointType.V;
      }
      if (char2.search(reT) !== -1) {
        type |= CodepointType.T;
      }
      if (char2.search(reLV) !== -1) {
        type |= CodepointType.LV;
      }
      if (char2.search(reLVT) !== -1) {
        type |= CodepointType.LVT;
      }
      if (char2.search(reExtPict) !== -1) {
        type |= CodepointType.ExtPict;
      }
      return type;
    };
    NonBoundaryPairs = [
      // GB6
      [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
      // GB7
      [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
      // GB8
      [CodepointType.LVT | CodepointType.T, CodepointType.T],
      // GB9
      [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
      // GB9a
      [CodepointType.Any, CodepointType.SpacingMark],
      // GB9b
      [CodepointType.Prepend, CodepointType.Any],
      // GB11
      [CodepointType.ZWJ, CodepointType.ExtPict],
      // GB12 and GB13
      [CodepointType.RI, CodepointType.RI]
    ];
    endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
    endsWithEmojiZWJ = (str) => {
      return str.search(endingEmojiZWJ) !== -1;
    };
    endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
    endsWithOddNumberOfRIs = (str) => {
      var match5 = str.match(endingRIs);
      if (match5 === null) {
        return false;
      } else {
        var numRIs = match5[0].length / 2;
        return numRIs % 2 === 1;
      }
    };
    TextTransforms = {
      delete(editor, options) {
        editor.delete(options);
      },
      insertFragment(editor, fragment2, options) {
        editor.insertFragment(fragment2, options);
      },
      insertText(editor, text) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Editor.withoutNormalizing(editor, () => {
          var {
            voids = false
          } = options;
          var {
            at: at2 = getDefaultInsertLocation(editor)
          } = options;
          if (Path.isPath(at2)) {
            at2 = Editor.range(editor, at2);
          }
          if (Range.isRange(at2)) {
            if (Range.isCollapsed(at2)) {
              at2 = at2.anchor;
            } else {
              var end2 = Range.end(at2);
              if (!voids && Editor.void(editor, {
                at: end2
              })) {
                return;
              }
              var start2 = Range.start(at2);
              var startRef = Editor.pointRef(editor, start2);
              var endRef = Editor.pointRef(editor, end2);
              Transforms.delete(editor, {
                at: at2,
                voids
              });
              var startPoint = startRef.unref();
              var endPoint = endRef.unref();
              at2 = startPoint || endPoint;
              Transforms.setSelection(editor, {
                anchor: at2,
                focus: at2
              });
            }
          }
          if (!voids && Editor.void(editor, {
            at: at2
          }) || Editor.elementReadOnly(editor, {
            at: at2
          })) {
            return;
          }
          var {
            path: path3,
            offset: offset3
          } = at2;
          if (text.length > 0)
            editor.apply({
              type: "insert_text",
              path: path3,
              offset: offset3,
              text
            });
        });
      }
    };
    Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);
    apply = (editor, op) => {
      for (var ref of Editor.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }
      for (var _ref2 of Editor.pointRefs(editor)) {
        PointRef.transform(_ref2, op);
      }
      for (var _ref22 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref22, op);
      }
      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();
      var dirtyPaths;
      var dirtyPathKeys;
      var add4 = (path4) => {
        if (path4) {
          var key2 = path4.join(",");
          if (!dirtyPathKeys.has(key2)) {
            dirtyPathKeys.add(key2);
            dirtyPaths.push(path4);
          }
        }
      };
      if (Path.operationCanTransformPath(op)) {
        dirtyPaths = [];
        dirtyPathKeys = /* @__PURE__ */ new Set();
        for (var path3 of oldDirtyPaths) {
          var newPath = Path.transform(path3, op);
          add4(newPath);
        }
      } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
      }
      var newDirtyPaths = editor.getDirtyPaths(op);
      for (var _path of newDirtyPaths) {
        add4(_path);
      }
      DIRTY_PATHS.set(editor, dirtyPaths);
      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
      Transforms.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor, {
        operation: op
      });
      if (op.type === "set_selection") {
        editor.marks = null;
      }
      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange({
            operation: op
          });
          editor.operations = [];
        });
      }
    };
    getDirtyPaths = (editor, op) => {
      switch (op.type) {
        case "insert_text":
        case "remove_text":
        case "set_node": {
          var {
            path: path3
          } = op;
          return Path.levels(path3);
        }
        case "insert_node": {
          var {
            node: node5,
            path: _path
          } = op;
          var levels2 = Path.levels(_path);
          var descendants = Text.isText(node5) ? [] : Array.from(Node2.nodes(node5), (_ref2) => {
            var [, p3] = _ref2;
            return _path.concat(p3);
          });
          return [...levels2, ...descendants];
        }
        case "merge_node": {
          var {
            path: _path2
          } = op;
          var ancestors = Path.ancestors(_path2);
          var previousPath = Path.previous(_path2);
          return [...ancestors, previousPath];
        }
        case "move_node": {
          var {
            path: _path3,
            newPath
          } = op;
          if (Path.equals(_path3, newPath)) {
            return [];
          }
          var oldAncestors = [];
          var newAncestors = [];
          for (var ancestor of Path.ancestors(_path3)) {
            var p2 = Path.transform(ancestor, op);
            oldAncestors.push(p2);
          }
          for (var _ancestor of Path.ancestors(newPath)) {
            var _p = Path.transform(_ancestor, op);
            newAncestors.push(_p);
          }
          var newParent = newAncestors[newAncestors.length - 1];
          var newIndex = newPath[newPath.length - 1];
          var resultPath = newParent.concat(newIndex);
          return [...oldAncestors, ...newAncestors, resultPath];
        }
        case "remove_node": {
          var {
            path: _path4
          } = op;
          var _ancestors = Path.ancestors(_path4);
          return [..._ancestors];
        }
        case "split_node": {
          var {
            path: _path5
          } = op;
          var _levels = Path.levels(_path5);
          var nextPath = Path.next(_path5);
          return [..._levels, nextPath];
        }
        default: {
          return [];
        }
      }
    };
    getFragment = (editor) => {
      var {
        selection
      } = editor;
      if (selection) {
        return Node2.fragment(editor, selection);
      }
      return [];
    };
    normalizeNode = (editor, entry) => {
      var [node5, path3] = entry;
      if (Text.isText(node5)) {
        return;
      }
      if (Element2.isElement(node5) && node5.children.length === 0) {
        var child = {
          text: ""
        };
        Transforms.insertNodes(editor, child, {
          at: path3.concat(0),
          voids: true
        });
        return;
      }
      var shouldHaveInlines = Editor.isEditor(node5) ? false : Element2.isElement(node5) && (editor.isInline(node5) || node5.children.length === 0 || Text.isText(node5.children[0]) || editor.isInline(node5.children[0]));
      var n4 = 0;
      for (var i4 = 0; i4 < node5.children.length; i4++, n4++) {
        var currentNode = Node2.get(editor, path3);
        if (Text.isText(currentNode))
          continue;
        var _child = currentNode.children[n4];
        var prev2 = currentNode.children[n4 - 1];
        var isLast = i4 === node5.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);
        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path3.concat(n4),
            voids: true
          });
          n4--;
        } else if (Element2.isElement(_child)) {
          if (editor.isInline(_child)) {
            if (prev2 == null || !Text.isText(prev2)) {
              var newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, newChild, {
                at: path3.concat(n4),
                voids: true
              });
              n4++;
            } else if (isLast) {
              var _newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path3.concat(n4 + 1),
                voids: true
              });
              n4++;
            }
          }
        } else {
          if (prev2 != null && Text.isText(prev2)) {
            if (Text.equals(_child, prev2, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path3.concat(n4),
                voids: true
              });
              n4--;
            } else if (prev2.text === "") {
              Transforms.removeNodes(editor, {
                at: path3.concat(n4 - 1),
                voids: true
              });
              n4--;
            } else if (_child.text === "") {
              Transforms.removeNodes(editor, {
                at: path3.concat(n4),
                voids: true
              });
              n4--;
            }
          }
        }
      }
    };
    shouldNormalize = (editor, _ref2) => {
      var {
        iteration,
        initialDirtyPathsLength
      } = _ref2;
      var maxIterations = initialDirtyPathsLength * 42;
      if (iteration > maxIterations) {
        throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
      }
      return true;
    };
    above = function above2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        voids = false,
        mode = "lowest",
        at: at2 = editor.selection,
        match: match5
      } = options;
      if (!at2) {
        return;
      }
      var path3 = Editor.path(editor, at2);
      var reverse = mode === "lowest";
      for (var [n4, p2] of Editor.levels(editor, {
        at: path3,
        voids,
        match: match5,
        reverse
      })) {
        if (Text.isText(n4))
          continue;
        if (Range.isRange(at2)) {
          if (Path.isAncestor(p2, at2.anchor.path) && Path.isAncestor(p2, at2.focus.path)) {
            return [n4, p2];
          }
        } else {
          if (!Path.equals(path3, p2)) {
            return [n4, p2];
          }
        }
      }
    };
    addMark = (editor, key2, value) => {
      var {
        selection
      } = editor;
      if (selection) {
        var match5 = (node5, path3) => {
          if (!Text.isText(node5)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path3);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match5(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.setNodes(editor, {
            [key2]: value
          }, {
            match: match5,
            split: true,
            voids: true
          });
        } else {
          var marks3 = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {
            [key2]: value
          });
          editor.marks = marks3;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    };
    after = function after2(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var anchor = Editor.point(editor, at2, {
        edge: "end"
      });
      var focus2 = Editor.end(editor, []);
      var range3 = {
        anchor,
        focus: focus2
      };
      var {
        distance = 1
      } = options;
      var d3 = 0;
      var target;
      for (var p2 of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {
        at: range3
      }))) {
        if (d3 > distance) {
          break;
        }
        if (d3 !== 0) {
          target = p2;
        }
        d3++;
      }
      return target;
    };
    before = function before2(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var anchor = Editor.start(editor, []);
      var focus2 = Editor.point(editor, at2, {
        edge: "start"
      });
      var range3 = {
        anchor,
        focus: focus2
      };
      var {
        distance = 1
      } = options;
      var d3 = 0;
      var target;
      for (var p2 of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {
        at: range3,
        reverse: true
      }))) {
        if (d3 > distance) {
          break;
        }
        if (d3 !== 0) {
          target = p2;
        }
        d3++;
      }
      return target;
    };
    deleteBackward = (editor, unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    };
    deleteForward = (editor, unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    };
    deleteFragment = function deleteFragment2(editor) {
      var {
        direction = "forward"
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        selection
      } = editor;
      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === "backward"
        });
      }
    };
    edges = (editor, at2) => {
      return [Editor.start(editor, at2), Editor.end(editor, at2)];
    };
    elementReadOnly = function elementReadOnly2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {
        match: (n4) => Element2.isElement(n4) && Editor.isElementReadOnly(editor, n4)
      }));
    };
    end = (editor, at2) => {
      return Editor.point(editor, at2, {
        edge: "end"
      });
    };
    first2 = (editor, at2) => {
      var path3 = Editor.path(editor, at2, {
        edge: "start"
      });
      return Editor.node(editor, path3);
    };
    fragment = (editor, at2) => {
      var range3 = Editor.range(editor, at2);
      return Node2.fragment(editor, range3);
    };
    getVoid = function getVoid2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {
        match: (n4) => Element2.isElement(n4) && Editor.isVoid(editor, n4)
      }));
    };
    hasBlocks = (editor, element) => {
      return element.children.some((n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4));
    };
    hasInlines = (editor, element) => {
      return element.children.some((n4) => Text.isText(n4) || Editor.isInline(editor, n4));
    };
    hasPath2 = (editor, path3) => {
      return Node2.has(editor, path3);
    };
    hasTexts = (editor, element) => {
      return element.children.every((n4) => Text.isText(n4));
    };
    insertBreak = (editor) => {
      Transforms.splitNodes(editor, {
        always: true
      });
    };
    insertNode = (editor, node5, options) => {
      Transforms.insertNodes(editor, node5, options);
    };
    insertSoftBreak = (editor) => {
      Transforms.splitNodes(editor, {
        always: true
      });
    };
    insertText = function insertText2(editor, text) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        selection,
        marks: marks3
      } = editor;
      if (selection) {
        if (marks3) {
          var node5 = _objectSpread$3({
            text
          }, marks3);
          Transforms.insertNodes(editor, node5, {
            at: options.at,
            voids: options.voids
          });
        } else {
          Transforms.insertText(editor, text, options);
        }
        editor.marks = null;
      }
    };
    isBlock = (editor, value) => {
      return !editor.isInline(value);
    };
    isEdge = (editor, point3, at2) => {
      return Editor.isStart(editor, point3, at2) || Editor.isEnd(editor, point3, at2);
    };
    isEmpty2 = (editor, element) => {
      var {
        children
      } = element;
      var [first3] = children;
      return children.length === 0 || children.length === 1 && Text.isText(first3) && first3.text === "" && !editor.isVoid(element);
    };
    isEnd = (editor, point3, at2) => {
      var end2 = Editor.end(editor, at2);
      return Point.equals(point3, end2);
    };
    isNormalizing = (editor) => {
      var isNormalizing2 = NORMALIZING.get(editor);
      return isNormalizing2 === void 0 ? true : isNormalizing2;
    };
    isStart = (editor, point3, at2) => {
      if (point3.offset !== 0) {
        return false;
      }
      var start2 = Editor.start(editor, at2);
      return Point.equals(point3, start2);
    };
    last4 = (editor, at2) => {
      var path3 = Editor.path(editor, at2, {
        edge: "end"
      });
      return Editor.node(editor, path3);
    };
    leaf = function leaf2(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path3 = Editor.path(editor, at2, options);
      var node5 = Node2.leaf(editor, path3);
      return [node5, path3];
    };
    _excluded$1 = ["text"];
    _excluded2$1 = ["text"];
    marks = function marks2(editor) {
      var {
        marks: marks3,
        selection
      } = editor;
      if (!selection) {
        return null;
      }
      if (marks3) {
        return marks3;
      }
      if (Range.isExpanded(selection)) {
        var [match5] = Editor.nodes(editor, {
          match: Text.isText
        });
        if (match5) {
          var [_node] = match5;
          var _rest = _objectWithoutProperties(_node, _excluded$1);
          return _rest;
        } else {
          return {};
        }
      }
      var {
        anchor
      } = selection;
      var {
        path: path3
      } = anchor;
      var [node5] = Editor.leaf(editor, path3);
      if (anchor.offset === 0) {
        var prev2 = Editor.previous(editor, {
          at: path3,
          match: Text.isText
        });
        var markedVoid = Editor.above(editor, {
          match: (n4) => Element2.isElement(n4) && Editor.isVoid(editor, n4) && editor.markableVoid(n4)
        });
        if (!markedVoid) {
          var block = Editor.above(editor, {
            match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4)
          });
          if (prev2 && block) {
            var [prevNode, prevPath] = prev2;
            var [, blockPath] = block;
            if (Path.isAncestor(blockPath, prevPath)) {
              node5 = prevNode;
            }
          }
        }
      }
      var rest = _objectWithoutProperties(node5, _excluded2$1);
      return rest;
    };
    next2 = function next3(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match5,
        at: at2 = editor.selection
      } = options;
      if (!at2) {
        return;
      }
      var pointAfterLocation = Editor.after(editor, at2, {
        voids
      });
      if (!pointAfterLocation)
        return;
      var [, to2] = Editor.last(editor, []);
      var span = [pointAfterLocation.path, to2];
      if (Path.isPath(at2) && at2.length === 0) {
        throw new Error("Cannot get the next node from the root node!");
      }
      if (match5 == null) {
        if (Path.isPath(at2)) {
          var [parent3] = Editor.parent(editor, at2);
          match5 = (n4) => parent3.children.includes(n4);
        } else {
          match5 = () => true;
        }
      }
      var [next4] = Editor.nodes(editor, {
        at: span,
        match: match5,
        mode,
        voids
      });
      return next4;
    };
    node3 = function node4(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path3 = Editor.path(editor, at2, options);
      var node5 = Node2.get(editor, path3);
      return [node5, path3];
    };
    normalize2 = function normalize3(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        force = false,
        operation
      } = options;
      var getDirtyPaths2 = (editor2) => {
        return DIRTY_PATHS.get(editor2) || [];
      };
      var getDirtyPathKeys = (editor2) => {
        return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();
      };
      var popDirtyPath = (editor2) => {
        var path3 = getDirtyPaths2(editor2).pop();
        var key2 = path3.join(",");
        getDirtyPathKeys(editor2).delete(key2);
        return path3;
      };
      if (!Editor.isNormalizing(editor)) {
        return;
      }
      if (force) {
        var allPaths = Array.from(Node2.nodes(editor), (_ref2) => {
          var [, p2] = _ref2;
          return p2;
        });
        var allPathKeys = new Set(allPaths.map((p2) => p2.join(",")));
        DIRTY_PATHS.set(editor, allPaths);
        DIRTY_PATH_KEYS.set(editor, allPathKeys);
      }
      if (getDirtyPaths2(editor).length === 0) {
        return;
      }
      Editor.withoutNormalizing(editor, () => {
        for (var dirtyPath of getDirtyPaths2(editor)) {
          if (Node2.has(editor, dirtyPath)) {
            var entry = Editor.node(editor, dirtyPath);
            var [node5, _2] = entry;
            if (Element2.isElement(node5) && node5.children.length === 0) {
              editor.normalizeNode(entry, {
                operation
              });
            }
          }
        }
        var dirtyPaths = getDirtyPaths2(editor);
        var initialDirtyPathsLength = dirtyPaths.length;
        var iteration = 0;
        while (dirtyPaths.length !== 0) {
          if (!editor.shouldNormalize({
            dirtyPaths,
            iteration,
            initialDirtyPathsLength,
            operation
          })) {
            return;
          }
          var _dirtyPath = popDirtyPath(editor);
          if (Node2.has(editor, _dirtyPath)) {
            var _entry = Editor.node(editor, _dirtyPath);
            editor.normalizeNode(_entry, {
              operation
            });
          }
          iteration++;
          dirtyPaths = getDirtyPaths2(editor);
        }
      });
    };
    parent = function parent2(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path3 = Editor.path(editor, at2, options);
      var parentPath = Path.parent(path3);
      var entry = Editor.node(editor, parentPath);
      return entry;
    };
    pathRef = function pathRef2(editor, path3) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        affinity = "forward"
      } = options;
      var ref = {
        current: path3,
        affinity,
        unref() {
          var {
            current: current2
          } = ref;
          var pathRefs2 = Editor.pathRefs(editor);
          pathRefs2.delete(ref);
          ref.current = null;
          return current2;
        }
      };
      var refs = Editor.pathRefs(editor);
      refs.add(ref);
      return ref;
    };
    pathRefs = (editor) => {
      var refs = PATH_REFS.get(editor);
      if (!refs) {
        refs = /* @__PURE__ */ new Set();
        PATH_REFS.set(editor, refs);
      }
      return refs;
    };
    path = function path2(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        depth,
        edge
      } = options;
      if (Path.isPath(at2)) {
        if (edge === "start") {
          var [, firstPath] = Node2.first(editor, at2);
          at2 = firstPath;
        } else if (edge === "end") {
          var [, lastPath] = Node2.last(editor, at2);
          at2 = lastPath;
        }
      }
      if (Range.isRange(at2)) {
        if (edge === "start") {
          at2 = Range.start(at2);
        } else if (edge === "end") {
          at2 = Range.end(at2);
        } else {
          at2 = Path.common(at2.anchor.path, at2.focus.path);
        }
      }
      if (Point.isPoint(at2)) {
        at2 = at2.path;
      }
      if (depth != null) {
        at2 = at2.slice(0, depth);
      }
      return at2;
    };
    pointRef = function pointRef2(editor, point3) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        affinity = "forward"
      } = options;
      var ref = {
        current: point3,
        affinity,
        unref() {
          var {
            current: current2
          } = ref;
          var pointRefs2 = Editor.pointRefs(editor);
          pointRefs2.delete(ref);
          ref.current = null;
          return current2;
        }
      };
      var refs = Editor.pointRefs(editor);
      refs.add(ref);
      return ref;
    };
    pointRefs = (editor) => {
      var refs = POINT_REFS.get(editor);
      if (!refs) {
        refs = /* @__PURE__ */ new Set();
        POINT_REFS.set(editor, refs);
      }
      return refs;
    };
    point = function point2(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        edge = "start"
      } = options;
      if (Path.isPath(at2)) {
        var path3;
        if (edge === "end") {
          var [, lastPath] = Node2.last(editor, at2);
          path3 = lastPath;
        } else {
          var [, firstPath] = Node2.first(editor, at2);
          path3 = firstPath;
        }
        var node5 = Node2.get(editor, path3);
        if (!Text.isText(node5)) {
          throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at2, "] because it has no ").concat(edge, " text node."));
        }
        return {
          path: path3,
          offset: edge === "end" ? node5.text.length : 0
        };
      }
      if (Range.isRange(at2)) {
        var [start2, end2] = Range.edges(at2);
        return edge === "start" ? start2 : end2;
      }
      return at2;
    };
    previous = function previous2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match5,
        at: at2 = editor.selection
      } = options;
      if (!at2) {
        return;
      }
      var pointBeforeLocation = Editor.before(editor, at2, {
        voids
      });
      if (!pointBeforeLocation) {
        return;
      }
      var [, to2] = Editor.first(editor, []);
      var span = [pointBeforeLocation.path, to2];
      if (Path.isPath(at2) && at2.length === 0) {
        throw new Error("Cannot get the previous node from the root node!");
      }
      if (match5 == null) {
        if (Path.isPath(at2)) {
          var [parent3] = Editor.parent(editor, at2);
          match5 = (n4) => parent3.children.includes(n4);
        } else {
          match5 = () => true;
        }
      }
      var [previous3] = Editor.nodes(editor, {
        reverse: true,
        at: span,
        match: match5,
        mode,
        voids
      });
      return previous3;
    };
    rangeRef = function rangeRef2(editor, range3) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        affinity = "forward"
      } = options;
      var ref = {
        current: range3,
        affinity,
        unref() {
          var {
            current: current2
          } = ref;
          var rangeRefs2 = Editor.rangeRefs(editor);
          rangeRefs2.delete(ref);
          ref.current = null;
          return current2;
        }
      };
      var refs = Editor.rangeRefs(editor);
      refs.add(ref);
      return ref;
    };
    rangeRefs = (editor) => {
      var refs = RANGE_REFS.get(editor);
      if (!refs) {
        refs = /* @__PURE__ */ new Set();
        RANGE_REFS.set(editor, refs);
      }
      return refs;
    };
    range2 = (editor, at2, to2) => {
      if (Range.isRange(at2) && !to2) {
        return at2;
      }
      var start2 = Editor.start(editor, at2);
      var end2 = Editor.end(editor, to2 || at2);
      return {
        anchor: start2,
        focus: end2
      };
    };
    removeMark = (editor, key2) => {
      var {
        selection
      } = editor;
      if (selection) {
        var match5 = (node5, path3) => {
          if (!Text.isText(node5)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path3);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match5(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.unsetNodes(editor, key2, {
            match: match5,
            split: true,
            voids: true
          });
        } else {
          var marks3 = _objectSpread$2({}, Editor.marks(editor) || {});
          delete marks3[key2];
          editor.marks = marks3;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    };
    setNormalizing = (editor, isNormalizing2) => {
      NORMALIZING.set(editor, isNormalizing2);
    };
    start = (editor, at2) => {
      return Editor.point(editor, at2, {
        edge: "start"
      });
    };
    string2 = function string3(editor, at2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        voids = false
      } = options;
      var range3 = Editor.range(editor, at2);
      var [start2, end2] = Range.edges(range3);
      var text = "";
      for (var [node5, path3] of Editor.nodes(editor, {
        at: range3,
        match: Text.isText,
        voids
      })) {
        var t4 = node5.text;
        if (Path.equals(path3, end2.path)) {
          t4 = t4.slice(0, end2.offset);
        }
        if (Path.equals(path3, start2.path)) {
          t4 = t4.slice(start2.offset);
        }
        text += t4;
      }
      return text;
    };
    unhangRange = function unhangRange2(editor, range3) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        voids = false
      } = options;
      var [start2, end2] = Range.edges(range3);
      if (start2.offset !== 0 || end2.offset !== 0 || Range.isCollapsed(range3) || Path.hasPrevious(end2.path)) {
        return range3;
      }
      var endBlock = Editor.above(editor, {
        at: end2,
        match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
        voids
      });
      var blockPath = endBlock ? endBlock[1] : [];
      var first3 = Editor.start(editor, start2);
      var before3 = {
        anchor: first3,
        focus: end2
      };
      var skip2 = true;
      for (var [node5, path3] of Editor.nodes(editor, {
        at: before3,
        match: Text.isText,
        reverse: true,
        voids
      })) {
        if (skip2) {
          skip2 = false;
          continue;
        }
        if (node5.text !== "" || Path.isBefore(path3, blockPath)) {
          end2 = {
            path: path3,
            offset: node5.text.length
          };
          break;
        }
      }
      return {
        anchor: start2,
        focus: end2
      };
    };
    withoutNormalizing = (editor, fn) => {
      var value = Editor.isNormalizing(editor);
      Editor.setNormalizing(editor, false);
      try {
        fn();
      } finally {
        Editor.setNormalizing(editor, value);
      }
      Editor.normalize(editor);
    };
    deleteText = function deleteText2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Editor.withoutNormalizing(editor, () => {
        var _Editor$void, _Editor$void2;
        var {
          reverse = false,
          unit = "character",
          distance = 1,
          voids = false
        } = options;
        var {
          at: at2 = editor.selection,
          hanging = false
        } = options;
        if (!at2) {
          return;
        }
        var isCollapsed = false;
        if (Range.isRange(at2) && Range.isCollapsed(at2)) {
          isCollapsed = true;
          at2 = at2.anchor;
        }
        if (Point.isPoint(at2)) {
          var furthestVoid = Editor.void(editor, {
            at: at2,
            mode: "highest"
          });
          if (!voids && furthestVoid) {
            var [, voidPath] = furthestVoid;
            at2 = voidPath;
          } else {
            var opts = {
              unit,
              distance
            };
            var target = reverse ? Editor.before(editor, at2, opts) || Editor.start(editor, []) : Editor.after(editor, at2, opts) || Editor.end(editor, []);
            at2 = {
              anchor: at2,
              focus: target
            };
            hanging = true;
          }
        }
        if (Path.isPath(at2)) {
          Transforms.removeNodes(editor, {
            at: at2,
            voids
          });
          return;
        }
        if (Range.isCollapsed(at2)) {
          return;
        }
        if (!hanging) {
          var [, _end] = Range.edges(at2);
          var endOfDoc = Editor.end(editor, []);
          if (!Point.equals(_end, endOfDoc)) {
            at2 = Editor.unhangRange(editor, at2, {
              voids
            });
          }
        }
        var [start2, end2] = Range.edges(at2);
        var startBlock = Editor.above(editor, {
          match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
          at: start2,
          voids
        });
        var endBlock = Editor.above(editor, {
          match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
          at: end2,
          voids
        });
        var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
        var isSingleText = Path.equals(start2.path, end2.path);
        var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {
          at: start2,
          mode: "highest"
        })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {
          at: start2,
          mode: "highest"
        });
        var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {
          at: end2,
          mode: "highest"
        })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {
          at: end2,
          mode: "highest"
        });
        if (startNonEditable) {
          var before3 = Editor.before(editor, start2);
          if (before3 && startBlock && Path.isAncestor(startBlock[1], before3.path)) {
            start2 = before3;
          }
        }
        if (endNonEditable) {
          var after3 = Editor.after(editor, end2);
          if (after3 && endBlock && Path.isAncestor(endBlock[1], after3.path)) {
            end2 = after3;
          }
        }
        var matches = [];
        var lastPath;
        for (var entry of Editor.nodes(editor, {
          at: at2,
          voids
        })) {
          var [node5, path3] = entry;
          if (lastPath && Path.compare(path3, lastPath) === 0) {
            continue;
          }
          if (!voids && Element2.isElement(node5) && (Editor.isVoid(editor, node5) || Editor.isElementReadOnly(editor, node5)) || !Path.isCommon(path3, start2.path) && !Path.isCommon(path3, end2.path)) {
            matches.push(entry);
            lastPath = path3;
          }
        }
        var pathRefs2 = Array.from(matches, (_ref2) => {
          var [, p2] = _ref2;
          return Editor.pathRef(editor, p2);
        });
        var startRef = Editor.pointRef(editor, start2);
        var endRef = Editor.pointRef(editor, end2);
        var removedText = "";
        if (!isSingleText && !startNonEditable) {
          var _point = startRef.current;
          var [_node] = Editor.leaf(editor, _point);
          var {
            path: _path
          } = _point;
          var {
            offset: offset3
          } = start2;
          var text = _node.text.slice(offset3);
          if (text.length > 0) {
            editor.apply({
              type: "remove_text",
              path: _path,
              offset: offset3,
              text
            });
            removedText = text;
          }
        }
        pathRefs2.reverse().map((r4) => r4.unref()).filter((r4) => r4 !== null).forEach((p2) => Transforms.removeNodes(editor, {
          at: p2,
          voids
        }));
        if (!endNonEditable) {
          var _point2 = endRef.current;
          var [_node2] = Editor.leaf(editor, _point2);
          var {
            path: _path2
          } = _point2;
          var _offset = isSingleText ? start2.offset : 0;
          var _text = _node2.text.slice(_offset, end2.offset);
          if (_text.length > 0) {
            editor.apply({
              type: "remove_text",
              path: _path2,
              offset: _offset,
              text: _text
            });
            removedText = _text;
          }
        }
        if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
          Transforms.mergeNodes(editor, {
            at: endRef.current,
            hanging: true,
            voids
          });
        }
        if (isCollapsed && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
          Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
        }
        var startUnref = startRef.unref();
        var endUnref = endRef.unref();
        var point3 = reverse ? startUnref || endUnref : endUnref || startUnref;
        if (options.at == null && point3) {
          Transforms.select(editor, point3);
        }
      });
    };
    insertFragment = function insertFragment2(editor, fragment2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          hanging = false,
          voids = false
        } = options;
        var {
          at: at2 = getDefaultInsertLocation(editor)
        } = options;
        if (!fragment2.length) {
          return;
        }
        if (Range.isRange(at2)) {
          if (!hanging) {
            at2 = Editor.unhangRange(editor, at2, {
              voids
            });
          }
          if (Range.isCollapsed(at2)) {
            at2 = at2.anchor;
          } else {
            var [, end2] = Range.edges(at2);
            if (!voids && Editor.void(editor, {
              at: end2
            })) {
              return;
            }
            var pointRef3 = Editor.pointRef(editor, end2);
            Transforms.delete(editor, {
              at: at2
            });
            at2 = pointRef3.unref();
          }
        } else if (Path.isPath(at2)) {
          at2 = Editor.start(editor, at2);
        }
        if (!voids && Editor.void(editor, {
          at: at2
        })) {
          return;
        }
        var inlineElementMatch = Editor.above(editor, {
          at: at2,
          match: (n4) => Element2.isElement(n4) && Editor.isInline(editor, n4),
          mode: "highest",
          voids
        });
        if (inlineElementMatch) {
          var [, _inlinePath] = inlineElementMatch;
          if (Editor.isEnd(editor, at2, _inlinePath)) {
            var after3 = Editor.after(editor, _inlinePath);
            at2 = after3;
          } else if (Editor.isStart(editor, at2, _inlinePath)) {
            var before3 = Editor.before(editor, _inlinePath);
            at2 = before3;
          }
        }
        var blockMatch = Editor.above(editor, {
          match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
          at: at2,
          voids
        });
        var [, blockPath] = blockMatch;
        var isBlockStart = Editor.isStart(editor, at2, blockPath);
        var isBlockEnd = Editor.isEnd(editor, at2, blockPath);
        var isBlockEmpty = isBlockStart && isBlockEnd;
        var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
        var mergeEnd = !isBlockEnd;
        var [, firstPath] = Node2.first({
          children: fragment2
        }, []);
        var [, lastPath] = Node2.last({
          children: fragment2
        }, []);
        var matches = [];
        var matcher = (_ref2) => {
          var [n4, p2] = _ref2;
          var isRoot = p2.length === 0;
          if (isRoot) {
            return false;
          }
          if (isBlockEmpty) {
            return true;
          }
          if (mergeStart && Path.isAncestor(p2, firstPath) && Element2.isElement(n4) && !editor.isVoid(n4) && !editor.isInline(n4)) {
            return false;
          }
          if (mergeEnd && Path.isAncestor(p2, lastPath) && Element2.isElement(n4) && !editor.isVoid(n4) && !editor.isInline(n4)) {
            return false;
          }
          return true;
        };
        for (var entry of Node2.nodes({
          children: fragment2
        }, {
          pass: matcher
        })) {
          if (matcher(entry)) {
            matches.push(entry);
          }
        }
        var starts = [];
        var middles = [];
        var ends = [];
        var starting = true;
        var hasBlocks2 = false;
        for (var [node5] of matches) {
          if (Element2.isElement(node5) && !editor.isInline(node5)) {
            starting = false;
            hasBlocks2 = true;
            middles.push(node5);
          } else if (starting) {
            starts.push(node5);
          } else {
            ends.push(node5);
          }
        }
        var [inlineMatch] = Editor.nodes(editor, {
          at: at2,
          match: (n4) => Text.isText(n4) || Editor.isInline(editor, n4),
          mode: "highest",
          voids
        });
        var [, inlinePath] = inlineMatch;
        var isInlineStart = Editor.isStart(editor, at2, inlinePath);
        var isInlineEnd = Editor.isEnd(editor, at2, inlinePath);
        var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
        var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
        Transforms.splitNodes(editor, {
          at: at2,
          match: (n4) => hasBlocks2 ? Element2.isElement(n4) && Editor.isBlock(editor, n4) : Text.isText(n4) || Editor.isInline(editor, n4),
          mode: hasBlocks2 ? "lowest" : "highest",
          always: hasBlocks2 && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
          voids
        });
        var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
        Transforms.insertNodes(editor, starts, {
          at: startRef.current,
          match: (n4) => Text.isText(n4) || Editor.isInline(editor, n4),
          mode: "highest",
          voids
        });
        if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
          Transforms.delete(editor, {
            at: blockPath,
            voids
          });
        }
        Transforms.insertNodes(editor, middles, {
          at: middleRef.current,
          match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
          mode: "lowest",
          voids
        });
        Transforms.insertNodes(editor, ends, {
          at: endRef.current,
          match: (n4) => Text.isText(n4) || Editor.isInline(editor, n4),
          mode: "highest",
          voids
        });
        if (!options.at) {
          var path3;
          if (ends.length > 0 && endRef.current) {
            path3 = Path.previous(endRef.current);
          } else if (middles.length > 0 && middleRef.current) {
            path3 = Path.previous(middleRef.current);
          } else if (startRef.current) {
            path3 = Path.previous(startRef.current);
          }
          if (path3) {
            var _end = Editor.end(editor, path3);
            Transforms.select(editor, _end);
          }
        }
        startRef.unref();
        middleRef.unref();
        endRef.unref();
      });
    };
    collapse = function collapse2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        edge = "anchor"
      } = options;
      var {
        selection
      } = editor;
      if (!selection) {
        return;
      } else if (edge === "anchor") {
        Transforms.select(editor, selection.anchor);
      } else if (edge === "focus") {
        Transforms.select(editor, selection.focus);
      } else if (edge === "start") {
        var [start2] = Range.edges(selection);
        Transforms.select(editor, start2);
      } else if (edge === "end") {
        var [, end2] = Range.edges(selection);
        Transforms.select(editor, end2);
      }
    };
    deselect = (editor) => {
      var {
        selection
      } = editor;
      if (selection) {
        editor.apply({
          type: "set_selection",
          properties: selection,
          newProperties: null
        });
      }
    };
    move = function move2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        selection
      } = editor;
      var {
        distance = 1,
        unit = "character",
        reverse = false
      } = options;
      var {
        edge = null
      } = options;
      if (!selection) {
        return;
      }
      if (edge === "start") {
        edge = Range.isBackward(selection) ? "focus" : "anchor";
      }
      if (edge === "end") {
        edge = Range.isBackward(selection) ? "anchor" : "focus";
      }
      var {
        anchor,
        focus: focus2
      } = selection;
      var opts = {
        distance,
        unit,
        ignoreNonSelectable: true
      };
      var props = {};
      if (edge == null || edge === "anchor") {
        var point3 = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
        if (point3) {
          props.anchor = point3;
        }
      }
      if (edge == null || edge === "focus") {
        var _point = reverse ? Editor.before(editor, focus2, opts) : Editor.after(editor, focus2, opts);
        if (_point) {
          props.focus = _point;
        }
      }
      Transforms.setSelection(editor, props);
    };
    select2 = (editor, target) => {
      var {
        selection
      } = editor;
      target = Editor.range(editor, target);
      if (selection) {
        Transforms.setSelection(editor, target);
        return;
      }
      if (!Range.isRange(target)) {
        throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
      }
      editor.apply({
        type: "set_selection",
        properties: selection,
        newProperties: target
      });
    };
    setPoint = function setPoint2(editor, props) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var {
        selection
      } = editor;
      var {
        edge = "both"
      } = options;
      if (!selection) {
        return;
      }
      if (edge === "start") {
        edge = Range.isBackward(selection) ? "focus" : "anchor";
      }
      if (edge === "end") {
        edge = Range.isBackward(selection) ? "anchor" : "focus";
      }
      var {
        anchor,
        focus: focus2
      } = selection;
      var point3 = edge === "anchor" ? anchor : focus2;
      Transforms.setSelection(editor, {
        [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point3), props)
      });
    };
    setSelection = (editor, props) => {
      var {
        selection
      } = editor;
      var oldProps = {};
      var newProps = {};
      if (!selection) {
        return;
      }
      for (var k3 in props) {
        if (k3 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k3 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k3 !== "anchor" && k3 !== "focus" && props[k3] !== selection[k3]) {
          oldProps[k3] = selection[k3];
          newProps[k3] = props[k3];
        }
      }
      if (Object.keys(oldProps).length > 0) {
        editor.apply({
          type: "set_selection",
          properties: oldProps,
          newProperties: newProps
        });
      }
    };
    insertNodes = function insertNodes2(editor, nodes2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          hanging = false,
          voids = false,
          mode = "lowest"
        } = options;
        var {
          at: at2,
          match: match5,
          select: select3
        } = options;
        if (Node2.isNode(nodes2)) {
          nodes2 = [nodes2];
        }
        if (nodes2.length === 0) {
          return;
        }
        var [node5] = nodes2;
        if (!at2) {
          at2 = getDefaultInsertLocation(editor);
          select3 = true;
        }
        if (select3 == null) {
          select3 = false;
        }
        if (Range.isRange(at2)) {
          if (!hanging) {
            at2 = Editor.unhangRange(editor, at2, {
              voids
            });
          }
          if (Range.isCollapsed(at2)) {
            at2 = at2.anchor;
          } else {
            var [, end2] = Range.edges(at2);
            var pointRef3 = Editor.pointRef(editor, end2);
            Transforms.delete(editor, {
              at: at2
            });
            at2 = pointRef3.unref();
          }
        }
        if (Point.isPoint(at2)) {
          if (match5 == null) {
            if (Text.isText(node5)) {
              match5 = (n4) => Text.isText(n4);
            } else if (editor.isInline(node5)) {
              match5 = (n4) => Text.isText(n4) || Editor.isInline(editor, n4);
            } else {
              match5 = (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
            }
          }
          var [entry] = Editor.nodes(editor, {
            at: at2.path,
            match: match5,
            mode,
            voids
          });
          if (entry) {
            var [, matchPath2] = entry;
            var pathRef3 = Editor.pathRef(editor, matchPath2);
            var isAtEnd = Editor.isEnd(editor, at2, matchPath2);
            Transforms.splitNodes(editor, {
              at: at2,
              match: match5,
              mode,
              voids
            });
            var path3 = pathRef3.unref();
            at2 = isAtEnd ? Path.next(path3) : path3;
          } else {
            return;
          }
        }
        var parentPath = Path.parent(at2);
        var index3 = at2[at2.length - 1];
        if (!voids && Editor.void(editor, {
          at: parentPath
        })) {
          return;
        }
        for (var _node of nodes2) {
          var _path = parentPath.concat(index3);
          index3++;
          editor.apply({
            type: "insert_node",
            path: _path,
            node: _node
          });
          at2 = Path.next(at2);
        }
        at2 = Path.previous(at2);
        if (select3) {
          var point3 = Editor.end(editor, at2);
          if (point3) {
            Transforms.select(editor, point3);
          }
        }
      });
    };
    liftNodes = function liftNodes2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          at: at2 = editor.selection,
          mode = "lowest",
          voids = false
        } = options;
        var {
          match: match5
        } = options;
        if (match5 == null) {
          match5 = Path.isPath(at2) ? matchPath(editor, at2) : (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
        }
        if (!at2) {
          return;
        }
        var matches = Editor.nodes(editor, {
          at: at2,
          match: match5,
          mode,
          voids
        });
        var pathRefs2 = Array.from(matches, (_ref2) => {
          var [, p2] = _ref2;
          return Editor.pathRef(editor, p2);
        });
        for (var pathRef3 of pathRefs2) {
          var path3 = pathRef3.unref();
          if (path3.length < 2) {
            throw new Error("Cannot lift node at a path [".concat(path3, "] because it has a depth of less than `2`."));
          }
          var parentNodeEntry = Editor.node(editor, Path.parent(path3));
          var [parent3, parentPath] = parentNodeEntry;
          var index3 = path3[path3.length - 1];
          var {
            length: length2
          } = parent3.children;
          if (length2 === 1) {
            var toPath = Path.next(parentPath);
            Transforms.moveNodes(editor, {
              at: path3,
              to: toPath,
              voids
            });
            Transforms.removeNodes(editor, {
              at: parentPath,
              voids
            });
          } else if (index3 === 0) {
            Transforms.moveNodes(editor, {
              at: path3,
              to: parentPath,
              voids
            });
          } else if (index3 === length2 - 1) {
            var _toPath = Path.next(parentPath);
            Transforms.moveNodes(editor, {
              at: path3,
              to: _toPath,
              voids
            });
          } else {
            var splitPath = Path.next(path3);
            var _toPath2 = Path.next(parentPath);
            Transforms.splitNodes(editor, {
              at: splitPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: path3,
              to: _toPath2,
              voids
            });
          }
        }
      });
    };
    _excluded = ["text"];
    _excluded2 = ["children"];
    hasSingleChildNest = (editor, node5) => {
      if (Element2.isElement(node5)) {
        var element = node5;
        if (Editor.isVoid(editor, node5)) {
          return true;
        } else if (element.children.length === 1) {
          return hasSingleChildNest(editor, element.children[0]);
        } else {
          return false;
        }
      } else if (Editor.isEditor(node5)) {
        return false;
      } else {
        return true;
      }
    };
    mergeNodes = function mergeNodes2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          match: match5,
          at: at2 = editor.selection
        } = options;
        var {
          hanging = false,
          voids = false,
          mode = "lowest"
        } = options;
        if (!at2) {
          return;
        }
        if (match5 == null) {
          if (Path.isPath(at2)) {
            var [parent3] = Editor.parent(editor, at2);
            match5 = (n4) => parent3.children.includes(n4);
          } else {
            match5 = (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
          }
        }
        if (!hanging && Range.isRange(at2)) {
          at2 = Editor.unhangRange(editor, at2, {
            voids
          });
        }
        if (Range.isRange(at2)) {
          if (Range.isCollapsed(at2)) {
            at2 = at2.anchor;
          } else {
            var [, end2] = Range.edges(at2);
            var pointRef3 = Editor.pointRef(editor, end2);
            Transforms.delete(editor, {
              at: at2
            });
            at2 = pointRef3.unref();
            if (options.at == null) {
              Transforms.select(editor, at2);
            }
          }
        }
        var [current2] = Editor.nodes(editor, {
          at: at2,
          match: match5,
          voids,
          mode
        });
        var prev2 = Editor.previous(editor, {
          at: at2,
          match: match5,
          voids,
          mode
        });
        if (!current2 || !prev2) {
          return;
        }
        var [node5, path3] = current2;
        var [prevNode, prevPath] = prev2;
        if (path3.length === 0 || prevPath.length === 0) {
          return;
        }
        var newPath = Path.next(prevPath);
        var commonPath = Path.common(path3, prevPath);
        var isPreviousSibling = Path.isSibling(path3, prevPath);
        var levels2 = Array.from(Editor.levels(editor, {
          at: path3
        }), (_ref2) => {
          var [n4] = _ref2;
          return n4;
        }).slice(commonPath.length).slice(0, -1);
        var emptyAncestor = Editor.above(editor, {
          at: path3,
          mode: "highest",
          match: (n4) => levels2.includes(n4) && hasSingleChildNest(editor, n4)
        });
        var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
        var properties2;
        var position3;
        if (Text.isText(node5) && Text.isText(prevNode)) {
          var rest = _objectWithoutProperties(node5, _excluded);
          position3 = prevNode.text.length;
          properties2 = rest;
        } else if (Element2.isElement(node5) && Element2.isElement(prevNode)) {
          var rest = _objectWithoutProperties(node5, _excluded2);
          position3 = prevNode.children.length;
          properties2 = rest;
        } else {
          throw new Error("Cannot merge the node at path [".concat(path3, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node5), " ").concat(Scrubber.stringify(prevNode)));
        }
        if (!isPreviousSibling) {
          Transforms.moveNodes(editor, {
            at: path3,
            to: newPath,
            voids
          });
        }
        if (emptyRef) {
          Transforms.removeNodes(editor, {
            at: emptyRef.current,
            voids
          });
        }
        if (Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
          Transforms.removeNodes(editor, {
            at: prevPath,
            voids
          });
        } else {
          editor.apply({
            type: "merge_node",
            path: newPath,
            position: position3,
            properties: properties2
          });
        }
        if (emptyRef) {
          emptyRef.unref();
        }
      });
    };
    moveNodes = (editor, options) => {
      Editor.withoutNormalizing(editor, () => {
        var {
          to: to2,
          at: at2 = editor.selection,
          mode = "lowest",
          voids = false
        } = options;
        var {
          match: match5
        } = options;
        if (!at2) {
          return;
        }
        if (match5 == null) {
          match5 = Path.isPath(at2) ? matchPath(editor, at2) : (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
        }
        var toRef = Editor.pathRef(editor, to2);
        var targets = Editor.nodes(editor, {
          at: at2,
          match: match5,
          mode,
          voids
        });
        var pathRefs2 = Array.from(targets, (_ref2) => {
          var [, p2] = _ref2;
          return Editor.pathRef(editor, p2);
        });
        for (var pathRef3 of pathRefs2) {
          var path3 = pathRef3.unref();
          var newPath = toRef.current;
          if (path3.length !== 0) {
            editor.apply({
              type: "move_node",
              path: path3,
              newPath
            });
          }
          if (toRef.current && Path.isSibling(newPath, path3) && Path.isAfter(newPath, path3)) {
            toRef.current = Path.next(toRef.current);
          }
        }
        toRef.unref();
      });
    };
    removeNodes = function removeNodes2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          hanging = false,
          voids = false,
          mode = "lowest"
        } = options;
        var {
          at: at2 = editor.selection,
          match: match5
        } = options;
        if (!at2) {
          return;
        }
        if (match5 == null) {
          match5 = Path.isPath(at2) ? matchPath(editor, at2) : (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
        }
        if (!hanging && Range.isRange(at2)) {
          at2 = Editor.unhangRange(editor, at2, {
            voids
          });
        }
        var depths = Editor.nodes(editor, {
          at: at2,
          match: match5,
          mode,
          voids
        });
        var pathRefs2 = Array.from(depths, (_ref2) => {
          var [, p2] = _ref2;
          return Editor.pathRef(editor, p2);
        });
        for (var pathRef3 of pathRefs2) {
          var path3 = pathRef3.unref();
          if (path3) {
            var [node5] = Editor.node(editor, path3);
            editor.apply({
              type: "remove_node",
              path: path3,
              node: node5
            });
          }
        }
      });
    };
    setNodes = function setNodes2(editor, props) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          match: match5,
          at: at2 = editor.selection,
          compare,
          merge: merge3
        } = options;
        var {
          hanging = false,
          mode = "lowest",
          split = false,
          voids = false
        } = options;
        if (!at2) {
          return;
        }
        if (match5 == null) {
          match5 = Path.isPath(at2) ? matchPath(editor, at2) : (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
        }
        if (!hanging && Range.isRange(at2)) {
          at2 = Editor.unhangRange(editor, at2, {
            voids
          });
        }
        if (split && Range.isRange(at2)) {
          if (Range.isCollapsed(at2) && Editor.leaf(editor, at2.anchor)[0].text.length > 0) {
            return;
          }
          var rangeRef3 = Editor.rangeRef(editor, at2, {
            affinity: "inward"
          });
          var [start2, end2] = Range.edges(at2);
          var splitMode = mode === "lowest" ? "lowest" : "highest";
          var endAtEndOfNode = Editor.isEnd(editor, end2, end2.path);
          Transforms.splitNodes(editor, {
            at: end2,
            match: match5,
            mode: splitMode,
            voids,
            always: !endAtEndOfNode
          });
          var startAtStartOfNode = Editor.isStart(editor, start2, start2.path);
          Transforms.splitNodes(editor, {
            at: start2,
            match: match5,
            mode: splitMode,
            voids,
            always: !startAtStartOfNode
          });
          at2 = rangeRef3.unref();
          if (options.at == null) {
            Transforms.select(editor, at2);
          }
        }
        if (!compare) {
          compare = (prop, nodeProp) => prop !== nodeProp;
        }
        for (var [node5, path3] of Editor.nodes(editor, {
          at: at2,
          match: match5,
          mode,
          voids
        })) {
          var properties2 = {};
          var newProperties = {};
          if (path3.length === 0) {
            continue;
          }
          var hasChanges = false;
          for (var k3 in props) {
            if (k3 === "children" || k3 === "text") {
              continue;
            }
            if (compare(props[k3], node5[k3])) {
              hasChanges = true;
              if (node5.hasOwnProperty(k3))
                properties2[k3] = node5[k3];
              if (merge3) {
                if (props[k3] != null)
                  newProperties[k3] = merge3(node5[k3], props[k3]);
              } else {
                if (props[k3] != null)
                  newProperties[k3] = props[k3];
              }
            }
          }
          if (hasChanges) {
            editor.apply({
              type: "set_node",
              path: path3,
              properties: properties2,
              newProperties
            });
          }
        }
      });
    };
    deleteRange = (editor, range3) => {
      if (Range.isCollapsed(range3)) {
        return range3.anchor;
      } else {
        var [, end2] = Range.edges(range3);
        var pointRef3 = Editor.pointRef(editor, end2);
        Transforms.delete(editor, {
          at: range3
        });
        return pointRef3.unref();
      }
    };
    splitNodes = function splitNodes2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          mode = "lowest",
          voids = false
        } = options;
        var {
          match: match5,
          at: at2 = editor.selection,
          height = 0,
          always = false
        } = options;
        if (match5 == null) {
          match5 = (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
        }
        if (Range.isRange(at2)) {
          at2 = deleteRange(editor, at2);
        }
        if (Path.isPath(at2)) {
          var path3 = at2;
          var point3 = Editor.point(editor, path3);
          var [parent3] = Editor.parent(editor, path3);
          match5 = (n4) => n4 === parent3;
          height = point3.path.length - path3.length + 1;
          at2 = point3;
          always = true;
        }
        if (!at2) {
          return;
        }
        var beforeRef = Editor.pointRef(editor, at2, {
          affinity: "backward"
        });
        var afterRef;
        try {
          var [highest] = Editor.nodes(editor, {
            at: at2,
            match: match5,
            mode,
            voids
          });
          if (!highest) {
            return;
          }
          var voidMatch = Editor.void(editor, {
            at: at2,
            mode: "highest"
          });
          var nudge = 0;
          if (!voids && voidMatch) {
            var [voidNode, voidPath] = voidMatch;
            if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {
              var after3 = Editor.after(editor, voidPath);
              if (!after3) {
                var text = {
                  text: ""
                };
                var afterPath = Path.next(voidPath);
                Transforms.insertNodes(editor, text, {
                  at: afterPath,
                  voids
                });
                after3 = Editor.point(editor, afterPath);
              }
              at2 = after3;
              always = true;
            }
            var siblingHeight = at2.path.length - voidPath.length;
            height = siblingHeight + 1;
            always = true;
          }
          afterRef = Editor.pointRef(editor, at2);
          var depth = at2.path.length - height;
          var [, highestPath] = highest;
          var lowestPath = at2.path.slice(0, depth);
          var position3 = height === 0 ? at2.offset : at2.path[depth] + nudge;
          for (var [node5, _path] of Editor.levels(editor, {
            at: lowestPath,
            reverse: true,
            voids
          })) {
            var split = false;
            if (_path.length < highestPath.length || _path.length === 0 || !voids && Element2.isElement(node5) && Editor.isVoid(editor, node5)) {
              break;
            }
            var _point = beforeRef.current;
            var isEnd2 = Editor.isEnd(editor, _point, _path);
            if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {
              split = true;
              var properties2 = Node2.extractProps(node5);
              editor.apply({
                type: "split_node",
                path: _path,
                position: position3,
                properties: properties2
              });
            }
            position3 = _path[_path.length - 1] + (split || isEnd2 ? 1 : 0);
          }
          if (options.at == null) {
            var _point2 = afterRef.current || Editor.end(editor, []);
            Transforms.select(editor, _point2);
          }
        } finally {
          var _afterRef;
          beforeRef.unref();
          (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();
        }
      });
    };
    unsetNodes = function unsetNodes2(editor, props) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!Array.isArray(props)) {
        props = [props];
      }
      var obj = {};
      for (var key2 of props) {
        obj[key2] = null;
      }
      Transforms.setNodes(editor, obj, options);
    };
    unwrapNodes = function unwrapNodes2(editor) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          mode = "lowest",
          split = false,
          voids = false
        } = options;
        var {
          at: at2 = editor.selection,
          match: match5
        } = options;
        if (!at2) {
          return;
        }
        if (match5 == null) {
          match5 = Path.isPath(at2) ? matchPath(editor, at2) : (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
        }
        if (Path.isPath(at2)) {
          at2 = Editor.range(editor, at2);
        }
        var rangeRef3 = Range.isRange(at2) ? Editor.rangeRef(editor, at2) : null;
        var matches = Editor.nodes(editor, {
          at: at2,
          match: match5,
          mode,
          voids
        });
        var pathRefs2 = Array.from(
          matches,
          (_ref2) => {
            var [, p2] = _ref2;
            return Editor.pathRef(editor, p2);
          }
          // unwrapNode will call liftNode which does not support splitting the node when nested.
          // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
          // that wrap target node. So we reverse the order.
        ).reverse();
        var _loop = function _loop2() {
          var path3 = pathRef3.unref();
          var [node5] = Editor.node(editor, path3);
          var range3 = Editor.range(editor, path3);
          if (split && rangeRef3) {
            range3 = Range.intersection(rangeRef3.current, range3);
          }
          Transforms.liftNodes(editor, {
            at: range3,
            match: (n4) => Element2.isAncestor(node5) && node5.children.includes(n4),
            voids
          });
        };
        for (var pathRef3 of pathRefs2) {
          _loop();
        }
        if (rangeRef3) {
          rangeRef3.unref();
        }
      });
    };
    wrapNodes = function wrapNodes2(editor, element) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      Editor.withoutNormalizing(editor, () => {
        var {
          mode = "lowest",
          split = false,
          voids = false
        } = options;
        var {
          match: match5,
          at: at2 = editor.selection
        } = options;
        if (!at2) {
          return;
        }
        if (match5 == null) {
          if (Path.isPath(at2)) {
            match5 = matchPath(editor, at2);
          } else if (editor.isInline(element)) {
            match5 = (n4) => Element2.isElement(n4) && Editor.isInline(editor, n4) || Text.isText(n4);
          } else {
            match5 = (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4);
          }
        }
        if (split && Range.isRange(at2)) {
          var [start2, end2] = Range.edges(at2);
          var rangeRef3 = Editor.rangeRef(editor, at2, {
            affinity: "inward"
          });
          Transforms.splitNodes(editor, {
            at: end2,
            match: match5,
            voids
          });
          Transforms.splitNodes(editor, {
            at: start2,
            match: match5,
            voids
          });
          at2 = rangeRef3.unref();
          if (options.at == null) {
            Transforms.select(editor, at2);
          }
        }
        var roots = Array.from(Editor.nodes(editor, {
          at: at2,
          match: editor.isInline(element) ? (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4) : (n4) => Editor.isEditor(n4),
          mode: "lowest",
          voids
        }));
        var _loop = function _loop2() {
          var a5 = Range.isRange(at2) ? Range.intersection(at2, Editor.range(editor, rootPath)) : at2;
          if (!a5) {
            return 0;
          }
          var matches = Array.from(Editor.nodes(editor, {
            at: a5,
            match: match5,
            mode,
            voids
          }));
          if (matches.length > 0) {
            var [first3] = matches;
            var last5 = matches[matches.length - 1];
            var [, firstPath] = first3;
            var [, lastPath] = last5;
            if (firstPath.length === 0 && lastPath.length === 0) {
              return 0;
            }
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range3 = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));
            var wrapper = _objectSpread(_objectSpread({}, element), {}, {
              children: []
            });
            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range3,
              match: (n4) => Element2.isAncestor(commonNode) && commonNode.children.includes(n4),
              to: wrapperPath.concat(0),
              voids
            });
          }
        }, _ret;
        for (var [, rootPath] of roots) {
          _ret = _loop();
          if (_ret === 0)
            continue;
        }
      });
    };
    createEditor = () => {
      var editor = {
        children: [],
        operations: [],
        selection: null,
        marks: null,
        isElementReadOnly: () => false,
        isInline: () => false,
        isSelectable: () => true,
        isVoid: () => false,
        markableVoid: () => false,
        onChange: () => {
        },
        // Core
        apply: function apply$1() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return apply(editor, ...args);
        },
        // Editor
        addMark: function addMark$1() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return addMark(editor, ...args);
        },
        deleteBackward: function deleteBackward$1() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return deleteBackward(editor, ...args);
        },
        deleteForward: function deleteForward$1() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return deleteForward(editor, ...args);
        },
        deleteFragment: function deleteFragment$1() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          return deleteFragment(editor, ...args);
        },
        getFragment: function getFragment$1() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          return getFragment(editor, ...args);
        },
        insertBreak: function insertBreak$1() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          return insertBreak(editor, ...args);
        },
        insertSoftBreak: function insertSoftBreak$1() {
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          return insertSoftBreak(editor, ...args);
        },
        insertFragment: function insertFragment$1() {
          for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
          }
          return insertFragment(editor, ...args);
        },
        insertNode: function insertNode$1() {
          for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            args[_key10] = arguments[_key10];
          }
          return insertNode(editor, ...args);
        },
        insertText: function insertText$1() {
          for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
            args[_key11] = arguments[_key11];
          }
          return insertText(editor, ...args);
        },
        normalizeNode: function normalizeNode$1() {
          for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
            args[_key12] = arguments[_key12];
          }
          return normalizeNode(editor, ...args);
        },
        removeMark: function removeMark$1() {
          for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
            args[_key13] = arguments[_key13];
          }
          return removeMark(editor, ...args);
        },
        getDirtyPaths: function getDirtyPaths$1() {
          for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
            args[_key14] = arguments[_key14];
          }
          return getDirtyPaths(editor, ...args);
        },
        shouldNormalize: function shouldNormalize$1() {
          for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
            args[_key15] = arguments[_key15];
          }
          return shouldNormalize(editor, ...args);
        },
        // Editor interface
        above: function above$1() {
          for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
            args[_key16] = arguments[_key16];
          }
          return above(editor, ...args);
        },
        after: function after$1() {
          for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
            args[_key17] = arguments[_key17];
          }
          return after(editor, ...args);
        },
        before: function before$1() {
          for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
            args[_key18] = arguments[_key18];
          }
          return before(editor, ...args);
        },
        collapse: function collapse$1() {
          for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
            args[_key19] = arguments[_key19];
          }
          return collapse(editor, ...args);
        },
        delete: function _delete() {
          for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
            args[_key20] = arguments[_key20];
          }
          return deleteText(editor, ...args);
        },
        deselect: function deselect$1() {
          for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
            args[_key21] = arguments[_key21];
          }
          return deselect(editor, ...args);
        },
        edges: function edges$1() {
          for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
            args[_key22] = arguments[_key22];
          }
          return edges(editor, ...args);
        },
        elementReadOnly: function elementReadOnly$1() {
          for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
            args[_key23] = arguments[_key23];
          }
          return elementReadOnly(editor, ...args);
        },
        end: function end$1() {
          for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
            args[_key24] = arguments[_key24];
          }
          return end(editor, ...args);
        },
        first: function first$1() {
          for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
            args[_key25] = arguments[_key25];
          }
          return first2(editor, ...args);
        },
        fragment: function fragment$1() {
          for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
            args[_key26] = arguments[_key26];
          }
          return fragment(editor, ...args);
        },
        getMarks: function getMarks() {
          for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
            args[_key27] = arguments[_key27];
          }
          return marks(editor, ...args);
        },
        hasBlocks: function hasBlocks$1() {
          for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
            args[_key28] = arguments[_key28];
          }
          return hasBlocks(editor, ...args);
        },
        hasInlines: function hasInlines$1() {
          for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
            args[_key29] = arguments[_key29];
          }
          return hasInlines(editor, ...args);
        },
        hasPath: function hasPath$1() {
          for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
            args[_key30] = arguments[_key30];
          }
          return hasPath2(editor, ...args);
        },
        hasTexts: function hasTexts$1() {
          for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
            args[_key31] = arguments[_key31];
          }
          return hasTexts(editor, ...args);
        },
        insertNodes: function insertNodes$1() {
          for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
            args[_key32] = arguments[_key32];
          }
          return insertNodes(editor, ...args);
        },
        isBlock: function isBlock$1() {
          for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
            args[_key33] = arguments[_key33];
          }
          return isBlock(editor, ...args);
        },
        isEdge: function isEdge$1() {
          for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
            args[_key34] = arguments[_key34];
          }
          return isEdge(editor, ...args);
        },
        isEmpty: function isEmpty$1() {
          for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
            args[_key35] = arguments[_key35];
          }
          return isEmpty2(editor, ...args);
        },
        isEnd: function isEnd$1() {
          for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
            args[_key36] = arguments[_key36];
          }
          return isEnd(editor, ...args);
        },
        isNormalizing: function isNormalizing$1() {
          for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
            args[_key37] = arguments[_key37];
          }
          return isNormalizing(editor, ...args);
        },
        isStart: function isStart$1() {
          for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
            args[_key38] = arguments[_key38];
          }
          return isStart(editor, ...args);
        },
        last: function last$1() {
          for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
            args[_key39] = arguments[_key39];
          }
          return last4(editor, ...args);
        },
        leaf: function leaf$1() {
          for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
            args[_key40] = arguments[_key40];
          }
          return leaf(editor, ...args);
        },
        levels: function levels$1() {
          for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
            args[_key41] = arguments[_key41];
          }
          return levels(editor, ...args);
        },
        liftNodes: function liftNodes$1() {
          for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
            args[_key42] = arguments[_key42];
          }
          return liftNodes(editor, ...args);
        },
        mergeNodes: function mergeNodes$1() {
          for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
            args[_key43] = arguments[_key43];
          }
          return mergeNodes(editor, ...args);
        },
        move: function move$1() {
          for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
            args[_key44] = arguments[_key44];
          }
          return move(editor, ...args);
        },
        moveNodes: function moveNodes$1() {
          for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
            args[_key45] = arguments[_key45];
          }
          return moveNodes(editor, ...args);
        },
        next: function next$1() {
          for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
            args[_key46] = arguments[_key46];
          }
          return next2(editor, ...args);
        },
        node: function node$1() {
          for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
            args[_key47] = arguments[_key47];
          }
          return node3(editor, ...args);
        },
        nodes: function nodes$1() {
          for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
            args[_key48] = arguments[_key48];
          }
          return nodes(editor, ...args);
        },
        normalize: function normalize$1() {
          for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
            args[_key49] = arguments[_key49];
          }
          return normalize2(editor, ...args);
        },
        parent: function parent$1() {
          for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
            args[_key50] = arguments[_key50];
          }
          return parent(editor, ...args);
        },
        path: function path$1() {
          for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
            args[_key51] = arguments[_key51];
          }
          return path(editor, ...args);
        },
        pathRef: function pathRef$1() {
          for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
            args[_key52] = arguments[_key52];
          }
          return pathRef(editor, ...args);
        },
        pathRefs: function pathRefs$1() {
          for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
            args[_key53] = arguments[_key53];
          }
          return pathRefs(editor, ...args);
        },
        point: function point$1() {
          for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
            args[_key54] = arguments[_key54];
          }
          return point(editor, ...args);
        },
        pointRef: function pointRef$1() {
          for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {
            args[_key55] = arguments[_key55];
          }
          return pointRef(editor, ...args);
        },
        pointRefs: function pointRefs$1() {
          for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {
            args[_key56] = arguments[_key56];
          }
          return pointRefs(editor, ...args);
        },
        positions: function positions$1() {
          for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {
            args[_key57] = arguments[_key57];
          }
          return positions(editor, ...args);
        },
        previous: function previous$1() {
          for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {
            args[_key58] = arguments[_key58];
          }
          return previous(editor, ...args);
        },
        range: function range$1() {
          for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {
            args[_key59] = arguments[_key59];
          }
          return range2(editor, ...args);
        },
        rangeRef: function rangeRef$1() {
          for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {
            args[_key60] = arguments[_key60];
          }
          return rangeRef(editor, ...args);
        },
        rangeRefs: function rangeRefs$1() {
          for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {
            args[_key61] = arguments[_key61];
          }
          return rangeRefs(editor, ...args);
        },
        removeNodes: function removeNodes$1() {
          for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {
            args[_key62] = arguments[_key62];
          }
          return removeNodes(editor, ...args);
        },
        select: function select$1() {
          for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {
            args[_key63] = arguments[_key63];
          }
          return select2(editor, ...args);
        },
        setNodes: function setNodes$1() {
          for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {
            args[_key64] = arguments[_key64];
          }
          return setNodes(editor, ...args);
        },
        setNormalizing: function setNormalizing$1() {
          for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {
            args[_key65] = arguments[_key65];
          }
          return setNormalizing(editor, ...args);
        },
        setPoint: function setPoint$1() {
          for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {
            args[_key66] = arguments[_key66];
          }
          return setPoint(editor, ...args);
        },
        setSelection: function setSelection$1() {
          for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {
            args[_key67] = arguments[_key67];
          }
          return setSelection(editor, ...args);
        },
        splitNodes: function splitNodes$1() {
          for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {
            args[_key68] = arguments[_key68];
          }
          return splitNodes(editor, ...args);
        },
        start: function start$1() {
          for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {
            args[_key69] = arguments[_key69];
          }
          return start(editor, ...args);
        },
        string: function string$1() {
          for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {
            args[_key70] = arguments[_key70];
          }
          return string2(editor, ...args);
        },
        unhangRange: function unhangRange$1() {
          for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {
            args[_key71] = arguments[_key71];
          }
          return unhangRange(editor, ...args);
        },
        unsetNodes: function unsetNodes$1() {
          for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {
            args[_key72] = arguments[_key72];
          }
          return unsetNodes(editor, ...args);
        },
        unwrapNodes: function unwrapNodes$1() {
          for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {
            args[_key73] = arguments[_key73];
          }
          return unwrapNodes(editor, ...args);
        },
        void: function _void() {
          for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {
            args[_key74] = arguments[_key74];
          }
          return getVoid(editor, ...args);
        },
        withoutNormalizing: function withoutNormalizing$1() {
          for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {
            args[_key75] = arguments[_key75];
          }
          return withoutNormalizing(editor, ...args);
        },
        wrapNodes: function wrapNodes$1() {
          for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {
            args[_key76] = arguments[_key76];
          }
          return wrapNodes(editor, ...args);
        }
      };
      return editor;
    };
  }
});

// node_modules/direction/index.js
var require_direction = __commonJS({
  "node_modules/direction/index.js"(exports, module2) {
    "use strict";
    module2.exports = direction;
    var RTL = "---";
    var LTR = "A-Za-z--------";
    var rtl = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var ltr = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    function direction(value) {
      value = String(value || "");
      if (rtl.test(value)) {
        return "rtl";
      }
      if (ltr.test(value)) {
        return "ltr";
      }
      return "neutral";
    }
  }
});

// node_modules/slate-react/node_modules/is-hotkey/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/slate-react/node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f3 = 1; f3 < 20; f3++) {
      CODES["f" + f3] = 111 + f3;
    }
    var f3;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string4) {
        return parseHotkey(string4, options);
      });
      var check = function check2(e5) {
        return array.some(function(object2) {
          return compareHotkey(object2, e5);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values = hotkey.split("+");
      var length2 = values.length;
      for (var k3 in MODIFIERS) {
        ret[MODIFIERS[k3]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var optional = value.endsWith("?") && value.length > 1;
          if (optional) {
            value = value.slice(0, -1);
          }
          var name = toKeyName(value);
          var modifier = MODIFIERS[name];
          if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name]) {
            throw new TypeError('Unknown modifier: "' + value + '"');
          }
          if (length2 === 1 || !modifier) {
            if (byKey) {
              ret.key = name;
            } else {
              ret.which = toKeyCode(value);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key2 in object2) {
        var expected = object2[key2];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key2 === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key2 === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key2];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name) {
      name = toKeyName(name);
      var code = CODES[name] || name.toUpperCase().charCodeAt(0);
      return code;
    }
    function toKeyName(name) {
      name = name.toLowerCase();
      name = ALIASES[name] || name;
      return name;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/slate-react/dist/index.es.js
var index_es_exports2 = {};
__export(index_es_exports2, {
  DefaultElement: () => DefaultElement,
  DefaultLeaf: () => DefaultLeaf,
  DefaultPlaceholder: () => DefaultPlaceholder,
  Editable: () => Editable,
  ReactEditor: () => ReactEditor,
  Slate: () => Slate,
  useEditor: () => useEditor,
  useFocused: () => useFocused,
  useReadOnly: () => useReadOnly,
  useSelected: () => useSelected,
  useSlate: () => useSlate,
  useSlateSelection: () => useSlateSelection,
  useSlateSelector: () => useSlateSelector,
  useSlateStatic: () => useSlateStatic,
  useSlateWithV: () => useSlateWithV,
  withReact: () => withReact
});
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key2 = sourceKeys[i4];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose3(source, excluded);
  var key2, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key2 = sourceSymbolKeys[i4];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _typeof3(o4) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof3(o4);
}
function _toPrimitive3(input, hint) {
  if (_typeof3(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof3(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey3(arg) {
  var key2 = _toPrimitive3(arg, "string");
  return _typeof3(key2) === "symbol" ? key2 : String(key2);
}
function _defineProperty3(obj, key2, value) {
  key2 = _toPropertyKey3(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function verifyDiffState(editor, textDiff) {
  var {
    path: path3,
    diff: diff2
  } = textDiff;
  if (!Editor.hasPath(editor, path3)) {
    return false;
  }
  var node5 = Node2.get(editor, path3);
  if (!Text.isText(node5)) {
    return false;
  }
  if (diff2.start !== node5.text.length || diff2.text.length === 0) {
    return node5.text.slice(diff2.start, diff2.start + diff2.text.length) === diff2.text;
  }
  var nextPath = Path.next(path3);
  if (!Editor.hasPath(editor, nextPath)) {
    return false;
  }
  var nextNode = Node2.get(editor, nextPath);
  return Text.isText(nextNode) && nextNode.text.startsWith(diff2.text);
}
function applyStringDiff(text) {
  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    diffs[_key - 1] = arguments[_key];
  }
  return diffs.reduce((text2, diff2) => text2.slice(0, diff2.start) + diff2.text + text2.slice(diff2.end), text);
}
function longestCommonPrefixLength(str, another) {
  var length2 = Math.min(str.length, another.length);
  for (var i4 = 0; i4 < length2; i4++) {
    if (str.charAt(i4) !== another.charAt(i4)) {
      return i4;
    }
  }
  return length2;
}
function longestCommonSuffixLength(str, another, max6) {
  var length2 = Math.min(str.length, another.length, max6);
  for (var i4 = 0; i4 < length2; i4++) {
    if (str.charAt(str.length - i4 - 1) !== another.charAt(another.length - i4 - 1)) {
      return i4;
    }
  }
  return length2;
}
function normalizeStringDiff(targetText, diff2) {
  var {
    start: start2,
    end: end2,
    text
  } = diff2;
  var removedText = targetText.slice(start2, end2);
  var prefixLength = longestCommonPrefixLength(removedText, text);
  var max6 = Math.min(removedText.length - prefixLength, text.length - prefixLength);
  var suffixLength = longestCommonSuffixLength(removedText, text, max6);
  var normalized = {
    start: start2 + prefixLength,
    end: end2 - suffixLength,
    text: text.slice(prefixLength, text.length - suffixLength)
  };
  if (normalized.start === normalized.end && normalized.text.length === 0) {
    return null;
  }
  return normalized;
}
function mergeStringDiffs(targetText, a5, b3) {
  var start2 = Math.min(a5.start, b3.start);
  var overlap = Math.max(0, Math.min(a5.start + a5.text.length, b3.end) - b3.start);
  var applied = applyStringDiff(targetText, a5, b3);
  var sliceEnd = Math.max(b3.start + b3.text.length, a5.start + a5.text.length + (a5.start + a5.text.length > b3.start ? b3.text.length : 0) - overlap);
  var text = applied.slice(start2, sliceEnd);
  var end2 = Math.max(a5.end, b3.end - a5.text.length + (a5.end - a5.start));
  return normalizeStringDiff(targetText, {
    start: start2,
    end: end2,
    text
  });
}
function targetRange(textDiff) {
  var {
    path: path3,
    diff: diff2
  } = textDiff;
  return {
    anchor: {
      path: path3,
      offset: diff2.start
    },
    focus: {
      path: path3,
      offset: diff2.end
    }
  };
}
function normalizePoint(editor, point3) {
  var {
    path: path3,
    offset: offset3
  } = point3;
  if (!Editor.hasPath(editor, path3)) {
    return null;
  }
  var leaf3 = Node2.get(editor, path3);
  if (!Text.isText(leaf3)) {
    return null;
  }
  var parentBlock = Editor.above(editor, {
    match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
    at: path3
  });
  if (!parentBlock) {
    return null;
  }
  while (offset3 > leaf3.text.length) {
    var entry = Editor.next(editor, {
      at: path3,
      match: Text.isText
    });
    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {
      return null;
    }
    offset3 -= leaf3.text.length;
    leaf3 = entry[0];
    path3 = entry[1];
  }
  return {
    path: path3,
    offset: offset3
  };
}
function normalizeRange(editor, range3) {
  var anchor = normalizePoint(editor, range3.anchor);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range3)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus2 = normalizePoint(editor, range3.focus);
  if (!focus2) {
    return null;
  }
  return {
    anchor,
    focus: focus2
  };
}
function transformPendingPoint(editor, point3, op) {
  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref2) => {
    var {
      path: path3
    } = _ref2;
    return Path.equals(path3, point3.path);
  });
  if (!textDiff || point3.offset <= textDiff.diff.start) {
    return Point.transform(point3, op, {
      affinity: "backward"
    });
  }
  var {
    diff: diff2
  } = textDiff;
  if (point3.offset <= diff2.start + diff2.text.length) {
    var _anchor = {
      path: point3.path,
      offset: diff2.start
    };
    var _transformed = Point.transform(_anchor, op, {
      affinity: "backward"
    });
    if (!_transformed) {
      return null;
    }
    return {
      path: _transformed.path,
      offset: _transformed.offset + point3.offset - diff2.start
    };
  }
  var anchor = {
    path: point3.path,
    offset: point3.offset - diff2.text.length + diff2.end - diff2.start
  };
  var transformed = Point.transform(anchor, op, {
    affinity: "backward"
  });
  if (!transformed) {
    return null;
  }
  if (op.type === "split_node" && Path.equals(op.path, point3.path) && anchor.offset < op.position && diff2.start < op.position) {
    return transformed;
  }
  return {
    path: transformed.path,
    offset: transformed.offset + diff2.text.length - diff2.end + diff2.start
  };
}
function transformPendingRange(editor, range3, op) {
  var anchor = transformPendingPoint(editor, range3.anchor, op);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range3)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus2 = transformPendingPoint(editor, range3.focus, op);
  if (!focus2) {
    return null;
  }
  return {
    anchor,
    focus: focus2
  };
}
function transformTextDiff(textDiff, op) {
  var {
    path: path3,
    diff: diff2,
    id: id2
  } = textDiff;
  switch (op.type) {
    case "insert_text": {
      if (!Path.equals(op.path, path3) || op.offset >= diff2.end) {
        return textDiff;
      }
      if (op.offset <= diff2.start) {
        return {
          diff: {
            start: op.text.length + diff2.start,
            end: op.text.length + diff2.end,
            text: diff2.text
          },
          id: id2,
          path: path3
        };
      }
      return {
        diff: {
          start: diff2.start,
          end: diff2.end + op.text.length,
          text: diff2.text
        },
        id: id2,
        path: path3
      };
    }
    case "remove_text": {
      if (!Path.equals(op.path, path3) || op.offset >= diff2.end) {
        return textDiff;
      }
      if (op.offset + op.text.length <= diff2.start) {
        return {
          diff: {
            start: diff2.start - op.text.length,
            end: diff2.end - op.text.length,
            text: diff2.text
          },
          id: id2,
          path: path3
        };
      }
      return {
        diff: {
          start: diff2.start,
          end: diff2.end - op.text.length,
          text: diff2.text
        },
        id: id2,
        path: path3
      };
    }
    case "split_node": {
      if (!Path.equals(op.path, path3) || op.position >= diff2.end) {
        return {
          diff: diff2,
          id: id2,
          path: Path.transform(path3, op, {
            affinity: "backward"
          })
        };
      }
      if (op.position > diff2.start) {
        return {
          diff: {
            start: diff2.start,
            end: Math.min(op.position, diff2.end),
            text: diff2.text
          },
          id: id2,
          path: path3
        };
      }
      return {
        diff: {
          start: diff2.start - op.position,
          end: diff2.end - op.position,
          text: diff2.text
        },
        id: id2,
        path: Path.transform(path3, op, {
          affinity: "forward"
        })
      };
    }
    case "merge_node": {
      if (!Path.equals(op.path, path3)) {
        return {
          diff: diff2,
          id: id2,
          path: Path.transform(path3, op)
        };
      }
      return {
        diff: {
          start: diff2.start + op.position,
          end: diff2.end + op.position,
          text: diff2.text
        },
        id: id2,
        path: Path.transform(path3, op)
      };
    }
  }
  var newPath = Path.transform(path3, op);
  if (!newPath) {
    return null;
  }
  return {
    diff: diff2,
    path: newPath,
    id: id2
  };
}
function ownKeys$62(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$62(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$62(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$62(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function createAndroidInputManager(_ref2) {
  var {
    editor,
    scheduleOnDOMSelectionChange,
    onDOMSelectionChange
  } = _ref2;
  var flushing = false;
  var compositionEndTimeoutId = null;
  var flushTimeoutId = null;
  var actionTimeoutId = null;
  var idCounter = 0;
  var insertPositionHint = false;
  var applyPendingSelection = () => {
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    if (pendingSelection) {
      var {
        selection
      } = editor;
      var normalized = normalizeRange(editor, pendingSelection);
      if (normalized && (!selection || !Range.equals(normalized, selection))) {
        Transforms.select(editor, normalized);
      }
    }
  };
  var performAction = () => {
    var action = EDITOR_TO_PENDING_ACTION.get(editor);
    EDITOR_TO_PENDING_ACTION.delete(editor);
    if (!action) {
      return;
    }
    if (action.at) {
      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);
      if (!target) {
        return;
      }
      var _targetRange = Editor.range(editor, target);
      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {
        Transforms.select(editor, target);
      }
    }
    action.run();
  };
  var flush = () => {
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    if (actionTimeoutId) {
      clearTimeout(actionTimeoutId);
      actionTimeoutId = null;
    }
    if (!hasPendingDiffs() && !hasPendingAction()) {
      applyPendingSelection();
      return;
    }
    if (!flushing) {
      flushing = true;
      setTimeout(() => flushing = false);
    }
    if (hasPendingAction()) {
      flushing = "action";
    }
    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {
      affinity: "forward"
    });
    EDITOR_TO_USER_MARKS.set(editor, editor.marks);
    debug("flush", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));
    var scheduleSelectionChange = hasPendingDiffs();
    var diff2;
    while (diff2 = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {
      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;
      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
      if (pendingMarks !== void 0) {
        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
        editor.marks = pendingMarks;
      }
      if (pendingMarks && insertPositionHint === false) {
        insertPositionHint = null;
      }
      var range3 = targetRange(diff2);
      if (!editor.selection || !Range.equals(editor.selection, range3)) {
        Transforms.select(editor, range3);
      }
      if (diff2.diff.text) {
        Editor.insertText(editor, diff2.diff.text);
      } else {
        Editor.deleteFragment(editor);
      }
      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref22) => {
        var {
          id: id2
        } = _ref22;
        return id2 !== diff2.id;
      }));
      if (!verifyDiffState(editor, diff2)) {
        scheduleSelectionChange = false;
        EDITOR_TO_PENDING_ACTION.delete(editor);
        EDITOR_TO_USER_MARKS.delete(editor);
        flushing = "action";
        EDITOR_TO_PENDING_SELECTION.delete(editor);
        scheduleOnDOMSelectionChange.cancel();
        onDOMSelectionChange.cancel();
        selectionRef === null || selectionRef === void 0 || selectionRef.unref();
      }
    }
    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {
      Transforms.select(editor, selection);
    }
    if (hasPendingAction()) {
      performAction();
      return;
    }
    if (scheduleSelectionChange) {
      scheduleOnDOMSelectionChange();
    }
    scheduleOnDOMSelectionChange.flush();
    onDOMSelectionChange.flush();
    applyPendingSelection();
    var userMarks = EDITOR_TO_USER_MARKS.get(editor);
    EDITOR_TO_USER_MARKS.delete(editor);
    if (userMarks !== void 0) {
      editor.marks = userMarks;
      editor.onChange();
    }
  };
  var handleCompositionEnd = (_event) => {
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
    }
    compositionEndTimeoutId = setTimeout(() => {
      IS_COMPOSING.set(editor, false);
      flush();
    }, RESOLVE_DELAY);
  };
  var handleCompositionStart = (_event) => {
    IS_COMPOSING.set(editor, true);
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
      compositionEndTimeoutId = null;
    }
  };
  var updatePlaceholderVisibility = function updatePlaceholderVisibility2() {
    var forceHide = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);
    if (!placeholderElement) {
      return;
    }
    if (hasPendingDiffs() || forceHide) {
      placeholderElement.style.display = "none";
      return;
    }
    placeholderElement.style.removeProperty("display");
  };
  var storeDiff = (path3, diff2) => {
    var _EDITOR_TO_PENDING_DI3;
    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];
    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);
    var target = Node2.leaf(editor, path3);
    var idx = pendingDiffs.findIndex((change) => Path.equals(change.path, path3));
    if (idx < 0) {
      var normalized = normalizeStringDiff(target.text, diff2);
      if (normalized) {
        pendingDiffs.push({
          path: path3,
          diff: diff2,
          id: idCounter++
        });
      }
      updatePlaceholderVisibility();
      return;
    }
    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff2);
    if (!merged) {
      pendingDiffs.splice(idx, 1);
      updatePlaceholderVisibility();
      return;
    }
    pendingDiffs[idx] = _objectSpread$62(_objectSpread$62({}, pendingDiffs[idx]), {}, {
      diff: merged
    });
  };
  var scheduleAction = function scheduleAction2(run) {
    var {
      at: at2
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    insertPositionHint = false;
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    scheduleOnDOMSelectionChange.cancel();
    onDOMSelectionChange.cancel();
    if (hasPendingAction()) {
      flush();
    }
    EDITOR_TO_PENDING_ACTION.set(editor, {
      at: at2,
      run
    });
    actionTimeoutId = setTimeout(flush);
  };
  var handleDOMBeforeInput = (event) => {
    var _targetRange2;
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      inputType: type
    } = event;
    var targetRange2 = null;
    var data = event.dataTransfer || event.data || void 0;
    if (insertPositionHint !== false && type !== "insertText" && type !== "insertCompositionText") {
      insertPositionHint = false;
    }
    var [nativeTargetRange] = event.getTargetRanges();
    if (nativeTargetRange) {
      targetRange2 = ReactEditor.toSlateRange(editor, nativeTargetRange, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    var window3 = ReactEditor.getWindow(editor);
    var domSelection = window3.getSelection();
    if (!targetRange2 && domSelection) {
      nativeTargetRange = domSelection;
      targetRange2 = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    targetRange2 = (_targetRange2 = targetRange2) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;
    if (!targetRange2) {
      return;
    }
    var canStoreDiff = true;
    if (type.startsWith("delete")) {
      if (Range.isExpanded(targetRange2)) {
        var [_start, _end] = Range.edges(targetRange2);
        var _leaf = Node2.leaf(editor, _start.path);
        if (_leaf.text.length === _start.offset && _end.offset === 0) {
          var next4 = Editor.next(editor, {
            at: _start.path,
            match: Text.isText
          });
          if (next4 && Path.equals(next4[1], _end.path)) {
            targetRange2 = {
              anchor: _end,
              focus: _end
            };
          }
        }
      }
      var direction = type.endsWith("Backward") ? "backward" : "forward";
      var [start2, end2] = Range.edges(targetRange2);
      var [leaf3, path3] = Editor.leaf(editor, start2.path);
      var diff2 = {
        text: "",
        start: start2.offset,
        end: end2.offset
      };
      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change) => Path.equals(change.path, path3));
      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff2] : [diff2];
      var text = applyStringDiff(leaf3.text, ...diffs);
      if (text.length === 0) {
        canStoreDiff = false;
      }
      if (Range.isExpanded(targetRange2)) {
        if (canStoreDiff && Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var point3 = {
            path: targetRange2.anchor.path,
            offset: start2.offset
          };
          var range3 = Editor.range(editor, point3, point3);
          handleUserSelect(range3);
          return storeDiff(targetRange2.anchor.path, {
            text: "",
            end: end2.offset,
            start: start2.offset
          });
        }
        return scheduleAction(() => Editor.deleteFragment(editor, {
          direction
        }), {
          at: targetRange2
        });
      }
    }
    switch (type) {
      case "deleteByComposition":
      case "deleteByCut":
      case "deleteByDrag": {
        return scheduleAction(() => Editor.deleteFragment(editor), {
          at: targetRange2
        });
      }
      case "deleteContent":
      case "deleteContentForward": {
        var {
          anchor
        } = targetRange2;
        if (canStoreDiff && Range.isCollapsed(targetRange2)) {
          var targetNode = Node2.leaf(editor, anchor.path);
          if (anchor.offset < targetNode.text.length) {
            return storeDiff(anchor.path, {
              text: "",
              start: anchor.offset,
              end: anchor.offset + 1
            });
          }
        }
        return scheduleAction(() => Editor.deleteForward(editor), {
          at: targetRange2
        });
      }
      case "deleteContentBackward": {
        var _nativeTargetRange;
        var {
          anchor: _anchor
        } = targetRange2;
        var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);
        if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange2) && _anchor.offset > 0) {
          return storeDiff(_anchor.path, {
            text: "",
            start: _anchor.offset - 1,
            end: _anchor.offset
          });
        }
        return scheduleAction(() => Editor.deleteBackward(editor), {
          at: targetRange2
        });
      }
      case "deleteEntireSoftLine": {
        return scheduleAction(() => {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
        }, {
          at: targetRange2
        });
      }
      case "deleteHardLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteHardLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "insertLineBreak": {
        return scheduleAction(() => Editor.insertSoftBreak(editor), {
          at: targetRange2
        });
      }
      case "insertParagraph": {
        return scheduleAction(() => Editor.insertBreak(editor), {
          at: targetRange2
        });
      }
      case "insertCompositionText":
      case "deleteCompositionText":
      case "insertFromComposition":
      case "insertFromDrop":
      case "insertFromPaste":
      case "insertFromYank":
      case "insertReplacementText":
      case "insertText": {
        if (isDataTransfer(data)) {
          return scheduleAction(() => ReactEditor.insertData(editor, data), {
            at: targetRange2
          });
        }
        var _text = data !== null && data !== void 0 ? data : "";
        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {
          _text = _text.replace("\uFEFF", "");
        }
        if (type === "insertText" && /.*\n.*\n$/.test(_text)) {
          _text = _text.slice(0, -1);
        }
        if (_text.includes("\n")) {
          return scheduleAction(() => {
            var parts = _text.split("\n");
            parts.forEach((line2, i4) => {
              if (line2) {
                Editor.insertText(editor, line2);
              }
              if (i4 !== parts.length - 1) {
                Editor.insertSoftBreak(editor);
              }
            });
          }, {
            at: targetRange2
          });
        }
        if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var [_start2, _end2] = Range.edges(targetRange2);
          var _diff = {
            start: _start2.offset,
            end: _end2.offset,
            text: _text
          };
          if (_text && insertPositionHint && type === "insertCompositionText") {
            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\S|$/);
            var diffPosition = _diff.start + _diff.text.search(/\S|$/);
            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {
              _diff.start -= 1;
              insertPositionHint = null;
              scheduleFlush();
            } else {
              insertPositionHint = false;
            }
          } else if (type === "insertText") {
            if (insertPositionHint === null) {
              insertPositionHint = _diff;
            } else if (insertPositionHint && Range.isCollapsed(targetRange2) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {
              insertPositionHint = _objectSpread$62(_objectSpread$62({}, insertPositionHint), {}, {
                text: insertPositionHint.text + _text
              });
            } else {
              insertPositionHint = false;
            }
          } else {
            insertPositionHint = false;
          }
          if (canStoreDiff) {
            storeDiff(_start2.path, _diff);
            return;
          }
        }
        return scheduleAction(() => Editor.insertText(editor, _text), {
          at: targetRange2
        });
      }
    }
  };
  var hasPendingAction = () => {
    return !!EDITOR_TO_PENDING_ACTION.get(editor);
  };
  var hasPendingDiffs = () => {
    var _EDITOR_TO_PENDING_DI4;
    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);
  };
  var hasPendingChanges = () => {
    return hasPendingAction() || hasPendingDiffs();
  };
  var isFlushing = () => {
    return flushing;
  };
  var handleUserSelect = (range3) => {
    EDITOR_TO_PENDING_SELECTION.set(editor, range3);
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      selection
    } = editor;
    if (!range3) {
      return;
    }
    var pathChanged = !selection || !Path.equals(selection.anchor.path, range3.anchor.path);
    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range3.anchor.path.slice(0, -1));
    if (pathChanged && insertPositionHint || parentPathChanged) {
      insertPositionHint = false;
    }
    if (pathChanged || hasPendingDiffs()) {
      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);
    }
  };
  var handleInput = () => {
    if (hasPendingAction() || !hasPendingDiffs()) {
      flush();
    }
  };
  var handleKeyDown = (_2) => {
    if (!hasPendingDiffs()) {
      updatePlaceholderVisibility(true);
      setTimeout(updatePlaceholderVisibility);
    }
  };
  var scheduleFlush = () => {
    if (!hasPendingAction()) {
      actionTimeoutId = setTimeout(flush);
    }
  };
  var handleDomMutations = (mutations) => {
    if (hasPendingDiffs() || hasPendingAction()) {
      return;
    }
    if (mutations.some((mutation) => isTrackedMutation(editor, mutation, mutations))) {
      var _EDITOR_TO_FORCE_REND;
      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();
    }
  };
  return {
    flush,
    scheduleFlush,
    hasPendingDiffs,
    hasPendingAction,
    hasPendingChanges,
    isFlushing,
    handleUserSelect,
    handleCompositionEnd,
    handleCompositionStart,
    handleDOMBeforeInput,
    handleKeyDown,
    handleDomMutations,
    handleInput
  };
}
function useIsMounted() {
  var isMountedRef = (0, import_react26.useRef)(false);
  (0, import_react26.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef.current;
}
function useMutationObserver2(node5, callback, options) {
  var [mutationObserver] = (0, import_react26.useState)(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect2(() => {
    mutationObserver.takeRecords();
  });
  (0, import_react26.useEffect)(() => {
    if (!node5.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    mutationObserver.observe(node5.current, options);
    return () => mutationObserver.disconnect();
  }, [mutationObserver, node5, options]);
}
function ownKeys$52(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$52(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$52(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$52(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$42(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$42(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$42(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$42(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function ownKeys$32(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$32(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$32(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$32(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {
  if (placeholderResizeObserver.current) {
    placeholderResizeObserver.current.disconnect();
    if (releaseObserver) {
      placeholderResizeObserver.current = null;
    }
  }
}
function clearTimeoutRef(timeoutRef) {
  if (timeoutRef.current) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = null;
  }
}
function ownKeys$22(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$22(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$22(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$22(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = (0, import_react26.useRef)(false);
  var animationFrameIdRef = (0, import_react26.useRef)(0);
  var onUserInput = (0, import_react26.useCallback)(() => {
    if (receivedUserInput.current) {
      return;
    }
    receivedUserInput.current = true;
    var window3 = ReactEditor.getWindow(editor);
    window3.cancelAnimationFrame(animationFrameIdRef.current);
    animationFrameIdRef.current = window3.requestAnimationFrame(() => {
      receivedUserInput.current = false;
    });
  }, [editor]);
  (0, import_react26.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);
  return {
    receivedUserInput,
    onUserInput
  };
}
function ownKeys$12(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread$12(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys$12(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys$12(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
function isError(error) {
  return error instanceof Error;
}
function useSlateSelector(selector) {
  var equalityFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : refEquality;
  var [, forceRender] = (0, import_react26.useReducer)((s5) => s5 + 1, 0);
  var context2 = (0, import_react26.useContext)(SlateSelectorContext);
  if (!context2) {
    throw new Error("The `useSlateSelector` hook must be used inside the <Slate> component's context.");
  }
  var {
    getSlate,
    addEventListener
  } = context2;
  var latestSubscriptionCallbackError = (0, import_react26.useRef)();
  var latestSelector = (0, import_react26.useRef)(() => null);
  var latestSelectedState = (0, import_react26.useRef)(null);
  var selectedState;
  try {
    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {
      selectedState = selector(getSlate());
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current && isError(err)) {
      err.message += "\nThe error may be correlated with this previous error:\n".concat(latestSubscriptionCallbackError.current.stack, "\n\n");
    }
    throw err;
  }
  useIsomorphicLayoutEffect2(() => {
    latestSelector.current = selector;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = void 0;
  });
  useIsomorphicLayoutEffect2(
    () => {
      function checkForUpdates() {
        try {
          var newSelectedState = latestSelector.current(getSlate());
          if (equalityFn(newSelectedState, latestSelectedState.current)) {
            return;
          }
          latestSelectedState.current = newSelectedState;
        } catch (err) {
          if (err instanceof Error) {
            latestSubscriptionCallbackError.current = err;
          } else {
            latestSubscriptionCallbackError.current = new Error(String(err));
          }
        }
        forceRender();
      }
      var unsubscribe = addEventListener(checkForUpdates);
      checkForUpdates();
      return () => unsubscribe();
    },
    // don't rerender on equalityFn change since we want to be able to define it inline
    [addEventListener, getSlate]
  );
  return selectedState;
}
function useSelectorContext(editor) {
  var eventListeners = (0, import_react26.useRef)([]).current;
  var slateRef = (0, import_react26.useRef)({
    editor
  }).current;
  var onChange = (0, import_react26.useCallback)((editor2) => {
    slateRef.editor = editor2;
    eventListeners.forEach((listener) => listener(editor2));
  }, [eventListeners, slateRef]);
  var selectorContext = (0, import_react26.useMemo)(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: (callback) => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange
  };
}
function ownKeys2(e5, r4) {
  var t4 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e5);
    r4 && (o4 = o4.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e5, r5).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread2(e5) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys2(Object(t4), true).forEach(function(r5) {
      _defineProperty3(e5, r5, t4[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys2(Object(t4)).forEach(function(r5) {
      Object.defineProperty(e5, r5, Object.getOwnPropertyDescriptor(t4, r5));
    });
  }
  return e5;
}
var import_direction, import_debounce3, import_throttle4, import_react26, import_is_hotkey, import_react_dom2, EditorContext, useSlateStatic, REACT_MAJOR_VERSION, IS_IOS, IS_APPLE, IS_ANDROID, IS_FIREFOX, IS_WEBKIT, IS_EDGE_LEGACY, IS_CHROME, IS_CHROME_LEGACY, IS_ANDROID_CHROME_LEGACY, IS_FIREFOX_LEGACY, IS_UC_MOBILE, IS_WECHATBROWSER, CAN_USE_DOM, HAS_BEFORE_INPUT_SUPPORT, NODE_TO_INDEX, NODE_TO_PARENT, EDITOR_TO_WINDOW, EDITOR_TO_ELEMENT, EDITOR_TO_PLACEHOLDER_ELEMENT, ELEMENT_TO_NODE, NODE_TO_ELEMENT, NODE_TO_KEY, EDITOR_TO_KEY_TO_ELEMENT, IS_READ_ONLY, IS_FOCUSED, IS_COMPOSING, EDITOR_TO_USER_SELECTION, EDITOR_TO_ON_CHANGE, EDITOR_TO_SCHEDULE_FLUSH, EDITOR_TO_PENDING_INSERTION_MARKS, EDITOR_TO_USER_MARKS, EDITOR_TO_PENDING_DIFFS, EDITOR_TO_PENDING_ACTION, EDITOR_TO_PENDING_SELECTION, EDITOR_TO_FORCE_RENDER, PLACEHOLDER_SYMBOL, MARK_PLACEHOLDER_SYMBOL, DOMText, getDefaultView, isDOMComment, isDOMElement, isDOMNode, isDOMSelection, isDOMText, isPlainTextOnlyPaste, normalizeDOMPoint, hasShadowRoot, getEditableChildAndIndex, getEditableChild, getPlainText, catchSlateFragment, getSlateFragmentAttribute, isTrackedMutation, n3, Key, ReactEditor, RESOLVE_DELAY, FLUSH_DELAY, debug, isDataTransfer, useIsomorphicLayoutEffect2, _excluded$32, MUTATION_OBSERVER_CONFIG$1, useAndroidInputManager, _excluded$22, _excluded2$12, shallowCompare, isDecorationFlagsEqual, isElementDecorationsEqual, isTextDecorationsEqual, String$1, TextString, MemoizedText$1, ZeroWidthString, Leaf, MemoizedLeaf, DefaultLeaf, Text2, MemoizedText, Element3, MemoizedElement, DefaultElement, DecorateContext, useDecorate, SelectedContext, useSelected, useChildren, ReadOnlyContext, useReadOnly, SlateContext, useSlate, useSlateWithV, TRIPLE_CLICK, HOTKEYS, APPLE_HOTKEYS, WINDOWS_HOTKEYS, create, Hotkeys, createRestoreDomManager, MUTATION_OBSERVER_CONFIG, RestoreDOMComponent, RestoreDOM, _excluded$12, _excluded22, Children2, Editable, DefaultPlaceholder, defaultDecorate, defaultScrollSelectionIntoView, isEventHandled, isDOMEventTargetInput, isDOMEventHandled, FocusedContext, useFocused, SlateSelectorContext, refEquality, _excluded3, Slate, useEditor, useSlateSelection, isSelectionEqual, doRectsIntersect, areRangesSameLine, findCurrentLineRange, withReact, getMatches;
var init_index_es3 = __esm({
  "node_modules/slate-react/dist/index.es.js"() {
    import_direction = __toESM(require_direction());
    import_debounce3 = __toESM(require_debounce());
    import_throttle4 = __toESM(require_throttle());
    import_react26 = __toESM(require_react());
    init_dist2();
    init_index_es2();
    init_resize_observer();
    import_is_hotkey = __toESM(require_lib2());
    import_react_dom2 = __toESM(require_react_dom());
    EditorContext = (0, import_react26.createContext)(null);
    useSlateStatic = () => {
      var editor = (0, import_react26.useContext)(EditorContext);
      if (!editor) {
        throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
      }
      return editor;
    };
    REACT_MAJOR_VERSION = parseInt(import_react26.default.version.split(".")[0], 10);
    IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
    IS_ANDROID = typeof navigator !== "undefined" && /Android/.test(navigator.userAgent);
    IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    IS_WEBKIT = typeof navigator !== "undefined" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);
    IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
    IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
    IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
    IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== "undefined" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent);
    IS_FIREFOX_LEGACY = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
    IS_UC_MOBILE = typeof navigator !== "undefined" && /.*UCBrowser/.test(navigator.userAgent);
    IS_WECHATBROWSER = typeof navigator !== "undefined" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent);
    CAN_USE_DOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
    typeof globalThis !== "undefined" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
    typeof globalThis.InputEvent.prototype.getTargetRanges === "function";
    NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
    NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_PLACEHOLDER_ELEMENT = /* @__PURE__ */ new WeakMap();
    ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
    NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
    NODE_TO_KEY = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
    IS_READ_ONLY = /* @__PURE__ */ new WeakMap();
    IS_FOCUSED = /* @__PURE__ */ new WeakMap();
    IS_COMPOSING = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_SCHEDULE_FLUSH = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_PENDING_INSERTION_MARKS = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_USER_MARKS = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_PENDING_DIFFS = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_PENDING_ACTION = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_PENDING_SELECTION = /* @__PURE__ */ new WeakMap();
    EDITOR_TO_FORCE_RENDER = /* @__PURE__ */ new WeakMap();
    PLACEHOLDER_SYMBOL = Symbol("placeholder");
    MARK_PLACEHOLDER_SYMBOL = Symbol("mark-placeholder");
    DOMText = globalThis.Text;
    getDefaultView = (value) => {
      return value && value.ownerDocument && value.ownerDocument.defaultView || null;
    };
    isDOMComment = (value) => {
      return isDOMNode(value) && value.nodeType === 8;
    };
    isDOMElement = (value) => {
      return isDOMNode(value) && value.nodeType === 1;
    };
    isDOMNode = (value) => {
      var window3 = getDefaultView(value);
      return !!window3 && value instanceof window3.Node;
    };
    isDOMSelection = (value) => {
      var window3 = value && value.anchorNode && getDefaultView(value.anchorNode);
      return !!window3 && value instanceof window3.Selection;
    };
    isDOMText = (value) => {
      return isDOMNode(value) && value.nodeType === 3;
    };
    isPlainTextOnlyPaste = (event) => {
      return event.clipboardData && event.clipboardData.getData("text/plain") !== "" && event.clipboardData.types.length === 1;
    };
    normalizeDOMPoint = (domPoint) => {
      var [node5, offset3] = domPoint;
      if (isDOMElement(node5) && node5.childNodes.length) {
        var isLast = offset3 === node5.childNodes.length;
        var index3 = isLast ? offset3 - 1 : offset3;
        [node5, index3] = getEditableChildAndIndex(node5, index3, isLast ? "backward" : "forward");
        isLast = index3 < offset3;
        while (isDOMElement(node5) && node5.childNodes.length) {
          var i4 = isLast ? node5.childNodes.length - 1 : 0;
          node5 = getEditableChild(node5, i4, isLast ? "backward" : "forward");
        }
        offset3 = isLast && node5.textContent != null ? node5.textContent.length : 0;
      }
      return [node5, offset3];
    };
    hasShadowRoot = (node5) => {
      var parent3 = node5 && node5.parentNode;
      while (parent3) {
        if (parent3.toString() === "[object ShadowRoot]") {
          return true;
        }
        parent3 = parent3.parentNode;
      }
      return false;
    };
    getEditableChildAndIndex = (parent3, index3, direction) => {
      var {
        childNodes
      } = parent3;
      var child = childNodes[index3];
      var i4 = index3;
      var triedForward = false;
      var triedBackward = false;
      while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute("contenteditable") === "false") {
        if (triedForward && triedBackward) {
          break;
        }
        if (i4 >= childNodes.length) {
          triedForward = true;
          i4 = index3 - 1;
          direction = "backward";
          continue;
        }
        if (i4 < 0) {
          triedBackward = true;
          i4 = index3 + 1;
          direction = "forward";
          continue;
        }
        child = childNodes[i4];
        index3 = i4;
        i4 += direction === "forward" ? 1 : -1;
      }
      return [child, index3];
    };
    getEditableChild = (parent3, index3, direction) => {
      var [child] = getEditableChildAndIndex(parent3, index3, direction);
      return child;
    };
    getPlainText = (domNode) => {
      var text = "";
      if (isDOMText(domNode) && domNode.nodeValue) {
        return domNode.nodeValue;
      }
      if (isDOMElement(domNode)) {
        for (var childNode of Array.from(domNode.childNodes)) {
          text += getPlainText(childNode);
        }
        var display = getComputedStyle(domNode).getPropertyValue("display");
        if (display === "block" || display === "list" || domNode.tagName === "BR") {
          text += "\n";
        }
      }
      return text;
    };
    catchSlateFragment = /data-slate-fragment="(.+?)"/m;
    getSlateFragmentAttribute = (dataTransfer) => {
      var htmlData = dataTransfer.getData("text/html");
      var [, fragment2] = htmlData.match(catchSlateFragment) || [];
      return fragment2;
    };
    isTrackedMutation = (editor, mutation, batch) => {
      var {
        target
      } = mutation;
      if (isDOMElement(target) && target.matches('[contentEditable="false"]')) {
        return false;
      }
      var {
        document: document2
      } = ReactEditor.getWindow(editor);
      if (document2.contains(target)) {
        return ReactEditor.hasDOMNode(editor, target, {
          editable: true
        });
      }
      var parentMutation = batch.find((_ref2) => {
        var {
          addedNodes,
          removedNodes
        } = _ref2;
        for (var node5 of addedNodes) {
          if (node5 === target || node5.contains(target)) {
            return true;
          }
        }
        for (var _node of removedNodes) {
          if (_node === target || _node.contains(target)) {
            return true;
          }
        }
      });
      if (!parentMutation || parentMutation === mutation) {
        return false;
      }
      return isTrackedMutation(editor, parentMutation, batch);
    };
    n3 = 0;
    Key = class {
      constructor() {
        _defineProperty3(this, "id", void 0);
        this.id = "".concat(n3++);
      }
    };
    ReactEditor = {
      androidPendingDiffs: (editor) => EDITOR_TO_PENDING_DIFFS.get(editor),
      androidScheduleFlush: (editor) => {
        var _EDITOR_TO_SCHEDULE_F;
        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();
      },
      blur: (editor) => {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        IS_FOCUSED.set(editor, false);
        if (root.activeElement === el) {
          el.blur();
        }
      },
      deselect: (editor) => {
        var {
          selection
        } = editor;
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        var domSelection = root.getSelection();
        if (domSelection && domSelection.rangeCount > 0) {
          domSelection.removeAllRanges();
        }
        if (selection) {
          Transforms.deselect(editor);
        }
      },
      findDocumentOrShadowRoot: (editor) => {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = el.getRootNode();
        if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {
          return root;
        }
        return el.ownerDocument;
      },
      findEventRange: (editor, event) => {
        if ("nativeEvent" in event) {
          event = event.nativeEvent;
        }
        var {
          clientX: x3,
          clientY: y4,
          target
        } = event;
        if (x3 == null || y4 == null) {
          throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
        }
        var node5 = ReactEditor.toSlateNode(editor, event.target);
        var path3 = ReactEditor.findPath(editor, node5);
        if (Element2.isElement(node5) && Editor.isVoid(editor, node5)) {
          var rect = target.getBoundingClientRect();
          var isPrev = editor.isInline(node5) ? x3 - rect.left < rect.left + rect.width - x3 : y4 - rect.top < rect.top + rect.height - y4;
          var edge = Editor.point(editor, path3, {
            edge: isPrev ? "start" : "end"
          });
          var point3 = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);
          if (point3) {
            var _range = Editor.range(editor, point3);
            return _range;
          }
        }
        var domRange;
        var {
          document: document2
        } = ReactEditor.getWindow(editor);
        if (document2.caretRangeFromPoint) {
          domRange = document2.caretRangeFromPoint(x3, y4);
        } else {
          var position3 = document2.caretPositionFromPoint(x3, y4);
          if (position3) {
            domRange = document2.createRange();
            domRange.setStart(position3.offsetNode, position3.offset);
            domRange.setEnd(position3.offsetNode, position3.offset);
          }
        }
        if (!domRange) {
          throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
        }
        var range3 = ReactEditor.toSlateRange(editor, domRange, {
          exactMatch: false,
          suppressThrow: false
        });
        return range3;
      },
      findKey: (editor, node5) => {
        var key2 = NODE_TO_KEY.get(node5);
        if (!key2) {
          key2 = new Key();
          NODE_TO_KEY.set(node5, key2);
        }
        return key2;
      },
      findPath: (editor, node5) => {
        var path3 = [];
        var child = node5;
        while (true) {
          var parent3 = NODE_TO_PARENT.get(child);
          if (parent3 == null) {
            if (Editor.isEditor(child)) {
              return path3;
            } else {
              break;
            }
          }
          var i4 = NODE_TO_INDEX.get(child);
          if (i4 == null) {
            break;
          }
          path3.unshift(i4);
          child = parent3;
        }
        throw new Error("Unable to find the path for Slate node: ".concat(Scrubber.stringify(node5)));
      },
      focus: function focus(editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          retries: 5
        };
        if (IS_FOCUSED.get(editor)) {
          return;
        }
        if (options.retries <= 0) {
          throw new Error("Could not set focus, editor seems stuck with pending operations");
        }
        if (editor.operations.length > 0) {
          setTimeout(() => {
            ReactEditor.focus(editor, {
              retries: options.retries - 1
            });
          }, 10);
          return;
        }
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        if (root.activeElement !== el) {
          if (editor.selection && root instanceof Document) {
            var domSelection = root.getSelection();
            var domRange = ReactEditor.toDOMRange(editor, editor.selection);
            domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();
            domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);
          }
          if (!editor.selection) {
            Transforms.select(editor, Editor.start(editor, []));
            editor.onChange();
          }
          el.focus({
            preventScroll: true
          });
          IS_FOCUSED.set(editor, true);
        }
      },
      getWindow: (editor) => {
        var window3 = EDITOR_TO_WINDOW.get(editor);
        if (!window3) {
          throw new Error("Unable to find a host window element for this editor");
        }
        return window3;
      },
      hasDOMNode: function hasDOMNode(editor, target) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var {
          editable = false
        } = options;
        var editorEl = ReactEditor.toDOMNode(editor, editor);
        var targetEl;
        try {
          targetEl = isDOMElement(target) ? target : target.parentElement;
        } catch (err) {
          if (err instanceof Error && !err.message.includes('Permission denied to access property "nodeType"')) {
            throw err;
          }
        }
        if (!targetEl) {
          return false;
        }
        return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
        // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
        targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute("data-slate-zero-width"));
      },
      hasEditableTarget: (editor, target) => isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
        editable: true
      }),
      hasRange: (editor, range3) => {
        var {
          anchor,
          focus: focus2
        } = range3;
        return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus2.path);
      },
      hasSelectableTarget: (editor, target) => ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target),
      hasTarget: (editor, target) => isDOMNode(target) && ReactEditor.hasDOMNode(editor, target),
      insertData: (editor, data) => {
        editor.insertData(data);
      },
      insertFragmentData: (editor, data) => editor.insertFragmentData(data),
      insertTextData: (editor, data) => editor.insertTextData(data),
      isComposing: (editor) => {
        return !!IS_COMPOSING.get(editor);
      },
      isFocused: (editor) => !!IS_FOCUSED.get(editor),
      isReadOnly: (editor) => !!IS_READ_ONLY.get(editor),
      isTargetInsideNonReadonlyVoid: (editor, target) => {
        if (IS_READ_ONLY.get(editor))
          return false;
        var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
        return Element2.isElement(slateNode) && Editor.isVoid(editor, slateNode);
      },
      setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),
      toDOMNode: (editor, node5) => {
        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
        var domNode = Editor.isEditor(node5) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node5));
        if (!domNode) {
          throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Scrubber.stringify(node5)));
        }
        return domNode;
      },
      toDOMPoint: (editor, point3) => {
        var [node5] = Editor.node(editor, point3.path);
        var el = ReactEditor.toDOMNode(editor, node5);
        var domPoint;
        if (Editor.void(editor, {
          at: point3
        })) {
          point3 = {
            path: point3.path,
            offset: 0
          };
        }
        var selector = "[data-slate-string], [data-slate-zero-width]";
        var texts = Array.from(el.querySelectorAll(selector));
        var start2 = 0;
        for (var i4 = 0; i4 < texts.length; i4++) {
          var text = texts[i4];
          var domNode = text.childNodes[0];
          if (domNode == null || domNode.textContent == null) {
            continue;
          }
          var {
            length: length2
          } = domNode.textContent;
          var attr = text.getAttribute("data-slate-length");
          var trueLength = attr == null ? length2 : parseInt(attr, 10);
          var end2 = start2 + trueLength;
          var nextText = texts[i4 + 1];
          if (point3.offset === end2 && nextText !== null && nextText !== void 0 && nextText.hasAttribute("data-slate-mark-placeholder")) {
            var _nextText$textContent;
            var domText = nextText.childNodes[0];
            domPoint = [
              // COMPAT: If we don't explicity set the dom point to be on the actual
              // dom text element, chrome will put the selection behind the actual dom
              // text element, causing domRange.getBoundingClientRect() calls on a collapsed
              // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
              // which will cause issues when scrolling to it.
              domText instanceof DOMText ? domText : nextText,
              (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith("\uFEFF") ? 1 : 0
            ];
            break;
          }
          if (point3.offset <= end2) {
            var offset3 = Math.min(length2, Math.max(0, point3.offset - start2));
            domPoint = [domNode, offset3];
            break;
          }
          start2 = end2;
        }
        if (!domPoint) {
          throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Scrubber.stringify(point3)));
        }
        return domPoint;
      },
      toDOMRange: (editor, range3) => {
        var {
          anchor,
          focus: focus2
        } = range3;
        var isBackward = Range.isBackward(range3);
        var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
        var domFocus = Range.isCollapsed(range3) ? domAnchor : ReactEditor.toDOMPoint(editor, focus2);
        var window3 = ReactEditor.getWindow(editor);
        var domRange = window3.document.createRange();
        var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
        var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
        var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
        var isStartAtZeroWidth = !!startEl.getAttribute("data-slate-zero-width");
        var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
        var isEndAtZeroWidth = !!endEl.getAttribute("data-slate-zero-width");
        domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
        domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
        return domRange;
      },
      toSlateNode: (editor, domNode) => {
        var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
        if (domEl && !domEl.hasAttribute("data-slate-node")) {
          domEl = domEl.closest("[data-slate-node]");
        }
        var node5 = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
        if (!node5) {
          throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
        }
        return node5;
      },
      toSlatePoint: (editor, domPoint, options) => {
        var {
          exactMatch,
          suppressThrow
        } = options;
        var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
        var parentNode = nearestNode.parentNode;
        var textNode = null;
        var offset3 = 0;
        if (parentNode) {
          var _domNode$textContent, _domNode$textContent2;
          var editorEl = ReactEditor.toDOMNode(editor, editor);
          var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
          var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
          var leafNode = parentNode.closest("[data-slate-leaf]");
          var domNode = null;
          if (leafNode) {
            textNode = leafNode.closest('[data-slate-node="text"]');
            if (textNode) {
              var window3 = ReactEditor.getWindow(editor);
              var range3 = window3.document.createRange();
              range3.setStart(textNode, 0);
              range3.setEnd(nearestNode, nearestOffset);
              var contents = range3.cloneContents();
              var removals = [...Array.prototype.slice.call(contents.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(contents.querySelectorAll("[contenteditable=false]"))];
              removals.forEach((el) => {
                if (IS_ANDROID && !exactMatch && el.hasAttribute("data-slate-zero-width") && el.textContent.length > 0 && el.textContext !== "\uFEFF") {
                  if (el.textContent.startsWith("\uFEFF")) {
                    el.textContent = el.textContent.slice(1);
                  }
                  return;
                }
                el.parentNode.removeChild(el);
              });
              offset3 = contents.textContent.length;
              domNode = textNode;
            }
          } else if (voidNode) {
            var leafNodes = voidNode.querySelectorAll("[data-slate-leaf]");
            for (var index3 = 0; index3 < leafNodes.length; index3++) {
              var current2 = leafNodes[index3];
              if (ReactEditor.hasDOMNode(editor, current2)) {
                leafNode = current2;
                break;
              }
            }
            if (!leafNode) {
              offset3 = 1;
            } else {
              textNode = leafNode.closest('[data-slate-node="text"]');
              domNode = leafNode;
              offset3 = domNode.textContent.length;
              domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
                offset3 -= el.textContent.length;
              });
            }
          }
          if (domNode && offset3 === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
          // and we don't add it for line-breaks.
          IS_ANDROID && domNode.getAttribute("data-slate-zero-width") === "z" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
          // because the text node should have no characters. However, during IME
          // composition the ASCII characters will be prepended to the zero-width
          // space, so subtract 1 from the offset to account for the zero-width
          // space character.
          (parentNode.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
          // when the document ends with a new-line character. This results in the offset
          // length being off by one, so we need to subtract one to account for this.
          IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith("\n\n"))) {
            offset3--;
          }
        }
        if (IS_ANDROID && !textNode && !exactMatch) {
          var node5 = parentNode.hasAttribute("data-slate-node") ? parentNode : parentNode.closest("[data-slate-node]");
          if (node5 && ReactEditor.hasDOMNode(editor, node5, {
            editable: true
          })) {
            var _slateNode = ReactEditor.toSlateNode(editor, node5);
            var {
              path: _path,
              offset: _offset
            } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));
            if (!node5.querySelector("[data-slate-leaf]")) {
              _offset = nearestOffset;
            }
            return {
              path: _path,
              offset: _offset
            };
          }
        }
        if (!textNode) {
          if (suppressThrow) {
            return null;
          }
          throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
        }
        var slateNode = ReactEditor.toSlateNode(editor, textNode);
        var path3 = ReactEditor.findPath(editor, slateNode);
        return {
          path: path3,
          offset: offset3
        };
      },
      toSlateRange: (editor, domRange, options) => {
        var _focusNode$textConten;
        var {
          exactMatch,
          suppressThrow
        } = options;
        var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
        var anchorNode;
        var anchorOffset;
        var focusNode;
        var focusOffset;
        var isCollapsed;
        if (el) {
          if (isDOMSelection(domRange)) {
            if (IS_FIREFOX && domRange.rangeCount > 1) {
              focusNode = domRange.focusNode;
              var firstRange = domRange.getRangeAt(0);
              var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);
              if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {
                let getLastChildren = function(element) {
                  if (element.childElementCount > 0) {
                    return getLastChildren(element.children[0]);
                  } else {
                    return element;
                  }
                };
                var firstNodeRow = firstRange.startContainer;
                var lastNodeRow = lastRange.startContainer;
                var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);
                var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);
                focusOffset = 0;
                if (lastNode.childNodes.length > 0) {
                  anchorNode = lastNode.childNodes[0];
                } else {
                  anchorNode = lastNode;
                }
                if (firstNode.childNodes.length > 0) {
                  focusNode = firstNode.childNodes[0];
                } else {
                  focusNode = firstNode;
                }
                if (lastNode instanceof HTMLElement) {
                  anchorOffset = lastNode.innerHTML.length;
                } else {
                  anchorOffset = 0;
                }
              } else {
                if (firstRange.startContainer === focusNode) {
                  anchorNode = lastRange.endContainer;
                  anchorOffset = lastRange.endOffset;
                  focusOffset = firstRange.startOffset;
                } else {
                  anchorNode = firstRange.startContainer;
                  anchorOffset = firstRange.endOffset;
                  focusOffset = lastRange.startOffset;
                }
              }
            } else {
              anchorNode = domRange.anchorNode;
              anchorOffset = domRange.anchorOffset;
              focusNode = domRange.focusNode;
              focusOffset = domRange.focusOffset;
            }
            if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {
              isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
            } else {
              isCollapsed = domRange.isCollapsed;
            }
          } else {
            anchorNode = domRange.startContainer;
            anchorOffset = domRange.startOffset;
            focusNode = domRange.endContainer;
            focusOffset = domRange.endOffset;
            isCollapsed = domRange.collapsed;
          }
        }
        if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
          throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
        }
        if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith("\n\n") && focusOffset === focusNode.textContent.length) {
          focusOffset--;
        }
        if ("getAttribute" in focusNode && focusNode.getAttribute("contenteditable") === "false" && focusNode.getAttribute("data-slate-void") !== "true") {
          var _anchorNode$textConte;
          focusNode = anchorNode;
          focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;
        }
        var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
          exactMatch,
          suppressThrow
        });
        if (!anchor) {
          return null;
        }
        var focus2 = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
          exactMatch,
          suppressThrow
        });
        if (!focus2) {
          return null;
        }
        var range3 = {
          anchor,
          focus: focus2
        };
        if (Range.isExpanded(range3) && Range.isForward(range3) && isDOMElement(focusNode) && Editor.void(editor, {
          at: range3.focus,
          mode: "highest"
        })) {
          range3 = Editor.unhangRange(editor, range3, {
            voids: true
          });
        }
        return range3;
      }
    };
    RESOLVE_DELAY = 25;
    FLUSH_DELAY = 200;
    debug = function debug2() {
    };
    isDataTransfer = (value) => (value === null || value === void 0 ? void 0 : value.constructor.name) === "DataTransfer";
    useIsomorphicLayoutEffect2 = CAN_USE_DOM ? import_react26.useLayoutEffect : import_react26.useEffect;
    _excluded$32 = ["node"];
    MUTATION_OBSERVER_CONFIG$1 = {
      subtree: true,
      childList: true,
      characterData: true
    };
    useAndroidInputManager = !IS_ANDROID ? () => null : (_ref2) => {
      var {
        node: node5
      } = _ref2, options = _objectWithoutProperties2(_ref2, _excluded$32);
      if (!IS_ANDROID) {
        return null;
      }
      var editor = useSlateStatic();
      var isMounted = useIsMounted();
      var [inputManager] = (0, import_react26.useState)(() => createAndroidInputManager(_objectSpread$52({
        editor
      }, options)));
      useMutationObserver2(node5, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);
      EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);
      if (isMounted) {
        inputManager.flush();
      }
      return inputManager;
    };
    _excluded$22 = ["anchor", "focus"];
    _excluded2$12 = ["anchor", "focus"];
    shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key2) => obj2.hasOwnProperty(key2) && obj1[key2] === obj2[key2]);
    isDecorationFlagsEqual = (range3, other) => {
      var rangeOwnProps = _objectWithoutProperties2(range3, _excluded$22);
      var otherOwnProps = _objectWithoutProperties2(other, _excluded2$12);
      return range3[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);
    };
    isElementDecorationsEqual = (list, another) => {
      if (list.length !== another.length) {
        return false;
      }
      for (var i4 = 0; i4 < list.length; i4++) {
        var range3 = list[i4];
        var other = another[i4];
        if (!Range.equals(range3, other) || !isDecorationFlagsEqual(range3, other)) {
          return false;
        }
      }
      return true;
    };
    isTextDecorationsEqual = (list, another) => {
      if (list.length !== another.length) {
        return false;
      }
      for (var i4 = 0; i4 < list.length; i4++) {
        var range3 = list[i4];
        var other = another[i4];
        if (range3.anchor.offset !== other.anchor.offset || range3.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range3, other)) {
          return false;
        }
      }
      return true;
    };
    String$1 = (props) => {
      var {
        isLast,
        leaf: leaf3,
        parent: parent3,
        text
      } = props;
      var editor = useSlateStatic();
      var path3 = ReactEditor.findPath(editor, text);
      var parentPath = Path.parent(path3);
      var isMarkPlaceholder = Boolean(leaf3[MARK_PLACEHOLDER_SYMBOL]);
      if (editor.isVoid(parent3)) {
        return import_react26.default.createElement(ZeroWidthString, {
          length: Node2.string(parent3).length
        });
      }
      if (leaf3.text === "" && parent3.children[parent3.children.length - 1] === text && !editor.isInline(parent3) && Editor.string(editor, parentPath) === "") {
        return import_react26.default.createElement(ZeroWidthString, {
          isLineBreak: true,
          isMarkPlaceholder
        });
      }
      if (leaf3.text === "") {
        return import_react26.default.createElement(ZeroWidthString, {
          isMarkPlaceholder
        });
      }
      if (isLast && leaf3.text.slice(-1) === "\n") {
        return import_react26.default.createElement(TextString, {
          isTrailing: true,
          text: leaf3.text
        });
      }
      return import_react26.default.createElement(TextString, {
        text: leaf3.text
      });
    };
    TextString = (props) => {
      var {
        text,
        isTrailing = false
      } = props;
      var ref = (0, import_react26.useRef)(null);
      var getTextContent = () => {
        return "".concat(text !== null && text !== void 0 ? text : "").concat(isTrailing ? "\n" : "");
      };
      var [initialText] = (0, import_react26.useState)(getTextContent);
      useIsomorphicLayoutEffect2(() => {
        var textWithTrailing = getTextContent();
        if (ref.current && ref.current.textContent !== textWithTrailing) {
          ref.current.textContent = textWithTrailing;
        }
      });
      return import_react26.default.createElement(MemoizedText$1, {
        ref
      }, initialText);
    };
    MemoizedText$1 = (0, import_react26.memo)((0, import_react26.forwardRef)((props, ref) => {
      return import_react26.default.createElement("span", {
        "data-slate-string": true,
        ref
      }, props.children);
    }));
    ZeroWidthString = (props) => {
      var {
        length: length2 = 0,
        isLineBreak = false,
        isMarkPlaceholder = false
      } = props;
      var attributes = {
        "data-slate-zero-width": isLineBreak ? "n" : "z",
        "data-slate-length": length2
      };
      if (isMarkPlaceholder) {
        attributes["data-slate-mark-placeholder"] = true;
      }
      return import_react26.default.createElement("span", _objectSpread$42({}, attributes), !IS_ANDROID || !isLineBreak ? "\uFEFF" : null, isLineBreak ? import_react26.default.createElement("br", null) : null);
    };
    Leaf = (props) => {
      var {
        leaf: leaf3,
        isLast,
        text,
        parent: parent3,
        renderPlaceholder,
        renderLeaf = (props2) => import_react26.default.createElement(DefaultLeaf, _objectSpread$32({}, props2))
      } = props;
      var editor = useSlateStatic();
      var placeholderResizeObserver = (0, import_react26.useRef)(null);
      var placeholderRef = (0, import_react26.useRef)(null);
      var [showPlaceholder, setShowPlaceholder] = (0, import_react26.useState)(false);
      var showPlaceholderTimeoutRef = (0, import_react26.useRef)(null);
      var callbackPlaceholderRef = (0, import_react26.useCallback)((placeholderEl) => {
        disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);
        if (placeholderEl == null) {
          var _leaf$onPlaceholderRe;
          EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
          (_leaf$onPlaceholderRe = leaf3.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf3, null);
        } else {
          EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);
          if (!placeholderResizeObserver.current) {
            var ResizeObserver$1 = window.ResizeObserver || ResizeObserver2;
            placeholderResizeObserver.current = new ResizeObserver$1(() => {
              var _leaf$onPlaceholderRe2;
              (_leaf$onPlaceholderRe2 = leaf3.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf3, placeholderEl);
            });
          }
          placeholderResizeObserver.current.observe(placeholderEl);
          placeholderRef.current = placeholderEl;
        }
      }, [placeholderRef, leaf3, editor]);
      var children = import_react26.default.createElement(String$1, {
        isLast,
        leaf: leaf3,
        parent: parent3,
        text
      });
      var leafIsPlaceholder = Boolean(leaf3[PLACEHOLDER_SYMBOL]);
      (0, import_react26.useEffect)(() => {
        if (leafIsPlaceholder) {
          if (!showPlaceholderTimeoutRef.current) {
            showPlaceholderTimeoutRef.current = setTimeout(() => {
              setShowPlaceholder(true);
              showPlaceholderTimeoutRef.current = null;
            }, 300);
          }
        } else {
          clearTimeoutRef(showPlaceholderTimeoutRef);
          setShowPlaceholder(false);
        }
        return () => clearTimeoutRef(showPlaceholderTimeoutRef);
      }, [leafIsPlaceholder, setShowPlaceholder]);
      if (leafIsPlaceholder && showPlaceholder) {
        var placeholderProps = {
          children: leaf3.placeholder,
          attributes: {
            "data-slate-placeholder": true,
            style: {
              position: "absolute",
              top: 0,
              pointerEvents: "none",
              width: "100%",
              maxWidth: "100%",
              display: "block",
              opacity: "0.333",
              userSelect: "none",
              textDecoration: "none",
              // Fixes https://github.com/udecode/plate/issues/2315
              WebkitUserModify: IS_WEBKIT ? "inherit" : void 0
            },
            contentEditable: false,
            ref: callbackPlaceholderRef
          }
        };
        children = import_react26.default.createElement(import_react26.default.Fragment, null, renderPlaceholder(placeholderProps), children);
      }
      var attributes = {
        "data-slate-leaf": true
      };
      return renderLeaf({
        attributes,
        children,
        leaf: leaf3,
        text
      });
    };
    MemoizedLeaf = import_react26.default.memo(Leaf, (prev2, next4) => {
      return next4.parent === prev2.parent && next4.isLast === prev2.isLast && next4.renderLeaf === prev2.renderLeaf && next4.renderPlaceholder === prev2.renderPlaceholder && next4.text === prev2.text && Text.equals(next4.leaf, prev2.leaf) && next4.leaf[PLACEHOLDER_SYMBOL] === prev2.leaf[PLACEHOLDER_SYMBOL];
    });
    DefaultLeaf = (props) => {
      var {
        attributes,
        children
      } = props;
      return import_react26.default.createElement("span", _objectSpread$32({}, attributes), children);
    };
    Text2 = (props) => {
      var {
        decorations,
        isLast,
        parent: parent3,
        renderPlaceholder,
        renderLeaf,
        text
      } = props;
      var editor = useSlateStatic();
      var ref = (0, import_react26.useRef)(null);
      var leaves = Text.decorations(text, decorations);
      var key2 = ReactEditor.findKey(editor, text);
      var children = [];
      for (var i4 = 0; i4 < leaves.length; i4++) {
        var leaf3 = leaves[i4];
        children.push(import_react26.default.createElement(MemoizedLeaf, {
          isLast: isLast && i4 === leaves.length - 1,
          key: "".concat(key2.id, "-").concat(i4),
          renderPlaceholder,
          leaf: leaf3,
          text,
          parent: parent3,
          renderLeaf
        }));
      }
      var callbackRef = (0, import_react26.useCallback)((span) => {
        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
        if (span) {
          KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key2, span);
          NODE_TO_ELEMENT.set(text, span);
          ELEMENT_TO_NODE.set(span, text);
        } else {
          KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key2);
          NODE_TO_ELEMENT.delete(text);
          if (ref.current) {
            ELEMENT_TO_NODE.delete(ref.current);
          }
        }
        ref.current = span;
      }, [ref, editor, key2, text]);
      return import_react26.default.createElement("span", {
        "data-slate-node": "text",
        ref: callbackRef
      }, children);
    };
    MemoizedText = import_react26.default.memo(Text2, (prev2, next4) => {
      return next4.parent === prev2.parent && next4.isLast === prev2.isLast && next4.renderLeaf === prev2.renderLeaf && next4.renderPlaceholder === prev2.renderPlaceholder && next4.text === prev2.text && isTextDecorationsEqual(next4.decorations, prev2.decorations);
    });
    Element3 = (props) => {
      var {
        decorations,
        element,
        renderElement = (p2) => import_react26.default.createElement(DefaultElement, _objectSpread$22({}, p2)),
        renderPlaceholder,
        renderLeaf,
        selection
      } = props;
      var editor = useSlateStatic();
      var readOnly2 = useReadOnly();
      var isInline = editor.isInline(element);
      var key2 = ReactEditor.findKey(editor, element);
      var ref = (0, import_react26.useCallback)((ref2) => {
        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
        if (ref2) {
          KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key2, ref2);
          NODE_TO_ELEMENT.set(element, ref2);
          ELEMENT_TO_NODE.set(ref2, element);
        } else {
          KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key2);
          NODE_TO_ELEMENT.delete(element);
        }
      }, [editor, key2, element]);
      var children = useChildren({
        decorations,
        node: element,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection
      });
      var attributes = {
        "data-slate-node": "element",
        ref
      };
      if (isInline) {
        attributes["data-slate-inline"] = true;
      }
      if (!isInline && Editor.hasInlines(editor, element)) {
        var text = Node2.string(element);
        var dir = (0, import_direction.default)(text);
        if (dir === "rtl") {
          attributes.dir = dir;
        }
      }
      if (Editor.isVoid(editor, element)) {
        attributes["data-slate-void"] = true;
        if (!readOnly2 && isInline) {
          attributes.contentEditable = false;
        }
        var Tag = isInline ? "span" : "div";
        var [[_text]] = Node2.texts(element);
        children = import_react26.default.createElement(Tag, {
          "data-slate-spacer": true,
          style: {
            height: "0",
            color: "transparent",
            outline: "none",
            position: "absolute"
          }
        }, import_react26.default.createElement(MemoizedText, {
          renderPlaceholder,
          decorations: [],
          isLast: false,
          parent: element,
          text: _text
        }));
        NODE_TO_INDEX.set(_text, 0);
        NODE_TO_PARENT.set(_text, element);
      }
      return renderElement({
        attributes,
        children,
        element
      });
    };
    MemoizedElement = import_react26.default.memo(Element3, (prev2, next4) => {
      return prev2.element === next4.element && prev2.renderElement === next4.renderElement && prev2.renderLeaf === next4.renderLeaf && prev2.renderPlaceholder === next4.renderPlaceholder && isElementDecorationsEqual(prev2.decorations, next4.decorations) && (prev2.selection === next4.selection || !!prev2.selection && !!next4.selection && Range.equals(prev2.selection, next4.selection));
    });
    DefaultElement = (props) => {
      var {
        attributes,
        children,
        element
      } = props;
      var editor = useSlateStatic();
      var Tag = editor.isInline(element) ? "span" : "div";
      return import_react26.default.createElement(Tag, _objectSpread$22(_objectSpread$22({}, attributes), {}, {
        style: {
          position: "relative"
        }
      }), children);
    };
    DecorateContext = (0, import_react26.createContext)(() => []);
    useDecorate = () => {
      return (0, import_react26.useContext)(DecorateContext);
    };
    SelectedContext = (0, import_react26.createContext)(false);
    useSelected = () => {
      return (0, import_react26.useContext)(SelectedContext);
    };
    useChildren = (props) => {
      var {
        decorations,
        node: node5,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection
      } = props;
      var decorate = useDecorate();
      var editor = useSlateStatic();
      var path3 = ReactEditor.findPath(editor, node5);
      var children = [];
      var isLeafBlock = Element2.isElement(node5) && !editor.isInline(node5) && Editor.hasInlines(editor, node5);
      for (var i4 = 0; i4 < node5.children.length; i4++) {
        var p2 = path3.concat(i4);
        var n4 = node5.children[i4];
        var key2 = ReactEditor.findKey(editor, n4);
        var range3 = Editor.range(editor, p2);
        var sel = selection && Range.intersection(range3, selection);
        var ds = decorate([n4, p2]);
        for (var dec of decorations) {
          var d3 = Range.intersection(dec, range3);
          if (d3) {
            ds.push(d3);
          }
        }
        if (Element2.isElement(n4)) {
          children.push(import_react26.default.createElement(SelectedContext.Provider, {
            key: "provider-".concat(key2.id),
            value: !!sel
          }, import_react26.default.createElement(MemoizedElement, {
            decorations: ds,
            element: n4,
            key: key2.id,
            renderElement,
            renderPlaceholder,
            renderLeaf,
            selection: sel
          })));
        } else {
          children.push(import_react26.default.createElement(MemoizedText, {
            decorations: ds,
            key: key2.id,
            isLast: isLeafBlock && i4 === node5.children.length - 1,
            parent: node5,
            renderPlaceholder,
            renderLeaf,
            text: n4
          }));
        }
        NODE_TO_INDEX.set(n4, i4);
        NODE_TO_PARENT.set(n4, node5);
      }
      return children;
    };
    ReadOnlyContext = (0, import_react26.createContext)(false);
    useReadOnly = () => {
      return (0, import_react26.useContext)(ReadOnlyContext);
    };
    SlateContext = (0, import_react26.createContext)(null);
    useSlate = () => {
      var context2 = (0, import_react26.useContext)(SlateContext);
      if (!context2) {
        throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
      }
      var {
        editor
      } = context2;
      return editor;
    };
    useSlateWithV = () => {
      var context2 = (0, import_react26.useContext)(SlateContext);
      if (!context2) {
        throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
      }
      return context2;
    };
    TRIPLE_CLICK = 3;
    HOTKEYS = {
      bold: "mod+b",
      compose: ["down", "left", "right", "up", "backspace", "enter"],
      moveBackward: "left",
      moveForward: "right",
      moveWordBackward: "ctrl+left",
      moveWordForward: "ctrl+right",
      deleteBackward: "shift?+backspace",
      deleteForward: "shift?+delete",
      extendBackward: "shift+left",
      extendForward: "shift+right",
      italic: "mod+i",
      insertSoftBreak: "shift+enter",
      splitBlock: "enter",
      undo: "mod+z"
    };
    APPLE_HOTKEYS = {
      moveLineBackward: "opt+up",
      moveLineForward: "opt+down",
      moveWordBackward: "opt+left",
      moveWordForward: "opt+right",
      deleteBackward: ["ctrl+backspace", "ctrl+h"],
      deleteForward: ["ctrl+delete", "ctrl+d"],
      deleteLineBackward: "cmd+shift?+backspace",
      deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
      deleteWordBackward: "opt+shift?+backspace",
      deleteWordForward: "opt+shift?+delete",
      extendLineBackward: "opt+shift+up",
      extendLineForward: "opt+shift+down",
      redo: "cmd+shift+z",
      transposeCharacter: "ctrl+t"
    };
    WINDOWS_HOTKEYS = {
      deleteWordBackward: "ctrl+shift?+backspace",
      deleteWordForward: "ctrl+shift?+delete",
      redo: ["ctrl+y", "ctrl+shift+z"]
    };
    create = (key2) => {
      var generic = HOTKEYS[key2];
      var apple = APPLE_HOTKEYS[key2];
      var windows = WINDOWS_HOTKEYS[key2];
      var isGeneric = generic && (0, import_is_hotkey.isHotkey)(generic);
      var isApple = apple && (0, import_is_hotkey.isHotkey)(apple);
      var isWindows = windows && (0, import_is_hotkey.isHotkey)(windows);
      return (event) => {
        if (isGeneric && isGeneric(event))
          return true;
        if (IS_APPLE && isApple && isApple(event))
          return true;
        if (!IS_APPLE && isWindows && isWindows(event))
          return true;
        return false;
      };
    };
    Hotkeys = {
      isBold: create("bold"),
      isCompose: create("compose"),
      isMoveBackward: create("moveBackward"),
      isMoveForward: create("moveForward"),
      isDeleteBackward: create("deleteBackward"),
      isDeleteForward: create("deleteForward"),
      isDeleteLineBackward: create("deleteLineBackward"),
      isDeleteLineForward: create("deleteLineForward"),
      isDeleteWordBackward: create("deleteWordBackward"),
      isDeleteWordForward: create("deleteWordForward"),
      isExtendBackward: create("extendBackward"),
      isExtendForward: create("extendForward"),
      isExtendLineBackward: create("extendLineBackward"),
      isExtendLineForward: create("extendLineForward"),
      isItalic: create("italic"),
      isMoveLineBackward: create("moveLineBackward"),
      isMoveLineForward: create("moveLineForward"),
      isMoveWordBackward: create("moveWordBackward"),
      isMoveWordForward: create("moveWordForward"),
      isRedo: create("redo"),
      isSoftBreak: create("insertSoftBreak"),
      isSplitBlock: create("splitBlock"),
      isTransposeCharacter: create("transposeCharacter"),
      isUndo: create("undo")
    };
    createRestoreDomManager = (editor, receivedUserInput) => {
      var bufferedMutations = [];
      var clear = () => {
        bufferedMutations = [];
      };
      var registerMutations = (mutations) => {
        if (!receivedUserInput.current) {
          return;
        }
        var trackedMutations = mutations.filter((mutation) => isTrackedMutation(editor, mutation, mutations));
        bufferedMutations.push(...trackedMutations);
      };
      function restoreDOM() {
        if (bufferedMutations.length > 0) {
          bufferedMutations.reverse().forEach((mutation) => {
            if (mutation.type === "characterData") {
              return;
            }
            mutation.removedNodes.forEach((node5) => {
              mutation.target.insertBefore(node5, mutation.nextSibling);
            });
            mutation.addedNodes.forEach((node5) => {
              mutation.target.removeChild(node5);
            });
          });
          clear();
        }
      }
      return {
        registerMutations,
        restoreDOM,
        clear
      };
    };
    MUTATION_OBSERVER_CONFIG = {
      subtree: true,
      childList: true,
      characterData: true,
      characterDataOldValue: true
    };
    RestoreDOMComponent = class extends import_react26.Component {
      constructor() {
        super(...arguments);
        _defineProperty3(this, "context", null);
        _defineProperty3(this, "manager", null);
        _defineProperty3(this, "mutationObserver", null);
      }
      observe() {
        var _this$mutationObserve;
        var {
          node: node5
        } = this.props;
        if (!node5.current) {
          throw new Error("Failed to attach MutationObserver, `node` is undefined");
        }
        (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node5.current, MUTATION_OBSERVER_CONFIG);
      }
      componentDidMount() {
        var {
          receivedUserInput
        } = this.props;
        var editor = this.context;
        this.manager = createRestoreDomManager(editor, receivedUserInput);
        this.mutationObserver = new MutationObserver(this.manager.registerMutations);
        this.observe();
      }
      getSnapshotBeforeUpdate() {
        var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;
        var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();
        if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {
          var _this$manager;
          (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);
        }
        (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();
        (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();
        return null;
      }
      componentDidUpdate() {
        var _this$manager3;
        (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();
        this.observe();
      }
      componentWillUnmount() {
        var _this$mutationObserve4;
        (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();
      }
      render() {
        return this.props.children;
      }
    };
    _defineProperty3(RestoreDOMComponent, "contextType", EditorContext);
    RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref2) => {
      var {
        children
      } = _ref2;
      return import_react26.default.createElement(import_react26.default.Fragment, null, children);
    };
    _excluded$12 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"];
    _excluded22 = ["text"];
    Children2 = (props) => import_react26.default.createElement(import_react26.default.Fragment, null, useChildren(props));
    Editable = (props) => {
      var defaultRenderPlaceholder = (0, import_react26.useCallback)((props2) => import_react26.default.createElement(DefaultPlaceholder, _objectSpread$12({}, props2)), []);
      var {
        autoFocus,
        decorate = defaultDecorate,
        onDOMBeforeInput: propsOnDOMBeforeInput,
        placeholder,
        readOnly: readOnly2 = false,
        renderElement,
        renderLeaf,
        renderPlaceholder = defaultRenderPlaceholder,
        scrollSelectionIntoView = defaultScrollSelectionIntoView,
        style: userStyle = {},
        as: Component2 = "div",
        disableDefaultStyles = false
      } = props, attributes = _objectWithoutProperties2(props, _excluded$12);
      var editor = useSlate();
      var [isComposing, setIsComposing] = (0, import_react26.useState)(false);
      var ref = (0, import_react26.useRef)(null);
      var deferredOperations = (0, import_react26.useRef)([]);
      var [placeholderHeight, setPlaceholderHeight] = (0, import_react26.useState)();
      var {
        onUserInput,
        receivedUserInput
      } = useTrackUserInput();
      var [, forceRender] = (0, import_react26.useReducer)((s5) => s5 + 1, 0);
      EDITOR_TO_FORCE_RENDER.set(editor, forceRender);
      IS_READ_ONLY.set(editor, readOnly2);
      var state = (0, import_react26.useMemo)(() => ({
        isDraggingInternally: false,
        isUpdatingSelection: false,
        latestElement: null,
        hasMarkPlaceholder: false
      }), []);
      (0, import_react26.useEffect)(() => {
        if (ref.current && autoFocus) {
          ref.current.focus();
        }
      }, [autoFocus]);
      var androidInputManagerRef = (0, import_react26.useRef)();
      var onDOMSelectionChange = (0, import_react26.useMemo)(() => (0, import_throttle4.default)(() => {
        var androidInputManager = androidInputManagerRef.current;
        if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {
          var root = ReactEditor.findDocumentOrShadowRoot(editor);
          var {
            activeElement
          } = root;
          var el = ReactEditor.toDOMNode(editor, editor);
          var domSelection = root.getSelection();
          if (activeElement === el) {
            state.latestElement = activeElement;
            IS_FOCUSED.set(editor, true);
          } else {
            IS_FOCUSED.delete(editor);
          }
          if (!domSelection) {
            return Transforms.deselect(editor);
          }
          var {
            anchorNode,
            focusNode
          } = domSelection;
          var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);
          var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);
          if (anchorNodeSelectable && focusNodeSelectable) {
            var range3 = ReactEditor.toSlateRange(editor, domSelection, {
              exactMatch: false,
              suppressThrow: true
            });
            if (range3) {
              if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {
                Transforms.select(editor, range3);
              } else {
                androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range3);
              }
            }
          }
          if (readOnly2 && (!anchorNodeSelectable || !focusNodeSelectable)) {
            Transforms.deselect(editor);
          }
        }
      }, 100), [editor, readOnly2, state]);
      var scheduleOnDOMSelectionChange = (0, import_react26.useMemo)(() => (0, import_debounce3.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
      androidInputManagerRef.current = useAndroidInputManager({
        node: ref,
        onDOMSelectionChange,
        scheduleOnDOMSelectionChange
      });
      useIsomorphicLayoutEffect2(() => {
        var _androidInputManagerR, _androidInputManagerR2;
        var window3;
        if (ref.current && (window3 = getDefaultView(ref.current))) {
          EDITOR_TO_WINDOW.set(editor, window3);
          EDITOR_TO_ELEMENT.set(editor, ref.current);
          NODE_TO_ELEMENT.set(editor, ref.current);
          ELEMENT_TO_NODE.set(ref.current, editor);
        } else {
          NODE_TO_ELEMENT.delete(editor);
        }
        var {
          selection
        } = editor;
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        var domSelection = root.getSelection();
        if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {
          return;
        }
        var setDomSelection = (forceChange) => {
          var hasDomSelection = domSelection.type !== "None";
          if (!selection && !hasDomSelection) {
            return;
          }
          var focusNode = domSelection.focusNode;
          var anchorNode;
          if (IS_FIREFOX && domSelection.rangeCount > 1) {
            var firstRange = domSelection.getRangeAt(0);
            var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);
            if (firstRange.startContainer === focusNode) {
              anchorNode = lastRange.endContainer;
            } else {
              anchorNode = firstRange.startContainer;
            }
          } else {
            anchorNode = domSelection.anchorNode;
          }
          var editorElement = EDITOR_TO_ELEMENT.get(editor);
          var hasDomSelectionInEditor = false;
          if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {
            hasDomSelectionInEditor = true;
          }
          if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {
            var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
              exactMatch: true,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: true
            });
            if (slateRange && Range.equals(slateRange, selection)) {
              var _anchorNode;
              if (!state.hasMarkPlaceholder) {
                return;
              }
              if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute("data-slate-mark-placeholder")) {
                return;
              }
            }
          }
          if (selection && !ReactEditor.hasRange(editor, selection)) {
            editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
              exactMatch: false,
              suppressThrow: true
            });
            return;
          }
          state.isUpdatingSelection = true;
          var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);
          if (newDomRange) {
            if (ReactEditor.isComposing(editor) && !IS_ANDROID) {
              domSelection.collapseToEnd();
            } else if (Range.isBackward(selection)) {
              domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
            } else {
              domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
            }
            scrollSelectionIntoView(editor, newDomRange);
          } else {
            domSelection.removeAllRanges();
          }
          return newDomRange;
        };
        if (domSelection.rangeCount <= 1) {
          setDomSelection();
        }
        var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === "action";
        if (!IS_ANDROID || !ensureSelection) {
          setTimeout(() => {
            state.isUpdatingSelection = false;
          });
          return;
        }
        var timeoutId = null;
        var animationFrameId = requestAnimationFrame(() => {
          if (ensureSelection) {
            var ensureDomSelection = (forceChange) => {
              try {
                var el = ReactEditor.toDOMNode(editor, editor);
                el.focus();
                setDomSelection(forceChange);
              } catch (e5) {
              }
            };
            ensureDomSelection();
            timeoutId = setTimeout(() => {
              ensureDomSelection(true);
              state.isUpdatingSelection = false;
            });
          }
        });
        return () => {
          cancelAnimationFrame(animationFrameId);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      });
      var onDOMBeforeInput = (0, import_react26.useCallback)((event) => {
        onUserInput();
        if (!readOnly2 && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
          var _EDITOR_TO_USER_SELEC;
          if (androidInputManagerRef.current) {
            return androidInputManagerRef.current.handleDOMBeforeInput(event);
          }
          scheduleOnDOMSelectionChange.flush();
          onDOMSelectionChange.flush();
          var {
            selection
          } = editor;
          var {
            inputType: type
          } = event;
          var data = event.dataTransfer || event.data || void 0;
          var isCompositionChange = type === "insertCompositionText" || type === "deleteCompositionText";
          if (isCompositionChange && ReactEditor.isComposing(editor)) {
            return;
          }
          var native = false;
          if (type === "insertText" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
          // Long-press events (hold a + press 4 = ) to choose a special character otherwise
          // causes duplicate inserts.
          event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
          // When there is an inline element, e.g. a link, and you select
          // right after it (the start of the next node).
          selection.anchor.offset !== 0) {
            var _node$parentElement, _window$getComputedSt;
            native = true;
            if (editor.marks) {
              native = false;
            }
            var {
              anchor: anchor2
            } = selection;
            var [node5, offset3] = ReactEditor.toDOMPoint(editor, anchor2);
            var anchorNode = (_node$parentElement = node5.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest("a");
            var window3 = ReactEditor.getWindow(editor);
            if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
              var _lastText$textContent;
              var lastText = window3 === null || window3 === void 0 ? void 0 : window3.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
              if (lastText === node5 && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset3) {
                native = false;
              }
            }
            if (native && node5.parentElement && (window3 === null || window3 === void 0 || (_window$getComputedSt = window3.getComputedStyle(node5.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === "pre") {
              var block = Editor.above(editor, {
                at: anchor2.path,
                match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4)
              });
              if (block && Node2.string(block[0]).includes("	")) {
                native = false;
              }
            }
          }
          if (!type.startsWith("delete") || type.startsWith("deleteBy")) {
            var [targetRange2] = event.getTargetRanges();
            if (targetRange2) {
              var range3 = ReactEditor.toSlateRange(editor, targetRange2, {
                exactMatch: false,
                suppressThrow: false
              });
              if (!selection || !Range.equals(selection, range3)) {
                native = false;
                var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);
                Transforms.select(editor, range3);
                if (selectionRef) {
                  EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
                }
              }
            }
          }
          if (isCompositionChange) {
            return;
          }
          if (!native) {
            event.preventDefault();
          }
          if (selection && Range.isExpanded(selection) && type.startsWith("delete")) {
            var direction = type.endsWith("Backward") ? "backward" : "forward";
            Editor.deleteFragment(editor, {
              direction
            });
            return;
          }
          switch (type) {
            case "deleteByComposition":
            case "deleteByCut":
            case "deleteByDrag": {
              Editor.deleteFragment(editor);
              break;
            }
            case "deleteContent":
            case "deleteContentForward": {
              Editor.deleteForward(editor);
              break;
            }
            case "deleteContentBackward": {
              Editor.deleteBackward(editor);
              break;
            }
            case "deleteEntireSoftLine": {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
              Editor.deleteForward(editor, {
                unit: "line"
              });
              break;
            }
            case "deleteHardLineBackward": {
              Editor.deleteBackward(editor, {
                unit: "block"
              });
              break;
            }
            case "deleteSoftLineBackward": {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
              break;
            }
            case "deleteHardLineForward": {
              Editor.deleteForward(editor, {
                unit: "block"
              });
              break;
            }
            case "deleteSoftLineForward": {
              Editor.deleteForward(editor, {
                unit: "line"
              });
              break;
            }
            case "deleteWordBackward": {
              Editor.deleteBackward(editor, {
                unit: "word"
              });
              break;
            }
            case "deleteWordForward": {
              Editor.deleteForward(editor, {
                unit: "word"
              });
              break;
            }
            case "insertLineBreak":
              Editor.insertSoftBreak(editor);
              break;
            case "insertParagraph": {
              Editor.insertBreak(editor);
              break;
            }
            case "insertFromComposition":
            case "insertFromDrop":
            case "insertFromPaste":
            case "insertFromYank":
            case "insertReplacementText":
            case "insertText": {
              if (type === "insertFromComposition") {
                if (ReactEditor.isComposing(editor)) {
                  setIsComposing(false);
                  IS_COMPOSING.set(editor, false);
                }
              }
              if ((data === null || data === void 0 ? void 0 : data.constructor.name) === "DataTransfer") {
                ReactEditor.insertData(editor, data);
              } else if (typeof data === "string") {
                if (native) {
                  deferredOperations.current.push(() => Editor.insertText(editor, data));
                } else {
                  Editor.insertText(editor, data);
                }
              }
              break;
            }
          }
          var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
          EDITOR_TO_USER_SELECTION.delete(editor);
          if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
            Transforms.select(editor, toRestore);
          }
        }
      }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly2, scheduleOnDOMSelectionChange]);
      var callbackRef = (0, import_react26.useCallback)((node5) => {
        if (node5 == null) {
          onDOMSelectionChange.cancel();
          scheduleOnDOMSelectionChange.cancel();
          EDITOR_TO_ELEMENT.delete(editor);
          NODE_TO_ELEMENT.delete(editor);
          if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
            ref.current.removeEventListener("beforeinput", onDOMBeforeInput);
          }
        } else {
          if (HAS_BEFORE_INPUT_SUPPORT) {
            node5.addEventListener("beforeinput", onDOMBeforeInput);
          }
        }
        ref.current = node5;
      }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput]);
      useIsomorphicLayoutEffect2(() => {
        var window3 = ReactEditor.getWindow(editor);
        window3.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
        return () => {
          window3.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
        };
      }, [scheduleOnDOMSelectionChange]);
      var decorations = decorate([editor, []]);
      var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(Node2.texts(editor)).length === 1 && Node2.string(editor) === "" && !isComposing;
      var placeHolderResizeHandler = (0, import_react26.useCallback)((placeholderEl) => {
        if (placeholderEl && showPlaceholder) {
          var _placeholderEl$getBou;
          setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);
        } else {
          setPlaceholderHeight(void 0);
        }
      }, [showPlaceholder]);
      if (showPlaceholder) {
        var start2 = Editor.start(editor, []);
        decorations.push({
          [PLACEHOLDER_SYMBOL]: true,
          placeholder,
          onPlaceholderResize: placeHolderResizeHandler,
          anchor: start2,
          focus: start2
        });
      }
      var {
        marks: marks3
      } = editor;
      state.hasMarkPlaceholder = false;
      if (editor.selection && Range.isCollapsed(editor.selection) && marks3) {
        var {
          anchor
        } = editor.selection;
        var leaf3 = Node2.leaf(editor, anchor.path);
        var rest = _objectWithoutProperties2(leaf3, _excluded22);
        if (!Text.equals(leaf3, marks3, {
          loose: true
        })) {
          state.hasMarkPlaceholder = true;
          var unset = Object.fromEntries(Object.keys(rest).map((mark) => [mark, null]));
          decorations.push(_objectSpread$12(_objectSpread$12(_objectSpread$12({
            [MARK_PLACEHOLDER_SYMBOL]: true
          }, unset), marks3), {}, {
            anchor,
            focus: anchor
          }));
        }
      }
      (0, import_react26.useEffect)(() => {
        setTimeout(() => {
          var {
            selection
          } = editor;
          if (selection) {
            var {
              anchor: _anchor
            } = selection;
            var _text = Node2.leaf(editor, _anchor.path);
            if (marks3 && !Text.equals(_text, marks3, {
              loose: true
            })) {
              EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks3);
              return;
            }
          }
          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
        });
      });
      return import_react26.default.createElement(ReadOnlyContext.Provider, {
        value: readOnly2
      }, import_react26.default.createElement(DecorateContext.Provider, {
        value: decorate
      }, import_react26.default.createElement(RestoreDOM, {
        node: ref,
        receivedUserInput
      }, import_react26.default.createElement(Component2, _objectSpread$12(_objectSpread$12({
        role: readOnly2 ? void 0 : "textbox",
        "aria-multiline": readOnly2 ? void 0 : true
      }, attributes), {}, {
        // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
        // have to use hacks to make these replacement-based features work.
        // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
        // mismatch warning app moves to browser. Pass-through consumer props when
        // not CAN_USE_DOM (SSR) and default to falsy value
        spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
        autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : "false",
        autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : "false",
        "data-slate-editor": true,
        "data-slate-node": "value",
        // explicitly set this
        contentEditable: !readOnly2,
        // in some cases, a decoration needs access to the range / selection to decorate a text node,
        // then you will select the whole text node when you select part the of text
        // this magic zIndex="-1" will fix it
        zindex: -1,
        suppressContentEditableWarning: true,
        ref: callbackRef,
        style: _objectSpread$12(_objectSpread$12({}, disableDefaultStyles ? {} : _objectSpread$12({
          // Allow positioning relative to the editable element.
          position: "relative",
          // Preserve adjacent whitespace and new lines.
          whiteSpace: "pre-wrap",
          // Allow words to break if they are too long.
          wordWrap: "break-word"
        }, placeholderHeight ? {
          minHeight: placeholderHeight
        } : {})), userStyle),
        onBeforeInput: (0, import_react26.useCallback)((event) => {
          if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly2 && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {
            event.preventDefault();
            if (!ReactEditor.isComposing(editor)) {
              var _text2 = event.data;
              Editor.insertText(editor, _text2);
            }
          }
        }, [attributes.onBeforeInput, editor, readOnly2]),
        onInput: (0, import_react26.useCallback)((event) => {
          if (isEventHandled(event, attributes.onInput)) {
            return;
          }
          if (androidInputManagerRef.current) {
            androidInputManagerRef.current.handleInput();
            return;
          }
          for (var op of deferredOperations.current) {
            op();
          }
          deferredOperations.current = [];
        }, [attributes.onInput]),
        onBlur: (0, import_react26.useCallback)((event) => {
          if (readOnly2 || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
            return;
          }
          var root = ReactEditor.findDocumentOrShadowRoot(editor);
          if (state.latestElement === root.activeElement) {
            return;
          }
          var {
            relatedTarget
          } = event;
          var el = ReactEditor.toDOMNode(editor, editor);
          if (relatedTarget === el) {
            return;
          }
          if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
            return;
          }
          if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
            var node5 = ReactEditor.toSlateNode(editor, relatedTarget);
            if (Element2.isElement(node5) && !editor.isVoid(node5)) {
              return;
            }
          }
          if (IS_WEBKIT) {
            var domSelection = root.getSelection();
            domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();
          }
          IS_FOCUSED.delete(editor);
        }, [readOnly2, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),
        onClick: (0, import_react26.useCallback)((event) => {
          if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
            var node5 = ReactEditor.toSlateNode(editor, event.target);
            var path3 = ReactEditor.findPath(editor, node5);
            if (!Editor.hasPath(editor, path3) || Node2.get(editor, path3) !== node5) {
              return;
            }
            if (event.detail === TRIPLE_CLICK && path3.length >= 1) {
              var blockPath = path3;
              if (!(Element2.isElement(node5) && Editor.isBlock(editor, node5))) {
                var _block$;
                var block = Editor.above(editor, {
                  match: (n4) => Element2.isElement(n4) && Editor.isBlock(editor, n4),
                  at: path3
                });
                blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path3.slice(0, 1);
              }
              var range3 = Editor.range(editor, blockPath);
              Transforms.select(editor, range3);
              return;
            }
            if (readOnly2) {
              return;
            }
            var _start = Editor.start(editor, path3);
            var end2 = Editor.end(editor, path3);
            var startVoid = Editor.void(editor, {
              at: _start
            });
            var endVoid = Editor.void(editor, {
              at: end2
            });
            if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
              var _range = Editor.range(editor, _start);
              Transforms.select(editor, _range);
            }
          }
        }, [editor, attributes.onClick, readOnly2]),
        onCompositionEnd: (0, import_react26.useCallback)((event) => {
          if (ReactEditor.hasSelectableTarget(editor, event.target)) {
            var _androidInputManagerR3;
            if (ReactEditor.isComposing(editor)) {
              setIsComposing(false);
              IS_COMPOSING.set(editor, false);
            }
            (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);
            if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {
              return;
            }
            if (!IS_WEBKIT && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
              var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
              EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
              if (placeholderMarks !== void 0) {
                EDITOR_TO_USER_MARKS.set(editor, editor.marks);
                editor.marks = placeholderMarks;
              }
              Editor.insertText(editor, event.data);
              var userMarks = EDITOR_TO_USER_MARKS.get(editor);
              EDITOR_TO_USER_MARKS.delete(editor);
              if (userMarks !== void 0) {
                editor.marks = userMarks;
              }
            }
          }
        }, [attributes.onCompositionEnd, editor]),
        onCompositionUpdate: (0, import_react26.useCallback)((event) => {
          if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
            if (!ReactEditor.isComposing(editor)) {
              setIsComposing(true);
              IS_COMPOSING.set(editor, true);
            }
          }
        }, [attributes.onCompositionUpdate, editor]),
        onCompositionStart: (0, import_react26.useCallback)((event) => {
          if (ReactEditor.hasSelectableTarget(editor, event.target)) {
            var _androidInputManagerR4;
            (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);
            if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {
              return;
            }
            setIsComposing(true);
            var {
              selection
            } = editor;
            if (selection) {
              if (Range.isExpanded(selection)) {
                Editor.deleteFragment(editor);
                return;
              }
              var inline2 = Editor.above(editor, {
                match: (n4) => Element2.isElement(n4) && Editor.isInline(editor, n4),
                mode: "highest"
              });
              if (inline2) {
                var [, inlinePath] = inline2;
                if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
                  var point3 = Editor.after(editor, inlinePath);
                  Transforms.setSelection(editor, {
                    anchor: point3,
                    focus: point3
                  });
                }
              }
            }
          }
        }, [attributes.onCompositionStart, editor]),
        onCopy: (0, import_react26.useCallback)((event) => {
          if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {
            event.preventDefault();
            ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
          }
        }, [attributes.onCopy, editor]),
        onCut: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {
            event.preventDefault();
            ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
            var {
              selection
            } = editor;
            if (selection) {
              if (Range.isExpanded(selection)) {
                Editor.deleteFragment(editor);
              } else {
                var node5 = Node2.parent(editor, selection.anchor.path);
                if (Editor.isVoid(editor, node5)) {
                  Transforms.delete(editor);
                }
              }
            }
          }
        }, [readOnly2, editor, attributes.onCut]),
        onDragOver: (0, import_react26.useCallback)((event) => {
          if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
            var node5 = ReactEditor.toSlateNode(editor, event.target);
            if (Element2.isElement(node5) && Editor.isVoid(editor, node5)) {
              event.preventDefault();
            }
          }
        }, [attributes.onDragOver, editor]),
        onDragStart: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
            var node5 = ReactEditor.toSlateNode(editor, event.target);
            var path3 = ReactEditor.findPath(editor, node5);
            var voidMatch = Element2.isElement(node5) && Editor.isVoid(editor, node5) || Editor.void(editor, {
              at: path3,
              voids: true
            });
            if (voidMatch) {
              var range3 = Editor.range(editor, path3);
              Transforms.select(editor, range3);
            }
            state.isDraggingInternally = true;
            ReactEditor.setFragmentData(editor, event.dataTransfer, "drag");
          }
        }, [readOnly2, editor, attributes.onDragStart, state]),
        onDrop: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
            event.preventDefault();
            var draggedRange = editor.selection;
            var range3 = ReactEditor.findEventRange(editor, event);
            var data = event.dataTransfer;
            Transforms.select(editor, range3);
            if (state.isDraggingInternally) {
              if (draggedRange && !Range.equals(draggedRange, range3) && !Editor.void(editor, {
                at: range3,
                voids: true
              })) {
                Transforms.delete(editor, {
                  at: draggedRange
                });
              }
            }
            ReactEditor.insertData(editor, data);
            if (!ReactEditor.isFocused(editor)) {
              ReactEditor.focus(editor);
            }
          }
          state.isDraggingInternally = false;
        }, [readOnly2, editor, attributes.onDrop, state]),
        onDragEnd: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {
            attributes.onDragEnd(event);
          }
          state.isDraggingInternally = false;
        }, [readOnly2, state, attributes, editor]),
        onFocus: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
            var el = ReactEditor.toDOMNode(editor, editor);
            var root = ReactEditor.findDocumentOrShadowRoot(editor);
            state.latestElement = root.activeElement;
            if (IS_FIREFOX && event.target !== el) {
              el.focus();
              return;
            }
            IS_FOCUSED.set(editor, true);
          }
        }, [readOnly2, state, editor, attributes.onFocus]),
        onKeyDown: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && ReactEditor.hasEditableTarget(editor, event.target)) {
            var _androidInputManagerR5;
            (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);
            var {
              nativeEvent
            } = event;
            if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
              IS_COMPOSING.set(editor, false);
              setIsComposing(false);
            }
            if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
              return;
            }
            var {
              selection
            } = editor;
            var element = editor.children[selection !== null ? selection.focus.path[0] : 0];
            var isRTL2 = (0, import_direction.default)(Node2.string(element)) === "rtl";
            if (Hotkeys.isRedo(nativeEvent)) {
              event.preventDefault();
              var maybeHistoryEditor = editor;
              if (typeof maybeHistoryEditor.redo === "function") {
                maybeHistoryEditor.redo();
              }
              return;
            }
            if (Hotkeys.isUndo(nativeEvent)) {
              event.preventDefault();
              var _maybeHistoryEditor = editor;
              if (typeof _maybeHistoryEditor.undo === "function") {
                _maybeHistoryEditor.undo();
              }
              return;
            }
            if (Hotkeys.isMoveLineBackward(nativeEvent)) {
              event.preventDefault();
              Transforms.move(editor, {
                unit: "line",
                reverse: true
              });
              return;
            }
            if (Hotkeys.isMoveLineForward(nativeEvent)) {
              event.preventDefault();
              Transforms.move(editor, {
                unit: "line"
              });
              return;
            }
            if (Hotkeys.isExtendLineBackward(nativeEvent)) {
              event.preventDefault();
              Transforms.move(editor, {
                unit: "line",
                edge: "focus",
                reverse: true
              });
              return;
            }
            if (Hotkeys.isExtendLineForward(nativeEvent)) {
              event.preventDefault();
              Transforms.move(editor, {
                unit: "line",
                edge: "focus"
              });
              return;
            }
            if (Hotkeys.isMoveBackward(nativeEvent)) {
              event.preventDefault();
              if (selection && Range.isCollapsed(selection)) {
                Transforms.move(editor, {
                  reverse: !isRTL2
                });
              } else {
                Transforms.collapse(editor, {
                  edge: "start"
                });
              }
              return;
            }
            if (Hotkeys.isMoveForward(nativeEvent)) {
              event.preventDefault();
              if (selection && Range.isCollapsed(selection)) {
                Transforms.move(editor, {
                  reverse: isRTL2
                });
              } else {
                Transforms.collapse(editor, {
                  edge: "end"
                });
              }
              return;
            }
            if (Hotkeys.isMoveWordBackward(nativeEvent)) {
              event.preventDefault();
              if (selection && Range.isExpanded(selection)) {
                Transforms.collapse(editor, {
                  edge: "focus"
                });
              }
              Transforms.move(editor, {
                unit: "word",
                reverse: !isRTL2
              });
              return;
            }
            if (Hotkeys.isMoveWordForward(nativeEvent)) {
              event.preventDefault();
              if (selection && Range.isExpanded(selection)) {
                Transforms.collapse(editor, {
                  edge: "focus"
                });
              }
              Transforms.move(editor, {
                unit: "word",
                reverse: isRTL2
              });
              return;
            }
            if (!HAS_BEFORE_INPUT_SUPPORT) {
              if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
                event.preventDefault();
                return;
              }
              if (Hotkeys.isSoftBreak(nativeEvent)) {
                event.preventDefault();
                Editor.insertSoftBreak(editor);
                return;
              }
              if (Hotkeys.isSplitBlock(nativeEvent)) {
                event.preventDefault();
                Editor.insertBreak(editor);
                return;
              }
              if (Hotkeys.isDeleteBackward(nativeEvent)) {
                event.preventDefault();
                if (selection && Range.isExpanded(selection)) {
                  Editor.deleteFragment(editor, {
                    direction: "backward"
                  });
                } else {
                  Editor.deleteBackward(editor);
                }
                return;
              }
              if (Hotkeys.isDeleteForward(nativeEvent)) {
                event.preventDefault();
                if (selection && Range.isExpanded(selection)) {
                  Editor.deleteFragment(editor, {
                    direction: "forward"
                  });
                } else {
                  Editor.deleteForward(editor);
                }
                return;
              }
              if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
                event.preventDefault();
                if (selection && Range.isExpanded(selection)) {
                  Editor.deleteFragment(editor, {
                    direction: "backward"
                  });
                } else {
                  Editor.deleteBackward(editor, {
                    unit: "line"
                  });
                }
                return;
              }
              if (Hotkeys.isDeleteLineForward(nativeEvent)) {
                event.preventDefault();
                if (selection && Range.isExpanded(selection)) {
                  Editor.deleteFragment(editor, {
                    direction: "forward"
                  });
                } else {
                  Editor.deleteForward(editor, {
                    unit: "line"
                  });
                }
                return;
              }
              if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
                event.preventDefault();
                if (selection && Range.isExpanded(selection)) {
                  Editor.deleteFragment(editor, {
                    direction: "backward"
                  });
                } else {
                  Editor.deleteBackward(editor, {
                    unit: "word"
                  });
                }
                return;
              }
              if (Hotkeys.isDeleteWordForward(nativeEvent)) {
                event.preventDefault();
                if (selection && Range.isExpanded(selection)) {
                  Editor.deleteFragment(editor, {
                    direction: "forward"
                  });
                } else {
                  Editor.deleteForward(editor, {
                    unit: "word"
                  });
                }
                return;
              }
            } else {
              if (IS_CHROME || IS_WEBKIT) {
                if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
                  var currentNode = Node2.parent(editor, selection.anchor.path);
                  if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {
                    event.preventDefault();
                    Editor.deleteBackward(editor, {
                      unit: "block"
                    });
                    return;
                  }
                }
              }
            }
          }
        }, [readOnly2, editor, attributes.onKeyDown]),
        onPaste: (0, import_react26.useCallback)((event) => {
          if (!readOnly2 && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
            if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_WEBKIT) {
              event.preventDefault();
              ReactEditor.insertData(editor, event.clipboardData);
            }
          }
        }, [readOnly2, editor, attributes.onPaste])
      }), import_react26.default.createElement(Children2, {
        decorations,
        node: editor,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection: editor.selection
      })))));
    };
    DefaultPlaceholder = (_ref2) => {
      var {
        attributes,
        children
      } = _ref2;
      return (
        // COMPAT: Artificially add a line-break to the end on the placeholder element
        // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
        import_react26.default.createElement("span", _objectSpread$12({}, attributes), children, IS_ANDROID && import_react26.default.createElement("br", null))
      );
    };
    defaultDecorate = () => [];
    defaultScrollSelectionIntoView = (editor, domRange) => {
      if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {
        var leafEl = domRange.startContainer.parentElement;
        leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
        e4(leafEl, {
          scrollMode: "if-needed"
        });
        delete leafEl.getBoundingClientRect;
      }
    };
    isEventHandled = (event, handler) => {
      if (!handler) {
        return false;
      }
      var shouldTreatEventAsHandled = handler(event);
      if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
      }
      return event.isDefaultPrevented() || event.isPropagationStopped();
    };
    isDOMEventTargetInput = (event) => {
      return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);
    };
    isDOMEventHandled = (event, handler) => {
      if (!handler) {
        return false;
      }
      var shouldTreatEventAsHandled = handler(event);
      if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
      }
      return event.defaultPrevented;
    };
    FocusedContext = (0, import_react26.createContext)(false);
    useFocused = () => {
      return (0, import_react26.useContext)(FocusedContext);
    };
    SlateSelectorContext = (0, import_react26.createContext)({});
    refEquality = (a5, b3) => a5 === b3;
    _excluded3 = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"];
    Slate = (props) => {
      var {
        editor,
        children,
        onChange,
        onSelectionChange,
        onValueChange,
        initialValue
      } = props, rest = _objectWithoutProperties2(props, _excluded3);
      var [context2, setContext] = import_react26.default.useState(() => {
        if (!Node2.isNodeList(initialValue)) {
          throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Scrubber.stringify(initialValue)));
        }
        if (!Editor.isEditor(editor)) {
          throw new Error("[Slate] editor is invalid! You passed: ".concat(Scrubber.stringify(editor)));
        }
        editor.children = initialValue;
        Object.assign(editor, rest);
        return {
          v: 0,
          editor
        };
      });
      var {
        selectorContext,
        onChange: handleSelectorChange
      } = useSelectorContext(editor);
      var onContextChange = (0, import_react26.useCallback)((options) => {
        var _options$operation;
        if (onChange) {
          onChange(editor.children);
        }
        switch (options === null || options === void 0 || (_options$operation = options.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type) {
          case "set_selection":
            onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);
            break;
          default:
            onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);
        }
        setContext((prevContext) => ({
          v: prevContext.v + 1,
          editor
        }));
        handleSelectorChange(editor);
      }, [editor, handleSelectorChange, onChange, onSelectionChange, onValueChange]);
      (0, import_react26.useEffect)(() => {
        EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
        return () => {
          EDITOR_TO_ON_CHANGE.set(editor, () => {
          });
        };
      }, [editor, onContextChange]);
      var [isFocused, setIsFocused] = (0, import_react26.useState)(ReactEditor.isFocused(editor));
      (0, import_react26.useEffect)(() => {
        setIsFocused(ReactEditor.isFocused(editor));
      }, [editor]);
      useIsomorphicLayoutEffect2(() => {
        var fn = () => setIsFocused(ReactEditor.isFocused(editor));
        if (REACT_MAJOR_VERSION >= 17) {
          document.addEventListener("focusin", fn);
          document.addEventListener("focusout", fn);
          return () => {
            document.removeEventListener("focusin", fn);
            document.removeEventListener("focusout", fn);
          };
        } else {
          document.addEventListener("focus", fn, true);
          document.addEventListener("blur", fn, true);
          return () => {
            document.removeEventListener("focus", fn, true);
            document.removeEventListener("blur", fn, true);
          };
        }
      }, []);
      return import_react26.default.createElement(SlateSelectorContext.Provider, {
        value: selectorContext
      }, import_react26.default.createElement(SlateContext.Provider, {
        value: context2
      }, import_react26.default.createElement(EditorContext.Provider, {
        value: context2.editor
      }, import_react26.default.createElement(FocusedContext.Provider, {
        value: isFocused
      }, children))));
    };
    useEditor = () => {
      var editor = (0, import_react26.useContext)(EditorContext);
      if (!editor) {
        throw new Error("The `useEditor` hook must be used inside the <Slate> component's context.");
      }
      return editor;
    };
    useSlateSelection = () => {
      return useSlateSelector((editor) => editor.selection, isSelectionEqual);
    };
    isSelectionEqual = (a5, b3) => {
      if (!a5 && !b3)
        return true;
      if (!a5 || !b3)
        return false;
      return Range.equals(a5, b3);
    };
    doRectsIntersect = (rect, compareRect) => {
      var middle = (compareRect.top + compareRect.bottom) / 2;
      return rect.top <= middle && rect.bottom >= middle;
    };
    areRangesSameLine = (editor, range1, range22) => {
      var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
      var rect2 = ReactEditor.toDOMRange(editor, range22).getBoundingClientRect();
      return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
    };
    findCurrentLineRange = (editor, parentRange) => {
      var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));
      var positions2 = Array.from(Editor.positions(editor, {
        at: parentRange
      }));
      var left = 0;
      var right = positions2.length;
      var middle = Math.floor(right / 2);
      if (areRangesSameLine(editor, Editor.range(editor, positions2[left]), parentRangeBoundary)) {
        return Editor.range(editor, positions2[left], parentRangeBoundary);
      }
      if (positions2.length < 2) {
        return Editor.range(editor, positions2[positions2.length - 1], parentRangeBoundary);
      }
      while (middle !== positions2.length && middle !== left) {
        if (areRangesSameLine(editor, Editor.range(editor, positions2[middle]), parentRangeBoundary)) {
          right = middle;
        } else {
          left = middle;
        }
        middle = Math.floor((left + right) / 2);
      }
      return Editor.range(editor, positions2[right], parentRangeBoundary);
    };
    withReact = function withReact2(editor) {
      var clipboardFormatKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment";
      var e5 = editor;
      var {
        apply: apply2,
        onChange,
        deleteBackward: deleteBackward2,
        addMark: addMark2,
        removeMark: removeMark2
      } = e5;
      EDITOR_TO_KEY_TO_ELEMENT.set(e5, /* @__PURE__ */ new WeakMap());
      e5.addMark = (key2, value) => {
        var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;
        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e5)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();
        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e5) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e5)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {
          EDITOR_TO_PENDING_INSERTION_MARKS.set(e5, null);
        }
        EDITOR_TO_USER_MARKS.delete(e5);
        addMark2(key2, value);
      };
      e5.removeMark = (key2) => {
        var _EDITOR_TO_PENDING_DI2;
        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e5) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e5)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {
          EDITOR_TO_PENDING_INSERTION_MARKS.set(e5, null);
        }
        EDITOR_TO_USER_MARKS.delete(e5);
        removeMark2(key2);
      };
      e5.deleteBackward = (unit) => {
        if (unit !== "line") {
          return deleteBackward2(unit);
        }
        if (e5.selection && Range.isCollapsed(e5.selection)) {
          var parentBlockEntry = Editor.above(e5, {
            match: (n4) => Element2.isElement(n4) && Editor.isBlock(e5, n4),
            at: e5.selection
          });
          if (parentBlockEntry) {
            var [, parentBlockPath] = parentBlockEntry;
            var parentElementRange = Editor.range(e5, parentBlockPath, e5.selection.anchor);
            var currentLineRange = findCurrentLineRange(e5, parentElementRange);
            if (!Range.isCollapsed(currentLineRange)) {
              Transforms.delete(e5, {
                at: currentLineRange
              });
            }
          }
        }
      };
      e5.apply = (op) => {
        var matches = [];
        var pathRefMatches = [];
        var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e5);
        if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {
          var transformed = pendingDiffs.map((textDiff) => transformTextDiff(textDiff, op)).filter(Boolean);
          EDITOR_TO_PENDING_DIFFS.set(e5, transformed);
        }
        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e5);
        if (pendingSelection) {
          EDITOR_TO_PENDING_SELECTION.set(e5, transformPendingRange(e5, pendingSelection, op));
        }
        var pendingAction = EDITOR_TO_PENDING_ACTION.get(e5);
        if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {
          var at2 = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e5, pendingAction.at, op) : transformPendingRange(e5, pendingAction.at, op);
          EDITOR_TO_PENDING_ACTION.set(e5, at2 ? _objectSpread2(_objectSpread2({}, pendingAction), {}, {
            at: at2
          }) : null);
        }
        switch (op.type) {
          case "insert_text":
          case "remove_text":
          case "set_node":
          case "split_node": {
            matches.push(...getMatches(e5, op.path));
            break;
          }
          case "set_selection": {
            var _EDITOR_TO_USER_SELEC;
            (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e5)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();
            EDITOR_TO_USER_SELECTION.delete(e5);
            break;
          }
          case "insert_node":
          case "remove_node": {
            matches.push(...getMatches(e5, Path.parent(op.path)));
            break;
          }
          case "merge_node": {
            var prevPath = Path.previous(op.path);
            matches.push(...getMatches(e5, prevPath));
            break;
          }
          case "move_node": {
            var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
            matches.push(...getMatches(e5, commonPath));
            var changedPath;
            if (Path.isBefore(op.path, op.newPath)) {
              matches.push(...getMatches(e5, Path.parent(op.path)));
              changedPath = op.newPath;
            } else {
              matches.push(...getMatches(e5, Path.parent(op.newPath)));
              changedPath = op.path;
            }
            var changedNode = Node2.get(editor, Path.parent(changedPath));
            var changedNodeKey = ReactEditor.findKey(e5, changedNode);
            var changedPathRef = Editor.pathRef(e5, Path.parent(changedPath));
            pathRefMatches.push([changedPathRef, changedNodeKey]);
            break;
          }
        }
        apply2(op);
        for (var [path3, key2] of matches) {
          var [node5] = Editor.node(e5, path3);
          NODE_TO_KEY.set(node5, key2);
        }
        for (var [pathRef3, _key] of pathRefMatches) {
          if (pathRef3.current) {
            var [_node] = Editor.node(e5, pathRef3.current);
            NODE_TO_KEY.set(_node, _key);
          }
        }
      };
      e5.setFragmentData = (data) => {
        var {
          selection
        } = e5;
        if (!selection) {
          return;
        }
        var [start2, end2] = Range.edges(selection);
        var startVoid = Editor.void(e5, {
          at: start2.path
        });
        var endVoid = Editor.void(e5, {
          at: end2.path
        });
        if (Range.isCollapsed(selection) && !startVoid) {
          return;
        }
        var domRange = ReactEditor.toDOMRange(e5, selection);
        var contents = domRange.cloneContents();
        var attach = contents.childNodes[0];
        contents.childNodes.forEach((node5) => {
          if (node5.textContent && node5.textContent.trim() !== "") {
            attach = node5;
          }
        });
        if (endVoid) {
          var [voidNode] = endVoid;
          var r4 = domRange.cloneRange();
          var domNode = ReactEditor.toDOMNode(e5, voidNode);
          r4.setEndAfter(domNode);
          contents = r4.cloneContents();
        }
        if (startVoid) {
          attach = contents.querySelector("[data-slate-spacer]");
        }
        Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
          var isNewline = zw.getAttribute("data-slate-zero-width") === "n";
          zw.textContent = isNewline ? "\n" : "";
        });
        if (isDOMText(attach)) {
          var span = attach.ownerDocument.createElement("span");
          span.style.whiteSpace = "pre";
          span.appendChild(attach);
          contents.appendChild(span);
          attach = span;
        }
        var fragment2 = e5.getFragment();
        var string4 = JSON.stringify(fragment2);
        var encoded = window.btoa(encodeURIComponent(string4));
        attach.setAttribute("data-slate-fragment", encoded);
        data.setData("application/".concat(clipboardFormatKey), encoded);
        var div = contents.ownerDocument.createElement("div");
        div.appendChild(contents);
        div.setAttribute("hidden", "true");
        contents.ownerDocument.body.appendChild(div);
        data.setData("text/html", div.innerHTML);
        data.setData("text/plain", getPlainText(div));
        contents.ownerDocument.body.removeChild(div);
        return data;
      };
      e5.insertData = (data) => {
        if (!e5.insertFragmentData(data)) {
          e5.insertTextData(data);
        }
      };
      e5.insertFragmentData = (data) => {
        var fragment2 = data.getData("application/".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);
        if (fragment2) {
          var decoded = decodeURIComponent(window.atob(fragment2));
          var parsed = JSON.parse(decoded);
          e5.insertFragment(parsed);
          return true;
        }
        return false;
      };
      e5.insertTextData = (data) => {
        var text = data.getData("text/plain");
        if (text) {
          var lines = text.split(/\r\n|\r|\n/);
          var split = false;
          for (var line2 of lines) {
            if (split) {
              Transforms.splitNodes(e5, {
                always: true
              });
            }
            e5.insertText(line2);
            split = true;
          }
          return true;
        }
        return false;
      };
      e5.onChange = (options) => {
        var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? import_react_dom2.default.unstable_batchedUpdates : (callback) => callback();
        maybeBatchUpdates(() => {
          var onContextChange = EDITOR_TO_ON_CHANGE.get(e5);
          if (onContextChange) {
            onContextChange(options);
          }
          onChange(options);
        });
      };
      return e5;
    };
    getMatches = (e5, path3) => {
      var matches = [];
      for (var [n4, p2] of Editor.levels(e5, {
        at: path3
      })) {
        var key2 = ReactEditor.findKey(e5, n4);
        matches.push([p2, key2]);
      }
      return matches;
    };
  }
});

// node_modules/moment/dist/moment.js
var moment_exports = {};
__export(moment_exports, {
  default: () => moment_default
});
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray4(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject3(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a5, b3) {
  return Object.prototype.hasOwnProperty.call(a5, b3);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k3;
    for (k3 in obj) {
      if (hasOwnProp(obj, k3)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate2(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map2(arr, fn) {
  var res = [], i4, arrLen = arr.length;
  for (i4 = 0; i4 < arrLen; ++i4) {
    res.push(fn(arr[i4], i4));
  }
  return res;
}
function extend(a5, b3) {
  for (var i4 in b3) {
    if (hasOwnProp(b3, i4)) {
      a5[i4] = b3[i4];
    }
  }
  if (hasOwnProp(b3, "toString")) {
    a5.toString = b3.toString;
  }
  if (hasOwnProp(b3, "valueOf")) {
    a5.valueOf = b3.valueOf;
  }
  return a5;
}
function createUTC(input, format4, locale3, strict) {
  return createLocalOrUTC(input, format4, locale3, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m4) {
  if (m4._pf == null) {
    m4._pf = defaultParsingFlags();
  }
  return m4._pf;
}
function isValid2(m4) {
  if (m4._isValid == null) {
    var flags = getParsingFlags(m4), parsedParts = some.call(flags.parsedDateParts, function(i4) {
      return i4 != null;
    }), isNowValid = !isNaN(m4._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m4._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m4)) {
      m4._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m4._isValid;
}
function createInvalid(flags) {
  var m4 = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m4), flags);
  } else {
    getParsingFlags(m4).userInvalidated = true;
  }
  return m4;
}
function copyConfig(to2, from4) {
  var i4, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from4._isAMomentObject)) {
    to2._isAMomentObject = from4._isAMomentObject;
  }
  if (!isUndefined(from4._i)) {
    to2._i = from4._i;
  }
  if (!isUndefined(from4._f)) {
    to2._f = from4._f;
  }
  if (!isUndefined(from4._l)) {
    to2._l = from4._l;
  }
  if (!isUndefined(from4._strict)) {
    to2._strict = from4._strict;
  }
  if (!isUndefined(from4._tzm)) {
    to2._tzm = from4._tzm;
  }
  if (!isUndefined(from4._isUTC)) {
    to2._isUTC = from4._isUTC;
  }
  if (!isUndefined(from4._offset)) {
    to2._offset = from4._offset;
  }
  if (!isUndefined(from4._pf)) {
    to2._pf = getParsingFlags(from4);
  }
  if (!isUndefined(from4._locale)) {
    to2._locale = from4._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i4 = 0; i4 < momentPropertiesLen; i4++) {
      prop = momentProperties[i4];
      val = from4[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn2(msg2) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg2);
  }
}
function deprecate(msg2, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg2);
    }
    if (firstTime) {
      var args = [], arg, i4, key2, argLen = arguments.length;
      for (i4 = 0; i4 < argLen; i4++) {
        arg = "";
        if (typeof arguments[i4] === "object") {
          arg += "\n[" + i4 + "] ";
          for (key2 in arguments[0]) {
            if (hasOwnProp(arguments[0], key2)) {
              arg += key2 + ": " + arguments[0][key2] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i4];
        }
        args.push(arg);
      }
      warn2(
        msg2 + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
function deprecateSimple(name, msg2) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg2);
  }
  if (!deprecations[name]) {
    warn2(msg2);
    deprecations[name] = true;
  }
}
function isFunction2(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set3(config2) {
  var prop, i4;
  for (i4 in config2) {
    if (hasOwnProp(config2, i4)) {
      prop = config2[i4];
      if (isFunction2(prop)) {
        this[i4] = prop;
      } else {
        this["_" + i4] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject3(parentConfig[prop]) && isObject3(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject3(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
function calendar(key2, mom, now2) {
  var output = this._calendar[key2] || this._calendar["sameElse"];
  return isFunction2(output) ? output.call(mom, now2) : output;
}
function zeroFill(number2, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
function addFormatToken(token3, padded, ordinal2, callback) {
  var func2 = callback;
  if (typeof callback === "string") {
    func2 = function() {
      return this[callback]();
    };
  }
  if (token3) {
    formatTokenFunctions[token3] = func2;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func2.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func2.apply(this, arguments),
        token3
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format4) {
  var array = format4.match(formattingTokens), i4, length2;
  for (i4 = 0, length2 = array.length; i4 < length2; i4++) {
    if (formatTokenFunctions[array[i4]]) {
      array[i4] = formatTokenFunctions[array[i4]];
    } else {
      array[i4] = removeFormattingTokens(array[i4]);
    }
  }
  return function(mom) {
    var output = "", i5;
    for (i5 = 0; i5 < length2; i5++) {
      output += isFunction2(array[i5]) ? array[i5].call(mom, format4) : array[i5];
    }
    return output;
  };
}
function formatMoment(m4, format4) {
  if (!m4.isValid()) {
    return m4.localeData().invalidDate();
  }
  format4 = expandFormat(format4, m4.localeData());
  formatFunctions[format4] = formatFunctions[format4] || makeFormatFunction(format4);
  return formatFunctions[format4](m4);
}
function expandFormat(format4, locale3) {
  var i4 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale3.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i4 >= 0 && localFormattingTokens.test(format4)) {
    format4 = format4.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i4 -= 1;
  }
  return format4;
}
function longDateFormat(key2) {
  var format4 = this._longDateFormat[key2], formatUpper = this._longDateFormat[key2.toUpperCase()];
  if (format4 || !formatUpper) {
    return format4;
  }
  this._longDateFormat[key2] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key2];
}
function invalidDate() {
  return this._invalidDate;
}
function ordinal(number2) {
  return this._ordinal.replace("%d", number2);
}
function relativeTime(number2, withoutSuffix, string4, isFuture2) {
  var output = this._relativeTime[string4];
  return isFunction2(output) ? output(number2, withoutSuffix, string4, isFuture2) : output.replace(/%d/i, number2);
}
function pastFuture(diff2, output) {
  var format4 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction2(format4) ? format4(output) : format4.replace(/%s/i, output);
}
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u3;
  for (u3 in unitsObj) {
    if (hasOwnProp(unitsObj, u3)) {
      units.push({ unit: u3, priority: priorities[u3] });
    }
  }
  units.sort(function(a5, b3) {
    return a5.priority - b3.priority;
  });
  return units;
}
function isLeapYear2(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number2) {
  if (number2 < 0) {
    return Math.ceil(number2) || 0;
  } else {
    return Math.floor(number2);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear2(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction2(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i4, prioritizedLen = prioritized.length;
    for (i4 = 0; i4 < prioritizedLen; i4++) {
      this[prioritized[i4].unit](units[prioritized[i4].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction2(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function addRegexToken(token3, regex, strictRegex) {
  regexes[token3] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token3, config2) {
  if (!hasOwnProp(regexes, token3)) {
    return new RegExp(unescapeFormat(token3));
  }
  return regexes[token3](config2._strict, config2._locale);
}
function unescapeFormat(s5) {
  return regexEscape(
    s5.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s5) {
  return s5.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function addParseToken(token3, callback) {
  var i4, func2 = callback, tokenLen;
  if (typeof token3 === "string") {
    token3 = [token3];
  }
  if (isNumber(callback)) {
    func2 = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token3.length;
  for (i4 = 0; i4 < tokenLen; i4++) {
    tokens[token3[i4]] = func2;
  }
}
function addWeekParseToken(token3, callback) {
  addParseToken(token3, function(input, array, config2, token4) {
    config2._w = config2._w || {};
    callback(input, config2._w, config2, token4);
  });
}
function addTimeToArrayFromToken(token3, input, config2) {
  if (input != null && hasOwnProp(tokens, token3)) {
    tokens[token3](input, config2._a, config2, token3);
  }
}
function mod(n4, x3) {
  return (n4 % x3 + x3) % x3;
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear2(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
function localeMonths(m4, format4) {
  if (!m4) {
    return isArray4(this._months) ? this._months : this._months["standalone"];
  }
  return isArray4(this._months) ? this._months[m4.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format4) ? "format" : "standalone"][m4.month()];
}
function localeMonthsShort(m4, format4) {
  if (!m4) {
    return isArray4(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray4(this._monthsShort) ? this._monthsShort[m4.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format4) ? "format" : "standalone"][m4.month()];
}
function handleStrictParse(monthName, format4, strict) {
  var i4, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i4 = 0; i4 < 12; ++i4) {
      mom = createUTC([2e3, i4]);
      this._shortMonthsParse[i4] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i4] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format4 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format4 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format4, strict) {
  var i4, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format4, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i4 = 0; i4 < 12; i4++) {
    mom = createUTC([2e3, i4]);
    if (strict && !this._longMonthsParse[i4]) {
      this._longMonthsParse[i4] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i4] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i4]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i4] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format4 === "MMMM" && this._longMonthsParse[i4].test(monthName)) {
      return i4;
    } else if (strict && format4 === "MMM" && this._shortMonthsParse[i4].test(monthName)) {
      return i4;
    } else if (!strict && this._monthsParse[i4].test(monthName)) {
      return i4;
    }
  }
}
function setMonth2(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth2(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth2() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a5, b3) {
    return b3.length - a5.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i4, mom;
  for (i4 = 0; i4 < 12; i4++) {
    mom = createUTC([2e3, i4]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i4 = 0; i4 < 12; i4++) {
    shortPieces[i4] = regexEscape(shortPieces[i4]);
    longPieces[i4] = regexEscape(longPieces[i4]);
  }
  for (i4 = 0; i4 < 24; i4++) {
    mixedPieces[i4] = regexEscape(mixedPieces[i4]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function daysInYear3(year) {
  return isLeapYear2(year) ? 366 : 365;
}
function getIsLeapYear() {
  return isLeapYear2(this.year());
}
function createDate(y4, m4, d3, h3, M4, s5, ms) {
  var date2;
  if (y4 < 100 && y4 >= 0) {
    date2 = new Date(y4 + 400, m4, d3, h3, M4, s5, ms);
    if (isFinite(date2.getFullYear())) {
      date2.setFullYear(y4);
    }
  } else {
    date2 = new Date(y4, m4, d3, h3, M4, s5, ms);
  }
  return date2;
}
function createUTCDate(y4) {
  var date2, args;
  if (y4 < 100 && y4 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y4 + 400;
    date2 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date2.getUTCFullYear())) {
      date2.setUTCFullYear(y4);
    }
  } else {
    date2 = new Date(Date.UTC.apply(null, arguments));
  }
  return date2;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear3(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear3(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear3(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear3(year) - weekOffset + weekOffsetNext) / 7;
}
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
function parseWeekday(input, locale3) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale3.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale3) {
  if (typeof input === "string") {
    return locale3.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n4) {
  return ws.slice(n4, 7).concat(ws.slice(0, n4));
}
function localeWeekdays(m4, format4) {
  var weekdays = isArray4(this._weekdays) ? this._weekdays : this._weekdays[m4 && m4 !== true && this._weekdays.isFormat.test(format4) ? "format" : "standalone"];
  return m4 === true ? shiftWeekdays(weekdays, this._week.dow) : m4 ? weekdays[m4.day()] : weekdays;
}
function localeWeekdaysShort(m4) {
  return m4 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m4 ? this._weekdaysShort[m4.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m4) {
  return m4 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m4 ? this._weekdaysMin[m4.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format4, strict) {
  var i4, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i4 = 0; i4 < 7; ++i4) {
      mom = createUTC([2e3, 1]).day(i4);
      this._minWeekdaysParse[i4] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i4] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i4] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format4 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format4 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format4 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format4 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format4, strict) {
  var i4, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format4, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i4 = 0; i4 < 7; i4++) {
    mom = createUTC([2e3, 1]).day(i4);
    if (strict && !this._fullWeekdaysParse[i4]) {
      this._fullWeekdaysParse[i4] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i4] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i4] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i4]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i4] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format4 === "dddd" && this._fullWeekdaysParse[i4].test(weekdayName)) {
      return i4;
    } else if (strict && format4 === "ddd" && this._shortWeekdaysParse[i4].test(weekdayName)) {
      return i4;
    } else if (strict && format4 === "dd" && this._minWeekdaysParse[i4].test(weekdayName)) {
      return i4;
    } else if (!strict && this._weekdaysParse[i4].test(weekdayName)) {
      return i4;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a5, b3) {
    return b3.length - a5.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i4, mom, minp, shortp, longp;
  for (i4 = 0; i4 < 7; i4++) {
    mom = createUTC([2e3, 1]).day(i4);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
function meridiem(token3, lowercase) {
  addFormatToken(token3, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
function matchMeridiem(isStrict, locale3) {
  return locale3._meridiemParse;
}
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
function commonPrefix(arr1, arr2) {
  var i4, minl = Math.min(arr1.length, arr2.length);
  for (i4 = 0; i4 < minl; i4 += 1) {
    if (arr1[i4] !== arr2[i4]) {
      return i4;
    }
  }
  return minl;
}
function normalizeLocale(key2) {
  return key2 ? key2.toLowerCase().replace("_", "-") : key2;
}
function chooseLocale(names) {
  var i4 = 0, j2, next4, locale3, split;
  while (i4 < names.length) {
    split = normalizeLocale(names[i4]).split("-");
    j2 = split.length;
    next4 = normalizeLocale(names[i4 + 1]);
    next4 = next4 ? next4.split("-") : null;
    while (j2 > 0) {
      locale3 = loadLocale(split.slice(0, j2).join("-"));
      if (locale3) {
        return locale3;
      }
      if (next4 && next4.length >= j2 && commonPrefix(split, next4) >= j2 - 1) {
        break;
      }
      j2--;
    }
    i4++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e5) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key2, values) {
  var data;
  if (key2) {
    if (isUndefined(values)) {
      data = getLocale(key2);
    } else {
      data = defineLocale(key2, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key2 + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config2) {
  if (config2 !== null) {
    var locale3, parentConfig = baseConfig;
    config2.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale3 = loadLocale(config2.parentLocale);
        if (locale3 != null) {
          parentConfig = locale3._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x3) {
        defineLocale(x3.name, x3.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config2) {
  if (config2 != null) {
    var locale3, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config2));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name;
      }
      locale3 = new Locale(config2);
      locale3.parentLocale = locales[name];
      locales[name] = locale3;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key2) {
  var locale3;
  if (key2 && key2._locale && key2._locale._abbr) {
    key2 = key2._locale._abbr;
  }
  if (!key2) {
    return globalLocale;
  }
  if (!isArray4(key2)) {
    locale3 = loadLocale(key2);
    if (locale3) {
      return locale3;
    }
    key2 = [key2];
  }
  return chooseLocale(key2);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m4) {
  var overflow, a5 = m4._a;
  if (a5 && getParsingFlags(m4).overflow === -2) {
    overflow = a5[MONTH] < 0 || a5[MONTH] > 11 ? MONTH : a5[DATE] < 1 || a5[DATE] > daysInMonth(a5[YEAR], a5[MONTH]) ? DATE : a5[HOUR] < 0 || a5[HOUR] > 24 || a5[HOUR] === 24 && (a5[MINUTE] !== 0 || a5[SECOND] !== 0 || a5[MILLISECOND] !== 0) ? HOUR : a5[MINUTE] < 0 || a5[MINUTE] > 59 ? MINUTE : a5[SECOND] < 0 || a5[SECOND] > 59 ? SECOND : a5[MILLISECOND] < 0 || a5[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m4)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m4)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m4)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m4).overflow = overflow;
  }
  return m4;
}
function configFromISO(config2) {
  var i4, l3, string4 = config2._i, match5 = extendedIsoRegex.exec(string4) || basicIsoRegex.exec(string4), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config2).iso = true;
    for (i4 = 0, l3 = isoDatesLen; i4 < l3; i4++) {
      if (isoDates[i4][1].exec(match5[1])) {
        dateFormat = isoDates[i4][0];
        allowTime = isoDates[i4][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i4 = 0, l3 = isoTimesLen; i4 < l3; i4++) {
        if (isoTimes[i4][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i4][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s5) {
  return s5.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m4 = hm % 100, h3 = (hm - m4) / 100;
    return h3 * 60 + m4;
  }
}
function configFromRFC2822(config2) {
  var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(
      match5[4],
      match5[3],
      match5[2],
      match5[5],
      match5[6],
      match5[7]
    );
    if (!checkWeekday(match5[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function defaults(a5, b3, c4) {
  if (a5 != null) {
    return a5;
  }
  if (b3 != null) {
    return b3;
  }
  return c4;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i4, date2, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear3(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date2 = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date2.getUTCMonth();
    config2._a[DATE] = date2.getUTCDate();
  }
  for (i4 = 0; i4 < 3 && config2._a[i4] == null; ++i4) {
    config2._a[i4] = input[i4] = currentDate[i4];
  }
  for (; i4 < 7; i4++) {
    config2._a[i4] = input[i4] = config2._a[i4] == null ? i4 === 2 ? 1 : 0 : config2._a[i4];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w3, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w3 = config2._w;
  if (w3.GG != null || w3.W != null || w3.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w3.GG,
      config2._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w3.W, 1);
    weekday = defaults(w3.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w3.gg, config2._a[YEAR], curWeek.year);
    week = defaults(w3.w, curWeek.week);
    if (w3.d != null) {
      weekday = w3.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w3.e != null) {
      weekday = w3.e + dow;
      if (w3.e < 0 || w3.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string4 = "" + config2._i, i4, parsedInput, tokens2, token3, skipped, stringLength = string4.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i4 = 0; i4 < tokenLen; i4++) {
    token3 = tokens2[i4];
    parsedInput = (string4.match(getParseRegexForToken(token3, config2)) || [])[0];
    if (parsedInput) {
      skipped = string4.substr(0, string4.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string4 = string4.slice(
        string4.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token3]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token3);
      }
      addTimeToArrayFromToken(token3, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token3);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string4.length > 0) {
    getParsingFlags(config2).unusedInput.push(string4);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(
    config2._locale,
    config2._a[HOUR],
    config2._meridiem
  );
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale3, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale3.meridiemHour != null) {
    return locale3.meridiemHour(hour, meridiem2);
  } else if (locale3.isPM != null) {
    isPm = locale3.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i4, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i4 = 0; i4 < configfLen; i4++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i4];
    configFromStringAndFormat(tempConfig);
    if (isValid2(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i4 = normalizeObjectUnits(config2._i), dayOrDate = i4.day === void 0 ? i4.date : i4.day;
  config2._a = map2(
    [i4.year, i4.month, dayOrDate, i4.hour, i4.minute, i4.second, i4.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input = config2._i, format4 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format4 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate2(input)) {
    config2._d = input;
  } else if (isArray4(format4)) {
    configFromStringAndArray(config2);
  } else if (format4) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid2(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate2(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray4(input)) {
    config2._a = map2(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject3(input)) {
    configFromObject(config2);
  } else if (isNumber(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format4, locale3, strict, isUTC) {
  var c4 = {};
  if (format4 === true || format4 === false) {
    strict = format4;
    format4 = void 0;
  }
  if (locale3 === true || locale3 === false) {
    strict = locale3;
    locale3 = void 0;
  }
  if (isObject3(input) && isObjectEmpty(input) || isArray4(input) && input.length === 0) {
    input = void 0;
  }
  c4._isAMomentObject = true;
  c4._useUTC = c4._isUTC = isUTC;
  c4._l = locale3;
  c4._i = input;
  c4._f = format4;
  c4._strict = strict;
  return createFromConfig(c4);
}
function createLocal(input, format4, locale3, strict) {
  return createLocalOrUTC(input, format4, locale3, strict, false);
}
function pickBy(fn, moments) {
  var res, i4;
  if (moments.length === 1 && isArray4(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i4 = 1; i4 < moments.length; ++i4) {
    if (!moments[i4].isValid() || moments[i4][fn](res)) {
      res = moments[i4];
    }
  }
  return res;
}
function min5() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max5() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
function isDurationValid(m4) {
  var key2, unitHasDecimal = false, i4, orderLen = ordering.length;
  for (key2 in m4) {
    if (hasOwnProp(m4, key2) && !(indexOf.call(ordering, key2) !== -1 && (m4[key2] == null || !isNaN(m4[key2])))) {
      return false;
    }
  }
  for (i4 = 0; i4 < orderLen; ++i4) {
    if (m4[ordering[i4]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m4[ordering[i4]]) !== toInt(m4[ordering[i4]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months3 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days3 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds3 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds3 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days3 + weeks2 * 7;
  this._months = +months3 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number2) {
  if (number2 < 0) {
    return Math.round(-1 * number2) * -1;
  } else {
    return Math.round(number2);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i4;
  for (i4 = 0; i4 < len; i4++) {
    if (dontConvert && array1[i4] !== array2[i4] || !dontConvert && toInt(array1[i4]) !== toInt(array2[i4])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset2(token3, separator) {
  addFormatToken(token3, 0, 0, function() {
    var offset3 = this.utcOffset(), sign2 = "+";
    if (offset3 < 0) {
      offset3 = -offset3;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
  });
}
function offsetFromString(matcher, string4) {
  var matches = (string4 || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m4) {
  return -Math.round(m4._d.getTimezoneOffset());
}
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset3 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset3 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset3, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset3 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c4 = {}, other;
  copyConfig(c4, this);
  c4 = prepareConfig(c4);
  if (c4._a) {
    other = c4._isUTC ? createUTC(c4._a) : createLocal(c4._a);
    this._isDSTShifted = this.isValid() && compareArrays(c4._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
function createDuration(input, key2) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key2) {
      duration[key2] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds3 = duration._milliseconds, days3 = absRound(duration._days), months3 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months3) {
    setMonth2(mom, get(mom, "Month") + months3 * isAdding);
  }
  if (days3) {
    set$1(mom, "Date", get(mom, "Date") + days3 * isAdding);
  }
  if (milliseconds3) {
    mom._d.setTime(mom._d.valueOf() + milliseconds3 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days3 || months3);
  }
}
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate2(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject3(input) && !isObjectEmpty(input), propertyTest = false, properties2 = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i4, property, propertyLen = properties2.length;
  for (i4 = 0; i4 < propertyLen; i4 += 1) {
    property = properties2[i4];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray4(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject3(input) && !isObjectEmpty(input), propertyTest = false, properties2 = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i4, property;
  for (i4 = 0; i4 < properties2.length; i4 += 1) {
    property = properties2[i4];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time3, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time3 = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time3 = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time3 = void 0;
    }
  }
  var now2 = time3 || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format4 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction2(formats[format4]) ? formats[format4].call(this, now2) : formats[format4]);
  return this.format(
    output || this.localeData().calendar(format4, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter3(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore2(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from4, to2, units, inclusivity) {
  var localFrom = isMoment(from4) ? from4 : createLocal(from4), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a5, b3) {
  if (a5.date() < b3.date()) {
    return -monthDiff(b3, a5);
  }
  var wholeMonthDiff = (b3.year() - a5.year()) * 12 + (b3.month() - a5.month()), anchor = a5.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b3 - anchor < 0) {
    anchor2 = a5.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b3 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a5.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b3 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m4 = utc ? this.clone().utc() : this;
  if (m4.year() < 0 || m4.year() > 9999) {
    return formatMoment(
      m4,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction2(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m4, "Z"));
    }
  }
  return formatMoment(
    m4,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func2 = "moment", zone = "", prefix2, year, datetime, suffix;
  if (!this.isLocal()) {
    func2 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix2 = "[" + func2 + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix2 + year + datetime + suffix);
}
function format3(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from3(time3, withoutSuffix) {
  if (this.isValid() && (isMoment(time3) && time3.isValid() || createLocal(time3).isValid())) {
    return createDuration({ to: this, from: time3 }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time3, withoutSuffix) {
  if (this.isValid() && (isMoment(time3) && time3.isValid() || createLocal(time3).isValid())) {
    return createDuration({ from: this, to: time3 }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale2(key2) {
  var newLocaleData;
  if (key2 === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key2);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
function localeData() {
  return this._locale;
}
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y4, m4, d3) {
  if (y4 < 100 && y4 >= 0) {
    return new Date(y4 + 400, m4, d3) - MS_PER_400_YEARS;
  } else {
    return new Date(y4, m4, d3).valueOf();
  }
}
function utcStartOfDate(y4, m4, d3) {
  if (y4 < 100 && y4 >= 0) {
    return Date.UTC(y4 + 400, m4, d3) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y4, m4, d3);
  }
}
function startOf(units) {
  var time3, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time3 = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time3 = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time3 = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time3 = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time3 = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time3 = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time3 = this._d.valueOf();
      time3 -= mod$1(
        time3 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time3 = this._d.valueOf();
      time3 -= mod$1(time3, MS_PER_MINUTE);
      break;
    case "second":
      time3 = this._d.valueOf();
      time3 -= mod$1(time3, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time3);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time3, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time3 = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time3 = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time3 = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time3 = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time3 = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time3 = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time3 = this._d.valueOf();
      time3 += MS_PER_HOUR - mod$1(
        time3 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time3 = this._d.valueOf();
      time3 += MS_PER_MINUTE - mod$1(time3, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time3 = this._d.valueOf();
      time3 += MS_PER_SECOND - mod$1(time3, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time3);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate2() {
  return new Date(this.valueOf());
}
function toArray3() {
  var m4 = this;
  return [
    m4.year(),
    m4.month(),
    m4.date(),
    m4.hour(),
    m4.minute(),
    m4.second(),
    m4.millisecond()
  ];
}
function toObject() {
  var m4 = this;
  return {
    years: m4.year(),
    months: m4.month(),
    date: m4.date(),
    hours: m4.hours(),
    minutes: m4.minutes(),
    seconds: m4.seconds(),
    milliseconds: m4.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid2(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
function localeEras(m4, format4) {
  var i4, l3, date2, eras = this._eras || getLocale("en")._eras;
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    switch (typeof eras[i4].since) {
      case "string":
        date2 = hooks(eras[i4].since).startOf("day");
        eras[i4].since = date2.valueOf();
        break;
    }
    switch (typeof eras[i4].until) {
      case "undefined":
        eras[i4].until = Infinity;
        break;
      case "string":
        date2 = hooks(eras[i4].until).startOf("day").valueOf();
        eras[i4].until = date2.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format4, strict) {
  var i4, l3, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    name = eras[i4].name.toUpperCase();
    abbr = eras[i4].abbr.toUpperCase();
    narrow = eras[i4].narrow.toUpperCase();
    if (strict) {
      switch (format4) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i4];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i4];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i4];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i4];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i4, l3, val, eras = this.localeData().eras();
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i4].since <= val && val <= eras[i4].until) {
      return eras[i4].name;
    }
    if (eras[i4].until <= val && val <= eras[i4].since) {
      return eras[i4].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i4, l3, val, eras = this.localeData().eras();
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i4].since <= val && val <= eras[i4].until) {
      return eras[i4].narrow;
    }
    if (eras[i4].until <= val && val <= eras[i4].since) {
      return eras[i4].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i4, l3, val, eras = this.localeData().eras();
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i4].since <= val && val <= eras[i4].until) {
      return eras[i4].abbr;
    }
    if (eras[i4].until <= val && val <= eras[i4].since) {
      return eras[i4].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i4, l3, dir, val, eras = this.localeData().eras();
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    dir = eras[i4].since <= eras[i4].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i4].since <= val && val <= eras[i4].until || eras[i4].until <= val && val <= eras[i4].since) {
      return (this.year() - hooks(eras[i4].since).year()) * dir + eras[i4].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale3) {
  return locale3.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale3) {
  return locale3.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale3) {
  return locale3.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale3) {
  return locale3._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i4, l3, eras = this.eras();
  for (i4 = 0, l3 = eras.length; i4 < l3; ++i4) {
    namePieces.push(regexEscape(eras[i4].name));
    abbrPieces.push(regexEscape(eras[i4].abbr));
    narrowPieces.push(regexEscape(eras[i4].narrow));
    mixedPieces.push(regexEscape(eras[i4].name));
    mixedPieces.push(regexEscape(eras[i4].abbr));
    mixedPieces.push(regexEscape(eras[i4].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
function addWeekYearFormatToken(token3, getter) {
  addFormatToken(0, [token3, token3.length], 0, getter);
}
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear2() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date2.getUTCFullYear());
  this.month(date2.getUTCMonth());
  this.date(date2.getUTCDate());
  return this;
}
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string4) {
  return string4;
}
function get$1(format4, index3, field, setter) {
  var locale3 = getLocale(), utc = createUTC().set(setter, index3);
  return locale3[field](utc, format4);
}
function listMonthsImpl(format4, index3, field) {
  if (isNumber(format4)) {
    index3 = format4;
    format4 = void 0;
  }
  format4 = format4 || "";
  if (index3 != null) {
    return get$1(format4, index3, field, "month");
  }
  var i4, out = [];
  for (i4 = 0; i4 < 12; i4++) {
    out[i4] = get$1(format4, i4, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format4, index3, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format4)) {
      index3 = format4;
      format4 = void 0;
    }
    format4 = format4 || "";
  } else {
    format4 = localeSorted;
    index3 = format4;
    localeSorted = false;
    if (isNumber(format4)) {
      index3 = format4;
      format4 = void 0;
    }
    format4 = format4 || "";
  }
  var locale3 = getLocale(), shift2 = localeSorted ? locale3._week.dow : 0, i4, out = [];
  if (index3 != null) {
    return get$1(format4, (index3 + shift2) % 7, field, "day");
  }
  for (i4 = 0; i4 < 7; i4++) {
    out[i4] = get$1(format4, (i4 + shift2) % 7, field, "day");
  }
  return out;
}
function listMonths(format4, index3) {
  return listMonthsImpl(format4, index3, "months");
}
function listMonthsShort(format4, index3) {
  return listMonthsImpl(format4, index3, "monthsShort");
}
function listWeekdays(localeSorted, format4, index3) {
  return listWeekdaysImpl(localeSorted, format4, index3, "weekdays");
}
function listWeekdaysShort(localeSorted, format4, index3) {
  return listWeekdaysImpl(localeSorted, format4, index3, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format4, index3) {
  return listWeekdaysImpl(localeSorted, format4, index3, "weekdaysMin");
}
function abs2() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number2) {
  if (number2 < 0) {
    return Math.floor(number2);
  } else {
    return Math.ceil(number2);
  }
}
function bubble() {
  var milliseconds3 = this._milliseconds, days3 = this._days, months3 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds3 >= 0 && days3 >= 0 && months3 >= 0 || milliseconds3 <= 0 && days3 <= 0 && months3 <= 0)) {
    milliseconds3 += absCeil(monthsToDays(months3) + days3) * 864e5;
    days3 = 0;
    months3 = 0;
  }
  data.milliseconds = milliseconds3 % 1e3;
  seconds2 = absFloor(milliseconds3 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days3 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days3));
  months3 += monthsFromDays;
  days3 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months3 / 12);
  months3 %= 12;
  data.days = days3;
  data.months = months3;
  data.years = years2;
  return this;
}
function daysToMonths(days3) {
  return days3 * 4800 / 146097;
}
function monthsToDays(months3) {
  return months3 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days3, months3, milliseconds3 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days3 = this._days + milliseconds3 / 864e5;
    months3 = this._months + daysToMonths(days3);
    switch (units) {
      case "month":
        return months3;
      case "quarter":
        return months3 / 3;
      case "year":
        return months3 / 12;
    }
  } else {
    days3 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days3 / 7 + milliseconds3 / 6048e5;
      case "day":
        return days3 + milliseconds3 / 864e5;
      case "hour":
        return days3 * 24 + milliseconds3 / 36e5;
      case "minute":
        return days3 * 1440 + milliseconds3 / 6e4;
      case "second":
        return days3 * 86400 + milliseconds3 / 1e3;
      case "millisecond":
        return Math.floor(days3 * 864e5) + milliseconds3;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
function weeks() {
  return absFloor(this.days() / 7);
}
function substituteTimeAgo(string4, number2, withoutSuffix, isFuture2, locale3) {
  return locale3.relativeTime(number2 || 1, !!withoutSuffix, string4, isFuture2);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale3) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days3 = round2(duration.as("d")), months3 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a5 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days3 <= 1 && ["d"] || days3 < thresholds2.d && ["dd", days3];
  if (thresholds2.w != null) {
    a5 = a5 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a5 = a5 || months3 <= 1 && ["M"] || months3 < thresholds2.M && ["MM", months3] || years2 <= 1 && ["y"] || ["yy", years2];
  a5[2] = withoutSuffix;
  a5[3] = +posNegDuration > 0;
  a5[4] = locale3;
  return substituteTimeAgo.apply(null, a5);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round2;
  }
  if (typeof roundingFunction === "function") {
    round2 = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale3, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale3 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale3);
  if (withSuffix) {
    output = locale3.pastFuture(+this, output);
  }
  return locale3.postformat(output);
}
function sign(x3) {
  return (x3 > 0) - (x3 < 0) || +x3;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days3 = abs$1(this._days), months3 = abs$1(this._months), minutes2, hours2, years2, s5, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months3 / 12);
  months3 %= 12;
  s5 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months3 ? ymSign + months3 + "M" : "") + (days3 ? daysSign + days3 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s5 + "S" : "");
}
var hookCallback, some, momentProperties, updateInProgress, deprecations, keys, defaultCalendar, formattingTokens, localFormattingTokens, formatFunctions, formatTokenFunctions, defaultLongDateFormat, defaultInvalidDate, defaultOrdinal, defaultDayOfMonthOrdinalParse, defaultRelativeTime, aliases, priorities, match1, match22, match3, match4, match6, match1to2, match3to4, match5to6, match1to3, match1to4, match1to6, matchUnsigned, matchSigned, matchOffset, matchShortOffset, matchTimestamp, matchWord, regexes, tokens, YEAR, MONTH, DATE, HOUR, MINUTE, SECOND, MILLISECOND, WEEK, WEEKDAY, indexOf, defaultLocaleMonths, defaultLocaleMonthsShort, MONTHS_IN_FORMAT, defaultMonthsShortRegex, defaultMonthsRegex, getSetYear, defaultLocaleWeek, defaultLocaleWeekdays, defaultLocaleWeekdaysShort, defaultLocaleWeekdaysMin, defaultWeekdaysRegex, defaultWeekdaysShortRegex, defaultWeekdaysMinRegex, defaultLocaleMeridiemParse, getSetHour, baseConfig, locales, localeFamilies, globalLocale, extendedIsoRegex, basicIsoRegex, tzRegex, isoDates, isoTimes, aspNetJsonRegex, rfc2822, obsOffsets, prototypeMin, prototypeMax, now, ordering, chunkOffset, aspNetRegex, isoRegex, add3, subtract2, lang, MS_PER_SECOND, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_400_YEARS, getSetDayOfMonth, getSetMinute, getSetSecond, token2, getSetMillisecond, proto, proto$1, mathAbs, asMilliseconds, asSeconds, asMinutes, asHours, asDays, asWeeks, asMonths, asQuarters, asYears, milliseconds2, seconds, minutes, hours, days2, months2, years, round2, thresholds, abs$1, proto$2, moment_default;
var init_moment = __esm({
  "node_modules/moment/dist/moment.js"() {
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t4 = Object(this), len = t4.length >>> 0, i4;
        for (i4 = 0; i4 < len; i4++) {
          if (i4 in t4 && fun.call(this, t4[i4], i4, t4)) {
            return true;
          }
        }
        return false;
      };
    }
    momentProperties = hooks.momentProperties = [];
    updateInProgress = false;
    deprecations = {};
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i4, res = [];
        for (i4 in obj) {
          if (hasOwnProp(obj, i4)) {
            res.push(i4);
          }
        }
        return res;
      };
    }
    defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    formatFunctions = {};
    formatTokenFunctions = {};
    defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    defaultInvalidDate = "Invalid date";
    defaultOrdinal = "%d";
    defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    aliases = {};
    priorities = {};
    match1 = /\d/;
    match22 = /\d\d/;
    match3 = /\d{3}/;
    match4 = /\d{4}/;
    match6 = /[+-]?\d{6}/;
    match1to2 = /\d\d?/;
    match3to4 = /\d\d\d\d?/;
    match5to6 = /\d\d\d\d\d\d?/;
    match1to3 = /\d{1,3}/;
    match1to4 = /\d{1,4}/;
    match1to6 = /[+-]?\d{1,6}/;
    matchUnsigned = /\d+/;
    matchSigned = /[+-]?\d+/;
    matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    regexes = {};
    tokens = {};
    YEAR = 0;
    MONTH = 1;
    DATE = 2;
    HOUR = 3;
    MINUTE = 4;
    SECOND = 5;
    MILLISECOND = 6;
    WEEK = 7;
    WEEKDAY = 8;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o4) {
        var i4;
        for (i4 = 0; i4 < this.length; ++i4) {
          if (this[i4] === o4) {
            return i4;
          }
        }
        return -1;
      };
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format4) {
      return this.localeData().monthsShort(this, format4);
    });
    addFormatToken("MMMM", 0, 0, function(format4) {
      return this.localeData().months(this, format4);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match22);
    addRegexToken("MMM", function(isStrict, locale3) {
      return locale3.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale3) {
      return locale3.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config2, token3) {
      var month = config2._locale.monthsParse(input, token3, config2._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config2).invalidMonth = input;
      }
    });
    defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    );
    defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    defaultMonthsShortRegex = matchWord;
    defaultMonthsRegex = matchWord;
    addFormatToken("Y", 0, 0, function() {
      var y4 = this.year();
      return y4 <= 9999 ? zeroFill(y4, 4) : "+" + y4;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match22);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    getSetYear = makeGetSet("FullYear", true);
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match22);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match22);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config2, token3) {
        week[token3.substr(0, 1)] = toInt(input);
      }
    );
    defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format4) {
      return this.localeData().weekdaysMin(this, format4);
    });
    addFormatToken("ddd", 0, 0, function(format4) {
      return this.localeData().weekdaysShort(this, format4);
    });
    addFormatToken("dddd", 0, 0, function(format4) {
      return this.localeData().weekdays(this, format4);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale3) {
      return locale3.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale3) {
      return locale3.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale3) {
      return locale3.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token3) {
      var weekday = config2._locale.weekdaysParse(input, token3, config2._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config2).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config2, token3) {
      week[token3] = toInt(input);
    });
    defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    defaultWeekdaysRegex = matchWord;
    defaultWeekdaysShortRegex = matchWord;
    defaultWeekdaysMinRegex = matchWord;
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match22);
    addRegexToken("hh", match1to2, match22);
    addRegexToken("kk", match1to2, match22);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config2) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config2) {
      config2._isPm = config2._locale.isPM(input);
      config2._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config2) {
      array[HOUR] = toInt(input);
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config2) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config2) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    getSetHour = makeGetSet("Hours", true);
    baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    locales = {};
    localeFamilies = {};
    extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ];
    isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ];
    aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config2) {
        config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
      }
    );
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    offset2("Z", ":");
    offset2("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config2) {
      config2._useUTC = true;
      config2._tzm = offsetFromString(matchShortOffset, input);
    });
    chunkOffset = /([\+\-]|\d\d)/gi;
    hooks.updateOffset = function() {
    };
    aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
    isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    add3 = createAdder(1, "add");
    subtract2 = createAdder(-1, "subtract");
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key2) {
        if (key2 === void 0) {
          return this.localeData();
        } else {
          return this.locale(key2);
        }
      }
    );
    MS_PER_SECOND = 1e3;
    MS_PER_MINUTE = 60 * MS_PER_SECOND;
    MS_PER_HOUR = 60 * MS_PER_MINUTE;
    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config2, token3) {
        var era = config2._locale.erasParse(input, token3, config2._strict);
        if (era) {
          getParsingFlags(config2).era = era;
        } else {
          getParsingFlags(config2).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config2, token3) {
      var match5;
      if (config2._locale._eraYearOrdinalRegex) {
        match5 = input.match(config2._locale._eraYearOrdinalRegex);
      }
      if (config2._locale.eraYearOrdinalParse) {
        array[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match22);
    addRegexToken("gg", match1to2, match22);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config2, token3) {
        week[token3.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config2, token3) {
      week[token3] = hooks.parseTwoDigitYear(input);
    });
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match22);
    addRegexToken("Do", function(isStrict, locale3) {
      return isStrict ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse : locale3._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config2) {
      config2._dayOfYear = toInt(input);
    });
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match22);
    addParseToken(["m", "mm"], MINUTE);
    getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match22);
    addParseToken(["s", "ss"], SECOND);
    getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match22);
    addRegexToken("SSS", match1to3, match3);
    for (token2 = "SSSS"; token2.length <= 9; token2 += "S") {
      addRegexToken(token2, matchUnsigned);
    }
    for (token2 = "S"; token2.length <= 9; token2 += "S") {
      addParseToken(token2, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    proto = Moment.prototype;
    proto.add = add3;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format3;
    proto.from = from3;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter3;
    proto.isBefore = isBefore2;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale2;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract2;
    proto.toArray = toArray3;
    proto.toObject = toObject;
    proto.toDate = toDate2;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth2;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear2;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set3;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number2) {
        var b3 = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b3 === 1 ? "st" : b3 === 2 ? "nd" : b3 === 3 ? "rd" : "th";
        return number2 + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    mathAbs = Math.abs;
    asMilliseconds = makeAs("ms");
    asSeconds = makeAs("s");
    asMinutes = makeAs("m");
    asHours = makeAs("h");
    asDays = makeAs("d");
    asWeeks = makeAs("w");
    asMonths = makeAs("M");
    asQuarters = makeAs("Q");
    asYears = makeAs("y");
    milliseconds2 = makeGetter("milliseconds");
    seconds = makeGetter("seconds");
    minutes = makeGetter("minutes");
    hours = makeGetter("hours");
    days2 = makeGetter("days");
    months2 = makeGetter("months");
    years = makeGetter("years");
    round2 = Math.round;
    thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    abs$1 = Math.abs;
    proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs2;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds2;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days2;
    proto$2.weeks = weeks;
    proto$2.months = months2;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale2;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config2) {
      config2._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config2) {
      config2._d = new Date(toInt(input));
    });
    hooks.version = "2.29.4";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min5;
    hooks.max = max5;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate2;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    moment_default = hooks;
  }
});

// node_modules/lodash/_baseExtremum.js
var require_baseExtremum = __commonJS({
  "node_modules/lodash/_baseExtremum.js"(exports, module2) {
    var isSymbol = require_isSymbol();
    function baseExtremum(array, iteratee, comparator) {
      var index3 = -1, length2 = array.length;
      while (++index3 < length2) {
        var value = array[index3], current2 = iteratee(value);
        if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
          var computed = current2, result = value;
        }
      }
      return result;
    }
    module2.exports = baseExtremum;
  }
});

// node_modules/lodash/_baseLt.js
var require_baseLt = __commonJS({
  "node_modules/lodash/_baseLt.js"(exports, module2) {
    function baseLt(value, other) {
      return value < other;
    }
    module2.exports = baseLt;
  }
});

// node_modules/lodash/min.js
var require_min = __commonJS({
  "node_modules/lodash/min.js"(exports, module2) {
    var baseExtremum = require_baseExtremum();
    var baseLt = require_baseLt();
    var identity2 = require_identity();
    function min6(array) {
      return array && array.length ? baseExtremum(array, identity2, baseLt) : void 0;
    }
    module2.exports = min6;
  }
});

// node_modules/lodash/_baseGt.js
var require_baseGt = __commonJS({
  "node_modules/lodash/_baseGt.js"(exports, module2) {
    function baseGt(value, other) {
      return value > other;
    }
    module2.exports = baseGt;
  }
});

// node_modules/lodash/max.js
var require_max = __commonJS({
  "node_modules/lodash/max.js"(exports, module2) {
    var baseExtremum = require_baseExtremum();
    var baseGt = require_baseGt();
    var identity2 = require_identity();
    function max6(array) {
      return array && array.length ? baseExtremum(array, identity2, baseGt) : void 0;
    }
    module2.exports = max6;
  }
});

// node_modules/@sanity/mutator/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/@sanity/mutator/node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env2).forEach(function(key2) {
        createDebug[key2] = env2[key2];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        var hash2 = 0;
        for (var i4 = 0; i4 < namespace.length; i4++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i4);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        var prevTime;
        function debug3() {
          if (!debug3.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug3;
          var curr = Number(/* @__PURE__ */ new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index3 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match5, format4) {
            if (match5 === "%%") {
              return match5;
            }
            index3++;
            var formatter = createDebug.formatters[format4];
            if (typeof formatter === "function") {
              var val = args[index3];
              match5 = formatter.call(self2, val);
              args.splice(index3, 1);
              index3--;
            }
            return match5;
          });
          createDebug.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.enabled = createDebug.enabled(namespace);
        debug3.useColors = createDebug.useColors();
        debug3.color = selectColor(namespace);
        debug3.destroy = destroy;
        debug3.extend = extend2;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        createDebug.instances.push(debug3);
        return debug3;
      }
      function destroy() {
        var index3 = createDebug.instances.indexOf(this);
        if (index3 !== -1) {
          createDebug.instances.splice(index3, 1);
          return true;
        }
        return false;
      }
      function extend2(namespace, delimiter2) {
        return createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i4;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i4 = 0; i4 < createDebug.instances.length; i4++) {
          var instance = createDebug.instances[i4];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i4;
        var len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/@sanity/mutator/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/@sanity/mutator/node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    function _typeof4(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof4 = function _typeof5(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof4 = function _typeof5(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof4(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      var index3 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match5) {
        if (match5 === "%%") {
          return;
        }
        index3++;
        if (match5 === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c4);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof4(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r4;
      try {
        r4 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r4 && typeof process !== "undefined" && "env" in process) {
        r4 = process.env.DEBUG;
      }
      return r4;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports);
    var formatters3 = module2.exports.formatters;
    formatters3.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize2(fn) {
  var cache3 = {};
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var memoize_browser_esm_default;
var init_memoize_browser_esm = __esm({
  "node_modules/@emotion/memoize/dist/memoize.browser.esm.js"() {
    memoize_browser_esm_default = memoize2;
  }
});

// node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var is_prop_valid_browser_esm_exports = {};
__export(is_prop_valid_browser_esm_exports, {
  default: () => is_prop_valid_browser_esm_default
});
var reactPropsRegex2, index2, is_prop_valid_browser_esm_default;
var init_is_prop_valid_browser_esm = __esm({
  "node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js"() {
    init_memoize_browser_esm();
    reactPropsRegex2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    index2 = memoize_browser_esm_default(
      function(prop) {
        return reactPropsRegex2.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    is_prop_valid_browser_esm_default = index2;
  }
});

// node_modules/parse-headers/parse-headers.js
var require_parse_headers = __commonJS({
  "node_modules/parse-headers/parse-headers.js"(exports, module2) {
    var trim2 = function(string4) {
      return string4.replace(/^\s+|\s+$/g, "");
    };
    var isArray5 = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
    module2.exports = function(headers) {
      if (!headers)
        return {};
      var result = {};
      var headersArr = trim2(headers).split("\n");
      for (var i4 = 0; i4 < headersArr.length; i4++) {
        var row = headersArr[i4];
        var index3 = row.indexOf(":"), key2 = trim2(row.slice(0, index3)).toLowerCase(), value = trim2(row.slice(index3 + 1));
        if (typeof result[key2] === "undefined") {
          result[key2] = value;
        } else if (isArray5(result[key2])) {
          result[key2].push(value);
        } else {
          result[key2] = [result[key2], value];
        }
      }
      return result;
    };
  }
});

// node_modules/debug/src/common.js
var require_common4 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug[key2] = env2[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i4);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index3 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match5, format4) => {
            if (match5 === "%%") {
              return "%";
            }
            index3++;
            const formatter = createDebug.formatters[format4];
            if (typeof formatter === "function") {
              const val = args[index3];
              match5 = formatter.call(self2, val);
              args.splice(index3, 1);
              index3--;
            }
            return match5;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend2;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      function extend2(namespace, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i4;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i4;
        let len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser4 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      let index3 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match5) => {
        if (match5 === "%%") {
          return;
        }
        index3++;
        if (match5 === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c4);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r4;
      try {
        r4 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r4 && typeof process !== "undefined" && "env" in process) {
        r4 = process.env.DEBUG;
      }
      return r4;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common4()(exports);
    var { formatters: formatters3 } = module2.exports;
    formatters3.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

export {
  require_react_fast_compare,
  require_isObject,
  require_baseGetTag,
  require_isObjectLike,
  require_debounce,
  createPubSub,
  esm_exports,
  init_esm,
  require_react_is,
  Je,
  Xe,
  nt,
  st,
  at,
  ct,
  styled_components_browser_esm_exports,
  init_styled_components_browser_esm,
  require_object_assign,
  require_prop_types,
  require_javascript,
  require_Refractor,
  detectOverflow,
  flip,
  hide,
  offset,
  shift,
  autoUpdate,
  require_react_dom,
  arrow2 as arrow,
  useFloating,
  floating_ui_react_dom_esm_exports,
  init_floating_ui_react_dom_esm,
  is_prop_valid_browser_esm_exports,
  init_is_prop_valid_browser_esm,
  Observable,
  refCount,
  Subject,
  BehaviorSubject,
  ReplaySubject,
  asyncScheduler,
  EMPTY,
  empty,
  from2 as from,
  of,
  throwError,
  isObservable,
  lastValueFrom,
  firstValueFrom,
  map,
  combineLatest,
  mergeMap,
  mergeAll,
  concat,
  defer,
  forkJoin,
  fromEvent,
  iif,
  timer,
  merge,
  NEVER,
  filter2 as filter,
  partition,
  auditTime,
  catchError,
  reduce,
  toArray,
  concatMap,
  debounce,
  debounceTime,
  take,
  mapTo,
  delay,
  distinct,
  distinctUntilChanged,
  first,
  groupBy,
  last2 as last,
  flatMap,
  mergeMapTo,
  pairwise,
  publishReplay,
  scan,
  share,
  shareReplay,
  skip,
  startWith,
  switchMap,
  switchMapTo,
  takeUntil,
  tap,
  throttleTime,
  withLatestFrom,
  init_esm5,
  init_operators,
  useAsObservable,
  useMemoObservable,
  observableCallback,
  observableCallback_exports,
  init_observableCallback,
  useObservableCallback,
  esm_exports2,
  init_esm2,
  require_isEqual,
  ResizeObserver2 as ResizeObserver,
  resize_observer_exports,
  init_resize_observer,
  require_throttle,
  _extends,
  init_extends,
  initReactI18next,
  useTranslation,
  I18nextProvider,
  es_exports,
  init_es,
  require_memoize,
  require_get,
  require_identity,
  require_sortBy,
  require_shallow_equals,
  require_deburr,
  require_words,
  require_createCompounder,
  require_upperFirst,
  require_startCase,
  require_browser,
  require_difference,
  require_intersection,
  require_isPlainObject,
  require_flatten,
  require_pick,
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose,
  es2015_default,
  es2015_exports,
  init_es20154 as init_es2015,
  require_classnames,
  getDevicePixelRatio,
  index_module_exports,
  init_index_module,
  require_bash,
  require_json,
  require_jsx,
  require_typescript,
  require_isString,
  require_parse_headers,
  require_browser4 as require_browser2,
  isPlainObject,
  init_is_plain_object,
  nanoid,
  index_browser_exports,
  init_index_browser,
  fromUrl,
  esm_exports3,
  init_esm3,
  require_omit,
  require_arrify,
  require_castArray,
  require_flatMap,
  require_negate,
  require_omitBy,
  require_isUndefined,
  require_capitalize,
  require_toPath,
  require_noop,
  require_uniqBy,
  require_uniq,
  require_object_inspect,
  require_partition,
  require_humanize_list,
  require_leven,
  require_cloneDeep,
  isValid,
  isValid_exports,
  init_isValid,
  format,
  format_exports,
  init_format,
  createBrowserHistory,
  createMemoryHistory,
  history_exports,
  init_history,
  require_with_selector,
  require_escapeRegExp,
  addDays,
  addMonths,
  startOfDay,
  isSameDay,
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  endOfDay,
  differenceInMonths,
  differenceInSeconds,
  differenceInWeeks,
  differenceInYears,
  startOfMinute,
  eachWeekOfInterval,
  startOfMonth,
  endOfMinute,
  getMinutes,
  getWeek,
  lastDayOfMonth,
  isAfter,
  isBefore,
  parse2 as parse,
  isSameMonth,
  parseISO,
  setMonth,
  set,
  setDate,
  setHours,
  setMinutes,
  setYear,
  startOfToday,
  sub,
  esm_exports4,
  init_esm4,
  require_image_url_umd,
  isDefaultCrop,
  isDefaultHotspot,
  getImageDimensions,
  isFileSource,
  isImageSource,
  asset_utils_esm_exports,
  init_asset_utils_esm,
  require_uniqueId,
  require_compact,
  require_keyBy,
  require_toLower,
  require_union,
  require_flow,
  require_trim,
  v4_default,
  uuid_exports,
  init_uuid,
  getRandomValues2 as getRandomValues,
  get_random_values_esm_exports,
  init_get_random_values_esm,
  require_browser2 as require_browser3,
  e4 as e,
  init_dist2 as init_dist,
  Path,
  Range,
  Element2 as Element,
  Node2 as Node,
  Operation,
  Editor,
  Text,
  Transforms,
  createEditor,
  index_es_exports,
  init_index_es2 as init_index_es,
  useSlateStatic,
  ReactEditor,
  useSelected,
  useSlate,
  Editable,
  Slate,
  withReact,
  index_es_exports2,
  init_index_es3 as init_index_es2,
  require_findIndex,
  require_clone,
  require_lib,
  require_orderBy,
  moment_default,
  moment_exports,
  init_moment,
  require_xor,
  require_groupBy,
  CSS2 as CSS,
  utilities_esm_exports,
  init_utilities_esm,
  useSensor,
  useSensors,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  DndContext,
  core_esm_exports,
  init_core_esm,
  horizontalListSortingStrategy,
  verticalListSortingStrategy,
  SortableContext,
  useSortable,
  sortableKeyboardCoordinates,
  sortable_esm_exports,
  init_sortable_esm,
  restrictToHorizontalAxis,
  restrictToVerticalAxis,
  modifiers_esm_exports,
  init_modifiers_esm,
  require_exif_component,
  require_find2 as require_find,
  require_range,
  require_speakingurl2 as require_speakingurl,
  require_min,
  require_max,
  require_browser3 as require_browser4,
  require_assignWith,
  require_values,
  require_reduce,
  exhaustMapWithTrailing,
  esm_exports5,
  init_esm6,
  refCountDelay,
  operators_exports,
  init_operators3 as init_operators2,
  parseToRgb,
  rgb,
  getLuminance,
  mix$1,
  polished_esm_exports,
  init_polished_esm,
  require_dataloader,
  require_raf,
  require_sample,
  require_client,
  require_isEmpty,
  require_server_browser
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

prismjs/components/prism-core.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

react-dom/cjs/react-dom-server-legacy.browser.development.js:
  (**
   * @license React
   * react-dom-server-legacy.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.browser.development.js:
  (**
   * @license React
   * react-dom-server.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=chunk-ZC45C7QK.js.map
