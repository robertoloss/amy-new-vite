import {
  BehaviorSubject,
  CSS,
  DndContext,
  EMPTY,
  Editable,
  Editor,
  Element as Element2,
  I18nextProvider,
  Je,
  KeyboardSensor,
  NEVER,
  Node as Node2,
  Observable,
  Operation,
  Path,
  PointerSensor,
  Range,
  ReactEditor,
  ResizeObserver as ResizeObserver2,
  Slate,
  SortableContext,
  Subject,
  Text as Text2,
  Transforms,
  Xe,
  addDays,
  addMonths,
  arrow,
  asyncScheduler,
  at,
  auditTime,
  autoUpdate,
  catchError,
  closestCenter,
  combineLatest,
  concat,
  concatMap,
  createBrowserHistory,
  createEditor,
  createMemoryHistory,
  createPubSub,
  ct,
  debounce,
  debounceTime,
  defer,
  delay,
  detectOverflow,
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  differenceInMonths,
  differenceInSeconds,
  differenceInWeeks,
  differenceInYears,
  distinct,
  distinctUntilChanged,
  e,
  eachWeekOfInterval,
  empty,
  endOfDay,
  endOfMinute,
  es2015_default,
  exhaustMapWithTrailing,
  filter,
  first,
  firstValueFrom,
  flatMap,
  flip,
  format,
  from,
  fromEvent,
  fromUrl,
  getDevicePixelRatio,
  getImageDimensions,
  getLuminance,
  getMinutes,
  getRandomValues,
  getWeek,
  groupBy,
  hide,
  horizontalListSortingStrategy,
  iif,
  initReactI18next,
  init_asset_utils_esm,
  init_core_esm,
  init_dist,
  init_es,
  init_es2015,
  init_esm,
  init_esm2,
  init_esm3,
  init_esm4,
  init_esm5,
  init_esm6,
  init_floating_ui_react_dom_esm,
  init_format,
  init_get_random_values_esm,
  init_history,
  init_index_browser,
  init_index_es,
  init_index_es2,
  init_index_module,
  init_isValid,
  init_is_plain_object,
  init_is_prop_valid_browser_esm,
  init_modifiers_esm,
  init_moment,
  init_observableCallback,
  init_operators,
  init_operators2,
  init_polished_esm,
  init_resize_observer,
  init_sortable_esm,
  init_styled_components_browser_esm,
  init_utilities_esm,
  init_uuid,
  isAfter,
  isBefore,
  isDefaultCrop,
  isDefaultHotspot,
  isFileSource,
  isImageSource,
  isObservable,
  isPlainObject,
  isSameDay,
  isSameMonth,
  isValid,
  is_prop_valid_browser_esm_exports,
  last,
  lastDayOfMonth,
  lastValueFrom,
  map,
  mapTo,
  merge,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mix$1,
  moment_default,
  nanoid,
  nt,
  observableCallback,
  of,
  offset,
  parse,
  parseISO,
  parseToRgb,
  partition,
  publishReplay,
  reduce,
  refCount,
  refCountDelay,
  require_Refractor,
  require_arrify,
  require_assignWith,
  require_bash,
  require_browser,
  require_browser2,
  require_browser3,
  require_browser4,
  require_capitalize,
  require_castArray,
  require_classnames,
  require_client,
  require_clone,
  require_cloneDeep,
  require_compact,
  require_dataloader,
  require_debounce,
  require_difference,
  require_escapeRegExp,
  require_exif_component,
  require_find,
  require_findIndex,
  require_flatMap,
  require_flatten,
  require_flow,
  require_get,
  require_groupBy,
  require_humanize_list,
  require_identity,
  require_image_url_umd,
  require_intersection,
  require_isEmpty,
  require_isEqual,
  require_isObject,
  require_isPlainObject,
  require_isString,
  require_isUndefined,
  require_javascript,
  require_json,
  require_jsx,
  require_keyBy,
  require_leven,
  require_lib,
  require_max,
  require_memoize,
  require_min,
  require_noop,
  require_object_inspect,
  require_omit,
  require_omitBy,
  require_orderBy,
  require_parse_headers,
  require_partition,
  require_pick,
  require_raf,
  require_range,
  require_react_dom,
  require_react_fast_compare,
  require_react_is,
  require_reduce,
  require_sample,
  require_server_browser,
  require_shallow_equals,
  require_sortBy,
  require_speakingurl,
  require_startCase,
  require_throttle,
  require_toLower,
  require_toPath,
  require_trim,
  require_typescript,
  require_union,
  require_uniq,
  require_uniqBy,
  require_uniqueId,
  require_upperFirst,
  require_values,
  require_with_selector,
  require_words,
  require_xor,
  restrictToHorizontalAxis,
  restrictToVerticalAxis,
  rgb,
  scan,
  set,
  setDate,
  setHours,
  setMinutes,
  setMonth,
  setYear,
  share,
  shareReplay,
  shift,
  skip,
  sortableKeyboardCoordinates,
  st,
  startOfDay,
  startOfMinute,
  startOfMonth,
  startOfToday,
  startWith,
  sub,
  switchMap,
  switchMapTo,
  take,
  takeUntil,
  tap,
  throttleTime,
  throwError,
  timer,
  toArray,
  useFloating,
  useMemoObservable,
  useObservableCallback,
  useSelected,
  useSensor,
  useSensors,
  useSlate,
  useSlateStatic,
  useSortable,
  useTranslation,
  v4_default,
  verticalListSortingStrategy,
  withLatestFrom,
  withReact
} from "./chunk-ZC45C7QK.js";
import {
  require_jsx_runtime
} from "./chunk-W7O3NKM5.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@sanity/types/lib/index.esm.js
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function isReference(reference2) {
  return isObject(reference2) && typeof reference2._ref === "string";
}
function isImage(value) {
  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith("image-");
}
function isCrossDatasetReference(reference2) {
  return isObject(reference2) && typeof reference2._ref === "string" && typeof reference2._dataset === "string" && typeof reference2._projectId === "string";
}
function isSanityDocument(document2) {
  return isObject(document2) && typeof document2._id === "string" && typeof document2._type === "string";
}
function isTypedObject(obj) {
  return isObject(obj) && typeof obj._type === "string";
}
function isKeyedObject(obj) {
  return isObject(obj) && typeof obj._key === "string";
}
function isValidationErrorMarker(marker) {
  return marker.level === "error";
}
function isValidationWarningMarker(marker) {
  return marker.level === "warning";
}
function isValidationInfoMarker(marker) {
  return marker.level === "info";
}
function isCreateMutation(mutation) {
  return "create" in mutation;
}
function isCreateIfNotExistsMutation(mutation) {
  return "createIfNotExists" in mutation;
}
function isCreateOrReplaceMutation(mutation) {
  return "createOrReplace" in mutation;
}
function isDeleteMutation(mutation) {
  return "delete" in mutation;
}
function isPatchMutation(mutation) {
  return "patch" in mutation;
}
var reKeySegment = /_key\s*==\s*['"](.*)['"]/;
var reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
  return typeof segment === "number" || typeof segment === "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
  if (typeof segment === "string") {
    return reKeySegment.test(segment.trim());
  }
  return typeof segment === "object" && "_key" in segment;
}
function isIndexTuple(segment) {
  if (typeof segment === "string" && reIndexTuple.test(segment)) {
    return true;
  }
  if (!Array.isArray(segment) || segment.length !== 2) {
    return false;
  }
  const [from2, to] = segment;
  return (typeof from2 === "number" || from2 === "") && (typeof to === "number" || to === "");
}
function isRecord$1(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isPortableTextTextBlock(value) {
  return isRecord$1(value) && typeof value._type === "string" && // block types can be named, so expect anything here.
  Array.isArray(value.children) && value.children.every((child) => isRecord$1(child)) && ("markDefs" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$1(def)) : false) && ("style" in value ? typeof value.style === "string" : true);
}
function isPortableTextSpan(value) {
  return isRecord$1(value) && value._type === "span" && typeof value.text === "string" && ("marks" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark === "string") : true);
}
function isPortableTextListBlock(value) {
  return isPortableTextTextBlock(value) && "listItem" in value && typeof value.listItem === "string" && "level" in value && Number.isInteger(value.level);
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isDocumentSchemaType(type) {
  if (!isObjectSchemaType(type)) {
    return false;
  }
  let current = type;
  while (current) {
    if (current.name === "document") {
      return true;
    }
    current = current.type;
  }
  return false;
}
function isObjectSchemaType(type) {
  if (!isRecord(type))
    return false;
  return type.jsonType === "object";
}
function isArraySchemaType(type) {
  if (!isRecord(type))
    return false;
  return type.jsonType === "array";
}
function isArrayOfBlocksSchemaType(type) {
  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType));
}
function isArrayOfObjectsSchemaType(type) {
  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));
}
function isArrayOfPrimitivesSchemaType(type) {
  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));
}
function isBooleanSchemaType(type) {
  if (!isRecord(type))
    return false;
  return type.jsonType === "boolean";
}
function isStringSchemaType(type) {
  if (!isRecord(type))
    return false;
  return type.jsonType === "string";
}
function isNumberSchemaType(type) {
  if (!isRecord(type))
    return false;
  return type.jsonType === "number";
}
function isPrimitiveSchemaType(type) {
  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);
}
function isReferenceSchemaType(type) {
  return isRecord(type) && (type.name === "reference" || isReferenceSchemaType(type.type));
}
function isCrossDatasetReferenceSchemaType(type) {
  return isRecord(type) && (type.name === "crossDatasetReference" || isCrossDatasetReferenceSchemaType(type.type));
}
function isTitledListValue(item) {
  return typeof item === "object" && item !== null && "title" in item && "value" in item;
}
function isSpanSchemaType(type) {
  if (!isRecord(type))
    return false;
  return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
function isBlockSchemaType(type) {
  if (!isRecord(type))
    return false;
  if (!Array.isArray(type.fields))
    return false;
  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField);
  const maybeStyle = type.fields.find(isBlockStyleObjectField);
  const maybeList = type.fields.find(isBlockListObjectField);
  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);
}
function isBlockStyleObjectField(field) {
  if (!isRecord(field))
    return false;
  if (field.name !== "style")
    return false;
  return isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockListObjectField(field) {
  if (!isRecord(field))
    return false;
  if (field.name !== "listItem")
    return false;
  return isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockChildrenObjectField(field) {
  if (!isRecord(field))
    return false;
  if (field.name !== "children")
    return false;
  if (!isArraySchemaType(field.type))
    return false;
  return field.type.of.some(isSpanSchemaType);
}
function defineType(schemaDefinition, defineOptions) {
  return schemaDefinition;
}
function defineField(schemaField, defineOptions) {
  return schemaField;
}
function defineArrayMember(arrayOfSchema, defineOptions) {
  return arrayOfSchema;
}
function typed(input) {
  return input;
}
function isSlug(thing) {
  return isObject(thing) && typeof thing.current === "string";
}
function isCreateSquashedMutation(mutation) {
  return "createSquashed" in mutation;
}
function isValidationError(node) {
  return node.level === "error";
}
function isValidationWarning(node) {
  return node.level === "warning";
}
function isValidationInfo(node) {
  return node.level === "info";
}

// node_modules/sanity/lib/index.esm.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());

// node_modules/@sanity/util/lib/paths.esm.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reKeySegment2 = /_key\s*==\s*['"](.*)['"]/;
var EMPTY_PATH = [];
var FOCUS_TERMINATOR = "$";
function get(obj, path2, defaultVal) {
  const select2 = typeof path2 === "string" ? fromString(path2) : path2;
  if (!Array.isArray(select2)) {
    throw new Error("Path must be an array or a string");
  }
  let acc = obj;
  for (let i = 0; i < select2.length; i++) {
    const segment = select2[i];
    if (isIndexSegment(segment)) {
      if (!Array.isArray(acc)) {
        return defaultVal;
      }
      acc = acc[segment];
    }
    if (isKeySegment(segment)) {
      if (!Array.isArray(acc)) {
        return defaultVal;
      }
      acc = acc.find((item) => item._key === segment._key);
    }
    if (typeof segment === "string") {
      acc = typeof acc === "object" && acc !== null ? acc[segment] : void 0;
    }
    if (typeof acc === "undefined") {
      return defaultVal;
    }
  }
  return acc;
}
var pathsMemo = /* @__PURE__ */ new Map();
function pathFor(path2) {
  if (path2.length === 0) {
    return EMPTY_PATH;
  }
  const asString = toString(path2);
  if (pathsMemo.has(asString)) {
    return pathsMemo.get(asString);
  }
  pathsMemo.set(asString, path2);
  Object.freeze(path2);
  return path2;
}
function isEqual(path2, otherPath) {
  return path2.length === otherPath.length && path2.every((segment, i) => isSegmentEqual(segment, otherPath[i]));
}
function numEqualSegments(path2, otherPath) {
  const length2 = Math.min(path2.length, otherPath.length);
  for (let i = 0; i < length2; i++) {
    if (!isSegmentEqual(path2[i], otherPath[i])) {
      return i;
    }
  }
  return length2;
}
function isSegmentEqual(segmentA, segmentB) {
  if (isKeySegment(segmentA) && isKeySegment(segmentB)) {
    return segmentA._key === segmentB._key;
  }
  if (isIndexSegment(segmentA)) {
    return Number(segmentA) === Number(segmentB);
  }
  if (isIndexTuple(segmentA) && isIndexTuple(segmentB)) {
    return segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1];
  }
  return segmentA === segmentB;
}
function startsWith(prefix, path2) {
  return prefix.every((segment, i) => isSegmentEqual(segment, path2[i]));
}
function trimLeft(prefix, path2) {
  if (prefix.length === 0 || path2.length === 0) {
    return path2;
  }
  const [prefixHead, ...prefixTail] = prefix;
  const [pathHead, ...pathTail] = path2;
  if (!isSegmentEqual(prefixHead, pathHead)) {
    return path2;
  }
  return pathFor(trimLeft(prefixTail, pathTail));
}
function trimChildPath(path2, childPath) {
  return startsWith(path2, childPath) ? trimLeft(path2, childPath) : EMPTY_PATH;
}
function toString(path2) {
  if (!Array.isArray(path2)) {
    throw new Error("Path is not an array");
  }
  return path2.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === "number") {
      return "".concat(target, "[").concat(segment, "]");
    }
    if (segmentType === "string") {
      const separator = i === 0 ? "" : ".";
      return "".concat(target).concat(separator).concat(segment);
    }
    if (isKeySegment(segment) && segment._key) {
      return "".concat(target, '[_key=="').concat(segment._key, '"]');
    }
    if (Array.isArray(segment)) {
      const [from2, to] = segment;
      return "".concat(target, "[").concat(from2, ":").concat(to, "]");
    }
    throw new Error("Unsupported path segment `".concat(JSON.stringify(segment), "`"));
  }, "");
}
function _resolveKeyedPath(value, path2) {
  if (path2.length === 0) {
    return path2;
  }
  const [next, ...rest] = path2;
  if (typeof next === "number") {
    if (!Array.isArray(value) || !(next in value)) {
      return [];
    }
    const item = value[next];
    const key2 = item == null ? void 0 : item._key;
    return [typeof key2 === "string" ? {
      _key: item._key
    } : next, ..._resolveKeyedPath(item, rest)];
  }
  const nextVal = get(value, [next]);
  return [next, ..._resolveKeyedPath(nextVal, rest)];
}
function resolveKeyedPath(value, path2) {
  if (!Array.isArray(path2)) {
    throw new Error("Path is not an array");
  }
  return pathFor(_resolveKeyedPath(value, path2));
}
function fromString(path2) {
  if (typeof path2 !== "string") {
    throw new Error("Path is not a string");
  }
  const segments = path2.match(rePropName);
  if (!segments) {
    throw new Error("Invalid path string");
  }
  return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
  if (isIndexSegment(segment)) {
    return normalizeIndexSegment(segment);
  }
  if (isKeySegment(segment)) {
    return normalizeKeySegment(segment);
  }
  if (isIndexTuple(segment)) {
    return normalizeIndexTupleSegment(segment);
  }
  return segment;
}
function normalizeIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
  const segments = segment.match(reKeySegment2);
  return {
    _key: segments[1]
  };
}
function normalizeIndexTupleSegment(segment) {
  const [from2, to] = segment.split(":").map((seg) => seg === "" ? seg : Number(seg));
  return [from2, to];
}

// node_modules/sanity/lib/index.esm.js
var import_react51 = __toESM(require_react());
var import_react_fast_compare = __toESM(require_react_fast_compare());
var import_debounce2 = __toESM(require_debounce());
init_esm();

// node_modules/@sanity/ui/dist/index.esm.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react46 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
init_styled_components_browser_esm();

// node_modules/@sanity/color/dist/index.js
var black$1 = "#101112";
var white$1 = "#fff";
var gray = {
  "50": {
    title: "Gray 50",
    hex: "#f2f3f5"
  },
  "100": {
    title: "Gray 100",
    hex: "#e6e8ec"
  },
  "200": {
    title: "Gray 200",
    hex: "#ced2d9"
  },
  "300": {
    title: "Gray 300",
    hex: "#b6bcc6"
  },
  "400": {
    title: "Gray 400",
    hex: "#9ea6b3"
  },
  "500": {
    title: "Gray 500",
    hex: "#8690a0"
  },
  "600": {
    title: "Gray 600",
    hex: "#6e7683"
  },
  "700": {
    title: "Gray 700",
    hex: "#565d67"
  },
  "800": {
    title: "Gray 800",
    hex: "#3f434a"
  },
  "900": {
    title: "Gray 900",
    hex: "#272a2e"
  },
  "950": {
    title: "Gray 950",
    hex: "#1b1d20"
  }
};
var blue = {
  "50": {
    title: "Blue 50",
    hex: "#e8f1fe"
  },
  "100": {
    title: "Blue 100",
    hex: "#d2e3fe"
  },
  "200": {
    title: "Blue 200",
    hex: "#a6c8fd"
  },
  "300": {
    title: "Blue 300",
    hex: "#7aacfd"
  },
  "400": {
    title: "Blue 400",
    hex: "#4e91fc"
  },
  "500": {
    title: "Blue 500",
    hex: "#2276fc"
  },
  "600": {
    title: "Blue 600",
    hex: "#1e61cd"
  },
  "700": {
    title: "Blue 700",
    hex: "#1a4d9e"
  },
  "800": {
    title: "Blue 800",
    hex: "#17396f"
  },
  "900": {
    title: "Blue 900",
    hex: "#132540"
  },
  "950": {
    title: "Blue 950",
    hex: "#111b29"
  }
};
var purple = {
  "50": {
    title: "Purple 50",
    hex: "#f8e9fe"
  },
  "100": {
    title: "Purple 100",
    hex: "#f2d3fe"
  },
  "200": {
    title: "Purple 200",
    hex: "#e6a7fd"
  },
  "300": {
    title: "Purple 300",
    hex: "#d97bfd"
  },
  "400": {
    title: "Purple 400",
    hex: "#cd4efc"
  },
  "500": {
    title: "Purple 500",
    hex: "#c123fc"
  },
  "600": {
    title: "Purple 600",
    hex: "#9d1fcd"
  },
  "700": {
    title: "Purple 700",
    hex: "#7a1b9e"
  },
  "800": {
    title: "Purple 800",
    hex: "#56186f"
  },
  "900": {
    title: "Purple 900",
    hex: "#331440"
  },
  "950": {
    title: "Purple 950",
    hex: "#211229"
  }
};
var magenta = {
  "50": {
    title: "Magenta 50",
    hex: "#fcebf5"
  },
  "100": {
    title: "Magenta 100",
    hex: "#f9d7eb"
  },
  "200": {
    title: "Magenta 200",
    hex: "#f4afd8"
  },
  "300": {
    title: "Magenta 300",
    hex: "#ef87c4"
  },
  "400": {
    title: "Magenta 400",
    hex: "#ea5fb1"
  },
  "500": {
    title: "Magenta 500",
    hex: "#e5389e"
  },
  "600": {
    title: "Magenta 600",
    hex: "#ba3082"
  },
  "700": {
    title: "Magenta 700",
    hex: "#8f2866"
  },
  "800": {
    title: "Magenta 800",
    hex: "#65204a"
  },
  "900": {
    title: "Magenta 900",
    hex: "#3a182d"
  },
  "950": {
    title: "Magenta 950",
    hex: "#25141f"
  }
};
var red = {
  "50": {
    title: "Red 50",
    hex: "#fdebea"
  },
  "100": {
    title: "Red 100",
    hex: "#fcd8d5"
  },
  "200": {
    title: "Red 200",
    hex: "#f9b1ab"
  },
  "300": {
    title: "Red 300",
    hex: "#f68b82"
  },
  "400": {
    title: "Red 400",
    hex: "#f36458"
  },
  "500": {
    title: "Red 500",
    hex: "#f03e2f"
  },
  "600": {
    title: "Red 600",
    hex: "#c33529"
  },
  "700": {
    title: "Red 700",
    hex: "#962c23"
  },
  "800": {
    title: "Red 800",
    hex: "#69231d"
  },
  "900": {
    title: "Red 900",
    hex: "#3c1a17"
  },
  "950": {
    title: "Red 950",
    hex: "#261514"
  }
};
var orange = {
  "50": {
    title: "Orange 50",
    hex: "#fef0e6"
  },
  "100": {
    title: "Orange 100",
    hex: "#fee2ce"
  },
  "200": {
    title: "Orange 200",
    hex: "#fdc59d"
  },
  "300": {
    title: "Orange 300",
    hex: "#fca86d"
  },
  "400": {
    title: "Orange 400",
    hex: "#fb8b3c"
  },
  "500": {
    title: "Orange 500",
    hex: "#e57322"
  },
  "600": {
    title: "Orange 600",
    hex: "#ba5f1f"
  },
  "700": {
    title: "Orange 700",
    hex: "#904b1b"
  },
  "800": {
    title: "Orange 800",
    hex: "#653818"
  },
  "900": {
    title: "Orange 900",
    hex: "#3a2415"
  },
  "950": {
    title: "Orange 950",
    hex: "#251a13"
  }
};
var yellow = {
  "50": {
    title: "Yellow 50",
    hex: "#fef7da"
  },
  "100": {
    title: "Yellow 100",
    hex: "#fdefb6"
  },
  "200": {
    title: "Yellow 200",
    hex: "#fcdf6d"
  },
  "300": {
    title: "Yellow 300",
    hex: "#fbd024"
  },
  "400": {
    title: "Yellow 400",
    hex: "#d9b421"
  },
  "500": {
    title: "Yellow 500",
    hex: "#b7991e"
  },
  "600": {
    title: "Yellow 600",
    hex: "#967e1c"
  },
  "700": {
    title: "Yellow 700",
    hex: "#746219"
  },
  "800": {
    title: "Yellow 800",
    hex: "#534717"
  },
  "900": {
    title: "Yellow 900",
    hex: "#312c14"
  },
  "950": {
    title: "Yellow 950",
    hex: "#201e13"
  }
};
var green = {
  "50": {
    title: "Green 50",
    hex: "#e7f9ed"
  },
  "100": {
    title: "Green 100",
    hex: "#d0f4dc"
  },
  "200": {
    title: "Green 200",
    hex: "#a1eaba"
  },
  "300": {
    title: "Green 300",
    hex: "#72e097"
  },
  "400": {
    title: "Green 400",
    hex: "#43d675"
  },
  "500": {
    title: "Green 500",
    hex: "#3ab564"
  },
  "600": {
    title: "Green 600",
    hex: "#329454"
  },
  "700": {
    title: "Green 700",
    hex: "#297343"
  },
  "800": {
    title: "Green 800",
    hex: "#215233"
  },
  "900": {
    title: "Green 900",
    hex: "#183122"
  },
  "950": {
    title: "Green 950",
    hex: "#14211a"
  }
};
var cyan = {
  "50": {
    title: "Cyan 50",
    hex: "#e3fafd"
  },
  "100": {
    title: "Cyan 100",
    hex: "#c7f5fc"
  },
  "200": {
    title: "Cyan 200",
    hex: "#90ecf9"
  },
  "300": {
    title: "Cyan 300",
    hex: "#59e3f6"
  },
  "400": {
    title: "Cyan 400",
    hex: "#22daf4"
  },
  "500": {
    title: "Cyan 500",
    hex: "#1fb8ce"
  },
  "600": {
    title: "Cyan 600",
    hex: "#1c97a8"
  },
  "700": {
    title: "Cyan 700",
    hex: "#197583"
  },
  "800": {
    title: "Cyan 800",
    hex: "#16545d"
  },
  "900": {
    title: "Cyan 900",
    hex: "#133237"
  },
  "950": {
    title: "Cyan 950",
    hex: "#112124"
  }
};
var hues = {
  gray,
  blue,
  purple,
  magenta,
  red,
  orange,
  yellow,
  green,
  cyan
};
var COLOR_HUES = ["gray", "blue", "purple", "magenta", "red", "orange", "yellow", "green", "cyan"];
var black = {
  title: "Black",
  hex: black$1
};
var white = {
  title: "White",
  hex: white$1
};

// node_modules/@sanity/icons/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var AccessDeniedIcon = (0, import_react.forwardRef)(function AccessDeniedIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "access-denied",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18.1568 6.84315C21.281 9.96734 21.281 15.0327 18.1568 18.1569C15.0326 21.281 9.96733 21.281 6.84313 18.1569C3.71894 15.0327 3.71894 9.96734 6.84313 6.84315C9.96733 3.71895 15.0326 3.71895 18.1568 6.84315ZM18.1568 6.84315L6.844 18.156",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ActivityIcon = (0, import_react.forwardRef)(function ActivityIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "activity",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M21 15H19L15.5 7L11 18L8 12L6 15H4",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var AddCircleIcon = (0, import_react.forwardRef)(function AddCircleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "add-circle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 12.4H17M12.5 8V17M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var AddIcon = (0, import_react.forwardRef)(function AddIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "add",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 5V20M5 12.5H20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ApiIcon = (0, import_react.forwardRef)(function ApiIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "api",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M5.93047 13.2107L6.66782 10.3728H6.73089L7.45854 13.2107H5.93047ZM8.17164 16H9.66089L7.56041 9H5.93047L3.82999 16H5.20767L5.65396 14.2876H7.73505L8.17164 16Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5389 9V16H11.9166V13.7782H13.0323C14.541 13.7782 15.5015 12.8517 15.5015 11.3964C15.5015 9.92654 14.5701 9 13.1003 9H10.5389ZM11.9166 10.1303H12.751C13.6533 10.1303 14.1044 10.5475 14.1044 11.3867C14.1044 12.2308 13.6533 12.6431 12.751 12.6431H11.9166V10.1303Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M21.1675 16V14.8164H19.717V10.1836H21.1675V9H16.8889V10.1836H18.3393V14.8164H16.8889V16H21.1675Z",
      fill: "currentColor"
    })]
  });
});
var ArchiveIcon = (0, import_react.forwardRef)(function ArchiveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "archive",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 10.5V17M20.5 7.5V20.5H4.5V7.5L7.5 4.5H17.5L20.5 7.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M4.5 7.5H20.5M16 14L12.5 17.5L9 14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ArrowDownIcon = (0, import_react.forwardRef)(function ArrowDownIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "arrow-down",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 19.5V5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M18 14L12.5 19.5L7 14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ArrowLeftIcon = (0, import_react.forwardRef)(function ArrowLeftIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "arrow-left",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 12.5H20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11 18L5.5 12.5L11 7",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ArrowRightIcon = (0, import_react.forwardRef)(function ArrowRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "arrow-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19.5 12.5H5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M14 7L19.5 12.5L14 18",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ArrowTopRightIcon = (0, import_react.forwardRef)(function ArrowTopRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "arrow-top-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 8.5L7 18",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9 8.5H16.5V16",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ArrowUpIcon = (0, import_react.forwardRef)(function ArrowUpIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "arrow-up",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M7 11L12.5 5.5L18 11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 5.5V20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var BarChartIcon = (0, import_react.forwardRef)(function BarChartIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bar-chart",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 5V19.5H20M8.5 18V13M11.5 18V9M14.5 18V11M17.5 18V7",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BasketIcon = (0, import_react.forwardRef)(function BasketIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "basket",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8.5 10.5H5L6.5 19.5H18.5L20 10.5H16.5M8.5 10.5L10.2721 5.18377C10.4082 4.77543 10.7903 4.5 11.2208 4.5H13.7792C14.2097 4.5 14.5918 4.77543 14.7279 5.18377L16.5 10.5M8.5 10.5H16.5M8.5 10.5L9.5 19.5M16.5 10.5L15.5 19.5M12.5 10.5V19.5M19.5 13.5H5.5M19 16.5H6",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BellIcon = (0, import_react.forwardRef)(function BellIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bell",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 17.5V18.5C10.5 20 11.5 20.5 12.5 20.5C13.5 20.5 14.5 20 14.5 18.5V17.5M5.5 17.5C6.5 16 6.5 15 6.5 12C6.5 8 8.5 5.5 12.5 5.5C16.5 5.5 18.5 8 18.5 12C18.5 15 18.5 16 19.5 17.5H5.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BillIcon = (0, import_react.forwardRef)(function BillIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bill",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M6.50001 5.5C8.50003 5.5 8.50003 8 8.50003 8V9.5M6.50001 5.5C4.5 5.5 4.5 8 4.5 8L4.50001 9.5H8.50003M6.50001 5.5C6.50001 5.5 15.8333 5.5 17.6667 5.5C19.5 5.5 19.5 8.5 19.5 8.5V20L17.6667 19L15.8333 20L14 19L12.1667 20L10.3334 19L8.50003 20V9.5M11 12.5H15M11 9.5H16M11 15.5H16",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BinaryDocumentIcon = (0, import_react.forwardRef)(function BinaryDocumentIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "binary-document",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 12.5V17.5M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5ZM12.5 12.5V17.5H15.5V12.5H12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinecap: "square",
      strokeLinejoin: "round"
    })]
  });
});
var BlockContentIcon = (0, import_react.forwardRef)(function BlockContentIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "block-content",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21 7.60002L11 7.60003V6.40003L21 6.40002V7.60002Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21 11.2667L12.4833 11.2667V10.0667L21 10.0667V11.2667Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21 14.9334H13.9254V13.7334L21 13.7334V14.9334Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21 18.6002H4V17.4002H21V18.6002Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9.86438 15.6H11.2L8.27623 7.60003H6.92377L4 15.6H5.29072L6.0371 13.4767H9.12362L9.86438 15.6ZM7.53546 9.05255H7.63086L8.80374 12.4344H6.35698L7.53546 9.05255Z",
      fill: "currentColor"
    })]
  });
});
var BlockElementIcon = (0, import_react.forwardRef)(function BlockElementIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "block-element",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5 19.5H20M5 5.5H20M6.5 8.5H18.5V16.5H6.5V8.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BlockquoteIcon = (0, import_react.forwardRef)(function BlockquoteIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "blockquote",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10 17.5H19M6 7.5H19M10 12.5H17M6.5 12V18",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BoldIcon = (0, import_react.forwardRef)(function BoldIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bold",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M13.2087 18C15.5322 18 16.9731 16.793 16.9731 14.8844C16.9731 13.4812 15.9245 12.3949 14.4836 12.2892V12.1534C15.6001 11.9875 16.4526 10.9841 16.4526 9.82991C16.4526 8.14761 15.1927 7.11409 13.0804 7.11409H8.32019V18H13.2087ZM10.5985 8.85674H12.4995C13.5859 8.85674 14.212 9.37727 14.212 10.2448C14.212 11.1199 13.5406 11.6254 12.3109 11.6254H10.5985V8.85674ZM10.5985 16.2574V13.1643H12.575C13.9178 13.1643 14.6496 13.6924 14.6496 14.6882C14.6496 15.7066 13.9404 16.2574 12.6278 16.2574H10.5985Z",
      fill: "currentColor"
    })
  });
});
var BoltIcon = (0, import_react.forwardRef)(function BoltIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bolt",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18 11.5L9 21L11 13.5H7L16 4L14 11.5H18Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BookIcon = (0, import_react.forwardRef)(function BookIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "book",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M20.5 17.5V5.5L12.5 6.5M20.5 17.5L12.5 18.5M20.5 17.5V18.5M4.5 17.5V5.5L12.5 6.5M4.5 17.5L12.5 18.5M4.5 17.5V18.5M12.5 18.5L4.5 19.5V18.5M12.5 18.5L20.5 19.5V18.5M12.5 18.5V6.5M12.5 18.5H4.5M12.5 18.5H20.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BottleIcon = (0, import_react.forwardRef)(function BottleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bottle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 17.5L17.5 17.5M17.5 13C17.5 12.087 17.5 11.3518 17.5 11C17.5 8.5 14.5 9 14.5 7.37494L14.5 5.5M17.5 13C17.5 15.1229 17.5 18.7543 17.5 20.5022C17.5 21.0545 17.0523 21.5 16.5 21.5L8.5 21.5C7.94772 21.5 7.5 21.0547 7.5 20.5024C7.5 18.8157 7.5 15.3546 7.5 13M17.5 13L7.5 13M7.5 13C7.5 12.2538 7.5 11.5648 7.5 11C7.5 8.5 10.5 9 10.5 7.37494L10.5 5.5M10.5 5.5L10.5 3.99999C10.5 3.72385 10.7239 3.49999 11 3.49999L14 3.49999C14.2761 3.49999 14.5 3.72385 14.5 3.99999L14.5 5.5M10.5 5.5L14.5 5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var BulbFilledIcon = (0, import_react.forwardRef)(function BulbFilledIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "bulb-filled",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M16.4272 14.3368C15.8273 15.1773 15.5 16.1794 15.5 17.212V18.5C15.5 19.0523 15.0523 19.5 14.5 19.5H14V20.5C14 21.0523 13.5523 21.5 13 21.5H12C11.4477 21.5 11 21.0523 11 20.5V19.5H10.5C9.94772 19.5 9.5 19.0523 9.5 18.5V17.212C9.5 16.1794 9.17266 15.1773 8.57284 14.3368C7.60216 12.9767 7 11.94 7 10C7 7 9.5 4.5 12.5 4.5C15.5 4.5 18 7 18 10C18 11.94 17.3978 12.9767 16.4272 14.3368Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16.4272 14.3368L15.9388 13.9883L16.4272 14.3368ZM14 19.5V18.9H13.4V19.5H14ZM11 19.5H11.6V18.9H11V19.5ZM8.57284 14.3368L9.06122 13.9883H9.06122L8.57284 14.3368ZM16.1 17.212C16.1 16.3069 16.3868 15.4261 16.9155 14.6853L15.9388 13.9883C15.2678 14.9284 14.9 16.0519 14.9 17.212H16.1ZM16.1 18.5V17.212H14.9V18.5H16.1ZM14.5 20.1C15.3837 20.1 16.1 19.3837 16.1 18.5H14.9C14.9 18.7209 14.7209 18.9 14.5 18.9V20.1ZM14 20.1H14.5V18.9H14V20.1ZM13.4 19.5V20.5H14.6V19.5H13.4ZM13.4 20.5C13.4 20.7209 13.2209 20.9 13 20.9V22.1C13.8837 22.1 14.6 21.3837 14.6 20.5H13.4ZM13 20.9H12V22.1H13V20.9ZM12 20.9C11.7791 20.9 11.6 20.7209 11.6 20.5H10.4C10.4 21.3837 11.1163 22.1 12 22.1V20.9ZM11.6 20.5V19.5H10.4V20.5H11.6ZM10.5 20.1H11V18.9H10.5V20.1ZM8.9 18.5C8.9 19.3837 9.61634 20.1 10.5 20.1V18.9C10.2791 18.9 10.1 18.7209 10.1 18.5H8.9ZM8.9 17.212V18.5H10.1V17.212H8.9ZM8.08446 14.6853C8.61315 15.4261 8.9 16.3069 8.9 17.212H10.1C10.1 16.0519 9.73217 14.9284 9.06122 13.9883L8.08446 14.6853ZM6.4 10C6.4 11.0377 6.56208 11.8595 6.86624 12.611C7.16624 13.3521 7.59495 13.9995 8.08446 14.6853L9.06122 13.9883C8.58004 13.314 8.22233 12.7629 7.97858 12.1607C7.739 11.5688 7.6 10.9023 7.6 10H6.4ZM12.5 3.9C9.16863 3.9 6.4 6.66863 6.4 10H7.6C7.6 7.33137 9.83137 5.1 12.5 5.1V3.9ZM18.6 10C18.6 6.66863 15.8314 3.9 12.5 3.9V5.1C15.1686 5.1 17.4 7.33137 17.4 10H18.6ZM16.9155 14.6853C17.4051 13.9995 17.8338 13.3521 18.1338 12.611C18.4379 11.8595 18.6 11.0377 18.6 10H17.4C17.4 10.9023 17.261 11.5688 17.0214 12.1607C16.7777 12.7629 16.42 13.314 15.9388 13.9883L16.9155 14.6853Z",
      fill: "currentColor"
    })]
  });
});
var BulbOutlineIcon = (0, import_react.forwardRef)(function BulbOutlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "bulb-outline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 16.5H15.5M11 20V20.5C11 21.0523 11.4477 21.5 12 21.5H13C13.5523 21.5 14 21.0523 14 20.5V20M18 10C18 11.94 17.3978 12.9767 16.4272 14.3368C15.8273 15.1773 15.5 16.1794 15.5 17.212V18.5C15.5 19.0523 15.0523 19.5 14.5 19.5H10.5C9.94772 19.5 9.5 19.0523 9.5 18.5V17.212C9.5 16.1794 9.17266 15.1773 8.57284 14.3368C7.60216 12.9767 7 11.94 7 10C7 7 9.5 4.5 12.5 4.5C15.5 4.5 18 7 18 10Z",
      stroke: "currentColor",
      strokeWidth: 1.2
    })
  });
});
var CalendarIcon = (0, import_react.forwardRef)(function CalendarIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "calendar",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M4.5 10.5V19.5H20.5V10.5M4.5 10.5V5.5H20.5V10.5M4.5 10.5H12.5H20.5M20.5 13.5H16.5M16.5 13.5H12.5M16.5 13.5V10.5M16.5 13.5V16.5M12.5 13.5H8.5M12.5 13.5V16.5M12.5 13.5V10.5M8.5 13.5H4.5M8.5 13.5V10.5M8.5 13.5V16.5M20.5 16.5H16.5M16.5 16.5H12.5M16.5 16.5V19.5M12.5 16.5H8.5M12.5 16.5V19.5M8.5 16.5H4.5M8.5 16.5V19.5M17.5 8V3M7.5 8V3",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CaseIcon = (0, import_react.forwardRef)(function CaseIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "case",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9 8.5122V6C9 5.44772 9.44772 5 10 5H15C15.5523 5 16 5.44772 16 6V8.5122M4.5 12V18.5C4.5 19.0523 4.94772 19.5 5.5 19.5H19.5C20.0523 19.5 20.5 19.0523 20.5 18.5V12M4.5 12V9.5122C4.5 8.95991 4.94772 8.5122 5.5 8.5122H19.5C20.0523 8.5122 20.5 8.95991 20.5 9.5122V12M4.5 12L11.7978 14.7367C12.2505 14.9064 12.7495 14.9064 13.2022 14.7367L20.5 12",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ChartUpwardIcon = (0, import_react.forwardRef)(function ChartUpwardIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "chart-upward",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 5V19.5H20M7.5 16L11.5 11.5L15.5 14L19.5 8.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CheckmarkCircleIcon = (0, import_react.forwardRef)(function CheckmarkCircleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "checkmark-circle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 12.1316L11.7414 14.5L16 10M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CheckmarkIcon = (0, import_react.forwardRef)(function CheckmarkIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "checkmark",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 11.5L10.5 16.5L19.5 7.60001",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ChevronDownIcon = (0, import_react.forwardRef)(function ChevronDownIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "chevron-down",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17 10.5L12.5 15L8 10.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ChevronLeftIcon = (0, import_react.forwardRef)(function ChevronLeftIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "chevron-left",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M14.5 17L10 12.5L14.5 8",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ChevronRightIcon = (0, import_react.forwardRef)(function ChevronRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "chevron-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 8L15 12.5L10.5 17",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ChevronUpIcon = (0, import_react.forwardRef)(function ChevronUpIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "chevron-up",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 14.5L12.5 10L17 14.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CircleIcon = (0, import_react.forwardRef)(function CircleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "circle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("circle", {
      cx: 12.5,
      cy: 12.5,
      r: 8,
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ClipboardIcon = (0, import_react.forwardRef)(function ClipboardIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "clipboard",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 5.5H6.5V19.5H18.5V5.5H17M12.5 3C11.5 3 11.5 4.5 11 4.5C10 4.5 9.5 5 9.5 6.5H15.6C15.6 5 15 4.5 14 4.5C13.5 4.5 13.5 3 12.5 3Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ClipboardImageIcon = (0, import_react.forwardRef)(function ClipboardImageIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "clipboard-image",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 5.5H6.5V19.5H10.5M17 5.5H18.5V11.5M10.5 18.5L12.73 15.8983C13.1327 15.4285 13.8613 15.4335 14.2575 15.909L15.299 17.1588C15.6754 17.6105 16.3585 17.6415 16.7743 17.2257L16.9903 17.0097C17.2947 16.7053 17.7597 16.6298 18.1447 16.8223L20.5 18M10.5 11.5H20.5V21.5H10.5V11.5ZM12.5 3C11.5 3 11.5 4.5 11 4.5C10 4.5 9.5 5 9.5 6.5H15.6C15.6 5 15 4.5 14 4.5C13.5 4.5 13.5 3 12.5 3Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ClockIcon = (0, import_react.forwardRef)(function ClockIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "clock",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 8V12.5L15.5 15.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CloseCircleIcon = (0, import_react.forwardRef)(function CloseCircleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "close-circle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 15.5L12.5 12.5M12.5 12.5L15.5 9.5M12.5 12.5L9.5 9.5M12.5 12.5L15.5 15.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CloseIcon = (0, import_react.forwardRef)(function CloseIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "close",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18 7L7 18M7 7L18 18",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CodeBlockIcon = (0, import_react.forwardRef)(function CodeBlockIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "code-block",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11 15L8.5 12.5L11 10M14 10L16.5 12.5L14 15M5.5 6.5H19.5V18.5H5.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CodeIcon = (0, import_react.forwardRef)(function CodeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "code",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11 16L7.5 12.5L11 9M14 9L17.5 12.5L14 16",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CogIcon = (0, import_react.forwardRef)(function CogIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "cog",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M14.2624 5.40607L13.8714 4.42848C13.6471 3.86771 13.104 3.5 12.5 3.5C11.896 3.5 11.3529 3.86771 11.1286 4.42848L10.7376 5.40607C10.5857 5.78585 10.2869 6.08826 9.90901 6.2448C9.53111 6.40133 9.10603 6.39874 8.73006 6.23761L7.76229 5.82285C7.20716 5.58494 6.56311 5.70897 6.13604 6.13604C5.70897 6.56311 5.58494 7.20716 5.82285 7.76229L6.23761 8.73006C6.39874 9.10602 6.40133 9.53111 6.2448 9.90901C6.08826 10.2869 5.78585 10.5857 5.40607 10.7376L4.42848 11.1286C3.86771 11.3529 3.5 11.896 3.5 12.5C3.5 13.104 3.86771 13.6471 4.42848 13.8714L5.40607 14.2624C5.78585 14.4143 6.08826 14.7131 6.2448 15.091C6.40133 15.4689 6.39874 15.894 6.23761 16.2699L5.82285 17.2377C5.58494 17.7928 5.70897 18.4369 6.13604 18.864C6.56311 19.291 7.20716 19.4151 7.76229 19.1772L8.73006 18.7624C9.10603 18.6013 9.53111 18.5987 9.90901 18.7552C10.2869 18.9117 10.5857 19.2141 10.7376 19.5939L11.1286 20.5715C11.3529 21.1323 11.896 21.5 12.5 21.5C13.104 21.5 13.6471 21.1323 13.8714 20.5715L14.2624 19.5939C14.4143 19.2141 14.7131 18.9117 15.091 18.7552C15.4689 18.5987 15.894 18.6013 16.2699 18.7624L17.2377 19.1771C17.7928 19.4151 18.4369 19.291 18.864 18.864C19.291 18.4369 19.4151 17.7928 19.1771 17.2377L18.7624 16.2699C18.6013 15.894 18.5987 15.4689 18.7552 15.091C18.9117 14.7131 19.2141 14.4143 19.5939 14.2624L20.5715 13.8714C21.1323 13.6471 21.5 13.104 21.5 12.5C21.5 11.896 21.1323 11.3529 20.5715 11.1286L19.5939 10.7376C19.2141 10.5857 18.9117 10.2869 18.7552 9.90901C18.5987 9.53111 18.6013 9.10602 18.7624 8.73006L19.1772 7.76229C19.4151 7.20716 19.291 6.56311 18.864 6.13604C18.4369 5.70897 17.7928 5.58494 17.2377 5.82285L16.2699 6.23761C15.894 6.39874 15.4689 6.40133 15.091 6.2448C14.7131 6.08826 14.4143 5.78585 14.2624 5.40607Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 12.5C16.5 14.7091 14.7091 16.5 12.5 16.5C10.2909 16.5 8.5 14.7091 8.5 12.5C8.5 10.2909 10.2909 8.5 12.5 8.5C14.7091 8.5 16.5 10.2909 16.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var CollapseIcon = (0, import_react.forwardRef)(function CollapseIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "collapse",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6 14.5L10.5 14.5V19M19 10.5H14.5L14.5 6",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 14.5L6 19M14.5 10.5L19 6",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ColorWheelIcon = (0, import_react.forwardRef)(function ColorWheelIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "color-wheel",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.43853 5.10896L11.1606 9.26642M13.8394 15.7336L15.5615 19.891M15.7336 11.1606L19.891 9.43853M9.26642 13.8394L5.10896 15.5615M5.3139 9.52342L9.23359 11.147M15.7664 13.853L19.6861 15.4766M13.853 9.23359L15.4766 5.3139M9.52342 19.6861L11.147 15.7664M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5ZM16 12.5C16 14.433 14.433 16 12.5 16C10.567 16 9 14.433 9 12.5C9 10.567 10.567 9 12.5 9C14.433 9 16 10.567 16 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CommentIcon = (0, import_react.forwardRef)(function CommentIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "comment",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 16.5H9.5V20.5L13.5 16.5H17.5C18.6046 16.5 19.5 15.6046 19.5 14.5V8.5C19.5 7.39543 18.6046 6.5 17.5 6.5H7.5C6.39543 6.5 5.5 7.39543 5.5 8.5V14.5C5.5 15.6046 6.39543 16.5 7.5 16.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ComponentIcon = (0, import_react.forwardRef)(function ComponentIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "component",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8.5 8.5L12.5 12.5M12.5 12.5L16.5 16.5M12.5 12.5L16.5 8.5M12.5 12.5L8.5 16.5M12.5 4L21 12.5L12.5 21L4 12.5L12.5 4Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ComposeIcon = (0, import_react.forwardRef)(function ComposeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "compose",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17 6L19 8M14 5.5H5.5V19.5H19.5V11M9 16L9.5 13.5L19 4L21 6L11.5 15.5L9 16Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ControlsIcon = (0, import_react.forwardRef)(function ControlsIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "controls",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 5V7.5M6.5 7.5C5.39543 7.5 4.5 8.39543 4.5 9.5C4.5 10.6046 5.39543 11.5 6.5 11.5M6.5 7.5C7.60457 7.5 8.5 8.39543 8.5 9.5C8.5 10.6046 7.60457 11.5 6.5 11.5M6.5 11.5V20M12.5 5V13.5M12.5 13.5C11.3954 13.5 10.5 14.3954 10.5 15.5C10.5 16.6046 11.3954 17.5 12.5 17.5M12.5 13.5C13.6046 13.5 14.5 14.3954 14.5 15.5C14.5 16.6046 13.6046 17.5 12.5 17.5M12.5 17.5V20M18.5 5V7.5M18.5 7.5C17.3954 7.5 16.5 8.39543 16.5 9.5C16.5 10.6046 17.3954 11.5 18.5 11.5M18.5 7.5C19.6046 7.5 20.5 8.39543 20.5 9.5C20.5 10.6046 19.6046 11.5 18.5 11.5M18.5 11.5V20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CopyIcon = (0, import_react.forwardRef)(function CopyIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "copy",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8.5 8.5H5.5V20.5H16.5V16.5M19.5 4.5H8.5V16.5H19.5V4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CreditCardIcon = (0, import_react.forwardRef)(function CreditCardIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "credit-card",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M20.5 9.5H4.5V11.5H20.5V9.5Z",
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7 15.5H14M5.5 18.5H19.5C20.0523 18.5 20.5 18.0523 20.5 17.5V7.5C20.5 6.94772 20.0523 6.5 19.5 6.5H5.5C4.94772 6.5 4.5 6.94772 4.5 7.5V17.5C4.5 18.0523 4.94772 18.5 5.5 18.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var CropIcon = (0, import_react.forwardRef)(function CropIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "crop",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 5V15.5H20M5 9.5H15.5V20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var CubeIcon = (0, import_react.forwardRef)(function CubeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "cube",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M4.5 8L12.5 3L20.5 8V17L12.5 22L4.5 17V8Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 22V13M12.5 13L4.5 8M12.5 13L20.5 8",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DashboardIcon = (0, import_react.forwardRef)(function DashboardIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "dashboard",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M14.5 19.5V12.5M10.5 12.5V5.5M5.5 12.5H19.5M5.5 19.5H19.5V5.5H5.5V19.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DatabaseIcon = (0, import_react.forwardRef)(function DatabaseIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "database",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 7V17.5C18.5 19.0594 16.0504 20.5 12.5 20.5C8.9496 20.5 6.5 19.0594 6.5 17.5V7M18.5 7C18.5 8.45543 15.8137 9.5 12.5 9.5C9.18629 9.5 6.5 8.45543 6.5 7C6.5 5.54457 9.18629 4.5 12.5 4.5C15.8137 4.5 18.5 5.54457 18.5 7Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DesktopIcon = (0, import_react.forwardRef)(function DesktopIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "desktop",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M4.5 13.5V15.5C4.5 16.0523 4.94772 16.5 5.5 16.5H12.5M4.5 13.5V6.5C4.5 5.94772 4.94772 5.5 5.5 5.5H19.5C20.0523 5.5 20.5 5.94772 20.5 6.5V13.5M4.5 13.5H20.5M20.5 13.5V15.5C20.5 16.0523 20.0523 16.5 19.5 16.5H12.5M12.5 16.5V19.5M12.5 19.5H8M12.5 19.5H17",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DocumentIcon = (0, import_react.forwardRef)(function DocumentIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5H18.5V20.5H6.5L6.5 9.5M11.5 4.5L6.5 9.5M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentPdfIcon = (0, import_react.forwardRef)(function DocumentPdfIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-pdf",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.7127 13.8012L12.7193 13.77C12.8488 13.2366 13.0117 12.5716 12.8845 11.969C12.7997 11.4937 12.4493 11.3084 12.1503 11.295C11.7977 11.2794 11.483 11.4803 11.4049 11.7726C11.2576 12.3082 11.3893 13.0402 11.6303 13.973C11.3268 14.6961 10.8425 15.7472 10.4877 16.3721C9.8271 16.7135 8.94113 17.2402 8.80946 17.9053C8.78268 18.028 8.81392 18.1842 8.88757 18.3248C8.97014 18.481 9.10181 18.6015 9.25579 18.6596C9.32274 18.6841 9.40308 18.7042 9.49681 18.7042C9.88959 18.7042 10.5256 18.3873 11.3736 16.9322C11.5031 16.8898 11.637 16.8452 11.7664 16.8006C12.3734 16.5953 13.0028 16.381 13.5718 16.2851C14.2012 16.622 14.9175 16.8385 15.404 16.8385C15.8861 16.8385 16.0758 16.5529 16.1472 16.381C16.2722 16.0797 16.2119 15.7004 16.0088 15.4973C15.7143 15.2072 14.9979 15.1313 13.882 15.2696C13.3331 14.9349 12.9738 14.4796 12.7127 13.8012ZM10.2645 17.1911C9.95431 17.6419 9.71998 17.8673 9.59278 17.9655C9.7423 17.691 10.0346 17.4009 10.2645 17.1911ZM12.2195 11.9355C12.3355 12.1341 12.3199 12.7345 12.2306 13.038C12.1213 12.5939 12.1056 11.9645 12.1704 11.8909L12.2195 11.9355ZM12.1837 14.6247C12.4225 15.0376 12.7238 15.3924 13.0563 15.6557C12.5743 15.7651 12.1346 15.9458 11.7419 16.1065C11.6481 16.1445 11.5566 16.1824 11.4674 16.2181C11.7642 15.6803 12.0119 15.071 12.1837 14.6247ZM15.6562 16.0864L15.6428 16.1065C15.6428 16.1065 15.4375 16.2315 14.6497 15.9213C15.5558 15.8789 15.6562 16.0864 15.6562 16.0864Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentRemoveIcon = (0, import_react.forwardRef)(function DocumentRemoveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-remove",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 14V20.5H18.5V14M6.5 11V9.5L11.5 4.5H18.5V11M3 12.5H22",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentSheetIcon = (0, import_react.forwardRef)(function DocumentSheetIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-sheet",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10.4 19V16.4M10.4 16.4L10.4 13.4M10.4 16.4H8M10.4 16.4H14.4M10.4 13.4V11M10.4 13.4H8M10.4 13.4H14.4M14.4 19V16.4M14.4 16.4V13.4M14.4 16.4H17M14.4 13.4V11M14.4 13.4H17M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentTextIcon = (0, import_react.forwardRef)(function DocumentTextIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-text",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16 13H9M14 16H9M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentVideoIcon = (0, import_react.forwardRef)(function DocumentVideoIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-video",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 16.5V13.5L14 15L11.5 16.5Z",
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentWordIcon = (0, import_react.forwardRef)(function DocumentWordIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-word",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.4699 13.4588H12.5263L13.6328 17H14.5435L16 12H14.9952L14.0656 15.7214H14.0129L12.929 12H12.0672L10.9984 15.7214H10.9419L10.0124 12H9L10.4565 17H11.371L12.4699 13.4588Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentZipIcon = (0, import_react.forwardRef)(function DocumentZipIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "document-zip",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 4.5V9.5H6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15 4.5L13.5 5L15.5 6L13.5 7L15.5 8L13.5 9L15.5 10L13.5 11L14.5 11.5V13M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5ZM13.5 13H15.5L16 17H13L13.5 13Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DocumentsIcon = (0, import_react.forwardRef)(function DocumentsIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "documents",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 4.5V9.5H5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 7.5H19.5V21.5H8.5V18.5M10.5 4.5H16.5V18.5H5.5V9.5L10.5 4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DotIcon = (0, import_react.forwardRef)(function DotIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "dot",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("circle", {
      cx: 12.5,
      cy: 12.5,
      r: 1.5,
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2
    })
  });
});
var DoubleChevronDownIcon = (0, import_react.forwardRef)(function DoubleChevronDownIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "double-chevron-down",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17 8.5L12.5 13L8 8.5M17 12.5L12.5 17L8 12.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DoubleChevronLeftIcon = (0, import_react.forwardRef)(function DoubleChevronLeftIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "double-chevron-left",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 17L8 12.5L12.5 8M16.5 17L12 12.5L16.5 8",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DoubleChevronRightIcon = (0, import_react.forwardRef)(function DoubleChevronRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "double-chevron-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 8L17 12.5L12.5 17M8.5 8L13 12.5L8.5 17",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DoubleChevronUpIcon = (0, import_react.forwardRef)(function DoubleChevronUpIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "double-chevron-up",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 12.5L12.5 8L17 12.5M8 16.5L12.5 12L17 16.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var DownloadIcon = (0, import_react.forwardRef)(function DownloadIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "download",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19.5 17V19.5H5.5V17M12.5 16L12.5 5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M17.5 11L12.5 16L7.5 11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var DragHandleIcon = (0, import_react.forwardRef)(function DragHandleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "drag-handle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 8C10.3284 8 11 7.32843 11 6.5C11 5.67157 10.3284 5 9.5 5C8.67157 5 8 5.67157 8 6.5C8 7.32843 8.67157 8 9.5 8Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 14C10.3284 14 11 13.3284 11 12.5C11 11.6716 10.3284 11 9.5 11C8.67157 11 8 11.6716 8 12.5C8 13.3284 8.67157 14 9.5 14Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11 18.5C11 19.3284 10.3284 20 9.5 20C8.67157 20 8 19.3284 8 18.5C8 17.6716 8.67157 17 9.5 17C10.3284 17 11 17.6716 11 18.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15.5 8C16.3284 8 17 7.32843 17 6.5C17 5.67157 16.3284 5 15.5 5C14.6716 5 14 5.67157 14 6.5C14 7.32843 14.6716 8 15.5 8Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M17 12.5C17 13.3284 16.3284 14 15.5 14C14.6716 14 14 13.3284 14 12.5C14 11.6716 14.6716 11 15.5 11C16.3284 11 17 11.6716 17 12.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15.5 20C16.3284 20 17 19.3284 17 18.5C17 17.6716 16.3284 17 15.5 17C14.6716 17 14 17.6716 14 18.5C14 19.3284 14.6716 20 15.5 20Z",
      fill: "currentColor"
    })]
  });
});
var DropIcon = (0, import_react.forwardRef)(function DropIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "drop",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 14.5C18.5 18 16 20.5 12.5 20.5C9 20.5 6.5 18 6.5 14.5C6.5 11 9.5 7.50001 12.5 4.5C15.5 7.5 18.5 11 18.5 14.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var EarthAmericasIcon = (0, import_react.forwardRef)(function EarthAmericasIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "earth-americas",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M7 13L5.5 9L10 5H15V10L14 9H11L9.5 11L10.5 12H12V13L13 14.5H15.5L18.5 17L15.5 19.5L10.5 20V17L12.5 15L9 13L7 10.5V13Z",
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("circle", {
      cx: 12.5,
      cy: 12.5,
      r: 8,
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var EarthGlobeIcon = (0, import_react.forwardRef)(function EarthGlobeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "earth-globe",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 16.5H19.5M5.5 8.5H19.5M4.5 12.5H20.5M12.5 20.5C12.5 20.5 8 18.5 8 12.5C8 6.5 12.5 4.5 12.5 4.5M12.5 4.5C12.5 4.5 17 6.5 17 12.5C17 18.5 12.5 20.5 12.5 20.5M12.5 4.5V20.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var EditIcon = (0, import_react.forwardRef)(function EditIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "edit",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15 7L18 10M6 19L7 15L17 5L20 8L10 18L6 19Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var EllipsisHorizontalIcon = (0, import_react.forwardRef)(function EllipsisHorizontalIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "ellipsis-horizontal",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 11C7.32843 11 8 11.6716 8 12.5C8 13.3284 7.32843 14 6.5 14C5.67157 14 5 13.3284 5 12.5C5 11.6716 5.67157 11 6.5 11Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 11C13.3284 11 14 11.6716 14 12.5C14 13.3284 13.3284 14 12.5 14C11.6716 14 11 13.3284 11 12.5C11 11.6716 11.6716 11 12.5 11Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 11C19.3284 11 20 11.6716 20 12.5C20 13.3284 19.3284 14 18.5 14C17.6716 14 17 13.3284 17 12.5C17 11.6716 17.6716 11 18.5 11Z",
      fill: "currentColor"
    })]
  });
});
var EllipsisVerticalIcon = (0, import_react.forwardRef)(function EllipsisVerticalIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "ellipsis-vertical",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M14 6.5C14 7.32843 13.3284 8 12.5 8C11.6716 8 11 7.32843 11 6.5C11 5.67157 11.6716 5 12.5 5C13.3284 5 14 5.67157 14 6.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M14 12.5C14 13.3284 13.3284 14 12.5 14C11.6716 14 11 13.3284 11 12.5C11 11.6716 11.6716 11 12.5 11C13.3284 11 14 11.6716 14 12.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M14 18.5C14 19.3284 13.3284 20 12.5 20C11.6716 20 11 19.3284 11 18.5C11 17.6716 11.6716 17 12.5 17C13.3284 17 14 17.6716 14 18.5Z",
      fill: "currentColor"
    })]
  });
});
var EnterIcon = (0, import_react.forwardRef)(function EnterIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "enter",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6 14.5H19.5V7",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10 18.5L6 14.5L10 10.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var EnterRightIcon = (0, import_react.forwardRef)(function EnterRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "enter-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19 14.5H5.5V7",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15 18.5L19 14.5L15 10.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var EnvelopeIcon = (0, import_react.forwardRef)(function EnvelopeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "envelope",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M20.5 18.5H4.5V6.5H20.5V18.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M20.5 18.5L17.75 15.5L15 12.5M4.5 18.5L10 12.5M20.5 6.5L12.5 15L4.5 6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var EqualIcon = (0, import_react.forwardRef)(function EqualIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "equal",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 4.5H3.5V20.5H7.5",
      stroke: "currentColor",
      strokeWidth: 1.2
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M17.5 20.5L21.5 20.5L21.5 4.5L17.5 4.5",
      stroke: "currentColor",
      strokeWidth: 1.2
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9 10.5H16",
      stroke: "currentColor",
      strokeWidth: 1.2
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9 14.5H16",
      stroke: "currentColor",
      strokeWidth: 1.2
    })]
  });
});
var ErrorFilledIcon = (0, import_react.forwardRef)(function ErrorFilledIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "error-filled",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4 12.5C4 7.80558 7.80558 4 12.5 4C17.1944 4 21 7.80558 21 12.5C21 17.1944 17.1944 21 12.5 21C7.80558 21 4 17.1944 4 12.5ZM13 14.5V16H12V14.5H13ZM12 9V13H13V9H12Z",
      fill: "currentColor"
    })
  });
});
var ErrorOutlineIcon = (0, import_react.forwardRef)(function ErrorOutlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "error-outline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 16V14.5M12.5 9V13M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ExpandIcon = (0, import_react.forwardRef)(function ExpandIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "expand",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M14 6.5H18.5V11M11 18.5H6.5V14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 6.5L14 11M6.5 18.5L11 14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var EyeClosedIcon = (0, import_react.forwardRef)(function EyeClosedIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "eye-closed",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7 15.5L5.5 17.5M20.5 12.5C19.8612 13.5647 19.041 14.6294 18.0008 15.501M18.0008 15.501C16.5985 16.676 14.7965 17.5 12.5 17.5M18.0008 15.501L18 15.5M18.0008 15.501L19.5 17.5M12.5 17.5C8.5 17.5 6 15 4.5 12.5M12.5 17.5V20M15.5 17L16.5 19.5M9.5 17L8.5 19.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var EyeOpenIcon = (0, import_react.forwardRef)(function EyeOpenIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "eye-open",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.39999 12.5C9.39999 10.7879 10.7879 9.39999 12.5 9.39999C14.2121 9.39999 15.6 10.7879 15.6 12.5C15.6 14.2121 14.2121 15.6 12.5 15.6C10.7879 15.6 9.39999 14.2121 9.39999 12.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 7.5C8.5 7.5 6 10 4.5 12.5C6 15 8.5 17.5 12.5 17.5C16.5 17.5 19 15 20.5 12.5C19 10 16.5 7.5 12.5 7.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var FilterIcon = (0, import_react.forwardRef)(function FilterIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "filter",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11 12L6 7V6L19 6L19 7L14 12V17L11 19V12Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinecap: "square",
      strokeLinejoin: "round"
    })
  });
});
var FolderIcon = (0, import_react.forwardRef)(function FolderIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "folder",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 8.5H19.5V18.5H5.5V5.5H10.5L11.5 8.5ZM11.5 8.5H5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var GenerateIcon = (0, import_react.forwardRef)(function GenerateIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "generate",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M9 5.30423C6.33576 6.60253 4.5 9.33688 4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5V14.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16 11L12.5 14.5L9 11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var GroqIcon = (0, import_react.forwardRef)(function GroqIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "groq",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M13 13H21L13 21L13 13Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12 12V4L4 12H12Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12 13H4L12 21V13Z",
      fill: "currentColor"
    })]
  });
});
var HeartFilledIcon = (0, import_react.forwardRef)(function HeartFilledIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "heart-filled",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17 16C15.8 17.3235 12.5 20.5 12.5 20.5C12.5 20.5 9.2 17.3235 8 16C5.2 12.9118 4.5 11.7059 4.5 9.5C4.5 7.29412 6.1 5.5 8.5 5.5C10.5 5.5 11.7 6.82353 12.5 8.14706C13.3 6.82353 14.5 5.5 16.5 5.5C18.9 5.5 20.5 7.29412 20.5 9.5C20.5 11.7059 19.8 12.9118 17 16Z",
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var HeartIcon = (0, import_react.forwardRef)(function HeartIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "heart",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17 16C15.8 17.3235 12.5 20.5 12.5 20.5C12.5 20.5 9.2 17.3235 8 16C5.2 12.9118 4.5 11.7059 4.5 9.5C4.5 7.29412 6.1 5.5 8.5 5.5C10.5 5.5 11.7 6.82353 12.5 8.14706C13.3 6.82353 14.5 5.5 16.5 5.5C18.9 5.5 20.5 7.29412 20.5 9.5C20.5 11.7059 19.8 12.9118 17 16Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var HelpCircleIcon = (0, import_react.forwardRef)(function HelpCircleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "help-circle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 13C12.5 11 14 11.5 14 10C14 9.34375 13.5 8.5 12.5 8.5C11.5 8.5 11 9 10.5 9.5M12.5 16V14.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var HomeIcon = (0, import_react.forwardRef)(function HomeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "home",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 8.75V18.5H18.5V8.75M4.5 10L12.5 5L20.5 10M14.5 18.5V11.5H10.5V18.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var IceCreamIcon = (0, import_react.forwardRef)(function IceCreamIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "ice-cream",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 13.5L12.5 20.5L15.5 13.5M12.5 8.26389C11.9692 7.78885 11.2684 7.5 10.5 7.5C8.84315 7.5 7.5 8.84315 7.5 10.5C7.5 12.1569 8.84315 13.5 10.5 13.5C11.2684 13.5 11.9692 13.2111 12.5 12.7361M9.5 7.5C9.5 5.84315 10.8431 4.5 12.5 4.5C14.1569 4.5 15.5 5.84315 15.5 7.5M17.5 10.5C17.5 12.1569 16.1569 13.5 14.5 13.5C12.8431 13.5 11.5 12.1569 11.5 10.5C11.5 8.84315 12.8431 7.5 14.5 7.5C16.1569 7.5 17.5 8.84315 17.5 10.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ImageIcon = (0, import_react.forwardRef)(function ImageIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "image",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 15.5L8.79289 12.2071C9.18342 11.8166 9.81658 11.8166 10.2071 12.2071L12.8867 14.8867C13.2386 15.2386 13.7957 15.2782 14.1938 14.9796L15.1192 14.2856C15.3601 14.1049 15.6696 14.0424 15.9618 14.1154L19.5 15M5.5 6.5H19.5V18.5H5.5V6.5ZM15.5 10.5C15.5 11.0523 15.0523 11.5 14.5 11.5C13.9477 11.5 13.5 11.0523 13.5 10.5C13.5 9.94772 13.9477 9.5 14.5 9.5C15.0523 9.5 15.5 9.94772 15.5 10.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ImageRemoveIcon = (0, import_react.forwardRef)(function ImageRemoveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "image-remove",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 11V6.5H19.5V11M5.5 14V18.5H19.5V14M3 12.5H22",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ImagesIcon = (0, import_react.forwardRef)(function ImagesIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "images",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 7.5H20.5V19.5H6.5V17.5M4.5 14.5L7.79289 11.2071C8.18342 10.8166 8.81658 10.8166 9.20711 11.2071L11.8867 13.8867C12.2386 14.2386 12.7957 14.2782 13.1938 13.9796L14.1192 13.2856C14.3601 13.1049 14.6696 13.0424 14.9618 13.1154L18.5 14M4.5 5.5H18.5V17.5H4.5V5.5ZM14.5 9.5C14.5 10.0523 14.0523 10.5 13.5 10.5C12.9477 10.5 12.5 10.0523 12.5 9.5C12.5 8.94772 12.9477 8.5 13.5 8.5C14.0523 8.5 14.5 8.94772 14.5 9.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var InfoFilledIcon = (0, import_react.forwardRef)(function InfoFilledIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "info-filled",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21 12.5C21 17.1944 17.1944 21 12.5 21C7.80558 21 4 17.1944 4 12.5C4 7.80558 7.80558 4 12.5 4C17.1944 4 21 7.80558 21 12.5ZM12 10.5V9H13V10.5H12ZM13 16V12H12V16H13Z",
      fill: "currentColor"
    })
  });
});
var InfoOutlineIcon = (0, import_react.forwardRef)(function InfoOutlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "info-outline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 10.5V9M12.5 12V16M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var InlineElementIcon = (0, import_react.forwardRef)(function InlineElementIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "inline-element",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 5V20M19.5 5V20M8.5 6.5H16.5V18.5H8.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var InlineIcon = (0, import_react.forwardRef)(function InlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "inline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 6.5H19.5V18.5H12.5M12.5 6.5H5.5V18.5H12.5M12.5 6.5V18.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var InsertAboveIcon = (0, import_react.forwardRef)(function InsertAboveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "insert-above",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M14.5 10.5556L10.5 10.5556M12.5 12.5L12.5 8.5M18.5 5.5L6.5 5.5M18.5 19.5L6.5 19.5L6.5 15.5L18.5 15.5L18.5 19.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinecap: "square",
      strokeLinejoin: "round"
    })
  });
});
var InsertBelowIcon = (0, import_react.forwardRef)(function InsertBelowIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "insert-below",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 14.5H14.5M12.5 12.5V16.5M6.5 19.5H18.5M6.5 5.5H18.5V9.5H6.5V5.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinecap: "square",
      strokeLinejoin: "round"
    })
  });
});
var ItalicIcon = (0, import_react.forwardRef)(function ItalicIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "italic",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.43 18H11.7276L13.4551 9.86763H12.1576L10.43 18ZM13.3043 8.29849C13.8022 8.29849 14.2095 7.89112 14.2095 7.39322C14.2095 6.89532 13.8022 6.48795 13.3043 6.48795C12.8064 6.48795 12.399 6.89532 12.399 7.39322C12.399 7.89112 12.8064 8.29849 13.3043 8.29849Z",
      fill: "currentColor"
    })
  });
});
var JoystickIcon = (0, import_react.forwardRef)(function JoystickIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "joystick",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 16V14.5H15.5V16M13.5 10.5V14.5M11.5 10.5V14.5M15.5 7.5C15.5 9.15685 14.1569 10.5 12.5 10.5C10.8431 10.5 9.5 9.15685 9.5 7.5C9.5 5.84315 10.8431 4.5 12.5 4.5C14.1569 4.5 15.5 5.84315 15.5 7.5ZM18.5 19.5H6.5C5.94772 19.5 5.5 19.0523 5.5 18.5V17.5C5.5 16.9477 5.94772 16.5 6.5 16.5H18.5C19.0523 16.5 19.5 16.9477 19.5 17.5V18.5C19.5 19.0523 19.0523 19.5 18.5 19.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var JsonIcon = (0, import_react.forwardRef)(function JsonIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "json",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11 5.5H9.5C8.39543 5.5 7.5 6.39543 7.5 7.5V12.5M7.5 12.5H4M7.5 12.5V17.5C7.5 18.6046 8.39543 19.5 9.5 19.5H11M14 5.5H15.5C16.6046 5.5 17.5 6.39543 17.5 7.5V12.5M17.5 12.5H21M17.5 12.5V17.5C17.5 18.6046 16.6046 19.5 15.5 19.5H14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var LaunchIcon = (0, import_react.forwardRef)(function LaunchIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "launch",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12 7.5H6.5V18.5H17.5V13M19.5 5.5L10.5 14.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M14 5.5H19.5V11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var LeaveIcon = (0, import_react.forwardRef)(function LeaveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "leave",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M14.5 15V18.5H5.5V6.5H14.5V10M9 12.5H21.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M18 9L21.5 12.5L18 16",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var LemonIcon = (0, import_react.forwardRef)(function LemonIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "lemon",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.6569 10.3431L6.41422 14.5858C7.58579 15.7574 9.12132 16.3431 10.6569 16.3431M10.6569 10.3431L14.8995 6.1005C16.0711 7.27208 16.6569 8.80761 16.6569 10.3431M10.6569 10.3431L10.6569 16.3431M10.6569 10.3431L16.6569 10.3431M10.6569 10.3431L14.8995 14.5858M14.8995 14.5858C13.7279 15.7574 12.1924 16.3431 10.6569 16.3431M14.8995 14.5858C16.0711 13.4142 16.6569 11.8787 16.6569 10.3431M16.3137 4.68629C19.4379 7.81049 19.4379 12.8758 16.3137 16C13.1895 19.1242 8.12419 19.1242 5 16L16.3137 4.68629Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var LinkIcon = (0, import_react.forwardRef)(function LinkIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "link",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11 12.5L12.5 14C13.281 14.781 14.719 14.781 15.5 14L18.5 11C19.281 10.219 19.281 8.78105 18.5 8L18 7.5C17.2189 6.71895 15.781 6.71895 15 7.5L13 9.5M12 15.5L10 17.5C9.21895 18.281 7.78105 18.281 7 17.5L6.5 17C5.71895 16.219 5.71896 14.781 6.5 14L9.50001 11C10.2811 10.219 11.719 10.2189 12.5 11L14 12.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var LinkRemovedIcon = (0, import_react.forwardRef)(function LinkRemovedIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "link-removed",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 11C19.281 10.219 19.281 8.78108 18.5 8.00003L18 7.50003C17.2189 6.71898 15.781 6.71898 15 7.50003L13 9.50003M15.5 14C14.7189 14.7811 13.281 14.7811 12.5 14M6.5 14C5.71895 14.7811 5.71894 16.219 6.49999 17L6.99999 17.5C7.78104 18.2811 9.21894 18.2811 9.99999 17.5L12 15.5M12.5 11C11.719 10.219 10.281 10.219 9.5 11M3 12.5H22",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var LockIcon = (0, import_react.forwardRef)(function LockIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "lock",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15.5 11.5V8.5C15.5 6.5 14 5.5 12.5 5.5C11 5.5 9.5 6.5 9.5 8.5V11.5M7.5 11.5H17.5V19.5H7.5V11.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var LogoJsIcon = (0, import_react.forwardRef)(function LogoJsIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "logo-js",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M20 5H5V20H20V5ZM12.5254 16.1572C12.5254 17.4189 11.7742 18.1536 10.4792 18.1536C9.24243 18.1536 8.49121 17.4189 8.45801 16.2942V16.261H9.67407V16.2859C9.69897 16.7466 9.9729 17.0703 10.4626 17.0703C10.9939 17.0703 11.272 16.7507 11.272 16.1489V12.011H12.5254V16.1572ZM18.2893 16.2153C18.2893 17.4023 17.3679 18.1536 15.8738 18.1536C14.4419 18.1536 13.5371 17.4688 13.4666 16.4062L13.4624 16.3398H14.6702L14.6743 16.3813C14.72 16.8296 15.2056 17.1326 15.907 17.1326C16.5752 17.1326 17.0359 16.813 17.0359 16.3523V16.3481C17.0359 15.9539 16.7412 15.7339 15.9983 15.5803L15.3674 15.4517C14.1223 15.1985 13.5869 14.6174 13.5869 13.7085V13.7043C13.5869 12.592 14.5415 11.8574 15.8696 11.8574C17.2683 11.8574 18.0901 12.5962 18.1689 13.5964L18.1731 13.6504H16.9944L16.9861 13.6006C16.9155 13.1731 16.5005 12.8743 15.8696 12.8743C15.2512 12.8784 14.8403 13.1606 14.8403 13.6089V13.613C14.8403 14.0032 15.1309 14.2356 15.8364 14.3809L16.4714 14.5095C17.7373 14.771 18.2893 15.2773 18.2893 16.2112V16.2153Z",
      fill: "currentColor"
    })
  });
});
var LogoTsIcon = (0, import_react.forwardRef)(function LogoTsIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "logo-ts",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M20 5H5V20H20V5ZM11.0769 18H9.82349V13.0444H8.02637V12.011H12.874V13.0444H11.0769V18ZM18.2893 16.2153C18.2893 17.4023 17.3679 18.1536 15.8738 18.1536C14.4419 18.1536 13.5371 17.4688 13.4666 16.4062L13.4624 16.3398H14.6702L14.6743 16.3813C14.72 16.8296 15.2056 17.1326 15.907 17.1326C16.5752 17.1326 17.0359 16.813 17.0359 16.3523V16.3481C17.0359 15.9539 16.7412 15.7339 15.9983 15.5803L15.3674 15.4517C14.1223 15.1985 13.5869 14.6174 13.5869 13.7085V13.7043C13.5869 12.592 14.5415 11.8574 15.8696 11.8574C17.2683 11.8574 18.0901 12.5962 18.1689 13.5964L18.1731 13.6504H16.9944L16.9861 13.6006C16.9155 13.1731 16.5005 12.8743 15.8696 12.8743C15.2512 12.8784 14.8403 13.1606 14.8403 13.6089V13.613C14.8403 14.0032 15.1309 14.2356 15.8364 14.3809L16.4714 14.5095C17.7373 14.771 18.2893 15.2773 18.2893 16.2112V16.2153Z",
      fill: "currentColor"
    })
  });
});
var MasterDetailIcon = (0, import_react.forwardRef)(function MasterDetailIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "master-detail",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7 9.5H10M11.5 6.5V18.5M7 12.5H10M13 9.5H18M7 15.5H10M5.5 6.5H19.5V18.5H5.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var MenuIcon = (0, import_react.forwardRef)(function MenuIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "menu",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M6 7.5H19M6 17.5H19M6 12.5H19",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var MobileDeviceIcon = (0, import_react.forwardRef)(function MobileDeviceIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "mobile-device",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 6.5C7.5 5.39543 8.39543 4.5 9.5 4.5H15.5C16.6046 4.5 17.5 5.39543 17.5 6.5V18.5C17.5 19.6046 16.6046 20.5 15.5 20.5H9.5C8.39543 20.5 7.5 19.6046 7.5 18.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M13.5 17.5C13.5 18.0523 13.0523 18.5 12.5 18.5C11.9477 18.5 11.5 18.0523 11.5 17.5C11.5 16.9477 11.9477 16.5 12.5 16.5C13.0523 16.5 13.5 16.9477 13.5 17.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var MoonIcon = (0, import_react.forwardRef)(function MoonIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "moon",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M19.6065 16.1775C18.9417 16.387 18.234 16.5 17.5 16.5C13.634 16.5 10.5 13.366 10.5 9.5C10.5 7.54163 11.3042 5.77109 12.6004 4.50062C12.567 4.50021 12.5335 4.5 12.5 4.5C8.08172 4.5 4.5 8.08172 4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5C15.5924 20.5 18.275 18.7454 19.6065 16.1775Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var NumberIcon = (0, import_react.forwardRef)(function NumberIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "number",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21.0165 17.6336H3.83636V16.4336H21.0165V17.6336Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.09808 13.3967V7.508H5.74066L3.83636 8.78241V10.091L5.65277 8.88495H5.74066V13.3967H3.84125V14.5539H8.89984V13.3967H7.09808Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9.81781 9.63202V9.66132H11.1069V9.62714C11.1069 8.95331 11.5756 8.49432 12.2739 8.49432C12.9575 8.49432 13.4018 8.89471 13.4018 9.50507C13.4018 9.9787 13.1528 10.3498 12.1909 11.3117L9.89594 13.5822V14.5539H14.8618V13.3869H11.7807V13.299L13.1577 11.9855C14.3491 10.843 14.7543 10.1838 14.7543 9.41229C14.7543 8.19159 13.7729 7.36639 12.3178 7.36639C10.8383 7.36639 9.81781 8.28436 9.81781 9.63202Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M17.6694 11.4631H18.5092C19.3198 11.4631 19.8422 11.8683 19.8422 12.4982C19.8422 13.1183 19.3295 13.5139 18.5239 13.5139C17.767 13.5139 17.2592 13.133 17.2104 12.5324H15.9262C15.9897 13.8508 17.0248 14.6955 18.5629 14.6955C20.1401 14.6955 21.2192 13.841 21.2192 12.591C21.2192 11.6584 20.6528 11.0334 19.7006 10.9211V10.8332C20.4721 10.6769 20.9457 10.0666 20.9457 9.23651C20.9457 8.12323 19.9741 7.36639 18.5434 7.36639C17.0541 7.36639 16.1118 8.17694 16.0629 9.50018H17.2983C17.3422 8.88007 17.8061 8.48456 18.4995 8.48456C19.2075 8.48456 19.6567 8.85565 19.6567 9.44159C19.6567 10.0324 19.1977 10.4182 18.4946 10.4182H17.6694V11.4631Z",
      fill: "currentColor"
    })]
  });
});
var OkHandIcon = (0, import_react.forwardRef)(function OkHandIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "ok-hand",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15.9957 11.5C14.8197 10.912 11.9957 9 10.4957 9C8.9957 9 5.17825 11.7674 6 13C7 14.5 9.15134 11.7256 10.4957 12C11.8401 12.2744 13 13.5 13 14.5C13 15.5 11.8401 16.939 10.4957 16.5C9.15134 16.061 8.58665 14.3415 7.4957 14C6.21272 13.5984 5.05843 14.6168 5.5 15.5C5.94157 16.3832 7.10688 17.6006 8.4957 19C9.74229 20.2561 11.9957 21.5 14.9957 20C17.9957 18.5 18.5 16.2498 18.5 13C18.5 11.5 13.7332 5.36875 11.9957 4.5C10.9957 4 10 5 10.9957 6.5C11.614 7.43149 13.5 9.27705 14 10.3751M15.5 8C15.5 8 15.3707 7.5 14.9957 6C14.4957 4 15.9957 3.5 16.4957 4.5C17.1281 5.76491 18.2872 10.9147 18.4957 13",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var OlistIcon = (0, import_react.forwardRef)(function OlistIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "olist",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10 7.5H19M10 12.5H19M10 17.5H19M5 18.5H7.5L7 17.5L7.5 16.5H5M5 6.5H6.5V8.5M5 8.5H6.5M6.5 8.5H8M8 13.5H6L7 11.5H5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var OverageIcon = (0, import_react.forwardRef)(function OverageIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "overage",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M18.5 11V6.5H14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 18.5L9 16L12 13L18.5 6.5M3 13.5H22",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var PackageIcon = (0, import_react.forwardRef)(function PackageIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "package",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 13V22M12.5 13L4.5 8M12.5 13L20.5 8M8.5 5.5L16.5 10.5M4.5 8L12.5 3L20.5 8V17L12.5 22L4.5 17V8Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PanelLeftIcon = (0, import_react.forwardRef)(function PanelLeftIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "panel-left",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 6.5H19.5V18.5H10.5M10.5 6.5H5.5V18.5H10.5M10.5 6.5V18.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PanelRightIcon = (0, import_react.forwardRef)(function PanelRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "panel-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M14.5 6.5H19.5V18.5H14.5M14.5 6.5H5.5V18.5H14.5M14.5 6.5V18.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PauseIcon = (0, import_react.forwardRef)(function PauseIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "pause",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 7.5H8.5V17.5H10.5V7.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 7.5H14.5V17.5H16.5V7.5Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 7.5H8.5V17.5H10.5V7.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 7.5H14.5V17.5H16.5V7.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2
    })]
  });
});
var PinIcon = (0, import_react.forwardRef)(function PinIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "pin",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6.5 10.5C6.5 7 9 4.5 12.5 4.5C16 4.5 18.5 7 18.5 10.5C18.5 14 15.5 17.5 12.5 20.5C9.5 17.5 6.5 14 6.5 10.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M14 10.5C14 11.3284 13.3284 12 12.5 12C11.6716 12 11 11.3284 11 10.5C11 9.67157 11.6716 9 12.5 9C13.3284 9 14 9.67157 14 10.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var PinRemovedIcon = (0, import_react.forwardRef)(function PinRemovedIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "pin-removed",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7.39787 14C8.51075 16.2897 10.5054 18.5054 12.5 20.5C14.4946 18.5054 16.4892 16.2897 17.6021 14M6.52009 11C6.50681 10.8334 6.5 10.6667 6.5 10.5C6.5 7 9 4.5 12.5 4.5C16 4.5 18.5 7 18.5 10.5C18.5 10.6667 18.4932 10.8334 18.4799 11M3 12.5H22",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PlayIcon = (0, import_react.forwardRef)(function PlayIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "play",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 18.5V6.5L17.5 12.5L7.5 18.5Z",
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PlugIcon = (0, import_react.forwardRef)(function PlugIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "plug",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M13.25 8.5L16.75 5M16.25 11.5L19.75 8M9.25 15.5L5.25 19.5M7.75 14L9.75 12C8.25 10 8.75 9 9.75 8C10.15 7.6 11.25 6.5 11.25 6.5L18.25 13.5C18.25 13.5 17.3825 14.3675 16.75 15C15.75 16 14.75 16.5 12.75 15L10.75 17L7.75 14Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PresentationIcon = (0, import_react.forwardRef)(function PresentationIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "presentation",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 18H5.5V8.5H19.5V18H14.5M10.5 18L9 22M10.5 18H14.5M14.5 18L16 22M4.5 8.5H20.5V6.5H4.5V8.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var PublishIcon = (0, import_react.forwardRef)(function PublishIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "publish",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M4.99997 5.50006H20M12.5 9.00005V20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 14L12.5 9.00006L17.5 14",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var ReadOnlyIcon = (0, import_react.forwardRef)(function ReadOnlyIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "read-only",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15 7L18 10M10 12L7 15L6 19L10 18L13 15M12 10L17 5L20 8L15 13M19 19L5 5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var RedoIcon = (0, import_react.forwardRef)(function RedoIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "redo",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19 9.5L10 9.5C7.51472 9.5 5.5 11.5147 5.5 14C5.5 16.4853 7.51472 18.5 10 18.5H19",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15 13.5L19 9.5L15 5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var RefreshIcon = (0, import_react.forwardRef)(function RefreshIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "refresh",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19.5 13.5C19.5 17.366 16.366 20.5 12.5 20.5C8.63401 20.5 5.5 17.366 5.5 13.5C5.5 9.63401 8.63401 6.5 12.5 6.5H15.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11.5 10.5L15.5 6.5L11.5 2.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var RemoveCircleIcon = (0, import_react.forwardRef)(function RemoveCircleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "remove-circle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 12.4H17M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var RemoveIcon = (0, import_react.forwardRef)(function RemoveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "remove",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5 12.5H20",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ResetIcon = (0, import_react.forwardRef)(function ResetIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "reset",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M4.56189 13.5L4.14285 13.9294C4.25676 14.0406 4.41017 14.1019 4.56932 14.1C4.72847 14.098 4.88032 14.0329 4.99144 13.9189L4.56189 13.5ZM9.92427 15.9243L15.9243 9.92427L15.0757 9.07574L9.07574 15.0757L9.92427 15.9243ZM9.07574 9.92426L15.0757 15.9243L15.9243 15.0757L9.92426 9.07574L9.07574 9.92426ZM19.9 12.5C19.9 16.5869 16.5869 19.9 12.5 19.9V21.1C17.2496 21.1 21.1 17.2496 21.1 12.5H19.9ZM5.1 12.5C5.1 8.41309 8.41309 5.1 12.5 5.1V3.9C7.75035 3.9 3.9 7.75035 3.9 12.5H5.1ZM12.5 5.1C16.5869 5.1 19.9 8.41309 19.9 12.5H21.1C21.1 7.75035 17.2496 3.9 12.5 3.9V5.1ZM5.15728 13.4258C5.1195 13.1227 5.1 12.8138 5.1 12.5H3.9C3.9 12.8635 3.92259 13.2221 3.9665 13.5742L5.15728 13.4258ZM12.5 19.9C9.9571 19.9 7.71347 18.6179 6.38048 16.6621L5.38888 17.3379C6.93584 19.6076 9.54355 21.1 12.5 21.1V19.9ZM4.99144 13.9189L7.42955 11.4189L6.57045 10.5811L4.13235 13.0811L4.99144 13.9189ZM4.98094 13.0706L2.41905 10.5706L1.58095 11.4294L4.14285 13.9294L4.98094 13.0706Z",
      fill: "currentColor"
    })
  });
});
var RestoreIcon = (0, import_react.forwardRef)(function RestoreIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "restore",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M5.88468 17C7.32466 19.1128 9.75033 20.5 12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5C8.08172 4.5 4.5 8.08172 4.5 12.5V13.5M12.5 8V12.5L15.5 15.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7 11L4.5 13.5L2 11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var RetrieveIcon = (0, import_react.forwardRef)(function RetrieveIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "retrieve",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M16 14L12.5 10.5L9 14M5.5 7.5H19.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 10.5L12.5 17.5M19.5 7.5V19.5H5.5V7.5L7.5 5.5H17.5L19.5 7.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var RetryIcon = (0, import_react.forwardRef)(function RetryIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "retry",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19 9.5L10 9.5C7.51472 9.5 5.5 11.5147 5.5 14C5.5 16.4853 7.51472 18.5 10 18.5H19",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M15 13.5L19 9.5L15 5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var RevertIcon = (0, import_react.forwardRef)(function RevertIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "revert",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6 9.5L15 9.5C17.4853 9.5 19.5 11.5147 19.5 14C19.5 16.4853 17.4853 18.5 15 18.5H6",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10 13.5L6 9.5L10 5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var RobotIcon = (0, import_react.forwardRef)(function RobotIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "robot",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 15.5V17.5M12.5 8.5V6.5M12.5 6.5C13.3284 6.5 14 5.82843 14 5C14 4.17157 13.3284 3.5 12.5 3.5C11.6716 3.5 11 4.17157 11 5C11 5.82843 11.6716 6.5 12.5 6.5ZM20.5 20.5V19.5C20.5 18.3954 19.6046 17.5 18.5 17.5H6.5C5.39543 17.5 4.5 18.3954 4.5 19.5V20.5H20.5ZM11.5 12C11.5 12.5523 11.0523 13 10.5 13C9.94772 13 9.5 12.5523 9.5 12C9.5 11.4477 9.94772 11 10.5 11C11.0523 11 11.5 11.4477 11.5 12ZM15.5 12C15.5 12.5523 15.0523 13 14.5 13C13.9477 13 13.5 12.5523 13.5 12C13.5 11.4477 13.9477 11 14.5 11C15.0523 11 15.5 11.4477 15.5 12ZM8.5 15.5H16.5C17.6046 15.5 18.5 14.6046 18.5 13.5V10.5C18.5 9.39543 17.6046 8.5 16.5 8.5H8.5C7.39543 8.5 6.5 9.39543 6.5 10.5V13.5C6.5 14.6046 7.39543 15.5 8.5 15.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var RocketIcon = (0, import_react.forwardRef)(function RocketIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "rocket",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 20.5L15.5 14M11 9.49999L4.5 12.5M9 14C9 14 7.54688 14.9531 6.5 16C5.5 17 4.5 20.5 4.5 20.5C4.5 20.5 8 19.5 9 18.5C10 17.5 11 16 11 16M9 14C9 14 10.1 9.9 12.5 7.5C15.5 4.5 20.5 4.5 20.5 4.5C20.5 4.5 20.5 9.5 17.5 12.5C15.7492 14.2508 11 16 11 16L9 14ZM16.5 9.99999C16.5 10.8284 15.8284 11.5 15 11.5C14.1716 11.5 13.5 10.8284 13.5 9.99999C13.5 9.17157 14.1716 8.49999 15 8.49999C15.8284 8.49999 16.5 9.17157 16.5 9.99999Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SchemaIcon = (0, import_react.forwardRef)(function SchemaIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "schema",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 9.5V12.5M12.5 12.5H8.5V15.5M12.5 12.5H16.5V15.5M10.5 5.5H14.5V9.5H10.5V5.5ZM6.5 15.5H10.5V19.5H6.5V15.5ZM14.5 15.5H18.5V19.5H14.5V15.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SearchIcon = (0, import_react.forwardRef)(function SearchIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "search",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15.0355 15.0355L20 20M16.5 11.5C16.5 14.2614 14.2614 16.5 11.5 16.5C8.73858 16.5 6.5 14.2614 6.5 11.5C6.5 8.73858 8.73858 6.5 11.5 6.5C14.2614 6.5 16.5 8.73858 16.5 11.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SelectIcon = (0, import_react.forwardRef)(function SelectIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "select",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 15.5L12.5 19.5L8.5 15.5M8.5 9.5L12.5 5.5L16.5 9.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ShareIcon = (0, import_react.forwardRef)(function ShareIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "share",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M15 10.5H18.5V19.5H6.5L6.5 10.5H10M12.5 16V3.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M9 7L12.5 3.5L16 7",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var SortIcon = (0, import_react.forwardRef)(function SortIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "sort",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8.5 18.5V6M16.5 19V6.5M12 15L8.5 18.5L5 15M13 10L16.5 6.5L20 10",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SparkleIcon = (0, import_react.forwardRef)(function SparkleIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "sparkle",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 10.5C8.5 12.5 5 12.5 5 12.5C5 12.5 8.5 12.5 10.5 14.5C12.5 16.5 12.5 20 12.5 20C12.5 20 12.5 16.5 14.5 14.5C16.5 12.5 20 12.5 20 12.5C20 12.5 16.5 12.5 14.5 10.5C12.5 8.5 12.5 5 12.5 5C12.5 5 12.5 8.5 10.5 10.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SparklesIcon = (0, import_react.forwardRef)(function SparklesIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "sparkles",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M11 3.5V5M11 5V6.5M11 5H12.5M11 5H9.5M9.5 15C9.5 15 12.2308 14.7692 13.5 13.5C14.7692 12.2308 15 9.5 15 9.5C15 9.5 15.2308 12.2308 16.5 13.5C17.7692 14.7692 20.5 15 20.5 15C20.5 15 17.7692 15.2308 16.5 16.5C15.2308 17.7692 15 20.5 15 20.5C15 20.5 14.7692 17.7692 13.5 16.5C12.2308 15.2308 9.5 15 9.5 15ZM4.5 10C4.5 10 5.72308 9.87692 6.3 9.3C6.87692 8.72308 7 7.5 7 7.5C7 7.5 7.12308 8.72308 7.7 9.3C8.27692 9.87692 9.5 10 9.5 10C9.5 10 8.27692 10.1231 7.7 10.7C7.12308 11.2769 7 12.5 7 12.5C7 12.5 6.87692 11.2769 6.3 10.7C5.72308 10.1231 4.5 10 4.5 10Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
});
var SpinnerIcon = (0, import_react.forwardRef)(function SpinnerIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "spinner",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SplitHorizontalIcon = (0, import_react.forwardRef)(function SplitHorizontalIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "split-horizontal",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M19.5 10.5V20.5H5.5V10.5M19.5 10.5H5.5M19.5 10.5V4.5H5.5V10.5M12.5 13V15.5M12.5 18V15.5M12.5 15.5H15M12.5 15.5H10",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SplitVerticalIcon = (0, import_react.forwardRef)(function SplitVerticalIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "split-vertical",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10.5 5.5V19.5M13 12.5H15.5M18 12.5H15.5M15.5 12.5V15M15.5 12.5V10M4.5 5.5H20.5V19.5H4.5V5.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SquareIcon = (0, import_react.forwardRef)(function SquareIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "square",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("rect", {
      x: 5.5,
      y: 5.5,
      width: 14,
      height: 14,
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var StackCompactIcon = (0, import_react.forwardRef)(function StackCompactIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "stack-compact",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 15.5V18.5H19.5V15.5M5.5 15.5H19.5M5.5 15.5V9.5M19.5 15.5V9.5M5.5 9.5V6.5H19.5V9.5M5.5 9.5H19.5M5.5 12.5H19.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var StackIcon = (0, import_react.forwardRef)(function StackIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "stack",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 12.5H19.5M5.5 18.5H19.5V6.5H5.5V18.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var StarIcon = (0, import_react.forwardRef)(function StarIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "star",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M13 4L15.2747 9.8691L21.5595 10.2188L16.6806 14.1959L18.2901 20.2812L13 16.87L7.70993 20.2812L9.31941 14.1959L4.44049 10.2188L10.7253 9.8691L13 4Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var StopIcon = (0, import_react.forwardRef)(function StopIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "stop",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("rect", {
      x: 7.5,
      y: 7.5,
      width: 10,
      height: 10,
      fill: "currentColor",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var StrikethroughIcon = (0, import_react.forwardRef)(function StrikethroughIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "strikethrough",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.5656 7.73438C11.0656 7.73438 10.0734 8.48438 10.0734 9.625C10.0734 10.2317 10.3649 10.6613 11.0519 11H8.90358C8.71703 10.6199 8.62813 10.1801 8.62813 9.67188C8.62813 7.75781 10.2297 6.46094 12.6125 6.46094C14.7922 6.46094 16.4172 7.75781 16.5344 9.57812H15.1203C14.925 8.42188 13.9719 7.73438 12.5656 7.73438Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M12.4875 18.2656C10.0969 18.2656 8.44844 17 8.3 15.0547H9.72188C9.89375 16.2344 11.0188 16.9844 12.6203 16.9844C14.1359 16.9844 15.2531 16.1641 15.2531 15.0469C15.2531 14.6375 15.1255 14.292 14.8589 14H16.5912C16.6638 14.266 16.6984 14.5566 16.6984 14.875C16.6984 16.9453 15.0656 18.2656 12.4875 18.2656Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7 13.1H18V11.9H7V13.1Z",
      fill: "currentColor"
    })]
  });
});
var StringIcon = (0, import_react.forwardRef)(function StringIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "string",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M11.6748 15.5227H13.1855L9.87842 6.36304H8.34863L5.0415 15.5227H6.50146L7.3457 13.0916H10.8369L11.6748 15.5227ZM9.04053 8.02612H9.14844L10.4751 11.8982H7.70752L9.04053 8.02612Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16.8101 14.488C16.0674 14.488 15.5278 14.1262 15.5278 13.5042C15.5278 12.8948 15.9595 12.571 16.9116 12.5076L18.6001 12.3997V12.9773C18.6001 13.8342 17.8384 14.488 16.8101 14.488ZM16.4609 15.637C17.3687 15.637 18.124 15.2434 18.5366 14.5515H18.6445V15.5227H19.9585V10.8C19.9585 9.34009 18.981 8.47681 17.248 8.47681C15.6802 8.47681 14.563 9.23853 14.4233 10.4255H15.7437C15.896 9.93677 16.4229 9.65747 17.1846 9.65747C18.1177 9.65747 18.6001 10.0701 18.6001 10.8V11.3967L16.7275 11.5046C15.0835 11.6062 14.1567 12.3235 14.1567 13.5676C14.1567 14.8308 15.1279 15.637 16.4609 15.637Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M19.9585 18.637L5.0415 18.637V17.437L19.9585 17.437V18.637Z",
      fill: "currentColor"
    })]
  });
});
var SunIcon = (0, import_react.forwardRef)(function SunIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "sun",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M19 12.5H22M3 12.5H6M12.5 6V3M12.5 22V19M17.3891 7.61091L19.5104 5.48959M5.48959 19.5104L7.61091 17.3891M7.61091 7.61091L5.48959 5.48959M19.5104 19.5104L17.3891 17.3891M16 12.5C16 14.433 14.433 16 12.5 16C10.567 16 9 14.433 9 12.5C9 10.567 10.567 9 12.5 9C14.433 9 16 10.567 16 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var SyncIcon = (0, import_react.forwardRef)(function SyncIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "sync",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M13.5 4.5H12.5C8.08172 4.5 4.5 8.08172 4.5 12.5C4.5 15.6631 6.33576 18.3975 9 19.6958M11.5 20.5H12.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 9.33688 18.6642 6.60253 16 5.30423",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var TabletDeviceIcon = (0, import_react.forwardRef)(function TabletDeviceIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "tablet-device",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M5.5 5.5C5.5 4.94772 5.94772 4.5 6.5 4.5H18.5C19.0523 4.5 19.5 4.94772 19.5 5.5V19.5C19.5 20.0523 19.0523 20.5 18.5 20.5H6.5C5.94772 20.5 5.5 20.0523 5.5 19.5V5.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M13 18C13 18.2761 12.7761 18.5 12.5 18.5C12.2239 18.5 12 18.2761 12 18C12 17.7239 12.2239 17.5 12.5 17.5C12.7761 17.5 13 17.7239 13 18Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var TagIcon = (0, import_react.forwardRef)(function TagIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "tag",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 20L5 20L5 12.5L12.5 5L20 12.5L12.5 20Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M11 15.5C11 16.3284 10.3284 17 9.5 17C8.67157 17 8 16.3284 8 15.5C8 14.6716 8.67157 14 9.5 14C10.3284 14 11 14.6716 11 15.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var TagsIcon = (0, import_react.forwardRef)(function TagsIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "tags",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.1562 7.93179L13.9717 6.11633L20.3553 12.5L13.9717 18.8836L10.6855 18.8836M11.0283 18.8836L17.4119 12.5L11.0283 6.11633L4.64462 12.5L4.64462 18.8836L11.0283 18.8836ZM9.75153 15.0534C9.75153 15.7585 9.17992 16.3302 8.47481 16.3302C7.76969 16.3302 7.19808 15.7585 7.19808 15.0534C7.19808 14.3483 7.76969 13.7767 8.47481 13.7767C9.17992 13.7767 9.75153 14.3483 9.75153 15.0534Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TerminalIcon = (0, import_react.forwardRef)(function TerminalIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "terminal",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8.5 9.5L11.5 12.5L8.5 15.5M13 15.5H17M5.5 6.5H19.5V18.5H5.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TextIcon = (0, import_react.forwardRef)(function TextIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "text",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 9V6.5H17.5V9M12.5 18.5V6.5M10 18.5H15",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ThLargeIcon = (0, import_react.forwardRef)(function ThLargeIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "th-large",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 6.5V12.5M12.5 12.5V18.5M12.5 12.5H20.5M12.5 12.5H4.5M4.5 6.5H20.5V18.5H4.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ThListIcon = (0, import_react.forwardRef)(function ThListIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "th-list",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 6.5V10.5M9.5 10.5V14.5M9.5 10.5H20.5M9.5 10.5H4.5M9.5 14.5V18.5M9.5 14.5H20.5M9.5 14.5H4.5M4.5 6.5H20.5V18.5H4.5V6.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TiersIcon = (0, import_react.forwardRef)(function TiersIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "tiers",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M16.5 14.5L20.5 16.5L12.5 20.5L4.5 16.5L8.5 14.5M16.5 10.5L20.5 12.5L12.5 16.5L4.5 12.5L8.5 10.5M12.5 12.5L20.5 8.5L12.5 4.5L4.5 8.5L12.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var ToggleArrowRightIcon = (0, import_react.forwardRef)(function ToggleArrowRightIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "toggle-arrow-right",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M10 16.5V8.5L16 12.5L10 16.5Z",
      fill: "currentColor",
      stroke: "currentColor",
      strokeLinejoin: "round"
    })
  });
});
var TokenIcon = (0, import_react.forwardRef)(function TokenIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "token",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17.5711 12.5C17.5711 15.2614 15.3325 17.5 12.5711 17.5M7.57107 12.5C7.57107 9.73858 9.80964 7.5 12.5711 7.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TransferIcon = (0, import_react.forwardRef)(function TransferIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "transfer",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M19.5 16.5H6M5.5 8.5L19 8.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M16 13L19.5 16.5L16 20M9 12L5.5 8.5L9 5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var TranslateIcon = (0, import_react.forwardRef)(function TranslateIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "translate",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.4 5.4H4V6.6H13.2189C13.1612 6.78478 13.0895 6.99578 13.0025 7.22211C12.7032 8.00031 12.2402 8.91125 11.5757 9.57574L10 11.1515L9.42426 10.5757C8.72102 9.8725 8.25297 9.16987 7.96199 8.64611C7.81668 8.38455 7.71617 8.16874 7.65305 8.02146C7.62151 7.94787 7.59937 7.89154 7.5857 7.85534C7.57886 7.83725 7.57415 7.8242 7.57144 7.81657L7.56886 7.80922C7.56886 7.80922 7.56921 7.81026 7 8C6.43079 8.18974 6.43091 8.19009 6.43091 8.19009L6.43133 8.19135L6.43206 8.19351L6.4341 8.19948L6.44052 8.21786C6.44587 8.23292 6.45336 8.25357 6.46313 8.27942C6.48266 8.33112 6.5113 8.40369 6.55008 8.49416C6.62758 8.67501 6.74582 8.92795 6.91301 9.22889C7.24703 9.83013 7.77898 10.6275 8.57574 11.4243L9.15147 12L4.57964 16.5718L4.57655 16.5749L4.57577 16.5757L5.4243 17.4242L5.42688 17.4216L10.0368 12.8117L12.6159 14.9609L13.3841 14.0391L10.8888 11.9597L12.4243 10.4243C13.2598 9.58875 13.7968 8.49969 14.1225 7.65289C14.2818 7.23863 14.395 6.87072 14.4696 6.6H16V5.4H10.6V4H9.4V5.4ZM17.4405 10L21.553 19.7672H20.2509L19.1279 17.1H14.8721L13.7491 19.7672H12.447L16.5595 10H17.4405ZM15.3773 15.9H18.6227L17 12.0462L15.3773 15.9Z",
      fill: "currentColor"
    })
  });
});
var TrashIcon = (0, import_react.forwardRef)(function TrashIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "trash",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5 6.5H20M10 6.5V4.5C10 3.94772 10.4477 3.5 11 3.5H14C14.5523 3.5 15 3.94772 15 4.5V6.5M12.5 9V17M15.5 9L15 17M9.5 9L10 17M18.5 6.5L17.571 18.5767C17.5309 19.0977 17.0965 19.5 16.574 19.5H8.42603C7.90349 19.5 7.46905 19.0977 7.42898 18.5767L6.5 6.5H18.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TrendUpwardIcon = (0, import_react.forwardRef)(function TrendUpwardIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "trend-upward",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M4.5 18.5L11.5 10.5L13.5 14.5L20.5 6.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M20.5 11V6.5H16",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var TriangleOutlineIcon = (0, import_react.forwardRef)(function TriangleOutlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "triangle-outline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M20.5 18.5H4.5L12.5 5.5L20.5 18.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TrolleyIcon = (0, import_react.forwardRef)(function TrolleyIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "trolley",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 17.5L5.81763 6.26772C5.71013 5.81757 5.30779 5.5 4.84498 5.5H3M8 17.5H17M8 17.5C8.82843 17.5 9.5 18.1716 9.5 19C9.5 19.8284 8.82843 20.5 8 20.5C7.17157 20.5 6.5 19.8284 6.5 19C6.5 18.1716 7.17157 17.5 8 17.5ZM17 17.5C17.8284 17.5 18.5 18.1716 18.5 19C18.5 19.8284 17.8284 20.5 17 20.5C16.1716 20.5 15.5 19.8284 15.5 19C15.5 18.1716 16.1716 17.5 17 17.5ZM7.78357 14.5H17.5L19 7.5H6",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TruncateIcon = (0, import_react.forwardRef)(function TruncateIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "truncate",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M5 12.5H20M8.5 19.5L12.5 15.5L16.5 19.5M16.5 5.5L12.5 9.5L8.5 5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var TwitterIcon = (0, import_react.forwardRef)(function TwitterIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "twitter",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M18.8738 6.65751C18.1994 5.9447 17.2445 5.5 16.1857 5.5C14.1423 5.5 12.4857 7.15655 12.4857 9.2C12.4857 9.55263 12.535 9.89374 12.6272 10.2168C7.0826 9.56422 4.55703 6.02857 4.55703 6.02857C4.55703 6.02857 4.02846 9.2 6.14274 11.3143C5.08571 11.3143 4.55703 10.7857 4.55703 10.7857C4.55703 10.7857 4.55703 13.4286 7.19989 14.4857C6.67143 15.0143 5.61417 14.4857 5.61417 14.4857C5.97533 15.9303 7.45606 16.8562 8.82133 17.1358C6.67298 19.1676 3.5 18.7143 3.5 18.7143C5.14562 19.771 7.21334 20.3 9.31429 20.3C16.1214 20.3 19.8162 15.6315 19.8848 9.37762C20.8722 8.58943 22 7.08571 22 7.08571C22 7.08571 21.277 7.45458 19.6913 7.98315C21.277 6.92601 21.4714 5.5 21.4714 5.5C21.4714 5.5 20.4135 6.55789 18.8738 6.65751Z",
      fill: "currentColor"
    })
  });
});
var UlistIcon = (0, import_react.forwardRef)(function UlistIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "ulist",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M7.10153 17.5001C7.10153 17.8323 6.83221 18.1016 6.5 18.1016C6.16778 18.1016 5.89847 17.8323 5.89847 17.5001C5.89847 17.1678 6.16778 16.8985 6.5 16.8985C6.83221 16.8985 7.10153 17.1678 7.10153 17.5001Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.10153 7.5C7.10153 7.83221 6.83221 8.10153 6.5 8.10153C6.16778 8.10153 5.89847 7.83221 5.89847 7.5C5.89847 7.16778 6.16778 6.89847 6.5 6.89847C6.83221 6.89847 7.10153 7.16778 7.10153 7.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.10153 12.5C7.10153 12.8322 6.83221 13.1015 6.5 13.1015C6.16778 13.1015 5.89847 12.8322 5.89847 12.5C5.89847 12.1678 6.16778 11.8985 6.5 11.8985C6.83221 11.8985 7.10153 12.1678 7.10153 12.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10 7.5H19M10 17.5H19M10 12.5H19",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var UnderlineIcon = (0, import_react.forwardRef)(function UnderlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "underline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M9.52791 7.11407H8.17V14.2582C8.17 16.5817 9.79195 18.2565 12.4927 18.2565C15.1934 18.2565 16.8154 16.5817 16.8154 14.2582V7.11407H15.4574V14.1677C15.4574 15.8122 14.3787 17.0042 12.4927 17.0042C10.6067 17.0042 9.52791 15.8122 9.52791 14.1677V7.11407Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7 20.5H18",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var UndoIcon = (0, import_react.forwardRef)(function UndoIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "undo",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M6 9.5L15 9.5C17.4853 9.5 19.5 11.5147 19.5 14C19.5 16.4853 17.4853 18.5 15 18.5H6",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M10 13.5L6 9.5L10 5.5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var UnknownIcon = (0, import_react.forwardRef)(function UnknownIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "unknown",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 13C12.5 11 14 11.5 14 10C14 9.34375 13.5 8.5 12.5 8.5C11.5 8.5 11 9 10.5 9.5M12.5 16V14.5M5.5 5.5H19.5V19.5H5.5V5.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var UnlockIcon = (0, import_react.forwardRef)(function UnlockIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "unlock",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M9.5 11.5V8.5C9.5 6.5 8 5.5 6.5 5.5C5 5.5 3.5 6.5 3.5 8.5V11.5M7.5 11.5H17.5V19.5H7.5V11.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var UnpublishIcon = (0, import_react.forwardRef)(function UnpublishIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "unpublish",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M5 19.5H20M12.5 16V5",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M17.5 11L12.5 16L7.5 11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var UploadIcon = (0, import_react.forwardRef)(function UploadIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", {
    "data-sanity-icon": "upload",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: [(0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 6.00003V15.5M5.5 15.5H19.5V19.5H5.5V15.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime.jsx)("path", {
      d: "M7.5 11L12.5 6.00003L17.5 11",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })]
  });
});
var UserIcon = (0, import_react.forwardRef)(function UserIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "user",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 14.5C7 15 5.5 16 5.5 19.5H19.5C19.5 16 18.3416 15.1708 17 14.5C16 14 14 14 14 12.5C14 11 15 10.25 15 8.25C15 6.25 14 5.25 12.5 5.25C11 5.25 10 6.25 10 8.25C10 10.25 11 11 11 12.5C11 14 9 14 8 14.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var UsersIcon = (0, import_react.forwardRef)(function UsersIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "users",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17.5 18.5H21.5C21.5 15 20.8416 14.1708 19.5 13.5C18.5 13 16.5 12.5 16.5 11C16.5 9.5 17.5 9 17.5 7C17.5 5 16.5 4 15 4C13.6628 4 12.723 4.79472 12.5347 6.38415M4.5 20.5C4.5 17 5.5 16 6.5 15.5C7.5 15 9.5 14.5 9.5 13C9.5 11.5 8.5 11 8.5 9C8.5 7 9.5 6 11 6C12.5 6 13.5 7 13.5 9C13.5 11 12.5 11.5 12.5 13C12.5 14.5 14.5 15 15.5 15.5C16.8416 16.1708 17.5 17 17.5 20.5H4.5Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var WarningFilledIcon = (0, import_react.forwardRef)(function WarningFilledIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "warning-filled",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M14.741 5.12637C13.7357 3.41737 11.2643 3.41737 10.259 5.12637L3.7558 16.1818C2.73624 17.915 3.98595 20.1 5.99683 20.1H19.0032C21.014 20.1 22.2637 17.915 21.2442 16.1818L14.741 5.12637ZM11.9 9V13H13.1V9H11.9ZM13.1 16V14.5H11.9V16H13.1Z",
      fill: "currentColor"
    })
  });
});
var WarningOutlineIcon = (0, import_react.forwardRef)(function WarningOutlineIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "warning-outline",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M12.5 9V13M12.5 16V14.5M14.2239 5.43058L20.727 16.486C21.5113 17.8192 20.55 19.5 19.0032 19.5H5.99683C4.45 19.5 3.48869 17.8192 4.27297 16.486L10.7761 5.43058C11.5494 4.11596 13.4506 4.11596 14.2239 5.43058Z",
      stroke: "currentColor",
      strokeWidth: 1.2,
      strokeLinejoin: "round"
    })
  });
});
var WrenchIcon = (0, import_react.forwardRef)(function WrenchIcon2(props2, ref) {
  return (0, import_jsx_runtime.jsx)("svg", {
    "data-sanity-icon": "wrench",
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ref,
    ...props2,
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M17.0407 5.14624L17.4649 5.57051C17.6166 5.41887 17.6757 5.19783 17.6202 4.99071C17.5646 4.78359 17.4027 4.62189 17.1955 4.56656L17.0407 5.14624ZM14.4013 7.7856L13.977 7.36134C13.8288 7.50959 13.7687 7.72447 13.8185 7.92813L14.4013 7.7856ZM12.8778 6.26211L12.4535 5.83784V5.83784L12.8778 6.26211ZM11.8309 10.6568L12.2552 11.0811C12.4152 10.9211 12.4716 10.6847 12.401 10.4697L11.8309 10.6568ZM5.63925 16.8485L5.21498 16.4242H5.21498L5.63925 16.8485ZM5.63925 19.935L6.06351 19.5108H6.06351L5.63925 19.935ZM8.72581 19.935L9.15007 20.3593L8.72581 19.935ZM15.1184 13.5425L15.2301 12.953C15.0351 12.916 14.8344 12.9779 14.6941 13.1182L15.1184 13.5425ZM18.9718 12.3561L19.3961 12.7804L18.9718 12.3561ZM20.0877 8.19324L20.6674 8.03843C20.612 7.83125 20.4503 7.66934 20.2432 7.61375C20.0361 7.55816 19.815 7.61734 19.6634 7.76898L20.0877 8.19324ZM17.4483 10.8326L17.3058 11.4154C17.5094 11.4652 17.7243 11.4051 17.8726 11.2569L17.4483 10.8326ZM15 10.2339L14.4172 10.3764C14.4704 10.5938 14.6401 10.7635 14.8575 10.8167L15 10.2339ZM16.6164 4.72198L13.977 7.36134L14.8256 8.20986L17.4649 5.57051L16.6164 4.72198ZM13.3021 6.68637C14.2723 5.71612 15.6467 5.39501 16.8859 5.72593L17.1955 4.56656C15.5595 4.12966 13.7389 4.55245 12.4535 5.83784L13.3021 6.68637ZM12.401 10.4697C11.9779 9.18109 12.2794 7.70907 13.3021 6.68637L12.4535 5.83784C11.0985 7.19284 10.7021 9.14218 11.2608 10.844L12.401 10.4697ZM11.4066 10.2326L5.21498 16.4242L6.06351 17.2727L12.2552 11.0811L11.4066 10.2326ZM5.21498 16.4242C4.12834 17.5109 4.12834 19.2727 5.21498 20.3593L6.06351 19.5108C5.4455 18.8928 5.4455 17.8908 6.06351 17.2727L5.21498 16.4242ZM5.21498 20.3593C6.30163 21.446 8.06343 21.446 9.15007 20.3593L8.30155 19.5108C7.68353 20.1288 6.68153 20.1288 6.06351 19.5108L5.21498 20.3593ZM9.15007 20.3593L15.5426 13.9668L14.6941 13.1182L8.30155 19.5108L9.15007 20.3593ZM18.5475 11.9318C17.6463 12.8331 16.3968 13.1742 15.2301 12.953L15.0066 14.132C16.5466 14.4239 18.2023 13.9741 19.3961 12.7804L18.5475 11.9318ZM19.508 8.34804C19.8389 9.58721 19.5178 10.9616 18.5475 11.9318L19.3961 12.7804C20.6815 11.495 21.1043 9.67445 20.6674 8.03843L19.508 8.34804ZM17.8726 11.2569L20.5119 8.6175L19.6634 7.76898L17.024 10.4083L17.8726 11.2569ZM14.8575 10.8167L17.3058 11.4154L17.5908 10.2498L15.1426 9.65106L14.8575 10.8167ZM13.8185 7.92813L14.4172 10.3764L15.5829 10.0914L14.9841 7.64307L13.8185 7.92813Z",
      fill: "currentColor"
    })
  });
});
var icons = {
  "access-denied": AccessDeniedIcon,
  activity: ActivityIcon,
  "add-circle": AddCircleIcon,
  add: AddIcon,
  api: ApiIcon,
  archive: ArchiveIcon,
  "arrow-down": ArrowDownIcon,
  "arrow-left": ArrowLeftIcon,
  "arrow-right": ArrowRightIcon,
  "arrow-top-right": ArrowTopRightIcon,
  "arrow-up": ArrowUpIcon,
  "bar-chart": BarChartIcon,
  basket: BasketIcon,
  bell: BellIcon,
  bill: BillIcon,
  "binary-document": BinaryDocumentIcon,
  "block-content": BlockContentIcon,
  "block-element": BlockElementIcon,
  blockquote: BlockquoteIcon,
  bold: BoldIcon,
  bolt: BoltIcon,
  book: BookIcon,
  bottle: BottleIcon,
  "bulb-filled": BulbFilledIcon,
  "bulb-outline": BulbOutlineIcon,
  calendar: CalendarIcon,
  case: CaseIcon,
  "chart-upward": ChartUpwardIcon,
  "checkmark-circle": CheckmarkCircleIcon,
  checkmark: CheckmarkIcon,
  "chevron-down": ChevronDownIcon,
  "chevron-left": ChevronLeftIcon,
  "chevron-right": ChevronRightIcon,
  "chevron-up": ChevronUpIcon,
  circle: CircleIcon,
  clipboard: ClipboardIcon,
  "clipboard-image": ClipboardImageIcon,
  clock: ClockIcon,
  "close-circle": CloseCircleIcon,
  close: CloseIcon,
  "code-block": CodeBlockIcon,
  code: CodeIcon,
  cog: CogIcon,
  collapse: CollapseIcon,
  "color-wheel": ColorWheelIcon,
  comment: CommentIcon,
  component: ComponentIcon,
  compose: ComposeIcon,
  controls: ControlsIcon,
  copy: CopyIcon,
  "credit-card": CreditCardIcon,
  crop: CropIcon,
  cube: CubeIcon,
  dashboard: DashboardIcon,
  database: DatabaseIcon,
  desktop: DesktopIcon,
  document: DocumentIcon,
  "document-pdf": DocumentPdfIcon,
  "document-remove": DocumentRemoveIcon,
  "document-sheet": DocumentSheetIcon,
  "document-text": DocumentTextIcon,
  "document-video": DocumentVideoIcon,
  "document-word": DocumentWordIcon,
  "document-zip": DocumentZipIcon,
  documents: DocumentsIcon,
  dot: DotIcon,
  "double-chevron-down": DoubleChevronDownIcon,
  "double-chevron-left": DoubleChevronLeftIcon,
  "double-chevron-right": DoubleChevronRightIcon,
  "double-chevron-up": DoubleChevronUpIcon,
  download: DownloadIcon,
  "drag-handle": DragHandleIcon,
  drop: DropIcon,
  "earth-americas": EarthAmericasIcon,
  "earth-globe": EarthGlobeIcon,
  edit: EditIcon,
  "ellipsis-horizontal": EllipsisHorizontalIcon,
  "ellipsis-vertical": EllipsisVerticalIcon,
  enter: EnterIcon,
  "enter-right": EnterRightIcon,
  envelope: EnvelopeIcon,
  equal: EqualIcon,
  "error-filled": ErrorFilledIcon,
  "error-outline": ErrorOutlineIcon,
  expand: ExpandIcon,
  "eye-closed": EyeClosedIcon,
  "eye-open": EyeOpenIcon,
  filter: FilterIcon,
  folder: FolderIcon,
  generate: GenerateIcon,
  groq: GroqIcon,
  "heart-filled": HeartFilledIcon,
  heart: HeartIcon,
  "help-circle": HelpCircleIcon,
  home: HomeIcon,
  "ice-cream": IceCreamIcon,
  image: ImageIcon,
  "image-remove": ImageRemoveIcon,
  images: ImagesIcon,
  "info-filled": InfoFilledIcon,
  "info-outline": InfoOutlineIcon,
  "inline-element": InlineElementIcon,
  inline: InlineIcon,
  "insert-above": InsertAboveIcon,
  "insert-below": InsertBelowIcon,
  italic: ItalicIcon,
  joystick: JoystickIcon,
  json: JsonIcon,
  launch: LaunchIcon,
  leave: LeaveIcon,
  lemon: LemonIcon,
  link: LinkIcon,
  "link-removed": LinkRemovedIcon,
  lock: LockIcon,
  "logo-js": LogoJsIcon,
  "logo-ts": LogoTsIcon,
  "master-detail": MasterDetailIcon,
  menu: MenuIcon,
  "mobile-device": MobileDeviceIcon,
  moon: MoonIcon,
  number: NumberIcon,
  "ok-hand": OkHandIcon,
  olist: OlistIcon,
  overage: OverageIcon,
  package: PackageIcon,
  "panel-left": PanelLeftIcon,
  "panel-right": PanelRightIcon,
  pause: PauseIcon,
  pin: PinIcon,
  "pin-removed": PinRemovedIcon,
  play: PlayIcon,
  plug: PlugIcon,
  presentation: PresentationIcon,
  publish: PublishIcon,
  "read-only": ReadOnlyIcon,
  redo: RedoIcon,
  refresh: RefreshIcon,
  "remove-circle": RemoveCircleIcon,
  remove: RemoveIcon,
  reset: ResetIcon,
  restore: RestoreIcon,
  retrieve: RetrieveIcon,
  retry: RetryIcon,
  revert: RevertIcon,
  robot: RobotIcon,
  rocket: RocketIcon,
  schema: SchemaIcon,
  search: SearchIcon,
  select: SelectIcon,
  share: ShareIcon,
  sort: SortIcon,
  sparkle: SparkleIcon,
  sparkles: SparklesIcon,
  spinner: SpinnerIcon,
  "split-horizontal": SplitHorizontalIcon,
  "split-vertical": SplitVerticalIcon,
  square: SquareIcon,
  "stack-compact": StackCompactIcon,
  stack: StackIcon,
  star: StarIcon,
  stop: StopIcon,
  strikethrough: StrikethroughIcon,
  string: StringIcon,
  sun: SunIcon,
  sync: SyncIcon,
  "tablet-device": TabletDeviceIcon,
  tag: TagIcon,
  tags: TagsIcon,
  terminal: TerminalIcon,
  text: TextIcon,
  "th-large": ThLargeIcon,
  "th-list": ThListIcon,
  tiers: TiersIcon,
  "toggle-arrow-right": ToggleArrowRightIcon,
  token: TokenIcon,
  transfer: TransferIcon,
  translate: TranslateIcon,
  trash: TrashIcon,
  "trend-upward": TrendUpwardIcon,
  "triangle-outline": TriangleOutlineIcon,
  trolley: TrolleyIcon,
  truncate: TruncateIcon,
  twitter: TwitterIcon,
  ulist: UlistIcon,
  underline: UnderlineIcon,
  undo: UndoIcon,
  unknown: UnknownIcon,
  unlock: UnlockIcon,
  unpublish: UnpublishIcon,
  upload: UploadIcon,
  user: UserIcon,
  users: UsersIcon,
  "warning-filled": WarningFilledIcon,
  "warning-outline": WarningOutlineIcon,
  wrench: WrenchIcon
};
var Icon = (0, import_react.forwardRef)(function Icon2(props2, ref) {
  const {
    symbol,
    ...restProps
  } = props2;
  const iconComponent = icons[symbol];
  if (!iconComponent) {
    return null;
  }
  return (0, import_react.createElement)(iconComponent, {
    ...restProps,
    ref
  });
});

// node_modules/@sanity/ui/dist/index.esm.js
var import_react_refractor = __toESM(require_Refractor());
init_floating_ui_react_dom_esm();
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/framer-motion/dist/es/motion/index.mjs
var React = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react2 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react2.createContext)({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never"
});

// node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react3 = __toESM(require_react(), 1);
var MotionContext = (0, import_react3.createContext)({});

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react7 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react4 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react4.createContext)(null);

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react5 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser = typeof document !== "undefined";

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser ? import_react5.useLayoutEffect : import_react5.useEffect;

// node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react6 = __toESM(require_react(), 1);
var LazyContext = (0, import_react6.createContext)({ strict: false });

// node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

// node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
var optimizedAppearDataId = "framerAppearId";
var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component3, visualState, props2, createVisualElement2) {
  const { visualElement: parent } = (0, import_react7.useContext)(MotionContext);
  const lazyContext = (0, import_react7.useContext)(LazyContext);
  const presenceContext = (0, import_react7.useContext)(PresenceContext);
  const reducedMotionConfig = (0, import_react7.useContext)(MotionConfigContext).reducedMotion;
  const visualElementRef = (0, import_react7.useRef)();
  createVisualElement2 = createVisualElement2 || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement2) {
    visualElementRef.current = createVisualElement2(Component3, {
      visualState,
      parent,
      props: props2,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  (0, import_react7.useInsertionEffect)(() => {
    visualElement && visualElement.update(props2, presenceContext);
  });
  const wantsHandoff = (0, import_react7.useRef)(Boolean(props2[optimizedAppearDataAttribute] && !window.HandoffComplete));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    visualElement.render();
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  (0, import_react7.useEffect)(() => {
    if (!visualElement)
      return;
    visualElement.updateFeatures();
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      wantsHandoff.current = false;
      window.HandoffComplete = true;
    }
  });
  return visualElement;
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react8.useCallback)(
    (instance2) => {
      instance2 && visualState.mount && visualState.mount(instance2);
      if (visualElement) {
        instance2 ? visualElement.mount(instance2) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance2);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance2;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}

// node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v) {
  return typeof v === "object" && typeof v.start === "function";
}

// node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
var variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
var variantProps = ["initial", ...variantPriorityOrder];

// node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
function isControllingVariants(props2) {
  return isAnimationControls(props2.animate) || variantProps.some((name) => isVariantLabel(props2[name]));
}
function isVariantNode(props2) {
  return Boolean(isControllingVariants(props2) || props2.variants);
}

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props2, context) {
  if (isControllingVariants(props2)) {
    const { initial, animate: animate2 } = props2;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props2.inherit !== false ? context : {};
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props2) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props2, (0, import_react9.useContext)(MotionContext));
  return (0, import_react9.useMemo)(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
var featureDefinitions = {};
for (const key2 in featureProps) {
  featureDefinitions[key2] = {
    isEnabled: (props2) => featureProps[key2].some((name) => !!props2[name])
  };
}

// node_modules/framer-motion/dist/es/motion/features/load-features.mjs
function loadFeatures(features2) {
  for (const key2 in features2) {
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features2[key2]
    };
  }
}

// node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react10 = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react10.createContext)({});

// node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react11 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react11.createContext)({});

// node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
var motionComponentSymbol = Symbol.for("motionComponentSymbol");

// node_modules/framer-motion/dist/es/motion/index.mjs
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement: createVisualElement2, useRender, useVisualState: useVisualState2, Component: Component3 }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props2, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...(0, import_react12.useContext)(MotionConfigContext),
      ...props2,
      layoutId: useLayoutId(props2)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props2);
    const visualState = useVisualState2(props2, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement2);
      const initialLayoutGroupConfig = (0, import_react12.useContext)(SwitchLayoutGroupContext);
      const isStrict = (0, import_react12.useContext)(LazyContext).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig
        );
      }
    }
    return React.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? React.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component3, props2, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  const ForwardRefComponent = (0, import_react12.forwardRef)(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component3;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = (0, import_react12.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}

// node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
function createMotionProxy(createConfig2) {
  function custom(Component3, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig2(Component3, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => {
      if (!componentCache.has(key2)) {
        componentCache.set(key2, custom(key2));
      }
      return componentCache.get(key2);
    }
  });
}

// node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component3) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component3 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component3.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component3) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component3)
  ) {
    return true;
  }
  return false;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
var import_react15 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
var import_react13 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}

// node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
var transformProps = new Set(transformPropOrder);

// node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}

// node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = (value) => Boolean(value && value.getVelocity);

// node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var numTransforms = transformPropOrder.length;
function buildTransform(transform2, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  for (let i = 0; i < numTransforms; i++) {
    const key2 = transformPropOrder[i];
    if (transform2[key2] !== void 0) {
      const transformName = translateAlias[key2] || key2;
      transformString += `${transformName}(${transform2[key2]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform2.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
var checkStringStartsWith = (token) => (key2) => typeof key2 === "string" && key2.startsWith(token);
var isCSSVariableName = checkStringStartsWith("--");
var isCSSVariableToken = checkStringStartsWith("var(--");
var cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;

// node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/framer-motion/dist/es/utils/clamp.mjs
var clamp = (min2, max2, v) => Math.min(Math.max(v, min2), max2);

// node_modules/framer-motion/dist/es/value/types/numbers/index.mjs
var number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
var alpha = {
  ...number,
  transform: (v) => clamp(0, 1, v)
};
var scale = {
  ...number,
  default: 1
};

// node_modules/framer-motion/dist/es/value/types/utils.mjs
var sanitize = (v) => Math.round(v * 1e5) / 1e5;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(v) {
  return typeof v === "string";
}

// node_modules/framer-motion/dist/es/value/types/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v) => isString(v) && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
};

// node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
var int = {
  ...number,
  transform: Math.round
};

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style, vars, transform: transform2, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (isCSSVariableName(key2)) {
      vars[key2] = value;
      continue;
    }
    const valueType = numberValueTypes[key2];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key2)) {
      hasTransform2 = true;
      transform2[key2] = valueAsType;
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key2.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin[key2] = valueAsType;
    } else {
      style[key2] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source, props2) {
  for (const key2 in source) {
    if (!isMotionValue(source[key2]) && !isForcedMotionValue(key2, props2)) {
      target[key2] = source[key2];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return (0, import_react13.useMemo)(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props2, visualState, isStatic) {
  const styleProp = props2.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props2);
  Object.assign(style, useInitialMotionValues(props2, visualState, isStatic));
  return props2.transformValues ? props2.transformValues(style) : style;
}
function useHTMLProps(props2, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props2, visualState, isStatic);
  if (props2.drag && props2.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props2.drag === true ? "none" : `pan-${props2.drag === "x" ? "y" : "x"}`;
  }
  if (props2.tabIndex === void 0 && (props2.onTap || props2.onTapStart || props2.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}

// node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || validMotionProps.has(key2);
}

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2);
}
try {
  loadExternalIsValidProp((init_is_prop_valid_browser_esm(), __toCommonJS(is_prop_valid_browser_esm_exports)).default);
} catch (_a4) {
}
function filterProps(props2, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props2) {
    if (key2 === "values" && typeof props2.values === "object")
      continue;
    if (shouldForward(key2) || forwardMotionProps === true && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props2["draggable"] && key2.startsWith("onDrag")) {
      filteredProps[key2] = props2[key2];
    }
  }
  return filteredProps;
}

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
var import_react14 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin, offset2, size2) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}

// node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});

// node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props2, visualState, _isStatic, Component3) {
  const visualProps = (0, import_react14.useMemo)(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component3), props2.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props2.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props2.style, props2);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component3, props2, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props2, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props2, typeof Component3 === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props2;
    const renderedChildren = (0, import_react15.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react15.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}

// node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars) {
    element.style.setProperty(key2, vars[key2]);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key2) ? camelToDash(key2) : key2, renderState.attrs[key2]);
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props2, prevProps) {
  const { style } = props2;
  const newValues = {};
  for (const key2 in style) {
    if (isMotionValue(style[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props2)) {
      newValues[key2] = style[key2];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props2, prevProps) {
  const newValues = scrapeMotionValuesFromProps(props2, prevProps);
  for (const key2 in props2) {
    if (isMotionValue(props2[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props2[key2];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react17 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
function resolveVariantFromProps(props2, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props2.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props2.variants && props2.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props2.custom, currentValues, currentVelocity);
  }
  return definition;
}

// node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react16 = __toESM(require_react(), 1);
function useConstant(init2) {
  const ref = (0, import_react16.useRef)(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}

// node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = (v) => {
  return Array.isArray(v);
};

// node_modules/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = (v) => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = (v) => {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props2, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props2, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance2) => onMount(props2, instance2, state);
  }
  return state;
}
var makeUseVisualState = (config) => (props2, isStatic) => {
  const context = (0, import_react17.useContext)(MotionContext);
  const presenceContext = (0, import_react17.useContext)(PresenceContext);
  const make3 = () => makeState(config, props2, context, presenceContext);
  return isStatic ? make3() : useConstant(make3);
};
function makeLatestValues(props2, context, presenceContext, scrapeMotionValues) {
  const values2 = {};
  const motionValues = scrapeMotionValues(props2, {});
  for (const key2 in motionValues) {
    values2[key2] = resolveMotionValue(motionValues[key2]);
  }
  let { initial, animate: animate2 } = props2;
  const isControllingVariants$1 = isControllingVariants(props2);
  const isVariantNode$1 = isVariantNode(props2);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props2.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate2 === void 0)
      animate2 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props2, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key2 in target) {
        let valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values2[key2] = valueTarget;
        }
      }
      for (const key2 in transitionEnd)
        values2[key2] = transitionEnd[key2];
    });
  }
  return values2;
}

// node_modules/framer-motion/dist/es/utils/noop.mjs
var noop = (any) => any;

// node_modules/framer-motion/dist/es/frameloop/render-step.mjs
var Queue = class {
  constructor() {
    this.order = [];
    this.scheduled = /* @__PURE__ */ new Set();
  }
  add(process4) {
    if (!this.scheduled.has(process4)) {
      this.scheduled.add(process4);
      this.order.push(process4);
      return true;
    }
  }
  remove(process4) {
    const index = this.order.indexOf(process4);
    if (index !== -1) {
      this.order.splice(index, 1);
      this.scheduled.delete(process4);
    }
  }
  clear() {
    this.order.length = 0;
    this.scheduled.clear();
  }
};
function createRenderStep(runNextFrame) {
  let thisFrame = new Queue();
  let nextFrame = new Queue();
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive2 = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive2)
        toKeepAlive.add(callback);
      if (queue.add(callback) && addToCurrentFrame && isProcessing) {
        numToRun = thisFrame.order.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.remove(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      nextFrame.clear();
      numToRun = thisFrame.order.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = thisFrame.order[i];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}

// node_modules/framer-motion/dist/es/frameloop/batcher.mjs
var stepsOrder = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const steps2 = stepsOrder.reduce((acc, key2) => {
    acc[key2] = createRenderStep(() => runNextFrame = true);
    return acc;
  }, {});
  const processStep = (stepId) => steps2[stepId].process(state);
  const processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    stepsOrder.forEach(processStep);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key2) => {
    const step = steps2[key2];
    acc[key2] = (process4, keepAlive2 = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process4, keepAlive2, immediate);
    };
    return acc;
  }, {});
  const cancel = (process4) => stepsOrder.forEach((key2) => steps2[key2].cancel(process4));
  return { schedule, cancel, state, steps: steps2 };
}

// node_modules/framer-motion/dist/es/frameloop/frame.mjs
var { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: (props2, instance2, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance2.getBBox === "function" ? instance2.getBBox() : instance2.getBoundingClientRect();
        } catch (e2) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame.render(() => {
        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance2.tagName), props2.transformTemplate);
        renderSVG(instance2, renderState);
      });
    }
  })
};

// node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
function createDomMotionConfig(Component3, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement2) {
  const baseConfig = isSVGComponent(Component3) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement: createVisualElement2,
    Component: Component3
  };
}

// node_modules/framer-motion/dist/es/events/add-dom-event.mjs
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}

// node_modules/framer-motion/dist/es/events/utils/is-primary-pointer.mjs
var isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};

// node_modules/framer-motion/dist/es/events/event-info.mjs
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
var addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};

// node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}

// node_modules/framer-motion/dist/es/utils/pipe.mjs
var combineFunctions = (a, b) => (v) => b(a(v));
var pipe = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/framer-motion/dist/es/motion/features/Feature.mjs
var Feature = class {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
};

// node_modules/framer-motion/dist/es/gestures/hover.mjs
function addHoverEvent(node, isActive) {
  const eventName = "pointer" + (isActive ? "enter" : "leave");
  const callbackName = "onHover" + (isActive ? "Start" : "End");
  const handleEvent = (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    const props2 = node.getProps();
    if (node.animationState && props2.whileHover) {
      node.animationState.setActive("whileHover", isActive);
    }
    if (props2[callbackName]) {
      frame.update(() => props2[callbackName](event, info));
    }
  };
  return addPointerEvent(node.current, eventName, handleEvent, {
    passive: !node.getProps()[callbackName]
  });
}
var HoverGesture = class extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/gestures/focus.mjs
var FocusGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/framer-motion/dist/es/gestures/press.mjs
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
var PressGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop;
    this.removeEndListeners = noop;
    this.removeAccessibleListeners = noop;
    this.startPointerPress = (startEvent, startInfo) => {
      this.removeEndListeners();
      if (this.isPressing)
        return;
      const props2 = this.node.getProps();
      const endPointerPress = (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel } = this.node.getProps();
        frame.update(() => {
          !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
        });
      };
      const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props2.onTap || props2["onPointerUp"]) });
      const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props2.onTapCancel || props2["onPointerCancel"]) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.update(() => onTap(event, info));
            }
          });
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      };
      const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
      const handleBlur = () => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      };
      const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.update(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props2 = this.node.getProps();
    if (props2.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.update(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props2 = this.node.getProps();
    const removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props2.onTapStart || props2["onPointerStart"]) });
    const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
};

// node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
var fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key2 = JSON.stringify(options);
  if (!rootObservers[key2]) {
    rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}

// node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
var thresholdNames = {
  some: 0,
  all: 1
};
var InViewFeature = class extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once: once2 } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once2 && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props: props2, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props2, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
};
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};

// node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}

// node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key2) => current[key2] = value.get());
  return current;
}
function getVelocity(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key2) => velocity[key2] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom) {
  const props2 = visualElement.getProps();
  return resolveVariantFromProps(props2, definition, custom !== void 0 ? custom : props2.custom, getCurrent(visualElement), getVelocity(visualElement));
}

// node_modules/framer-motion/dist/es/utils/errors.mjs
var warning = noop;
var invariant = noop;
if (true) {
  warning = (check, message) => {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = (check, message) => {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/framer-motion/dist/es/utils/time-conversion.mjs
var secondsToMilliseconds = (seconds) => seconds * 1e3;
var millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;

// node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
var instantAnimationState = {
  current: false
};

// node_modules/framer-motion/dist/es/easing/utils/is-bezier-definition.mjs
var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

// node_modules/framer-motion/dist/es/animation/animators/waapi/easing.mjs
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
var supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}

// node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs
function animateStyle(element, valueName, keyframes2, { delay: delay3 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay3,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}

// node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index];
}

// node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs
var calcBezier = (t3, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t3 + (3 * a2 - 6 * a1)) * t3 + 3 * a1) * t3;
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t3) => t3 === 0 || t3 === 1 ? t3 : calcBezier(getTForX(t3), mY1, mY2);
}

// node_modules/framer-motion/dist/es/easing/ease.mjs
var easeIn = cubicBezier(0.42, 0, 1, 1);
var easeOut = cubicBezier(0, 0, 0.58, 1);
var easeInOut = cubicBezier(0.42, 0, 0.58, 1);

// node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs
var isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};

// node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs
var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

// node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs
var reverseEasing = (easing) => (p) => 1 - easing(1 - p);

// node_modules/framer-motion/dist/es/easing/circ.mjs
var circIn = (p) => 1 - Math.sin(Math.acos(p));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circIn);

// node_modules/framer-motion/dist/es/easing/back.mjs
var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
var backIn = reverseEasing(backOut);
var backInOut = mirrorEasing(backIn);

// node_modules/framer-motion/dist/es/easing/anticipate.mjs
var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

// node_modules/framer-motion/dist/es/easing/utils/map.mjs
var easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
var easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
};

// node_modules/framer-motion/dist/es/value/types/color/utils.mjs
var isColorString = (type, testProp) => (v) => {
  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
};
var splitColor = (aName, bName, cName) => (v) => {
  if (!isString(v))
    return v;
  const [a, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/framer-motion/dist/es/value/types/color/rgba.mjs
var clampRgbUnit = (v) => clamp(0, 255, v);
var rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
};
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/framer-motion/dist/es/value/types/color/hex.mjs
function parseHex(v) {
  let r2 = "";
  let g = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r2 = v.substring(1, 3);
    g = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
  } else {
    r2 = v.substring(1, 2);
    g = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r2 += r2;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/framer-motion/dist/es/value/types/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/framer-motion/dist/es/value/types/color/index.mjs
var color = {
  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return isString(v) ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  }
};

// node_modules/framer-motion/dist/es/utils/mix.mjs
var mix = (from2, to, progress3) => -progress3 * from2 + progress3 * to + from2;

// node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p, q, t3) {
  if (t3 < 0)
    t3 += 1;
  if (t3 > 1)
    t3 -= 1;
  if (t3 < 1 / 6)
    return p + (q - p) * 6 * t3;
  if (t3 < 1 / 2)
    return q;
  if (t3 < 2 / 3)
    return p + (q - p) * (2 / 3 - t3) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red2 = green2 = blue2 = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red2 = hueToRgb(p, q, hue + 1 / 3);
    green2 = hueToRgb(p, q, hue);
    blue2 = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}

// node_modules/framer-motion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from2, to, v) => {
  const fromExpo = from2 * from2;
  return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color3) {
  const type = getColorType(color3);
  invariant(Boolean(type), `'${color3}' is not an animatable color. Use the equivalent color code instead.`);
  let model = type.parse(color3);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
var mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba.transform(blended);
  };
};

// node_modules/framer-motion/dist/es/value/types/complex/index.mjs
function test(v) {
  var _a4, _b4;
  return isNaN(v) && isString(v) && (((_a4 = v.match(floatRegex)) === null || _a4 === void 0 ? void 0 : _a4.length) || 0) + (((_b4 = v.match(colorRegex)) === null || _b4 === void 0 ? void 0 : _b4.length) || 0) > 0;
}
var cssVarTokeniser = {
  regex: cssVariableRegex,
  countKey: "Vars",
  token: "${v}",
  parse: noop
};
var colorTokeniser = {
  regex: colorRegex,
  countKey: "Colors",
  token: "${c}",
  parse: color.parse
};
var numberTokeniser = {
  regex: floatRegex,
  countKey: "Numbers",
  token: "${n}",
  parse: number.parse
};
function tokenise(info, { regex, countKey, token, parse: parse7 }) {
  const matches = info.tokenised.match(regex);
  if (!matches)
    return;
  info["num" + countKey] = matches.length;
  info.tokenised = info.tokenised.replace(regex, token);
  info.values.push(...matches.map(parse7));
}
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const info = {
    value: originalValue,
    tokenised: originalValue,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  if (info.value.includes("var(--"))
    tokenise(info, cssVarTokeniser);
  tokenise(info, colorTokeniser);
  tokenise(info, numberTokeniser);
  return info;
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { values: values2, numColors, numVars, tokenised } = analyseComplexValue(source);
  const numValues = values2.length;
  return (v) => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      if (i < numVars) {
        output = output.replace(cssVarTokeniser.token, v[i]);
      } else if (i < numVars + numColors) {
        output = output.replace(colorTokeniser.token, color.transform(v[i]));
      } else {
        output = output.replace(numberTokeniser.token, sanitize(v[i]));
      }
    }
    return output;
  };
}
var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone
};

// node_modules/framer-motion/dist/es/utils/mix-complex.mjs
var mixImmediate = (origin, target) => (p) => `${p > 0 ? target : origin}`;
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v) => mix(origin, target, v);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return origin.startsWith("var(") ? mixImmediate(origin, target) : mixComplex(origin, target);
  }
}
var mixArray = (from2, to) => {
  const output = [...from2];
  const numValues = output.length;
  const blendValue = from2.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
var mixObject = (origin, target) => {
  const output = { ...origin, ...target };
  const blendValue = {};
  for (const key2 in output) {
    if (origin[key2] !== void 0 && target[key2] !== void 0) {
      blendValue[key2] = getMixer(origin[key2], target[key2]);
    }
  }
  return (v) => {
    for (const key2 in blendValue) {
      output[key2] = blendValue[key2](v);
    }
    return output;
  };
};
var mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return mixImmediate(origin, target);
  }
};

// node_modules/framer-motion/dist/es/utils/progress.mjs
var progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};

// node_modules/framer-motion/dist/es/utils/interpolate.mjs
var mixNumber = (from2, to) => (p) => mix(from2, to, p);
function detectMixerFactory(v) {
  if (typeof v === "number") {
    return mixNumber;
  } else if (typeof v === "string") {
    return color.test(v) ? mixColor : mixComplex;
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  if (inputLength === 1)
    return () => output[0];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1])
          break;
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}

// node_modules/framer-motion/dist/es/utils/offsets/fill.mjs
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset2.push(mix(min2, 1, offsetProgress));
  }
}

// node_modules/framer-motion/dist/es/utils/offsets/default.mjs
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}

// node_modules/framer-motion/dist/es/utils/offsets/time.mjs
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}

// node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs
function defaultEasing(values2, easing) {
  return values2.map(() => easing || easeInOut).splice(0, values2.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t3) => {
      state.value = mapTimeToKeyframe(t3);
      state.done = t3 >= duration;
      return state;
    }
  };
}

// node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs
var velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue2, t3, current) {
  const prevT = Math.max(t3 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue2(prevT), t3 - prevT);
}

// node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta2 = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta2);
      return safeMin - a / b * c;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta2 = exponentialDecay * duration;
      const d = delta2 * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta2);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e2) * f) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  const origin = keyframes2[0];
  const target = keyframes2[keyframes2.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t3) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t3) + initialDelta * Math.cos(angularFreq * t3));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t3) => target - Math.exp(-undampedAngularFreq * t3) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t3);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t3) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
      const freqForT = Math.min(dampedAngularFreq * t3, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t3) => {
      const current = resolveSpring(t3);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t3 !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t3, current);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t3 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    }
  };
}

// node_modules/framer-motion/dist/es/animation/generators/inertia.mjs
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
  const nearestBoundary = (v) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t3) => -amplitude * Math.exp(-t3 / timeConstant);
  const calcLatest = (t3) => target + calcDelta(t3);
  const applyFriction = (t3) => {
    const delta2 = calcDelta(t3);
    const latest = calcLatest(t3);
    state.done = Math.abs(delta2) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t3) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t3;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t3, state.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t3) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t3);
        checkCatchBoundary(t3);
      }
      if (timeReachedBoundary !== void 0 && t3 > timeReachedBoundary) {
        return spring$1.next(t3 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t3);
        return state;
      }
    }
  };
}

// node_modules/framer-motion/dist/es/animation/animators/js/driver-frameloop.mjs
var frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
  };
};

// node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs
var maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}

// node_modules/framer-motion/dist/es/animation/animators/js/index.mjs
var types = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function animateValue({ autoplay = true, delay: delay3 = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
  let speed = 1;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types[type] || keyframes;
  let mapNumbersToKeyframes;
  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {
      clamp: false
    });
    keyframes$1 = [0, 100];
  }
  const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
  let mirroredGenerator;
  if (repeatType === "mirror") {
    mirroredGenerator = generatorFactory({
      ...options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -(options.velocity || 0)
    });
  }
  let playState = "idle";
  let holdTime = null;
  let startTime = null;
  let cancelTime = null;
  if (generator.calculatedDuration === null && repeat) {
    generator.calculatedDuration = calcGeneratorDuration(generator);
  }
  const { calculatedDuration } = generator;
  let resolvedDuration = Infinity;
  let totalDuration = Infinity;
  if (calculatedDuration !== null) {
    resolvedDuration = calculatedDuration + repeatDelay;
    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
  }
  let currentTime = 0;
  const tick = (timestamp) => {
    if (startTime === null)
      return;
    if (speed > 0)
      startTime = Math.min(startTime, timestamp);
    if (speed < 0)
      startTime = Math.min(timestamp - totalDuration / speed, startTime);
    if (holdTime !== null) {
      currentTime = holdTime;
    } else {
      currentTime = Math.round(timestamp - startTime) * speed;
    }
    const timeWithoutDelay = currentTime - delay3 * (speed >= 0 ? 1 : -1);
    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    currentTime = Math.max(timeWithoutDelay, 0);
    if (playState === "finished" && holdTime === null) {
      currentTime = totalDuration;
    }
    let elapsed = currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress3 = currentTime / resolvedDuration;
      let currentIteration = Math.floor(progress3);
      let iterationProgress = progress3 % 1;
      if (!iterationProgress && progress3 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const iterationIsOdd = Boolean(currentIteration % 2);
      if (iterationIsOdd) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      let p = clamp(0, 1, iterationProgress);
      if (currentTime > totalDuration) {
        p = repeatType === "reverse" && iterationIsOdd ? 1 : 0;
      }
      elapsed = p * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes$1[0] } : frameGenerator.next(elapsed);
    if (mapNumbersToKeyframes) {
      state.value = mapNumbersToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
    }
    const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      finish();
    }
    return state;
  };
  const stopAnimationDriver = () => {
    animationDriver && animationDriver.stop();
    animationDriver = void 0;
  };
  const cancel = () => {
    playState = "idle";
    stopAnimationDriver();
    resolveFinishedPromise();
    updateFinishedPromise();
    startTime = cancelTime = null;
  };
  const finish = () => {
    playState = "finished";
    onComplete && onComplete();
    stopAnimationDriver();
    resolveFinishedPromise();
  };
  const play = () => {
    if (hasStopped)
      return;
    if (!animationDriver)
      animationDriver = driver(tick);
    const now3 = animationDriver.now();
    onPlay && onPlay();
    if (holdTime !== null) {
      startTime = now3 - holdTime;
    } else if (!startTime || playState === "finished") {
      startTime = now3;
    }
    if (playState === "finished") {
      updateFinishedPromise();
    }
    cancelTime = startTime;
    holdTime = null;
    playState = "running";
    animationDriver.start();
  };
  if (autoplay) {
    play();
  }
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      currentTime = newTime;
      if (holdTime !== null || !animationDriver || speed === 0) {
        holdTime = newTime;
      } else {
        startTime = animationDriver.now() - newTime / speed;
      }
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      if (newSpeed === speed || !animationDriver)
        return;
      speed = newSpeed;
      controls.time = millisecondsToSeconds(currentTime);
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = "paused";
      holdTime = currentTime;
    },
    stop: () => {
      hasStopped = true;
      if (playState === "idle")
        return;
      playState = "idle";
      onStop && onStop();
      cancel();
    },
    cancel: () => {
      if (cancelTime !== null)
        tick(cancelTime);
      cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => {
      startTime = 0;
      return tick(elapsed);
    }
  };
  return controls;
}

// node_modules/framer-motion/dist/es/utils/memo.mjs
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}

// node_modules/framer-motion/dist/es/animation/animators/waapi/create-accelerated-animation.mjs
var supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
var acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]);
var sampleDelta = 10;
var maxDuration2 = 2e4;
var requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia";
  if (!canAccelerateAnimation)
    return false;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes2, duration = 300, ease: ease2, times } = options;
  if (requiresPregeneratedKeyframes(valueName, options)) {
    const sampleAnimation = animateValue({
      ...options,
      repeat: 0,
      delay: 0
    });
    let state = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t3 = 0;
    while (!state.done && t3 < maxDuration2) {
      state = sampleAnimation.sample(t3);
      pregeneratedKeyframes.push(state.value);
      t3 += sampleDelta;
    }
    times = void 0;
    keyframes2 = pregeneratedKeyframes;
    duration = t3 - sampleDelta;
    ease2 = "linear";
  }
  const animation2 = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times
  });
  const cancelAnimation = () => animation2.cancel();
  const safeCancel = () => {
    frame.update(cancelAnimation);
    resolveFinishedPromise();
    updateFinishedPromise();
  };
  animation2.onfinish = () => {
    value.set(getFinalKeyframe(keyframes2, options));
    onComplete && onComplete();
    safeCancel();
  };
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    attachTimeline(timeline) {
      animation2.timeline = timeline;
      animation2.onfinish = null;
      return noop;
    },
    get time() {
      return millisecondsToSeconds(animation2.currentTime || 0);
    },
    set time(newTime) {
      animation2.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation2.playbackRate;
    },
    set speed(newSpeed) {
      animation2.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      if (hasStopped)
        return;
      animation2.play();
      cancelFrame(cancelAnimation);
    },
    pause: () => animation2.pause(),
    stop: () => {
      hasStopped = true;
      if (animation2.playState === "idle")
        return;
      const { currentTime } = animation2;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options,
          autoplay: false
        });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => animation2.finish(),
    cancel: safeCancel
  };
  return controls;
}

// node_modules/framer-motion/dist/es/animation/animators/instant.mjs
function createInstantAnimation({ keyframes: keyframes2, delay: delay3, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
    onComplete && onComplete();
    return {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop,
      pause: noop,
      stop: noop,
      then: (resolve) => {
        resolve();
        return Promise.resolve();
      },
      cancel: noop,
      complete: noop
    };
  };
  return delay3 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay3,
    onComplete: setValue
  }) : setValue();
}

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
var criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
var keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
var ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
var getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};

// node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = (key2, value) => {
  if (key2 === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/framer-motion/dist/es/value/types/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter2 = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
};

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
var defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter2,
  WebkitFilter: filter2
};
var getDefaultValueType = (key2) => defaultValueTypes[key2];

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  if (defaultValueType !== filter2)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}

// node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
var isZeroValueString = (v) => /^0[^.\s]+$/.test(v);

// node_modules/framer-motion/dist/es/animation/utils/is-none.mjs
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  }
}

// node_modules/framer-motion/dist/es/animation/utils/keyframes.mjs
function getKeyframes(value, valueName, target, transition) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let keyframes2;
  if (Array.isArray(target)) {
    keyframes2 = [...target];
  } else {
    keyframes2 = [null, target];
  }
  const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
  let animatableTemplateValue = void 0;
  const noneKeyframeIndexes = [];
  for (let i = 0; i < keyframes2.length; i++) {
    if (keyframes2[i] === null) {
      keyframes2[i] = i === 0 ? defaultOrigin : keyframes2[i - 1];
    }
    if (isNone(keyframes2[i])) {
      noneKeyframeIndexes.push(i);
    }
    if (typeof keyframes2[i] === "string" && keyframes2[i] !== "none" && keyframes2[i] !== "0") {
      animatableTemplateValue = keyframes2[i];
    }
  }
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
    for (let i = 0; i < noneKeyframeIndexes.length; i++) {
      const index = noneKeyframeIndexes[i];
      keyframes2[index] = getAnimatableNone2(valueName, animatableTemplateValue);
    }
  }
  return keyframes2;
}

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition(transition, key2) {
  return transition[key2] || transition["default"] || transition;
}

// node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
var animateMotionValue = (valueName, value, target, transition = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition, valueName) || {};
    const delay3 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay3);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ease: "easeOut",
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(instantAnimationState.current ? { ...options, delay: 0 } : options);
    }
    if (
      /**
       * If this is a handoff animation, the optimised animation will be running via
       * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
       * optimised animation.
       */
      !transition.isHandoff && value.owner && value.owner.current instanceof HTMLElement && /**
       * If we're outputting values to onUpdate then we can't use WAAPI as there's
       * no way to read the value from WAAPI every frame.
       */
      !value.owner.getProps().onUpdate
    ) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animateValue(options);
  };
};

// node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}

// node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
var isNumericalString = (v) => /^\-?\d*\.?\d+$/.test(v);

// node_modules/framer-motion/dist/es/utils/array.mjs
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
function moveItem([...arr], fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    const [item] = arr.splice(fromIndex, 1);
    arr.splice(endIndex, 0, item);
  }
  return arr;
}

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var SubscriptionManager = class {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};

// node_modules/framer-motion/dist/es/utils/warn-once.mjs
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}

// node_modules/framer-motion/dist/es/value/index.mjs
var isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
var collectMotionValues = {
  current: void 0
};
var MotionValue = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init2, options = {}) {
    this.version = "10.16.16";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v, render2 = true) => {
      this.prev = this.current;
      this.current = v;
      const { delta: delta2, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta2;
        this.lastUpdated = timestamp;
        frame.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render2 && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init2;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    if (true) {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
    }
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render2 = true) {
    if (!render2 || !this.passiveEffect) {
      this.updateAndNotify(v, render2);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta2) {
    this.set(current);
    this.prev = prev;
    this.timeDelta = delta2;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v) {
    this.updateAndNotify(v);
    this.prev = v;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
};
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}

// node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
var testValueType = (v) => (type) => type.test(v);

// node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
var auto = {
  test: (v) => v === "auto",
  parse: (v) => v
};

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = [...dimensionValueTypes, color, complex];
var findValueType = (v) => valueTypes.find(testValueType(v));

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement, key2, value) {
  if (visualElement.hasValue(key2)) {
    visualElement.getValue(key2).set(value);
  } else {
    visualElement.addValue(key2, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a4, _b4;
  const newValueKeys = Object.keys(target).filter((key2) => !visualElement.hasValue(key2));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i = 0; i < numNewValues; i++) {
    const key2 = newValueKeys[i];
    const targetValue = target[key2];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b4 = (_a4 = origin[key2]) !== null && _a4 !== void 0 ? _a4 : visualElement.readValue(key2)) !== null && _b4 !== void 0 ? _b4 : target[key2];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone2(key2, targetValue);
    }
    visualElement.addValue(key2, motionValue(value, { owner: visualElement }));
    if (origin[key2] === void 0) {
      origin[key2] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key2, value);
  }
}
function getOriginFromTransition(key2, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key2] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement) {
  const origin = {};
  for (const key2 in target) {
    const transitionOrigin = getOriginFromTransition(key2, transition);
    if (transitionOrigin !== void 0) {
      origin[key2] = transitionOrigin;
    } else {
      const value = visualElement.getValue(key2);
      if (value) {
        origin[key2] = value.get();
      }
    }
  }
  return origin;
}

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== true;
  needsAnimating[key2] = false;
  return shouldBlock;
}
function hasKeyframesChanged(value, target) {
  const current = value.get();
  if (Array.isArray(target)) {
    for (let i = 0; i < target.length; i++) {
      if (target[i] !== current)
        return true;
    }
  } else {
    return current !== target;
  }
}
function animateTarget(visualElement, definition, { delay: delay3 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target) {
    const value = visualElement.getValue(key2);
    const valueTarget = target[key2];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2)) {
      continue;
    }
    const valueTransition = {
      delay: delay3,
      elapsed: 0,
      ...getValueTransition(transition || {}, key2)
    };
    if (window.HandoffAppearAnimations) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        const elapsed = window.HandoffAppearAnimations(appearId, key2, value, frame);
        if (elapsed !== null) {
          valueTransition.elapsed = elapsed;
          valueTransition.isHandoff = true;
        }
      }
    }
    let canSkip = !valueTransition.isHandoff && !hasKeyframesChanged(value, valueTarget);
    if (valueTransition.type === "spring" && (value.getVelocity() || valueTransition.velocity)) {
      canSkip = false;
    }
    if (value.animation) {
      canSkip = false;
    }
    if (canSkip)
      continue;
    value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key2) ? { type: false } : valueTransition));
    const animation2 = value.animation;
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key2);
      animation2.then(() => willChange.remove(key2));
    }
    animations2.push(animation2);
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }
  return animations2;
}

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first2, last2] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first2().then(() => last2());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation2;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation2 = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation2 = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation2 = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation2.then(() => visualElement.notify("AnimationComplete", definition));
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var reversePriorityOrder = [...variantPriorityOrder].reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation: animation2, options }) => animateVisualElement(visualElement, animation2, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props2 = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props2[type] !== void 0 ? props2[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type] && prop !== props2[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key2) => {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (const key2 in allKeys) {
        const next = resolvedValues[key2];
        const prev = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key2);
            } else {
              typeState.protectedKeys[key2] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key2);
          } else {
            removedKeys.add(key2);
          }
        } else if (next !== void 0 && removedKeys.has(key2)) {
          markToAnimate(key2);
        } else {
          typeState.protectedKeys[key2] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation2) => ({
          animation: animation2,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key2] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props2.initial === false || props2.initial === props2.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a4;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a4 = visualElement.variantChildren) === null || _a4 === void 0 ? void 0 : _a4.forEach((child) => {
      var _a5;
      return (_a5 = child.animationState) === null || _a5 === void 0 ? void 0 : _a5.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key2 in state) {
      state[key2].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}

// node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
var AnimationFeature = class extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate2)) {
      this.unmount = animate2.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate2 !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
var id = 0;
var ExitAnimationFeature = class extends Feature {
  constructor() {
    super(...arguments);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete, custom } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};

// node_modules/framer-motion/dist/es/utils/distance.mjs
var distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}

// node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
var PanSession = class {
  constructor(event, handlers, { transformPagePoint, contextWindow } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
};
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history2) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history2)),
    offset: subtractPoint(point, startDevicePoint(history2)),
    velocity: getVelocity2(history2, 0.1)
  };
}
function startDevicePoint(history2) {
  return history2[0];
}
function lastDevicePoint(history2) {
  return history2[history2.length - 1];
}
function getVelocity2(history2, timeDelta) {
  if (history2.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history2.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history2);
  while (i >= 0) {
    timestampedPoint = history2[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta2, source, target, origin = 0.5) {
  delta2.origin = origin;
  delta2.originPoint = mix(source.min, source.max, delta2.origin);
  delta2.scale = calcLength(target) / calcLength(source);
  if (isNear(delta2.scale, 1, 1e-4) || isNaN(delta2.scale))
    delta2.scale = 1;
  delta2.translate = mix(target.min, target.max, delta2.origin) - delta2.originPoint;
  if (isNear(delta2.translate) || isNaN(delta2.translate))
    delta2.translate = 0;
}
function calcBoxDelta(delta2, source, target, origin) {
  calcAxisDelta(delta2.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta2.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mix(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mix(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom: bottom2, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom2)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin2(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}

// node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
var createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
var createAxis = () => ({ min: 0, max: 0 });
var createBox = () => ({
  x: createAxis(),
  y: createAxis()
});

// node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox({ top, left, right, bottom: bottom2 }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom2 }
  };
}
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta2;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta2 = node.projectionDelta;
    const instance2 = node.instance;
    if (instance2 && instance2.style && instance2.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta2) {
      treeScale.x *= delta2.x.scale;
      treeScale.y *= delta2.y.scale;
      applyBoxDelta(box, delta2);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key2, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key2], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function transformBox(box, transform2) {
  transformAxis(box.x, transform2, xKeys);
  transformAxis(box.y, transform2, yKeys);
}

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance2, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance2.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}

// node_modules/framer-motion/dist/es/utils/get-context-window.mjs
var getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = class {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.update(() => onDragStart(event, info), false, true);
      }
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.update(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a4;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a4 = this.visualElement.projection) === null || _a4 === void 0 ? void 0 : _a4.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = "_drag" + axis.toUpperCase();
    const props2 = this.visualElement.getProps();
    const externalMotionValue = props2[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props2.initial ? props2.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mix(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta: delta2, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta2[axis].translate;
          motionValue2.set(motionValue2.get() + delta2[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props2 = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props2;
    return {
      ...props2,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// node_modules/framer-motion/dist/es/gestures/drag/index.mjs
var DragGesture = class extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
};

// node_modules/framer-motion/dist/es/gestures/pan/index.mjs
var asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.update(() => handler(event, info));
  }
};
var PanGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.update(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react18 = __toESM(require_react(), 1);
function usePresence() {
  const context = (0, import_react18.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id4 = (0, import_react18.useId)();
  (0, import_react18.useEffect)(() => register(id4), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id4);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}

// node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};

// node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  }
};

// node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    return template(shadow);
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = class extends import_react19.default.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      queueMicrotask(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
function MeasureLayout(props2) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = (0, import_react19.useContext)(LayoutGroupContext);
  return import_react19.default.createElement(MeasureLayoutWithContext, { ...props2, layoutGroup, switchLayoutGroup: (0, import_react19.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
var isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress3)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress3));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress3);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);
  }
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, noop);
function compress(min2, max2, easing) {
  return (p) => {
    if (p < min2)
      return 0;
    if (p > max2)
      return 1;
    return easing(progress(min2, max2, p));
  };
}

// node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
var xKeys2 = ["x", "scaleX", "originX"];
var yKeys2 = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys2, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys2, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}

// node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta2) {
  return delta2.translate === 0 && delta2.scale === 1;
}
function isDeltaZero(delta2) {
  return isAxisDeltaZero(delta2.x) && isAxisDeltaZero(delta2.y);
}
function boxEquals(a, b) {
  return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
}
function boxEqualsRounded(a, b) {
  return Math.round(a.x.min) === Math.round(b.x.min) && Math.round(a.x.max) === Math.round(b.x.max) && Math.round(a.y.min) === Math.round(b.y.min) && Math.round(a.y.max) === Math.round(b.y.max);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}

// node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var NodeStack = class {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};

// node_modules/framer-motion/dist/es/projection/styles/transform.mjs
function buildProjectionTransform(delta2, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta2.x.translate / treeScale.x;
  const yTranslate = delta2.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate: rotate3, rotateX, rotateY } = latestTransform;
    if (rotate3)
      transform2 += `rotate(${rotate3}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta2.x.scale * treeScale.x;
  const elementScaleY = delta2.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}

// node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = (a, b) => a.depth - b.depth;

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = class {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
};

// node_modules/framer-motion/dist/es/utils/delay.mjs
function delay2(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}

// node_modules/framer-motion/dist/es/debug/record.mjs
function record(data) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data);
  }
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}

// node_modules/framer-motion/dist/es/animation/interfaces/single-value.mjs
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var transformAxes = ["", "X", "Y", "Z"];
var hiddenVisibility = { visibility: "hidden" };
var animationTarget = 1e3;
var id2 = 0;
var projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        record(projectionFrameData);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance2, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance2);
      this.instance = instance2;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance2);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance2, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay2(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta: delta2, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta2, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now3 = performance.now();
      frameData.delta = clamp(0, 1e3 / 60, now3 - frameData.timestamp);
      frameData.timestamp = now3;
      frameData.isProcessing = true;
      steps.update.process(frameData);
      steps.preRender.process(frameData);
      steps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        queueMicrotask(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.offset.x);
        translateAxis(box.y, scroll2.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll: scroll2, options } = node;
        if (node !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta2) {
      this.targetDelta = delta2;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a4;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a4 = this.parent) === null || _a4 === void 0 ? void 0 : _a4.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a4;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a4 = this.parent) === null || _a4 === void 0 ? void 0 : _a4.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
      }
      const { target } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = "none";
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta2, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress3 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta2.x, progress3);
        mixAxisDelta(targetDelta.y, delta2.y, progress3);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress3);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress3;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? ((_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.lead) || this : this;
    }
    getPrevLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? (_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key2 = "rotate" + transformAxes[i];
        if (latestValues[key2]) {
          resetValues[key2] = latestValues[key2];
          visualElement.setStaticValue(key2, 0);
        }
      }
      visualElement.render();
      for (const key2 in resetValues) {
        visualElement.setStaticValue(key2, resetValues[key2]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a4, _b4;
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x, y } = this.projectionDelta;
      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b4 = (_a4 = valuesToRender.opacity) !== null && _a4 !== void 0 ? _a4 : this.latestValues.opacity) !== null && _b4 !== void 0 ? _b4 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key2];
        const corrected = styles.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key2] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a4;
        return (_a4 = node.currentAnimation) === null || _a4 === void 0 ? void 0 : _a4.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a4;
  const snapshot = ((_a4 = node.resumeFrom) === null || _a4 === void 0 ? void 0 : _a4.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  projectionFrameData.totalNodes++;
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta2, p) {
  output.translate = mix(delta2.translate, 0, p);
  output.scale = mix(delta2.scale, 1, p);
  output.origin = delta2.origin;
  output.originPoint = delta2.originPoint;
}
function mixAxis(output, from2, to, p) {
  output.min = mix(from2.min, to.min, p);
  output.max = mix(from2.max, to.max, p);
}
function mixBox(output, from2, to, p) {
  mixAxis(output.x, from2.x, to.x, p);
  mixAxis(output.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
var userAgentContains = (string3) => typeof navigator !== "undefined" && navigator.userAgent.toLowerCase().includes(string3);
var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}

// node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance2) => ({
    x: instance2.scrollLeft,
    y: instance2.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance2, value) => {
    instance2.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance2) => Boolean(window.getComputedStyle(instance2).position === "fixed")
});

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
var splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match4 = splitCSSVariableRegex.exec(current);
  if (!match4)
    return [,];
  const [, token, fallback] = match4;
  return [token, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  } else if (isCSSVariableToken(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariableToken(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key2 in target) {
    const current = target[key2];
    if (!isCSSVariableToken(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key2] = resolved;
    if (!transitionEnd)
      transitionEnd = {};
    if (transitionEnd[key2] === void 0) {
      transitionEnd[key2] = current;
    }
  }
  return { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
var isPositionalKey = (key2) => positionalKeys.has(key2);
var hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
var isNumOrPxType = (v) => v === number || v === px;
var getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
var getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
  if (transform2 === "none" || !transform2)
    return 0;
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform2.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (value !== void 0) {
      removedTransforms.push([key2, value.get()]);
      value.set(key2.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
var convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key2) => {
    origin[key2] = positionalValues[key2](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value && value.jump(origin[key2]);
    target[key2] = positionalValues[key2](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (!visualElement.hasValue(key2))
      return;
    let from2 = origin[key2];
    let fromType = findDimensionValueType(from2);
    const to = target[key2];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (let i = fromIndex; i < numKeyframes; i++) {
        if (to[i] === null)
          break;
        if (!toType) {
          toType = findDimensionValueType(to[i]);
          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key2] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key2] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key2] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key2);
        transitionEnd[key2] = transitionEnd[key2] !== void 0 ? transitionEnd[key2] : target[key2];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key2, value]) => {
        visualElement.getValue(key2).set(value);
      });
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
var parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};

// node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
var prefersReducedMotion = { current: null };
var hasReducedMotionListener = { current: false };

// node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}

// node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key2 in next) {
    const nextValue = next[key2];
    const prevValue = prev[key2];
    if (isMotionValue(nextValue)) {
      element.addValue(key2, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key2);
      }
      if (true) {
        warnOnce(nextValue.version === "10.16.16", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.16.16 may not work as expected.`);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key2, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key2);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key2 in prev) {
    if (next[key2] === void 0)
      element.removeValue(key2);
  }
  return next;
}

// node_modules/framer-motion/dist/es/render/store.mjs
var visualElementStore = /* @__PURE__ */ new WeakMap();

// node_modules/framer-motion/dist/es/render/VisualElement.mjs
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
var propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
var numVariantProps = variantProps.length;
var VisualElement = class {
  constructor({ parent, props: props2, presenceContext, reducedMotionConfig, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => frame.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props2.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props2;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props2);
    this.isVariantNode = isVariantNode(props2);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props2, {});
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      if (latestValues[key2] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key2], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key2);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance2) {
    this.current = instance2;
    visualElementStore.set(instance2, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance2);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key2) => this.bindToMotionValue(key2, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (true) {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
    }
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove2) => remove2());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key2 in this.events) {
      this.events[key2].clear();
    }
    for (const key2 in this.features) {
      this.features[key2].unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    const valueIsTransform = transformProps.has(key2);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue;
      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key2, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    if (preloadedFeatures2 && isStrict) {
      const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      renderedProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
    }
    for (let i = 0; i < numFeatures; i++) {
      const name = featureNames[i];
      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
      if (ProjectionNode)
        ProjectionNodeConstructor = ProjectionNode;
      if (isEnabled(renderedProps)) {
        if (!this.features[name] && FeatureConstructor) {
          this.features[name] = new FeatureConstructor(this);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key2 in this.features) {
      const feature = this.features[key2];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props2, presenceContext) {
    if (props2.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props2;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key2 = propEventHandlers[i];
      if (this.propEventSubscriptions[key2]) {
        this.propEventSubscriptions[key2]();
        delete this.propEventSubscriptions[key2];
      }
      const listener = props2["on" + key2];
      if (listener) {
        this.propEventSubscriptions[key2] = this.on(key2, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props2, this.prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = this.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    if (value !== this.values.get(key2)) {
      this.removeValue(key2);
      this.bindToMotionValue(key2, value);
    }
    this.values.set(key2, value);
    this.latestValues[key2] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key2);
    }
    delete this.latestValues[key2];
    this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2]) {
      return this.props.values[key2];
    }
    let value = this.values.get(key2);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key2, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2) {
    var _a4;
    return this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : (_a4 = this.getBaseTargetFromProps(this.props, key2)) !== null && _a4 !== void 0 ? _a4 : this.readValueFromInstance(this.current, key2, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    var _a4;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a4 = resolveVariantFromProps(this.props, initial)) === null || _a4 === void 0 ? void 0 : _a4[key2] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key2);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
};

// node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
var DOMVisualElement = class extends VisualElement {
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props2, key2) {
    return props2.style ? props2.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style }) {
    delete vars[key2];
    delete style[key2];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  }
};

// node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var HTMLVisualElement = class extends DOMVisualElement {
  readValueFromInstance(instance2, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle2(instance2);
      const value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance2, { transformPagePoint }) {
    return measureViewportBox(instance2, transformPagePoint);
  }
  build(renderState, latestValues, options, props2) {
    buildHTMLStyles(renderState, latestValues, options, props2.transformTemplate);
  }
  scrapeMotionValuesFromProps(props2, prevProps) {
    return scrapeMotionValuesFromProps(props2, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance2, renderState, styleProp, projection) {
    renderHTML(instance2, renderState, styleProp, projection);
  }
};

// node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
var SVGVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props2, key2) {
    return props2[key2];
  }
  readValueFromInstance(instance2, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key2 = !camelCaseAttributes.has(key2) ? camelToDash(key2) : key2;
    return instance2.getAttribute(key2);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props2, prevProps) {
    return scrapeMotionValuesFromProps2(props2, prevProps);
  }
  build(renderState, latestValues, options, props2) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props2.transformTemplate);
  }
  renderInstance(instance2, renderState, styleProp, projection) {
    renderSVG(instance2, renderState, styleProp, projection);
  }
  mount(instance2) {
    this.isSVGTag = isSVGTag(instance2.tagName);
    super.mount(instance2);
  }
};

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = (Component3, options) => {
  return isSVGComponent(Component3) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
};

// node_modules/framer-motion/dist/es/motion/features/layout.mjs
var layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
var preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
var motion = createMotionProxy((Component3, config) => createDomMotionConfig(Component3, config, preloadedFeatures, createDomVisualElement));

// node_modules/framer-motion/dist/es/render/dom/motion-minimal.mjs
var m = createMotionProxy(createDomMotionConfig);

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var React4 = __toESM(require_react(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
var import_react21 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
var import_react20 = __toESM(require_react(), 1);
function useIsMounted() {
  const isMounted = (0, import_react20.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = (0, import_react21.useState)(0);
  const forceRender = (0, import_react21.useCallback)(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = (0, import_react21.useCallback)(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var React3 = __toESM(require_react(), 1);
var import_react23 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var React2 = __toESM(require_react(), 1);
var import_react22 = __toESM(require_react(), 1);
var PopChildMeasure = class extends React2.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
function PopChild({ children, isPresent }) {
  const id4 = (0, import_react22.useId)();
  const ref = (0, import_react22.useRef)(null);
  const size2 = (0, import_react22.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  (0, import_react22.useInsertionEffect)(() => {
    const { width, height, top, left } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id4;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id4}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return React2.createElement(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2 }, React2.cloneElement(children, { ref }));
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id4 = (0, import_react23.useId)();
  const context = (0, import_react23.useMemo)(
    () => ({
      id: id4,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  (0, import_react23.useMemo)(() => {
    presenceChildren.forEach((_, key2) => presenceChildren.set(key2, false));
  }, [isPresent]);
  React3.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = React3.createElement(PopChild, { isPresent }, children);
  }
  return React3.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
var import_react24 = __toESM(require_react(), 1);
function useUnmountEffect(callback) {
  return (0, import_react24.useEffect)(() => () => callback(), []);
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key2 = getChildKey(child);
    allChildren.set(key2, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  import_react25.Children.forEach(children, (child) => {
    if ((0, import_react25.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}
var AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
  const forceRender = (0, import_react25.useContext)(LayoutGroupContext).forceRender || useForceUpdate()[0];
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exitingChildren = (0, import_react25.useRef)(/* @__PURE__ */ new Map()).current;
  const presentChildren = (0, import_react25.useRef)(childrenToRender);
  const allChildren = (0, import_react25.useRef)(/* @__PURE__ */ new Map()).current;
  const isInitialRender = (0, import_react25.useRef)(true);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exitingChildren.clear();
  });
  if (isInitialRender.current) {
    return React4.createElement(React4.Fragment, null, childrenToRender.map((child) => React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key2 = presentKeys[i];
    if (targetKeys.indexOf(key2) === -1 && !exitingChildren.has(key2)) {
      exitingChildren.set(key2, void 0);
    }
  }
  if (mode === "wait" && exitingChildren.size) {
    childrenToRender = [];
  }
  exitingChildren.forEach((component, key2) => {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    const child = allChildren.get(key2);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key2);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = () => {
        exitingChildren.delete(key2);
        const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));
        leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));
        presentChildren.current = filteredChildren.filter((presentChild) => {
          const presentChildKey = getChildKey(presentChild);
          return (
            // filter out the node exiting
            presentChildKey === key2 || // filter out the leftover children
            leftOverKeys.includes(presentChildKey)
          );
        });
        if (!exitingChildren.size) {
          if (isMounted.current === false)
            return;
          forceRender();
          onExitComplete && onExitComplete();
        }
      };
      exitingComponent = React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child);
      exitingChildren.set(key2, exitingComponent);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  });
  childrenToRender = childrenToRender.map((child) => {
    const key2 = child.key;
    return exitingChildren.has(key2) ? child : React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
  });
  if (mode === "wait" && childrenToRender.length > 1) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  return React4.createElement(React4.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => (0, import_react25.cloneElement)(child)));
};

// node_modules/framer-motion/dist/es/components/MotionConfig/index.mjs
var React5 = __toESM(require_react(), 1);
var import_react26 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs
var React6 = __toESM(require_react(), 1);
var import_react27 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs
var React7 = __toESM(require_react(), 1);
var import_react29 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs
var import_react28 = __toESM(require_react(), 1);
var DeprecatedLayoutGroupContext = (0, import_react28.createContext)(null);

// node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
var React8 = __toESM(require_react(), 1);
var import_react31 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/ReorderContext.mjs
var import_react30 = __toESM(require_react(), 1);
var ReorderContext = (0, import_react30.createContext)(null);

// node_modules/framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs
function checkReorder(order2, value, offset2, velocity) {
  if (!velocity)
    return order2;
  const index = order2.findIndex((item2) => item2.value === value);
  if (index === -1)
    return order2;
  const nextOffset = velocity > 0 ? 1 : -1;
  const nextItem = order2[index + nextOffset];
  if (!nextItem)
    return order2;
  const item = order2[index];
  const nextLayout = nextItem.layout;
  const nextItemCenter = mix(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset2 > nextItemCenter || nextOffset === -1 && item.layout.min + offset2 < nextItemCenter) {
    return moveItem(order2, index, index + nextOffset);
  }
  return order2;
}

// node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
function ReorderGroup({ children, as = "ul", axis = "y", onReorder, values: values2, ...props2 }, externalRef) {
  const Component3 = useConstant(() => motion(as));
  const order2 = [];
  const isReordering = (0, import_react31.useRef)(false);
  invariant(Boolean(values2), "Reorder.Group must be provided a values prop");
  const context = {
    axis,
    registerItem: (value, layout2) => {
      const idx = order2.findIndex((entry) => value === entry.value);
      if (idx !== -1) {
        order2[idx].layout = layout2[axis];
      } else {
        order2.push({ value, layout: layout2[axis] });
      }
      order2.sort(compareMin);
    },
    updateOrder: (item, offset2, velocity) => {
      if (isReordering.current)
        return;
      const newOrder = checkReorder(order2, item, offset2, velocity);
      if (order2 !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue).filter((value) => values2.indexOf(value) !== -1));
      }
    }
  };
  (0, import_react31.useEffect)(() => {
    isReordering.current = false;
  });
  return React8.createElement(
    Component3,
    { ...props2, ref: externalRef, ignoreStrict: true },
    React8.createElement(ReorderContext.Provider, { value: context }, children)
  );
}
var Group = (0, import_react31.forwardRef)(ReorderGroup);
function getValue(item) {
  return item.value;
}
function compareMin(a, b) {
  return a.layout.min - b.layout.min;
}

// node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
var React9 = __toESM(require_react(), 1);
var import_react33 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/value/use-motion-value.mjs
var import_react32 = __toESM(require_react(), 1);
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial));
  const { isStatic } = (0, import_react32.useContext)(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = (0, import_react32.useState)(initial);
    (0, import_react32.useEffect)(() => value.on("change", setLatest), []);
  }
  return value;
}

// node_modules/framer-motion/dist/es/utils/transform.mjs
var isCustomValueType = (v) => {
  return typeof v === "object" && v.mix;
};
var getMixer2 = (v) => isCustomValueType(v) ? v.mix : void 0;
function transform(...args) {
  const useImmediate = !Array.isArray(args[0]);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate(inputRange, outputRange, {
    mixer: getMixer2(outputRange[0]),
    ...options
  });
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// node_modules/framer-motion/dist/es/value/use-combine-values.mjs
function useCombineMotionValues(values2, combineValues) {
  const value = useMotionValue(combineValues());
  const updateValue = () => value.set(combineValues());
  updateValue();
  useIsomorphicLayoutEffect(() => {
    const scheduleUpdate = () => frame.update(updateValue, false, true);
    const subscriptions = values2.map((v) => v.on("change", scheduleUpdate));
    return () => {
      subscriptions.forEach((unsubscribe) => unsubscribe());
      cancelFrame(updateValue);
    };
  });
  return value;
}

// node_modules/framer-motion/dist/es/value/use-computed.mjs
function useComputed(compute) {
  collectMotionValues.current = [];
  compute();
  const value = useCombineMotionValues(collectMotionValues.current, compute);
  collectMotionValues.current = void 0;
  return value;
}

// node_modules/framer-motion/dist/es/value/use-transform.mjs
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  if (typeof input === "function") {
    return useComputed(input);
  }
  const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
}
function useListTransform(values2, transformer) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values2, () => {
    latest.length = 0;
    const numValues = values2.length;
    for (let i = 0; i < numValues; i++) {
      latest[i] = values2[i].get();
    }
    return transformer(latest);
  });
}

// node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
function useDefaultMotionValue(value, defaultValue = 0) {
  return isMotionValue(value) ? value : useMotionValue(defaultValue);
}
function ReorderItem({ children, style = {}, value, as = "li", onDrag, layout: layout2 = true, ...props2 }, externalRef) {
  const Component3 = useConstant(() => motion(as));
  const context = (0, import_react33.useContext)(ReorderContext);
  const point = {
    x: useDefaultMotionValue(style.x),
    y: useDefaultMotionValue(style.y)
  };
  const zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
  invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  const { axis, registerItem, updateOrder } = context;
  return React9.createElement(Component3, { drag: axis, ...props2, dragSnapToOrigin: true, style: { ...style, x: point.x, y: point.y, zIndex }, layout: layout2, onDrag: (event, gesturePoint) => {
    const { velocity } = gesturePoint;
    velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
    onDrag && onDrag(event, gesturePoint);
  }, onLayoutMeasure: (measured) => registerItem(value, measured), ref: externalRef, ignoreStrict: true }, children);
}
var Item = (0, import_react33.forwardRef)(ReorderItem);

// node_modules/framer-motion/dist/es/render/dom/features-animation.mjs
var domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
};

// node_modules/framer-motion/dist/es/render/dom/features-max.mjs
var domMax = {
  ...domAnimation,
  ...drag,
  ...layout
};

// node_modules/framer-motion/dist/es/value/use-spring.mjs
var import_react34 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs
var import_react35 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/value/use-scroll.mjs
var import_react36 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs
function resolveElements(elements, scope, selectorCache) {
  var _a4;
  if (typeof elements === "string") {
    let root = document;
    if (scope) {
      invariant(Boolean(scope.current), "Scope provided, but no element detected.");
      root = scope.current;
    }
    if (selectorCache) {
      (_a4 = selectorCache[elements]) !== null && _a4 !== void 0 ? _a4 : selectorCache[elements] = root.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = root.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  return Array.from(elements || []);
}

// node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs
var import_react37 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs
var import_react38 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion-config.mjs
var import_react39 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/dom/scroll/observe.mjs
function observeTimeline(update, timeline) {
  let prevProgress;
  const onFrame = () => {
    const { currentTime } = timeline;
    const percentage = currentTime === null ? 0 : currentTime.value;
    const progress3 = percentage / 100;
    if (prevProgress !== progress3) {
      update(progress3);
    }
    prevProgress = progress3;
  };
  frame.update(onFrame, true);
  return () => cancelFrame(onFrame);
}

// node_modules/framer-motion/dist/es/render/dom/scroll/supports.mjs
var supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);

// node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs
var GroupPlaybackControls = class {
  constructor(animations2) {
    this.animations = animations2.filter(Boolean);
  }
  then(onResolve, onReject) {
    return Promise.all(this.animations).then(onResolve).catch(onReject);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i = 0; i < this.animations.length; i++) {
      this.animations[i][propName] = newValue;
    }
  }
  attachTimeline(timeline) {
    const cancelAll = this.animations.map((animation2) => {
      if (supportsScrollTimeline() && animation2.attachTimeline) {
        animation2.attachTimeline(timeline);
      } else {
        animation2.pause();
        return observeTimeline((progress3) => {
          animation2.time = animation2.duration * progress3;
        }, timeline);
      }
    });
    return () => {
      cancelAll.forEach((cancelTimeline, i) => {
        if (cancelTimeline)
          cancelTimeline();
        this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get duration() {
    let max2 = 0;
    for (let i = 0; i < this.animations.length; i++) {
      max2 = Math.max(max2, this.animations[i].duration);
    }
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  stop() {
    this.runAll("stop");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
};

// node_modules/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 === "object" && !Array.isArray(keyframes2);
}

// node_modules/framer-motion/dist/es/animation/utils/create-visual-element.mjs
function createVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  };
  const node = isSVGElement(element) ? new SVGVisualElement(options, {
    enableHardwareAcceleration: false
  }) : new HTMLVisualElement(options, {
    enableHardwareAcceleration: true
  });
  node.mount(element);
  visualElementStore.set(element, node);
}

// node_modules/framer-motion/dist/es/easing/utils/create-generator-easing.mjs
function createGeneratorEasing(options, scale2 = 100) {
  const generator = spring({ keyframes: [0, scale2], ...options });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress3) => generator.next(duration * progress3).value / scale2,
    duration: millisecondsToSeconds(duration)
  };
}

// node_modules/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs
function calcNextTime(current, next, prev, labels) {
  var _a4;
  if (typeof next === "number") {
    return next;
  } else if (next.startsWith("-") || next.startsWith("+")) {
    return Math.max(0, current + parseFloat(next));
  } else if (next === "<") {
    return prev;
  } else {
    return (_a4 = labels.get(next)) !== null && _a4 !== void 0 ? _a4 : current;
  }
}

// node_modules/framer-motion/dist/es/utils/wrap.mjs
var wrap = (min2, max2, v) => {
  const rangeSize = max2 - min2;
  return ((v - min2) % rangeSize + rangeSize) % rangeSize + min2;
};

// node_modules/framer-motion/dist/es/easing/utils/get-easing-for-segment.mjs
function getEasingForSegment(easing, i) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;
}

// node_modules/framer-motion/dist/es/animation/sequence/utils/edit.mjs
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i = 0; i < sequence.length; i++) {
    const keyframe2 = sequence[i];
    if (keyframe2.at > startTime && keyframe2.at < endTime) {
      removeItem(sequence, keyframe2);
      i--;
    }
  }
}
function addKeyframes(sequence, keyframes2, easing, offset2, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i = 0; i < keyframes2.length; i++) {
    sequence.push({
      value: keyframes2[i],
      at: mix(startTime, endTime, offset2[i]),
      easing: getEasingForSegment(easing, i)
    });
  }
}

// node_modules/framer-motion/dist/es/animation/sequence/utils/sort.mjs
function compareByTime(a, b) {
  if (a.at === b.at) {
    if (a.value === null)
      return 1;
    if (b.value === null)
      return -1;
    return 0;
  } else {
    return a.at - b.at;
  }
}

// node_modules/framer-motion/dist/es/animation/sequence/create.mjs
var defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {
  const defaultDuration = defaultTransition.duration || 0.3;
  const animationDefinitions = /* @__PURE__ */ new Map();
  const sequences = /* @__PURE__ */ new Map();
  const elementCache = {};
  const timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  for (let i = 0; i < sequence.length; i++) {
    const segment = sequence[i];
    if (typeof segment === "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    if (transition.at !== void 0) {
      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
    }
    let maxDuration3 = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes);
      const { delay: delay3 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay3 === "function" ? delay3(elementIndex, numElements) : delay3;
      const numKeyframes = valueKeyframesAsList.length;
      if (numKeyframes <= 2 && type === "spring") {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta2 = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta2);
        }
        const springTransition = { ...remainingTransition };
        if (duration !== void 0) {
          springTransition.duration = secondsToMilliseconds(duration);
        }
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta);
        ease2 = springEasing.ease;
        duration = springEasing.duration;
      }
      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;
      const startTime = currentTime + calculatedDelay;
      const targetTime = startTime + duration;
      if (times.length === 1 && times[0] === 0) {
        times[1] = 1;
      }
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder);
      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime);
      maxDuration3 = Math.max(calculatedDelay + duration, maxDuration3);
      totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const elements = resolveElements(subject, scope, elementCache);
      const numElements = elements.length;
      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {
        keyframes2 = keyframes2;
        transition = transition;
        const element = elements[elementIndex];
        const subjectSequence = getSubjectSequence(element, sequences);
        for (const key2 in keyframes2) {
          resolveValueSequence(keyframes2[key2], getValueTransition2(transition, key2), getValueSequence(key2, subjectSequence), elementIndex, numElements);
        }
      }
      prevTime = currentTime;
      currentTime += maxDuration3;
    }
  }
  sequences.forEach((valueSequences, element) => {
    for (const key2 in valueSequences) {
      const valueSequence = valueSequences[key2];
      valueSequence.sort(compareByTime);
      const keyframes2 = [];
      const valueOffset = [];
      const valueEasing = [];
      for (let i = 0; i < valueSequence.length; i++) {
        const { at: at2, value, easing } = valueSequence[i];
        keyframes2.push(value);
        valueOffset.push(progress(0, totalDuration, at2));
        valueEasing.push(easing || "easeOut");
      }
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0);
        keyframes2.unshift(keyframes2[0]);
        valueEasing.unshift(defaultSegmentEasing);
      }
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1);
        keyframes2.push(null);
      }
      if (!animationDefinitions.has(element)) {
        animationDefinitions.set(element, {
          keyframes: {},
          transition: {}
        });
      }
      const definition = animationDefinitions.get(element);
      definition.keyframes[key2] = keyframes2;
      definition.transition[key2] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  });
  return animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  !sequences.has(subject) && sequences.set(subject, {});
  return sequences.get(subject);
}
function getValueSequence(name, sequences) {
  if (!sequences[name])
    sequences[name] = [];
  return sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition2(transition, key2) {
  return transition[key2] ? { ...transition, ...transition[key2] } : { ...transition };
}
var isNumber = (keyframe2) => typeof keyframe2 === "number";
var isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);

// node_modules/framer-motion/dist/es/animation/animate.mjs
function animateElements(elementOrSelector, keyframes2, options, scope) {
  const elements = resolveElements(elementOrSelector, scope);
  const numElements = elements.length;
  invariant(Boolean(numElements), "No valid element provided.");
  const animations2 = [];
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    if (!visualElementStore.has(element)) {
      createVisualElement(element);
    }
    const visualElement = visualElementStore.get(element);
    const transition = { ...options };
    if (typeof transition.delay === "function") {
      transition.delay = transition.delay(i, numElements);
    }
    animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
  }
  return new GroupPlaybackControls(animations2);
}
var isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);
  animationDefinitions.forEach(({ keyframes: keyframes2, transition }, subject) => {
    let animation2;
    if (isMotionValue(subject)) {
      animation2 = animateSingleValue(subject, keyframes2.default, transition.default);
    } else {
      animation2 = animateElements(subject, keyframes2, transition);
    }
    animations2.push(animation2);
  });
  return new GroupPlaybackControls(animations2);
}
var createScopedAnimate = (scope) => {
  function scopedAnimate(valueOrElementOrSequence, keyframes2, options) {
    let animation2;
    if (isSequence(valueOrElementOrSequence)) {
      animation2 = animateSequence(valueOrElementOrSequence, keyframes2, scope);
    } else if (isDOMKeyframes(keyframes2)) {
      animation2 = animateElements(valueOrElementOrSequence, keyframes2, options, scope);
    } else {
      animation2 = animateSingleValue(valueOrElementOrSequence, keyframes2, options);
    }
    if (scope) {
      scope.animations.push(animation2);
    }
    return animation2;
  }
  return scopedAnimate;
};
var animate = createScopedAnimate();

// node_modules/framer-motion/dist/es/utils/use-cycle.mjs
var import_react40 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-in-view.mjs
var import_react41 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/events/use-dom-event.mjs
var import_react42 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs
var import_react43 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/use-reset-projection.mjs
var React10 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/animation/hooks/use-animated-state.mjs
var import_react44 = __toESM(require_react(), 1);
var createObject = () => ({});
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});

// node_modules/framer-motion/dist/es/value/use-inverted-scale.mjs
var import_react45 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimateSharedLayout.mjs
var React11 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/frameloop/index-legacy.mjs
var cancelSync = stepsOrder.reduce((acc, key2) => {
  acc[key2] = (process4) => cancelFrame(process4);
  return acc;
}, {});

// node_modules/@sanity/ui/dist/index.esm.js
var EMPTY_ARRAY = [];
var EMPTY_RECORD = {};
var FLOATING_STATIC_SIDES = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key2) => {
    style[key2] = value;
    return style;
  }, {});
}
function rem(pixelValue) {
  if (pixelValue === 0)
    return 0;
  return "".concat(pixelValue / 16, "rem");
}
function _responsive(media, values2, callback) {
  const statements = (values2 == null ? void 0 : values2.map(callback)) || [];
  return statements.map((statement, mediaIndex) => {
    if (mediaIndex === 0)
      return statement;
    return {
      ["@media screen and (min-width: ".concat(media[mediaIndex - 1], "px)")]: statement
    };
  });
}
function _getArrayProp(val, defaultVal) {
  if (val === void 0)
    return defaultVal || EMPTY_ARRAY;
  return Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props2) {
  let spaceIndexes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EMPTY_ARRAY;
  if (!Array.isArray(spaceIndexes)) {
    throw new Error("the property must be array of numbers");
  }
  if (spaceIndexes.length === 0) {
    return null;
  }
  return _responsive(theme.sanity.media, spaceIndexes, (spaceIndex) => _fillCSSObject(props2, rem(theme.sanity.space[spaceIndex])));
}
function responsiveFont(fontKey, props2) {
  const {
    $size,
    $weight,
    theme
  } = props2;
  const {
    fonts: fonts2,
    media
  } = theme.sanity;
  const {
    family,
    sizes,
    weights
  } = fonts2[fontKey];
  const fontWeight = $weight && weights[$weight] || weights.regular;
  const defaultSize = sizes[2];
  const base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size) {
    if (!responsiveFont.warned) {
      console.warn("No size specified for responsive font", {
        fontKey,
        $size,
        props: props2,
        base
      });
      responsiveFont.warned = true;
    }
    return [base];
  }
  const resp = _responsive(media, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size2) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size2;
  const negHeight = ascenderHeight + descenderHeight;
  const capHeight = lineHeight - negHeight;
  const iconOffset = (capHeight - iconSize) / 2;
  const customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1;
  const customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: "calc(".concat(lineHeight, " / ").concat(fontSize2, ")"),
    letterSpacing: rem(letterSpacing),
    transform: "translateY(".concat(rem(descenderHeight), ")"),
    "&:before": {
      marginTop: "calc(".concat(rem(0 - negHeight), " - 1px)")
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: "calc(".concat(customIconSize, " / 16 * 1rem)"),
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: "calc(".concat(iconSize, " / 16 * 1rem)"),
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props2) {
  return responsiveFont("code", props2);
}
function responsiveHeadingFont(props2) {
  return responsiveFont("heading", props2);
}
function responsiveLabelFont(props2) {
  return responsiveFont("label", props2);
}
function responsiveTextAlignStyle(props2) {
  const {
    theme
  } = props2;
  return _responsive(theme.sanity.media, props2.$align, (textAlign) => {
    return {
      textAlign
    };
  });
}
function responsiveTextFont(props2) {
  return responsiveFont("text", props2);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = (0, import_react46.useMemo)(() => JSON.stringify(val != null ? val : defaultVal), [defaultVal, val]);
  return (0, import_react46.useMemo)(
    () => _getArrayProp(val, defaultVal),
    // Improve performance: Keep object identify for a given hash of the value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [__perf_hash__]
  );
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg) {
    if (Array.isArray(el)) {
      ret.push(...el);
    } else {
      ret.push(el);
    }
  }
  return ret.filter(Boolean);
}
function useClickOutside(listener) {
  let elementsArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EMPTY_ARRAY;
  let boundaryElement = arguments.length > 2 ? arguments[2] : void 0;
  const [element, setElement] = (0, import_react46.useState)(null);
  const [elements, setElements] = (0, import_react46.useState)(() => _getElements(element, elementsArg));
  const elementsRef = (0, import_react46.useRef)(elements);
  (0, import_react46.useEffect)(() => {
    const prevElements = elementsRef.current;
    const nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements);
      elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements) {
      if (!nextElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
    for (const el of nextElements) {
      if (!prevElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
  }, [element, elementsArg]);
  (0, import_react46.useEffect)(() => {
    if (!listener)
      return void 0;
    const handleWindowMouseDown = (evt) => {
      const target = evt.target;
      if (!(target instanceof Node)) {
        return;
      }
      if (boundaryElement && !boundaryElement.contains(target)) {
        return;
      }
      for (const el of elements) {
        if (target === el || el.contains(target)) {
          return;
        }
      }
      listener(evt);
    };
    window.addEventListener("mousedown", handleWindowMouseDown);
    return () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]);
  return setElement;
}
var resizeObservers = [];
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a4 = this, x = _a4.x, y = _a4.y, top = _a4.top, right = _a4.right, bottom2 = _a4.bottom, left = _a4.left, width = _a4.width, height = _a4.height;
    return {
      x,
      y,
      top,
      right,
      bottom: bottom2,
      left,
      width,
      height
    };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a4 = target.getBBox(), width = _a4.width, height = _a4.height;
    return !width && !height;
  }
  var _b4 = target, offsetWidth = _b4.offsetWidth, offsetHeight = _b4.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a4;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a4 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a4 === void 0 ? void 0 : _a4.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};
var global$1 = typeof window !== "undefined" ? window : {};
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size$1 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft2 + borderRight2;
  var verticalBorderArea = borderTop2 + borderBottom2;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a4 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a4.borderBoxSize, contentBoxSize = _a4.contentBoxSize, devicePixelContentBoxSize = _a4.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
    var callback = callbacks_1[_i2];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = {
      characterData: true
    };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver5() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();
var ResizeObserverDetail = function() {
  function ResizeObserverDetail2(resizeObserver2, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver2;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver2, callback) {
    var detail = new ResizeObserverDetail(resizeObserver2, callback);
    observerMap.set(resizeObserver2, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver2, target, options) {
    var detail = observerMap.get(resizeObserver2);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver2, target) {
    var detail = observerMap.get(resizeObserver2);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver2) {
    var _this = this;
    var detail = observerMap.get(resizeObserver2);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver2, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();
var ResizeObserver3 = function() {
  function ResizeObserver5(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver5.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver5.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver5.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver5.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver5;
}();
var _ResizeObserver = typeof document !== "undefined" && typeof window !== "undefined" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver3;
var _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver2 = new _ResizeObserver((_ref) => {
        let [entry] = _ref;
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      resizeObserver2.observe(element);
      return () => {
        resizeObserver2.unobserve(element);
        resizeObserver2.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap();
  const subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      if (!subscribersCache.has(element)) {
        subscribersCache.set(element, subscribers);
        const listener = _createElementRectValueListener();
        dispose = listener.subscribe(element, (elementRect) => {
          for (const sub2 of subscribers) {
            sub2(elementRect);
          }
        });
      }
      subscribers.push(subscriber);
      return () => {
        const idx = subscribers.indexOf(subscriber);
        if (idx > -1) {
          subscribers.splice(idx, 1);
        }
        if (subscribers.length === 0) {
          if (dispose)
            dispose();
        }
      };
    }
  };
}
function useElementSize(element) {
  const [size2, setSize] = (0, import_react46.useState)(null);
  (0, import_react46.useEffect)(() => {
    if (!element)
      return void 0;
    return _elementSizeObserver.subscribe(element, setSize);
  }, [element]);
  return size2;
}
function useElementRect(element) {
  const elementSize = useElementSize(element);
  return (elementSize == null ? void 0 : elementSize._contentRect) || null;
}
function useGlobalKeyDown(onKeyDown) {
  return (0, import_react46.useEffect)(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);
}
function multiplyChannel(b, s) {
  return b * s;
}
function multiply$1(b, s) {
  return {
    r: Math.round(clamp$1(multiplyChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp$1(multiplyChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp$1(multiplyChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp$1(num) {
  return Math.max(Math.min(num, 255), 0);
}
function screenChannel(b, s) {
  return b + s - b * s;
}
function screen$1(b, s) {
  return {
    r: Math.round(clamp2(screenChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp2(screenChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp2(screenChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp2(num) {
  return Math.max(Math.min(num, 255), 0);
}
function hexToRgb(hex2) {
  if (hex2.length === 4) {
    const hexR = hex2.slice(1, 2);
    const hexG = hex2.slice(2, 3);
    const hexB = hex2.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex2.slice(1, 3), 16),
    g: parseInt(hex2.slice(3, 5), 16),
    b: parseInt(hex2.slice(5, 7), 16)
  };
}
function rgbToHex(_ref2) {
  let {
    r: r2,
    g,
    b
  } = _ref2;
  return "#" + ((1 << 24) + (r2 << 16) + (g << 8) + b).toString(16).slice(1);
}
function hslToRgb(hsl) {
  const s = hsl.s / 100;
  const l = hsl.l / 100;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m2 = l - c / 2;
  let r2 = 0;
  let g = 0;
  let b = 0;
  if (0 <= hsl.h && hsl.h < 60) {
    r2 = c;
    g = x;
    b = 0;
  } else if (60 <= hsl.h && hsl.h < 120) {
    r2 = x;
    g = c;
    b = 0;
  } else if (120 <= hsl.h && hsl.h < 180) {
    r2 = 0;
    g = c;
    b = x;
  } else if (180 <= hsl.h && hsl.h < 240) {
    r2 = 0;
    g = x;
    b = c;
  } else if (240 <= hsl.h && hsl.h < 300) {
    r2 = x;
    g = 0;
    b = c;
  } else if (300 <= hsl.h && hsl.h < 360) {
    r2 = c;
    g = 0;
    b = x;
  }
  return {
    r: Math.round((r2 + m2) * 255),
    g: Math.round((g + m2) * 255),
    b: Math.round((b + m2) * 255)
  };
}
var HEX_CHARS = "0123456789ABCDEFabcdef";
var HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c of str) {
    if (HEX_CHARS.indexOf(c) === -1) {
      return false;
    }
  }
  return true;
}
function isHex(str) {
  if (str[0] !== "#")
    return false;
  if (!(str.length === 4 || str.length === 7))
    return false;
  return isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res) {
    throw new Error('parseHsl: string is not a HSL color: "'.concat(str, '"'));
  }
  return {
    h: parseInt(res[1]),
    s: parseFloat(res[3]),
    l: parseFloat(res[5])
  };
}
function parseColor(color3) {
  if (!color3)
    return {
      r: 0,
      g: 0,
      b: 0
    };
  if (typeof color3 !== "string") {
    throw new Error("parseColor: expected a string");
  }
  if (isHex(color3)) {
    return hexToRgb(color3);
  }
  if (color3.startsWith("hsl(")) {
    return hslToRgb(parseHsl(color3));
  }
  throw new Error('parseColor: unexpected color format: "'.concat(color3, '"'));
}
function rgba2(color3, a) {
  const rgb2 = parseColor(color3);
  return "rgba(".concat(rgb2.r, ",").concat(rgb2.g, ",").concat(rgb2.b, ",").concat(a, ")");
}
function createButtonTones(opts, base, dark, solid, muted, mode) {
  return {
    default: opts.button({
      base,
      dark,
      solid: solid.default,
      muted: muted.default,
      mode
    }),
    primary: opts.button({
      base,
      dark,
      solid: solid.primary,
      muted: muted.primary,
      mode
    }),
    positive: opts.button({
      base,
      dark,
      solid: solid.positive,
      muted: muted.positive,
      mode
    }),
    caution: opts.button({
      base,
      dark,
      solid: solid.caution,
      muted: muted.caution,
      mode
    }),
    critical: opts.button({
      base,
      dark,
      solid: solid.critical,
      muted: muted.critical,
      mode
    })
  };
}
function createButtonModes(opts, base, dark, solid, muted) {
  return {
    default: createButtonTones(opts, base, dark, solid, muted, "default"),
    ghost: createButtonTones(opts, base, dark, solid, muted, "ghost"),
    bleed: createButtonTones(opts, base, dark, solid, muted, "bleed")
  };
}
function createCardStates(opts, base, dark, name, solid, muted) {
  return {
    enabled: opts.card({
      base,
      dark,
      name,
      state: "enabled",
      solid,
      muted
    }),
    disabled: opts.card({
      base,
      dark,
      name,
      state: "disabled",
      solid,
      muted
    }),
    hovered: opts.card({
      base,
      dark,
      name,
      state: "hovered",
      solid,
      muted
    }),
    pressed: opts.card({
      base,
      dark,
      name,
      state: "pressed",
      solid,
      muted
    }),
    selected: opts.card({
      base,
      dark,
      name,
      state: "selected",
      solid,
      muted
    })
  };
}
var black2 = "hsl(0, 0%, 0%)";
var white2 = "hsl(0, 0%, 100%)";
var colors = {
  default: {
    lightest: "hsl(0, 0%, 95%)",
    lighter: "hsl(0, 0%, 70%)",
    light: "hsl(0, 0%, 65%)",
    base: "hsl(0, 0%, 50%)",
    dark: "hsl(0, 0%, 35%)",
    darker: "hsl(0, 0%, 20%)",
    darkest: "hsl(0, 0%, 5%)"
  },
  transparent: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  primary: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  positive: {
    lightest: "hsl(120, 100%, 95%)",
    lighter: "hsl(120, 100%, 70%)",
    light: "hsl(120, 100%, 65%)",
    base: "hsl(120, 100%, 50%)",
    dark: "hsl(120, 100%, 35%)",
    darker: "hsl(120, 100%, 20%)",
    darkest: "hsl(120, 100%, 5%)"
  },
  caution: {
    lightest: "hsl(60, 100%, 95%)",
    lighter: "hsl(60, 100%, 70%)",
    light: "hsl(60, 100%, 65%)",
    base: "hsl(60, 100%, 50%)",
    dark: "hsl(60, 100%, 35%)",
    darker: "hsl(60, 100%, 20%)",
    darkest: "hsl(60, 100%, 5%)"
  },
  critical: {
    lightest: "hsl(0, 100%, 95%)",
    lighter: "hsl(0, 100%, 70%)",
    light: "hsl(0, 100%, 65%)",
    base: "hsl(0, 100%, 50%)",
    dark: "hsl(0, 100%, 35%)",
    darker: "hsl(0, 100%, 20%)",
    darkest: "hsl(0, 100%, 5%)"
  }
};
var spots = {
  gray: "hsl(0, 0%, 50%)",
  red: "hsl(0, 100%, 50%)",
  orange: "hsl(30, 100%, 50%)",
  yellow: "hsl(60, 100%, 50%)",
  green: "hsl(120, 100%, 50%)",
  cyan: "hsl(180, 100%, 50%)",
  blue: "hsl(240, 100%, 50%)",
  purple: "hsl(270, 100%, 50%)",
  magenta: "hsl(300, 100%, 50%)"
};
var tones$1 = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base]
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base]
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base]
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base]
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base]
  }
};
var defaultOpts = {
  base: (_ref4) => {
    let {
      dark,
      name
    } = _ref4;
    if (name === "default") {
      return {
        bg: dark ? black2 : white2,
        fg: dark ? white2 : black2,
        border: dark ? colors.default.darkest : colors.default.lightest,
        focusRing: colors.primary.base,
        shadow: {
          outline: black2,
          umbra: black2,
          penumbra: black2,
          ambient: black2
        },
        skeleton: {
          from: dark ? white2 : black2,
          to: dark ? white2 : black2
        }
      };
    }
    return {
      bg: tones$1[name].bg[dark ? 0 : 1],
      fg: tones$1[name].fg[dark ? 0 : 1],
      border: tones$1[name].border[dark ? 0 : 1],
      focusRing: tones$1[name].focusRing[dark ? 0 : 1],
      shadow: {
        outline: black2,
        umbra: black2,
        penumbra: black2,
        ambient: black2
      },
      skeleton: {
        from: dark ? white2 : black2,
        to: dark ? white2 : black2
      }
    };
  },
  solid: (_ref5) => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref5;
    const color3 = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color3.light : color3.dark,
        bg2: dark ? color3.light : color3.dark,
        border: dark ? color3.lighter : color3.darker,
        fg: dark ? color3.darkest : color3.lightest,
        muted: {
          fg: black2
        },
        accent: {
          fg: black2
        },
        link: {
          fg: black2
        },
        code: {
          bg: black2,
          fg: black2
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: color3.base,
      bg2: color3.base,
      border: dark ? color3.light : color3.dark,
      fg: dark ? color3.darkest : color3.lightest,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  muted: (_ref6) => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref6;
    const color3 = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color3.darker : color3.lighter,
        bg2: dark ? color3.darker : color3.lighter,
        border: dark ? color3.lighter : color3.darker,
        fg: dark ? color3.lightest : color3.darkest,
        muted: {
          fg: black2
        },
        accent: {
          fg: black2
        },
        link: {
          fg: black2
        },
        code: {
          bg: black2,
          fg: black2
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: dark ? color3.darkest : color3.lightest,
      bg2: dark ? color3.darkest : color3.lightest,
      border: dark ? color3.darker : color3.lighter,
      fg: dark ? color3.lighter : color3.darker,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  button: (_ref7) => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref7;
    if (mode === "bleed") {
      return {
        ...muted,
        enabled: {
          bg: "transparent",
          bg2: "transparent",
          fg: muted.enabled.fg,
          border: "transparent",
          muted: {
            fg: black2
          },
          accent: {
            fg: black2
          },
          link: {
            fg: black2
          },
          code: {
            bg: black2,
            fg: black2
          },
          skeleton: base.skeleton
        },
        hovered: {
          bg: muted.enabled.bg,
          bg2: muted.enabled.bg,
          fg: muted.hovered.fg,
          border: "transparent",
          muted: {
            fg: black2
          },
          accent: {
            fg: black2
          },
          link: {
            fg: black2
          },
          code: {
            bg: black2,
            fg: black2
          },
          skeleton: base.skeleton
        }
      };
    }
    if (mode === "ghost")
      return {
        ...solid,
        enabled: muted.enabled
      };
    return solid;
  },
  card: (_ref8) => {
    let {
      base
    } = _ref8;
    return {
      bg: black2,
      bg2: black2,
      fg: black2,
      border: black2,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  input: () => {
    return {
      bg: black2,
      fg: black2,
      border: black2,
      placeholder: black2
    };
  },
  selectable: (_ref9) => {
    let {
      muted,
      state,
      tone
    } = _ref9;
    return muted[tone][state];
  },
  spot: (_ref10) => {
    let {
      key: key2
    } = _ref10;
    return spots[key2];
  },
  syntax: () => ({
    atrule: black2,
    attrName: black2,
    attrValue: black2,
    attribute: black2,
    boolean: black2,
    builtin: black2,
    cdata: black2,
    char: black2,
    class: black2,
    className: black2,
    comment: black2,
    constant: black2,
    deleted: black2,
    doctype: black2,
    entity: black2,
    function: black2,
    hexcode: black2,
    id: black2,
    important: black2,
    inserted: black2,
    keyword: black2,
    number: black2,
    operator: black2,
    prolog: black2,
    property: black2,
    pseudoClass: black2,
    pseudoElement: black2,
    punctuation: black2,
    regex: black2,
    selector: black2,
    string: black2,
    symbol: black2,
    tag: black2,
    unit: black2,
    url: black2,
    variable: black2
  })
};
function createInputModes(opts, base, dark, solid, muted) {
  return {
    default: {
      enabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "default",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "default",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    },
    invalid: {
      enabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    }
  };
}
function createMutedTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSelectableTones(opts, base, dark, solid, muted) {
  return {
    default: _createSelectableStates(opts, base, dark, solid, muted, "default"),
    primary: _createSelectableStates(opts, base, dark, solid, muted, "primary"),
    positive: _createSelectableStates(opts, base, dark, solid, muted, "positive"),
    caution: _createSelectableStates(opts, base, dark, solid, muted, "caution"),
    critical: _createSelectableStates(opts, base, dark, solid, muted, "critical")
  };
}
function _createSelectableStates(opts, base, dark, solid, muted, tone) {
  return {
    enabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "enabled",
      tone
    }),
    hovered: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "hovered",
      tone
    }),
    pressed: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "pressed",
      tone
    }),
    selected: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "selected",
      tone
    }),
    disabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "disabled",
      tone
    })
  };
}
function createSolidTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSpot(opts, base, dark) {
  return {
    gray: opts.spot({
      base,
      dark,
      key: "gray"
    }),
    blue: opts.spot({
      base,
      dark,
      key: "blue"
    }),
    purple: opts.spot({
      base,
      dark,
      key: "purple"
    }),
    magenta: opts.spot({
      base,
      dark,
      key: "magenta"
    }),
    red: opts.spot({
      base,
      dark,
      key: "red"
    }),
    orange: opts.spot({
      base,
      dark,
      key: "orange"
    }),
    yellow: opts.spot({
      base,
      dark,
      key: "yellow"
    }),
    green: opts.spot({
      base,
      dark,
      key: "green"
    }),
    cyan: opts.spot({
      base,
      dark,
      key: "cyan"
    })
  };
}
function createColorTheme() {
  let partialOpts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const builders = {
    ...defaultOpts,
    ...partialOpts
  };
  return {
    light: _createColorScheme(builders, false),
    dark: _createColorScheme(builders, true)
  };
}
function _createColorScheme(opts, dark) {
  return {
    default: _createColor(opts, dark, "default"),
    transparent: _createColor(opts, dark, "transparent"),
    primary: _createColor(opts, dark, "primary"),
    positive: _createColor(opts, dark, "positive"),
    caution: _createColor(opts, dark, "caution"),
    critical: _createColor(opts, dark, "critical")
  };
}
function _createColor(opts, dark, name) {
  const base = opts.base({
    dark,
    name
  });
  const solid = createSolidTones(opts, base, dark, name);
  const muted = createMutedTones(opts, base, dark, name);
  return {
    base,
    button: createButtonModes(opts, base, dark, solid, muted),
    card: createCardStates(opts, base, dark, name, solid, muted),
    dark,
    input: createInputModes(opts, base, dark, solid, muted),
    selectable: createSelectableTones(opts, base, dark, solid, muted),
    spot: createSpot(opts, base, dark),
    syntax: opts.syntax({
      base,
      dark
    }),
    solid,
    muted
  };
}
function multiply(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex2 = rgbToHex(multiply$1(b, s));
  return hex2;
}
function screen(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex2 = rgbToHex(screen$1(b, s));
  return hex2;
}
var tones = {
  default: hues.gray,
  transparent: hues.gray,
  primary: hues.blue,
  positive: hues.green,
  caution: hues.yellow,
  critical: hues.red
};
var NEUTRAL_TONES = ["default", "transparent"];
var color2 = createColorTheme({
  base: (_ref11) => {
    let {
      dark,
      name
    } = _ref11;
    if (name === "default") {
      const tints2 = hues.gray;
      const skeletonFrom2 = dark ? tints2[900].hex : tints2[100].hex;
      return {
        fg: dark ? white.hex : black.hex,
        bg: dark ? black.hex : white.hex,
        border: tints2[dark ? 800 : 200].hex,
        focusRing: hues.blue[dark ? 500 : 500].hex,
        shadow: {
          outline: rgba2(tints2[500].hex, 0.4),
          umbra: dark ? rgba2(tints2[950].hex, 0.4) : rgba2(tints2[500].hex, 0.2),
          penumbra: dark ? rgba2(tints2[950].hex, 0.28) : rgba2(tints2[500].hex, 0.14),
          ambient: dark ? rgba2(tints2[950].hex, 0.24) : rgba2(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    if (name === "transparent") {
      const tints2 = tones.default;
      const skeletonFrom2 = tints2[dark ? 800 : 200].hex;
      return {
        fg: tints2[dark ? 100 : 900].hex,
        bg: tints2[dark ? 950 : 50].hex,
        border: tints2[dark ? 800 : 300].hex,
        focusRing: hues.blue[500].hex,
        shadow: {
          outline: rgba2(tints2[500].hex, 0.4),
          umbra: dark ? rgba2(tints2[900].hex, 0.4) : rgba2(tints2[500].hex, 0.2),
          penumbra: dark ? rgba2(tints2[900].hex, 0.28) : rgba2(tints2[500].hex, 0.14),
          ambient: dark ? rgba2(tints2[900].hex, 0.24) : rgba2(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    const tints = tones[name] || tones.default;
    const skeletonFrom = tints[dark ? 800 : 200].hex;
    return {
      fg: tints[dark ? 100 : 900].hex,
      bg: tints[dark ? 950 : 50].hex,
      border: tints[dark ? 800 : 200].hex,
      focusRing: tints[500].hex,
      shadow: {
        outline: rgba2(tints[500].hex, 0.4),
        umbra: dark ? rgba2(tints[900].hex, 0.4) : rgba2(tints[500].hex, 0.2),
        penumbra: dark ? rgba2(tints[900].hex, 0.28) : rgba2(tints[500].hex, 0.14),
        ambient: dark ? rgba2(tints[900].hex, 0.24) : rgba2(tints[500].hex, 0.12)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba2(skeletonFrom, 0.5)
      }
    };
  },
  solid: (_ref12) => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref12;
    const mix2 = dark ? screen : multiply;
    const mix22 = dark ? multiply : screen;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = mix2(base.bg, tints[dark ? 800 : 200].hex);
      const skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
        border: mix2(base.bg, tints[dark ? 800 : 200].hex),
        fg: mix2(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 950 : 50].hex)
        },
        accent: {
          fg: mix2(base.bg, tints[dark ? 950 : 50].hex)
        },
        link: {
          fg: mix2(base.bg, tints[dark ? 950 : 50].hex)
        },
        code: {
          bg: bg2,
          fg: mix2(base.bg, tints[dark ? 950 : 50].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix2(base.bg, tints[dark ? 300 : 600].hex);
      const skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
        border: mix2(base.bg, tints[dark ? 300 : 600].hex),
        fg: mix2(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix22(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix22(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix2(bg2, tints[dark ? 950 : 50].hex),
          fg: mix2(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      const bg2 = mix2(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: mix2(base.bg, tints[dark ? 200 : 800].hex),
        bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
        border: mix2(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix2(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix22(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix22(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix2(bg2, tints[dark ? 950 : 50].hex),
          fg: mix2(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix2(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
        border: mix2(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix2(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix22(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix22(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix2(bg2, tints[dark ? 950 : 50].hex),
          fg: mix2(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = mix2(base.bg, tints[dark ? 400 : 500].hex);
    const skeletonFrom = mix22(bg, tints[dark ? 200 : 800].hex);
    return {
      bg,
      bg2: mix22(bg, tints[dark ? 50 : 950].hex),
      border: mix2(base.bg, tints[dark ? 400 : 500].hex),
      fg: mix2(base.bg, dark ? black.hex : white.hex),
      muted: {
        fg: mix2(base.bg, tints[dark ? 900 : 100].hex)
      },
      accent: {
        fg: mix22(bg, hues.red[dark ? 900 : 100].hex)
      },
      link: {
        fg: mix22(bg, hues.blue[dark ? 900 : 100].hex)
      },
      code: {
        bg: mix2(bg, tints[dark ? 950 : 50].hex),
        fg: mix2(base.bg, tints[dark ? 900 : 100].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba2(skeletonFrom, 0.5)
      }
    };
  },
  muted: (_ref13) => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref13;
    const mix2 = dark ? screen : multiply;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = base.bg;
      const skeletonFrom2 = mix2(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 950 : 50].hex),
        border: mix2(bg2, tints[dark ? 950 : 50].hex),
        fg: mix2(bg2, tints[dark ? 800 : 200].hex),
        muted: {
          fg: mix2(bg2, tints[dark ? 900 : 100].hex)
        },
        accent: {
          fg: mix2(bg2, tints[dark ? 900 : 100].hex)
        },
        link: {
          fg: mix2(bg2, tints[dark ? 900 : 100].hex)
        },
        code: {
          bg: bg2,
          fg: mix2(bg2, tints[dark ? 900 : 100].hex)
        },
        skeleton: {
          from: rgba2(skeletonFrom2, 0.5),
          to: rgba2(skeletonFrom2, 0.25)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix2(base.bg, tints[dark ? 950 : 50].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 950 : 50].hex),
        border: mix2(bg2, tints[dark ? 900 : 100].hex),
        fg: mix2(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix2(base.bg, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix2(base.bg, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix2(bg2, tints[dark ? 950 : 50].hex),
          fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix2(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 950 : 50].hex),
        border: mix2(bg2, tints[dark ? 900 : 100].hex),
        fg: mix2(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix2(bg2, tints[dark ? 950 : 50].hex),
          fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix2(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 950 : 50].hex),
        border: mix2(bg2, tints[dark ? 900 : 100].hex),
        fg: mix2(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix2(bg2, tints[dark ? 950 : 50].hex),
          fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba2(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = base.bg;
    const skeletonFrom = mix2(bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix2(bg, tints[dark ? 950 : 50].hex),
      border: mix2(bg, tints[dark ? 900 : 100].hex),
      fg: mix2(base.bg, tints[dark ? 300 : 700].hex),
      muted: {
        fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix2(base.bg, hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix2(base.bg, hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix2(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba2(skeletonFrom, 0.5)
      }
    };
  },
  button: (_ref14) => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref14;
    if (mode === "bleed") {
      return {
        enabled: {
          ...muted.enabled,
          border: muted.enabled.bg
        },
        hovered: {
          ...muted.hovered,
          border: muted.hovered.bg
        },
        pressed: {
          ...muted.pressed,
          border: muted.pressed.bg
        },
        selected: {
          ...muted.selected,
          border: muted.selected.bg
        },
        disabled: {
          ...muted.disabled,
          border: muted.disabled.bg
        }
      };
    }
    if (mode === "ghost") {
      return {
        ...solid,
        enabled: {
          ...muted.enabled,
          border: base.border
        },
        disabled: muted.disabled
      };
    }
    return solid;
  },
  card: (_ref15) => {
    let {
      base,
      dark,
      muted,
      name,
      solid,
      state
    } = _ref15;
    if (state === "hovered") {
      return muted[name].hovered;
    }
    if (state === "disabled") {
      return muted[name].disabled;
    }
    const isNeutral = NEUTRAL_TONES.includes(name);
    const tints = tones[name] || tones.default;
    const mix2 = dark ? screen : multiply;
    if (state === "pressed") {
      if (isNeutral) {
        return muted.primary.pressed;
      }
      return muted[name].pressed;
    }
    if (state === "selected") {
      if (isNeutral) {
        return solid.primary.enabled;
      }
      return solid[name].enabled;
    }
    const bg = base.bg;
    const skeletonFrom = mix2(base.bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix2(bg, tints[dark ? 950 : 50].hex),
      fg: base.fg,
      border: base.border,
      muted: {
        fg: mix2(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix2(base.bg, hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix2(base.bg, hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix2(base.bg, tints[dark ? 950 : 50].hex),
        fg: tints[dark ? 400 : 600].hex
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba2(skeletonFrom, 0.5)
      }
    };
  },
  input: (_ref16) => {
    let {
      base,
      dark,
      mode,
      state
    } = _ref16;
    const mix2 = dark ? screen : multiply;
    if (mode === "invalid") {
      const tints = tones.critical;
      return {
        bg: mix2(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix2(base.bg, tints[dark ? 400 : 600].hex),
        border: mix2(base.bg, tints[dark ? 800 : 200].hex),
        placeholder: mix2(base.bg, tints[dark ? 600 : 400].hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: base.bg,
        fg: base.fg,
        border: mix2(base.bg, hues.gray[dark ? 700 : 300].hex),
        placeholder: mix2(base.bg, hues.gray[dark ? 600 : 400].hex)
      };
    }
    if (state === "disabled") {
      return {
        bg: mix2(base.bg, hues.gray[dark ? 950 : 50].hex),
        fg: mix2(base.bg, hues.gray[dark ? 700 : 300].hex),
        border: mix2(base.bg, hues.gray[dark ? 900 : 100].hex),
        placeholder: mix2(base.bg, hues.gray[dark ? 800 : 200].hex)
      };
    }
    if (state === "readOnly") {
      return {
        bg: mix2(base.bg, hues.gray[dark ? 950 : 50].hex),
        fg: mix2(base.bg, hues.gray[dark ? 200 : 800].hex),
        border: mix2(base.bg, hues.gray[dark ? 800 : 200].hex),
        placeholder: mix2(base.bg, hues.gray[dark ? 600 : 400].hex)
      };
    }
    return {
      bg: base.bg,
      fg: base.fg,
      border: base.border,
      placeholder: mix2(base.bg, hues.gray[dark ? 600 : 400].hex)
    };
  },
  selectable: (_ref17) => {
    let {
      base,
      muted,
      tone,
      solid,
      state
    } = _ref17;
    if (state === "enabled") {
      return {
        ...muted[tone].enabled,
        bg: base.bg
      };
    }
    if (state === "pressed") {
      if (tone === "default") {
        return muted.primary.pressed;
      }
      return muted[tone].pressed;
    }
    if (state === "selected") {
      if (tone === "default") {
        return solid.primary.enabled;
      }
      return solid[tone].enabled;
    }
    if (state === "disabled") {
      return {
        ...muted[tone].disabled,
        bg: base.bg
      };
    }
    return muted[tone][state];
  },
  spot: (_ref18) => {
    let {
      base,
      dark,
      key: key2
    } = _ref18;
    const mix2 = dark ? screen : multiply;
    return mix2(base.bg, hues[key2][dark ? 400 : 500].hex);
  },
  syntax: (_ref19) => {
    let {
      base,
      dark
    } = _ref19;
    const mix2 = dark ? screen : multiply;
    const mainShade = dark ? 400 : 600;
    const secondaryShade = dark ? 600 : 400;
    return {
      atrule: mix2(base.bg, hues.purple[mainShade].hex),
      attrName: mix2(base.bg, hues.green[mainShade].hex),
      attrValue: mix2(base.bg, hues.yellow[mainShade].hex),
      attribute: mix2(base.bg, hues.yellow[mainShade].hex),
      boolean: mix2(base.bg, hues.purple[mainShade].hex),
      builtin: mix2(base.bg, hues.purple[mainShade].hex),
      cdata: mix2(base.bg, hues.yellow[mainShade].hex),
      char: mix2(base.bg, hues.yellow[mainShade].hex),
      class: mix2(base.bg, hues.orange[mainShade].hex),
      className: mix2(base.bg, hues.cyan[mainShade].hex),
      comment: mix2(base.bg, hues.gray[secondaryShade].hex),
      constant: mix2(base.bg, hues.purple[mainShade].hex),
      deleted: mix2(base.bg, hues.red[mainShade].hex),
      doctype: mix2(base.bg, hues.gray[secondaryShade].hex),
      entity: mix2(base.bg, hues.red[mainShade].hex),
      function: mix2(base.bg, hues.green[mainShade].hex),
      hexcode: mix2(base.bg, hues.blue[mainShade].hex),
      id: mix2(base.bg, hues.purple[mainShade].hex),
      important: mix2(base.bg, hues.purple[mainShade].hex),
      inserted: mix2(base.bg, hues.yellow[mainShade].hex),
      keyword: mix2(base.bg, hues.magenta[mainShade].hex),
      number: mix2(base.bg, hues.purple[mainShade].hex),
      operator: mix2(base.bg, hues.magenta[mainShade].hex),
      prolog: mix2(base.bg, hues.gray[secondaryShade].hex),
      property: mix2(base.bg, hues.blue[mainShade].hex),
      pseudoClass: mix2(base.bg, hues.yellow[mainShade].hex),
      pseudoElement: mix2(base.bg, hues.yellow[mainShade].hex),
      punctuation: mix2(base.bg, hues.gray[mainShade].hex),
      regex: mix2(base.bg, hues.blue[mainShade].hex),
      selector: mix2(base.bg, hues.red[mainShade].hex),
      string: mix2(base.bg, hues.yellow[mainShade].hex),
      symbol: mix2(base.bg, hues.purple[mainShade].hex),
      tag: mix2(base.bg, hues.red[mainShade].hex),
      unit: mix2(base.bg, hues.orange[mainShade].hex),
      url: mix2(base.bg, hues.red[mainShade].hex),
      variable: mix2(base.bg, hues.red[mainShade].hex)
    };
  }
});
var fonts = {
  code: {
    family: "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 3,
      descenderHeight: 3,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 13,
      letterSpacing: 0
    }, {
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 25,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }]
  },
  heading: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 700,
      medium: 800,
      semibold: 900,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 12,
      iconSize: 17,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 27,
      iconSize: 41,
      lineHeight: 33,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 33,
      iconSize: 49,
      lineHeight: 39,
      letterSpacing: 0
    }, {
      ascenderHeight: 9,
      descenderHeight: 9,
      fontSize: 38,
      iconSize: 53,
      lineHeight: 45,
      letterSpacing: 0
    }]
  },
  label: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
    weights: {
      regular: 600,
      medium: 700,
      semibold: 800,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 9.8,
      iconSize: 15,
      lineHeight: 11,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 11.25,
      iconSize: 17,
      lineHeight: 12,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 12.75,
      iconSize: 19,
      lineHeight: 13,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 14,
      iconSize: 21,
      lineHeight: 14,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 15.5,
      iconSize: 23,
      lineHeight: 15,
      letterSpacing: 0.5
    }]
  },
  text: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 3,
      descenderHeight: 3,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 13,
      letterSpacing: 0
    }, {
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 25,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }]
  }
};
var studioTheme = {
  avatar: {
    sizes: [{
      distance: -3,
      size: 25
    }, {
      distance: -6,
      size: 35
    }, {
      distance: -9,
      size: 55
    }]
  },
  button: {
    textWeight: "medium"
  },
  color: color2,
  container: [320, 640, 960, 1280, 1600, 1920],
  focusRing: {
    offset: 1,
    width: 2
  },
  fonts,
  media: [360, 600, 900, 1200, 1800, 2400],
  radius: [0, 1, 3, 6, 9, 12, 21],
  shadows: [null, {
    umbra: [0, 0, 0, 0],
    penumbra: [0, 0, 0, 0],
    ambient: [0, 0, 0, 0]
  }, {
    umbra: [0, 3, 5, -1],
    penumbra: [0, 6, 10, 0],
    ambient: [0, 1, 18, 0]
  }, {
    umbra: [0, 7, 8, -4],
    penumbra: [0, 12, 17, 2],
    ambient: [0, 5, 22, 4]
  }, {
    umbra: [0, 9, 11, -5],
    penumbra: [0, 18, 28, 2],
    ambient: [0, 7, 34, 6]
  }, {
    umbra: [0, 11, 15, -7],
    penumbra: [0, 24, 38, 3],
    ambient: [0, 9, 46, 8]
  }],
  space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
  input: {
    checkbox: {
      size: 17
    },
    radio: {
      size: 17,
      markSize: 9
    },
    switch: {
      width: 33,
      height: 17,
      padding: 4,
      transitionDurationMs: 150,
      transitionTimingFunction: "ease-out"
    },
    border: {
      width: 1
    }
  }
  // styles: {
  //   button: {
  //     root: {
  //       transition: 'background-color 100ms,border-color 100ms,color 100ms',
  //     },
  //   },
  //   card: {
  //     root: {
  //       transition: 'background-color 100ms,border-color 100ms,color 100ms',
  //     },
  //   },
  // },
};
var DEFAULT_THEME_LAYER = {
  dialog: {
    zOffset: 600
  },
  popover: {
    zOffset: 400
  },
  tooltip: {
    zOffset: 200
  }
};
function getGlobalScope() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof window !== "undefined")
    return window;
  if (typeof self !== "undefined")
    return self;
  if (typeof global !== "undefined")
    return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
var globalScope = getGlobalScope();
var key$8 = Symbol.for("@sanity/ui/context/theme");
globalScope[key$8] = globalScope[key$8] || (0, import_react46.createContext)(null);
var ThemeContext = globalScope[key$8];
function ThemeProvider(props2) {
  const parentTheme = (0, import_react46.useContext)(ThemeContext);
  const {
    children,
    scheme = (parentTheme == null ? void 0 : parentTheme.scheme) || "light",
    theme: themeProp = (parentTheme == null ? void 0 : parentTheme.theme) || null,
    tone = (parentTheme == null ? void 0 : parentTheme.tone) || "default"
  } = props2;
  const theme = (0, import_react46.useMemo)(() => {
    if (!themeProp)
      return null;
    const {
      color: rootColor,
      layer: rootLayer,
      ...restTheme
    } = themeProp;
    const colorScheme = rootColor[scheme] || rootColor.light;
    const color3 = colorScheme[tone] || colorScheme.default;
    const layer = rootLayer || DEFAULT_THEME_LAYER;
    return {
      sanity: {
        ...restTheme,
        color: color3,
        layer
      }
    };
  }, [scheme, themeProp, tone]);
  const value = (0, import_react46.useMemo)(() => themeProp && {
    version: 0,
    theme: themeProp,
    scheme,
    tone
  }, [themeProp, scheme, tone]);
  if (!theme) {
    return (0, import_jsx_runtime2.jsx)("pre", {
      children: 'ThemeProvider: no "theme" property provided'
    });
  }
  return (0, import_jsx_runtime2.jsx)(ThemeContext.Provider, {
    value,
    children: (0, import_jsx_runtime2.jsx)(Xe, {
      theme,
      children
    })
  });
}
function isRecord2(value) {
  return Boolean(value && typeof value === "object");
}
function useRootTheme() {
  const value = (0, import_react46.useContext)(ThemeContext);
  if (!value) {
    throw new Error("useRootTheme(): missing context value");
  }
  if (!isRecord2(value) || value.version !== 0) {
    throw new Error("useRootTheme(): the context value is not compatible");
  }
  return value;
}
function ThemeColorProvider(props2) {
  const {
    children,
    scheme,
    tone
  } = props2;
  const root = useRootTheme();
  return (0, import_jsx_runtime2.jsx)(ThemeProvider, {
    scheme: scheme || root.scheme,
    theme: root.theme,
    tone,
    children
  });
}
function useTheme() {
  return Je();
}
var MEDIA_STORE_CACHE = /* @__PURE__ */ new WeakMap();
function _getMediaQuery(media, index) {
  if (index === 0) {
    return "screen and (max-width: ".concat(media[index] - 1, "px)");
  }
  if (index === media.length) {
    return "screen and (min-width: ".concat(media[index - 1], "px)");
  }
  return "screen and (min-width: ".concat(media[index - 1], "px) and (max-width: ").concat(media[index] - 1, "px)");
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index = mediaLen; index > -1; index -= 1) {
        const mediaQuery = _getMediaQuery(media, index);
        sizes.push({
          index,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  const getSnapshot = () => {
    for (const {
      index,
      mq
    } of getSizes()) {
      if (mq.matches)
        return index;
    }
    return 0;
  };
  const subscribe = (onStoreChange) => {
    const disposeFns = [];
    for (const {
      mq
    } of getSizes()) {
      const handleChange = () => {
        if (mq.matches)
          onStoreChange();
      };
      mq.addEventListener("change", handleChange);
      disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns) {
        disposeFn();
      }
    };
  };
  return {
    getSnapshot,
    subscribe
  };
}
function getServerSnapshot$2() {
  return 0;
}
function useMediaIndex() {
  const theme = useTheme();
  const {
    media
  } = theme.sanity;
  let store = MEDIA_STORE_CACHE.get(media);
  if (!store) {
    store = _createMediaStore(media);
    MEDIA_STORE_CACHE.set(media, store);
  }
  return (0, import_react46.useSyncExternalStore)(store.subscribe, store.getSnapshot, getServerSnapshot$2);
}
var MEDIA_QUERY_CACHE$1;
function getMatchMedia$1() {
  if (!MEDIA_QUERY_CACHE$1) {
    MEDIA_QUERY_CACHE$1 = window.matchMedia("(prefers-color-scheme: dark)");
  }
  return MEDIA_QUERY_CACHE$1;
}
function subscribe$1(onStoreChange) {
  const matchMedia = getMatchMedia$1();
  matchMedia.addEventListener("change", onStoreChange);
  return () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot$1() {
  return getMatchMedia$1().matches;
}
function getServerSnapshot$1() {
  return false;
}
function usePrefersDark() {
  return (0, import_react46.useSyncExternalStore)(subscribe$1, getSnapshot$1, getServerSnapshot$1);
}
var useIsomorphicEffect = typeof window !== "undefined" ? import_react46.useLayoutEffect : import_react46.useEffect;
function useForwardedRef(ref) {
  const innerRef = (0, import_react46.useRef)(null);
  useIsomorphicEffect(() => {
    if (!ref)
      return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
function useCustomValidity(ref, customValidity) {
  (0, import_react46.useEffect)(() => {
    if (ref.current) {
      ref.current.setCustomValidity(customValidity || "");
    }
  }, [customValidity, ref]);
}
var BORDER_VALUE = "1px solid var(--card-border-color)";
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$border, (value) => value ? {
    "&&": {
      border: BORDER_VALUE
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$borderTop, (value) => value ? {
    "&&": {
      borderTop: BORDER_VALUE
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$borderRight, (value) => value ? {
    "&&": {
      borderRight: BORDER_VALUE
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$borderBottom, (value) => value ? {
    "&&": {
      borderBottom: BORDER_VALUE
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$borderLeft, (value) => value ? {
    "&&": {
      borderLeft: BORDER_VALUE
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
var BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
var BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$display, (display) => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$overflow, (overflow) => ({
    overflow
  }));
}
var BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$3, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$align, (align2) => {
    return {
      alignItems: align2
    };
  });
}
function responsiveFlexGapStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props2.$gap, (gap) => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$wrap, (wrap5) => {
    return {
      flexWrap: wrap5
    };
  });
}
function responsiveFlexJustifyStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$justify, (justify) => {
    return {
      justifyContent: justify
    };
  });
}
function responsiveFlexDirectionStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$direction, (direction) => {
    return {
      flexDirection: direction
    };
  });
}
var BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  if (!props2.$flex)
    return EMPTY_ARRAY;
  return _responsive(media, props2.$flex, (flex) => ({
    flex
  }));
}
function focusRingBorderStyle(border2) {
  return "inset 0 0 0 ".concat(border2.width, "px ").concat(border2.color);
}
function focusRingStyle(opts) {
  const {
    base,
    border: border2,
    focusRing
  } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border2 && focusRingBorderStyle(border2), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
var GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
var GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$columns, (columns) => ({
    gridTemplateColumns: columns && "repeat(".concat(columns, ",minmax(0,1fr));")
  }));
}
function responsiveGridRowsStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$rows, (rows) => ({
    gridTemplateRows: rows && "repeat(".concat(rows, ",minmax(0,1fr));")
  }));
}
function responsiveGridGapStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props2.$gap, (gap) => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props2.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props2.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
var GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
var GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$row, (row) => {
    if (typeof row === "number") {
      return {
        gridRow: "span ".concat(row, " / span ").concat(row)
      };
    }
    return {
      gridRow: GRID_ITEM_ROW[row]
    };
  });
}
function responsiveGridItemRowStartStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$rowStart, (rowStart) => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$rowEnd, (rowEnd) => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$column, (column) => {
    if (typeof column === "number") {
      return {
        gridColumn: "span ".concat(column, " / span ").concat(column)
      };
    }
    return {
      gridColumn: GRID_ITEM_COLUMN[column]
    };
  });
}
function responsiveGridItemColumnStartStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$columnStart, (columnStart) => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$columnEnd, (columnEnd) => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props2) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space,
    theme
  } = props2;
  const {
    fonts: fonts2,
    media,
    space: spaceScale
  } = theme.sanity;
  const len = Math.max($padding.length, $space.length, $fontSize.length);
  const _padding = [];
  const _space = [];
  const _fontSize = [];
  for (let i = 0; i < len; i += 1) {
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i];
    _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i];
    _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  }
  return _responsive(media, _padding, (_, i) => {
    const size2 = fonts2.text.sizes[_fontSize[i]] || fonts2.text.sizes[2];
    const emSize = size2.lineHeight - size2.ascenderHeight - size2.descenderHeight;
    const p = spaceScale[_padding[i]];
    const s = spaceScale[_space[i]];
    const styles = {
      paddingTop: rem(p - size2.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size2.descenderHeight),
      paddingLeft: rem(p)
    };
    if ($iconRight)
      styles.paddingRight = rem(p + emSize + s);
    if ($iconLeft)
      styles.paddingLeft = rem(p + emSize + s);
    return styles;
  });
}
function responsiveInputPaddingIconRightStyle(props2) {
  return responsiveInputPaddingStyle({
    ...props2,
    $iconRight: true
  });
}
var __freeze$D = Object.freeze;
var __defProp$E = Object.defineProperty;
var __template$D = (cooked, raw) => __freeze$D(__defProp$E(cooked, "raw", {
  value: __freeze$D(raw || cooked.slice())
}));
var _a$D;
var _b$m;
var _c$d;
var ROOT_STYLE = nt(_a$D || (_a$D = __template$D(["\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  align-items: center;\n"])));
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props2) {
  const {
    theme,
    $scheme,
    $tone,
    $weight
  } = props2;
  const font = theme.sanity.fonts.text;
  const color3 = theme.sanity.color.input;
  return nt(_b$m || (_b$m = __template$D(["\n    appearance: none;\n    background: none;\n    border: 0;\n    border-radius: 0;\n    outline: none;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: ", ";\n    font-weight: ", ";\n    margin: 0;\n    position: relative;\n    z-index: 1;\n    display: block;\n\n    /* NOTE: This is a hack to disable Chromes autofill styles */\n    &:-webkit-autofill,\n    &:-webkit-autofill:hover,\n    &:-webkit-autofill:focus,\n    &:-webkit-autofill:active {\n      -webkit-text-fill-color: var(--input-fg-color) !important;\n      transition: background-color 5000s;\n      transition-delay: 86400s /* 24h */;\n    }\n\n    /* &:is(textarea) */\n    &[data-as='textarea'] {\n      resize: none;\n    }\n\n    color: var(--input-fg-color);\n\n    &::placeholder {\n      color: var(--input-placeholder-color);\n    }\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --input-fg-color: ", ";\n      --input-placeholder-color: ", ";\n\n      /* enabled */\n      &:not(:invalid):not(:disabled):not(:read-only) {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* disabled */\n      &:not(:invalid):disabled {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* invalid */\n      &:invalid {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* readOnly */\n      &:read-only {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n    }\n  "])), font.family, $weight && font.weights[$weight] || font.weights.regular, $scheme, $tone, color3.default.enabled.fg, color3.default.enabled.placeholder, color3.default.enabled.fg, color3.default.enabled.placeholder, color3.default.disabled.fg, color3.default.disabled.placeholder, color3.invalid.enabled.fg, color3.invalid.enabled.placeholder, color3.default.readOnly.fg, color3.default.readOnly.placeholder);
}
function textInputFontSizeStyle(props2) {
  const {
    theme
  } = props2;
  const {
    fonts: fonts2,
    media
  } = theme.sanity;
  return _responsive(media, props2.$fontSize, (sizeIndex) => {
    const size2 = fonts2.text.sizes[sizeIndex] || fonts2.text.sizes[2];
    return {
      fontSize: rem(size2.fontSize),
      lineHeight: size2.lineHeight / size2.fontSize
    };
  });
}
function textInputRepresentationStyle(props2) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    theme
  } = props2;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color3 = theme.sanity.color.input;
  return nt(_c$d || (_c$d = __template$D(["\n    --input-box-shadow: none;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: block;\n    pointer-events: none;\n    z-index: 0;\n\n    background-color: var(--card-bg-color);\n    box-shadow: var(--input-box-shadow);\n\n    border-top-left-radius: ", ";\n    border-bottom-left-radius: ", ";\n    border-top-right-radius: ", ";\n    border-bottom-right-radius: ", ";\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --card-bg-color: ", ";\n      --card-fg-color: ", ";\n\n      /* enabled */\n      *:not(:disabled) + &[data-border] {\n        --input-box-shadow: ", ";\n      }\n\n      /* invalid */\n      *:not(:disabled):invalid + & {\n        --card-bg-color: ", ";\n        --card-fg-color: ", ";\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* focused */\n      *:not(:disabled):focus + & {\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n\n        &:not([data-border]) {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* disabled */\n      *:disabled + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* readOnly */\n      *:read-only + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n      }\n\n      /* hovered */\n      @media (hover: hover) {\n        *:not(:disabled):not(:read-only):not(:invalid):hover + & {\n          --card-bg-color: ", ";\n          --card-fg-color: ", ";\n        }\n\n        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n    }\n  "])), $hasPrefix ? 0 : void 0, $hasPrefix ? 0 : void 0, $hasSuffix ? 0 : void 0, $hasSuffix ? 0 : void 0, $scheme, $tone, color3.default.enabled.bg, color3.default.enabled.fg, focusRingBorderStyle({
    color: color3.default.enabled.border,
    width: input.border.width
  }), color3.invalid.enabled.bg, color3.invalid.enabled.fg, focusRingBorderStyle({
    color: color3.invalid.enabled.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      color: color3.default.enabled.border,
      width: input.border.width
    },
    focusRing
  }), focusRingStyle({
    focusRing
  }), color3.default.disabled.bg, color3.default.disabled.fg, focusRingBorderStyle({
    color: color3.default.disabled.border,
    width: input.border.width
  }), color3.default.readOnly.bg, color3.default.readOnly.fg, color3.default.hovered.bg, color3.default.hovered.fg, focusRingBorderStyle({
    color: color3.default.hovered.border,
    width: input.border.width
  }));
}
function responsiveMarginStyle(props2) {
  const {
    theme
  } = props2;
  return [_getResponsiveSpace(theme, ["margin"], props2.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props2.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props2.$marginY), _getResponsiveSpace(theme, ["marginTop"], props2.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props2.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props2.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props2.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props2) {
  const {
    theme
  } = props2;
  return [_getResponsiveSpace(theme, ["padding"], props2.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props2.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props2.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props2.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props2.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props2.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props2.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    radius
  } = theme.sanity;
  return _responsive(media, props2.$radius, (radiusIndex) => ({
    borderRadius: rem(radius[radiusIndex])
  }));
}
function toBoxShadow(shadow, color3) {
  return "".concat(shadow.map(rem).join(" "), " ").concat(color3);
}
function shadowStyle(shadow) {
  if (!shadow)
    return EMPTY_RECORD;
  const outline = "0 0 0 ".concat(rem(1), " var(--card-shadow-outline-color)");
  const umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)");
  const penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)");
  const ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: "".concat(outline, ", ").concat(umbra, ", ").concat(penumbra, ", ").concat(ambient)
  };
}
function responsiveShadowStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    shadows
  } = theme.sanity;
  return _responsive(media, props2.$shadow, (shadow) => shadowStyle(shadows[shadow]));
}
var __freeze$C = Object.freeze;
var __defProp$D = Object.defineProperty;
var __template$C = (cooked, raw) => __freeze$C(__defProp$D(cooked, "raw", {
  value: __freeze$C(raw || cooked.slice())
}));
var _a$C;
var _b$l;
var _c$c;
function textBaseStyle(props2) {
  const {
    $accent,
    $muted,
    theme
  } = props2;
  const {
    weights
  } = theme.sanity.fonts.text;
  return nt(_c$c || (_c$c = __template$C(["\n    color: var(--card-fg-color);\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n      background-color: var(--card-code-bg-color);\n      color: var(--card-code-fg-color);\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & strong {\n      font-weight: ", ";\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && nt(_a$C || (_a$C = __template$C(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && nt(_b$l || (_b$l = __template$C(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family, weights.bold);
}
var __freeze$B = Object.freeze;
var __defProp$C = Object.defineProperty;
var __template$B = (cooked, raw) => __freeze$B(__defProp$C(cooked, "raw", {
  value: __freeze$B(raw || cooked.slice())
}));
var _a$B;
var Root$E = st.div(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
var SpanWithTextOverflow$2 = st.span(_a$B || (_a$B = __template$B(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var Text3 = (0, import_react46.forwardRef)(function Text22(props2, ref) {
  const {
    accent = false,
    align: align2,
    children: childrenProp,
    muted = false,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = (0, import_jsx_runtime2.jsx)(SpanWithTextOverflow$2, {
      children
    });
  }
  return (0, import_jsx_runtime2.jsx)(Root$E, {
    "data-ui": "Text",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align2),
    $muted: muted,
    ref,
    $size: useArrayProp(size2),
    $weight: weight,
    children: (0, import_jsx_runtime2.jsx)("span", {
      children
    })
  });
});
var avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props2) {
  const {
    $color,
    theme
  } = props2;
  const {
    focusRing
  } = theme.sanity;
  return {
    backgroundColor: $color,
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props2) {
  const {
    theme
  } = props2;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props2.$size, (size2) => {
    const avatarSize = avatar.sizes[size2] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarInitialsStyle(props2) {
  const {
    theme
  } = props2;
  const {
    base
  } = theme.sanity.color;
  return {
    width: "100%",
    height: "100%",
    color: base.fg,
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "3px",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
var Root$D = st.div(responsiveAvatarSizeStyle, avatarStyle.root);
var Arrow = st.div(avatarStyle.arrow);
var BgStroke = st.ellipse(avatarStyle.bgStroke);
var Stroke = st.ellipse(avatarStyle.stroke);
var Initials = st.div(avatarStyle.initials);
var Avatar = (0, import_react46.forwardRef)(function Avatar2(props2, ref) {
  const {
    as: asProp,
    color: colorKey = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 0,
    ...restProps
  } = props2;
  const as = import_react_is.default.isValidElementType(asProp) ? asProp : "div";
  const size2 = useArrayProp(sizeProp);
  const theme = useTheme();
  const color3 = theme.sanity.color.spot[colorKey] || theme.sanity.color.spot.gray;
  const avatarSize = theme.sanity.avatar.sizes[size2[0]] || theme.sanity.avatar.sizes[0];
  const _sizeRem = avatarSize.size;
  const _radius = _sizeRem / 2;
  const elementId = (0, import_react46.useId)();
  const [arrowPosition, setArrowPosition] = (0, import_react46.useState)(animateArrowFrom || arrowPositionProp || "inside");
  const [imageFailed, setImageFailed] = (0, import_react46.useState)(false);
  const imageId = "avatar-image-".concat(elementId);
  (0, import_react46.useEffect)(() => {
    if (arrowPosition === arrowPositionProp)
      return void 0;
    const raf2 = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf2);
  }, [arrowPosition, arrowPositionProp]);
  (0, import_react46.useEffect)(() => {
    if (src)
      setImageFailed(false);
  }, [src]);
  const handleImageError = (0, import_react46.useCallback)(() => {
    setImageFailed(true);
    if (onImageLoadError) {
      onImageLoadError(new Error("Avatar: the image failed to load"));
    }
  }, [onImageLoadError]);
  const initialsSize = (0, import_react46.useMemo)(() => size2.map((s) => s === 0 ? 0 : s + 1), [size2]);
  return (0, import_jsx_runtime2.jsxs)(Root$D, {
    as,
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Avatar",
    ...restProps,
    $size: size2,
    $color: color3,
    "aria-label": title,
    "data-arrow-position": arrowPosition,
    "data-status": status,
    ref,
    title,
    children: [(0, import_jsx_runtime2.jsx)(Arrow, {
      children: (0, import_jsx_runtime2.jsx)("svg", {
        width: "11",
        height: "7",
        viewBox: "0 0 11 7",
        fill: "none",
        children: (0, import_jsx_runtime2.jsx)("path", {
          d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
          fill: color3
        })
      })
    }), !imageFailed && src && (0, import_jsx_runtime2.jsxs)("svg", {
      viewBox: "0 0 ".concat(_sizeRem, " ").concat(_sizeRem),
      fill: "none",
      children: [(0, import_jsx_runtime2.jsx)("defs", {
        children: (0, import_jsx_runtime2.jsx)("pattern", {
          id: imageId,
          patternContentUnits: "objectBoundingBox",
          width: "1",
          height: "1",
          children: (0, import_jsx_runtime2.jsx)("image", {
            href: src,
            width: "1",
            height: "1",
            onError: handleImageError
          })
        })
      }), (0, import_jsx_runtime2.jsx)("circle", {
        cx: _radius,
        cy: _radius,
        r: _radius,
        fill: "url(#".concat(imageId, ")")
      }), (0, import_jsx_runtime2.jsx)(BgStroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        vectorEffect: "non-scaling-stroke"
      }), (0, import_jsx_runtime2.jsx)(Stroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        stroke: color3,
        vectorEffect: "non-scaling-stroke"
      })]
    }), (imageFailed || !src) && initials && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {
      children: (0, import_jsx_runtime2.jsx)(Initials, {
        children: (0, import_jsx_runtime2.jsx)(Text3, {
          as: "span",
          size: initialsSize,
          children: (0, import_jsx_runtime2.jsx)("strong", {
            children: initials
          })
        })
      })
    })]
  });
});
var __freeze$A = Object.freeze;
var __defProp$B = Object.defineProperty;
var __template$A = (cooked, raw) => __freeze$A(__defProp$B(cooked, "raw", {
  value: __freeze$A(raw || cooked.slice())
}));
var _a$A;
function _responsiveAvatarCounterSizeStyle(props2) {
  const {
    theme
  } = props2;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props2.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    if (!avatarSize)
      return EMPTY_RECORD;
    return {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    };
  });
}
function _avatarCounterBaseStyle(props2) {
  const {
    theme
  } = props2;
  return nt(_a$A || (_a$A = __template$A(["\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    user-select: none;\n    color: inherit;\n    color: var(--card-fg-color);\n    background: var(--card-bg-color);\n    box-shadow:\n      0 0 0 1px var(--card-bg-color),\n      inset 0 0 0 1.5px var(--card-hairline-hard-color);\n    padding: 0 ", ";\n\n    &:not([hidden]) {\n      display: flex;\n    }\n  "])), rem(theme.sanity.space[2]));
}
var Root$C = st.div(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
var AvatarCounter = (0, import_react46.forwardRef)(function AvatarCounter2(props2, ref) {
  const {
    count: count2,
    size: sizeProp = 0
  } = props2;
  const size2 = useArrayProp(sizeProp);
  const counterSize = (0, import_react46.useMemo)(() => size2.map((s) => s === 0 ? 0 : s + 1), [size2]);
  return (0, import_jsx_runtime2.jsx)(Root$C, {
    $size: size2,
    "data-ui": "AvatarCounter",
    ref,
    children: (0, import_jsx_runtime2.jsx)(Text3, {
      as: "span",
      size: counterSize,
      children: (0, import_jsx_runtime2.jsx)("strong", {
        children: count2
      })
    })
  });
});
function childrenToElementArray(children) {
  const childrenArray = Array.isArray(children) ? children : [children];
  return childrenArray.filter((node) => (0, import_react_is.isElement)(node) || (0, import_react_is.isFragment)(node) || typeof node === "string");
}
var __freeze$z = Object.freeze;
var __defProp$A = Object.defineProperty;
var __template$z = (cooked, raw) => __freeze$z(__defProp$A(cooked, "raw", {
  value: __freeze$z(raw || cooked.slice())
}));
var _a$z;
var BASE_STYLES = nt(_a$z || (_a$z = __template$z(["\n  white-space: nowrap;\n\n  & > div {\n    vertical-align: top;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  }\n"])));
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props2) {
  const {
    theme
  } = props2;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props2.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    if (!avatarSize)
      return EMPTY_RECORD;
    return {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    };
  });
}
var Root$B = st.div(responsiveAvatarStackSizeStyle, avatarStackStyle);
var AvatarStack = (0, import_react46.forwardRef)(function AvatarStack2(props2, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 0,
    ...restProps
  } = props2;
  const children = childrenToElementArray(childrenProp).filter((child) => typeof child !== "string");
  const maxLength = Math.max(maxLengthProp, 0);
  const size2 = useArrayProp(sizeProp);
  const len = children.length;
  const visibleCount = maxLength - 1;
  const extraCount = len - visibleCount;
  const visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return (0, import_jsx_runtime2.jsxs)(Root$B, {
    "data-ui": "AvatarStack",
    ...restProps,
    ref,
    $size: size2,
    children: [len === 0 && (0, import_jsx_runtime2.jsx)("div", {
      children: (0, import_jsx_runtime2.jsx)(AvatarCounter, {
        count: len
      })
    }), len !== 0 && extraCount > 1 && (0, import_jsx_runtime2.jsx)("div", {
      children: (0, import_jsx_runtime2.jsx)(AvatarCounter, {
        count: extraCount,
        size: size2
      })
    }), visibleChildren.map((child, childIndex) => (0, import_jsx_runtime2.jsx)("div", {
      children: (0, import_react46.cloneElement)(child, {
        size: size2
      })
    }, String(childIndex)))]
  });
});
var Root$A = st.div(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
var Box = (0, import_react46.forwardRef)(function Box2(props2, ref) {
  const {
    as: asProp = "div",
    column,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$A, {
    "data-as": typeof asProp === "string" ? asProp : void 0,
    "data-ui": "Box",
    ...restProps,
    $column: useArrayProp(column),
    $columnStart: useArrayProp(columnStart),
    $columnEnd: useArrayProp(columnEnd),
    $display: useArrayProp(display),
    $flex: useArrayProp(flex),
    $height: useArrayProp(height),
    $margin: useArrayProp(margin),
    $marginX: useArrayProp(marginX),
    $marginY: useArrayProp(marginY),
    $marginTop: useArrayProp(marginTop),
    $marginRight: useArrayProp(marginRight),
    $marginBottom: useArrayProp(marginBottom),
    $marginLeft: useArrayProp(marginLeft),
    $overflow: useArrayProp(overflow),
    $padding: useArrayProp(padding),
    $paddingX: useArrayProp(paddingX),
    $paddingY: useArrayProp(paddingY),
    $paddingTop: useArrayProp(paddingTop),
    $paddingRight: useArrayProp(paddingRight),
    $paddingBottom: useArrayProp(paddingBottom),
    $paddingLeft: useArrayProp(paddingLeft),
    $row: useArrayProp(row),
    $rowStart: useArrayProp(rowStart),
    $rowEnd: useArrayProp(rowEnd),
    $sizing: useArrayProp(sizing),
    as: asProp,
    ref,
    children: props2.children
  });
});
var __freeze$y = Object.freeze;
var __defProp$z = Object.defineProperty;
var __template$y = (cooked, raw) => __freeze$y(__defProp$z(cooked, "raw", {
  value: __freeze$y(raw || cooked.slice())
}));
var _a$y;
var _b$k;
var _c$b;
function labelBaseStyle(props2) {
  const {
    $accent,
    $muted,
    theme
  } = props2;
  const {
    fonts: fonts2
  } = theme.sanity;
  return nt(_c$b || (_c$b = __template$y(["\n    text-transform: uppercase;\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && nt(_a$y || (_a$y = __template$y(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && nt(_b$k || (_b$k = __template$y(["\n      color: var(--card-muted-fg-color);\n    "]))), fonts2.code.family);
}
var __freeze$x = Object.freeze;
var __defProp$y = Object.defineProperty;
var __template$x = (cooked, raw) => __freeze$x(__defProp$y(cooked, "raw", {
  value: __freeze$x(raw || cooked.slice())
}));
var _a$x;
var Root$z = st.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
var SpanWithTextOverflow$1 = st.span(_a$x || (_a$x = __template$x(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var Label = (0, import_react46.forwardRef)(function Label2(props2, ref) {
  const {
    accent,
    align: align2,
    children: childrenProp,
    muted = false,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = (0, import_jsx_runtime2.jsx)(SpanWithTextOverflow$1, {
      children
    });
  } else {
    children = (0, import_jsx_runtime2.jsx)("span", {
      children
    });
  }
  return (0, import_jsx_runtime2.jsx)(Root$z, {
    "data-ui": "Label",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align2),
    $muted: muted,
    $size: useArrayProp(size2),
    $weight: weight,
    ref,
    children
  });
});
function badgeStyle(props2) {
  const {
    $mode,
    $tone,
    theme
  } = props2;
  const palette = theme.sanity.color[$mode === "outline" ? "muted" : "solid"];
  const color3 = palette[$tone] || palette.default;
  return {
    backgroundColor: color3.enabled.bg,
    color: color3.enabled.fg,
    boxShadow: "inset 0 0 0 1px ".concat(color3.enabled.border),
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block"
    }
  };
}
var Root$y = st(Box)(responsiveRadiusStyle, badgeStyle);
var Badge = (0, import_react46.forwardRef)(function Badge2(props2, ref) {
  const {
    children,
    fontSize: fontSize2,
    mode = "default",
    padding = 1,
    radius = 2,
    tone = "default",
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$y, {
    "data-ui": "Badge",
    ...restProps,
    $mode: mode,
    $tone: tone,
    $radius: useArrayProp(radius),
    padding: useArrayProp(padding),
    ref,
    children: (0, import_jsx_runtime2.jsx)(Label, {
      size: fontSize2,
      children
    })
  });
});
var Root$x = st(Box)(flexItemStyle, responsiveFlexStyle);
var Flex = (0, import_react46.forwardRef)(function Flex2(props2, ref) {
  const {
    align: align2,
    as,
    direction = "row",
    gap,
    justify,
    wrap: wrap5,
    ...restProps
  } = props2;
  return (
    // @ts-expect-error -- some dollar prefixed typings aren't inferred correctly https://github.com/styled-components/styled-components/issues/4062
    (0, import_jsx_runtime2.jsx)(Root$x, {
      "data-ui": "Flex",
      ...restProps,
      $align: useArrayProp(align2),
      $direction: useArrayProp(direction),
      $gap: useArrayProp(gap),
      $justify: useArrayProp(justify),
      $wrap: useArrayProp(wrap5),
      forwardedAs: as,
      ref
    })
  );
});
var __freeze$w = Object.freeze;
var __defProp$x = Object.defineProperty;
var __template$w = (cooked, raw) => __freeze$w(__defProp$x(cooked, "raw", {
  value: __freeze$w(raw || cooked.slice())
}));
var _a$w;
var _b$j;
var rotate$1 = ct(_a$w || (_a$w = __template$w(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var Root$w = st(Text3)(_b$j || (_b$j = __template$w(["\n  & > span > svg {\n    animation: ", " 500ms linear infinite;\n  }\n"])), rotate$1);
var Spinner = (0, import_react46.forwardRef)(function Spinner2(props2, ref) {
  return (0, import_jsx_runtime2.jsx)(Root$w, {
    "data-ui": "Spinner",
    ...props2,
    ref,
    children: (0, import_jsx_runtime2.jsx)(SpinnerIcon, {})
  });
});
function _colorVarsStyle(base, color3) {
  let checkered = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var _a4, _b4, _c4, _d4, _e3, _f3, _g3, _h2;
  return {
    // Base
    // @todo: rename to "--base-"?
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    "--card-focus-ring-color": base.focusRing,
    // Card
    "--card-bg-color": color3.bg,
    "--card-bg-image": checkered ? "repeating-conic-gradient(".concat(color3.bg, " 0% 25%, ").concat(color3.bg2 || color3.bg, " 0% 50%)") : void 0,
    "--card-fg-color": color3.fg,
    "--card-border-color": color3.border,
    "--card-muted-fg-color": (_a4 = color3.muted) == null ? void 0 : _a4.fg,
    "--card-accent-fg-color": (_b4 = color3.accent) == null ? void 0 : _b4.fg,
    "--card-link-fg-color": (_c4 = color3.link) == null ? void 0 : _c4.fg,
    "--card-code-bg-color": (_d4 = color3.code) == null ? void 0 : _d4.bg,
    "--card-code-fg-color": (_e3 = color3.code) == null ? void 0 : _e3.fg,
    "--card-skeleton-color-from": (_f3 = color3.skeleton) == null ? void 0 : _f3.from,
    "--card-skeleton-color-to": (_g3 = color3.skeleton) == null ? void 0 : _g3.to,
    // @todo: deprecate
    "--card-link-color": (_h2 = color3.link) == null ? void 0 : _h2.fg,
    "--card-hairline-soft-color": color3.border,
    "--card-hairline-hard-color": color3.border
  };
}
var __freeze$v = Object.freeze;
var __defProp$w = Object.defineProperty;
var __template$v = (cooked, raw) => __freeze$v(__defProp$w(cooked, "raw", {
  value: __freeze$v(raw || cooked.slice())
}));
var _a$v;
function buttonBaseStyles() {
  return nt(_a$v || (_a$v = __template$v(["\n    -webkit-font-smoothing: inherit;\n    appearance: none;\n    display: inline-flex;\n    align-items: center;\n    font: inherit;\n    border: 0;\n    outline: none;\n    user-select: none;\n    text-decoration: none;\n    border: 0;\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n    white-space: nowrap;\n    text-align: left;\n    position: relative;\n\n    & > span {\n      display: block;\n      flex: 1;\n      min-width: 0;\n      border-radius: inherit;\n    }\n\n    &::-moz-focus-inner {\n      border: 0;\n      padding: 0;\n    }\n  "])));
}
var buttonTheme = {
  border: {
    width: 1
  }
};
function buttonColorStyles(props2) {
  var _a22, _b4;
  const {
    $mode,
    theme
  } = props2;
  const {
    focusRing
  } = theme.sanity;
  const base = theme.sanity.color.base;
  const mode = theme.sanity.color.button[$mode] || theme.sanity.color.button.default;
  const color3 = mode[props2.$tone] || mode.default;
  const border2 = {
    width: buttonTheme.border.width,
    color: "var(--card-border-color)"
  };
  return [_colorVarsStyle(base, color3.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border2),
    '&:disabled, &[data-disabled="true"]': _colorVarsStyle(base, color3.disabled),
    "&:not([data-disabled='true'])": {
      "&:focus": {
        boxShadow: focusRingStyle({
          base,
          border: border2,
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: focusRingBorderStyle(border2)
      },
      "@media (hover: hover)": {
        "&:hover": _colorVarsStyle(base, color3.hovered),
        "&:active": _colorVarsStyle(base, color3.pressed),
        "&[data-hovered]": _colorVarsStyle(base, color3.hovered)
      },
      "&[data-selected]": _colorVarsStyle(base, color3.pressed)
    }
  }, (_b4 = (_a22 = theme.sanity.styles) == null ? void 0 : _a22.button) == null ? void 0 : _b4.root].filter(Boolean);
}
var __freeze$u = Object.freeze;
var __defProp$v = Object.defineProperty;
var __template$u = (cooked, raw) => __freeze$u(__defProp$v(cooked, "raw", {
  value: __freeze$u(raw || cooked.slice())
}));
var _a$u;
var Root$v = st.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
var LoadingBox = st.div(_a$u || (_a$u = __template$u(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: var(--card-bg-color);\n  border-radius: inherit;\n  z-index: 1;\n  box-shadow: inherit;\n"])));
var Button = (0, import_react46.forwardRef)(function Button2(props2, ref) {
  const {
    children,
    disabled,
    fontSize: fontSize2,
    icon,
    iconRight,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    ...restProps
  } = props2;
  const justify = useArrayProp(justifyProp);
  const padding = useArrayProp(paddingProp);
  const paddingX = useArrayProp(paddingXProp);
  const paddingY = useArrayProp(paddingYProp);
  const paddingTop = useArrayProp(paddingTopProp);
  const paddingBottom = useArrayProp(paddingBottomProp);
  const paddingLeft = useArrayProp(paddingLeftProp);
  const paddingRight = useArrayProp(paddingRightProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const theme = useTheme();
  const boxProps = (0, import_react46.useMemo)(() => ({
    // flex: 1,
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }), [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]);
  return (0, import_jsx_runtime2.jsxs)(Root$v, {
    "data-ui": "Button",
    ...restProps,
    $mode: mode,
    $radius: radius,
    $tone: tone,
    "data-disabled": Boolean(loading || disabled),
    "data-selected": selected ? "" : void 0,
    disabled: Boolean(loading || disabled),
    ref,
    type,
    children: [Boolean(loading) && (0, import_jsx_runtime2.jsx)(LoadingBox, {
      children: (0, import_jsx_runtime2.jsx)(Spinner, {})
    }), (icon || text || iconRight) && (0, import_jsx_runtime2.jsx)(Box, {
      as: "span",
      ...boxProps,
      children: (0, import_jsx_runtime2.jsxs)(Flex, {
        as: "span",
        justify,
        children: [icon && (0, import_jsx_runtime2.jsxs)(Text3, {
          size: fontSize2,
          children: [(0, import_react46.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react46.createElement)(icon)]
        }), text && (0, import_jsx_runtime2.jsx)(Box, {
          flex: iconRight ? 1 : void 0,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: (0, import_jsx_runtime2.jsx)(Text3, {
            align: textAlign,
            size: fontSize2,
            textOverflow: "ellipsis",
            weight: theme.sanity.button.textWeight,
            children: text
          })
        }), iconRight && (0, import_jsx_runtime2.jsxs)(Text3, {
          size: fontSize2,
          children: [(0, import_react46.isValidElement)(iconRight) && iconRight, (0, import_react_is.isValidElementType)(iconRight) && (0, import_react46.createElement)(iconRight)]
        })]
      })
    }), children && (0, import_jsx_runtime2.jsx)(Box, {
      as: "span",
      ...boxProps,
      children
    })]
  });
});
var __freeze$t = Object.freeze;
var __defProp$u = Object.defineProperty;
var __template$t = (cooked, raw) => __freeze$t(__defProp$u(cooked, "raw", {
  value: __freeze$t(raw || cooked.slice())
}));
var _a$t;
var _b$i;
var _c$a;
function cardStyle(props2) {
  return [cardBaseStyle(props2), cardColorStyle(props2)];
}
function cardBaseStyle(props2) {
  const {
    $checkered,
    theme
  } = props2;
  const space = theme.sanity.space;
  return nt(_b$i || (_b$i = __template$t(["\n    ", "\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      outline: none;\n      text-decoration: none;\n    }\n\n    /* &:is(pre) */\n    &[data-as='pre'] {\n      font: inherit;\n    }\n  "])), $checkered && nt(_a$t || (_a$t = __template$t(["\n      background-size: ", "px ", "px;\n      background-position: 50% 50%;\n      background-image: var(--card-bg-image);\n    "])), space[3], space[3]));
}
function cardColorStyle(props2) {
  var _a22, _b22;
  const {
    $checkered,
    $focusRing,
    theme
  } = props2;
  const {
    focusRing
  } = theme.sanity;
  const {
    base,
    card,
    dark
  } = theme.sanity.color;
  const border2 = {
    width: 0,
    color: "var(--card-border-color)"
  };
  return nt(_c$a || (_c$a = __template$t(["\n    color-scheme: ", ";\n\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      --card-focus-ring-box-shadow: none;\n\n      cursor: default;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      cursor: pointer;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    ", "\n  "])), dark ? "dark" : "light", _colorVarsStyle(base, card.enabled, $checkered), _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border: border2,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border2) : void 0, _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border: border2,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border2) : void 0, (_b22 = (_a22 = theme.sanity.styles) == null ? void 0 : _a22.card) == null ? void 0 : _b22.root);
}
var Root$u = st(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
var Card = (0, import_react46.forwardRef)(function Card2(props2, ref) {
  const {
    __unstable_checkered: checkered = false,
    __unstable_focusRing: focusRing = false,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props2;
  const as = (0, import_react_is.isValidElementType)(asProp) ? asProp : "div";
  const rootTheme = useRootTheme();
  const tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return (0, import_jsx_runtime2.jsx)(ThemeColorProvider, {
    scheme,
    tone,
    children: (0, import_jsx_runtime2.jsx)(Root$u, {
      "data-as": typeof as === "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border2),
      $borderTop: useArrayProp(borderTop2),
      $borderRight: useArrayProp(borderRight2),
      $borderBottom: useArrayProp(borderBottom2),
      $borderLeft: useArrayProp(borderLeft2),
      $checkered: checkered,
      $focusRing: focusRing,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    })
  });
});
var __freeze$s = Object.freeze;
var __defProp$t = Object.defineProperty;
var __template$s = (cooked, raw) => __freeze$s(__defProp$t(cooked, "raw", {
  value: __freeze$s(raw || cooked.slice())
}));
var _a$s;
var _b$h;
function checkboxBaseStyles() {
  return nt(_a$s || (_a$s = __template$s(["\n    position: relative;\n    display: inline-block;\n  "])));
}
function inputElementStyles(props2) {
  const {
    theme
  } = props2;
  const color3 = theme.sanity.color.input;
  const {
    focusRing,
    input,
    radius
  } = theme.sanity;
  return nt(_b$h || (_b$h = __template$s(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    outline: none;\n    opacity: 0;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n\n    & + span {\n      position: relative;\n      display: block;\n      height: ", ";\n      width: ", ";\n      box-sizing: border-box;\n      box-shadow: ", ";\n      border-radius: ", ";\n      line-height: 1;\n      background-color: ", ";\n\n      & > svg {\n        display: block;\n        position: absolute;\n        opacity: 0;\n        height: 100%;\n        width: 100%;\n\n        & > path {\n          vector-effect: non-scaling-stroke;\n          stroke-width: 2 !important;\n        }\n      }\n    }\n\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span > svg:first-child {\n      opacity: 1;\n    }\n\n    &[data-read-only] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:not([data-read-only]):disabled + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:indeterminate + span > svg:last-child {\n      opacity: 1;\n    }\n  "])), rem(input.checkbox.size), rem(input.checkbox.size), focusRingBorderStyle({
    color: color3.default.enabled.border,
    width: input.border.width
  }), rem(radius[2]), color3.default.enabled.bg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color3.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color3.default.enabled.border,
    width: input.border.width
  }), color3.default.readOnly.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color3.default.readOnly.border
  }), color3.default.readOnly.fg, color3.default.disabled.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color3.default.disabled.border
  }), color3.default.disabled.fg);
}
var Root$t = st.div(checkboxBaseStyles);
var Input$5 = st.input(inputElementStyles);
var Checkbox = (0, import_react46.forwardRef)(function Checkbox2(props2, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props2;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  (0, import_react46.useEffect)(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return (0, import_jsx_runtime2.jsxs)(Root$t, {
    className,
    "data-ui": "Checkbox",
    style,
    children: [(0, import_jsx_runtime2.jsx)(Input$5, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      readOnly,
      ref
    }), (0, import_jsx_runtime2.jsxs)("span", {
      children: [(0, import_jsx_runtime2.jsx)(CheckmarkIcon, {}), (0, import_jsx_runtime2.jsx)(RemoveIcon, {})]
    })]
  });
});
var __freeze$r = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$r = (cooked, raw) => __freeze$r(__defProp$s(cooked, "raw", {
  value: __freeze$r(raw || cooked.slice())
}));
var _a$r;
function codeSyntaxHighlightingStyle(_ref20) {
  let {
    theme
  } = _ref20;
  const color3 = theme.sanity.color.syntax;
  return {
    "&.atrule": {
      color: color3.atrule
    },
    "&.attr-name": {
      color: color3.attrName
    },
    "&.attr-value": {
      color: color3.attrValue
    },
    "&.attribute": {
      color: color3.attribute
    },
    "&.boolean": {
      color: color3.boolean
    },
    "&.builtin": {
      color: color3.builtin
    },
    "&.cdata": {
      color: color3.cdata
    },
    "&.char": {
      color: color3.char
    },
    "&.class": {
      color: color3.class
    },
    "&.class-name": {
      color: color3.className
    },
    "&.comment": {
      color: color3.comment
    },
    "&.constant": {
      color: color3.constant
    },
    "&.deleted": {
      color: color3.deleted
    },
    "&.doctype": {
      color: color3.doctype
    },
    "&.entity": {
      color: color3.entity
    },
    "&.function": {
      color: color3.function
    },
    "&.hexcode": {
      color: color3.hexcode
    },
    "&.id": {
      color: color3.id
    },
    "&.important": {
      color: color3.important
    },
    "&.inserted": {
      color: color3.inserted
    },
    "&.keyword": {
      color: color3.keyword
    },
    "&.number": {
      color: color3.number
    },
    "&.operator": {
      color: color3.operator
    },
    "&.prolog": {
      color: color3.prolog
    },
    "&.property": {
      color: color3.property
    },
    "&.pseudo-class": {
      color: color3.pseudoClass
    },
    "&.pseudo-element": {
      color: color3.pseudoElement
    },
    "&.punctuation": {
      color: color3.punctuation
    },
    "&.regex": {
      color: color3.regex
    },
    "&.selector": {
      color: color3.selector
    },
    "&.string": {
      color: color3.string
    },
    "&.symbol": {
      color: color3.symbol
    },
    "&.tag": {
      color: color3.tag
    },
    "&.unit": {
      color: color3.unit
    },
    "&.url": {
      color: color3.url
    },
    "&.variable": {
      color: color3.variable
    }
  };
}
function codeBaseStyle() {
  return nt(_a$r || (_a$r = __template$r(["\n    color: var(--card-code-fg-color);\n\n    & code {\n      font-family: inherit;\n\n      &.refractor .token {\n        ", "\n      }\n    }\n\n    & a {\n      color: inherit;\n      text-decoration: underline;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), codeSyntaxHighlightingStyle);
}
var Root$s = st.pre(codeBaseStyle, responsiveCodeFontStyle);
var Code = (0, import_react46.forwardRef)(function Code2(props2, ref) {
  const {
    children,
    language: languageProp,
    size: size2 = 2,
    weight,
    ...restProps
  } = props2;
  const language = typeof languageProp === "string" ? languageProp : void 0;
  const registered = language ? import_react_refractor.default.hasLanguage(language) : false;
  return (0, import_jsx_runtime2.jsxs)(Root$s, {
    "data-ui": "Code",
    ...restProps,
    $size: useArrayProp(size2),
    $weight: weight,
    ref,
    children: [!(language && registered) && (0, import_jsx_runtime2.jsx)("code", {
      children
    }), language && registered && (0, import_jsx_runtime2.jsx)(import_react_refractor.default, {
      inline: true,
      language,
      value: String(children)
    })]
  });
});
var BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props2) {
  const {
    theme
  } = props2;
  const {
    container,
    media
  } = theme.sanity;
  return _responsive(media, props2.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
var Root$r = st(Box)(containerBaseStyle, responsiveContainerWidthStyle);
var Container = (0, import_react46.forwardRef)(function Container2(props2, ref) {
  const {
    as,
    width = 2,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$r, {
    "data-ui": "Container",
    ...restProps,
    $width: useArrayProp(width),
    forwardedAs: as,
    ref
  });
});
var Root$q = st(Box)(responsiveGridStyle);
var Grid = (0, import_react46.forwardRef)(function Grid2(props2, ref) {
  const {
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$q, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Grid",
    ...restProps,
    $autoRows: useArrayProp(autoRows),
    $autoCols: useArrayProp(autoCols),
    $autoFlow: useArrayProp(autoFlow),
    $columns: useArrayProp(columns),
    $gap: useArrayProp(gap),
    $gapX: useArrayProp(gapX),
    $gapY: useArrayProp(gapY),
    $rows: useArrayProp(rows),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$q = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$q = (cooked, raw) => __freeze$q(__defProp$r(cooked, "raw", {
  value: __freeze$q(raw || cooked.slice())
}));
var _a$q;
var _b$g;
var _c$9;
function headingBaseStyle(props2) {
  const {
    $accent,
    $muted,
    theme
  } = props2;
  return nt(_c$9 || (_c$9 = __template$q(["\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && nt(_a$q || (_a$q = __template$q(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && nt(_b$g || (_b$g = __template$q(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family);
}
var __freeze$p = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$p = (cooked, raw) => __freeze$p(__defProp$q(cooked, "raw", {
  value: __freeze$p(raw || cooked.slice())
}));
var _a$p;
var Root$p = st.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
var SpanWithTextOverflow = st.span(_a$p || (_a$p = __template$p(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var Heading = (0, import_react46.forwardRef)(function Heading2(props2, ref) {
  const {
    accent = false,
    align: align2,
    children: childrenProp,
    muted = false,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = (0, import_jsx_runtime2.jsx)(SpanWithTextOverflow, {
      children
    });
  }
  return (0, import_jsx_runtime2.jsx)(Root$p, {
    "data-ui": "Heading",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align2),
    $muted: muted,
    $size: useArrayProp(size2),
    $weight: weight,
    ref,
    children: (0, import_jsx_runtime2.jsx)("span", {
      children
    })
  });
});
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props2) {
  const {
    theme
  } = props2;
  return _responsive(theme.sanity.media, props2.$space, (spaceIndex) => {
    const space = rem(theme.sanity.space[spaceIndex]);
    return {
      margin: "-".concat(space, " 0 0 -").concat(space),
      "& > div": {
        padding: "".concat(space, " 0 0 ").concat(space)
      }
    };
  });
}
var Root$o = st(Box)(inlineBaseStyle, inlineSpaceStyle);
var Inline = (0, import_react46.forwardRef)(function Inline2(props2, ref) {
  const {
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props2;
  const children = (0, import_react46.useMemo)(() => childrenToElementArray(childrenProp).filter(Boolean).map((child, idx) => (0, import_jsx_runtime2.jsx)("div", {
    children: child
  }, idx)), [childrenProp]);
  return (0, import_jsx_runtime2.jsx)(Root$o, {
    "data-ui": "Inline",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$o = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$o = (cooked, raw) => __freeze$o(__defProp$p(cooked, "raw", {
  value: __freeze$o(raw || cooked.slice())
}));
var _a$o;
function kbdStyle() {
  return nt(_a$o || (_a$o = __template$o(["\n    background: var(--card-bg-color);\n    font: inherit;\n    box-shadow: inset 0 0 0 1px var(--card-hairline-hard-color);\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
var Root$n = st.kbd(responsiveRadiusStyle, kbdStyle);
var KBD = (0, import_react46.forwardRef)(function KBD2(props2, ref) {
  const {
    children,
    fontSize: fontSize2 = 1,
    padding = 1,
    radius = 2,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$n, {
    "data-ui": "KBD",
    ...restProps,
    $radius: useArrayProp(radius),
    ref,
    children: (0, import_jsx_runtime2.jsx)(Box, {
      as: "span",
      padding,
      children: (0, import_jsx_runtime2.jsx)(Code, {
        as: "span",
        muted: true,
        size: fontSize2,
        children
      })
    })
  });
});
var key$7 = Symbol.for("@sanity/ui/context/boundaryElement");
globalScope[key$7] = globalScope[key$7] || (0, import_react46.createContext)(null);
var BoundaryElementContext = globalScope[key$7];
function BoundaryElementProvider(props2) {
  const {
    children,
    element
  } = props2;
  const value = (0, import_react46.useMemo)(() => ({
    version: 0,
    element
  }), [element]);
  return (0, import_jsx_runtime2.jsx)(BoundaryElementContext.Provider, {
    value,
    children
  });
}
var DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = (0, import_react46.useContext)(BoundaryElementContext);
  if (value && (!isRecord2(value) || value.version !== 0)) {
    throw new Error("useBoundaryElement(): the context value is not compatible");
  }
  return value || DEFAULT_VALUE;
}
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp > width) {
      ret.push(i);
    }
  }
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp <= width) {
      ret.push(i);
    }
  }
  return ret;
}
var ElementQuery = (0, import_react46.forwardRef)(function ElementQuery2(props2, ref) {
  const theme = useTheme();
  const {
    children,
    media = theme.sanity.media,
    ...restProps
  } = props2;
  const forwardedRef = useForwardedRef(ref);
  const [element, setElement] = (0, import_react46.useState)(null);
  const elementSize = useElementSize(element);
  const width = (0, import_react46.useMemo)(() => {
    var _a4;
    return (_a4 = elementSize == null ? void 0 : elementSize.border.width) != null ? _a4 : window.innerWidth;
  }, [elementSize]);
  const max2 = (0, import_react46.useMemo)(() => findMaxBreakpoints(media, width), [media, width]);
  const min2 = (0, import_react46.useMemo)(() => findMinBreakpoints(media, width), [media, width]);
  const setRef = (0, import_react46.useCallback)((el) => {
    forwardedRef.current = el;
    setElement(el);
  }, [forwardedRef]);
  return (0, import_jsx_runtime2.jsx)("div", {
    "data-ui": "ElementQuery",
    ...restProps,
    "data-eq-max": max2.length ? max2.join(" ") : void 0,
    "data-eq-min": min2.length ? min2.join(" ") : void 0,
    ref: setRef,
    children
  });
});
var __defProp$o = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp$o(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var ErrorBoundary = class extends import_react46.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      error: null
    });
  }
  static getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  }
  componentDidCatch(error2, info) {
    this.props.onCatch({
      error: error2,
      info
    });
  }
  render() {
    const {
      error: error2
    } = this.state;
    if (error2) {
      const message = typeof (error2 == null ? void 0 : error2.message) === "string" ? error2.message : "Error";
      return (0, import_jsx_runtime2.jsx)(Code, {
        children: message
      });
    }
    return this.props.children;
  }
};
function getLayerContext(contextValue) {
  if (!isRecord2(contextValue) || contextValue.version !== 0) {
    throw new Error("the context value is not compatible");
  }
  if (!contextValue) {
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  }
  if (contextValue.version === 0) {
    return contextValue;
  }
  throw new Error("could not get layer context");
}
var key$6 = Symbol.for("@sanity/ui/context/layer");
globalScope[key$6] = globalScope[key$6] || (0, import_react46.createContext)(null);
var LayerContext = globalScope[key$6];
function useLayer() {
  const value = (0, import_react46.useContext)(LayerContext);
  if (!value) {
    throw new Error("useLayer(): missing context value");
  }
  try {
    return getLayerContext(value);
  } catch (err) {
    if (err instanceof Error) {
      throw new Error("useLayer(): ".concat(err.message));
    } else {
      throw new Error("useLayer(): ".concat(err));
    }
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    if (innerDispose)
      innerDispose();
    outerDispose();
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node) {
  return element.contains(node) || element === node;
}
function _hasFocus(element) {
  return Boolean(document.activeElement) && element.contains(document.activeElement);
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (isHTMLAnchorElement(element)) {
    return Boolean(element.href) && element.rel !== "ignore";
  }
  if (isHTMLInputElement(element)) {
    return element.type !== "hidden" && element.type !== "file" && !element.disabled;
  }
  if (isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element)) {
    return !element.disabled;
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus();
  } catch (_) {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child))) {
      return true;
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child))) {
      return true;
    }
  }
  return false;
}
function _isScrollable(el) {
  if (!(el instanceof Element))
    return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function LayerProvider(props2) {
  var _a4;
  const {
    children,
    zOffset: zOffsetProp = 0
  } = props2;
  const parentContextValue = (0, import_react46.useContext)(LayerContext);
  const parent = parentContextValue && getLayerContext(parentContextValue);
  const parentRegisterChild = parent == null ? void 0 : parent.registerChild;
  const parentLevel = (_a4 = parent == null ? void 0 : parent.level) != null ? _a4 : 0;
  const level = parentLevel + 1;
  const zOffset = useArrayProp(zOffsetProp);
  const maxMediaIndex = zOffset.length - 1;
  const mediaIndex = Math.min(useMediaIndex(), maxMediaIndex);
  const zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  const [, setChildLayers] = (0, import_react46.useState)({});
  const [size2, setSize] = (0, import_react46.useState)(0);
  const isTopLayer = size2 === 0;
  const registerChild = (0, import_react46.useCallback)((childLevel) => {
    const parentDispose = parentRegisterChild == null ? void 0 : parentRegisterChild(childLevel);
    if (childLevel !== void 0) {
      setChildLayers((state) => {
        var _a22;
        const prevLen = (_a22 = state[childLevel]) != null ? _a22 : 0;
        const nextState = {
          ...state,
          [childLevel]: prevLen + 1
        };
        setSize(Object.keys(nextState).length);
        return nextState;
      });
    } else {
      setSize((v) => v + 1);
    }
    return () => {
      if (childLevel !== void 0) {
        setChildLayers((state) => {
          const nextState = {
            ...state
          };
          if (nextState[childLevel] === 1) {
            delete nextState[childLevel];
            setSize(Object.keys(nextState).length);
          } else {
            nextState[childLevel] -= 1;
          }
          return nextState;
        });
      } else {
        setSize((v) => v - 1);
      }
      parentDispose == null ? void 0 : parentDispose();
    };
  }, [parentRegisterChild]);
  (0, import_react46.useEffect)(() => parentRegisterChild == null ? void 0 : parentRegisterChild(level), [level, parentRegisterChild]);
  const value = (0, import_react46.useMemo)(() => ({
    version: 0,
    isTopLayer,
    level,
    registerChild,
    size: size2,
    zIndex
  }), [isTopLayer, level, registerChild, size2, zIndex]);
  return (0, import_jsx_runtime2.jsx)(LayerContext.Provider, {
    value,
    children
  });
}
var Root$m = st.div({
  position: "relative"
});
var LayerChildren = (0, import_react46.forwardRef)(function LayerChildren2(props2, ref) {
  const {
    children,
    onActivate,
    onFocus,
    style = EMPTY_RECORD,
    ...restProps
  } = props2;
  const {
    zIndex,
    isTopLayer
  } = useLayer();
  const lastFocusedRef = (0, import_react46.useRef)(null);
  const forwardedRef = useForwardedRef(ref);
  const isTopLayerRef = (0, import_react46.useRef)(isTopLayer);
  (0, import_react46.useEffect)(() => {
    const becameTopLayer = isTopLayerRef.current !== isTopLayer && isTopLayer;
    if (becameTopLayer) {
      onActivate == null ? void 0 : onActivate({
        activeElement: lastFocusedRef.current
      });
    }
    isTopLayerRef.current = isTopLayer;
  }, [isTopLayer, onActivate]);
  const handleFocus = (0, import_react46.useCallback)((event) => {
    onFocus == null ? void 0 : onFocus(event);
    const rootElement = forwardedRef.current;
    const target = document.activeElement;
    if (!isTopLayer || !rootElement || !target)
      return;
    if (isHTMLElement(target) && containsOrEqualsElement(rootElement, target)) {
      lastFocusedRef.current = target;
    }
  }, [forwardedRef, isTopLayer, onFocus]);
  return (0, import_jsx_runtime2.jsx)(Root$m, {
    ...restProps,
    "data-ui": "Layer",
    onFocus: handleFocus,
    ref: forwardedRef,
    style: {
      ...style,
      zIndex
    },
    children
  });
});
var Layer = (0, import_react46.forwardRef)(function Layer2(props2, ref) {
  const {
    children,
    zOffset = 1,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(LayerProvider, {
    zOffset,
    children: (0, import_jsx_runtime2.jsx)(LayerChildren, {
      ...restProps,
      ref,
      children
    })
  });
});
var key$5 = Symbol.for("@sanity/ui/context/portal");
var elementKey = Symbol.for("@sanity/ui/context/portal/element");
globalScope[elementKey] = null;
var defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    if (typeof document === "undefined") {
      return null;
    }
    if (globalScope[elementKey]) {
      return globalScope[elementKey];
    }
    globalScope[elementKey] = document.createElement("div");
    globalScope[elementKey].setAttribute("data-portal", "");
    document.body.appendChild(globalScope[elementKey]);
    return globalScope[elementKey];
  }
};
globalScope[key$5] = globalScope[key$5] || (0, import_react46.createContext)(defaultContextValue);
var PortalContext = globalScope[key$5];
function usePortal() {
  const value = (0, import_react46.useContext)(PortalContext);
  if (!value) {
    throw new Error("usePortal(): missing context value");
  }
  if (!isRecord2(value) || value.version !== 0) {
    throw new Error("usePortal(): the context value is not compatible");
  }
  return value;
}
function Portal(props2) {
  var _a4;
  const {
    children,
    __unstable_name: name
  } = props2;
  const portal = usePortal();
  const portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a4 = portal.elements) == null ? void 0 : _a4.default);
  if (!portalElement) {
    return null;
  }
  return (0, import_react_dom2.createPortal)(children, portalElement);
}
function useUnique(value) {
  const valueRef = (0, import_react46.useRef)(value);
  if (!_isEqual(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB) {
    return objA === objB;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every((key2) => objA[key2] === objB[key2]);
}
var __BROWSER__ = typeof document !== "undefined";
function PortalProvider(props2) {
  const {
    boundaryElement,
    children,
    element,
    __unstable_elements: elementsProp
  } = props2;
  const elements = useUnique(elementsProp);
  const value = (0, import_react46.useMemo)(() => {
    return {
      version: 0,
      boundaryElement: boundaryElement || null,
      element: element || __BROWSER__ && document.body || null,
      elements
    };
  }, [boundaryElement, element, elements]);
  return (0, import_jsx_runtime2.jsx)(PortalContext.Provider, {
    value,
    children
  });
}
var __freeze$n = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$n = (cooked, raw) => __freeze$n(__defProp$n(cooked, "raw", {
  value: __freeze$n(raw || cooked.slice())
}));
var _a$n;
var Root$l = st.div(_a$n || (_a$n = __template$n(["\n  display: block;\n  width: 0;\n  height: 0;\n  position: absolute;\n  overflow: hidden;\n  overflow: clip;\n"])));
var SrOnly = (0, import_react46.forwardRef)(function SrOnly2(props2, ref) {
  const {
    as,
    children
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$l, {
    "aria-hidden": true,
    as,
    "data-ui": "SrOnly",
    ref,
    children
  });
});
var __freeze$m = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$m = (cooked, raw) => __freeze$m(__defProp$m(cooked, "raw", {
  value: __freeze$m(raw || cooked.slice())
}));
var _a$m;
var _b$f;
var Root$k = st.div(_a$m || (_a$m = __template$m(["\n  position: relative;\n"])));
var ItemWrapper = st.div(_b$f || (_b$f = __template$m(["\n  position: absolute;\n  left: 0;\n  right: 0;\n"])));
var VirtualList = (0, import_react46.forwardRef)(function VirtualList2(props2, ref) {
  const {
    as = "div",
    gap = 0,
    getItemKey: getItemKey2,
    items = [],
    onChange,
    renderItem,
    ...restProps
  } = props2;
  const {
    space
  } = useTheme().sanity;
  const forwardedRef = useForwardedRef(ref);
  const wrapperRef = (0, import_react46.useRef)(null);
  const [scrollTop, setScrollTop] = (0, import_react46.useState)(0);
  const [scrollHeight, setScrollHeight] = (0, import_react46.useState)(0);
  const [itemHeight, setItemHeight] = (0, import_react46.useState)(-1);
  (0, import_react46.useEffect)(() => {
    if (!wrapperRef.current)
      return;
    const firstElement = wrapperRef.current.firstChild;
    if (firstElement instanceof HTMLElement) {
      setItemHeight(firstElement.offsetHeight);
    }
  }, [renderItem]);
  (0, import_react46.useEffect)(() => {
    if (!forwardedRef.current)
      return;
    let _scrollEl = forwardedRef.current.parentNode;
    while (_scrollEl && !_isScrollable(_scrollEl)) {
      _scrollEl = _scrollEl.parentNode;
    }
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement))
        return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, {
        passive: true
      });
      const ro = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      ro.observe(scrollEl);
      handleScroll2();
      return () => {
        scrollEl.removeEventListener("scroll", handleScroll2);
        ro.unobserve(scrollEl);
        ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    };
    const handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    window.addEventListener("scroll", handleScroll, {
      passive: true
    });
    window.addEventListener("resize", handleResize);
    setScrollHeight(window.innerHeight);
    handleScroll();
    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [forwardedRef]);
  const len = items.length;
  const height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0;
  const fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0;
  const toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  (0, import_react46.useEffect)(() => {
    if (!onChange)
      return;
    onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex]);
  const children = (0, import_react46.useMemo)(() => {
    if (!renderItem || items.length === 0)
      return null;
    if (itemHeight === -1) {
      return [(0, import_jsx_runtime2.jsx)(ItemWrapper, {
        children: renderItem(items[0])
      }, 0)];
    }
    return items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
      const itemIndex = fromIndex + _itemIndex;
      const node = renderItem(item);
      const key2 = getItemKey2 ? getItemKey2(item, itemIndex) : itemIndex;
      return (0, import_jsx_runtime2.jsx)(ItemWrapper, {
        style: {
          top: itemIndex * (itemHeight + space[gap])
        },
        children: node
      }, key2);
    });
  }, [fromIndex, gap, getItemKey2, itemHeight, items, renderItem, space, toIndex]);
  const wrapperStyle = (0, import_react46.useMemo)(() => ({
    height
  }), [height]);
  return (0, import_jsx_runtime2.jsx)(Root$k, {
    as,
    "data-ui": "VirtualList",
    ...restProps,
    ref: forwardedRef,
    children: (0, import_jsx_runtime2.jsx)("div", {
      ref: wrapperRef,
      style: wrapperStyle,
      children
    })
  });
});
var DEFAULT_POPOVER_DISTANCE = 4;
var DEFAULT_POPOVER_PADDING = 4;
var DEFAULT_POPOVER_ARROW_WIDTH = 27;
var DEFAULT_POPOVER_ARROW_HEIGHT = 11;
var DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
var DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options) {
  const {
    apply: apply3,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform,
        rects
      } = args;
      const {
        floating,
        reference: reference2
      } = rects;
      const overflow = await detectOverflow(args, {
        altBoundary: true,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      const floatingW = floating.width;
      const floatingH = floating.height;
      if (placement.includes("top")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.top;
      }
      if (placement.includes("right")) {
        maxWidth = floatingW - overflow.right;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      if (placement.includes("bottom")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.bottom;
      }
      if (placement.includes("left")) {
        maxWidth = floatingW - overflow.left;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      apply3({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference2.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      const targetH = nextDimensions.height;
      const targetW = nextDimensions.width;
      if (floatingW !== targetW || floatingH !== targetH) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    mediaIndex,
    theme,
    width
  } = params;
  const w = width[mediaIndex];
  const currentWidth = w === void 0 ? width[width.length - 1] : w;
  return typeof currentWidth === "number" ? theme.sanity.container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (currentWidth === void 0 && boundaryWidth === void 0) {
    return void 0;
  }
  return Math.min(currentWidth != null ? currentWidth : Infinity, (boundaryWidth || Infinity) - DEFAULT_POPOVER_PADDING * 2);
}
var __freeze$l = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$l = (cooked, raw) => __freeze$l(__defProp$l(cooked, "raw", {
  value: __freeze$l(raw || cooked.slice())
}));
var _a$l;
var _b$e;
var _c$8;
var Root$j = st.div(_a$l || (_a$l = __template$l(["\n  position: absolute;\n  pointer-events: none;\n  width: ", "px;\n  height: ", "px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: ", "px ", "px;\n  }\n\n  [data-placement^='top'] > & {\n    bottom: -", "px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -", "px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -", "px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -", "px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])), DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH);
var BorderPath = st.path(_b$e || (_b$e = __template$l(["\n  fill: var(--card-shadow-outline-color);\n"])));
var ShapePath = st.path(_c$8 || (_c$8 = __template$l(["\n  fill: var(--card-bg-color);\n"])));
var PopoverArrow = (0, import_react46.forwardRef)(function PopoverArrow2(props2, ref) {
  return (0, import_jsx_runtime2.jsx)(Root$j, {
    "data-ui": "Popover__arrow",
    ...props2,
    ref,
    children: (0, import_jsx_runtime2.jsxs)("svg", {
      width: DEFAULT_POPOVER_ARROW_WIDTH,
      height: DEFAULT_POPOVER_ARROW_HEIGHT,
      viewBox: "0 0 27 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [(0, import_jsx_runtime2.jsx)(BorderPath, {
        d: "M1.18708 1C3.29803 1.0011 5.29585 1.95479 6.62414 3.59561L11.1683 9.20895C12.369 10.6922 14.631 10.6922 15.8317 9.20894L20.3759 3.59561C21.7042 1.95478 23.702 1.0011 25.8129 1H21.9436C21.0533 1.49255 20.2545 2.15618 19.5986 2.96641L15.0545 8.57975C14.254 9.56855 12.746 9.56855 11.9455 8.57975L7.40139 2.96642C6.74548 2.15618 5.94673 1.49255 5.05643 1H1.18708Z"
      }), (0, import_jsx_runtime2.jsx)(ShapePath, {
        d: "M1.18342 0C3.59749 0 5.88246 1.0901 7.40138 2.96642L11.9455 8.57975C12.746 9.56855 14.254 9.56855 15.0545 8.57975L19.5986 2.96641C21.1175 1.0901 23.4025 0 25.8166 0H27H0H1.18342Z"
      })]
    })
  });
});
var Root$i = st(Card)({
  "&:not([hidden])": {
    display: "flex"
  },
  flexDirection: "column",
  width: "max-content",
  minWidth: "min-content"
});
var PopoverCard = (0, import_react46.memo)((0, import_react46.forwardRef)(function PopoverCard2(props2, ref) {
  const {
    __unstable_margins: marginsProp,
    arrow: arrow2,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props2;
  const {
    zIndex
  } = useLayer();
  const margins = (0, import_react46.useMemo)(() => marginsProp || DEFAULT_POPOVER_MARGINS, [marginsProp]);
  const x = (xProp != null ? xProp : 0) + margins[3];
  const y = (yProp != null ? yProp : 0) + margins[0];
  const rootStyle3 = (0, import_react46.useMemo)(() => ({
    position: strategy,
    top: y,
    left: x,
    width,
    zIndex,
    ...style
  }), [strategy, style, width, x, y, zIndex]);
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowStyle = (0, import_react46.useMemo)(() => {
    const style2 = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide)
      style2[staticSide] = 0 - DEFAULT_POPOVER_ARROW_WIDTH;
    return style2;
  }, [arrowX, arrowY, staticSide]);
  return (0, import_jsx_runtime2.jsxs)(Root$i, {
    "data-ui": "Popover",
    ...restProps,
    "data-placement": placement,
    radius,
    ref,
    scheme,
    shadow,
    sizing: "border",
    style: rootStyle3,
    tone,
    children: [(0, import_jsx_runtime2.jsx)(Flex, {
      "data-ui": "Popover__wrapper",
      direction: "column",
      flex: 1,
      overflow,
      children: (0, import_jsx_runtime2.jsx)(Flex, {
        direction: "column",
        flex: 1,
        padding,
        children
      })
    }), arrow2 && (0, import_jsx_runtime2.jsx)(PopoverArrow, {
      ref: arrowRef,
      style: arrowStyle
    })]
  });
}));
PopoverCard.displayName = "PopoverCard";
var Popover = (0, import_react46.memo)((0, import_react46.forwardRef)(function Popover2(props2, ref) {
  var _a4, _b4, _c4, _d4, _e3, _f3, _g3, _h2, _i2;
  const theme = useTheme();
  const boundaryElementContext = useBoundaryElement();
  const {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    arrow: arrowProp = true,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = false,
    content,
    disabled,
    fallbackPlacements = (_b4 = props2.fallbackPlacements) != null ? _b4 : DEFAULT_FALLBACK_PLACEMENTS$1[(_a4 = props2.placement) != null ? _a4 : "bottom"],
    matchReferenceWidth,
    floatingBoundary = (_c4 = props2.boundaryElement) != null ? _c4 : boundaryElementContext.element,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = true,
    radius: radiusProp = 3,
    referenceBoundary = (_d4 = props2.boundaryElement) != null ? _d4 : boundaryElementContext.element,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = (_e3 = theme.sanity.layer) == null ? void 0 : _e3.popover.zOffset,
    updateRef,
    ...restProps
  } = props2;
  const boundarySize = (_f3 = useElementSize(boundaryElement)) == null ? void 0 : _f3.border;
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const widthArrayProp = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const forwardedRef = useForwardedRef(ref);
  const arrowRef = (0, import_react46.useRef)(null);
  const rootBoundary = "viewport";
  const mediaIndex = useMediaIndex();
  const boundaryWidth = constrainSize || preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0;
  const width = calcCurrentWidth({
    mediaIndex,
    theme,
    width: widthArrayProp
  });
  const widthRef = (0, import_react46.useRef)(width);
  (0, import_react46.useEffect)(() => {
    widthRef.current = width;
  }, [width]);
  const maxWidth = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  });
  const maxWidthRef = (0, import_react46.useRef)(maxWidth);
  (0, import_react46.useEffect)(() => {
    maxWidthRef.current = maxWidth;
  }, [maxWidth]);
  const referenceWidthRef = (0, import_react46.useRef)();
  (0, import_react46.useEffect)(() => {
    const floatingElement = forwardedRef.current;
    if (!open || !floatingElement)
      return;
    const referenceWidth = referenceWidthRef.current;
    if (matchReferenceWidth) {
      if (referenceWidth !== void 0) {
        floatingElement.style.width = "".concat(referenceWidth, "px");
      }
    } else if (width !== void 0) {
      floatingElement.style.width = "".concat(width, "px");
    }
    if (typeof maxWidth === "number") {
      floatingElement.style.maxWidth = "".concat(maxWidth, "px");
    }
  }, [width, forwardedRef, matchReferenceWidth, maxWidth, open]);
  const middleware = (0, import_react46.useMemo)(() => {
    const ret = [];
    if (constrainSize || preventOverflow) {
      ret.push(flip({
        boundary: floatingBoundary || void 0,
        fallbackPlacements,
        padding: DEFAULT_POPOVER_PADDING,
        rootBoundary
      }));
    }
    ret.push(offset({
      mainAxis: arrowProp ? DEFAULT_POPOVER_DISTANCE : 0
    }));
    if (constrainSize || matchReferenceWidth) {
      ret.push(size({
        apply(_ref21) {
          let {
            availableWidth,
            availableHeight,
            elements,
            referenceWidth
          } = _ref21;
          referenceWidthRef.current = referenceWidth;
          const _currentWidth = widthRef.current;
          const _maxWidth = maxWidthRef.current;
          if (matchReferenceWidth) {
            elements.floating.style.width = "".concat(referenceWidth, "px");
          } else if (_currentWidth !== void 0) {
            elements.floating.style.width = "".concat(_currentWidth, "px");
          }
          if (constrainSize) {
            elements.floating.style.maxWidth = "".concat(Math.min(availableWidth, _maxWidth != null ? _maxWidth : Infinity), "px");
            elements.floating.style.maxHeight = "".concat(availableHeight, "px");
          }
        },
        boundaryElement: floatingBoundary || void 0,
        constrainSize,
        margins,
        matchReferenceWidth,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (preventOverflow) {
      ret.push(shift({
        boundary: floatingBoundary || void 0,
        rootBoundary,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (arrowProp) {
      ret.push(arrow({
        element: arrowRef,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    ret.push(hide({
      boundary: referenceBoundary || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    }));
    return ret;
  }, [arrowProp, constrainSize, fallbackPlacements, floatingBoundary, margins, matchReferenceWidth, preventOverflow, referenceBoundary]);
  const {
    x,
    y,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const referenceHidden = (_g3 = middlewareData.hide) == null ? void 0 : _g3.referenceHidden;
  const arrowX = (_h2 = middlewareData.arrow) == null ? void 0 : _h2.x;
  const arrowY = (_i2 = middlewareData.arrow) == null ? void 0 : _i2.y;
  const setArrow = (0, import_react46.useCallback)((arrowEl) => {
    arrowRef.current = arrowEl;
  }, []);
  const setFloating = (0, import_react46.useCallback)((node) => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const setReference = (0, import_react46.useCallback)((node) => {
    refs.setReference(node);
    const childRef = childProp == null ? void 0 : childProp.ref;
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
  }, [childProp, refs]);
  const child = (0, import_react46.useMemo)(() => {
    if (!childProp || referenceElement)
      return null;
    return (0, import_react46.cloneElement)(childProp, {
      ref: setReference
    });
  }, [childProp, referenceElement, setReference]);
  (0, import_react46.useEffect)(() => {
    if (updateRef) {
      if (typeof updateRef === "function") {
        updateRef(update);
      } else if (updateRef) {
        updateRef.current = update;
      }
    }
  }, [update, updateRef]);
  (0, import_react46.useEffect)(() => {
    refs.setReference(referenceElement || null);
  }, [referenceElement, refs]);
  if (disabled) {
    return childProp || (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  }
  const popover = (0, import_jsx_runtime2.jsx)(LayerProvider, {
    zOffset,
    children: (0, import_jsx_runtime2.jsx)(PopoverCard, {
      ...restProps,
      __unstable_margins: margins,
      arrow: arrowProp,
      arrowRef: setArrow,
      arrowX,
      arrowY,
      hidden: referenceHidden,
      overflow,
      padding,
      placement,
      radius,
      ref: setFloating,
      scheme,
      shadow,
      strategy,
      tone,
      width: matchReferenceWidth ? referenceWidthRef.current : width,
      x,
      y,
      children: content
    })
  });
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [open && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {
      children: portal ? (0, import_jsx_runtime2.jsx)(Portal, {
        __unstable_name: typeof portal === "string" ? portal : void 0,
        children: popover
      }) : popover
    }), child]
  });
}));
Popover.displayName = "Popover";
var __freeze$k = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$k = (cooked, raw) => __freeze$k(__defProp$k(cooked, "raw", {
  value: __freeze$k(raw || cooked.slice())
}));
var _a$k;
var _b$d;
function radioBaseStyle() {
  return nt(_a$k || (_a$k = __template$k(["\n    position: relative;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n\n    &[data-read-only] {\n      outline: 1px solid red;\n    }\n  "])));
}
function inputElementStyle(props2) {
  const {
    theme
  } = props2;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color3 = theme.sanity.color.input;
  const dist = (input.radio.size - input.radio.markSize) / 2;
  return nt(_b$d || (_b$d = __template$k(["\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n    border-radius: ", ";\n    border: none;\n\n    /* enabled */\n    & + span {\n      display: block;\n      position: relative;\n      height: ", ";\n      width: ", ";\n      border-radius: ", ";\n      background: ", ";\n      box-shadow: ", ";\n\n      &::after {\n        content: '';\n        position: absolute;\n        top: ", ";\n        left: ", ";\n        height: ", ";\n        width: ", ";\n        border-radius: ", ";\n        background: ", ";\n        opacity: 0;\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span::after {\n      opacity: 1;\n    }\n\n    /* read only */\n    &[data-read-only] + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n  "])), rem(input.radio.size / 2), rem(input.radio.size), rem(input.radio.size), rem(input.radio.size / 2), color3.default.enabled.bg, focusRingBorderStyle({
    color: color3.default.enabled.border,
    width: input.border.width
  }), rem(dist), rem(dist), rem(input.radio.markSize), rem(input.radio.markSize), rem(input.radio.markSize / 2), color3.default.enabled.fg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color3.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color3.default.enabled.border,
    width: input.border.width
  }), color3.default.readOnly.border, color3.default.readOnly.bg, color3.default.readOnly.fg, color3.default.disabled.border, color3.default.disabled.bg, color3.default.disabled.fg);
}
var Root$h = st.div(radioBaseStyle);
var Input$4 = st.input(inputElementStyle);
var Radio = (0, import_react46.forwardRef)(function Radio2(props2, forwardedRef) {
  const {
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props2;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return (0, import_jsx_runtime2.jsxs)(Root$h, {
    className,
    "data-ui": "Radio",
    style,
    children: [(0, import_jsx_runtime2.jsx)(Input$4, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      disabled: disabled || readOnly,
      readOnly,
      ref,
      type: "radio"
    }), (0, import_jsx_runtime2.jsx)("span", {})]
  });
});
var __freeze$j = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$j = (cooked, raw) => __freeze$j(__defProp$j(cooked, "raw", {
  value: __freeze$j(raw || cooked.slice())
}));
var _a$j;
var _b$c;
var _c$7;
var _d$5;
function rootStyle() {
  return nt(_a$j || (_a$j = __template$j(["\n    position: relative;\n    width: -webkit-fill-available;\n    width: stretch;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function inputBaseStyle(props2) {
  const {
    theme
  } = props2;
  const font = theme.sanity.fonts.text;
  return nt(_b$c || (_b$c = __template$j(["\n    -webkit-font-smoothing: antialiased;\n    appearance: none;\n    border: 0;\n    font-family: ", ";\n    color: inherit;\n    width: 100%;\n    outline: none;\n    margin: 0;\n\n    &:disabled {\n      opacity: 1;\n    }\n  "])), font.family);
}
function inputColorStyle(props2) {
  const {
    theme
  } = props2;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color3 = theme.sanity.color.input;
  return nt(_c$7 || (_c$7 = __template$j(["\n    /* enabled */\n    background-color: ", ";\n    color: ", ";\n    box-shadow: ", ";\n\n    /* hovered */\n    @media (hover: hover) {\n      &:not(:disabled):hover {\n        background-color: ", ";\n        color: ", ";\n        box-shadow: ", ";\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus {\n      box-shadow: ", ";\n    }\n\n    /* read-only */\n    &[data-read-only] {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n  "])), color3.default.enabled.bg, color3.default.enabled.fg, focusRingBorderStyle({
    color: color3.default.enabled.border,
    width: input.border.width
  }), color3.default.hovered.bg, color3.default.hovered.fg, focusRingBorderStyle({
    color: color3.default.hovered.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      width: input.border.width,
      color: color3.default.enabled.border
    },
    focusRing
  }), color3.default.readOnly.bg, color3.default.readOnly.fg, focusRingBorderStyle({
    color: color3.default.readOnly.border,
    width: input.border.width
  }), color3.default.disabled.bg, color3.default.disabled.fg, focusRingBorderStyle({
    color: color3.default.disabled.border,
    width: input.border.width
  }));
}
function textSize(size2) {
  return {
    fontSize: rem(size2.fontSize),
    lineHeight: rem(size2.lineHeight)
  };
}
function inputTextSizeStyle(props2) {
  const {
    theme,
    $fontSize
  } = props2;
  const {
    sizes
  } = theme.sanity.fonts.text;
  return _responsive(theme.sanity.media, $fontSize, (sizeIndex) => textSize(sizes[sizeIndex] || sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props2) {
  const {
    theme
  } = props2;
  const color3 = theme.sanity.color.input;
  return nt(_d$5 || (_d$5 = __template$j(["\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n\n    /* enabled */\n    --card-fg-color: ", ";\n\n    /* hover */\n    @media (hover: hover) {\n      select:not(disabled):not(:read-only):hover + && {\n        --card-fg-color: ", ";\n      }\n    }\n\n    /* disabled */\n    select:disabled + && {\n      --card-fg-color: ", ";\n    }\n\n    /* read-only */\n    select[data-read-only] + && {\n      --card-fg-color: ", ";\n    }\n  "])), color3.default.enabled.fg, color3.default.hovered.fg, color3.default.disabled.fg, color3.default.readOnly.fg);
}
var selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
var Root$g = st.div(selectStyle.root);
var Input$3 = st.select(selectStyle.input);
var IconBox = st(Box)(selectStyle.iconBox);
var Select = (0, import_react46.forwardRef)(function Select2(props2, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 1,
    readOnly,
    space = 3,
    ...restProps
  } = props2;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return (0, import_jsx_runtime2.jsxs)(Root$g, {
    "data-ui": "Select",
    children: [(0, import_jsx_runtime2.jsx)(Input$3, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-ui": "Select",
      ...restProps,
      $fontSize: useArrayProp(fontSize2),
      $padding: useArrayProp(padding),
      $radius: useArrayProp(radius),
      $space: useArrayProp(space),
      disabled: disabled || readOnly,
      ref,
      children
    }), (0, import_jsx_runtime2.jsx)(IconBox, {
      padding,
      children: (0, import_jsx_runtime2.jsx)(Text3, {
        size: fontSize2,
        children: (0, import_jsx_runtime2.jsx)(SelectIcon, {})
      })
    })]
  });
});
var BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props2.$space, (spaceIndex) => ({
    gridGap: rem(space[spaceIndex])
  }));
}
var Root$f = st(Box)(stackBaseStyle, responsiveStackSpaceStyle);
var Stack = (0, import_react46.forwardRef)(function Stack2(props2, ref) {
  const {
    as,
    space,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$f, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Stack",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref
  });
});
var __freeze$i = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$i = (cooked, raw) => __freeze$i(__defProp$i(cooked, "raw", {
  value: __freeze$i(raw || cooked.slice())
}));
var _a$i;
var _b$b;
var _c$6;
var _d$4;
var _e$2;
var _f$2;
var _g;
function switchBaseStyles() {
  return nt(_a$i || (_a$i = __template$i(["\n    position: relative;\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function switchInputStyles() {
  return nt(_b$b || (_b$b = __template$i(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    padding: 0;\n    margin: 0;\n\n    /* Place the input element above the representation element */\n    z-index: 1;\n  "])));
}
function switchRepresentationStyles(props2) {
  const {
    theme
  } = props2;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color3 = theme.sanity.color.button.default;
  return nt(_c$6 || (_c$6 = __template$i(["\n    --switch-bg-color: ", ";\n    --switch-fg-color: ", ";\n    --switch-box-shadow: none;\n\n    &:not([hidden]) {\n      display: block;\n    }\n    position: relative;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n\n    /* Make sure its not possible to interact with the wrapper element */\n    pointer-events: none;\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      z-index: 1;\n      box-shadow: var(--switch-box-shadow);\n      border-radius: inherit;\n    }\n\n    /* Focus styles */\n    input:focus + && {\n      --switch-box-shadow: ", ";\n    }\n\n    input:focus:not(:focus-visible) + && {\n      --switch-box-shadow: none;\n    }\n\n    input:checked + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    @media (hover: hover) {\n      input:not(:disabled):hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n\n      input:not(:disabled):checked:hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n    }\n\n    input:not([data-read-only]):disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n  "])), color3.default.enabled.bg, color3.default.enabled.fg, rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2), focusRingStyle({
    focusRing
  }), color3.positive.enabled.bg, color3.positive.enabled.fg, color3.default.hovered.bg, color3.default.hovered.fg, color3.positive.hovered.bg, color3.positive.hovered.fg, color3.default.disabled.bg, color3.default.disabled.fg);
}
function switchTrackStyles(props2) {
  const {
    theme
  } = props2;
  const {
    input
  } = theme.sanity;
  return nt(_d$4 || (_d$4 = __template$i(["\n    &:not([hidden]) {\n      display: block;\n    }\n    background-color: var(--switch-bg-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n  "])), rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2));
}
function switchThumbStyles(props2) {
  const {
    $indeterminate,
    theme
  } = props2;
  const {
    input
  } = theme.sanity;
  const trackWidth = input.switch.width;
  const trackHeight = input.switch.height;
  const trackPadding = input.switch.padding;
  const size2 = trackHeight - input.switch.padding * 2;
  const checkedOffset = trackWidth - trackPadding * 2 - size2;
  const indeterminateOffset = trackWidth / 2 - size2 / 2 - trackPadding;
  const checked = $indeterminate !== true && props2.$checked === true;
  return nt(_g || (_g = __template$i(["\n    &:not([hidden]) {\n      display: block;\n    }\n    position: absolute;\n    left: ", ";\n    top: ", ";\n    height: ", ";\n    width: ", ";\n    border-radius: ", ";\n    transition-property: transform;\n    transition-duration: ", "ms;\n    transition-timing-function: ", ";\n    background: var(--switch-fg-color);\n    transform: translate3d(0, 0, 0);\n\n    ", "\n\n    ", "\n  "])), rem(trackPadding), rem(trackPadding), rem(size2), rem(size2), rem(size2 / 2), input.switch.transitionDurationMs, input.switch.transitionTimingFunction, checked && nt(_e$2 || (_e$2 = __template$i(["\n      transform: translate3d(", "px, 0, 0);\n    "])), checkedOffset), $indeterminate && nt(_f$2 || (_f$2 = __template$i(["\n      transform: translate3d(", "px, 0, 0);\n    "])), indeterminateOffset));
}
var Root$e = st.span(switchBaseStyles);
var Input$2 = st.input(switchInputStyles);
var Representation = st.span(switchRepresentationStyles);
var Track = st.span(switchTrackStyles);
var Thumb = st.span(switchThumbStyles);
var Switch = (0, import_react46.forwardRef)(function Switch2(props2, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props2;
  const ref = useForwardedRef(forwardedRef);
  (0, import_react46.useEffect)(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return (0, import_jsx_runtime2.jsxs)(Root$e, {
    className,
    "data-ui": "Switch",
    style,
    children: [(0, import_jsx_runtime2.jsx)(Input$2, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked: indeterminate !== true && checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      ref
    }), (0, import_jsx_runtime2.jsxs)(Representation, {
      "aria-hidden": true,
      "data-name": "representation",
      children: [(0, import_jsx_runtime2.jsx)(Track, {}), (0, import_jsx_runtime2.jsx)(Thumb, {
        $checked: checked,
        $indeterminate: indeterminate
      })]
    })]
  });
});
var __freeze$h = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$h = (cooked, raw) => __freeze$h(__defProp$h(cooked, "raw", {
  value: __freeze$h(raw || cooked.slice())
}));
var _a$h;
var Root$d = st.span(textInputRootStyle);
var InputRoot$1 = st.span(_a$h || (_a$h = __template$h(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
var Input$1 = st.textarea(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation$1 = st.div(responsiveRadiusStyle, textInputRepresentationStyle);
var TextArea = (0, import_react46.forwardRef)(function TextArea2(props2, forwardedRef) {
  const {
    border: border2 = true,
    customValidity,
    disabled = false,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 1,
    weight,
    ...restProps
  } = props2;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  useCustomValidity(ref, customValidity);
  return (0, import_jsx_runtime2.jsx)(Root$d, {
    "data-ui": "TextArea",
    children: (0, import_jsx_runtime2.jsxs)(InputRoot$1, {
      children: [(0, import_jsx_runtime2.jsx)(Input$1, {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize2),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }), (0, import_jsx_runtime2.jsx)(Presentation$1, {
        $radius: useArrayProp(radius),
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border2 ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      })]
    })
  });
});
var __freeze$g = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$g = (cooked, raw) => __freeze$g(__defProp$g(cooked, "raw", {
  value: __freeze$g(raw || cooked.slice())
}));
var _a$g;
var _b$a;
var _c$5;
var _d$3;
var _e$1;
var _f$1;
var CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
var Root$c = st(Card).attrs({
  forwardedAs: "span"
})(textInputRootStyle);
var InputRoot = st.span(_a$g || (_a$g = __template$g(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
var Prefix = st(Card).attrs({
  forwardedAs: "span"
})(_b$a || (_b$a = __template$g(["\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
var Suffix = st(Card).attrs({
  forwardedAs: "span"
})(_c$5 || (_c$5 = __template$g(["\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
var Input = st.input(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation = st.span(responsiveRadiusStyle, textInputRepresentationStyle);
var LeftBox = st(Box)(_d$3 || (_d$3 = __template$g(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
var RightBox = st(Box)(_e$1 || (_e$1 = __template$g(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
var RightCard = st(Card)(_f$1 || (_f$1 = __template$g(["\n  background-color: transparent;\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
var TextInputClearButton = st(Button)({
  "&:not([hidden])": {
    display: "block"
  }
});
var TextInput = (0, import_react46.forwardRef)(function TextInput2(props2, forwardedRef) {
  const {
    border: border2 = true,
    clearButton,
    disabled = false,
    fontSize: fontSizeProp = 2,
    icon,
    iconRight,
    onClear,
    padding: paddingProp = 3,
    prefix,
    radius: radiusProp = 1,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props2;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  const fontSize2 = useArrayProp(fontSizeProp);
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const $hasClearButton = Boolean(clearButton);
  const $hasIcon = Boolean(icon);
  const $hasIconRight = Boolean(iconRight);
  const $hasSuffix = Boolean(suffix);
  const $hasPrefix = Boolean(prefix);
  useCustomValidity(ref, customValidity);
  const handleClearMouseDown = (0, import_react46.useCallback)((event) => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleClearClick = (0, import_react46.useCallback)((event) => {
    var _a22;
    event.preventDefault();
    event.stopPropagation();
    if (onClear)
      onClear();
    (_a22 = ref.current) == null ? void 0 : _a22.focus();
  }, [onClear, ref]);
  const prefixNode = (0, import_react46.useMemo)(() => prefix && (0, import_jsx_runtime2.jsx)(Prefix, {
    borderTop: true,
    borderLeft: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: (0, import_jsx_runtime2.jsx)("span", {
      children: prefix
    })
  }), [prefix, radius]);
  const presentationNode = (0, import_react46.useMemo)(() => (0, import_jsx_runtime2.jsxs)(Presentation, {
    $hasPrefix,
    $hasSuffix,
    $radius: radius,
    $scheme: rootTheme.scheme,
    $tone: rootTheme.tone,
    "data-border": border2 ? "" : void 0,
    "data-scheme": rootTheme.scheme,
    "data-tone": rootTheme.tone,
    children: [icon && (0, import_jsx_runtime2.jsx)(LeftBox, {
      padding,
      children: (0, import_jsx_runtime2.jsxs)(Text3, {
        size: fontSize2,
        children: [(0, import_react46.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react46.createElement)(icon)]
      })
    }), !$hasClearButton && iconRight && (0, import_jsx_runtime2.jsx)(RightBox, {
      padding,
      children: (0, import_jsx_runtime2.jsxs)(Text3, {
        size: fontSize2,
        children: [(0, import_react46.isValidElement)(iconRight) && iconRight, (0, import_react_is.isValidElementType)(iconRight) && (0, import_react46.createElement)(iconRight)]
      })
    })]
  }), [border2, fontSize2, icon, iconRight, padding, radius, rootTheme, $hasClearButton, $hasPrefix, $hasSuffix]);
  const clearButtonBoxPadding = (0, import_react46.useMemo)(() => padding.map((v) => {
    if (v === 0)
      return 0;
    if (v === 1)
      return 1;
    if (v === 2)
      return 1;
    return v - 2;
  }), [padding]);
  const clearButtonPadding = (0, import_react46.useMemo)(() => padding.map((v) => {
    if (v === 0)
      return 0;
    if (v === 1)
      return 0;
    if (v === 2)
      return 1;
    return v - 1;
  }), [padding]);
  const clearButtonProps = (0, import_react46.useMemo)(() => typeof clearButton === "object" ? clearButton : EMPTY_RECORD, [clearButton]);
  const clearButtonNode = (0, import_react46.useMemo)(() => !disabled && !readOnly && clearButton && (0, import_jsx_runtime2.jsx)(RightCard, {
    forwardedAs: "span",
    padding: clearButtonBoxPadding,
    style: CLEAR_BUTTON_BOX_STYLE,
    tone: customValidity ? "critical" : "inherit",
    children: (0, import_jsx_runtime2.jsx)(TextInputClearButton, {
      "aria-label": "Clear",
      "data-qa": "clear-button",
      fontSize: fontSize2,
      icon: CloseIcon,
      mode: "bleed",
      padding: clearButtonPadding,
      radius,
      ...clearButtonProps,
      onClick: handleClearClick,
      onMouseDown: handleClearMouseDown
    })
  }), [clearButton, clearButtonBoxPadding, clearButtonPadding, clearButtonProps, customValidity, disabled, fontSize2, handleClearClick, handleClearMouseDown, radius, readOnly]);
  const suffixNode = (0, import_react46.useMemo)(() => suffix && (0, import_jsx_runtime2.jsx)(Suffix, {
    borderTop: true,
    borderRight: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: (0, import_jsx_runtime2.jsx)("span", {
      children: suffix
    })
  }), [radius, suffix]);
  return (0, import_jsx_runtime2.jsxs)(Root$c, {
    "data-ui": "TextInput",
    tone: rootTheme.tone,
    children: [prefixNode, (0, import_jsx_runtime2.jsxs)(InputRoot, {
      children: [(0, import_jsx_runtime2.jsx)(Input, {
        "data-as": "input",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: fontSize2,
        $iconLeft: $hasIcon,
        $iconRight: $hasIconRight || $hasClearButton,
        $padding: padding,
        $scheme: rootTheme.scheme,
        $space: space,
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        readOnly,
        ref,
        type
      }), presentationNode, clearButtonNode]
    }), suffixNode]
  });
});
function useDelayedState(initialState) {
  const [state, setState] = (0, import_react46.useState)(initialState);
  const delayedAction = (0, import_react46.useRef)();
  const onStateChange = (0, import_react46.useCallback)((nextState, delay3) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current) {
      clearTimeout(delayedAction.current);
      delayedAction.current = void 0;
    }
    if (!delay3)
      return action();
    delayedAction.current = setTimeout(action, delay3);
  }, []);
  return [state, onStateChange];
}
var DEFAULT_TOOLTIP_PADDING = 4;
var DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
var __freeze$f = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template$f = (cooked, raw) => __freeze$f(__defProp$f(cooked, "raw", {
  value: __freeze$f(raw || cooked.slice())
}));
var _a$f;
var _b$9;
var _c$4;
var Root$b = st.div(_a$f || (_a$f = __template$f(["\n  position: absolute;\n  pointer-events: none;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: 7.5px 7.5px;\n  }\n\n  /* position: absolute;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    &:not([hidden]) {\n      display: block;\n    }\n    transform-origin: 7.5px 7.5px;\n  } */\n\n  [data-placement^='top'] > & {\n    bottom: -27px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -27px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -27px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -27px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])));
var Border = st.path(_b$9 || (_b$9 = __template$f(["\n  fill: var(--card-shadow-outline-color);\n"])));
var Shape = st.path(_c$4 || (_c$4 = __template$f(["\n  fill: var(--card-bg-color);\n"])));
var TooltipArrow = (0, import_react46.forwardRef)(function TooltipArrow2(props2, ref) {
  const {
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Root$b, {
    "data-ui": "Tooltip__arrow",
    ...restProps,
    ref,
    children: (0, import_jsx_runtime2.jsxs)("svg", {
      width: "15",
      height: "15",
      viewBox: "0 0 15 15",
      children: [(0, import_jsx_runtime2.jsx)(Border, {
        d: "M11.5266 1C11.032 1.32802 10.5837 1.73105 10.1995 2.20057L9.04792 3.6081C8.24771 4.58614 6.7523 4.58614 5.95209 3.6081L4.80047 2.20057C4.41632 1.73105 3.96796 1.32802 3.47341 1H0.156727C1.65639 1 3.07687 1.67313 4.02651 2.83381L5.17813 4.24134C6.37844 5.70839 8.62156 5.70839 9.82187 4.24134L10.9735 2.83381C11.9231 1.67313 13.3436 1 14.8433 1H11.5266Z"
      }), (0, import_jsx_runtime2.jsx)(Shape, {
        d: "M0.156725 0C1.95632 0 3.66089 0.80776 4.80047 2.20057L5.95209 3.6081C6.75229 4.58614 8.24771 4.58614 9.04791 3.6081L10.1995 2.20057C11.3391 0.80776 13.0437 0 14.8433 0H15H0H0.156725Z"
      })]
    })
  });
});
var key$4 = Symbol.for("@sanity/ui/context/tooltipDelayGroup");
globalScope[key$4] = globalScope[key$4] || (0, import_react46.createContext)(null);
var TooltipDelayGroupContext = globalScope[key$4];
function useTooltipDelayGroup() {
  const value = (0, import_react46.useContext)(TooltipDelayGroupContext);
  return value;
}
function TooltipDelayGroupProvider(props2) {
  const {
    children,
    delay: delay3
  } = props2;
  const [isGroupActive, setIsGroupActive] = useDelayedState(false);
  const [openTooltipId, setOpenTooltipId] = useDelayedState(null);
  const isInsideContext = useTooltipDelayGroup();
  if (isInsideContext) {
    throw new Error("TooltipDelayGroupProvider cannot be nested inside another TooltipDelayGroupProvider");
  }
  const openDelay = typeof delay3 === "number" ? delay3 : (delay3 == null ? void 0 : delay3.open) || 0;
  const closeDelay = typeof delay3 === "number" ? delay3 : (delay3 == null ? void 0 : delay3.close) || 0;
  const value = (0, import_react46.useMemo)(() => ({
    isGroupActive,
    setIsGroupActive,
    openTooltipId,
    setOpenTooltipId,
    // When the group is active, we want the next tooltip to open immediately.
    openDelay: isGroupActive ? 1 : openDelay,
    closeDelay
  }), [closeDelay, isGroupActive, openDelay, openTooltipId, setIsGroupActive, setOpenTooltipId]);
  return (0, import_jsx_runtime2.jsx)(TooltipDelayGroupContext.Provider, {
    value,
    children
  });
}
var __freeze$e = Object.freeze;
var __defProp$e = Object.defineProperty;
var __template$e = (cooked, raw) => __freeze$e(__defProp$e(cooked, "raw", {
  value: __freeze$e(raw || cooked.slice())
}));
var _a$e;
var Root$a = st(Layer)(_a$e || (_a$e = __template$e(["\n  pointer-events: none;\n  max-width: ", "px;\n"])), (_ref22) => {
  let {
    $maxWidth
  } = _ref22;
  return $maxWidth;
});
var Tooltip = (0, import_react46.forwardRef)(function Tooltip2(props2, ref) {
  var _a22, _b4, _c4, _d4, _e3, _f3;
  const boundaryElementContext = useBoundaryElement();
  const theme = useTheme();
  const {
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = (_b4 = props2.fallbackPlacements) != null ? _b4 : DEFAULT_FALLBACK_PLACEMENTS[(_a22 = props2.placement) != null ? _a22 : "bottom"],
    padding,
    placement: placementProp = "bottom",
    portal: portalProp,
    scheme,
    shadow = 2,
    zOffset = (_c4 = theme.sanity.layer) == null ? void 0 : _c4.tooltip.zOffset,
    delay: delay3,
    ...restProps
  } = props2;
  const fallbackPlacements = useArrayProp(fallbackPlacementsProp);
  const forwardedRef = useForwardedRef(ref);
  const [referenceElement, setReferenceElement] = (0, import_react46.useState)(null);
  const arrowRef = (0, import_react46.useRef)(null);
  const rootBoundary = "viewport";
  const portal = usePortal();
  const portalElement = typeof portalProp === "string" ? ((_d4 = portal.elements) == null ? void 0 : _d4[portalProp]) || null : portal.element;
  const tooltipWidth = (0, import_react46.useMemo)(() => {
    const availableWidths = [...boundaryElement ? [boundaryElement.offsetWidth] : [], (portalElement == null ? void 0 : portalElement.offsetWidth) || document.body.offsetWidth];
    return Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2;
  }, [boundaryElement, portalElement == null ? void 0 : portalElement.offsetWidth]);
  const middleware = (0, import_react46.useMemo)(() => {
    const ret = [];
    ret.push(flip({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: DEFAULT_TOOLTIP_PADDING,
      rootBoundary
    }));
    ret.push(offset({
      mainAxis: 3
    }));
    ret.push(shift({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: DEFAULT_TOOLTIP_PADDING
    }));
    ret.push(arrow({
      element: arrowRef,
      padding: 2
    }));
    return ret;
  }, [boundaryElement, fallbackPlacements]);
  const {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowX = (_e3 = middlewareData.arrow) == null ? void 0 : _e3.x;
  const arrowY = (_f3 = middlewareData.arrow) == null ? void 0 : _f3.y;
  const arrowStyle = (0, import_react46.useMemo)(() => {
    const style = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide)
      style[staticSide] = -15;
    return style;
  }, [arrowX, arrowY, staticSide]);
  const tooltipId = (0, import_react46.useId)();
  const [isOpen, setIsOpen] = useDelayedState(false);
  const delayGroupContext = useTooltipDelayGroup();
  const showTooltip = isOpen || (delayGroupContext == null ? void 0 : delayGroupContext.openTooltipId) === tooltipId;
  const isInsideGroup = delayGroupContext !== null;
  const openDelayProp = typeof delay3 === "number" ? delay3 : (delay3 == null ? void 0 : delay3.open) || 0;
  const closeDelayProp = typeof delay3 === "number" ? delay3 : (delay3 == null ? void 0 : delay3.close) || 0;
  const openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp;
  const closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp;
  const handleIsOpenChange = (0, import_react46.useCallback)((open, immediate) => {
    if (isInsideGroup) {
      if (open) {
        const groupedOpenDelay = immediate ? 0 : openDelay;
        delayGroupContext.setIsGroupActive(open, groupedOpenDelay);
        delayGroupContext.setOpenTooltipId(tooltipId, groupedOpenDelay);
      } else {
        const minimumGroupDeactivateDelay = 200;
        const groupDeactivateDelay = closeDelay > minimumGroupDeactivateDelay ? closeDelay : minimumGroupDeactivateDelay;
        delayGroupContext.setIsGroupActive(open, groupDeactivateDelay);
        delayGroupContext.setOpenTooltipId(null, immediate ? 0 : closeDelay);
      }
    } else {
      const standaloneDelay = immediate ? 0 : open ? openDelay : closeDelay;
      setIsOpen(open, standaloneDelay);
    }
  }, [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]);
  const handleBlur = (0, import_react46.useCallback)((e2) => {
    var _a32, _b22;
    handleIsOpenChange(false);
    (_b22 = (_a32 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a32.onBlur) == null ? void 0 : _b22.call(_a32, e2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleClick = (0, import_react46.useCallback)((e2) => {
    var _a32, _b22;
    handleIsOpenChange(false, true);
    (_b22 = childProp == null ? void 0 : (_a32 = childProp.props).onClick) == null ? void 0 : _b22.call(_a32, e2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleContextMenu = (0, import_react46.useCallback)((e2) => {
    var _a32, _b22;
    handleIsOpenChange(false, true);
    (_b22 = childProp == null ? void 0 : (_a32 = childProp.props).onContextMenu) == null ? void 0 : _b22.call(_a32, e2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleFocus = (0, import_react46.useCallback)((e2) => {
    var _a32, _b22;
    handleIsOpenChange(true);
    (_b22 = (_a32 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a32.onFocus) == null ? void 0 : _b22.call(_a32, e2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleMouseEnter = (0, import_react46.useCallback)((e2) => {
    var _a32, _b22;
    handleIsOpenChange(true);
    (_b22 = (_a32 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a32.onMouseEnter) == null ? void 0 : _b22.call(_a32, e2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleMouseLeave = (0, import_react46.useCallback)((e2) => {
    var _a32, _b22;
    handleIsOpenChange(false);
    (_b22 = (_a32 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a32.onMouseLeave) == null ? void 0 : _b22.call(_a32, e2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  (0, import_react46.useEffect)(() => {
    if (!isOpen)
      return;
    function handleWindowMouseMove(event) {
      if (!referenceElement)
        return;
      const isHoveringReference = referenceElement === event.target || event.target instanceof Node && referenceElement.contains(event.target);
      if (!isHoveringReference) {
        handleIsOpenChange(false);
        window.removeEventListener("mousemove", handleWindowMouseMove);
      }
    }
    window.addEventListener("mousemove", handleWindowMouseMove);
    return () => {
      window.removeEventListener("mousemove", handleWindowMouseMove);
    };
  }, [isOpen, referenceElement, handleIsOpenChange]);
  (0, import_react46.useEffect)(() => {
    if (disabled)
      handleIsOpenChange(false);
  }, [disabled, handleIsOpenChange]);
  (0, import_react46.useEffect)(() => {
    if (!content)
      handleIsOpenChange(false);
  }, [content, handleIsOpenChange]);
  (0, import_react46.useEffect)(() => refs.setReference(referenceElement), [referenceElement, refs]);
  (0, import_react46.useEffect)(() => {
    if (!showTooltip)
      return;
    function handleWindowKeyDown(event) {
      if (event.key === "Escape") {
        handleIsOpenChange(false, true);
      }
    }
    window.addEventListener("keydown", handleWindowKeyDown);
    return () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]);
  const setArrow = (0, import_react46.useCallback)((arrowEl) => {
    arrowRef.current = arrowEl;
    update();
  }, [update]);
  const setFloating = (0, import_react46.useCallback)((node) => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const childRef = childProp == null ? void 0 : childProp.ref;
  const setReference = (0, import_react46.useCallback)((node) => {
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
    setReferenceElement(node);
  }, [childRef]);
  const child = (0, import_react46.useMemo)(() => {
    if (!childProp)
      return null;
    return (0, import_react46.cloneElement)(childProp, {
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onContextMenu: handleContextMenu,
      ref: setReference
    });
  }, [childProp, handleBlur, handleClick, handleContextMenu, handleFocus, handleMouseEnter, handleMouseLeave, setReference]);
  if (!child)
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  if (disabled)
    return child;
  const root = (0, import_jsx_runtime2.jsx)(Root$a, {
    "data-ui": "Tooltip",
    ...restProps,
    ref: setFloating,
    style: floatingStyles,
    zOffset,
    $maxWidth: tooltipWidth,
    children: (0, import_jsx_runtime2.jsxs)(Card, {
      "data-ui": "Tooltip__card",
      "data-placement": placement,
      padding,
      radius: 2,
      scheme,
      shadow,
      children: [content, (0, import_jsx_runtime2.jsx)(TooltipArrow, {
        ref: setArrow,
        style: arrowStyle
      })]
    })
  });
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [child, showTooltip && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {
      children: portalProp ? (0, import_jsx_runtime2.jsx)(Portal, {
        __unstable_name: typeof portalProp === "string" ? portalProp : void 0,
        children: root
      }) : root
    })]
  });
});
var __freeze$d = Object.freeze;
var __defProp$d = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$d(cooked, "raw", {
  value: __freeze$d(raw || cooked.slice())
}));
var _a$d;
var _b$8;
var _c$3;
var _d$2;
var Root$9 = st.div(_a$d || (_a$d = __template$d(["\n  line-height: 0;\n"])));
var ListBox = st(Box)(_b$8 || (_b$8 = __template$d(["\n  & > ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n"])));
var rotate = ct(_c$3 || (_c$3 = __template$d(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var AnimatedSpinnerIcon = st(SpinnerIcon)(_d$2 || (_d$2 = __template$d(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function AutocompleteOption(props2) {
  const {
    children,
    id: id4,
    onSelect,
    selected,
    value
  } = props2;
  const handleClick = (0, import_react46.useCallback)(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]);
  const handleKeyDown = (0, import_react46.useCallback)((event) => {
    if (event.key === "Enter" && !_isEnterToClickElement(event.currentTarget)) {
      handleClick();
    }
  }, [handleClick]);
  return (0, import_jsx_runtime2.jsx)("li", {
    "aria-selected": selected,
    "data-ui": "AutocompleteOption",
    id: id4,
    role: "option",
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    children
  });
}
function autocompleteReducer(state, msg2) {
  if (msg2.type === "input/change") {
    return {
      ...state,
      activeValue: null,
      focused: true,
      query: msg2.query
    };
  }
  if (msg2.type === "input/focus") {
    return {
      ...state,
      focused: true
    };
  }
  if (msg2.type === "root/blur") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg2.type === "root/clear") {
    return {
      ...state,
      activeValue: null,
      query: null,
      value: null
    };
  }
  if (msg2.type === "root/escape") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg2.type === "root/open") {
    return {
      ...state,
      query: state.query || msg2.query
    };
  }
  if (msg2.type === "root/setActiveValue") {
    return {
      ...state,
      activeValue: msg2.value,
      listFocused: msg2.listFocused || state.listFocused
    };
  }
  if (msg2.type === "root/setListFocused") {
    return {
      ...state,
      listFocused: msg2.listFocused
    };
  }
  if (msg2.type === "value/change") {
    return {
      ...state,
      activeValue: msg2.value,
      query: null,
      value: msg2.value
    };
  }
  return state;
}
var AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
var AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
var AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
var DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
var DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
var InnerAutocomplete = (0, import_react46.forwardRef)(function InnerAutocomplete2(props2, ref) {
  const {
    border: border2 = true,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: fontSize2 = 2,
    icon,
    id: id4,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 3,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props2;
  const [state, dispatch] = (0, import_react46.useReducer)(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: false,
    listFocused: false,
    query: null,
    value: valueProp || null
  });
  const {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  const defaultRenderOption = (0, import_react46.useCallback)((_ref23) => {
    let {
      value: value2
    } = _ref23;
    return (0, import_jsx_runtime2.jsx)(Card, {
      "data-as": "button",
      padding: paddingProp,
      radius: 2,
      tone: "inherit",
      children: (0, import_jsx_runtime2.jsx)(Text3, {
        size: fontSize2,
        textOverflow: "ellipsis",
        children: value2
      })
    });
  }, [fontSize2, paddingProp]);
  const renderOption = typeof renderOptionProp === "function" ? renderOptionProp : defaultRenderOption;
  const filterOption = typeof filterOptionProp === "function" ? filterOptionProp : DEFAULT_FILTER_OPTION;
  const rootElementRef = (0, import_react46.useRef)(null);
  const resultsPopoverElementRef = (0, import_react46.useRef)(null);
  const inputElementRef = (0, import_react46.useRef)(null);
  const listBoxElementRef = (0, import_react46.useRef)(null);
  const listFocusedRef = (0, import_react46.useRef)(false);
  const valueRef = (0, import_react46.useRef)(value);
  const valuePropRef = (0, import_react46.useRef)(valueProp);
  const popoverMouseWithinRef = (0, import_react46.useRef)(false);
  const forwardedRef = useForwardedRef(ref);
  const listBoxId = "".concat(id4, "-listbox");
  const options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY;
  const padding = useArrayProp(paddingProp);
  const currentOption = (0, import_react46.useMemo)(() => value !== null ? options.find((o) => o.value === value) : void 0, [options, value]);
  const filteredOptions = (0, import_react46.useMemo)(() => options.filter((option) => query ? filterOption(query, option) : true), [filterOption, options, query]);
  const filteredOptionsLen = filteredOptions.length;
  const activeItemId = activeValue ? "".concat(id4, "-option-").concat(activeValue) : void 0;
  const expanded = query !== null && loading || focused && query !== null;
  const handleRootBlur = (0, import_react46.useCallback)((event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current) {
        return;
      }
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e2 of elements) {
          if (e2 === document.activeElement || e2.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
        }
      }
      if (focusInside === false) {
        dispatch({
          type: "root/blur"
        });
        popoverMouseWithinRef.current = false;
        if (onQueryChange)
          onQueryChange(null);
        if (onBlur)
          onBlur(event);
      }
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]);
  const handleRootFocus = (0, import_react46.useCallback)((event) => {
    const listBoxElement = listBoxElementRef.current;
    const focusedElement = event.target instanceof HTMLElement ? event.target : null;
    const listFocused2 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || false;
    if (listFocused2 !== listFocusedRef.current) {
      listFocusedRef.current = listFocused2;
      dispatch({
        type: "root/setListFocused",
        listFocused: listFocused2
      });
    }
  }, []);
  const handleOptionSelect = (0, import_react46.useCallback)((v) => {
    var _a4;
    dispatch({
      type: "value/change",
      value: v
    });
    popoverMouseWithinRef.current = false;
    if (onSelect)
      onSelect(v);
    valueRef.current = v;
    if (onChange)
      onChange(v);
    if (onQueryChange)
      onQueryChange(null);
    (_a4 = inputElementRef.current) == null ? void 0 : _a4.focus();
  }, [onChange, onSelect, onQueryChange]);
  const handleRootKeyDown = (0, import_react46.useCallback)((event) => {
    var _a4, _b4;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      if (!filteredOptionsLen)
        return;
      const activeOption = filteredOptions.find((o) => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      if (!filteredOptionsLen)
        return;
      const activeOption = filteredOptions.find((o) => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "Escape") {
      dispatch({
        type: "root/escape"
      });
      popoverMouseWithinRef.current = false;
      if (onQueryChange)
        onQueryChange(null);
      (_a4 = inputElementRef.current) == null ? void 0 : _a4.focus();
      return;
    }
    const target = event.target;
    const listEl = listBoxElementRef.current;
    if ((listEl === target || (listEl == null ? void 0 : listEl.contains(target))) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
      (_b4 = inputElementRef.current) == null ? void 0 : _b4.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]);
  const handleInputChange = (0, import_react46.useCallback)((event) => {
    const nextQuery = event.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    });
    if (onQueryChange)
      onQueryChange(nextQuery);
  }, [onQueryChange]);
  const handleInputFocus = (0, import_react46.useCallback)((event) => {
    if (!focused) {
      dispatch({
        type: "input/focus"
      });
      if (onFocus)
        onFocus(event);
    }
  }, [focused, onFocus]);
  const handlePopoverMouseEnter = (0, import_react46.useCallback)(() => {
    popoverMouseWithinRef.current = true;
  }, []);
  const handlePopoverMouseLeave = (0, import_react46.useCallback)(() => {
    popoverMouseWithinRef.current = false;
  }, []);
  const handleClearButtonClick = (0, import_react46.useCallback)(() => {
    var _a4;
    dispatch({
      type: "root/clear"
    });
    valueRef.current = "";
    if (onChange)
      onChange("");
    if (onQueryChange)
      onQueryChange(null);
    (_a4 = inputElementRef.current) == null ? void 0 : _a4.focus();
  }, [onChange, onQueryChange]);
  const handleClearButtonFocus = (0, import_react46.useCallback)(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  (0, import_react46.useEffect)(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp;
      if (valueProp !== void 0) {
        dispatch({
          type: "value/change",
          value: valueProp
        });
        valueRef.current = valueProp;
      }
      return;
    }
    if (valueProp !== valueRef.current) {
      valueRef.current = valueProp || null;
      dispatch({
        type: "value/change",
        value: valueProp || null
      });
    }
  }, [valueProp]);
  (0, import_react46.useEffect)(() => {
    if (!focused && valueRef.current) {
      dispatch({
        type: "root/setActiveValue",
        value: valueRef.current
      });
    }
  }, [focused]);
  (0, import_react46.useEffect)(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement)
      return;
    const activeOption = filteredOptions.find((o) => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption);
      const activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement)) {
          return;
        }
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const setRef = (0, import_react46.useCallback)((el) => {
    inputElementRef.current = el;
    forwardedRef.current = el;
  }, [forwardedRef]);
  const clearButton = (0, import_react46.useMemo)(() => {
    if (!loading && !disabled && value) {
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
    }
    return void 0;
  }, [disabled, handleClearButtonFocus, loading, value]);
  const openButtonBoxPadding = (0, import_react46.useMemo)(() => padding.map((v) => {
    if (v === 0)
      return 0;
    if (v === 1)
      return 1;
    if (v === 2)
      return 1;
    return v - 2;
  }), [padding]);
  const openButtonPadding = (0, import_react46.useMemo)(() => padding.map((v) => Math.max(v - 1, 0)), [padding]);
  const openButtonProps = (0, import_react46.useMemo)(() => typeof openButton === "object" ? openButton : EMPTY_RECORD, [openButton]);
  const handleOpenClick = (0, import_react46.useCallback)((event) => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
    if (openButtonProps.onClick)
      openButtonProps.onClick(event);
    _raf(() => {
      var _a4;
      return (_a4 = inputElementRef.current) == null ? void 0 : _a4.focus();
    });
  }, [currentOption, openButtonProps, renderValue, value]);
  const openButtonNode = (0, import_react46.useMemo)(() => !disabled && !readOnly && openButton ? (0, import_jsx_runtime2.jsx)(Box, {
    "aria-hidden": expanded,
    padding: openButtonBoxPadding,
    children: (0, import_jsx_runtime2.jsx)(Button, {
      "aria-label": "Open",
      disabled: expanded,
      fontSize: fontSize2,
      icon: ChevronDownIcon,
      mode: "bleed",
      padding: openButtonPadding,
      ...openButtonProps,
      onClick: handleOpenClick
    })
  }) : void 0, [disabled, expanded, fontSize2, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]);
  const inputValue = (0, import_react46.useMemo)(() => {
    if (query === null) {
      if (value !== null) {
        return renderValue(value, currentOption);
      }
      return "";
    }
    return query;
  }, [currentOption, query, renderValue, value]);
  const input = (0, import_jsx_runtime2.jsx)(TextInput, {
    ...restProps,
    "aria-activedescendant": activeItemId,
    "aria-autocomplete": "list",
    "aria-expanded": expanded,
    "aria-owns": listBoxId,
    autoCapitalize: "off",
    autoComplete: "off",
    autoCorrect: "off",
    border: border2,
    clearButton,
    customValidity,
    disabled,
    fontSize: fontSize2,
    icon,
    iconRight: loading && AnimatedSpinnerIcon,
    id: id4,
    inputMode: "search",
    onChange: handleInputChange,
    onClear: handleClearButtonClick,
    onFocus: handleInputFocus,
    padding,
    prefix,
    radius,
    readOnly,
    ref: setRef,
    role: "combobox",
    spellCheck: false,
    suffix: suffix || openButtonNode,
    value: inputValue
  });
  const handleListBoxKeyDown = (0, import_react46.useCallback)((event) => {
    var _a4;
    if (event.key === "Tab") {
      if (listFocused)
        (_a4 = inputElementRef.current) == null ? void 0 : _a4.focus();
    }
  }, [listFocused]);
  const content = (0, import_react46.useMemo)(() => {
    if (filteredOptions.length === 0)
      return null;
    return (0, import_jsx_runtime2.jsx)(ListBox, {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: (0, import_jsx_runtime2.jsx)(Stack, {
        as: "ul",
        "aria-multiselectable": false,
        "data-ui": "AutoComplete__resultsList",
        id: listBoxId,
        ref: listBoxElementRef,
        role: "listbox",
        space: 1,
        children: filteredOptions.map((option) => {
          const active = activeValue !== null ? option.value === activeValue : currentOption === option;
          return (0, import_jsx_runtime2.jsx)(AutocompleteOption, {
            id: "".concat(id4, "-option-").concat(option.value),
            onSelect: handleOptionSelect,
            selected: active,
            value: option.value,
            children: (0, import_react46.cloneElement)(renderOption(option), {
              disabled: loading,
              selected: active,
              tabIndex: listFocused && active ? 0 : -1
            })
          }, option.value);
        })
      })
    });
  }, [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id4, listBox, listBoxId, listFocused, loading, renderOption]);
  const results = (0, import_react46.useMemo)(() => {
    if (renderPopover) {
      return renderPopover({
        content,
        hidden: !expanded,
        inputElement: inputElementRef.current,
        onMouseEnter: handlePopoverMouseEnter,
        onMouseLeave: handlePopoverMouseLeave
      }, resultsPopoverElementRef);
    }
    if (filteredOptionsLen === 0) {
      return null;
    }
    return (0, import_jsx_runtime2.jsx)(Popover, {
      arrow: false,
      constrainSize: true,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: true,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: true,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    });
  }, [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return (0, import_jsx_runtime2.jsxs)(Root$9, {
    "data-ui": "Autocomplete",
    onBlur: handleRootBlur,
    onFocus: handleRootFocus,
    onKeyDown: handleRootKeyDown,
    ref: rootElementRef,
    children: [input, results]
  });
});
var Autocomplete = InnerAutocomplete;
var __freeze$c = Object.freeze;
var __defProp$c = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$c(cooked, "raw", {
  value: __freeze$c(raw || cooked.slice())
}));
var _a$c;
var _b$7;
var Root$8 = st.ol(_a$c || (_a$c = __template$c(["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  list-style: none;\n  align-items: center;\n  white-space: nowrap;\n  line-height: 0;\n"])));
var ExpandButton = st(Button)(_b$7 || (_b$7 = __template$c(["\n  appearance: none;\n  margin: -4px;\n"])));
var Breadcrumbs = (0, import_react46.forwardRef)(function Breadcrumbs2(props2, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props2;
  const space = useArrayProp(spaceRaw);
  const [open, setOpen] = (0, import_react46.useState)(false);
  const [expandElement, setExpandElement] = (0, import_react46.useState)(null);
  const [popoverElement, setPopoverElement] = (0, import_react46.useState)(null);
  const collapse = (0, import_react46.useCallback)(() => setOpen(false), []);
  const expand = (0, import_react46.useCallback)(() => setOpen(true), []);
  useClickOutside(collapse, [expandElement, popoverElement]);
  const rawItems = (0, import_react46.useMemo)(() => import_react46.Children.toArray(children).filter((child) => {
    return (0, import_react46.isValidElement)(child);
  }), [children]);
  const items = (0, import_react46.useMemo)(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2);
      const afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), (0, import_jsx_runtime2.jsx)(Popover, {
        constrainSize: true,
        content: (0, import_jsx_runtime2.jsx)(Stack, {
          as: "ol",
          overflow: "auto",
          padding: space,
          space,
          children: rawItems.slice(beforeLength - 1, len - afterLength)
        }),
        open,
        placement: "top",
        portal: true,
        ref: setPopoverElement,
        children: (0, import_jsx_runtime2.jsx)(ExpandButton, {
          fontSize: 1,
          mode: "bleed",
          onClick: open ? collapse : expand,
          padding: 1,
          ref: setExpandElement,
          selected: open,
          text: ""
        })
      }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return (0, import_jsx_runtime2.jsx)(Root$8, {
    "data-ui": "Breadcrumbs",
    ...restProps,
    ref,
    children: items.map((item, itemIndex) => (0, import_jsx_runtime2.jsxs)(import_react46.Fragment, {
      children: [itemIndex > 0 && (0, import_jsx_runtime2.jsx)(Box, {
        "aria-hidden": true,
        as: "li",
        paddingX: space,
        children: separator || (0, import_jsx_runtime2.jsx)(Text3, {
          muted: true,
          children: "/"
        })
      }), (0, import_jsx_runtime2.jsx)(Box, {
        as: "li",
        children: item
      })]
    }, itemIndex))
  });
});
function dialogStyle(_ref24) {
  let {
    theme
  } = _ref24;
  const color3 = theme.sanity.color.base;
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color3.shadow.umbra
  };
}
function responsiveDialogPositionStyle(props2) {
  const {
    theme
  } = props2;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props2.$position, (position) => ({
    "&&": {
      position
    }
  }));
}
var key$3 = Symbol.for("@sanity/ui/context/dialog");
globalScope[key$3] = globalScope[key$3] || (0, import_react46.createContext)({
  version: 0
});
var DialogContext = globalScope[key$3];
function useDialog() {
  return (0, import_react46.useContext)(DialogContext);
}
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b;
var _b$6;
var _c$2;
var _d$1;
var _e;
var _f;
function isTargetWithinScope(boundaryElement, portalElement, target) {
  if (!boundaryElement || !portalElement)
    return true;
  return containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
var Root$7 = st(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle);
var DialogContainer = st(Container)(_a$b || (_a$b = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n"])));
var DialogCardRoot = st(Card)(_b$6 || (_b$6 = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  min-height: 0;\n  max-height: 100%;\n  overflow: hidden;\n  overflow: clip;\n"])));
var DialogLayout = st(Flex)(_c$2 || (_c$2 = __template$b(["\n  flex: 1;\n  min-height: 0;\n  width: 100%;\n"])));
var DialogHeader = st(Card)(_d$1 || (_d$1 = __template$b(["\n  position: relative;\n  z-index: 2;\n\n  &:after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-hairline-soft-color);\n  }\n"])));
var DialogContent = st(Box)(_e || (_e = __template$b(["\n  position: relative;\n  z-index: 1;\n  overflow: auto;\n  outline: none;\n"])));
var DialogFooter = st(Box)(_f || (_f = __template$b(["\n  position: relative;\n  z-index: 3;\n  border-top: 1px solid var(--card-hairline-soft-color);\n"])));
var DialogCard = (0, import_react46.forwardRef)(function DialogCard2(props2, ref) {
  var _a22;
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef,
    footer,
    header,
    id: id4,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props2;
  const portal = usePortal();
  const portalElement = portalProp ? ((_a22 = portal.elements) == null ? void 0 : _a22[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const width = useArrayProp(widthProp);
  const forwardedRef = useForwardedRef(ref);
  const [rootElement, setRootElement] = (0, import_react46.useState)(null);
  const localContentRef = (0, import_react46.useRef)(null);
  const layer = useLayer();
  const {
    isTopLayer
  } = layer;
  const labelId = "".concat(id4, "_label");
  const showCloseButton = Boolean(onClose) && hideCloseButton === false;
  const showHeader = Boolean(header) || showCloseButton;
  (0, import_react46.useEffect)(() => {
    if (!autoFocus)
      return;
    if (forwardedRef.current) {
      focusFirstDescendant(forwardedRef.current);
    }
  }, [autoFocus, forwardedRef]);
  useGlobalKeyDown((0, import_react46.useCallback)((event) => {
    if (!isTopLayer || !onClose)
      return;
    const target = document.activeElement;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClose();
    }
  }, [boundaryElement, isTopLayer, onClose, portalElement]));
  useClickOutside((0, import_react46.useCallback)((event) => {
    if (!isTopLayer || !onClickOutside)
      return;
    const target = event.target;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    onClickOutside();
  }, [boundaryElement, isTopLayer, onClickOutside, portalElement]), [rootElement]);
  const setRef = (0, import_react46.useCallback)((el) => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef]);
  const setContentRef = (0, import_react46.useCallback)((el) => {
    localContentRef.current = el;
    if (typeof contentRef === "function")
      contentRef(el);
    else if (contentRef)
      contentRef.current = el;
  }, [contentRef]);
  return (0, import_jsx_runtime2.jsx)(DialogContainer, {
    "data-ui": "DialogCard",
    width,
    children: (0, import_jsx_runtime2.jsx)(DialogCardRoot, {
      radius,
      ref: setRef,
      scheme,
      shadow,
      children: (0, import_jsx_runtime2.jsxs)(DialogLayout, {
        direction: "column",
        children: [showHeader && (0, import_jsx_runtime2.jsx)(DialogHeader, {
          children: (0, import_jsx_runtime2.jsxs)(Flex, {
            children: [(0, import_jsx_runtime2.jsx)(Box, {
              flex: 1,
              padding: 4,
              children: header && (0, import_jsx_runtime2.jsx)(Text3, {
                id: labelId,
                weight: "semibold",
                children: header
              })
            }), showCloseButton && (0, import_jsx_runtime2.jsx)(Box, {
              padding: 2,
              children: (0, import_jsx_runtime2.jsx)(Button, {
                "aria-label": "Close dialog",
                disabled: !onClose,
                icon: CloseIcon,
                mode: "bleed",
                onClick: onClose,
                padding: 3
              })
            })]
          })
        }), (0, import_jsx_runtime2.jsx)(DialogContent, {
          flex: 1,
          ref: setContentRef,
          tabIndex: -1,
          children
        }), footer && (0, import_jsx_runtime2.jsx)(DialogFooter, {
          children: footer
        })]
      })
    })
  });
});
var Dialog = (0, import_react46.forwardRef)(function Dialog2(props2, ref) {
  var _a22, _b22;
  const dialog = useDialog();
  const theme = useTheme();
  const {
    __unstable_autoFocus: autoFocus = true,
    __unstable_hideCloseButton: hideCloseButton = false,
    cardRadius: cardRadiusProp = 3,
    cardShadow = 4,
    children,
    contentRef,
    footer,
    header,
    id: id4,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: paddingProp = 4,
    portal: portalProp,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || ((_a22 = theme.sanity.layer) == null ? void 0 : _a22.dialog.zOffset),
    ...restProps
  } = props2;
  const portal = usePortal();
  const portalElement = portalProp ? ((_b22 = portal.elements) == null ? void 0 : _b22[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const cardRadius = useArrayProp(cardRadiusProp);
  const padding = useArrayProp(paddingProp);
  const position = useArrayProp(positionProp);
  const width = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const preDivRef = (0, import_react46.useRef)(null);
  const postDivRef = (0, import_react46.useRef)(null);
  const cardRef = (0, import_react46.useRef)(null);
  const focusedElementRef = (0, import_react46.useRef)(null);
  const handleFocus = (0, import_react46.useCallback)((event) => {
    onFocus == null ? void 0 : onFocus(event);
    const target = event.target;
    const cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    if (isHTMLElement(event.target)) {
      focusedElementRef.current = event.target;
    }
  }, [onFocus]);
  const labelId = "".concat(id4, "_label");
  const rootClickTimeoutRef = (0, import_react46.useRef)();
  const handleRootClick = (0, import_react46.useCallback)(() => {
    if (rootClickTimeoutRef.current) {
      clearTimeout(rootClickTimeoutRef.current);
    }
    rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target = focusedElementRef.current;
        if (!target || !document.body.contains(target)) {
          const cardElement = cardRef.current;
          if (cardElement)
            focusFirstDescendant(cardElement);
          return;
        }
        target.focus();
      }
    }, 0);
  }, [boundaryElement, portalElement]);
  return (0, import_jsx_runtime2.jsx)(Portal, {
    __unstable_name: portalProp,
    children: (0, import_jsx_runtime2.jsxs)(Root$7, {
      ...restProps,
      $padding: padding,
      $position: position,
      "aria-labelledby": labelId,
      "aria-modal": true,
      "data-ui": "Dialog",
      id: id4,
      onActivate,
      onClick: handleRootClick,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [(0, import_jsx_runtime2.jsx)("div", {
        ref: preDivRef,
        tabIndex: 0
      }), (0, import_jsx_runtime2.jsx)(DialogCard, {
        __unstable_autoFocus: autoFocus,
        __unstable_hideCloseButton: hideCloseButton,
        contentRef,
        footer,
        header,
        id: id4,
        onClickOutside,
        onClose,
        portal: portalProp,
        radius: cardRadius,
        ref: cardRef,
        scheme,
        shadow: cardShadow,
        width,
        children
      }), (0, import_jsx_runtime2.jsx)("div", {
        ref: postDivRef,
        tabIndex: 0
      })]
    })
  });
});
function DialogProvider(props2) {
  const {
    children,
    position,
    zOffset
  } = props2;
  const contextValue = (0, import_react46.useMemo)(() => ({
    version: 0,
    position,
    zOffset
  }), [position, zOffset]);
  return (0, import_jsx_runtime2.jsx)(DialogContext.Provider, {
    value: contextValue,
    children
  });
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a;
var _b$5;
var Root$6 = st.kbd(_a$a || (_a$a = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n  font: inherit;\n"])));
var Key = st(KBD)(_b$5 || (_b$5 = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n"])));
var Hotkeys = (0, import_react46.forwardRef)(function Hotkeys2(props2, ref) {
  const {
    fontSize: fontSize2,
    keys,
    padding,
    radius,
    space: spaceProp = 1,
    ...restProps
  } = props2;
  const space = useArrayProp(spaceProp);
  if (!keys || keys.length === 0) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  }
  return (0, import_jsx_runtime2.jsx)(Root$6, {
    "data-ui": "Hotkeys",
    ...restProps,
    ref,
    children: (0, import_jsx_runtime2.jsx)(Inline, {
      as: "span",
      space,
      children: keys.map((key2, i) => (0, import_jsx_runtime2.jsx)(Key, {
        fontSize: fontSize2,
        padding,
        radius,
        children: key2
      }, i))
    })
  });
});
var key$2 = Symbol.for("@sanity/ui/context/menu");
globalScope[key$2] = globalScope[key$2] || (0, import_react46.createContext)(null);
var MenuContext = globalScope[key$2];
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path2 = [];
  let e2 = el;
  while (e2 !== rootElement) {
    const parentElement = e2.parentElement;
    if (!parentElement)
      return path2;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e2);
    path2.unshift(index);
    if (parentElement === rootElement) {
      return path2;
    }
    e2 = parentElement;
  }
  return path2;
}
var EMPTY_PATH2 = [];
function _sortElements(rootElement, elements) {
  if (!rootElement)
    return;
  const map3 = /* @__PURE__ */ new WeakMap();
  for (const el of elements) {
    map3.set(el, _getDOMPath(rootElement, el));
  }
  const _sort = (a, b) => {
    const _a4 = map3.get(a) || EMPTY_PATH2;
    const _b4 = map3.get(b) || EMPTY_PATH2;
    const len = Math.max(_a4.length, _b4.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a4[i] || -1;
      const bIndex = _b4[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props2) {
  const {
    onKeyDown,
    originElement,
    shouldFocus
  } = props2;
  const elementsRef = (0, import_react46.useRef)([]);
  const [rootElement, setRootElement] = (0, import_react46.useState)(null);
  const [activeIndex, _setActiveIndex] = (0, import_react46.useState)(-1);
  const activeIndexRef = (0, import_react46.useRef)(activeIndex);
  const activeElement = elementsRef.current[activeIndex] || null;
  const mounted = Boolean(rootElement);
  const setActiveIndex = (0, import_react46.useCallback)((nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex);
    activeIndexRef.current = nextActiveIndex;
  }, []);
  const mount = (0, import_react46.useCallback)((element, selected) => {
    if (!element)
      return () => void 0;
    if (elementsRef.current.indexOf(element) === -1) {
      elementsRef.current.push(element);
      _sortElements(rootElement, elementsRef.current);
    }
    if (selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      if (idx > -1) {
        elementsRef.current.splice(idx, 1);
      }
    };
  }, [rootElement, setActiveIndex]);
  const handleKeyDown = (0, import_react46.useCallback)((event) => {
    if (event.key === "Tab") {
      if (originElement) {
        originElement.focus();
      }
      return;
    }
    if (event.key === "Home") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[0];
      if (!el)
        return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[focusableElements.length - 1];
      if (!el)
        return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0)
        return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0)
        return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex + 1) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onKeyDown, originElement, setActiveIndex]);
  const handleItemMouseEnter = (0, import_react46.useCallback)((event) => {
    const element = event.currentTarget;
    const currentIndex = elementsRef.current.indexOf(element);
    setActiveIndex(currentIndex);
  }, [setActiveIndex]);
  const handleItemMouseLeave = (0, import_react46.useCallback)(() => {
    setActiveIndex(-2);
    rootElement == null ? void 0 : rootElement.focus();
  }, [setActiveIndex, rootElement]);
  (0, import_react46.useEffect)(() => {
    if (!mounted)
      return;
    const rafId = window.requestAnimationFrame(() => {
      const _activeIndex = activeIndexRef.current;
      if (_activeIndex === -1) {
        if (shouldFocus === "first") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[0];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[focusableElements.length - 1];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        return;
      }
      const element = elementsRef.current[_activeIndex] || null;
      element == null ? void 0 : element.focus();
    });
    return () => {
      window.cancelAnimationFrame(rafId);
    };
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]);
  return {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  };
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
var Root$5 = st(Box)(_a$9 || (_a$9 = __template$9(["\n  outline: none;\n  overflow: auto;\n"])));
var Menu = (0, import_react46.forwardRef)(function Menu2(props2, ref) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props2.focusFirst && "first" || props2.focusLast && "last" || null,
    space = 1,
    ...restProps
  } = props2;
  const forwardedRef = useForwardedRef(ref);
  const {
    isTopLayer
  } = useLayer();
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  } = useMenuController({
    onKeyDown,
    originElement,
    shouldFocus
  });
  const handleRefChange = (0, import_react46.useCallback)((el) => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef, setRootElement]);
  (0, import_react46.useEffect)(() => {
    if (onItemSelect)
      onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]);
  useClickOutside((0, import_react46.useCallback)((event) => isTopLayer && onClickOutside && onClickOutside(event), [isTopLayer, onClickOutside]), [rootElement]);
  useGlobalKeyDown((0, import_react46.useCallback)((event) => {
    if (!isTopLayer)
      return;
    if (event.key === "Escape") {
      event.stopPropagation();
      if (onEscape)
        onEscape();
    }
  }, [isTopLayer, onEscape]));
  (0, import_react46.useEffect)(() => {
    if (!rootElement || !registerElement)
      return;
    return registerElement(rootElement);
  }, [registerElement, rootElement]);
  const value = (0, import_react46.useMemo)(() => ({
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    // deprecated
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }), [activeElement, activeIndex, mount, handleItemMouseEnter, handleItemMouseLeave, onClickOutside, onEscape, onItemClick, registerElement]);
  return (0, import_jsx_runtime2.jsx)(MenuContext.Provider, {
    value,
    children: (0, import_jsx_runtime2.jsx)(Root$5, {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: (0, import_jsx_runtime2.jsx)(Stack, {
        space,
        children
      })
    })
  });
});
var MenuButton = (0, import_react46.forwardRef)(function MenuButton2(props2, ref) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = false,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id: id4,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = true,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props2;
  const [open, setOpen] = (0, import_react46.useState)(false);
  const [shouldFocus, setShouldFocus] = (0, import_react46.useState)(null);
  const [buttonElement, setButtonElement] = (0, import_react46.useState)(null);
  const [menuElements, setChildMenuElements] = (0, import_react46.useState)([]);
  const openRef = (0, import_react46.useRef)(open);
  (0, import_react46.useEffect)(() => {
    if (onOpen && open && !openRef.current) {
      onOpen();
    }
  }, [onOpen, open]);
  (0, import_react46.useEffect)(() => {
    if (onClose && !open && openRef.current) {
      onClose();
    }
  }, [onClose, open]);
  (0, import_react46.useEffect)(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = (0, import_react46.useCallback)(() => {
    setOpen((v) => !v);
    setShouldFocus(null);
  }, []);
  const handleButtonKeyDown = (0, import_react46.useCallback)((event) => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("last");
      return;
    }
  }, []);
  const handleMenuClickOutside = (0, import_react46.useCallback)((event) => {
    const target = event.target;
    if (!(target instanceof Node)) {
      return;
    }
    if (buttonElement && (target === buttonElement || buttonElement.contains(target))) {
      return;
    }
    for (const el of menuElements) {
      if (target === el || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [buttonElement, menuElements]);
  const handleMenuEscape = (0, import_react46.useCallback)(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose)
      return;
    if (buttonElement)
      buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const handleBlur = (0, import_react46.useCallback)((event) => {
    const target = event.relatedTarget;
    if (!(target instanceof Node)) {
      return;
    }
    for (const el of menuElements) {
      if (el === target || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [menuElements]);
  const handleItemClick = (0, import_react46.useCallback)(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose)
      return;
    if (buttonElement)
      buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const registerElement = (0, import_react46.useCallback)((el) => {
    setChildMenuElements((els) => els.concat([el]));
    return () => {
      setChildMenuElements((els) => {
        return els.filter((_el) => _el !== el);
      });
    };
  }, []);
  const menuProps = (0, import_react46.useMemo)(() => ({
    "aria-labelledby": id4,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), [buttonElement, handleMenuClickOutside, handleMenuEscape, handleItemClick, id4, handleBlur, registerElement, shouldFocus]);
  const menu = (0, import_react_is.isElement)(menuProp) ? (0, import_react46.cloneElement)(menuProp, menuProps) : null;
  const setButtonRef = (0, import_react46.useCallback)((el) => {
    if (typeof ref === "function") {
      ref(el);
    } else if (ref) {
      ref.current = el;
    }
    setButtonElement(el);
  }, [ref]);
  const button = (0, import_react46.useMemo)(() => (0, import_react_is.isElement)(buttonProp) ? (0, import_react46.cloneElement)(buttonProp, {
    "data-ui": "MenuButton",
    id: id4,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonRef,
    selected: open
  }) : null, [buttonProp, handleButtonClick, handleButtonKeyDown, id4, open, setButtonRef]);
  const popoverProps = (0, import_react46.useMemo)(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...popover || {}
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return (0, import_jsx_runtime2.jsx)(Popover, {
    "data-ui": "MenuButton__popover",
    ...popoverProps,
    content: menu,
    open,
    children: button || (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {})
  });
});
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
var MenuDivider = st.hr(_a$8 || (_a$8 = __template$8(["\n  height: 1px;\n  border: 0;\n  background: var(--card-hairline-soft-color);\n  margin: 0;\n"])));
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7;
var _b$4;
function selectableBaseStyle() {
  return nt(_a$7 || (_a$7 = __template$7(["\n    background-color: inherit;\n    color: inherit;\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])));
}
function selectableColorStyle(props2) {
  var _a22, _b22;
  const {
    $tone,
    theme
  } = props2;
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return nt(_b$4 || (_b$4 = __template$7(["\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n    outline: none;\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[aria-pressed='true'] {\n          ", "\n        }\n\n        &[data-selected],\n        &[aria-selected='true'] > & {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    ", "\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), (_b22 = (_a22 = theme.sanity.styles) == null ? void 0 : _a22.card) == null ? void 0 : _b22.root);
}
var Selectable = st(Box)(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
function useMenu() {
  const value = (0, import_react46.useContext)(MenuContext);
  if (!value) {
    throw new Error("useMenu(): missing context value");
  }
  if (!isRecord2(value) || value.version !== 0) {
    throw new Error("useMenu(): the context value is not compatible");
  }
  return value;
}
function MenuGroup(props2) {
  const {
    as = "button",
    children,
    fontSize: fontSize2,
    icon,
    onClick,
    padding = 3,
    popover,
    radius = 2,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props2;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    registerElement
  } = menu;
  const [rootElement, setRootElement] = (0, import_react46.useState)(null);
  const [open, setOpen] = (0, import_react46.useState)(false);
  const shouldFocusRef = (0, import_react46.useRef)(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  const [withinMenu, setWithinMenu] = (0, import_react46.useState)(false);
  const handleMouseEnter = (0, import_react46.useCallback)((event) => {
    setWithinMenu(false);
    onItemMouseEnter(event);
    setOpen(true);
  }, [onItemMouseEnter]);
  const handleMenuKeyDown = (0, import_react46.useCallback)((event) => {
    if (event.key === "ArrowLeft") {
      event.stopPropagation();
      setOpen(false);
      requestAnimationFrame(() => {
        rootElement == null ? void 0 : rootElement.focus();
      });
    }
  }, [rootElement]);
  const handleClick = (0, import_react46.useCallback)((event) => {
    if (onClick)
      onClick(event);
    shouldFocusRef.current = "first";
    setOpen(true);
    requestAnimationFrame(() => {
      shouldFocusRef.current = null;
    });
  }, [onClick]);
  const handleChildItemClick = (0, import_react46.useCallback)(() => {
    setOpen(false);
    if (onItemClick)
      onItemClick();
  }, [onItemClick]);
  const handleMenuMouseEnter = (0, import_react46.useCallback)(() => setWithinMenu(true), []);
  (0, import_react46.useEffect)(() => mount(rootElement), [mount, rootElement]);
  (0, import_react46.useEffect)(() => {
    if (!active)
      setOpen(false);
  }, [active]);
  (0, import_react46.useEffect)(() => {
    if (!open)
      setWithinMenu(false);
  }, [open]);
  const childMenu = (0, import_jsx_runtime2.jsx)(Menu, {
    onClickOutside,
    onEscape,
    onItemClick: handleChildItemClick,
    onKeyDown: handleMenuKeyDown,
    onMouseEnter: handleMenuMouseEnter,
    registerElement,
    shouldFocus: shouldFocusRef.current,
    children
  });
  const handleKeyDown = (0, import_react46.useCallback)((event) => {
    const target = event.currentTarget;
    if (document.activeElement !== target) {
      return;
    }
    if (event.key === "ArrowRight") {
      shouldFocusRef.current = "first";
      setOpen(true);
      setWithinMenu(true);
      requestAnimationFrame(() => {
        shouldFocusRef.current = null;
      });
      return;
    }
  }, []);
  return (0, import_jsx_runtime2.jsx)(Popover, {
    ...popover,
    content: childMenu,
    "data-ui": "MenuGroup__popover",
    open,
    children: (0, import_jsx_runtime2.jsx)(Selectable, {
      "data-as": as,
      "data-ui": "MenuGroup",
      forwardedAs: as,
      ...restProps,
      "aria-pressed": as === "button" ? withinMenu : void 0,
      "data-pressed": as !== "button" ? withinMenu : void 0,
      "data-selected": !withinMenu && active ? "" : void 0,
      $radius: useArrayProp(radius),
      $tone: tone,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onMouseEnter: handleMouseEnter,
      ref: setRootElement,
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: (0, import_jsx_runtime2.jsx)(Box, {
        padding,
        children: (0, import_jsx_runtime2.jsxs)(Flex, {
          children: [icon && (0, import_jsx_runtime2.jsxs)(Text3, {
            size: fontSize2,
            children: [(0, import_react46.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react46.createElement)(icon)]
          }), (0, import_jsx_runtime2.jsx)(Box, {
            flex: 1,
            marginLeft: icon ? space : void 0,
            children: (0, import_jsx_runtime2.jsx)(Text3, {
              size: fontSize2,
              textOverflow: "ellipsis",
              children: text
            })
          }), (0, import_jsx_runtime2.jsx)(Box, {
            marginLeft: space,
            children: (0, import_jsx_runtime2.jsx)(Text3, {
              size: fontSize2,
              children: (0, import_jsx_runtime2.jsx)(ChevronRightIcon, {})
            })
          })]
        })
      })
    })
  });
}
var MenuItem = (0, import_react46.forwardRef)(function MenuItem2(props2, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize: fontSize2 = 2,
    hotkeys,
    icon,
    iconRight,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props2;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu;
  const [rootElement, setRootElement] = (0, import_react46.useState)(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  (0, import_react46.useEffect)(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const ref = useForwardedRef(forwardedRef);
  const handleClick = (0, import_react46.useCallback)((event) => {
    if (disabled)
      return;
    if (onClick)
      onClick(event);
    if (onItemClick)
      onItemClick();
  }, [disabled, onClick, onItemClick]);
  const paddingProps = (0, import_react46.useMemo)(() => ({
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }), [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]);
  const setRef = (0, import_react46.useCallback)((el) => {
    ref.current = el;
    setRootElement(el);
  }, [ref]);
  return (0, import_jsx_runtime2.jsxs)(Selectable, {
    "data-ui": "MenuItem",
    ...restProps,
    "aria-pressed": as === "button" && pressed,
    "data-pressed": as !== "button" && pressed ? "" : void 0,
    "data-selected": active ? "" : void 0,
    "data-disabled": disabled ? "" : void 0,
    forwardedAs: as,
    $radius: useArrayProp(radius),
    $padding: useArrayProp(0),
    $tone: tone,
    disabled,
    onClick: handleClick,
    onMouseEnter: onItemMouseEnter,
    onMouseLeave: onItemMouseLeave,
    ref: setRef,
    role: "menuitem",
    tabIndex: -1,
    type: as === "button" ? "button" : void 0,
    children: [(icon || text || iconRight) && (0, import_jsx_runtime2.jsx)(Box, {
      as: "span",
      ...paddingProps,
      children: (0, import_jsx_runtime2.jsxs)(Flex, {
        as: "span",
        children: [icon && (0, import_jsx_runtime2.jsxs)(Text3, {
          size: fontSize2,
          children: [(0, import_react46.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react46.createElement)(icon)]
        }), text && (0, import_jsx_runtime2.jsx)(Box, {
          flex: 1,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: (0, import_jsx_runtime2.jsx)(Text3, {
            size: fontSize2,
            textOverflow: "ellipsis",
            children: text
          })
        }), hotkeys && (0, import_jsx_runtime2.jsx)(Box, {
          marginLeft: space,
          style: {
            marginTop: -4,
            marginBottom: -4
          },
          children: (0, import_jsx_runtime2.jsx)(Hotkeys, {
            fontSize: fontSize2,
            keys: hotkeys
          })
        }), iconRight && (0, import_jsx_runtime2.jsxs)(Text3, {
          size: fontSize2,
          children: [(0, import_react46.isValidElement)(iconRight) && iconRight, (0, import_react_is.isValidElementType)(iconRight) && (0, import_react46.createElement)(iconRight)]
        })]
      })
    }), children && (0, import_jsx_runtime2.jsx)(Box, {
      as: "span",
      ...paddingProps,
      children
    })]
  });
});
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6;
var _b$3;
var _c$1;
var _d;
var keyframe = ct(_a$6 || (_a$6 = __template$6(["\n  0% {\n    background-position: 100%;\n  }\n  100% {\n    background-position: -100%;\n  }\n"])));
var animation = nt(_b$3 || (_b$3 = __template$6(["\n  background-image: linear-gradient(\n    to right,\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-to),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from)\n  );\n  background-position: 100%;\n  background-size: 200% 100%;\n  background-attachment: fixed;\n  animation-name: ", ";\n  animation-timing-function: ease-in-out;\n  animation-iteration-count: infinite;\n  animation-duration: 2000ms;\n"])), keyframe);
var skeletonStyle = nt(_d || (_d = __template$6(["\n  opacity: ", ";\n  transition: opacity 200ms ease-in;\n\n  @media screen and (prefers-reduced-motion: no-preference) {\n    ", "\n  }\n\n  @media screen and (prefers-reduced-motion: reduce) {\n    background-color: var(--card-skeleton-color-from);\n  }\n"])), (_ref25) => {
  let {
    $visible
  } = _ref25;
  return $visible ? 1 : 0;
}, (_ref26) => {
  let {
    $animated
  } = _ref26;
  return $animated ? animation : nt(_c$1 || (_c$1 = __template$6(["\n            background-color: var(--card-skeleton-color-from);\n          "])));
});
var Root$4 = st(Box)(responsiveRadiusStyle, skeletonStyle);
var Skeleton = (0, import_react46.forwardRef)(function Skeleton2(props2, ref) {
  const {
    animated = false,
    delay: delay3,
    radius,
    ...restProps
  } = props2;
  const [visible, setVisible] = (0, import_react46.useState)(delay3 ? false : true);
  (0, import_react46.useEffect)(() => {
    if (!delay3) {
      return setVisible(true);
    }
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay3);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay3]);
  return (0, import_jsx_runtime2.jsx)(Root$4, {
    ...restProps,
    $animated: animated,
    $radius: useArrayProp(radius),
    $visible: visible,
    ref
  });
});
var Root$3 = st(Skeleton)((_ref27) => {
  let {
    $size,
    $style,
    theme
  } = _ref27;
  const {
    media
  } = theme.sanity;
  const font = theme.sanity.fonts[$style];
  const styles = _responsive(media, $size, (sizeIndex) => {
    const fontSize2 = font.sizes[sizeIndex];
    const capHeight = fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight;
    return {
      height: capHeight
    };
  });
  return styles;
});
var TextSkeleton = (0, import_react46.forwardRef)(function TextSkeleton2(props2, ref) {
  const {
    size: size2 = 2,
    ...restProps
  } = props2;
  const $size = useArrayProp(size2);
  return (0, import_jsx_runtime2.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "text"
  });
});
var LabelSkeleton = (0, import_react46.forwardRef)(function TextSkeleton3(props2, ref) {
  const {
    size: size2 = 2,
    ...restProps
  } = props2;
  const $size = useArrayProp(size2);
  return (0, import_jsx_runtime2.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "label"
  });
});
var HeadingSkeleton = (0, import_react46.forwardRef)(function TextSkeleton4(props2, ref) {
  const {
    size: size2 = 2,
    ...restProps
  } = props2;
  const $size = useArrayProp(size2);
  return (0, import_jsx_runtime2.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "heading"
  });
});
var CodeSkeleton = (0, import_react46.forwardRef)(function TextSkeleton5(props2, ref) {
  const {
    size: size2 = 2,
    ...restProps
  } = props2;
  const $size = useArrayProp(size2);
  return (0, import_jsx_runtime2.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "code"
  });
});
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
var CustomButton = st(Button)(_a$5 || (_a$5 = __template$5(["\n  max-width: 100%;\n"])));
var Tab = (0, import_react46.forwardRef)(function Tab2(props2, forwardedRef) {
  const {
    icon,
    id: id4,
    focused,
    fontSize: fontSize2,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props2;
  const elementRef = (0, import_react46.useRef)(null);
  const focusedRef = (0, import_react46.useRef)(false);
  const handleBlur = (0, import_react46.useCallback)(() => {
    focusedRef.current = false;
  }, []);
  const handleFocus = (0, import_react46.useCallback)((event) => {
    focusedRef.current = true;
    if (onFocus)
      onFocus(event);
  }, [onFocus]);
  const ref = useForwardedRef(forwardedRef);
  (0, import_react46.useEffect)(() => {
    if (focused && !focusedRef.current) {
      if (elementRef.current)
        elementRef.current.focus();
      focusedRef.current = true;
    }
  }, [focused]);
  const setRef = (el) => {
    elementRef.current = el;
    ref.current = el;
  };
  return (0, import_jsx_runtime2.jsx)(CustomButton, {
    "data-ui": "Tab",
    ...restProps,
    "aria-selected": selected ? "true" : "false",
    fontSize: fontSize2,
    icon,
    id: id4,
    mode: "bleed",
    onClick,
    onBlur: handleBlur,
    onFocus: handleFocus,
    padding,
    ref: setRef,
    role: "tab",
    selected,
    tabIndex: selected ? 0 : -1,
    text: label,
    type: "button"
  });
});
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
function _isReactElement(node) {
  return Boolean(node);
}
var CustomInline = st(Inline)(_a$4 || (_a$4 = __template$4(["\n  & > div {\n    display: inline-block;\n    vertical-align: middle;\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n"])));
var TabList = (0, import_react46.forwardRef)(function TabList2(props2, ref) {
  const {
    children: childrenProp,
    ...restProps
  } = props2;
  const [focusedIndex, setFocusedIndex] = (0, import_react46.useState)(-1);
  const children = (0, import_react46.useMemo)(() => childrenProp.filter(_isReactElement), [childrenProp]);
  const tabs = children.map((child, childIndex) => (0, import_react46.cloneElement)(child, {
    focused: focusedIndex === childIndex,
    key: childIndex,
    onFocus: () => handleTabFocus(childIndex)
  }));
  const numTabs = tabs.length;
  const handleTabFocus = (0, import_react46.useCallback)((tabIdx) => {
    setFocusedIndex(tabIdx);
  }, []);
  const handleKeyDown = (0, import_react46.useCallback)((event) => {
    if (event.key === "ArrowLeft") {
      setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs);
    }
    if (event.key === "ArrowRight") {
      setFocusedIndex((prevIndex) => (prevIndex + 1) % numTabs);
    }
  }, [numTabs]);
  return (0, import_jsx_runtime2.jsx)(CustomInline, {
    "data-ui": "TabList",
    ...restProps,
    onKeyDown: handleKeyDown,
    ref,
    role: "tablist",
    children: tabs
  });
});
var TabPanel = (0, import_react46.forwardRef)(function TabPanel2(props2, ref) {
  const {
    flex,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime2.jsx)(Box, {
    "data-ui": "TabPanel",
    ...restProps,
    flex,
    ref,
    role: "tabpanel",
    tabIndex: props2.tabIndex === void 0 ? 0 : props2.tabIndex,
    children: props2.children
  });
});
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3;
var _b$2;
var STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
};
var ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
};
var Root$2 = st(Card)(_a$3 || (_a$3 = __template$3(["\n  pointer-events: all;\n"])));
var TextBox = st(Flex)(_b$2 || (_b$2 = __template$3(["\n  overflow-x: auto;\n"])));
function Toast(props2) {
  const {
    closable,
    description,
    onClose,
    title,
    status,
    ...restProps
  } = props2;
  const cardTone = status ? STATUS_CARD_TONE[status] : "default";
  const role = status ? ROLES[status] : "status";
  return (0, import_jsx_runtime2.jsx)(Root$2, {
    "data-ui": "Toast",
    role,
    ...restProps,
    marginTop: 3,
    radius: 2,
    shadow: 2,
    tone: cardTone,
    children: (0, import_jsx_runtime2.jsxs)(Flex, {
      align: "flex-start",
      children: [(0, import_jsx_runtime2.jsx)(TextBox, {
        flex: 1,
        padding: 3,
        children: (0, import_jsx_runtime2.jsxs)(Stack, {
          space: 3,
          children: [title && (0, import_jsx_runtime2.jsx)(Text3, {
            weight: "semibold",
            children: title
          }), description && (0, import_jsx_runtime2.jsx)(Text3, {
            muted: true,
            size: 1,
            children: description
          })]
        })
      }), closable && (0, import_jsx_runtime2.jsx)(Box, {
        padding: 1,
        children: (0, import_jsx_runtime2.jsx)(Button, {
          as: "button",
          icon: CloseIcon,
          mode: "bleed",
          padding: 2,
          onClick: onClose,
          style: {
            verticalAlign: "top"
          }
        })
      })]
    })
  });
}
function useMounted() {
  const [mounted, mount] = (0, import_react46.useReducer)(() => true, false);
  (0, import_react46.useEffect)(mount, [mount]);
  return mounted;
}
var key$1 = Symbol.for("@sanity/ui/context/toast");
globalScope[key$1] = globalScope[key$1] || (0, import_react46.createContext)(null);
var ToastContext = globalScope[key$1];
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2;
var _b$1;
var Root$1 = st(Layer)(_a$2 || (_a$2 = __template$2(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n"])));
var ToastContainer = st.div(_b$1 || (_b$1 = __template$2(["\n  box-sizing: border-box;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  max-width: 420px;\n  width: 100%;\n"])));
var toastId = 0;
function ToastProvider(props2) {
  const {
    children,
    padding = 4,
    paddingX,
    paddingY,
    zOffset
  } = props2;
  const [state, _setState] = (0, import_react46.useState)([]);
  const toastsRef = (0, import_react46.useRef)({});
  const push = (0, import_react46.useCallback)((params) => {
    const setState = (state2) => (0, import_react46.startTransition)(() => _setState(state2));
    const id4 = params.id || String(toastId++);
    const duration = params.duration || 5e3;
    const dismiss = () => {
      var _a22;
      const timeoutId = (_a22 = toastsRef.current[id4]) == null ? void 0 : _a22.timeoutId;
      setState((prevState) => {
        const idx = prevState.findIndex((t3) => t3.id === id4);
        if (idx > -1) {
          const toasts = prevState.slice(0);
          toasts.splice(idx, 1);
          return toasts;
        }
        return prevState;
      });
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
        delete toastsRef.current[id4];
      }
    };
    setState((prevState) => {
      return prevState.filter((t3) => t3.id !== id4).concat([{
        dismiss,
        id: id4,
        params: {
          ...params,
          duration
        }
      }]);
    });
    if (toastsRef.current[id4]) {
      clearTimeout(toastsRef.current[id4].timeoutId);
      delete toastsRef.current[id4];
    }
    toastsRef.current[id4] = {
      timeoutId: setTimeout(dismiss, duration)
    };
    return id4;
  }, []);
  (0, import_react46.useEffect)(() => () => {
    for (const {
      timeoutId
    } of Object.values(toastsRef.current)) {
      clearTimeout(timeoutId);
    }
    toastsRef.current = {};
  }, []);
  const value = (0, import_react46.useMemo)(() => ({
    version: 0,
    push
  }), [push]);
  const mounted = useMounted();
  return (0, import_jsx_runtime2.jsxs)(ToastContext.Provider, {
    value,
    children: [children, mounted && (0, import_jsx_runtime2.jsx)(Root$1, {
      "data-ui": "ToastProvider",
      zOffset,
      children: (0, import_jsx_runtime2.jsx)(ToastContainer, {
        children: (0, import_jsx_runtime2.jsx)(Box, {
          padding,
          paddingX,
          paddingY,
          children: (0, import_jsx_runtime2.jsx)(AnimatePresence, {
            initial: false,
            children: state.map((_ref28) => {
              let {
                dismiss,
                id: id4,
                params
              } = _ref28;
              return (0, import_jsx_runtime2.jsx)(motion.div, {
                animate: {
                  opacity: 1,
                  y: 0,
                  scale: 1
                },
                exit: {
                  opacity: 0,
                  scale: 0.5,
                  transition: {
                    duration: 0.2
                  }
                },
                initial: {
                  opacity: 0,
                  y: 32,
                  scale: 0.25
                },
                layout: "position",
                transition: {
                  type: "spring",
                  damping: 30,
                  stiffness: 400
                },
                children: (0, import_jsx_runtime2.jsx)(Toast, {
                  closable: params.closable,
                  description: params.description,
                  onClose: dismiss,
                  status: params.status,
                  title: params.title
                })
              }, id4);
            })
          })
        })
      })
    })]
  });
}
function useToast() {
  const value = (0, import_react46.useContext)(ToastContext);
  if (!value) {
    throw new Error("useToast(): missing context value");
  }
  if (!isRecord2(value) || value.version !== 0) {
    throw new Error("useToast(): the context value is not compatible");
  }
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a4;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(0, idx);
  const len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a4 = state[k]) == null ? void 0 : _a4.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a4;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(idx);
  const len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i]) {
      continue;
    }
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a4 = state[k]) == null ? void 0 : _a4.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem") {
    el.focus();
  }
  if (el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    if (firstChild && firstChild instanceof HTMLElement) {
      firstChild.focus();
    }
  }
}
var key = Symbol.for("@sanity/ui/context/tree");
globalScope[key] = globalScope[key] || (0, import_react46.createContext)(null);
var TreeContext = globalScope[key];
var Tree = (0, import_react46.memo)((0, import_react46.forwardRef)(function Tree2(props2, ref) {
  const {
    children,
    space = 1,
    onFocus,
    ...restProps
  } = props2;
  const forwardedRef = useForwardedRef(ref);
  const [focusedElement, setFocusedElement] = (0, import_react46.useState)(null);
  const focusedElementRef = (0, import_react46.useRef)(focusedElement);
  const path2 = (0, import_react46.useMemo)(() => [], []);
  const [itemElements, setItemElements] = (0, import_react46.useState)([]);
  const [state, setState] = (0, import_react46.useState)({});
  const stateRef = (0, import_react46.useRef)(state);
  (0, import_react46.useEffect)(() => {
    focusedElementRef.current = focusedElement;
  }, [focusedElement]);
  (0, import_react46.useEffect)(() => {
    stateRef.current = state;
  }, [state]);
  const registerItem = (0, import_react46.useCallback)((element, path22, expanded, selected) => {
    setState((s) => ({
      ...s,
      [path22]: {
        element,
        expanded
      }
    }));
    if (selected) {
      setFocusedElement(element);
    }
    return () => {
      setState((s) => {
        const newState = {
          ...s
        };
        delete newState[path22];
        return newState;
      });
    };
  }, []);
  const setExpanded = (0, import_react46.useCallback)((path22, expanded) => {
    setState((s) => {
      const itemState = s[path22];
      if (!itemState)
        return s;
      return {
        ...s,
        [path22]: {
          ...itemState,
          expanded
        }
      };
    });
  }, []);
  const contextValue = (0, import_react46.useMemo)(() => ({
    version: 0,
    focusedElement: focusedElement || itemElements[0] || null,
    level: 0,
    path: path2,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }), [focusedElement, itemElements, path2, registerItem, setExpanded, space, state]);
  const handleKeyDown = (0, import_react46.useCallback)((event) => {
    var _a4;
    if (!focusedElementRef.current)
      return;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (nextEl) {
        _focusItemElement(nextEl);
        setFocusedElement(nextEl);
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (prevEl) {
        _focusItemElement(prevEl);
        setFocusedElement(prevEl);
      }
      return;
    }
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!itemKey)
        return;
      const itemState = stateRef.current[itemKey];
      if (!itemState)
        return;
      if (itemState.expanded) {
        setState((s) => {
          const itemState2 = s[itemKey];
          if (!itemState2)
            return s;
          return {
            ...s,
            [itemKey]: {
              ...itemState2,
              expanded: false
            }
          };
        });
      } else {
        const itemPath = itemKey.split("/");
        itemPath.pop();
        const parentKey = itemPath.join("/");
        const parentState = parentKey && stateRef.current[parentKey];
        if (parentState) {
          parentState.element.focus();
          setFocusedElement(parentState.element);
        }
      }
      return;
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!focusedKey)
        return;
      if (!((_a4 = stateRef.current[focusedKey]) == null ? void 0 : _a4.expanded)) {
        setState((s) => {
          const itemState = s[focusedKey];
          if (!itemState)
            return s;
          return {
            ...s,
            [focusedKey]: {
              ...itemState,
              expanded: true
            }
          };
        });
      }
      return;
    }
  }, [itemElements]);
  const handleFocus = (0, import_react46.useCallback)((event) => {
    setFocusedElement(event.target);
    onFocus == null ? void 0 : onFocus(event);
  }, [onFocus]);
  (0, import_react46.useEffect)(() => {
    if (!forwardedRef.current)
      return;
    const _itemElements = Array.from(forwardedRef.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, [children, forwardedRef]);
  return (0, import_jsx_runtime2.jsx)(TreeContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime2.jsx)(Stack, {
      as: "ul",
      "data-ui": "Tree",
      ...restProps,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      ref: forwardedRef,
      role: "tree",
      space,
      children
    })
  });
}));
Tree.displayName = "Tree";
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
var _b;
var _c;
function treeItemRootStyle() {
  return nt(_a$1 || (_a$1 = __template$1(["\n    &[role='none'] > [role='treeitem'] {\n      outline: none;\n      cursor: default;\n      border-radius: 3px;\n\n      &:focus {\n        position: relative;\n      }\n    }\n\n    &[role='treeitem'] {\n      outline: none;\n\n      & > div {\n        cursor: default;\n        border-radius: 3px;\n      }\n\n      &:focus > div {\n        position: relative;\n      }\n    }\n  "])));
}
function treeItemRootColorStyle(props2) {
  const {
    theme
  } = props2;
  const $tone = "default";
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return nt(_b || (_b = __template$1([`
    /* <div role="none"><a data-ui="TreeItem__box" role="treeitem" tabIndex="0"></div> */
    &[role='none'] {
      & > [role='treeitem'] {
        `, "\n\n        background-color: var(--card-bg-color);\n        color: var(--treeitem-fg-color);\n      }\n\n      &[data-selected] > [role='treeitem'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {\n          ", "\n        }\n\n        & > [role='treeitem']:focus {\n          ", `
        }
      }
    }

    /* <div role="treeitem" tabIndex="0"><div data-ui="TreeItem__box"></div> */
    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        `, "\n\n        background-color: var(--card-bg-color);\n        color: var(--card-fg-color);\n      }\n\n      &[data-selected] > [data-ui='TreeItem__box'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {\n          ", "\n        }\n\n        &:focus > [data-ui='TreeItem__box'] {\n          ", "\n        }\n      }\n    }\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected));
}
function treeItemBoxStyle(props2) {
  const {
    $level,
    theme
  } = props2;
  const {
    space
  } = theme.sanity;
  return nt(_c || (_c = __template$1(["\n    padding-left: ", ";\n\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])), rem(space[2] * $level));
}
function useTree() {
  const tree = (0, import_react46.useContext)(TreeContext);
  if (!tree) {
    throw new Error("Tree: missing context value");
  }
  return tree;
}
var TreeGroup = (0, import_react46.memo)(function TreeGroup2(props2) {
  const {
    children,
    expanded = false,
    ...restProps
  } = props2;
  const tree = useTree();
  return (0, import_jsx_runtime2.jsx)(Stack, {
    as: "ul",
    "data-ui": "TreeGroup",
    ...restProps,
    hidden: !expanded,
    marginTop: tree.space,
    role: "group",
    space: tree.space,
    children
  });
});
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
var Root = (0, import_react46.memo)(st.li(treeItemRootStyle, treeItemRootColorStyle));
var TreeItemBox = st(Box).attrs({
  forwardedAs: "a"
})(treeItemBoxStyle);
var ToggleArrowText = st(Text3)(_a || (_a = __template(["\n  & > svg {\n    transition: transform 100ms;\n  }\n"])));
var TreeItem = (0, import_react46.memo)(function TreeItem2(props2) {
  const {
    children,
    expanded: expandedProp = false,
    fontSize: fontSize2,
    href,
    icon,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 3,
    selected = false,
    space = 2,
    text,
    weight,
    ...restProps
  } = props2;
  const rootRef = (0, import_react46.useRef)(null);
  const treeitemRef = (0, import_react46.useRef)(null);
  const tree = useTree();
  const {
    path: path2,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree;
  const _id = (0, import_react46.useId)();
  const id4 = idProp || _id;
  const itemPath = (0, import_react46.useMemo)(() => path2.concat([id4 || ""]), [id4, path2]);
  const itemKey = itemPath.join("/");
  const itemState = tree.state[itemKey];
  const focused = tree.focusedElement === rootRef.current;
  const expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || false;
  const tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1;
  const contextValue = (0, import_react46.useMemo)(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]);
  const handleClick = (0, import_react46.useCallback)((event) => {
    if (onClick)
      onClick(event);
    const target = event.target;
    if (target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]'))) {
      event.stopPropagation();
      setExpanded(itemKey, !expanded);
      setFocusedElement(rootRef.current);
    }
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]);
  const handleKeyDown = (0, import_react46.useCallback)((event) => {
    if (focused && event.key === "Enter") {
      const el = treeitemRef.current || rootRef.current;
      el == null ? void 0 : el.click();
    }
  }, [focused]);
  (0, import_react46.useEffect)(() => {
    if (!rootRef.current)
      return;
    return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = (0, import_jsx_runtime2.jsxs)(Flex, {
    padding,
    children: [(0, import_jsx_runtime2.jsxs)(Box, {
      marginRight: space,
      style: {
        visibility: icon || children ? "visible" : "hidden",
        pointerEvents: "none"
      },
      children: [icon && (0, import_jsx_runtime2.jsx)(Text3, {
        muted,
        size: fontSize2,
        weight,
        children: (0, import_react46.createElement)(icon)
      }), !icon && (0, import_jsx_runtime2.jsx)(ToggleArrowText, {
        muted,
        size: fontSize2,
        weight,
        children: (0, import_jsx_runtime2.jsx)(ToggleArrowRightIcon, {
          style: {
            transform: expanded ? "rotate(90deg)" : void 0
          }
        })
      })]
    }), (0, import_jsx_runtime2.jsx)(Box, {
      flex: 1,
      children: (0, import_jsx_runtime2.jsx)(Text3, {
        muted,
        size: fontSize2,
        textOverflow: "ellipsis",
        weight,
        children: text
      })
    })]
  });
  if (href) {
    return (0, import_jsx_runtime2.jsxs)(Root, {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id4,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [(0, import_jsx_runtime2.jsx)(TreeItemBox, {
        $level: tree.level,
        "aria-expanded": expanded,
        as: linkAs,
        "data-ui": "TreeItem__box",
        href,
        ref: treeitemRef,
        role: "treeitem",
        tabIndex,
        children: content
      }), (0, import_jsx_runtime2.jsx)(TreeContext.Provider, {
        value: contextValue,
        children: children && (0, import_jsx_runtime2.jsx)(TreeGroup, {
          hidden: !expanded,
          children
        })
      })]
    });
  }
  return (0, import_jsx_runtime2.jsxs)(Root, {
    "data-selected": selected ? "" : void 0,
    "data-ui": "TreeItem",
    "data-tree-id": id4,
    "data-tree-key": itemKey,
    ...restProps,
    "aria-expanded": expanded,
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    ref: rootRef,
    role: "treeitem",
    tabIndex,
    children: [(0, import_jsx_runtime2.jsx)(TreeItemBox, {
      $level: tree.level,
      as: "div",
      "data-ui": "TreeItem__box",
      children: content
    }), (0, import_jsx_runtime2.jsx)(TreeContext.Provider, {
      value: contextValue,
      children: children && (0, import_jsx_runtime2.jsx)(TreeGroup, {
        expanded,
        children
      })
    })]
  });
});

// node_modules/sanity/lib/index.esm.js
init_esm2();
init_esm5();
init_operators();
var import_isEqual4 = __toESM(require_isEqual());
init_resize_observer();
var import_throttle2 = __toESM(require_throttle());
init_es();
init_styled_components_browser_esm();
var import_sortBy = __toESM(require_sortBy());

// node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@tanstack/react-virtual/build/lib/index.mjs
var React12 = __toESM(require_react(), 1);

// node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}

// node_modules/@tanstack/virtual-core/build/lib/utils.mjs
function memo3(getDeps, fn, opts) {
  var _opts$initialDeps;
  var deps = (_opts$initialDeps = opts.initialDeps) != null ? _opts$initialDeps : [];
  var result;
  return function() {
    var depTime;
    if (opts.key && opts.debug != null && opts.debug())
      depTime = Date.now();
    var newDeps = getDeps();
    var depsChanged = newDeps.length !== deps.length || newDeps.some(function(dep, index) {
      return deps[index] !== dep;
    });
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    var resultTime;
    if (opts.key && opts.debug != null && opts.debug())
      resultTime = Date.now();
    result = fn.apply(void 0, newDeps);
    if (opts.key && opts.debug != null && opts.debug()) {
      var depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      var resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      var resultFpsPercentage = resultEndTime / 16;
      var pad = function pad2(str, num) {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info("%c " + pad(resultEndTime, 5) + " /" + pad(depEndTime, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + "deg 100% 31%);", opts == null ? void 0 : opts.key);
    }
    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);
    return result;
  };
}
function notUndefined(value, msg2) {
  if (value === void 0) {
    throw new Error("Unexpected undefined" + (msg2 ? ": " + msg2 : ""));
  } else {
    return value;
  }
}
var approxEqual = function approxEqual2(a, b) {
  return Math.abs(a - b) < 1;
};

// node_modules/@tanstack/virtual-core/build/lib/index.mjs
var defaultKeyExtractor = function defaultKeyExtractor2(index) {
  return index;
};
var defaultRangeExtractor = function defaultRangeExtractor2(range2) {
  var start = Math.max(range2.startIndex - range2.overscan, 0);
  var end = Math.min(range2.endIndex + range2.overscan, range2.count - 1);
  var arr = [];
  for (var _i2 = start; _i2 <= end; _i2++) {
    arr.push(_i2);
  }
  return arr;
};
var observeElementRect = function observeElementRect2(instance2, cb) {
  var element = instance2.scrollElement;
  if (!element) {
    return;
  }
  var handler = function handler2(rect) {
    var width = rect.width, height = rect.height;
    cb({
      width: Math.round(width),
      height: Math.round(height)
    });
  };
  handler(element.getBoundingClientRect());
  var observer = new ResizeObserver(function(entries) {
    var entry = entries[0];
    if (entry != null && entry.borderBoxSize) {
      var box = entry.borderBoxSize[0];
      if (box) {
        handler({
          width: box.inlineSize,
          height: box.blockSize
        });
        return;
      }
    }
    handler(element.getBoundingClientRect());
  });
  observer.observe(element, {
    box: "border-box"
  });
  return function() {
    observer.unobserve(element);
  };
};
var observeElementOffset = function observeElementOffset2(instance2, cb) {
  var element = instance2.scrollElement;
  if (!element) {
    return;
  }
  var handler = function handler2() {
    cb(element[instance2.options.horizontal ? "scrollLeft" : "scrollTop"]);
  };
  handler();
  element.addEventListener("scroll", handler, {
    passive: true
  });
  return function() {
    element.removeEventListener("scroll", handler);
  };
};
var measureElement = function measureElement2(element, entry, instance2) {
  if (entry != null && entry.borderBoxSize) {
    var box = entry.borderBoxSize[0];
    if (box) {
      var size2 = Math.round(box[instance2.options.horizontal ? "inlineSize" : "blockSize"]);
      return size2;
    }
  }
  return Math.round(element.getBoundingClientRect()[instance2.options.horizontal ? "width" : "height"]);
};
var elementScroll = function elementScroll2(offset2, _ref2, instance2) {
  var _instance$scrollEleme3, _instance$scrollEleme4;
  var _ref2$adjustments = _ref2.adjustments, adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments, behavior = _ref2.behavior;
  var toOffset = offset2 + adjustments;
  (_instance$scrollEleme3 = instance2.scrollElement) == null ? void 0 : _instance$scrollEleme3.scrollTo == null ? void 0 : _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance2.options.horizontal ? "left" : "top"] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));
};
var Virtualizer = function Virtualizer2(_opts) {
  var _this = this;
  this.unsubs = [];
  this.scrollElement = null;
  this.isScrolling = false;
  this.isScrollingTimeoutId = null;
  this.scrollToIndexTimeoutId = null;
  this.measurementsCache = [];
  this.itemSizeCache = /* @__PURE__ */ new Map();
  this.pendingMeasuredCacheIndexes = [];
  this.scrollDirection = null;
  this.scrollAdjustments = 0;
  this.measureElementCache = /* @__PURE__ */ new Map();
  this.observer = function() {
    var _ro = null;
    var get6 = function get7() {
      if (_ro) {
        return _ro;
      } else if (typeof ResizeObserver !== "undefined") {
        return _ro = new ResizeObserver(function(entries) {
          entries.forEach(function(entry) {
            _this._measureElement(entry.target, entry);
          });
        });
      } else {
        return null;
      }
    };
    return {
      disconnect: function disconnect() {
        var _get;
        return (_get = get6()) == null ? void 0 : _get.disconnect();
      },
      observe: function observe(target) {
        var _get2;
        return (_get2 = get6()) == null ? void 0 : _get2.observe(target, {
          box: "border-box"
        });
      },
      unobserve: function unobserve(target) {
        var _get3;
        return (_get3 = get6()) == null ? void 0 : _get3.unobserve(target);
      }
    };
  }();
  this.range = {
    startIndex: 0,
    endIndex: 0
  };
  this.setOptions = function(opts) {
    Object.entries(opts).forEach(function(_ref3) {
      var key2 = _ref3[0], value = _ref3[1];
      if (typeof value === "undefined")
        delete opts[key2];
    });
    _this.options = _extends2({
      debug: false,
      initialOffset: 0,
      overscan: 1,
      paddingStart: 0,
      paddingEnd: 0,
      scrollPaddingStart: 0,
      scrollPaddingEnd: 0,
      horizontal: false,
      getItemKey: defaultKeyExtractor,
      rangeExtractor: defaultRangeExtractor,
      onChange: function onChange() {
      },
      measureElement,
      initialRect: {
        width: 0,
        height: 0
      },
      scrollMargin: 0,
      scrollingDelay: 150,
      indexAttribute: "data-index",
      initialMeasurementsCache: [],
      lanes: 1
    }, opts);
  };
  this.notify = function() {
    _this.options.onChange == null ? void 0 : _this.options.onChange(_this);
  };
  this.cleanup = function() {
    _this.unsubs.filter(Boolean).forEach(function(d) {
      return d();
    });
    _this.unsubs = [];
    _this.scrollElement = null;
  };
  this._didMount = function() {
    _this.measureElementCache.forEach(_this.observer.observe);
    return function() {
      _this.observer.disconnect();
      _this.cleanup();
    };
  };
  this._willUpdate = function() {
    var scrollElement = _this.options.getScrollElement();
    if (_this.scrollElement !== scrollElement) {
      _this.cleanup();
      _this.scrollElement = scrollElement;
      _this._scrollToOffset(_this.scrollOffset, {
        adjustments: void 0,
        behavior: void 0
      });
      _this.unsubs.push(_this.options.observeElementRect(_this, function(rect) {
        var prev = _this.scrollRect;
        _this.scrollRect = rect;
        if (_this.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {
          _this.maybeNotify();
        }
      }));
      _this.unsubs.push(_this.options.observeElementOffset(_this, function(offset2) {
        _this.scrollAdjustments = 0;
        if (_this.scrollOffset === offset2) {
          return;
        }
        if (_this.isScrollingTimeoutId !== null) {
          clearTimeout(_this.isScrollingTimeoutId);
          _this.isScrollingTimeoutId = null;
        }
        _this.isScrolling = true;
        _this.scrollDirection = _this.scrollOffset < offset2 ? "forward" : "backward";
        _this.scrollOffset = offset2;
        _this.maybeNotify();
        _this.isScrollingTimeoutId = setTimeout(function() {
          _this.isScrollingTimeoutId = null;
          _this.isScrolling = false;
          _this.scrollDirection = null;
          _this.maybeNotify();
        }, _this.options.scrollingDelay);
      }));
    }
  };
  this.getSize = function() {
    return _this.scrollRect[_this.options.horizontal ? "width" : "height"];
  };
  this.memoOptions = memo3(function() {
    return [_this.options.count, _this.options.paddingStart, _this.options.scrollMargin, _this.options.getItemKey];
  }, function(count2, paddingStart, scrollMargin, getItemKey2) {
    _this.pendingMeasuredCacheIndexes = [];
    return {
      count: count2,
      paddingStart,
      scrollMargin,
      getItemKey: getItemKey2
    };
  }, {
    key: false
  });
  this.getFurthestMeasurement = function(measurements, index) {
    var furthestMeasurementsFound = /* @__PURE__ */ new Map();
    var furthestMeasurements = /* @__PURE__ */ new Map();
    for (var m2 = index - 1; m2 >= 0; m2--) {
      var measurement = measurements[m2];
      if (furthestMeasurementsFound.has(measurement.lane)) {
        continue;
      }
      var previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);
      if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
        furthestMeasurements.set(measurement.lane, measurement);
      } else if (measurement.end < previousFurthestMeasurement.end) {
        furthestMeasurementsFound.set(measurement.lane, true);
      }
      if (furthestMeasurementsFound.size === _this.options.lanes) {
        break;
      }
    }
    return furthestMeasurements.size === _this.options.lanes ? Array.from(furthestMeasurements.values()).sort(function(a, b) {
      return a.end - b.end;
    })[0] : void 0;
  };
  this.getMeasurements = memo3(function() {
    return [_this.memoOptions(), _this.itemSizeCache];
  }, function(_ref4, itemSizeCache) {
    var count2 = _ref4.count, paddingStart = _ref4.paddingStart, scrollMargin = _ref4.scrollMargin, getItemKey2 = _ref4.getItemKey;
    var min2 = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;
    _this.pendingMeasuredCacheIndexes = [];
    var measurements = _this.measurementsCache.slice(0, min2);
    for (var _i2 = min2; _i2 < count2; _i2++) {
      var key2 = getItemKey2(_i2);
      var furthestMeasurement = _this.options.lanes === 1 ? measurements[_i2 - 1] : _this.getFurthestMeasurement(measurements, _i2);
      var start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;
      var measuredSize = itemSizeCache.get(key2);
      var size2 = typeof measuredSize === "number" ? measuredSize : _this.options.estimateSize(_i2);
      var end = start + size2;
      var lane = furthestMeasurement ? furthestMeasurement.lane : _i2 % _this.options.lanes;
      measurements[_i2] = {
        index: _i2,
        start,
        size: size2,
        end,
        key: key2,
        lane
      };
    }
    _this.measurementsCache = measurements;
    return measurements;
  }, {
    key: "getMeasurements",
    debug: function debug5() {
      return _this.options.debug;
    }
  });
  this.calculateRange = memo3(function() {
    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];
  }, function(measurements, outerSize, scrollOffset) {
    return _this.range = calculateRange({
      measurements,
      outerSize,
      scrollOffset
    });
  }, {
    key: "calculateRange",
    debug: function debug5() {
      return _this.options.debug;
    }
  });
  this.maybeNotify = memo3(function() {
    var range2 = _this.calculateRange();
    return [range2.startIndex, range2.endIndex, _this.isScrolling];
  }, function() {
    _this.notify();
  }, {
    key: "maybeNotify",
    debug: function debug5() {
      return _this.options.debug;
    },
    initialDeps: [this.range.startIndex, this.range.endIndex, this.isScrolling]
  });
  this.getIndexes = memo3(function() {
    return [_this.options.rangeExtractor, _this.calculateRange(), _this.options.overscan, _this.options.count];
  }, function(rangeExtractor, range2, overscan, count2) {
    return rangeExtractor(_extends2({}, range2, {
      overscan,
      count: count2
    }));
  }, {
    key: "getIndexes",
    debug: function debug5() {
      return _this.options.debug;
    }
  });
  this.indexFromElement = function(node) {
    var attributeName = _this.options.indexAttribute;
    var indexStr = node.getAttribute(attributeName);
    if (!indexStr) {
      console.warn("Missing attribute name '" + attributeName + "={index}' on measured element.");
      return -1;
    }
    return parseInt(indexStr, 10);
  };
  this._measureElement = function(node, entry) {
    var _this$itemSizeCache$g;
    var index = _this.indexFromElement(node);
    var item = _this.measurementsCache[index];
    if (!item) {
      return;
    }
    var prevNode = _this.measureElementCache.get(item.key);
    if (!node.isConnected) {
      _this.observer.unobserve(node);
      if (node === prevNode) {
        _this.measureElementCache["delete"](item.key);
      }
      return;
    }
    if (prevNode !== node) {
      if (prevNode) {
        _this.observer.unobserve(prevNode);
      }
      _this.observer.observe(node);
      _this.measureElementCache.set(item.key, node);
    }
    var measuredItemSize = _this.options.measureElement(node, entry, _this);
    var itemSize = (_this$itemSizeCache$g = _this.itemSizeCache.get(item.key)) != null ? _this$itemSizeCache$g : item.size;
    var delta2 = measuredItemSize - itemSize;
    if (delta2 !== 0) {
      if (item.start < _this.scrollOffset) {
        if (_this.options.debug) {
          console.info("correction", delta2);
        }
        _this._scrollToOffset(_this.scrollOffset, {
          adjustments: _this.scrollAdjustments += delta2,
          behavior: void 0
        });
      }
      _this.pendingMeasuredCacheIndexes.push(index);
      _this.itemSizeCache = new Map(_this.itemSizeCache.set(item.key, measuredItemSize));
      _this.notify();
    }
  };
  this.measureElement = function(node) {
    if (!node) {
      return;
    }
    _this._measureElement(node, void 0);
  };
  this.getVirtualItems = memo3(function() {
    return [_this.getIndexes(), _this.getMeasurements()];
  }, function(indexes, measurements) {
    var virtualItems = [];
    for (var k = 0, len = indexes.length; k < len; k++) {
      var _i3 = indexes[k];
      var measurement = measurements[_i3];
      virtualItems.push(measurement);
    }
    return virtualItems;
  }, {
    key: "getIndexes",
    debug: function debug5() {
      return _this.options.debug;
    }
  });
  this.getVirtualItemForOffset = function(offset2) {
    var measurements = _this.getMeasurements();
    return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, function(index) {
      return notUndefined(measurements[index]).start;
    }, offset2)]);
  };
  this.getOffsetForAlignment = function(toOffset, align2) {
    var size2 = _this.getSize();
    if (align2 === "auto") {
      if (toOffset <= _this.scrollOffset) {
        align2 = "start";
      } else if (toOffset >= _this.scrollOffset + size2) {
        align2 = "end";
      } else {
        align2 = "start";
      }
    }
    if (align2 === "start") {
      toOffset = toOffset;
    } else if (align2 === "end") {
      toOffset = toOffset - size2;
    } else if (align2 === "center") {
      toOffset = toOffset - size2 / 2;
    }
    var scrollSizeProp = _this.options.horizontal ? "scrollWidth" : "scrollHeight";
    var scrollSize = _this.scrollElement ? "document" in _this.scrollElement ? _this.scrollElement.document.documentElement[scrollSizeProp] : _this.scrollElement[scrollSizeProp] : 0;
    var maxOffset = scrollSize - _this.getSize();
    return Math.max(Math.min(maxOffset, toOffset), 0);
  };
  this.getOffsetForIndex = function(index, align2) {
    if (align2 === void 0) {
      align2 = "auto";
    }
    index = Math.max(0, Math.min(index, _this.options.count - 1));
    var measurement = notUndefined(_this.getMeasurements()[index]);
    if (align2 === "auto") {
      if (measurement.end >= _this.scrollOffset + _this.getSize() - _this.options.scrollPaddingEnd) {
        align2 = "end";
      } else if (measurement.start <= _this.scrollOffset + _this.options.scrollPaddingStart) {
        align2 = "start";
      } else {
        return [_this.scrollOffset, align2];
      }
    }
    var toOffset = align2 === "end" ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;
    return [_this.getOffsetForAlignment(toOffset, align2), align2];
  };
  this.isDynamicMode = function() {
    return _this.measureElementCache.size > 0;
  };
  this.cancelScrollToIndex = function() {
    if (_this.scrollToIndexTimeoutId !== null) {
      clearTimeout(_this.scrollToIndexTimeoutId);
      _this.scrollToIndexTimeoutId = null;
    }
  };
  this.scrollToOffset = function(toOffset, _temp) {
    var _ref5 = _temp === void 0 ? {} : _temp, _ref5$align = _ref5.align, align2 = _ref5$align === void 0 ? "start" : _ref5$align, behavior = _ref5.behavior;
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align2), {
      adjustments: void 0,
      behavior
    });
  };
  this.scrollToIndex = function(index, _temp2) {
    var _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$align = _ref6.align, initialAlign = _ref6$align === void 0 ? "auto" : _ref6$align, behavior = _ref6.behavior;
    index = Math.max(0, Math.min(index, _this.options.count - 1));
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    var _this$getOffsetForInd = _this.getOffsetForIndex(index, initialAlign), toOffset = _this$getOffsetForInd[0], align2 = _this$getOffsetForInd[1];
    _this._scrollToOffset(toOffset, {
      adjustments: void 0,
      behavior
    });
    if (behavior !== "smooth" && _this.isDynamicMode()) {
      _this.scrollToIndexTimeoutId = setTimeout(function() {
        _this.scrollToIndexTimeoutId = null;
        var elementInDOM = _this.measureElementCache.has(_this.options.getItemKey(index));
        if (elementInDOM) {
          var _this$getOffsetForInd2 = _this.getOffsetForIndex(index, align2), _toOffset = _this$getOffsetForInd2[0];
          if (!approxEqual(_toOffset, _this.scrollOffset)) {
            _this.scrollToIndex(index, {
              align: align2,
              behavior
            });
          }
        } else {
          _this.scrollToIndex(index, {
            align: align2,
            behavior
          });
        }
      });
    }
  };
  this.scrollBy = function(delta2, _temp3) {
    var _ref7 = _temp3 === void 0 ? {} : _temp3, behavior = _ref7.behavior;
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    _this._scrollToOffset(_this.scrollOffset + delta2, {
      adjustments: void 0,
      behavior
    });
  };
  this.getTotalSize = function() {
    var _this$getMeasurements;
    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) - _this.options.scrollMargin + _this.options.paddingEnd;
  };
  this._scrollToOffset = function(offset2, _ref8) {
    var adjustments = _ref8.adjustments, behavior = _ref8.behavior;
    _this.options.scrollToFn(offset2, {
      behavior,
      adjustments
    }, _this);
  };
  this.measure = function() {
    _this.itemSizeCache = /* @__PURE__ */ new Map();
    _this.notify();
  };
  this.setOptions(_opts);
  this.scrollRect = this.options.initialRect;
  this.scrollOffset = this.options.initialOffset;
  this.measurementsCache = this.options.initialMeasurementsCache;
  this.measurementsCache.forEach(function(item) {
    _this.itemSizeCache.set(item.key, item.size);
  });
  this.maybeNotify();
};
var findNearestBinarySearch = function findNearestBinarySearch2(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange(_ref9) {
  var measurements = _ref9.measurements, outerSize = _ref9.outerSize, scrollOffset = _ref9.scrollOffset;
  var count2 = measurements.length - 1;
  var getOffset = function getOffset2(index) {
    return measurements[index].start;
  };
  var startIndex = findNearestBinarySearch(0, count2, getOffset, scrollOffset);
  var endIndex = startIndex;
  while (endIndex < count2 && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return {
    startIndex,
    endIndex
  };
}

// node_modules/@tanstack/react-virtual/build/lib/index.mjs
var useIsomorphicLayoutEffect2 = typeof document !== "undefined" ? React12.useLayoutEffect : React12.useEffect;
function useVirtualizerBase(options) {
  var rerender = React12.useReducer(function() {
    return {};
  }, {})[1];
  var resolvedOptions = _extends({}, options, {
    onChange: function onChange(instance3) {
      rerender();
      options.onChange == null ? void 0 : options.onChange(instance3);
    }
  });
  var _React$useState = React12.useState(function() {
    return new Virtualizer(resolvedOptions);
  }), instance2 = _React$useState[0];
  instance2.setOptions(resolvedOptions);
  React12.useEffect(function() {
    return instance2._didMount();
  }, []);
  useIsomorphicLayoutEffect2(function() {
    return instance2._willUpdate();
  });
  return instance2;
}
function useVirtualizer(options) {
  return useVirtualizerBase(_extends({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll
  }, options));
}

// node_modules/sanity/lib/index.esm.js
var import_throttle3 = __toESM(require_throttle());
var import_shallow_equals = __toESM(require_shallow_equals());
var import_startCase2 = __toESM(require_startCase());

// node_modules/sanity/lib/router.esm.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react47 = __toESM(require_react());
var import_debug = __toESM(require_browser());
var import_difference = __toESM(require_difference());
var import_intersection = __toESM(require_intersection());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_pick = __toESM(require_pick());
var import_identity = __toESM(require_identity());
var RouterContext = import_react47.default.createContext(null);
function useRouter() {
  const router = (0, import_react47.useContext)(RouterContext);
  if (!router) {
    throw new Error("Router: missing context value");
  }
  return router;
}
function isLeftClickEvent(event) {
  return event.button === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function useLink(options) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace = false
  } = options;
  const {
    navigateUrl
  } = useRouter();
  const onClick = (0, import_react47.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (!href)
      return;
    if (onClickProp) {
      onClickProp(event);
    }
    if (isModifiedEvent(event) || !isLeftClickEvent(event)) {
      return;
    }
    if (target) {
      return;
    }
    event.preventDefault();
    navigateUrl({
      path: href,
      replace
    });
  }, [href, navigateUrl, onClickProp, replace, target]);
  return {
    onClick
  };
}
function useIntentLink(options) {
  const {
    intent,
    onClick: onClickProp,
    params,
    replace,
    target
  } = options;
  const {
    resolveIntentLink
  } = useRouter();
  const href = (0, import_react47.useMemo)(() => resolveIntentLink(intent, params), [intent, params, resolveIntentLink]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
var IntentLink = (0, import_react47.forwardRef)(function IntentLink2(props2, ref) {
  const {
    intent,
    params,
    target,
    ...restProps
  } = props2;
  const {
    onClick,
    href
  } = useIntentLink({
    intent,
    params,
    target,
    onClick: props2.onClick
  });
  return (0, import_jsx_runtime3.jsx)("a", {
    ...restProps,
    href,
    onClick,
    ref,
    target
  });
});
var Link = (0, import_react47.forwardRef)(function Link2(props2, ref) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace,
    ...restProps
  } = props2;
  const {
    onClick
  } = useLink({
    onClick: onClickProp,
    href,
    target,
    replace
  });
  return (0, import_jsx_runtime3.jsx)("a", {
    ...restProps,
    onClick,
    href,
    target,
    ref
  });
});
function addScope(routerState, scope, scopedState) {
  return scopedState && {
    ...routerState,
    [scope]: scopedState
  };
}
function RouteScope(props2) {
  const {
    children,
    scope,
    __unsafe_disableScopedSearchParams
  } = props2;
  const parentRouter = useRouter();
  const {
    resolvePathFromState: parent_resolvePathFromState,
    navigate: parent_navigate
  } = parentRouter;
  const parentStateRef = (0, import_react47.useRef)(parentRouter.state);
  parentStateRef.current = parentRouter.state;
  const resolveNextParentState = (0, import_react47.useCallback)((_nextState) => {
    const {
      _searchParams,
      ...nextState
    } = _nextState;
    const nextParentState = addScope(parentStateRef.current, scope, nextState);
    if (__unsafe_disableScopedSearchParams) {
      nextParentState._searchParams = _searchParams;
    } else {
      nextParentState[scope]._searchParams = _searchParams;
    }
    return nextParentState;
  }, [scope, __unsafe_disableScopedSearchParams]);
  const resolvePathFromState = (0, import_react47.useCallback)((nextState) => parent_resolvePathFromState(resolveNextParentState(nextState)), [parent_resolvePathFromState, resolveNextParentState]);
  const navigate = (0, import_react47.useCallback)((nextState) => parent_navigate(resolveNextParentState(nextState)), [parent_navigate, resolveNextParentState]);
  const childRouter = (0, import_react47.useMemo)(() => {
    const parentState = parentRouter.state;
    const childState = {
      ...parentState[scope] || {}
    };
    if (__unsafe_disableScopedSearchParams) {
      childState._searchParams = parentState._searchParams;
    }
    return {
      ...parentRouter,
      navigate,
      resolvePathFromState,
      state: childState
    };
  }, [scope, parentRouter, navigate, resolvePathFromState, __unsafe_disableScopedSearchParams]);
  return (0, import_jsx_runtime3.jsx)(RouterContext.Provider, {
    value: childRouter,
    children
  });
}
function RouterProvider(props2) {
  const {
    onNavigate,
    router: routerProp,
    state
  } = props2;
  const resolveIntentLink = (0, import_react47.useCallback)((intentName, parameters) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload
    });
  }, [routerProp]);
  const resolvePathFromState = (0, import_react47.useCallback)((nextState) => {
    return routerProp.encode(nextState);
  }, [routerProp]);
  const navigate = (0, import_react47.useCallback)(function(nextState) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    onNavigate({
      path: resolvePathFromState(nextState),
      replace: options.replace
    });
  }, [onNavigate, resolvePathFromState]);
  const navigateIntent = (0, import_react47.useCallback)(function(intentName, params) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    onNavigate({
      path: resolveIntentLink(intentName, params),
      replace: options.replace
    });
  }, [onNavigate, resolveIntentLink]);
  const router = (0, import_react47.useMemo)(() => ({
    navigate,
    navigateIntent,
    navigateUrl: onNavigate,
    resolveIntentLink,
    resolvePathFromState,
    state
  }), [navigate, navigateIntent, onNavigate, resolveIntentLink, resolvePathFromState, state]);
  return (0, import_jsx_runtime3.jsx)(RouterContext.Provider, {
    value: router,
    children: props2.children
  });
}
var EMPTY_STATE$1 = {};
function useStateLink(options) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false
  } = options;
  if (state && toIndex) {
    throw new Error("Passing both `state` and `toIndex={true}` as props to StateLink is invalid");
  }
  if (!state && !toIndex) {
    console.error(new Error("No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property"));
  }
  const {
    resolvePathFromState
  } = useRouter();
  const href = (0, import_react47.useMemo)(() => resolvePathFromState(toIndex ? EMPTY_STATE$1 : state || EMPTY_STATE$1), [resolvePathFromState, state, toIndex]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
var StateLink = (0, import_react47.forwardRef)(function StateLink2(props2, ref) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false,
    ...restProps
  } = props2;
  const {
    onClick,
    href
  } = useStateLink({
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex
  });
  return (0, import_jsx_runtime3.jsx)("a", {
    ...restProps,
    href,
    onClick,
    ref
  });
});
var VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/;
function createSegment(segment) {
  if (!segment) {
    return null;
  }
  if (segment.startsWith(":")) {
    const paramName = segment.substring(1);
    if (!VALID_PARAM_SEGMENT.test(paramName)) {
      const addendum = segment.includes("*") ? " Splats are not supported. Consider using child routes instead" : "";
      console.error(new Error('Warning: Param segments "'.concat(segment, '" includes invalid characters.').concat(addendum)));
    }
    return {
      type: "param",
      name: paramName
    };
  }
  return {
    type: "dir",
    name: segment
  };
}
function _parseRoute(route2) {
  const [pathname] = route2.split("?");
  const segments = pathname.split("/").map(createSegment).filter(Boolean);
  return {
    raw: route2,
    segments
  };
}
var debug = (0, import_debug.default)("state-router");
function arrayify(val) {
  if (Array.isArray(val)) {
    return val;
  }
  return val ? [val] : [];
}
function parseScopedParams(params) {
  return params.map((_ref) => {
    let [key2, value] = _ref;
    return [parse2(key2), value];
  });
}
var OPEN = 1;
var CLOSED = 0;
function parse2(str) {
  const result = [];
  let i = 0;
  let state = CLOSED;
  while (i < str.length) {
    const nextBracketIdx = str.indexOf("[", i);
    if (nextBracketIdx === -1) {
      result.push(str.slice(i, str.length));
      break;
    }
    if (state === OPEN) {
      throw new Error("Nested brackets not supported");
    }
    state = OPEN;
    if (nextBracketIdx > i) {
      result.push(str.slice(i, nextBracketIdx));
      i = nextBracketIdx;
    }
    const nextClosing = str.indexOf("]", nextBracketIdx);
    if (nextClosing === -1) {
      if (state === OPEN) {
        throw new Error("Unclosed bracket");
      }
      break;
    }
    state = CLOSED;
    result.push(str.slice(i + 1, nextClosing));
    i = nextClosing + 1;
  }
  return result;
}
function matchPath(node, path2, searchParams) {
  const parts = path2.split("/").filter(Boolean);
  const segmentsLength = node.route.segments.length;
  if (parts.length < segmentsLength) {
    return null;
  }
  const state = {};
  const isMatching = node.route.segments.every((segment, i) => {
    if (segment.type === "dir") {
      return segment.name === parts[i];
    }
    const transform2 = node.transform && node.transform[segment.name];
    state[segment.name] = transform2 ? transform2.toState(parts[i]) : parts[i];
    return true;
  });
  if (!isMatching) {
    return null;
  }
  const rest = parts.slice(segmentsLength);
  let childState = null;
  const children = typeof node.children === "function" ? arrayify(node.children(state)) : node.children;
  const unscopedParams = removeScope(node.scope, searchParams);
  children.some((childNode) => {
    if (childNode) {
      const childParams = childNode.scope ? unscopedParams.filter((_ref2) => {
        let [namespaces2] = _ref2;
        return childNode.scope === namespaces2[0];
      }) : unscopedParams;
      childState = matchPath(childNode, rest.join("/"), childParams);
      return childState;
    }
    return void 0;
  });
  if (rest.length > 0 && !childState) {
    return null;
  }
  const selfParams = unscopedParams.flatMap((_ref3) => {
    let [namespace, value] = _ref3;
    return namespace.length === 1 ? [[namespace[0], value]] : [];
  });
  const mergedState = {
    ...state,
    ...childState || {},
    ...selfParams.length > 0 ? {
      _searchParams: selfParams
    } : {}
  };
  return node.scope ? {
    [node.scope]: mergedState
  } : mergedState;
}
function _resolveStateFromPath(node, path2) {
  debug("resolving state from path %s", path2);
  const [pathname, search2] = path2.split("?");
  const urlSearchParams = Array.from(new URLSearchParams(search2).entries());
  const pathMatch = matchPath(node, pathname, parseScopedParams(urlSearchParams));
  debug("resolved: %o", pathMatch || null);
  return pathMatch || null;
}
function removeScope(scope, searchParams) {
  return scope ? searchParams.map((_ref4) => {
    let [namespaces2, value] = _ref4;
    return [namespaces2[0] === scope ? namespaces2.slice(1) : namespaces2, value];
  }) : searchParams;
}
function isRecord3(value) {
  return (0, import_isPlainObject.default)(value);
}
function createMatchError(node, missingKeys, unmappableStateKeys) {
  return {
    type: "error",
    node,
    missingKeys,
    unmappableStateKeys
  };
}
function createMatchOk(node, matchedState, searchParams, child) {
  return {
    type: "ok",
    node,
    matchedState,
    searchParams,
    child
  };
}
function _findMatchingRoutes(node, _state) {
  if (!_state) {
    return createMatchOk(node, {}, []);
  }
  const scopedState = node.scope ? _state[node.scope] : _state;
  const {
    _searchParams: searchParams = [],
    ...state
  } = scopedState || {};
  const requiredParams = node.route.segments.filter((seg) => seg.type === "param").map((seg) => seg.name);
  const stateKeys = isRecord3(state) ? Object.keys(state) : [];
  const consumedParams = (0, import_intersection.default)(stateKeys, requiredParams);
  const missingParams = (0, import_difference.default)(requiredParams, consumedParams);
  const remainingParams = (0, import_difference.default)(stateKeys, consumedParams);
  if (missingParams.length > 0) {
    return createMatchError(node, missingParams, []);
  }
  const scopedParams = searchParams.map((_ref5) => {
    let [key2, value] = _ref5;
    return [[key2], value];
  });
  const consumedState = (0, import_pick.default)(state, consumedParams);
  if (remainingParams.length === 0) {
    return createMatchOk(node, consumedState, scopedParams);
  }
  const children = arrayify((typeof node.children === "function" ? node.children(isRecord3(state) ? state : {}) : node.children) || []);
  if (remainingParams.length > 0 && children.length === 0) {
    return createMatchError(node, [], remainingParams);
  }
  const remainingState = (0, import_pick.default)(state, remainingParams);
  const childResult = children.map((childNode) => _findMatchingRoutes(childNode, remainingState));
  const found = childResult.find((res) => res.type === "ok");
  return found ? createMatchOk(node, consumedState, scopedParams, found) : createMatchError(node, [], remainingParams);
}
function encodeURIComponentExcept(uriComponent, unescaped) {
  const chars2 = [...String(uriComponent)];
  let res = "";
  for (let i = 0; i < chars2.length; i++) {
    const char = chars2[i];
    if (unescaped.includes(char)) {
      res += char;
    } else {
      res += encodeURIComponent(char);
    }
  }
  return res;
}
function _resolvePathFromState(node, _state) {
  debug("Resolving path from state %o", _state);
  const match4 = _findMatchingRoutes(node, _state);
  if (match4.type === "error") {
    const unmappable = match4.unmappableStateKeys;
    if (unmappable.length > 0) {
      throw new Error("Unable to find matching route for state. Could not map the following state key".concat(unmappable.length == 1 ? "" : "s", " to a valid url: ").concat(unmappable.map(quote).join(", ")));
    }
    const missingKeys = match4.missingKeys;
    throw new Error("Unable to find matching route for state. State object is missing the following key".concat(missingKeys.length == 1 ? "" : "s", " defined in route: ").concat(missingKeys.map(quote).join(", ")));
  }
  const {
    path: path2,
    searchParams
  } = pathFromMatchResult(match4);
  const search2 = searchParams.length > 0 ? encodeParams$1(searchParams) : "";
  return "/".concat(path2.join("/")).concat(search2 ? "?".concat(search2) : "");
}
function bracketify(value) {
  return "[".concat(value, "]");
}
function encodeParams$1(params) {
  return params.flatMap((_ref6) => {
    let [key2, value] = _ref6;
    if (value === void 0) {
      return [];
    }
    return [encodeSearchParamKey(serializeScopedPath(key2)), encodeSearchParamValue(value)].join("=");
  }).join("&");
}
function serializeScopedPath(scopedPath) {
  const [head, ...tail] = scopedPath;
  return tail.length > 0 ? [head, ...tail.map(bracketify)].join("") : head;
}
function encodeSearchParamValue(value) {
  return encodeURIComponentExcept(value, "/");
}
function encodeSearchParamKey(value) {
  return encodeURIComponentExcept(value, "[]");
}
function pathFromMatchResult(match4) {
  const matchedState = match4.matchedState;
  const base = match4.node.route.segments.map((segment) => {
    if (segment.type === "dir") {
      return segment.name;
    }
    const transform2 = match4.node.transform && match4.node.transform[segment.name];
    return transform2 ? transform2.toPath(matchedState[segment.name]) : matchedState[segment.name];
  });
  const childMatch = match4.child ? pathFromMatchResult(match4.child) : void 0;
  const searchParams = (childMatch == null ? void 0 : childMatch.searchParams) ? [...match4.searchParams, ...childMatch.searchParams] : match4.searchParams;
  return {
    searchParams: addNodeScope(match4.node, searchParams),
    path: [...base || [], ...(childMatch == null ? void 0 : childMatch.path) || []]
  };
}
function addNodeScope(node, searchParams) {
  const scope = node.scope;
  return scope && !node.__unsafe_disableScopedSearchParams ? searchParams.map((_ref7) => {
    let [namespaces2, value] = _ref7;
    return [[scope, ...namespaces2], value];
  }) : searchParams;
}
function quote(value) {
  return '"'.concat(value, '"');
}
function encodeBase64Url(str) {
  return encodeBase64(str).replace(/\//g, "_").replace(/\+/g, "-").replace(/[=]+$/, "");
}
function decodeBase64Url(str) {
  return decodeBase64(str.replace(/-/g, "+").replace(/_/g, "/"));
}
function percentToByte(p) {
  return String.fromCharCode(parseInt(p.slice(1), 16));
}
function encodeBase64(str) {
  return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));
}
function byteToPercent(b) {
  return "%".concat("00".concat(b.charCodeAt(0).toString(16)).slice(-2));
}
function decodeBase64(str) {
  return decodeURIComponent(Array.from(atob(str), byteToPercent).join(""));
}
function decodeJsonParams() {
  let pathSegment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const segment = decodeURIComponent(pathSegment);
  if (!segment) {
    return {};
  }
  try {
    return JSON.parse(decodeBase64Url(segment));
  } catch (err) {
  }
  try {
    return JSON.parse(atob(segment));
  } catch (err) {
  }
  try {
    return JSON.parse(segment);
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
  }
  return {};
}
function encodeJsonParams(params) {
  return params ? encodeBase64Url(JSON.stringify(params)) : "";
}
function decodeParams(pathSegment) {
  return pathSegment.split(";").reduce((params, pair) => {
    const [key2, value] = pair.split("=");
    params[decodeURIComponent(key2)] = decodeURIComponent(value);
    return params;
  }, {});
}
function encodeParams(params) {
  return Object.entries(params).filter((_ref8) => {
    let [, value] = _ref8;
    return value !== void 0 && value !== null;
  }).map((_ref9) => {
    let [key2, value] = _ref9;
    return "".concat(encodeURIComponent(key2), "=").concat(encodeURIComponent(value));
  }).join(";");
}
var route = {
  create: (routeOrOpts, childrenOrOpts, children) => _createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),
  intents: (base) => {
    const basePath = normalize(base).join("/");
    return route.create("".concat(basePath, "/:intent"), [route.create(":params", {
      transform: {
        params: {
          toState: decodeParams,
          toPath: encodeParams
        }
      }
    }, [route.create(":payload", {
      transform: {
        payload: {
          toState: decodeJsonParams,
          toPath: encodeJsonParams
        }
      }
    })])]);
  },
  scope(scopeName, routeOrOpts, childrenOrOpts, children) {
    const options = normalizeArgs(routeOrOpts, childrenOrOpts, children);
    return _createNode({
      ...options,
      scope: scopeName
    });
  }
};
function normalizeChildren(children) {
  if (Array.isArray(children) || typeof children === "function") {
    return children;
  }
  return children ? [children] : [];
}
function isRoute(val) {
  return val && "_isRoute" in val;
}
function normalizeArgs(path2, childrenOrOpts, children) {
  if (typeof path2 === "object") {
    return path2;
  }
  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === "function" || isRoute(childrenOrOpts)) {
    return {
      path: path2,
      children: normalizeChildren(childrenOrOpts)
    };
  }
  if (children) {
    return {
      path: path2,
      ...childrenOrOpts,
      children: normalizeChildren(children)
    };
  }
  return {
    path: path2,
    ...childrenOrOpts
  };
}
function normalize() {
  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
    paths[_key] = arguments[_key];
  }
  return paths.reduce((acc, path2) => acc.concat(path2.split("/")), []).filter(Boolean);
}
var EMPTY_STATE = {};
function isRoot(pathname) {
  return pathname.split("/").every((segment) => !segment);
}
function _createNode(options) {
  const {
    path: path2,
    scope,
    transform: transform2,
    children,
    __unsafe_disableScopedSearchParams
  } = options;
  if (!path2) {
    throw new TypeError("Missing path");
  }
  const parsedRoute = _parseRoute(path2);
  return {
    _isRoute: true,
    // todo: make a Router class instead
    scope,
    // eslint-disable-next-line camelcase
    __unsafe_disableScopedSearchParams,
    route: parsedRoute,
    children: children || [],
    transform: transform2,
    encode(state) {
      return _resolvePathFromState(this, state);
    },
    decode(_path) {
      return _resolveStateFromPath(this, _path);
    },
    isRoot,
    isNotFound(pathname) {
      return this.decode(pathname) === null;
    },
    getBasePath() {
      return this.encode(EMPTY_STATE);
    },
    getRedirectBase(pathname) {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath();
        if (pathname !== basePath) {
          return basePath;
        }
      }
      return null;
    }
  };
}
function useRouterState() {
  let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : import_identity.default;
  const {
    state
  } = useRouter();
  return (0, import_react47.useMemo)(() => selector(state), [selector, state]);
}
function withRouter(Component3) {
  function WithRouter2(props2) {
    const router = useRouter();
    return (0, import_jsx_runtime3.jsx)(Component3, {
      ...props2,
      router
    });
  }
  WithRouter2.displayName = "withRouter(".concat(Component3.displayName || Component3.name, ")");
  return WithRouter2;
}
var WithRouter = withRouter((props2) => props2.children(props2.router));

// node_modules/sanity/lib/index.esm.js
init_es2015();
var import_classnames = __toESM(require_classnames());
init_index_module();
var import_react_refractor2 = __toESM(require_Refractor());
var import_bash = __toESM(require_bash());
var import_javascript = __toESM(require_javascript());
var import_json = __toESM(require_json());
var import_jsx = __toESM(require_jsx());
var import_typescript = __toESM(require_typescript());
var import_isString2 = __toESM(require_isString());

// node_modules/get-it/dist/_chunks/defaultOptionsValidator-dittwL7d.js
var isReactNative = typeof navigator === "undefined" ? false : navigator.product === "ReactNative";
var defaultOptions = {
  timeout: isReactNative ? 6e4 : 12e4
};
var processOptions = function processOptions2(opts) {
  const options = {
    ...defaultOptions,
    ...typeof opts === "string" ? {
      url: opts
    } : opts
  };
  const {
    searchParams
  } = new URL(options.url, "http://localhost");
  options.timeout = normalizeTimeout(options.timeout);
  if (options.query) {
    for (const [key2, value] of Object.entries(options.query)) {
      if (value !== void 0) {
        if (Array.isArray(value)) {
          for (const v of value) {
            searchParams.append(key2, v);
          }
        } else {
          searchParams.append(key2, value);
        }
      }
    }
  }
  const [url] = options.url.split("?");
  const search2 = searchParams.toString();
  if (search2) {
    options.url = "".concat(url, "?").concat(search2);
  }
  options.method = options.body && !options.method ? "POST" : (options.method || "GET").toUpperCase();
  return options;
};
function normalizeTimeout(time2) {
  if (time2 === false || time2 === 0) {
    return false;
  }
  if (time2.connect || time2.socket) {
    return time2;
  }
  const delay3 = Number(time2);
  if (isNaN(delay3)) {
    return normalizeTimeout(defaultOptions.timeout);
  }
  return {
    connect: delay3,
    socket: delay3
  };
}
var validUrl = /^https?:\/\//i;
var validateOptions = function validateOptions2(options) {
  if (!validUrl.test(options.url)) {
    throw new Error('"'.concat(options.url, '" is not a valid URL'));
  }
};

// node_modules/get-it/dist/index.browser.js
var import_parse_headers = __toESM(require_parse_headers());
var middlewareReducer = (middleware) => function applyMiddleware(hook, defaultValue) {
  const bailEarly = hook === "onError";
  let value = defaultValue;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  for (let i = 0; i < middleware[hook].length; i++) {
    const handler = middleware[hook][i];
    value = handler(value, ...args);
    if (bailEarly && !value) {
      break;
    }
  }
  return value;
};
function createPubSub2() {
  const subscribers = /* @__PURE__ */ Object.create(null);
  let nextId = 0;
  function subscribe(subscriber) {
    const id4 = nextId++;
    subscribers[id4] = subscriber;
    return function unsubscribe() {
      delete subscribers[id4];
    };
  }
  function publish2(event) {
    for (const id4 in subscribers) {
      subscribers[id4](event);
    }
  }
  return {
    publish: publish2,
    subscribe
  };
}
var channelNames = ["request", "response", "progress", "error", "abort"];
var middlehooks = ["processOptions", "validateOptions", "interceptRequest", "finalizeOptions", "onRequest", "onResponse", "onError", "onReturn", "onHeaders"];
function createRequester(initMiddleware, httpRequest) {
  const loadedMiddleware = [];
  const middleware = middlehooks.reduce((ware, name) => {
    ware[name] = ware[name] || [];
    return ware;
  }, {
    processOptions: [processOptions],
    validateOptions: [validateOptions]
  });
  function request(opts) {
    const onResponse = (reqErr, res, ctx) => {
      let error2 = reqErr;
      let response = res;
      if (!error2) {
        try {
          response = applyMiddleware("onResponse", res, ctx);
        } catch (err) {
          response = null;
          error2 = err;
        }
      }
      error2 = error2 && applyMiddleware("onError", error2, ctx);
      if (error2) {
        channels.error.publish(error2);
      } else if (response) {
        channels.response.publish(response);
      }
    };
    const channels = channelNames.reduce((target, name) => {
      target[name] = createPubSub2();
      return target;
    }, {});
    const applyMiddleware = middlewareReducer(middleware);
    const options = applyMiddleware("processOptions", opts);
    applyMiddleware("validateOptions", options);
    const context = {
      options,
      channels,
      applyMiddleware
    };
    let ongoingRequest;
    const unsubscribe = channels.request.subscribe((ctx) => {
      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));
    });
    channels.abort.subscribe(() => {
      unsubscribe();
      if (ongoingRequest) {
        ongoingRequest.abort();
      }
    });
    const returnValue = applyMiddleware("onReturn", channels, context);
    if (returnValue === channels) {
      channels.request.publish(context);
    }
    return returnValue;
  }
  request.use = function use2(newMiddleware) {
    if (!newMiddleware) {
      throw new Error("Tried to add middleware that resolved to falsey value");
    }
    if (typeof newMiddleware === "function") {
      throw new Error("Tried to add middleware that was a function. It probably expects you to pass options to it.");
    }
    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
      throw new Error("Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event");
    }
    middlehooks.forEach((key2) => {
      if (newMiddleware[key2]) {
        middleware[key2].push(newMiddleware[key2]);
      }
    });
    loadedMiddleware.push(newMiddleware);
    return request;
  };
  request.clone = () => createRequester(loadedMiddleware, httpRequest);
  initMiddleware.forEach(request.use);
  return request;
}
var __accessCheck = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _method;
var _url;
var _resHeaders;
var _headers;
var _controller;
var _init;
var _useAbortSignal;
var FetchXhr = class {
  constructor() {
    this.readyState = 0;
    this.responseType = "";
    __privateAdd(this, _method, void 0);
    __privateAdd(this, _url, void 0);
    __privateAdd(this, _resHeaders, void 0);
    __privateAdd(this, _headers, {});
    __privateAdd(this, _controller, void 0);
    __privateAdd(this, _init, {});
    __privateAdd(this, _useAbortSignal, void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility
  open(method, url, _async) {
    __privateSet(this, _method, method);
    __privateSet(this, _url, url);
    __privateSet(this, _resHeaders, "");
    this.readyState = 1;
    this.onreadystatechange();
    __privateSet(this, _controller, void 0);
  }
  abort() {
    if (__privateGet(this, _controller)) {
      __privateGet(this, _controller).abort();
    }
  }
  getAllResponseHeaders() {
    return __privateGet(this, _resHeaders);
  }
  setRequestHeader(name, value) {
    __privateGet(this, _headers)[name] = value;
  }
  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components
  setInit(init2) {
    let useAbortSignal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    __privateSet(this, _init, init2);
    __privateSet(this, _useAbortSignal, useAbortSignal);
  }
  send(body) {
    const textBody = this.responseType !== "arraybuffer";
    const options = {
      ...__privateGet(this, _init),
      method: __privateGet(this, _method),
      headers: __privateGet(this, _headers),
      body
    };
    if (typeof AbortController === "function" && __privateGet(this, _useAbortSignal)) {
      __privateSet(this, _controller, new AbortController());
      if (typeof EventTarget !== "undefined" && __privateGet(this, _controller).signal instanceof EventTarget) {
        options.signal = __privateGet(this, _controller).signal;
      }
    }
    if (typeof document !== "undefined") {
      options.credentials = this.withCredentials ? "include" : "omit";
    }
    fetch(__privateGet(this, _url), options).then((res) => {
      res.headers.forEach((value, key2) => {
        __privateSet(this, _resHeaders, __privateGet(this, _resHeaders) + "".concat(key2, ": ").concat(value, "\r\n"));
      });
      this.status = res.status;
      this.statusText = res.statusText;
      this.readyState = 3;
      return textBody ? res.text() : res.arrayBuffer();
    }).then((resBody) => {
      if (typeof resBody === "string") {
        this.responseText = resBody;
      } else {
        this.response = resBody;
      }
      this.readyState = 4;
      this.onreadystatechange();
    }).catch((err) => {
      var _a4;
      if (err.name === "AbortError") {
        this.onabort();
        return;
      }
      (_a4 = this.onerror) == null ? void 0 : _a4.call(this, err);
    });
  }
};
_method = /* @__PURE__ */ new WeakMap();
_url = /* @__PURE__ */ new WeakMap();
_resHeaders = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_controller = /* @__PURE__ */ new WeakMap();
_init = /* @__PURE__ */ new WeakMap();
_useAbortSignal = /* @__PURE__ */ new WeakMap();
var adapter = typeof XMLHttpRequest === "function" ? "xhr" : "fetch";
var XmlHttpRequest = adapter === "xhr" ? XMLHttpRequest : FetchXhr;
var httpRequester = (context, callback) => {
  var _a4;
  const opts = context.options;
  const options = context.applyMiddleware("finalizeOptions", opts);
  const timers = {};
  const injectedResponse = context.applyMiddleware("interceptRequest", void 0, {
    adapter,
    context
  });
  if (injectedResponse) {
    const cbTimer = setTimeout(callback, 0, null, injectedResponse);
    const cancel = () => clearTimeout(cbTimer);
    return {
      abort: cancel
    };
  }
  let xhr = new XmlHttpRequest();
  if (xhr instanceof FetchXhr && typeof options.fetch === "object") {
    xhr.setInit(options.fetch, (_a4 = options.useAbortSignal) != null ? _a4 : true);
  }
  const headers = options.headers;
  const delays = options.timeout;
  let aborted = false;
  let loaded = false;
  let timedOut = false;
  xhr.onerror = (event) => {
    onError(new Error("Request error while attempting to reach ".concat(options.url).concat(event.lengthComputable ? "(".concat(event.loaded, " of ").concat(event.total, " bytes transferred)") : "")));
  };
  xhr.ontimeout = (event) => {
    onError(new Error("Request timeout while attempting to reach ".concat(options.url).concat(event.lengthComputable ? "(".concat(event.loaded, " of ").concat(event.total, " bytes transferred)") : "")));
  };
  xhr.onabort = () => {
    stopTimers(true);
    aborted = true;
  };
  xhr.onreadystatechange = () => {
    resetTimers();
    if (aborted || xhr.readyState !== 4) {
      return;
    }
    if (xhr.status === 0) {
      return;
    }
    onLoad();
  };
  xhr.open(
    options.method,
    options.url,
    true
    // Always async
  );
  xhr.withCredentials = !!options.withCredentials;
  if (headers && xhr.setRequestHeader) {
    for (const key2 in headers) {
      if (headers.hasOwnProperty(key2)) {
        xhr.setRequestHeader(key2, headers[key2]);
      }
    }
  }
  if (options.rawBody) {
    xhr.responseType = "arraybuffer";
  }
  context.applyMiddleware("onRequest", {
    options,
    adapter,
    request: xhr,
    context
  });
  xhr.send(options.body || null);
  if (delays) {
    timers.connect = setTimeout(() => timeoutRequest("ETIMEDOUT"), delays.connect);
  }
  return {
    abort
  };
  function abort() {
    aborted = true;
    if (xhr) {
      xhr.abort();
    }
  }
  function timeoutRequest(code) {
    timedOut = true;
    xhr.abort();
    const error2 = new Error(code === "ESOCKETTIMEDOUT" ? "Socket timed out on request to ".concat(options.url) : "Connection timed out on request to ".concat(options.url));
    error2.code = code;
    context.channels.error.publish(error2);
  }
  function resetTimers() {
    if (!delays) {
      return;
    }
    stopTimers();
    timers.socket = setTimeout(() => timeoutRequest("ESOCKETTIMEDOUT"), delays.socket);
  }
  function stopTimers(force) {
    if (force || aborted || xhr.readyState >= 2 && timers.connect) {
      clearTimeout(timers.connect);
    }
    if (timers.socket) {
      clearTimeout(timers.socket);
    }
  }
  function onError(error2) {
    if (loaded) {
      return;
    }
    stopTimers(true);
    loaded = true;
    xhr = null;
    const err = error2 || new Error("Network error while attempting to reach ".concat(options.url));
    err.isNetworkError = true;
    err.request = options;
    callback(err);
  }
  function reduceResponse() {
    return {
      body: xhr.response || (xhr.responseType === "" || xhr.responseType === "text" ? xhr.responseText : ""),
      url: options.url,
      method: options.method,
      headers: (0, import_parse_headers.default)(xhr.getAllResponseHeaders()),
      statusCode: xhr.status,
      statusMessage: xhr.statusText
    };
  }
  function onLoad() {
    if (aborted || loaded || timedOut) {
      return;
    }
    if (xhr.status === 0) {
      onError(new Error("Unknown XHR error"));
      return;
    }
    stopTimers();
    loaded = true;
    callback(null, reduceResponse());
  }
};
var getIt = function() {
  let initMiddleware = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let httpRequest = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : httpRequester;
  return createRequester(initMiddleware, httpRequest);
};

// node_modules/get-it/dist/middleware.browser.js
var import_debug2 = __toESM(require_browser2());
init_is_plain_object();
function agent(opts) {
  return {};
}
var isBuffer = typeof Buffer === "undefined" ? () => false : (obj) => Buffer.isBuffer(obj);
var serializeTypes = ["boolean", "string", "number"];
function jsonRequest() {
  return {
    processOptions: (options) => {
      const body = options.body;
      if (!body) {
        return options;
      }
      const isStream2 = typeof body.pipe === "function";
      const shouldSerialize = !isStream2 && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject(body));
      if (!shouldSerialize) {
        return options;
      }
      return Object.assign({}, options, {
        body: JSON.stringify(options.body),
        headers: Object.assign({}, options.headers, {
          "Content-Type": "application/json"
        })
      });
    }
  };
}
function jsonResponse(opts) {
  return {
    onResponse: (response) => {
      const contentType = response.headers["content-type"] || "";
      const shouldDecode = opts && opts.force || contentType.indexOf("application/json") !== -1;
      if (!response.body || !contentType || !shouldDecode) {
        return response;
      }
      return Object.assign({}, response, {
        body: tryParse2(response.body)
      });
    },
    processOptions: (options) => Object.assign({}, options, {
      headers: Object.assign({
        Accept: "application/json"
      }, options.headers)
    })
  };
  function tryParse2(body) {
    try {
      return JSON.parse(body);
    } catch (err) {
      err.message = "Failed to parsed response body as JSON: ".concat(err.message);
      throw err;
    }
  }
}
var actualGlobal = {};
if (typeof globalThis !== "undefined") {
  actualGlobal = globalThis;
} else if (typeof window !== "undefined") {
  actualGlobal = window;
} else if (typeof global !== "undefined") {
  actualGlobal = global;
} else if (typeof self !== "undefined") {
  actualGlobal = self;
}
var global$12 = actualGlobal;
function observable() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const Observable2 = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track
    opts.implementation || global$12.Observable
  );
  if (!Observable2) {
    throw new Error("`Observable` is not available in global scope, and no implementation was passed");
  }
  return {
    onReturn: (channels, context) => new Observable2((observer) => {
      channels.error.subscribe((err) => observer.error(err));
      channels.progress.subscribe((event) => observer.next(Object.assign({
        type: "progress"
      }, event)));
      channels.response.subscribe((response) => {
        observer.next(Object.assign({
          type: "response"
        }, response));
        observer.complete();
      });
      channels.request.publish(context);
      return () => channels.abort.publish();
    })
  };
}
function progress2() {
  return {
    onRequest: (evt) => {
      if (evt.adapter !== "xhr") {
        return;
      }
      const xhr = evt.request;
      const context = evt.context;
      if ("upload" in xhr && "onprogress" in xhr.upload) {
        xhr.upload.onprogress = handleProgress("upload");
      }
      if ("onprogress" in xhr) {
        xhr.onprogress = handleProgress("download");
      }
      function handleProgress(stage) {
        return (event) => {
          const percent2 = event.lengthComputable ? event.loaded / event.total * 100 : -1;
          context.channels.progress.publish({
            stage,
            percent: percent2,
            total: event.total,
            loaded: event.loaded,
            lengthComputable: event.lengthComputable
          });
        };
      }
    }
  };
}
var promise = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const PromiseImplementation = options.implementation || Promise;
  if (!PromiseImplementation) {
    throw new Error("`Promise` is not available in global scope, and no implementation was passed");
  }
  return {
    onReturn: (channels, context) => new PromiseImplementation((resolve, reject) => {
      const cancel = context.options.cancelToken;
      if (cancel) {
        cancel.promise.then((reason) => {
          channels.abort.publish(reason);
          reject(reason);
        });
      }
      channels.error.subscribe(reject);
      channels.response.subscribe((response) => {
        resolve(options.onlyBody ? response.body : response);
      });
      setTimeout(() => {
        try {
          channels.request.publish(context);
        } catch (err) {
          reject(err);
        }
      }, 0);
    })
  };
};
var Cancel = class {
  constructor(message) {
    this.__CANCEL__ = true;
    this.message = message;
  }
  toString() {
    return "Cancel".concat(this.message ? ": ".concat(this.message) : "");
  }
};
var _CancelToken = class _CancelToken2 {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise = null;
    this.promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    executor((message) => {
      if (this.reason) {
        return;
      }
      this.reason = new Cancel(message);
      resolvePromise(this.reason);
    });
  }
};
_CancelToken.source = () => {
  let cancel;
  const token = new _CancelToken((can) => {
    cancel = can;
  });
  return {
    token,
    cancel
  };
};
var CancelToken = _CancelToken;
var isCancel = (value) => !!(value && (value == null ? void 0 : value.__CANCEL__));
promise.Cancel = Cancel;
promise.CancelToken = CancelToken;
promise.isCancel = isCancel;
var defaultShouldRetry = (err, attempt, options) => {
  if (options.method !== "GET" && options.method !== "HEAD") {
    return false;
  }
  return err.isNetworkError || false;
};
var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
var sharedRetry = (opts) => {
  const maxRetries = opts.maxRetries || 5;
  const retryDelay = opts.retryDelay || getRetryDelay;
  const allowRetry = opts.shouldRetry;
  return {
    onError: (err, context) => {
      const options = context.options;
      const max2 = options.maxRetries || maxRetries;
      const shouldRetry2 = options.shouldRetry || allowRetry;
      const attemptNumber = options.attemptNumber || 0;
      if (isStream(options.body)) {
        return err;
      }
      if (!shouldRetry2(err, attemptNumber, options) || attemptNumber >= max2) {
        return err;
      }
      const newContext = Object.assign({}, context, {
        options: Object.assign({}, options, {
          attemptNumber: attemptNumber + 1
        })
      });
      setTimeout(() => context.channels.request.publish(newContext), retryDelay(attemptNumber));
      return null;
    }
  };
};
function getRetryDelay(attemptNum) {
  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;
}
var retry = function() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return sharedRetry({
    shouldRetry: defaultShouldRetry,
    ...opts
  });
};
retry.shouldRetry = defaultShouldRetry;
function buildKeepAlive(agent2) {
  return function keepAlive2() {
    let config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const ms = config.ms || 1e3;
    const maxFree = config.maxFree || 256;
    const agentOptions = {
      keepAlive: true,
      keepAliveMsecs: ms,
      maxFreeSockets: maxFree
    };
    return agent2(agentOptions);
  };
}
var keepAlive = buildKeepAlive(agent);

// node_modules/@sanity/client/dist/_chunks/browserMiddleware-MafB5TmI.js
init_esm5();
init_operators();
var MAX_ITEMS_IN_ERROR_MESSAGE = 5;
var ClientError = class extends Error {
  constructor(res) {
    const props2 = extractErrorProps(res);
    super(props2.message);
    this.statusCode = 400;
    Object.assign(this, props2);
  }
};
var ServerError = class extends Error {
  constructor(res) {
    const props2 = extractErrorProps(res);
    super(props2.message);
    this.statusCode = 500;
    Object.assign(this, props2);
  }
};
function extractErrorProps(res) {
  const body = res.body;
  const props2 = {
    response: res,
    statusCode: res.statusCode,
    responseBody: stringifyBody(body, res),
    message: "",
    details: void 0
  };
  if (body.error && body.message) {
    props2.message = "".concat(body.error, " - ").concat(body.message);
    return props2;
  }
  if (isMutationError(body)) {
    const allItems = body.error.items || [];
    const items = allItems.slice(0, MAX_ITEMS_IN_ERROR_MESSAGE).map((item) => {
      var _a4;
      return (_a4 = item.error) == null ? void 0 : _a4.description;
    }).filter(Boolean);
    let itemsStr = items.length ? ":\n- ".concat(items.join("\n- ")) : "";
    if (allItems.length > MAX_ITEMS_IN_ERROR_MESSAGE) {
      itemsStr += "\n...and ".concat(allItems.length - MAX_ITEMS_IN_ERROR_MESSAGE, " more");
    }
    props2.message = "".concat(body.error.description).concat(itemsStr);
    props2.details = body.error;
    return props2;
  }
  if (body.error && body.error.description) {
    props2.message = body.error.description;
    props2.details = body.error;
    return props2;
  }
  props2.message = body.error || body.message || httpErrorMessage(res);
  return props2;
}
function isMutationError(body) {
  return isPlainObject3(body) && isPlainObject3(body.error) && body.error.type === "mutationError" && typeof body.error.description === "string";
}
function isPlainObject3(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function httpErrorMessage(res) {
  const statusMessage = res.statusMessage ? " ".concat(res.statusMessage) : "";
  return "".concat(res.method, "-request to ").concat(res.url, " resulted in HTTP ").concat(res.statusCode).concat(statusMessage);
}
function stringifyBody(body, res) {
  const contentType = (res.headers["content-type"] || "").toLowerCase();
  const isJson = contentType.indexOf("application/json") !== -1;
  return isJson ? JSON.stringify(body, null, 2) : body;
}
var httpError = {
  onResponse: (res) => {
    if (res.statusCode >= 500) {
      throw new ServerError(res);
    } else if (res.statusCode >= 400) {
      throw new ClientError(res);
    }
    return res;
  }
};
var printWarnings = {
  onResponse: (res) => {
    const warn2 = res.headers["x-sanity-warning"];
    const warnings = Array.isArray(warn2) ? warn2 : [warn2];
    warnings.filter(Boolean).forEach((msg2) => console.warn(msg2));
    return res;
  }
};
function defineHttpRequest(envMiddleware2, _ref) {
  let {
    maxRetries = 5,
    retryDelay
  } = _ref;
  const request = getIt([maxRetries > 0 ? retry({
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    retryDelay,
    // This option is typed incorrectly in get-it.
    maxRetries,
    shouldRetry
  }) : {}, ...envMiddleware2, printWarnings, jsonRequest(), jsonResponse(), progress2(), httpError, observable({
    implementation: Observable
  })]);
  function httpRequest(options) {
    let requester2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : request;
    return requester2({
      maxRedirects: 0,
      ...options
    });
  }
  httpRequest.defaultRequester = request;
  return httpRequest;
}
function shouldRetry(err, attempt, options) {
  const isSafe = options.method === "GET" || options.method === "HEAD";
  const uri = options.uri || options.url;
  const isQuery = uri.startsWith("/data/query");
  const isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);
  if ((isSafe || isQuery) && isRetriableResponse)
    return true;
  return retry.shouldRetry(err, attempt, options);
}
function getSelection(sel) {
  if (typeof sel === "string" || Array.isArray(sel)) {
    return {
      id: sel
    };
  }
  if (typeof sel === "object" && sel !== null && "query" in sel && typeof sel.query === "string") {
    return "params" in sel && typeof sel.params === "object" && sel.params !== null ? {
      query: sel.query,
      params: sel.params
    } : {
      query: sel.query
    };
  }
  const selectionOpts = ["* Document ID (<docId>)", "* Array of document IDs", "* Object containing `query`"].join("\n");
  throw new Error("Unknown selection - must be one of:\n\n".concat(selectionOpts));
}
var VALID_ASSET_TYPES = ["image", "file"];
var VALID_INSERT_LOCATIONS = ["before", "after", "replace"];
var dataset = (name) => {
  if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(name)) {
    throw new Error("Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters");
  }
};
var projectId = (id4) => {
  if (!/^[-a-z0-9]+$/i.test(id4)) {
    throw new Error("`projectId` can only contain only a-z, 0-9 and dashes");
  }
};
var validateAssetType = (type) => {
  if (VALID_ASSET_TYPES.indexOf(type) === -1) {
    throw new Error("Invalid asset type: ".concat(type, ". Must be one of ").concat(VALID_ASSET_TYPES.join(", ")));
  }
};
var validateObject = (op, val) => {
  if (val === null || typeof val !== "object" || Array.isArray(val)) {
    throw new Error("".concat(op, "() takes an object of properties"));
  }
};
var validateDocumentId = (op, id4) => {
  if (typeof id4 !== "string" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id4) || id4.includes("..")) {
    throw new Error("".concat(op, '(): "').concat(id4, '" is not a valid document ID'));
  }
};
var requireDocumentId = (op, doc) => {
  if (!doc._id) {
    throw new Error("".concat(op, '() requires that the document contains an ID ("_id" property)'));
  }
  validateDocumentId(op, doc._id);
};
var validateInsert = (at2, selector, items) => {
  const signature = "insert(at, selector, items)";
  if (VALID_INSERT_LOCATIONS.indexOf(at2) === -1) {
    const valid = VALID_INSERT_LOCATIONS.map((loc) => '"'.concat(loc, '"')).join(", ");
    throw new Error("".concat(signature, ' takes an "at"-argument which is one of: ').concat(valid));
  }
  if (typeof selector !== "string") {
    throw new Error("".concat(signature, ' takes a "selector"-argument which must be a string'));
  }
  if (!Array.isArray(items)) {
    throw new Error("".concat(signature, ' takes an "items"-argument which must be an array'));
  }
};
var hasDataset = (config) => {
  if (!config.dataset) {
    throw new Error("`dataset` must be provided to perform queries");
  }
  return config.dataset || "";
};
var requestTag = (tag) => {
  if (typeof tag !== "string" || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {
    throw new Error("Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.");
  }
  return tag;
};
var __accessCheck$6 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet$6 = (obj, member, getter) => {
  __accessCheck$6(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$6 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$6 = (obj, member, value, setter) => {
  __accessCheck$6(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _client$5;
var _client2$5;
var BasePatch = class {
  constructor(selection) {
    let operations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.selection = selection;
    this.operations = operations;
  }
  /**
   * Sets the given attributes to the document. Does NOT merge objects.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \{"nested.prop": "value"\}
   */
  set(attrs) {
    return this._assign("set", attrs);
  }
  /**
   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \{"nested.prop": "value"\}
   */
  setIfMissing(attrs) {
    return this._assign("setIfMissing", attrs);
  }
  /**
   * Performs a "diff-match-patch" operation on the string attributes provided.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \{"nested.prop": "dmp"\}
   */
  diffMatchPatch(attrs) {
    validateObject("diffMatchPatch", attrs);
    return this._assign("diffMatchPatch", attrs);
  }
  /**
   * Unsets the attribute paths provided.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attribute paths to unset.
   */
  unset(attrs) {
    if (!Array.isArray(attrs)) {
      throw new Error("unset(attrs) takes an array of attributes to unset, non-array given");
    }
    this.operations = Object.assign({}, this.operations, {
      unset: attrs
    });
    return this;
  }
  /**
   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.
   *
   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.
   */
  inc(attrs) {
    return this._assign("inc", attrs);
  }
  /**
   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.
   *
   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.
   */
  dec(attrs) {
    return this._assign("dec", attrs);
  }
  /**
   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.
   *
   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path
   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key=="abc123"]`
   * @param items - Array of items to insert/replace
   */
  insert(at2, selector, items) {
    validateInsert(at2, selector, items);
    return this._assign("insert", {
      [at2]: selector,
      items
    });
  }
  /**
   * Append the given items to the array at the given JSONPath
   *
   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`
   * @param items - Array of items to append to the array
   */
  append(selector, items) {
    return this.insert("after", "".concat(selector, "[-1]"), items);
  }
  /**
   * Prepend the given items to the array at the given JSONPath
   *
   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`
   * @param items - Array of items to prepend to the array
   */
  prepend(selector, items) {
    return this.insert("before", "".concat(selector, "[0]"), items);
  }
  /**
   * Change the contents of an array by removing existing elements and/or adding new elements.
   *
   * @param selector - Attribute or JSONPath expression for array
   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x
   * @param deleteCount - An integer indicating the number of old array elements to remove.
   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.
   */
  splice(selector, start, deleteCount, items) {
    const delAll = typeof deleteCount === "undefined" || deleteCount === -1;
    const startIndex = start < 0 ? start - 1 : start;
    const delCount = delAll ? -1 : Math.max(0, start + deleteCount);
    const delRange = startIndex < 0 && delCount >= 0 ? "" : delCount;
    const rangeSelector = "".concat(selector, "[").concat(startIndex, ":").concat(delRange, "]");
    return this.insert("replace", rangeSelector, items || []);
  }
  /**
   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value
   *
   * @param rev - Revision to lock the patch to
   */
  ifRevisionId(rev) {
    this.operations.ifRevisionID = rev;
    return this;
  }
  /**
   * Return a plain JSON representation of the patch
   */
  serialize() {
    return {
      ...getSelection(this.selection),
      ...this.operations
    };
  }
  /**
   * Return a plain JSON representation of the patch
   */
  toJSON() {
    return this.serialize();
  }
  /**
   * Clears the patch of all operations
   */
  reset() {
    this.operations = {};
    return this;
  }
  _assign(op, props2) {
    let merge2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    validateObject(op, props2);
    this.operations = Object.assign({}, this.operations, {
      [op]: Object.assign({}, merge2 && this.operations[op] || {}, props2)
    });
    return this;
  }
  _set(op, props2) {
    return this._assign(op, props2, false);
  }
};
var _ObservablePatch = class _ObservablePatch2 extends BasePatch {
  constructor(selection, operations, client) {
    super(selection, operations);
    __privateAdd$6(this, _client$5, void 0);
    __privateSet$6(this, _client$5, client);
  }
  /**
   * Clones the patch
   */
  clone() {
    return new _ObservablePatch2(this.selection, {
      ...this.operations
    }, __privateGet$6(this, _client$5));
  }
  commit(options) {
    if (!__privateGet$6(this, _client$5)) {
      throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method");
    }
    const returnFirst = typeof this.selection === "string";
    const opts = Object.assign({
      returnFirst,
      returnDocuments: true
    }, options);
    return __privateGet$6(this, _client$5).mutate({
      patch: this.serialize()
    }, opts);
  }
};
_client$5 = /* @__PURE__ */ new WeakMap();
var ObservablePatch = _ObservablePatch;
var _Patch = class _Patch2 extends BasePatch {
  constructor(selection, operations, client) {
    super(selection, operations);
    __privateAdd$6(this, _client2$5, void 0);
    __privateSet$6(this, _client2$5, client);
  }
  /**
   * Clones the patch
   */
  clone() {
    return new _Patch2(this.selection, {
      ...this.operations
    }, __privateGet$6(this, _client2$5));
  }
  commit(options) {
    if (!__privateGet$6(this, _client2$5)) {
      throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method");
    }
    const returnFirst = typeof this.selection === "string";
    const opts = Object.assign({
      returnFirst,
      returnDocuments: true
    }, options);
    return __privateGet$6(this, _client2$5).mutate({
      patch: this.serialize()
    }, opts);
  }
};
_client2$5 = /* @__PURE__ */ new WeakMap();
var Patch = _Patch;
var __accessCheck$5 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet$5 = (obj, member, getter) => {
  __accessCheck$5(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$5 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$5 = (obj, member, value, setter) => {
  __accessCheck$5(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _client$4;
var _client2$4;
var defaultMutateOptions = {
  returnDocuments: false
};
var BaseTransaction = class {
  constructor() {
    let operations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let transactionId = arguments.length > 1 ? arguments[1] : void 0;
    this.operations = operations;
    this.trxId = transactionId;
  }
  /**
   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc - Document to create. Requires a `_type` property.
   */
  create(doc) {
    validateObject("create", doc);
    return this._add({
      create: doc
    });
  }
  /**
   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.
   */
  createIfNotExists(doc) {
    const op = "createIfNotExists";
    validateObject(op, doc);
    requireDocumentId(op, doc);
    return this._add({
      [op]: doc
    });
  }
  /**
   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.
   */
  createOrReplace(doc) {
    const op = "createOrReplace";
    validateObject(op, doc);
    requireDocumentId(op, doc);
    return this._add({
      [op]: doc
    });
  }
  /**
   * Deletes the document with the given document ID
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param documentId - Document ID to delete
   */
  delete(documentId) {
    validateDocumentId("delete", documentId);
    return this._add({
      delete: {
        id: documentId
      }
    });
  }
  transactionId(id4) {
    if (!id4) {
      return this.trxId;
    }
    this.trxId = id4;
    return this;
  }
  /**
   * Return a plain JSON representation of the transaction
   */
  serialize() {
    return [...this.operations];
  }
  /**
   * Return a plain JSON representation of the transaction
   */
  toJSON() {
    return this.serialize();
  }
  /**
   * Clears the transaction of all operations
   */
  reset() {
    this.operations = [];
    return this;
  }
  _add(mut) {
    this.operations.push(mut);
    return this;
  }
};
var _Transaction = class _Transaction2 extends BaseTransaction {
  constructor(operations, client, transactionId) {
    super(operations, transactionId);
    __privateAdd$5(this, _client$4, void 0);
    __privateSet$5(this, _client$4, client);
  }
  /**
   * Clones the transaction
   */
  clone() {
    return new _Transaction2([...this.operations], __privateGet$5(this, _client$4), this.trxId);
  }
  commit(options) {
    if (!__privateGet$5(this, _client$4)) {
      throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method");
    }
    return __privateGet$5(this, _client$4).mutate(this.serialize(), Object.assign({
      transactionId: this.trxId
    }, defaultMutateOptions, options || {}));
  }
  patch(patchOrDocumentId, patchOps) {
    const isBuilder2 = typeof patchOps === "function";
    const isPatch = typeof patchOrDocumentId !== "string" && patchOrDocumentId instanceof Patch;
    if (isPatch) {
      return this._add({
        patch: patchOrDocumentId.serialize()
      });
    }
    if (isBuilder2) {
      const patch2 = patchOps(new Patch(patchOrDocumentId, {}, __privateGet$5(this, _client$4)));
      if (!(patch2 instanceof Patch)) {
        throw new Error("function passed to `patch()` must return the patch");
      }
      return this._add({
        patch: patch2.serialize()
      });
    }
    return this._add({
      patch: {
        id: patchOrDocumentId,
        ...patchOps
      }
    });
  }
};
_client$4 = /* @__PURE__ */ new WeakMap();
var Transaction = _Transaction;
var _ObservableTransaction = class _ObservableTransaction2 extends BaseTransaction {
  constructor(operations, client, transactionId) {
    super(operations, transactionId);
    __privateAdd$5(this, _client2$4, void 0);
    __privateSet$5(this, _client2$4, client);
  }
  /**
   * Clones the transaction
   */
  clone() {
    return new _ObservableTransaction2([...this.operations], __privateGet$5(this, _client2$4), this.trxId);
  }
  commit(options) {
    if (!__privateGet$5(this, _client2$4)) {
      throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method");
    }
    return __privateGet$5(this, _client2$4).mutate(this.serialize(), Object.assign({
      transactionId: this.trxId
    }, defaultMutateOptions, options || {}));
  }
  patch(patchOrDocumentId, patchOps) {
    const isBuilder2 = typeof patchOps === "function";
    const isPatch = typeof patchOrDocumentId !== "string" && patchOrDocumentId instanceof ObservablePatch;
    if (isPatch) {
      return this._add({
        patch: patchOrDocumentId.serialize()
      });
    }
    if (isBuilder2) {
      const patch2 = patchOps(new ObservablePatch(patchOrDocumentId, {}, __privateGet$5(this, _client2$4)));
      if (!(patch2 instanceof ObservablePatch)) {
        throw new Error("function passed to `patch()` must return the patch");
      }
      return this._add({
        patch: patch2.serialize()
      });
    }
    return this._add({
      patch: {
        id: patchOrDocumentId,
        ...patchOps
      }
    });
  }
};
_client2$4 = /* @__PURE__ */ new WeakMap();
var ObservableTransaction = _ObservableTransaction;
var BASE_URL = "https://www.sanity.io/help/";
function generateHelpUrl(slug3) {
  return BASE_URL + slug3;
}
function once(fn) {
  let didCall = false;
  let returnValue;
  return function() {
    if (didCall) {
      return returnValue;
    }
    returnValue = fn(...arguments);
    didCall = true;
    return returnValue;
  };
}
var createWarningPrinter = (message) => (
  // eslint-disable-next-line no-console
  once(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return console.warn(message.join(" "), ...args);
  })
);
var printCdnWarning = createWarningPrinter(["Since you haven't set a value for `useCdn`, we will deliver content using our", "global, edge-cached API-CDN. If you wish to have content delivered faster, set", "`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API."]);
var printCdnPreviewDraftsWarning = createWarningPrinter(["The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.", "The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning."]);
var printBrowserTokenWarning = createWarningPrinter(["You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.", "See ".concat(generateHelpUrl("js-client-browser-token"), " for more information and how to hide this warning.")]);
var printNoApiVersionSpecifiedWarning = createWarningPrinter(["Using the Sanity client without specifying an API version is deprecated.", "See ".concat(generateHelpUrl("js-client-api-version"))]);
var printNoDefaultExport = createWarningPrinter(["The default export of @sanity/client has been deprecated. Use the named export `createClient` instead."]);
var defaultCdnHost = "apicdn.sanity.io";
var defaultConfig = {
  apiHost: "https://api.sanity.io",
  apiVersion: "1",
  useProjectHostname: true
};
var LOCALHOSTS = ["localhost", "127.0.0.1", "0.0.0.0"];
var isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;
var validateApiVersion = function validateApiVersion2(apiVersion) {
  if (apiVersion === "1" || apiVersion === "X") {
    return;
  }
  const apiDate = new Date(apiVersion);
  const apiVersionValid = /^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;
  if (!apiVersionValid) {
    throw new Error("Invalid API version string, expected `1` or date in format `YYYY-MM-DD`");
  }
};
var validateApiPerspective = function validateApiPerspective2(perspective) {
  switch (perspective) {
    case "previewDrafts":
    case "published":
    case "raw":
      return;
    default:
      throw new TypeError("Invalid API perspective string, expected `published`, `previewDrafts` or `raw`");
  }
};
var initConfig = (config, prevConfig) => {
  const specifiedConfig = Object.assign({}, prevConfig, config);
  if (!specifiedConfig.apiVersion) {
    printNoApiVersionSpecifiedWarning();
  }
  const newConfig = Object.assign({}, defaultConfig, specifiedConfig);
  const projectBased = newConfig.useProjectHostname;
  if (typeof Promise === "undefined") {
    const helpUrl = generateHelpUrl("js-client-promise-polyfill");
    throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(helpUrl));
  }
  if (projectBased && !newConfig.projectId) {
    throw new Error("Configuration must contain `projectId`");
  }
  if (typeof newConfig.perspective === "string") {
    validateApiPerspective(newConfig.perspective);
  }
  if ("encodeSourceMapAtPath" in newConfig || "encodeSourceMap" in newConfig || "studioUrl" in newConfig || "logger" in newConfig) {
    throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client', such as 'encodeSourceMapAtPath', 'encodeSourceMap', 'studioUrl' and 'logger'. Make sure you're using the right import.");
  }
  if ("stega" in newConfig && newConfig["stega"] !== void 0 && newConfig["stega"] !== false) {
    throw new Error("It looks like you're using options meant for '@sanity/client/stega'. Make sure you're using the right import. Or set 'stega' in 'createClient' to 'false'.");
  }
  const isBrowser2 = typeof window !== "undefined" && window.location && window.location.hostname;
  const isLocalhost = isBrowser2 && isLocal(window.location.hostname);
  if (isBrowser2 && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
    printBrowserTokenWarning();
  } else if (typeof newConfig.useCdn === "undefined") {
    printCdnWarning();
  }
  if (projectBased) {
    projectId(newConfig.projectId);
  }
  if (newConfig.dataset) {
    dataset(newConfig.dataset);
  }
  if ("requestTagPrefix" in newConfig) {
    newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\.+$/, "") : void 0;
  }
  newConfig.apiVersion = "".concat(newConfig.apiVersion).replace(/^v/, "");
  newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
  newConfig.useCdn = newConfig.useCdn !== false && !newConfig.withCredentials;
  validateApiVersion(newConfig.apiVersion);
  const hostParts = newConfig.apiHost.split("://", 2);
  const protocol = hostParts[0];
  const host = hostParts[1];
  const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;
  if (newConfig.useProjectHostname) {
    newConfig.url = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(host, "/v").concat(newConfig.apiVersion);
    newConfig.cdnUrl = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(cdnHost, "/v").concat(newConfig.apiVersion);
  } else {
    newConfig.url = "".concat(newConfig.apiHost, "/v").concat(newConfig.apiVersion);
    newConfig.cdnUrl = newConfig.url;
  }
  return newConfig;
};
var projectHeader = "X-Sanity-Project-ID";
function requestOptions(config) {
  let overrides = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const headers = {};
  const token = overrides.token || config.token;
  if (token) {
    headers.Authorization = "Bearer ".concat(token);
  }
  if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
    headers[projectHeader] = config.projectId;
  }
  const withCredentials = Boolean(typeof overrides.withCredentials === "undefined" ? config.token || config.withCredentials : overrides.withCredentials);
  const timeout = typeof overrides.timeout === "undefined" ? config.timeout : overrides.timeout;
  return Object.assign({}, overrides, {
    headers: Object.assign({}, headers, overrides.headers || {}),
    timeout: typeof timeout === "undefined" ? 5 * 60 * 1e3 : timeout,
    proxy: overrides.proxy || config.proxy,
    json: true,
    withCredentials,
    fetch: typeof overrides.fetch === "object" && typeof config.fetch === "object" ? {
      ...config.fetch,
      ...overrides.fetch
    } : overrides.fetch || config.fetch
  });
}
var encodeQueryString = (_ref2) => {
  let {
    query,
    params = {},
    options = {}
  } = _ref2;
  const searchParams = new URLSearchParams();
  const {
    tag,
    ...opts
  } = options;
  if (tag)
    searchParams.append("tag", tag);
  searchParams.append("query", query);
  for (const [key2, value] of Object.entries(params)) {
    searchParams.append("$".concat(key2), JSON.stringify(value));
  }
  for (const [key2, value] of Object.entries(opts)) {
    if (value)
      searchParams.append(key2, "".concat(value));
  }
  return "?".concat(searchParams);
};
var excludeFalsey = (param, defValue) => {
  const value = typeof param === "undefined" ? defValue : param;
  return param === false ? void 0 : value;
};
var getMutationQuery = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    dryRun: options.dryRun,
    returnIds: true,
    returnDocuments: excludeFalsey(options.returnDocuments, true),
    visibility: options.visibility || "sync",
    autoGenerateArrayKeys: options.autoGenerateArrayKeys,
    skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation
  };
};
var isResponse = (event) => event.type === "response";
var getBody = (event) => event.body;
var indexBy = (docs, attr) => docs.reduce((indexed, doc) => {
  indexed[attr(doc)] = doc;
  return indexed;
}, /* @__PURE__ */ Object.create(null));
var getQuerySizeLimit = 11264;
function _fetch(client, httpRequest, query, params) {
  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const mapResponse = options.filterResponse === false ? (res) => res : (res) => res.result;
  const {
    cache: cache2,
    next,
    ...opts
  } = {
    // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.
    // This is necessary in React Server Components to avoid opting out of Request Memoization.
    useAbortSignal: typeof options.signal !== "undefined",
    ...options
  };
  const reqOpts = typeof cache2 !== "undefined" || typeof next !== "undefined" ? {
    ...opts,
    fetch: {
      cache: cache2,
      next
    }
  } : opts;
  return _dataRequest(client, httpRequest, "query", {
    query,
    params
  }, reqOpts).pipe(map(mapResponse));
}
function _getDocument(client, httpRequest, id4) {
  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const options = {
    uri: _getDataUrl(client, "doc", id4),
    json: true,
    tag: opts.tag
  };
  return _requestObservable(client, httpRequest, options).pipe(filter(isResponse), map((event) => event.body.documents && event.body.documents[0]));
}
function _getDocuments(client, httpRequest, ids) {
  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const options = {
    uri: _getDataUrl(client, "doc", ids.join(",")),
    json: true,
    tag: opts.tag
  };
  return _requestObservable(client, httpRequest, options).pipe(filter(isResponse), map((event) => {
    const indexed = indexBy(event.body.documents || [], (doc) => doc._id);
    return ids.map((id4) => indexed[id4] || null);
  }));
}
function _createIfNotExists(client, httpRequest, doc, options) {
  requireDocumentId("createIfNotExists", doc);
  return _create(client, httpRequest, doc, "createIfNotExists", options);
}
function _createOrReplace(client, httpRequest, doc, options) {
  requireDocumentId("createOrReplace", doc);
  return _create(client, httpRequest, doc, "createOrReplace", options);
}
function _delete(client, httpRequest, selection, options) {
  return _dataRequest(client, httpRequest, "mutate", {
    mutations: [{
      delete: getSelection(selection)
    }]
  }, options);
}
function _mutate(client, httpRequest, mutations, options) {
  let mut;
  if (mutations instanceof Patch || mutations instanceof ObservablePatch) {
    mut = {
      patch: mutations.serialize()
    };
  } else if (mutations instanceof Transaction || mutations instanceof ObservableTransaction) {
    mut = mutations.serialize();
  } else {
    mut = mutations;
  }
  const muts = Array.isArray(mut) ? mut : [mut];
  const transactionId = options && options.transactionId || void 0;
  return _dataRequest(client, httpRequest, "mutate", {
    mutations: muts,
    transactionId
  }, options);
}
function _dataRequest(client, httpRequest, endpoint, body) {
  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const isMutation = endpoint === "mutate";
  const isQuery = endpoint === "query";
  const strQuery = isMutation ? "" : encodeQueryString(body);
  const useGet = !isMutation && strQuery.length < getQuerySizeLimit;
  const stringQuery = useGet ? strQuery : "";
  const returnFirst = options.returnFirst;
  const {
    timeout,
    token,
    tag,
    headers
  } = options;
  const uri = _getDataUrl(client, endpoint, stringQuery);
  const reqOptions = {
    method: useGet ? "GET" : "POST",
    uri,
    json: true,
    body: useGet ? void 0 : body,
    query: isMutation && getMutationQuery(options),
    timeout,
    headers,
    token,
    tag,
    perspective: options.perspective,
    resultSourceMap: options.resultSourceMap,
    canUseCdn: isQuery,
    signal: options.signal,
    fetch: options.fetch,
    useAbortSignal: options.useAbortSignal
  };
  return _requestObservable(client, httpRequest, reqOptions).pipe(filter(isResponse), map(getBody), map((res) => {
    if (!isMutation) {
      return res;
    }
    const results = res.results || [];
    if (options.returnDocuments) {
      return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);
    }
    const key2 = returnFirst ? "documentId" : "documentIds";
    const ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);
    return {
      transactionId: res.transactionId,
      results,
      [key2]: ids
    };
  }));
}
function _create(client, httpRequest, doc, op) {
  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const mutation = {
    [op]: doc
  };
  const opts = Object.assign({
    returnFirst: true,
    returnDocuments: true
  }, options);
  return _dataRequest(client, httpRequest, "mutate", {
    mutations: [mutation]
  }, opts);
}
function _requestObservable(client, httpRequest, options) {
  var _a4;
  const uri = options.url || options.uri;
  const config = client.config();
  const canUseCdn = typeof options.canUseCdn === "undefined" ? ["GET", "HEAD"].indexOf(options.method || "GET") >= 0 && uri.indexOf("/data/") === 0 : options.canUseCdn;
  let useCdn = config.useCdn && canUseCdn;
  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(".") : options.tag || config.requestTagPrefix;
  if (tag && options.tag !== null) {
    options.query = {
      tag: requestTag(tag),
      ...options.query
    };
  }
  if (["GET", "HEAD", "POST"].indexOf(options.method || "GET") >= 0 && uri.indexOf("/data/query/") === 0) {
    const resultSourceMap = (_a4 = options.resultSourceMap) != null ? _a4 : config.resultSourceMap;
    if (resultSourceMap !== void 0 && resultSourceMap !== false) {
      options.query = {
        resultSourceMap,
        ...options.query
      };
    }
    const perspective = options.perspective || config.perspective;
    if (typeof perspective === "string" && perspective !== "raw") {
      validateApiPerspective(perspective);
      options.query = {
        perspective,
        ...options.query
      };
      if (perspective === "previewDrafts" && useCdn) {
        useCdn = false;
        printCdnPreviewDraftsWarning();
      }
    }
  }
  const reqOptions = requestOptions(config, Object.assign({}, options, {
    url: _getUrl(client, uri, useCdn)
  }));
  const request = new Observable((subscriber) => httpRequest(reqOptions, config.requester).subscribe(subscriber));
  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;
}
function _request(client, httpRequest, options) {
  const observable2 = _requestObservable(client, httpRequest, options).pipe(filter((event) => event.type === "response"), map((event) => event.body));
  return observable2;
}
function _getDataUrl(client, operation, path2) {
  const config = client.config();
  const catalog = hasDataset(config);
  const baseUri = "/".concat(operation, "/").concat(catalog);
  const uri = path2 ? "".concat(baseUri, "/").concat(path2) : baseUri;
  return "/data".concat(uri).replace(/\/($|\?)/, "$1");
}
function _getUrl(client, uri) {
  let canUseCdn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const {
    url,
    cdnUrl
  } = client.config();
  const base = canUseCdn ? cdnUrl : url;
  return "".concat(base, "/").concat(uri.replace(/^\//, ""));
}
function _withAbortSignal(signal) {
  return (input) => {
    return new Observable((observer) => {
      const abort = () => observer.error(_createAbortError(signal));
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const subscription = input.subscribe(observer);
      signal.addEventListener("abort", abort);
      return () => {
        signal.removeEventListener("abort", abort);
        subscription.unsubscribe();
      };
    });
  };
}
var isDomExceptionSupported = Boolean(globalThis.DOMException);
function _createAbortError(signal) {
  var _a4, _b4;
  if (isDomExceptionSupported) {
    return new DOMException((_a4 = signal == null ? void 0 : signal.reason) != null ? _a4 : "The operation was aborted.", "AbortError");
  }
  const error2 = new Error((_b4 = signal == null ? void 0 : signal.reason) != null ? _b4 : "The operation was aborted.");
  error2.name = "AbortError";
  return error2;
}
var __accessCheck$4 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _client$3;
var _httpRequest$4;
var _client2$3;
var _httpRequest2$4;
var ObservableAssetsClient = class {
  constructor(client, httpRequest) {
    __privateAdd$4(this, _client$3, void 0);
    __privateAdd$4(this, _httpRequest$4, void 0);
    __privateSet$4(this, _client$3, client);
    __privateSet$4(this, _httpRequest$4, httpRequest);
  }
  upload(assetType, body, options) {
    return _upload(__privateGet$4(this, _client$3), __privateGet$4(this, _httpRequest$4), assetType, body, options);
  }
};
_client$3 = /* @__PURE__ */ new WeakMap();
_httpRequest$4 = /* @__PURE__ */ new WeakMap();
var AssetsClient = class {
  constructor(client, httpRequest) {
    __privateAdd$4(this, _client2$3, void 0);
    __privateAdd$4(this, _httpRequest2$4, void 0);
    __privateSet$4(this, _client2$3, client);
    __privateSet$4(this, _httpRequest2$4, httpRequest);
  }
  upload(assetType, body, options) {
    const observable2 = _upload(__privateGet$4(this, _client2$3), __privateGet$4(this, _httpRequest2$4), assetType, body, options);
    return lastValueFrom(observable2.pipe(filter((event) => event.type === "response"), map((event) => event.body.document)));
  }
};
_client2$3 = /* @__PURE__ */ new WeakMap();
_httpRequest2$4 = /* @__PURE__ */ new WeakMap();
function _upload(client, httpRequest, assetType, body) {
  let opts = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  validateAssetType(assetType);
  let meta = opts.extract || void 0;
  if (meta && !meta.length) {
    meta = ["none"];
  }
  const dataset2 = hasDataset(client.config());
  const assetEndpoint = assetType === "image" ? "images" : "files";
  const options = optionsFromFile(opts, body);
  const {
    tag,
    label,
    title,
    description,
    creditLine,
    filename,
    source
  } = options;
  const query = {
    label,
    title,
    description,
    filename,
    meta,
    creditLine
  };
  if (source) {
    query.sourceId = source.id;
    query.sourceName = source.name;
    query.sourceUrl = source.url;
  }
  return _requestObservable(client, httpRequest, {
    tag,
    method: "POST",
    timeout: options.timeout || 0,
    uri: "/assets/".concat(assetEndpoint, "/").concat(dataset2),
    headers: options.contentType ? {
      "Content-Type": options.contentType
    } : {},
    query,
    body
  });
}
function optionsFromFile(opts, file2) {
  if (typeof File === "undefined" || !(file2 instanceof File)) {
    return opts;
  }
  return Object.assign({
    filename: opts.preserveFilename === false ? void 0 : file2.name,
    contentType: file2.type
  }, opts);
}
var defaults = (obj, defaults3) => Object.keys(defaults3).concat(Object.keys(obj)).reduce((target, prop) => {
  target[prop] = typeof obj[prop] === "undefined" ? defaults3[prop] : obj[prop];
  return target;
}, {});
var pick2 = (obj, props2) => props2.reduce((selection, prop) => {
  if (typeof obj[prop] === "undefined") {
    return selection;
  }
  selection[prop] = obj[prop];
  return selection;
}, {});
var MAX_URL_LENGTH = 16e3 - 1200;
var possibleOptions = ["includePreviousRevision", "includeResult", "visibility", "effectFormat", "tag"];
var defaultOptions2 = {
  includeResult: true
};
function _listen(query, params) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    url,
    token,
    withCredentials,
    requestTagPrefix
  } = this.config();
  const tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(".") : opts.tag;
  const options = {
    ...defaults(opts, defaultOptions2),
    tag
  };
  const listenOpts = pick2(options, possibleOptions);
  const qs = encodeQueryString({
    query,
    params,
    options: {
      tag,
      ...listenOpts
    }
  });
  const uri = "".concat(url).concat(_getDataUrl(this, "listen", qs));
  if (uri.length > MAX_URL_LENGTH) {
    return new Observable((observer) => observer.error(new Error("Query too large for listener")));
  }
  const listenFor = options.events ? options.events : ["mutation"];
  const shouldEmitReconnect = listenFor.indexOf("reconnect") !== -1;
  const esOptions = {};
  if (token || withCredentials) {
    esOptions.withCredentials = true;
  }
  if (token) {
    esOptions.headers = {
      Authorization: "Bearer ".concat(token)
    };
  }
  return new Observable((observer) => {
    let es;
    getEventSource().then((eventSource) => {
      es = eventSource;
    }).catch((reason) => {
      observer.error(reason);
      stop();
    });
    let reconnectTimer;
    let stopped = false;
    function onError() {
      if (stopped) {
        return;
      }
      emitReconnect();
      if (stopped) {
        return;
      }
      if (es.readyState === es.CLOSED) {
        unsubscribe();
        clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(open, 100);
      }
    }
    function onChannelError(err) {
      observer.error(cooerceError(err));
    }
    function onMessage(evt) {
      const event = parseEvent(evt);
      return event instanceof Error ? observer.error(event) : observer.next(event);
    }
    function onDisconnect() {
      stopped = true;
      unsubscribe();
      observer.complete();
    }
    function unsubscribe() {
      if (!es)
        return;
      es.removeEventListener("error", onError);
      es.removeEventListener("channelError", onChannelError);
      es.removeEventListener("disconnect", onDisconnect);
      listenFor.forEach((type) => es.removeEventListener(type, onMessage));
      es.close();
    }
    function emitReconnect() {
      if (shouldEmitReconnect) {
        observer.next({
          type: "reconnect"
        });
      }
    }
    async function getEventSource() {
      const {
        default: EventSource
      } = await import("./browser-N7NE4VPU.js");
      const evs = new EventSource(uri, esOptions);
      evs.addEventListener("error", onError);
      evs.addEventListener("channelError", onChannelError);
      evs.addEventListener("disconnect", onDisconnect);
      listenFor.forEach((type) => evs.addEventListener(type, onMessage));
      return evs;
    }
    function open() {
      getEventSource().then((eventSource) => {
        es = eventSource;
      }).catch((reason) => {
        observer.error(reason);
        stop();
      });
    }
    function stop() {
      stopped = true;
      unsubscribe();
    }
    return stop;
  });
}
function parseEvent(event) {
  try {
    const data = event.data && JSON.parse(event.data) || {};
    return Object.assign({
      type: event.type
    }, data);
  } catch (err) {
    return err;
  }
}
function cooerceError(err) {
  if (err instanceof Error) {
    return err;
  }
  const evt = parseEvent(err);
  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
}
function extractErrorMessage(err) {
  if (!err.error) {
    return err.message || "Unknown listener error";
  }
  if (err.error.description) {
    return err.error.description;
  }
  return typeof err.error === "string" ? err.error : JSON.stringify(err.error, null, 2);
}
var __accessCheck$3 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _client$2;
var _httpRequest$3;
var _client2$2;
var _httpRequest2$3;
var ObservableDatasetsClient = class {
  constructor(client, httpRequest) {
    __privateAdd$3(this, _client$2, void 0);
    __privateAdd$3(this, _httpRequest$3, void 0);
    __privateSet$3(this, _client$2, client);
    __privateSet$3(this, _httpRequest$3, httpRequest);
  }
  /**
   * Create a new dataset with the given name
   *
   * @param name - Name of the dataset to create
   * @param options - Options for the dataset
   */
  create(name, options) {
    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), "PUT", name, options);
  }
  /**
   * Edit a dataset with the given name
   *
   * @param name - Name of the dataset to edit
   * @param options - New options for the dataset
   */
  edit(name, options) {
    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), "PATCH", name, options);
  }
  /**
   * Delete a dataset with the given name
   *
   * @param name - Name of the dataset to delete
   */
  delete(name) {
    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), "DELETE", name);
  }
  /**
   * Fetch a list of datasets for the configured project
   */
  list() {
    return _request(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), {
      uri: "/datasets",
      tag: null
    });
  }
};
_client$2 = /* @__PURE__ */ new WeakMap();
_httpRequest$3 = /* @__PURE__ */ new WeakMap();
var DatasetsClient = class {
  constructor(client, httpRequest) {
    __privateAdd$3(this, _client2$2, void 0);
    __privateAdd$3(this, _httpRequest2$3, void 0);
    __privateSet$3(this, _client2$2, client);
    __privateSet$3(this, _httpRequest2$3, httpRequest);
  }
  /**
   * Create a new dataset with the given name
   *
   * @param name - Name of the dataset to create
   * @param options - Options for the dataset
   */
  create(name, options) {
    return lastValueFrom(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), "PUT", name, options));
  }
  /**
   * Edit a dataset with the given name
   *
   * @param name - Name of the dataset to edit
   * @param options - New options for the dataset
   */
  edit(name, options) {
    return lastValueFrom(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), "PATCH", name, options));
  }
  /**
   * Delete a dataset with the given name
   *
   * @param name - Name of the dataset to delete
   */
  delete(name) {
    return lastValueFrom(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), "DELETE", name));
  }
  /**
   * Fetch a list of datasets for the configured project
   */
  list() {
    return lastValueFrom(_request(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), {
      uri: "/datasets",
      tag: null
    }));
  }
};
_client2$2 = /* @__PURE__ */ new WeakMap();
_httpRequest2$3 = /* @__PURE__ */ new WeakMap();
function _modify(client, httpRequest, method, name, options) {
  dataset(name);
  return _request(client, httpRequest, {
    method,
    uri: "/datasets/".concat(name),
    body: options,
    tag: null
  });
}
var __accessCheck$2 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _client$1;
var _httpRequest$2;
var _client2$1;
var _httpRequest2$2;
var ObservableProjectsClient = class {
  constructor(client, httpRequest) {
    __privateAdd$2(this, _client$1, void 0);
    __privateAdd$2(this, _httpRequest$2, void 0);
    __privateSet$2(this, _client$1, client);
    __privateSet$2(this, _httpRequest$2, httpRequest);
  }
  list(options) {
    const uri = (options == null ? void 0 : options.includeMembers) === false ? "/projects?includeMembers=false" : "/projects";
    return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), {
      uri
    });
  }
  /**
   * Fetch a project by project ID
   *
   * @param projectId - ID of the project to fetch
   */
  getById(projectId2) {
    return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), {
      uri: "/projects/".concat(projectId2)
    });
  }
};
_client$1 = /* @__PURE__ */ new WeakMap();
_httpRequest$2 = /* @__PURE__ */ new WeakMap();
var ProjectsClient = class {
  constructor(client, httpRequest) {
    __privateAdd$2(this, _client2$1, void 0);
    __privateAdd$2(this, _httpRequest2$2, void 0);
    __privateSet$2(this, _client2$1, client);
    __privateSet$2(this, _httpRequest2$2, httpRequest);
  }
  list(options) {
    const uri = (options == null ? void 0 : options.includeMembers) === false ? "/projects?includeMembers=false" : "/projects";
    return lastValueFrom(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), {
      uri
    }));
  }
  /**
   * Fetch a project by project ID
   *
   * @param projectId - ID of the project to fetch
   */
  getById(projectId2) {
    return lastValueFrom(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), {
      uri: "/projects/".concat(projectId2)
    }));
  }
};
_client2$1 = /* @__PURE__ */ new WeakMap();
_httpRequest2$2 = /* @__PURE__ */ new WeakMap();
var __accessCheck$1 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _client;
var _httpRequest$1;
var _client2;
var _httpRequest2$1;
var ObservableUsersClient = class {
  constructor(client, httpRequest) {
    __privateAdd$1(this, _client, void 0);
    __privateAdd$1(this, _httpRequest$1, void 0);
    __privateSet$1(this, _client, client);
    __privateSet$1(this, _httpRequest$1, httpRequest);
  }
  /**
   * Fetch a user by user ID
   *
   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.
   */
  getById(id4) {
    return _request(__privateGet$1(this, _client), __privateGet$1(this, _httpRequest$1), {
      uri: "/users/".concat(id4)
    });
  }
};
_client = /* @__PURE__ */ new WeakMap();
_httpRequest$1 = /* @__PURE__ */ new WeakMap();
var UsersClient = class {
  constructor(client, httpRequest) {
    __privateAdd$1(this, _client2, void 0);
    __privateAdd$1(this, _httpRequest2$1, void 0);
    __privateSet$1(this, _client2, client);
    __privateSet$1(this, _httpRequest2$1, httpRequest);
  }
  /**
   * Fetch a user by user ID
   *
   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.
   */
  getById(id4) {
    return lastValueFrom(_request(__privateGet$1(this, _client2), __privateGet$1(this, _httpRequest2$1), {
      uri: "/users/".concat(id4)
    }));
  }
};
_client2 = /* @__PURE__ */ new WeakMap();
_httpRequest2$1 = /* @__PURE__ */ new WeakMap();
var __accessCheck2 = (obj, member, msg2) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg2);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _clientConfig;
var _httpRequest;
var _clientConfig2;
var _httpRequest2;
var _ObservableSanityClient = class _ObservableSanityClient2 {
  constructor(httpRequest) {
    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultConfig;
    __privateAdd2(this, _clientConfig, void 0);
    __privateAdd2(this, _httpRequest, void 0);
    this.listen = _listen;
    this.config(config);
    __privateSet2(this, _httpRequest, httpRequest);
    this.assets = new ObservableAssetsClient(this, __privateGet2(this, _httpRequest));
    this.datasets = new ObservableDatasetsClient(this, __privateGet2(this, _httpRequest));
    this.projects = new ObservableProjectsClient(this, __privateGet2(this, _httpRequest));
    this.users = new ObservableUsersClient(this, __privateGet2(this, _httpRequest));
  }
  /**
   * Clone the client - returns a new instance
   */
  clone() {
    return new _ObservableSanityClient2(__privateGet2(this, _httpRequest), this.config());
  }
  config(newConfig) {
    if (newConfig === void 0) {
      return {
        ...__privateGet2(this, _clientConfig)
      };
    }
    if (__privateGet2(this, _clientConfig) && __privateGet2(this, _clientConfig).allowReconfigure === false) {
      throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client");
    }
    __privateSet2(this, _clientConfig, initConfig(newConfig, __privateGet2(this, _clientConfig) || {}));
    return this;
  }
  /**
   * Clone the client with a new (partial) configuration.
   *
   * @param newConfig - New client configuration properties, shallowly merged with existing configuration
   */
  withConfig(newConfig) {
    return new _ObservableSanityClient2(__privateGet2(this, _httpRequest), {
      ...this.config(),
      ...newConfig
    });
  }
  fetch(query, params) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return _fetch(this, __privateGet2(this, _httpRequest), query, params, options);
  }
  /**
   * Fetch a single document with the given ID.
   *
   * @param id - Document ID to fetch
   * @param options - Request options
   */
  getDocument(id4, options) {
    return _getDocument(this, __privateGet2(this, _httpRequest), id4, options);
  }
  /**
   * Fetch multiple documents in one request.
   * Should be used sparingly - performing a query is usually a better option.
   * The order/position of documents is preserved based on the original array of IDs.
   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array
   *
   * @param ids - Document IDs to fetch
   * @param options - Request options
   */
  getDocuments(ids, options) {
    return _getDocuments(this, __privateGet2(this, _httpRequest), ids, options);
  }
  create(document2, options) {
    return _create(this, __privateGet2(this, _httpRequest), document2, "create", options);
  }
  createIfNotExists(document2, options) {
    return _createIfNotExists(this, __privateGet2(this, _httpRequest), document2, options);
  }
  createOrReplace(document2, options) {
    return _createOrReplace(this, __privateGet2(this, _httpRequest), document2, options);
  }
  delete(selection, options) {
    return _delete(this, __privateGet2(this, _httpRequest), selection, options);
  }
  mutate(operations, options) {
    return _mutate(this, __privateGet2(this, _httpRequest), operations, options);
  }
  /**
   * Create a new buildable patch of operations to perform
   *
   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch
   * @param operations - Optional object of patch operations to initialize the patch instance with
   * @returns Patch instance - call `.commit()` to perform the operations defined
   */
  patch(selection, operations) {
    return new ObservablePatch(selection, operations, this);
  }
  /**
   * Create a new transaction of mutations
   *
   * @param operations - Optional array of mutation operations to initialize the transaction instance with
   */
  transaction(operations) {
    return new ObservableTransaction(operations, this);
  }
  /**
   * Perform an HTTP request against the Sanity API
   *
   * @param options - Request options
   */
  request(options) {
    return _request(this, __privateGet2(this, _httpRequest), options);
  }
  /**
   * Get a Sanity API URL for the URI provided
   *
   * @param uri - URI/path to build URL for
   * @param canUseCdn - Whether or not to allow using the API CDN for this route
   */
  getUrl(uri, canUseCdn) {
    return _getUrl(this, uri, canUseCdn);
  }
  /**
   * Get a Sanity API URL for the data operation and path provided
   *
   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)
   * @param path - Path to append after the operation
   */
  getDataUrl(operation, path2) {
    return _getDataUrl(this, operation, path2);
  }
};
_clientConfig = /* @__PURE__ */ new WeakMap();
_httpRequest = /* @__PURE__ */ new WeakMap();
var ObservableSanityClient = _ObservableSanityClient;
var _SanityClient = class _SanityClient2 {
  constructor(httpRequest) {
    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultConfig;
    __privateAdd2(this, _clientConfig2, void 0);
    __privateAdd2(this, _httpRequest2, void 0);
    this.listen = _listen;
    this.config(config);
    __privateSet2(this, _httpRequest2, httpRequest);
    this.assets = new AssetsClient(this, __privateGet2(this, _httpRequest2));
    this.datasets = new DatasetsClient(this, __privateGet2(this, _httpRequest2));
    this.projects = new ProjectsClient(this, __privateGet2(this, _httpRequest2));
    this.users = new UsersClient(this, __privateGet2(this, _httpRequest2));
    this.observable = new ObservableSanityClient(httpRequest, config);
  }
  /**
   * Clone the client - returns a new instance
   */
  clone() {
    return new _SanityClient2(__privateGet2(this, _httpRequest2), this.config());
  }
  config(newConfig) {
    if (newConfig === void 0) {
      return {
        ...__privateGet2(this, _clientConfig2)
      };
    }
    if (__privateGet2(this, _clientConfig2) && __privateGet2(this, _clientConfig2).allowReconfigure === false) {
      throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client");
    }
    if (this.observable) {
      this.observable.config(newConfig);
    }
    __privateSet2(this, _clientConfig2, initConfig(newConfig, __privateGet2(this, _clientConfig2) || {}));
    return this;
  }
  /**
   * Clone the client with a new (partial) configuration.
   *
   * @param newConfig - New client configuration properties, shallowly merged with existing configuration
   */
  withConfig(newConfig) {
    return new _SanityClient2(__privateGet2(this, _httpRequest2), {
      ...this.config(),
      ...newConfig
    });
  }
  fetch(query, params) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return lastValueFrom(_fetch(this, __privateGet2(this, _httpRequest2), query, params, options));
  }
  /**
   * Fetch a single document with the given ID.
   *
   * @param id - Document ID to fetch
   * @param options - Request options
   */
  getDocument(id4, options) {
    return lastValueFrom(_getDocument(this, __privateGet2(this, _httpRequest2), id4, options));
  }
  /**
   * Fetch multiple documents in one request.
   * Should be used sparingly - performing a query is usually a better option.
   * The order/position of documents is preserved based on the original array of IDs.
   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array
   *
   * @param ids - Document IDs to fetch
   * @param options - Request options
   */
  getDocuments(ids, options) {
    return lastValueFrom(_getDocuments(this, __privateGet2(this, _httpRequest2), ids, options));
  }
  create(document2, options) {
    return lastValueFrom(_create(this, __privateGet2(this, _httpRequest2), document2, "create", options));
  }
  createIfNotExists(document2, options) {
    return lastValueFrom(_createIfNotExists(this, __privateGet2(this, _httpRequest2), document2, options));
  }
  createOrReplace(document2, options) {
    return lastValueFrom(_createOrReplace(this, __privateGet2(this, _httpRequest2), document2, options));
  }
  delete(selection, options) {
    return lastValueFrom(_delete(this, __privateGet2(this, _httpRequest2), selection, options));
  }
  mutate(operations, options) {
    return lastValueFrom(_mutate(this, __privateGet2(this, _httpRequest2), operations, options));
  }
  /**
   * Create a new buildable patch of operations to perform
   *
   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch
   * @param operations - Optional object of patch operations to initialize the patch instance with
   * @returns Patch instance - call `.commit()` to perform the operations defined
   */
  patch(documentId, operations) {
    return new Patch(documentId, operations, this);
  }
  /**
   * Create a new transaction of mutations
   *
   * @param operations - Optional array of mutation operations to initialize the transaction instance with
   */
  transaction(operations) {
    return new Transaction(operations, this);
  }
  /**
   * Perform a request against the Sanity API
   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!
   *
   * @param options - Request options
   * @returns Promise resolving to the response body
   */
  request(options) {
    return lastValueFrom(_request(this, __privateGet2(this, _httpRequest2), options));
  }
  /**
   * Perform an HTTP request a `/data` sub-endpoint
   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.
   *
   * @deprecated - Use `request()` or your own HTTP library instead
   * @param endpoint - Endpoint to hit (mutate, query etc)
   * @param body - Request body
   * @param options - Request options
   * @internal
   */
  dataRequest(endpoint, body, options) {
    return lastValueFrom(_dataRequest(this, __privateGet2(this, _httpRequest2), endpoint, body, options));
  }
  /**
   * Get a Sanity API URL for the URI provided
   *
   * @param uri - URI/path to build URL for
   * @param canUseCdn - Whether or not to allow using the API CDN for this route
   */
  getUrl(uri, canUseCdn) {
    return _getUrl(this, uri, canUseCdn);
  }
  /**
   * Get a Sanity API URL for the data operation and path provided
   *
   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)
   * @param path - Path to append after the operation
   */
  getDataUrl(operation, path2) {
    return _getDataUrl(this, operation, path2);
  }
};
_clientConfig2 = /* @__PURE__ */ new WeakMap();
_httpRequest2 = /* @__PURE__ */ new WeakMap();
var SanityClient = _SanityClient;
function defineCreateClientExports(envMiddleware2, ClassConstructor) {
  const httpRequest = defineHttpRequest(envMiddleware2, {});
  const requester2 = httpRequest.defaultRequester;
  const createClient2 = (config) => new ClassConstructor(defineHttpRequest(envMiddleware2, {
    maxRetries: config.maxRetries,
    retryDelay: config.retryDelay
  }), config);
  return {
    requester: requester2,
    createClient: createClient2
  };
}
var envMiddleware = [];

// node_modules/@sanity/client/dist/index.browser.js
function defineDeprecatedCreateClient(createClient2) {
  return function deprecatedCreateClient2(config) {
    printNoDefaultExport();
    return createClient2(config);
  };
}
var exp = defineCreateClientExports(envMiddleware, SanityClient);
var requester = exp.requester;
var createClient = exp.createClient;
var deprecatedCreateClient = defineDeprecatedCreateClient(createClient);

// node_modules/sanity/lib/index.esm.js
init_esm3();
var import_react_is2 = __toESM(require_react_is());

// node_modules/@sanity/schema/lib/_exports/index.esm.js
var import_pick2 = __toESM(require_pick());
var import_omit = __toESM(require_omit());
var import_arrify = __toESM(require_arrify());
var import_castArray = __toESM(require_castArray());
var import_flatMap = __toESM(require_flatMap());
var import_startCase = __toESM(require_startCase());
var import_omitBy = __toESM(require_omitBy());
var import_isUndefined = __toESM(require_isUndefined());
var import_capitalize = __toESM(require_capitalize());
var import_isPlainObject2 = __toESM(require_isPlainObject());
var import_toPath = __toESM(require_toPath());
var import_uniqBy = __toESM(require_uniqBy());
var DEFAULT_OVERRIDEABLE_FIELDS = ["jsonType", "type", "name", "title", "description", "options", "fieldsets", "validation", "readOnly", "hidden", "components", "diffComponent", "initialValue"];
var OVERRIDABLE_FIELDS$e = [...DEFAULT_OVERRIDEABLE_FIELDS];
var ANY_CORE = {
  name: "any",
  type: null,
  jsonType: "any"
};
var AnyType = {
  get() {
    return ANY_CORE;
  },
  extend(subTypeDef, extendMember) {
    const parsed = Object.assign((0, import_pick2.default)(ANY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {
      type: ANY_CORE,
      of: subTypeDef.of.map((fieldDef) => {
        return {
          name: fieldDef.name,
          type: extendMember((0, import_omit.default)(fieldDef, "name"))
        };
      })
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` property of subtypes of "array"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$e), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var primitivePreview = {
  prepare: (val) => ({
    title: String(val)
  })
};
var OVERRIDABLE_FIELDS$d = [...DEFAULT_OVERRIDEABLE_FIELDS];
var STRING_CORE = {
  name: "string",
  title: "String",
  type: null,
  jsonType: "string"
};
var StringType = {
  get() {
    return STRING_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(STRING_CORE, OVERRIDABLE_FIELDS$d), subTypeDef, {
      type: STRING_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$d), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$c = [...DEFAULT_OVERRIDEABLE_FIELDS, "rows"];
var TEXT_CORE = {
  name: "text",
  title: "Text",
  type: null,
  jsonType: "string"
};
var TextType = {
  get() {
    return TEXT_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(TEXT_CORE, OVERRIDABLE_FIELDS$c), subTypeDef, {
      type: TEXT_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$c), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$b = [...DEFAULT_OVERRIDEABLE_FIELDS];
var DATETIME_CORE = {
  name: "datetime",
  title: "Datetime",
  type: null,
  jsonType: "string"
};
var DateTimeType = {
  get() {
    return DATETIME_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(DATETIME_CORE, OVERRIDABLE_FIELDS$b), subTypeDef, {
      type: DATETIME_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$b), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$a = [...DEFAULT_OVERRIDEABLE_FIELDS];
var DATE_CORE = {
  name: "date",
  title: "Datetime",
  type: null,
  jsonType: "string"
};
var DateType = {
  get() {
    return DATE_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(DATE_CORE, OVERRIDABLE_FIELDS$a), subTypeDef, {
      type: DATE_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$a), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$9 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var BOOLEAN_CORE = {
  name: "boolean",
  title: "Boolean",
  type: null,
  jsonType: "boolean"
};
var BooleanType = {
  get() {
    return BOOLEAN_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(BOOLEAN_CORE, OVERRIDABLE_FIELDS$9), subTypeDef, {
      type: BOOLEAN_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$9), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$8 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var URL_CORE = {
  name: "url",
  title: "Url",
  type: null,
  jsonType: "string"
};
var UrlType = {
  get() {
    return URL_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(URL_CORE, OVERRIDABLE_FIELDS$8), subTypeDef, {
      type: URL_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$8), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$7 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var EMAIL_CORE = {
  name: "email",
  title: "Email",
  type: null,
  jsonType: "string"
};
var EmailType = {
  get() {
    return EMAIL_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(EMAIL_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {
      type: EMAIL_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$7), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var OVERRIDABLE_FIELDS$6 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var NUMBER_CORE = {
  name: "number",
  title: "Number",
  type: null,
  jsonType: "number"
};
var NumberType = {
  get() {
    return NUMBER_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign((0, import_pick2.default)(NUMBER_CORE, OVERRIDABLE_FIELDS$6), subTypeDef, {
      type: NUMBER_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$6), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function lazyGetter(target, key2, getter) {
  let config = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  Object.defineProperty(target, key2, {
    configurable: true,
    enumerable: config.enumerable !== false,
    get() {
      const val = getter();
      Object.defineProperty(target, key2, {
        value: val,
        writable: Boolean(config.writable),
        configurable: false
      });
      return val;
    }
  });
  return target;
}
function isEmpty(object2) {
  for (const key2 in object2) {
    if (object2.hasOwnProperty(key2)) {
      return false;
    }
  }
  return true;
}
function _stringify(value, options, depth) {
  if (depth > options.maxDepth) {
    return "...";
  }
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "[empty]";
    }
    const capLength = Math.max(value.length - options.maxBreadth);
    const asString2 = value.slice(0, options.maxBreadth).map((item, index) => _stringify(item, options, depth + 1)).concat(capLength > 0 ? "+".concat(capLength) : []).join(", ");
    return depth === 0 ? asString2 : "[".concat(asString2, "]");
  }
  if (typeof value === "object" && value !== null) {
    const keys = Object.keys(value).filter((key2) => !options.ignoreKeys.includes(key2) && typeof value[key2] !== "undefined");
    if (isEmpty((0, import_pick2.default)(value, keys))) {
      return "{empty}";
    }
    const asString2 = keys.slice(0, options.maxBreadth).map((key2) => "".concat(key2, ": ").concat(_stringify(value[key2], options, depth + 1))).join(", ");
    return depth === 0 ? asString2 : "{".concat(asString2, "}");
  }
  const asString = String(value);
  return asString === "" ? '""' : asString;
}
function stringify(value) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const opts = {
    maxDepth: "maxDepth" in options ? options.maxDepth : 2,
    maxBreadth: "maxBreadth" in options ? options.maxBreadth : 2,
    ignoreKeys: "ignoreKeys" in options ? options.ignoreKeys : []
  };
  return _stringify(value, opts, 0);
}
var OPTIONS = {
  maxEntries: 2,
  maxDepth: 2,
  maxBreadth: 2,
  ignoreKeys: ["_id", "_type", "_key", "_ref"]
};
function createFallbackPrepare(fieldNames) {
  return (value) => ({
    title: stringify((0, import_pick2.default)(value, fieldNames), OPTIONS)
  });
}
function isBlockField(field) {
  return field.type === "array" && field.of && field.of.some((member) => member.type === "block");
}
var TITLE_CANDIDATES = ["title", "name", "label", "heading", "header", "caption"];
var DESCRIPTION_CANDIDATES = ["description", ...TITLE_CANDIDATES];
function fieldHasReferenceTo(fieldDef, refType) {
  return (0, import_arrify.default)(fieldDef.to || []).some((memberTypeDef) => memberTypeDef.type === refType);
}
function isImageAssetField(fieldDef) {
  return fieldHasReferenceTo(fieldDef, "sanity.imageAsset");
}
function resolveImageAssetPath(typeDef) {
  const fields = typeDef.fields || [];
  const imageAssetField = fields.find(isImageAssetField);
  if (imageAssetField) {
    return imageAssetField.name;
  }
  const fieldWithImageAsset = fields.find((fieldDef) => (fieldDef.fields || []).some(isImageAssetField));
  return fieldWithImageAsset ? "".concat(fieldWithImageAsset.name, ".asset") : void 0;
}
function isFileAssetField(fieldDef) {
  return fieldHasReferenceTo(fieldDef, "sanity.fileAsset");
}
function resolveFileAssetPath(typeDef) {
  const fields = typeDef.fields || [];
  const assetField = fields.find(isFileAssetField);
  if (assetField) {
    return assetField.name;
  }
  const fieldWithFileAsset = fields.find((fieldDef) => (fieldDef.fields || []).some(isFileAssetField));
  return fieldWithFileAsset ? "".concat(fieldWithFileAsset.name, ".asset") : void 0;
}
function guessPreviewFields(rawObjectTypeDef) {
  const objectTypeDef = {
    fields: [],
    ...rawObjectTypeDef
  };
  const stringFieldNames = objectTypeDef.fields.filter((field) => field.type === "string").map((field) => field.name);
  const blockFieldNames = objectTypeDef.fields.filter(isBlockField).map((field) => field.name);
  let titleField = TITLE_CANDIDATES.find((candidate) => stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate));
  let descField = DESCRIPTION_CANDIDATES.find((candidate) => candidate !== titleField && (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)));
  if (!titleField) {
    titleField = stringFieldNames[0] || blockFieldNames[0];
    descField = stringFieldNames[1] || blockFieldNames[1];
  }
  const mediaField = objectTypeDef.fields.find((field) => field.type === "image");
  const imageAssetPath = resolveImageAssetPath(objectTypeDef);
  if (!titleField) {
    const fileAssetPath = resolveFileAssetPath(objectTypeDef);
    if (fileAssetPath) {
      titleField = "".concat(fileAssetPath, ".originalFilename");
    }
    if (imageAssetPath) {
      titleField = "".concat(imageAssetPath, ".originalFilename");
    }
  }
  if (!titleField && !imageAssetPath) {
    const fieldNames = objectTypeDef.fields.map((field) => field.name);
    const fieldMapping = fieldNames.reduce((acc, fieldName) => {
      acc[fieldName] = fieldName;
      return acc;
    }, {});
    return {
      select: fieldMapping,
      prepare: createFallbackPrepare(fieldNames)
    };
  }
  const select2 = (0, import_omitBy.default)({
    title: titleField,
    description: descField,
    media: mediaField ? mediaField.name : imageAssetPath
  }, import_isUndefined.default);
  return {
    select: select2
  };
}
function warnIfPreviewOnOptions(type) {
  if (type.options && type.options.preview) {
    console.warn('Heads up! The preview config is no longer defined on "options", but instead on the type/field itself.\nPlease move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of "'.concat(type.name, '".\n'));
  }
}
function warnIfPreviewHasFields(type) {
  const preview = type.preview || (type.options || {}).preview;
  if (preview && "fields" in preview) {
    console.warn('Heads up! "preview.fields" should be renamed to "preview.select". Please update the preview config for "'.concat(type.name, '".\n'));
  }
}
function parseSelection(selection) {
  return selection.reduce((acc, field) => {
    acc[field] = field;
    return acc;
  }, {});
}
function parsePreview(preview) {
  if (!preview) {
    return preview;
  }
  const select2 = preview.select || preview.fields || {};
  if (Array.isArray(select2)) {
    return {
      ...(0, import_pick2.default)(preview, ["prepare", "component"]),
      select: parseSelection(select2)
    };
  }
  return {
    ...(0, import_pick2.default)(preview, ["prepare", "component"]),
    select: select2
  };
}
function createPreviewGetter(objectTypeDef) {
  return function previewGetter() {
    warnIfPreviewOnOptions(objectTypeDef);
    warnIfPreviewHasFields(objectTypeDef);
    const preview = parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview);
    return preview || guessPreviewFields(objectTypeDef);
  };
}
var CANDIDATES = ["title", "name", "label", "heading", "header", "caption", "description"];
var PRIMITIVES = ["string", "boolean", "number"];
var isPrimitive = (field) => PRIMITIVES.includes(field.type);
function guessOrderingConfig(objectTypeDef) {
  let candidates = CANDIDATES.filter((candidate) => objectTypeDef.fields.some((field) => isPrimitive(field) && field.name === candidate));
  if (candidates.length === 0) {
    candidates = objectTypeDef.fields.filter(isPrimitive).map((field) => field.name);
  }
  return candidates.map((name) => ({
    name,
    title: (0, import_capitalize.default)((0, import_startCase.default)(name)),
    by: [{
      field: name,
      direction: "asc"
    }]
  }));
}
function normalizeSearchConfigs(configs) {
  if (!Array.isArray(configs)) {
    throw new Error("The search config of a document type must be an array of search config objects");
  }
  return configs.map((conf) => {
    if (conf === "defaults") {
      return conf;
    }
    if (!(0, import_isPlainObject2.default)(conf)) {
      throw new Error("Search config must be an object of {path: string, weight: number}");
    }
    return {
      weight: "weight" in conf ? conf.weight : 1,
      path: (0, import_toPath.default)(conf.path),
      mapWith: typeof conf.mapWith === "string" ? conf.mapWith : void 0
    };
  });
}
var stringFieldsSymbol = Symbol("__cachedStringFields");
var isReference2 = (type) => type.type && type.type.name === "reference";
var portableTextFields = ["style", "list"];
var isPortableTextBlock = (type) => type.name === "block" || type.type && isPortableTextBlock(type.type);
var isPortableTextArray = (type) => type.jsonType === "array" && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
function reduceType(type, reducer, acc) {
  let path2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  let maxDepth2 = arguments.length > 4 ? arguments[4] : void 0;
  if (maxDepth2 < 0) {
    return acc;
  }
  const accumulator = reducer(acc, type, path2);
  if (type.jsonType === "array" && Array.isArray(type.of)) {
    return reduceArray(type, reducer, accumulator, path2, maxDepth2);
  }
  if (type.jsonType === "object" && Array.isArray(type.fields) && !isReference2(type)) {
    return reduceObject(type, reducer, accumulator, path2, maxDepth2);
  }
  return accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path2, maxDepth2) {
  return arrayType.of.reduce((acc, ofType) => reduceType(ofType, reducer, acc, path2, maxDepth2 - 1), accumulator);
}
function reduceObject(objectType, reducer, accumulator, path2, maxDepth2) {
  const isPtBlock = isPortableTextBlock(objectType);
  return objectType.fields.reduce((acc, field) => {
    if (isPtBlock && portableTextFields.includes(field.name)) {
      return acc;
    }
    const segment = [field.name].concat(field.type.jsonType === "array" ? [[]] : []);
    return reduceType(field.type, reducer, acc, path2.concat(segment), maxDepth2 - 1);
  }, accumulator);
}
var BASE_WEIGHTS = [{
  weight: 1,
  path: ["_id"]
}, {
  weight: 1,
  path: ["_type"]
}];
var PREVIEW_FIELD_WEIGHT_MAP = {
  title: 10,
  subtitle: 5,
  description: 1.5
};
function deriveFromPreview(type) {
  var _a4;
  const select2 = (_a4 = type == null ? void 0 : type.preview) == null ? void 0 : _a4.select;
  if (!select2) {
    return [];
  }
  return Object.keys(select2).filter((fieldName) => fieldName in PREVIEW_FIELD_WEIGHT_MAP).map((fieldName) => ({
    weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
    path: select2[fieldName].split(".")
  }));
}
function getCachedStringFieldPaths(type, maxDepth2) {
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = (0, import_uniqBy.default)([...BASE_WEIGHTS, ...deriveFromPreview(type), ...getStringFieldPaths(type, maxDepth2).map((path2) => ({
      weight: 1,
      path: path2
    })), ...getPortableTextFieldPaths(type, maxDepth2).map((path2) => ({
      weight: 1,
      path: path2,
      mapWith: "pt::text"
    }))], (spec) => spec.path.join("."));
  }
  return type[stringFieldsSymbol];
}
function getCachedBaseFieldPaths(type) {
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = (0, import_uniqBy.default)([...BASE_WEIGHTS, ...deriveFromPreview(type)], (spec) => spec.path.join("."));
  }
  return type[stringFieldsSymbol];
}
function getStringFieldPaths(type, maxDepth2) {
  const reducer = (accumulator, childType, path2) => childType.jsonType === "string" ? [...accumulator, path2] : accumulator;
  return reduceType(type, reducer, [], [], maxDepth2);
}
function getPortableTextFieldPaths(type, maxDepth2) {
  const reducer = (accumulator, childType, path2) => isPortableTextArray(childType) ? [...accumulator, path2] : accumulator;
  return reduceType(type, reducer, [], [], maxDepth2);
}
function resolveSearchConfigForBaseFieldPaths(type) {
  return getCachedBaseFieldPaths(type);
}
function resolveSearchConfig(type) {
  return getCachedStringFieldPaths(type, 4);
}
var OVERRIDABLE_FIELDS$5 = [...DEFAULT_OVERRIDEABLE_FIELDS, "orderings", "__experimental_search", "blockEditor", "icon"];
var ObjectType = {
  get() {
    return {
      name: "object",
      title: "Object",
      type: null,
      jsonType: "object"
    };
  },
  extend(rawSubTypeDef, createMemberType) {
    const subTypeDef = {
      fields: [],
      ...rawSubTypeDef
    };
    const options = {
      ...subTypeDef.options || {}
    };
    const parsed = Object.assign((0, import_pick2.default)(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {
      type: this.get(),
      title: subTypeDef.title || (subTypeDef.name ? (0, import_startCase.default)(subTypeDef.name) : ""),
      options,
      orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),
      fields: subTypeDef.fields.map((fieldDef) => {
        const {
          name,
          fieldset,
          group: group2,
          ...rest
        } = fieldDef;
        const compiledField = {
          name,
          group: group2,
          fieldset
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType({
            ...rest,
            title: fieldDef.title || (0, import_startCase.default)(name)
          });
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "groups", () => {
      return createFieldsGroups(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    lazyGetter(parsed, "__experimental_search", () => {
      const userProvidedSearchConfig = subTypeDef.__experimental_search ? normalizeSearchConfigs(subTypeDef.__experimental_search) : null;
      if (userProvidedSearchConfig) {
        return userProvidedSearchConfig.map((entry) => entry === "defaults" ? normalizeSearchConfigs(subTypeDef) : entry);
      }
      return resolveSearchConfig(parsed);
    }, {
      enumerable: false
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "object"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$5), {
            title: extensionDef.title || subTypeDef.title || (subTypeDef.name ? (0, import_startCase.default)(subTypeDef.name) : ""),
            type: parent
          });
          lazyGetter(current, "__experimental_search", () => parent.__experimental_search);
          return subtype(current);
        }
      };
    }
  }
};
function createFieldsets(typeDef, fields) {
  const fieldsetsByName = {};
  for (const fieldset of typeDef.fieldsets || []) {
    if (fieldsetsByName[fieldset.name]) {
      throw new Error('Duplicate fieldset name "'.concat(fieldset.name, `" found for type '`).concat(typeDef.title ? typeDef.title : (0, import_startCase.default)(typeDef.name), "'"));
    }
    fieldsetsByName[fieldset.name] = {
      title: (0, import_startCase.default)(fieldset.name),
      ...fieldset,
      fields: []
    };
  }
  const fieldsets = /* @__PURE__ */ new Set();
  for (const field of fields) {
    if (!field.fieldset) {
      fieldsets.add({
        single: true,
        field
      });
      continue;
    }
    const fieldset = fieldsetsByName[field.fieldset];
    if (!fieldset) {
      throw new Error("Fieldset '".concat(field.fieldset, "' is not defined in schema for type '").concat(typeDef.name, "'"));
    }
    fieldset.fields.push(field);
    fieldsets.add(fieldset);
  }
  return Array.from(fieldsets);
}
function createFieldsGroups(typeDef, fields) {
  const groupsByName = {};
  let numDefaultGroups = 0;
  for (const group2 of typeDef.groups || []) {
    if (groupsByName[group2.name]) {
      throw new Error('Duplicate group name "'.concat(group2.name, `" found for type '`).concat(typeDef.title ? typeDef.title : (0, import_startCase.default)(typeDef.name), "'"));
    }
    groupsByName[group2.name] = {
      title: (0, import_startCase.default)(group2.name),
      ...group2,
      fields: []
    };
    if (group2.default && ++numDefaultGroups > 1) {
      throw new Error("More than one field group defined as default for type '".concat(typeDef.title ? typeDef.title : (0, import_startCase.default)(typeDef.name), "' - only 1 is supported"));
    }
  }
  fields.forEach((field) => {
    const fieldGroupNames = (0, import_castArray.default)(field.group || []);
    if (fieldGroupNames.length === 0) {
      return;
    }
    fieldGroupNames.forEach((fieldGroupName) => {
      const currentGroup = groupsByName[fieldGroupName];
      if (!currentGroup) {
        throw new Error("Field group '".concat(fieldGroupName, "' is not defined in schema for type '").concat(typeDef.title ? typeDef.name : (0, import_startCase.default)(typeDef.name), "'"));
      }
      currentGroup.fields.push(field);
    });
  });
  return (0, import_flatMap.default)(groupsByName).filter((group2) => group2.fields.length > 0);
}
var REF_FIELD$1 = {
  name: "_ref",
  title: "Referenced document ID",
  type: "string"
};
var WEAK_FIELD$1 = {
  name: "_weak",
  title: "Weak reference",
  type: "boolean"
};
var REFERENCE_FIELDS$1 = [REF_FIELD$1, WEAK_FIELD$1];
var OVERRIDABLE_FIELDS$4 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var REFERENCE_CORE = {
  name: "reference",
  title: "Reference",
  type: null,
  jsonType: "object"
};
function humanize$1(arr, conjunction) {
  const len = arr.length;
  if (len === 1) {
    return arr[0];
  }
  const first2 = arr.slice(0, len - 1);
  const last2 = arr[len - 1];
  return "".concat(first2.join(", "), " ").concat(conjunction, " ").concat(last2);
}
function buildTitle$1(type) {
  if (!type.to || type.to.length === 0) {
    return "Reference";
  }
  return "Reference to ".concat(humanize$1((0, import_arrify.default)(type.to).map((toType) => toType.title), "or").toLowerCase());
}
var ReferenceType = {
  get() {
    return REFERENCE_CORE;
  },
  extend(subTypeDef, createMemberType) {
    if (!subTypeDef.to) {
      throw new Error('Missing "to" field in reference definition. Check the type '.concat(subTypeDef.name));
    }
    const parsed = Object.assign((0, import_pick2.default)(REFERENCE_CORE, OVERRIDABLE_FIELDS$4), subTypeDef, {
      type: REFERENCE_CORE
    });
    lazyGetter(parsed, "fields", () => {
      return REFERENCE_FIELDS$1.map((fieldDef) => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: createMemberType(type)
        };
      });
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "to", () => {
      return (0, import_arrify.default)(subTypeDef.to).map((toType) => createMemberType(toType));
    });
    lazyGetter(parsed, "title", () => subTypeDef.title || buildTitle$1(parsed));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` of subtypes of "reference"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$4), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var REF_FIELD = {
  name: "_ref",
  title: "Referenced document ID",
  type: "string"
};
var WEAK_FIELD = {
  name: "_weak",
  title: "Weak reference marker",
  type: "boolean"
};
var DATASET_FIELD = {
  name: "_dataset",
  title: "Target dataset",
  type: "string"
};
var PROJECT_ID_FIELD = {
  name: "_projectId",
  title: "Target project ID",
  type: "string",
  hidden: true
};
var REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD, DATASET_FIELD, PROJECT_ID_FIELD];
var OVERRIDABLE_FIELDS$3 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var CROSS_DATASET_REFERENCE_CORE = {
  name: "crossDatasetReference",
  type: null,
  jsonType: "object"
};
function humanize(arr, conjunction) {
  const len = arr.length;
  if (len === 1) {
    return arr[0];
  }
  const first2 = arr.slice(0, len - 1);
  const last2 = arr[len - 1];
  return "".concat(first2.join(", "), " ").concat(conjunction, " ").concat(last2);
}
function buildTitle(type) {
  if (!type.to || type.to.length === 0) {
    return "Cross dataset Reference";
  }
  return "Cross dataset reference to ".concat(humanize((0, import_arrify.default)(type.to).map((toType) => toType.title || (0, import_capitalize.default)(toType.type)), "or").toLowerCase());
}
var CrossDatasetReferenceType = {
  get() {
    return CROSS_DATASET_REFERENCE_CORE;
  },
  extend(subTypeDef, createMemberType) {
    if (!subTypeDef.to) {
      throw new Error('Missing "to" field in cross dataset reference definition. Check the type '.concat(subTypeDef.name));
    }
    const parsed = Object.assign((0, import_pick2.default)(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {
      type: CROSS_DATASET_REFERENCE_CORE
    });
    lazyGetter(parsed, "fields", () => {
      return REFERENCE_FIELDS.map((fieldDef) => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: createMemberType(type)
        };
      });
    });
    lazyGetter(parsed, "to", () => {
      return (0, import_arrify.default)(subTypeDef.to).map((toType) => {
        return {
          ...toType,
          // eslint-disable-next-line camelcase
          __experimental_search: resolveSearchConfigForBaseFieldPaths(toType)
        };
      });
    });
    lazyGetter(parsed, "title", () => subTypeDef.title || buildTitle(parsed));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` of subtypes of "reference"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$3), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var ASSET_FIELD$1 = {
  name: "asset",
  type: "reference",
  to: [{
    type: "sanity.imageAsset"
  }]
};
var HOTSPOT_FIELD = {
  name: "hotspot",
  type: "sanity.imageHotspot"
};
var CROP_FIELD = {
  name: "crop",
  type: "sanity.imageCrop"
};
var OVERRIDABLE_FIELDS$2 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var IMAGE_CORE = {
  name: "image",
  title: "Image",
  type: null,
  jsonType: "object"
};
var DEFAULT_OPTIONS$3 = {};
var ImageType = {
  get() {
    return IMAGE_CORE;
  },
  extend(rawSubTypeDef, createMemberType) {
    const options = {
      ...rawSubTypeDef.options || DEFAULT_OPTIONS$3
    };
    let hotspotFields = [HOTSPOT_FIELD, CROP_FIELD];
    if (!options.hotspot) {
      hotspotFields = hotspotFields.map((field) => ({
        ...field,
        hidden: true
      }));
    }
    const fields = [ASSET_FIELD$1, ...hotspotFields, ...rawSubTypeDef.fields || []];
    const subTypeDef = {
      ...rawSubTypeDef,
      fields
    };
    const parsed = Object.assign((0, import_pick2.default)(this.get(), OVERRIDABLE_FIELDS$2), subTypeDef, {
      type: IMAGE_CORE,
      title: subTypeDef.title || (subTypeDef.name ? (0, import_startCase.default)(subTypeDef.name) : ""),
      options,
      fields: subTypeDef.fields.map((fieldDef) => {
        const {
          name,
          fieldset,
          ...rest
        } = fieldDef;
        const compiledField = {
          name,
          fieldset,
          isCustomized: Boolean(rawSubTypeDef.fields)
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType({
            ...rest,
            title: fieldDef.title || (0, import_startCase.default)(name)
          });
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
      fields
    })));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "image"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$2), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var ASSET_FIELD = {
  name: "asset",
  type: "reference",
  to: {
    type: "sanity.fileAsset"
  }
};
var OVERRIDABLE_FIELDS$1 = [...DEFAULT_OVERRIDEABLE_FIELDS];
var FILE_CORE = {
  name: "file",
  title: "File",
  type: null,
  jsonType: "object"
};
var DEFAULT_OPTIONS$2 = {
  accept: ""
};
var FileType = {
  get() {
    return FILE_CORE;
  },
  extend(rawSubTypeDef, createMemberType) {
    const options = {
      ...rawSubTypeDef.options || DEFAULT_OPTIONS$2
    };
    const fields = [ASSET_FIELD, ...rawSubTypeDef.fields || []];
    const subTypeDef = {
      ...rawSubTypeDef,
      fields
    };
    const parsed = Object.assign((0, import_pick2.default)(FILE_CORE, OVERRIDABLE_FIELDS$1), subTypeDef, {
      type: FILE_CORE,
      title: subTypeDef.title || (subTypeDef.name ? (0, import_startCase.default)(subTypeDef.name) : ""),
      options,
      fields: subTypeDef.fields.map((fieldDef) => {
        const {
          name,
          fieldset,
          ...rest
        } = fieldDef;
        const compiledField = {
          name,
          fieldset,
          isCustomized: Boolean(rawSubTypeDef.fields)
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType({
            ...rest,
            title: fieldDef.title || (0, import_startCase.default)(name)
          });
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
      fields
    })));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "file"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS$1), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var DOCUMENT_CORE = {
  name: "document",
  title: "Document",
  type: null,
  jsonType: "object"
};
var DocumentType = {
  get() {
    return DOCUMENT_CORE;
  },
  extend: ObjectType.extend
};
var OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS];
var ARRAY_CORE = {
  name: "array",
  type: null,
  jsonType: "array",
  of: []
};
var ArrayType = {
  get() {
    return ARRAY_CORE;
  },
  extend(subTypeDef, createMemberType) {
    const parsed = Object.assign((0, import_pick2.default)(ARRAY_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
      type: ARRAY_CORE
    });
    lazyGetter(parsed, "of", () => {
      return subTypeDef.of.map((ofTypeDef) => {
        return createMemberType(ofTypeDef);
      });
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` property of subtypes of "array"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, OVERRIDABLE_FIELDS), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var DEFAULT_LINK_ANNOTATION = {
  type: "object",
  name: "link",
  title: "Link",
  i18nTitleKey: "inputs.portable-text.annotation.link",
  options: {
    modal: {
      type: "popover"
    }
  },
  fields: [{
    name: "href",
    type: "url",
    title: "Link",
    description: "A valid web, email, phone, or relative link.",
    validation: (Rule2) => Rule2.uri({
      scheme: ["http", "https", "tel", "mailto"],
      allowRelative: true
    })
  }]
};
var DEFAULT_TEXT_FIELD = {
  type: "text",
  name: "text",
  title: "Text"
};
var DEFAULT_MARKS_FIELD = {
  name: "marks",
  type: "array",
  of: [{
    type: "string"
  }],
  title: "Marks"
};
var LIST_TYPES = {
  bullet: {
    title: "Bulleted list",
    value: "bullet",
    i18nTitleKey: "inputs.portable-text.list-type.bullet"
  },
  numbered: {
    title: "Numbered list",
    value: "number",
    i18nTitleKey: "inputs.portable-text.list-type.number"
  }
};
var DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered];
var BLOCK_STYLES = {
  normal: {
    title: "Normal",
    value: "normal",
    i18nTitleKey: "inputs.portable-text.style.normal"
  },
  h1: {
    title: "Heading 1",
    value: "h1",
    i18nTitleKey: "inputs.portable-text.style.h1"
  },
  h2: {
    title: "Heading 2",
    value: "h2",
    i18nTitleKey: "inputs.portable-text.style.h2"
  },
  h3: {
    title: "Heading 3",
    value: "h3",
    i18nTitleKey: "inputs.portable-text.style.h3"
  },
  h4: {
    title: "Heading 4",
    value: "h4",
    i18nTitleKey: "inputs.portable-text.style.h4"
  },
  h5: {
    title: "Heading 5",
    value: "h5",
    i18nTitleKey: "inputs.portable-text.style.h5"
  },
  h6: {
    title: "Heading 6",
    value: "h6",
    i18nTitleKey: "inputs.portable-text.style.h6"
  },
  blockquote: {
    title: "Quote",
    value: "blockquote",
    i18nTitleKey: "inputs.portable-text.style.quote"
  }
};
var DEFAULT_BLOCK_STYLES = [BLOCK_STYLES.normal, BLOCK_STYLES.h1, BLOCK_STYLES.h2, BLOCK_STYLES.h3, BLOCK_STYLES.h4, BLOCK_STYLES.h5, BLOCK_STYLES.h6, BLOCK_STYLES.blockquote];
var DECORATOR_STRONG = {
  title: "Strong",
  value: "strong",
  i18nTitleKey: "inputs.portable-text.decorator.strong"
};
var DECORATOR_EMPHASIS = {
  title: "Italic",
  value: "em",
  i18nTitleKey: "inputs.portable-text.decorator.emphasis"
};
var DECORATOR_CODE = {
  title: "Code",
  value: "code",
  i18nTitleKey: "inputs.portable-text.decorator.code"
};
var DECORATOR_UNDERLINE = {
  title: "Underline",
  value: "underline",
  i18nTitleKey: "inputs.portable-text.decorator.underline"
};
var DECORATOR_STRIKE = {
  title: "Strike",
  value: "strike-through",
  i18nTitleKey: "inputs.portable-text.decorator.strike-through"
};
var DECORATORS = {
  strong: DECORATOR_STRONG,
  em: DECORATOR_EMPHASIS,
  code: DECORATOR_CODE,
  underline: DECORATOR_UNDERLINE,
  strikeThrough: DECORATOR_STRIKE
};
var DEFAULT_DECORATORS = [DECORATORS.strong, DECORATORS.em, DECORATORS.code, DECORATORS.underline, DECORATORS.strikeThrough];
var INHERITED_FIELDS$1 = ["type", "name", "title", "jsonType", "description", "options", "fieldsets", "icon"];
var BLOCK_CORE = {
  name: "block",
  title: "Block",
  type: null,
  jsonType: "object"
};
var DEFAULT_OPTIONS$1 = {};
var BlockType = {
  get() {
    return BLOCK_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = {
      ...subTypeDef.options || DEFAULT_OPTIONS$1
    };
    const {
      marks,
      styles,
      lists,
      of: of2,
      ...rest
    } = subTypeDef;
    const childrenField = createChildrenField(marks, of2);
    const styleField = createStyleField(styles);
    const listItemField = createListItemField(lists);
    const markDefsField = {
      name: "markDefs",
      title: "Mark definitions",
      type: "array",
      of: (marks == null ? void 0 : marks.annotations) || DEFAULT_ANNOTATIONS
    };
    const levelField = {
      name: "level",
      title: "Indentation",
      type: "number"
    };
    const fields = [childrenField, styleField, listItemField, markDefsField, levelField].concat(subTypeDef.fields || []);
    const parsed = Object.assign((0, import_pick2.default)(BLOCK_CORE, INHERITED_FIELDS$1), rest, {
      type: BLOCK_CORE,
      options
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map((fieldDef) => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "block"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, INHERITED_FIELDS$1), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function ensureNormalStyle(styles) {
  return styles.some((style) => style.value === "normal") ? styles : [BLOCK_STYLES.normal, ...styles];
}
function createStyleField(styles) {
  return {
    name: "style",
    title: "Style",
    type: "string",
    options: {
      list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES)
    }
  };
}
function createListItemField(lists) {
  return {
    name: "listItem",
    title: "List type",
    type: "string",
    options: {
      list: lists || DEFAULT_LIST_TYPES
    }
  };
}
var DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION];
function createChildrenField(marks) {
  let of2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return {
    name: "children",
    title: "Content",
    type: "array",
    of: [{
      type: "span",
      fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],
      annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,
      decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS
    }, ...of2.filter((memberType) => memberType.type !== "span")]
  };
}
var INHERITED_FIELDS = ["type", "name", "title", "jsonType", "description", "options", "fieldsets", "icon"];
var SPAN_CORE = {
  name: "span",
  title: "Span",
  type: null,
  jsonType: "object"
};
var MARKS_FIELD = {
  name: "marks",
  title: "Marks",
  type: "array",
  of: [{
    type: "string"
  }]
};
var TEXT_FIELD = {
  name: "text",
  title: "Text",
  type: "string"
};
var DEFAULT_OPTIONS = {};
var SpanType = {
  get() {
    return SPAN_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = {
      ...subTypeDef.options || DEFAULT_OPTIONS
    };
    const {
      annotations = [],
      marks = []
    } = subTypeDef;
    const fields = [MARKS_FIELD, TEXT_FIELD];
    const parsed = Object.assign((0, import_pick2.default)(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {
      type: SPAN_CORE,
      options
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map((fieldDef) => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "annotations", () => annotations.map(extendMember));
    lazyGetter(parsed, "marks", () => marks.map(extendMember));
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: (extensionDef) => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "span"');
          }
          const current = Object.assign({}, parent, (0, import_pick2.default)(extensionDef, INHERITED_FIELDS), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var types2 = Object.freeze({
  __proto__: null,
  any: AnyType,
  array: ArrayType,
  block: BlockType,
  boolean: BooleanType,
  crossDatasetReference: CrossDatasetReferenceType,
  date: DateType,
  datetime: DateTimeType,
  document: DocumentType,
  email: EmailType,
  file: FileType,
  image: ImageType,
  number: NumberType,
  object: ObjectType,
  reference: ReferenceType,
  span: SpanType,
  string: StringType,
  text: TextType,
  url: UrlType
});
function compileRegistry(schemaDef) {
  const registry = Object.assign(/* @__PURE__ */ Object.create(null), types2);
  const defsByName = schemaDef.types.reduce((acc, def) => {
    if (acc[def.name]) {
      throw new Error("Duplicate type name added to schema: ".concat(def.name));
    }
    acc[def.name] = def;
    return acc;
  }, {});
  schemaDef.types.forEach(add);
  return registry;
  function ensure(typeName) {
    if (!registry[typeName]) {
      if (!defsByName[typeName]) {
        throw new Error("Unknown type: ".concat(typeName));
      }
      add(defsByName[typeName]);
    }
  }
  function extendMember(memberDef) {
    ensure(memberDef.type);
    return registry[memberDef.type].extend(memberDef, extendMember).get();
  }
  function add(typeDef) {
    ensure(typeDef.type);
    if (registry[typeDef.name]) {
      return;
    }
    registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember);
  }
}
var Schema$1 = class Schema {
  static compile(schemaDef) {
    return new Schema(schemaDef);
  }
  constructor(schemaDef) {
    this._original = schemaDef;
    this._registry = compileRegistry(schemaDef);
  }
  get name() {
    return this._original.name;
  }
  get(name) {
    return this._registry[name] && this._registry[name].get();
  }
  has(name) {
    return name in this._registry;
  }
  getTypeNames() {
    return Object.keys(this._registry);
  }
};
var Schema2 = Schema$1;

// node_modules/@sanity/schema/lib/_exports/_internal.esm.js
var import_flatten = __toESM(require_flatten());
var import_get = __toESM(require_get());
var import_uniq = __toESM(require_uniq());
var import_isPlainObject3 = __toESM(require_isPlainObject());
var import_object_inspect = __toESM(require_object_inspect());
var import_partition = __toESM(require_partition());
var import_humanize_list = __toESM(require_humanize_list());
var import_omit2 = __toESM(require_omit());
var import_leven = __toESM(require_leven());

// node_modules/@sanity/generate-help-url/dist/generate-help-url.esm.js
var BASE_URL2 = "https://docs.sanity.io/help/";
function generateHelpUrl2(slug3) {
  return BASE_URL2 + slug3;
}

// node_modules/@sanity/schema/lib/_exports/_internal.esm.js
var import_difference2 = __toESM(require_difference());
var HELP_IDS = {
  TYPE_INVALID: "schema-type-invalid",
  TYPE_IS_ESM_MODULE: "schema-type-is-esm-module",
  TYPE_NAME_RESERVED: "schema-type-name-reserved",
  TYPE_MISSING_NAME: "schema-type-missing-name-or-type",
  TYPE_MISSING_TYPE: "schema-type-missing-name-or-type",
  TYPE_TITLE_RECOMMENDED: "schema-type-title-is-recommended",
  TYPE_TITLE_INVALID: "schema-type-title-is-recommended",
  OBJECT_FIELDS_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_NOT_UNIQUE: "schema-object-fields-invalid",
  OBJECT_FIELD_NAME_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_DEFINITION_INVALID_TYPE: "schema-object-fields-invalid",
  ARRAY_PREDEFINED_CHOICES_INVALID: "schema-predefined-choices-invalid",
  ARRAY_OF_ARRAY: "schema-array-of-array",
  ARRAY_OF_INVALID: "schema-array-of-invalid",
  ARRAY_OF_NOT_UNIQUE: "schema-array-of-invalid",
  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: "schema-array-of-type-global-type-conflict",
  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: "schema-array-of-type-builtin-type-conflict",
  REFERENCE_TO_INVALID: "schema-reference-to-invalid",
  REFERENCE_TO_NOT_UNIQUE: "schema-reference-to-invalid",
  REFERENCE_INVALID_OPTIONS: "schema-reference-invalid-options",
  REFERENCE_INVALID_OPTIONS_LOCATION: "schema-reference-options-nesting",
  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: "schema-reference-filter-params-combination",
  SLUG_SLUGIFY_FN_RENAMED: "slug-slugifyfn-renamed",
  ASSET_METADATA_FIELD_INVALID: "asset-metadata-field-invalid",
  CROSS_DATASET_REFERENCE_INVALID: "cross-dataset-reference-invalid",
  DEPRECATED_BLOCKEDITOR_KEY: "schema-deprecated-blockeditor-key",
  STANDALONE_BLOCK_TYPE: "schema-standalone-block-type"
};
function createValidationResult(severity, message, helpId) {
  if (helpId && !Object.keys(HELP_IDS).some((id4) => HELP_IDS[id4] === helpId)) {
    throw new Error('Used the unknown helpId "'.concat(helpId, '", please add it to the array in createValidationResult.js'));
  }
  return {
    severity,
    message,
    helpId
  };
}
var error = (message, helpId) => createValidationResult("error", message, helpId);
var warning2 = (message, helpId) => createValidationResult("warning", message, helpId);
function groupProblems(types3) {
  return (0, import_flatten.default)(types3.map((type) => getTypeProblems(type))).filter((type) => type.problems.length > 0);
}
function createTypeWithMembersProblemsAccessor(memberPropertyName) {
  let getMembers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (type) => (0, import_get.default)(type, memberPropertyName);
  return function getProblems(type, parentPath) {
    const currentPath = [...parentPath, {
      kind: "type",
      type: type.type,
      name: type.name
    }];
    const members = getMembers(type) || [];
    const memberProblems = Array.isArray(members) ? members.map((memberType) => {
      const propertySegment = {
        kind: "property",
        name: memberPropertyName
      };
      const memberPath = [...currentPath, propertySegment];
      return getTypeProblems(memberType, memberPath);
    }) : [[{
      path: currentPath,
      problems: [error("Member declaration (".concat(memberPropertyName, ") is not an array"))]
    }]];
    return [{
      path: currentPath,
      problems: type._problems || []
    }, ...(0, import_flatten.default)(memberProblems)];
  };
}
var arrify2 = (val) => Array.isArray(val) ? val : typeof val === "undefined" && [] || [val];
var getObjectProblems = createTypeWithMembersProblemsAccessor("fields");
var getImageProblems = createTypeWithMembersProblemsAccessor("fields");
var getFileProblems = createTypeWithMembersProblemsAccessor("fields");
var getArrayProblems = createTypeWithMembersProblemsAccessor("of");
var getReferenceProblems = createTypeWithMembersProblemsAccessor("to", (type) => "to" in type ? arrify2(type.to) : []);
var getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor("marks.annotations");
var getBlockMemberProblems = createTypeWithMembersProblemsAccessor("of");
var getBlockProblems = (type, problems) => [...getBlockAnnotationProblems(type, problems), ...getBlockMemberProblems(type, problems)];
function getDefaultProblems(type) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return [{
    path: [...path2, {
      kind: "type",
      type: type.type,
      name: type.name
    }],
    problems: type._problems || []
  }];
}
function getTypeProblems(type) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  switch (type.type) {
    case "object": {
      return getObjectProblems(type, path2);
    }
    case "document": {
      return getObjectProblems(type, path2);
    }
    case "array": {
      return getArrayProblems(type, path2);
    }
    case "reference": {
      return getReferenceProblems(type, path2);
    }
    case "block": {
      return getBlockProblems(type, path2);
    }
    case "image": {
      return getImageProblems(type, path2);
    }
    case "file": {
      return getFileProblems(type, path2);
    }
    default: {
      return getDefaultProblems(type, path2);
    }
  }
}
function getDupes(array3) {
  let selector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (v) => v;
  const dupes = array3.reduce((acc, item) => {
    const key2 = selector(item);
    if (!acc[key2]) {
      acc[key2] = [];
    }
    acc[key2].push(item);
    return acc;
  }, {});
  return Object.keys(dupes).map((key2) => dupes[key2].length > 1 ? dupes[key2] : null).filter(Boolean);
}
var NOOP_VISITOR = (typeDef) => typeDef;
var TYPE_TYPE = {
  name: "type",
  type: null
};
var FUTURE_RESERVED = ["any", "time", "date"];
function traverseSchema() {
  let types3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let coreTypes2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let visitor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NOOP_VISITOR;
  const coreTypesRegistry = /* @__PURE__ */ Object.create(null);
  const registry = /* @__PURE__ */ Object.create(null);
  const coreTypeNames2 = coreTypes2.map((typeDef) => typeDef.name);
  const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames2);
  const typeNames = types3.map((typeDef) => typeDef && typeDef.name).filter(Boolean);
  coreTypes2.forEach((coreType) => {
    coreTypesRegistry[coreType.name] = coreType;
  });
  types3.forEach((type, i) => {
    registry[type && type.name || "__unnamed_".concat(i)] = {};
  });
  function getType3(typeName) {
    return typeName === "type" ? TYPE_TYPE : coreTypesRegistry[typeName] || registry[typeName] || null;
  }
  const duplicateNames = (0, import_uniq.default)((0, import_flatten.default)(getDupes(typeNames)));
  function isDuplicate(typeName) {
    return duplicateNames.includes(typeName);
  }
  function getTypeNames() {
    return typeNames.concat(coreTypeNames2);
  }
  function isReserved(typeName) {
    return typeName === "type" || reservedTypeNames.includes(typeName);
  }
  const visitType = (isRoot2) => (typeDef, index) => {
    return visitor(typeDef, {
      visit: visitType(false),
      isRoot: isRoot2,
      getType: getType3,
      getTypeNames,
      isReserved,
      isDuplicate,
      index
    });
  };
  coreTypes2.forEach((coreTypeDef) => {
    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
  });
  types3.forEach((typeDef, i) => {
    Object.assign(registry[typeDef && typeDef.name || "__unnamed_".concat(i)], visitType(true)(typeDef, i));
  });
  return {
    get(typeName) {
      const res = registry[typeName] || coreTypesRegistry[typeName];
      if (res) {
        return res;
      }
      throw new Error("No such type: ".concat(typeName));
    },
    has(typeName) {
      return typeName in registry || typeName in coreTypesRegistry;
    },
    getTypeNames() {
      return Object.keys(registry);
    },
    getTypes() {
      return this.getTypeNames().map(this.get);
    },
    toJSON() {
      return this.getTypes();
    }
  };
}
var coreTypes = [{
  name: "array",
  jsonType: "array",
  type: "type"
}, {
  name: "block",
  jsonType: "object",
  type: "type"
}, {
  name: "boolean",
  jsonType: "boolean",
  type: "type"
}, {
  name: "datetime",
  jsonType: "string",
  type: "type"
}, {
  name: "date",
  jsonType: "string",
  type: "type"
}, {
  name: "document",
  jsonType: "object",
  type: "type"
}, {
  name: "email",
  jsonType: "string",
  type: "type"
}, {
  name: "file",
  jsonType: "object",
  type: "type"
}, {
  name: "geopoint",
  jsonType: "object",
  type: "type"
}, {
  name: "image",
  jsonType: "object",
  type: "type"
}, {
  name: "number",
  jsonType: "number",
  type: "type"
}, {
  name: "object",
  jsonType: "object",
  type: "type"
}, {
  name: "reference",
  jsonType: "object",
  type: "type"
}, {
  name: "crossDatasetReference",
  jsonType: "object",
  type: "type"
}, {
  name: "slug",
  jsonType: "object",
  type: "type"
}, {
  name: "span",
  jsonType: "object",
  type: "type"
}, {
  name: "string",
  jsonType: "string",
  type: "type"
}, {
  name: "telephone",
  jsonType: "string",
  type: "type"
}, {
  name: "text",
  jsonType: "string",
  type: "type"
}, {
  name: "url",
  jsonType: "string",
  type: "type"
}];
var coreTypeNames = coreTypes.map((t3) => t3.name);
function traverseSanitySchema(schemaTypes, visitor) {
  return traverseSchema(schemaTypes, coreTypes, visitor);
}
var REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isComponentLike(value) {
  const type = typeof value;
  return type === "function" || typeof (value == null ? void 0 : value.$$typeof) === "symbol" && REACT_SYM_RE.test(String(value == null ? void 0 : value.$$typeof));
}
function validateComponent(typeDef) {
  const components = "components" in typeDef ? typeDef.components : false;
  if (!components) {
    return [];
  }
  const warnings = [];
  if (components.input && !isComponentLike(components.input)) {
    warnings.push(warning2("The `components.input` property is set but does not appear to be a valid React component (expected a function, but saw ".concat((0, import_object_inspect.default)(components.input), "). If you have imported a custom input component, please verify that you have imported the correct named/default export.")));
  }
  if (components.field && !isComponentLike(components.field)) {
    warnings.push(warning2("The `components.field` property is set but does not appear to be a valid React component (expected a function, but saw ".concat((0, import_object_inspect.default)(components.field), "). If you have imported a custom field component, please verify that you have imported the correct named/default export.")));
  }
  if (components.item && !isComponentLike(components.item)) {
    warnings.push(warning2("The `components.item` property is set but does not appear to be a valid React component (expected a function, but saw ".concat((0, import_object_inspect.default)(components.item), "). If you have imported a custom item component, please verify that you have imported the correct named/default export.")));
  }
  if (components.preview && !isComponentLike(components.preview)) {
    warnings.push(warning2("The `components.preview` property is set but does not appear to be a valid React component (expected a function, but saw ".concat((0, import_object_inspect.default)(components.preview), "). If you have imported a custom preview component, please verify that you have imported the correct named/default export.")));
  }
  return warnings;
}
var VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/;
var CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
  if (typeof name !== "string") {
    return [error('Field names must be strings. Saw "'.concat((0, import_object_inspect.default)(name), '"'), HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }
  if (name.startsWith("_")) {
    return [error('Invalid field name "'.concat(name, `". Field names cannot start with underscores "_" as it's reserved for system fields.`), HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }
  if (!VALID_FIELD_RE.test(name)) {
    return [error('Invalid field name: "'.concat(name, '". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ').concat(String(VALID_FIELD_RE), ")."), HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }
  if (!CONVENTIONAL_FIELD_RE.test(name)) {
    return [warning2("Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional? It may be wise to keep special characters out of field names for easier access later on."), HELP_IDS.OBJECT_FIELD_NAME_INVALID];
  }
  return [];
}
function validateField(field, _visitorContext) {
  if (!(0, import_isPlainObject3.default)(field)) {
    return [error("Incorrect type for field definition - should be an object, saw ".concat((0, import_object_inspect.default)(field)), HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE)];
  }
  const problems = [];
  problems.push(..."name" in field ? validateFieldName(field.name) : [error("Missing field name", HELP_IDS.OBJECT_FIELD_NAME_INVALID)]);
  problems.push(...validateComponent(field));
  return problems;
}
function getDuplicateFields(array3) {
  const dupes = {};
  array3.forEach((field) => {
    if (!dupes[field.name]) {
      dupes[field.name] = [];
    }
    dupes[field.name].push(field);
  });
  return Object.keys(dupes).map((fieldName) => dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);
}
function validateFields(fields) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    allowEmpty: false
  };
  const problems = [];
  const fieldsIsArray = Array.isArray(fields);
  if (!fieldsIsArray) {
    return [error('The "fields" property must be an array of fields. Instead saw "'.concat(typeof fields, '"'), HELP_IDS.OBJECT_FIELDS_INVALID)];
  }
  const fieldsWithNames = fields.filter((field) => typeof field.name === "string");
  getDuplicateFields(fieldsWithNames).forEach((dupes) => {
    problems.push(error("Found ".concat(dupes.length, ' fields with name "').concat(dupes[0].name, '" in object'), HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
  });
  if (fields.length === 0 && !options.allowEmpty) {
    problems.push(error("Object should have at least one field", HELP_IDS.OBJECT_FIELDS_INVALID));
  }
  const standaloneBlockFields = fields.filter((field) => field.type === "block").map((field) => '"'.concat(field.name, '"'));
  if (standaloneBlockFields.length > 0) {
    const fmtFields = standaloneBlockFields.join(", ");
    problems.push(error("Invalid standalone block field(s) ".concat(fmtFields, ". Block content must be defined as an array of blocks"), HELP_IDS.STANDALONE_BLOCK_TYPE));
  }
  return problems;
}
function validatePreview(preview) {
  if (!(0, import_isPlainObject3.default)(preview)) {
    return [error('The "preview" property must be an object, instead saw "'.concat(typeof preview, '"'))];
  }
  if (typeof preview.prepare !== "undefined" && typeof preview.prepare !== "function") {
    return [error('The "preview.prepare" property must be a function, instead saw "'.concat(typeof preview.prepare, '"'))];
  }
  if (!preview.select) {
    return [];
  }
  if (!(0, import_isPlainObject3.default)(preview.select)) {
    return [error('The "preview.select" property must be an object, instead saw "'.concat(typeof preview.prepare, '"'))];
  }
  return Object.keys(preview.select).reduce((errs, key2) => {
    return typeof preview.select[key2] === "string" ? errs : errs.concat(error('The key "'.concat(key2, '" of "preview.select" must be a string, instead saw "').concat(typeof preview.select[key2], '"')));
  }, []);
}
var object = (typeDef, visitorContext) => {
  let problems = validateFields(typeDef.fields);
  let preview = typeDef.preview;
  if (preview) {
    const previewErrors = validatePreview(typeDef.preview);
    problems = problems.concat(previewErrors);
    preview = previewErrors.some((err) => err.severity === "error") ? {} : preview;
  }
  if (typeDef.type !== "document" && typeDef.type !== "object" && typeof typeDef.initialValue !== "undefined") {
    problems.push(error('The "initialValue" property is currently only supported for document & object types.'));
  }
  return {
    ...typeDef,
    preview,
    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index) => {
      const {
        name,
        ...fieldTypeDef
      } = field;
      const {
        _problems,
        ...fieldType
      } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
var documentVisitor = (typeDefinition, visitorContext) => {
  const typeDef = object(typeDefinition, visitorContext);
  const {
    initialValue,
    initialValues
  } = typeDef;
  const hasInitialValue = typeof initialValue !== "undefined";
  if (hasInitialValue && !(0, import_isPlainObject3.default)(initialValue) && typeof initialValue !== "function") {
    typeDef._problems.push(error('The "initialValue" property must be either a plain object or a function'));
  }
  if (typeof initialValues !== "undefined") {
    typeDef._problems.push(error('Found property "initialValues" - did you mean "initialValue"?'));
  }
  return typeDef;
};
function normalizeToProp$1(typeDef) {
  if (Array.isArray(typeDef.to)) {
    return typeDef.to;
  }
  return typeDef.to ? [typeDef.to] : typeDef.to;
}
var reference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || (0, import_isPlainObject3.default)(typeDef.to);
  const normalizedTo = normalizeToProp$1(typeDef);
  const problems = (0, import_flatten.default)([isValidTo ? getDupes(normalizedTo, (t3) => "".concat(t3.name, ";").concat(t3.type)).map((dupes) => error("Found ".concat(dupes.length, ' members with same type, but not unique names "').concat(dupes[0].type, '" in reference. This makes it impossible to tell their values apart and you should consider naming them'), HELP_IDS.REFERENCE_TO_INVALID)) : error('The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.REFERENCE_TO_INVALID)]);
  if (isValidTo && normalizedTo.length === 0) {
    problems.push(error('The reference type should define at least one accepted type. Please check the "to" property.', HELP_IDS.REFERENCE_TO_INVALID));
  }
  problems.push(...getOptionErrors$1(typeDef));
  return {
    ...typeDef,
    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),
    _problems: problems
  };
};
function getOptionErrors$1(typeDef) {
  const {
    options
  } = typeDef;
  const problems = [];
  problems.push(...["filter", "filterParams"].filter((key2) => key2 in typeDef).map((key2) => error("`".concat(key2, "` is not allowed on a reference type definition - did you mean `options.").concat(key2, "`?"), HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION)));
  if (!options) {
    return problems;
  }
  if (!(0, import_isPlainObject3.default)(options)) {
    return problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS));
  }
  if (typeof options.filter === "function" && typeof options.filterParams !== "undefined") {
    return problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
  }
  if (typeof options.filter === "function" || !options.filter && !options.filterParams) {
    return problems;
  }
  if (typeof options.filter !== "string") {
    return problems.concat(error("If set, `filter` must be a string. Got ".concat(typeof options.filter)));
  }
  if (typeof options.filterParams !== "undefined" && !(0, import_isPlainObject3.default)(options.filterParams)) {
    return problems.concat(error("If set, `filterParams` must be an object."));
  }
  if (options.filterParams) {
    return problems.concat(Object.keys(options.filterParams).filter((key2) => key2.startsWith("__") || key2.startsWith("$")).map((key2) => error('Filter parameter cannot be prefixed with "$" or "__". Got '.concat(key2, '".'))));
  }
  return problems;
}
function isPrimitiveTypeName(typeName) {
  return typeName === "string" || typeName === "number" || typeName === "boolean";
}
function isAssignable(typeName, type) {
  return (typeof type.name === "string" ? type.name : type.type) === typeName;
}
function quote$2(n) {
  return '"'.concat(n, '"');
}
function pluralize(arr) {
  let suf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "s";
  return arr.length === 1 ? "" : suf;
}
function format2(value) {
  if (Array.isArray(value)) {
    return "array with ".concat(value.length, " entries");
  }
  if (typeof value === "object" && value !== null) {
    return "object with keys ".concat((0, import_humanize_list.default)(Object.keys(value).map(quote$2)));
  }
  return quote$2(value);
}
var array = (typeDef, visitorContext) => {
  var _a4, _b4, _c4;
  const ofIsArray = Array.isArray(typeDef.of);
  if (ofIsArray) {
    const invalid = typeDef.of.reduce((errs, def, idx) => {
      if (typeof def.name === "string") {
        if (
          // specifying the same name as the type is redundant, but should not be a hard error at this point
          // Consider showing a warning for this and deprecate this ability eventually
          def.name !== def.type && coreTypeNames.includes(def.name)
        ) {
          return errs.concat(error('Found array member declaration with the same type name as a built-in type ("'.concat(def.name, '"). Array members can not be given the same name as a built-in type.'), HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT));
        }
      }
      if (def.type === "object" && def.name && visitorContext.getType(def.name)) {
        return errs.concat(warning2('Found array member declaration with the same name as the global schema type "'.concat(def.name, `". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`), HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT));
      }
      if (def.type === "array") {
        return errs.concat(error('Found array member declaration of type "array" - multidimensional arrays are not currently supported by Sanity', HELP_IDS.ARRAY_OF_ARRAY));
      }
      if (def) {
        return errs;
      }
      const err = "Found ".concat(def === null ? "null" : typeof def, ", expected member declaration");
      return errs.concat(error("Found invalid type member declaration in array at index ".concat(idx, ": ").concat(err), HELP_IDS.ARRAY_OF_INVALID));
    }, []);
    if (invalid.length > 0) {
      return {
        ...typeDef,
        of: [],
        _problems: invalid
      };
    }
  }
  const problems = (0, import_flatten.default)([ofIsArray ? getDupes(typeDef.of, (t3) => "".concat(t3.name, ";").concat(t3.type)).map((dupes) => error("Found ".concat(dupes.length, ' members with same type, but not unique names "').concat(dupes[0].type, '" in array. This makes it impossible to tell their values apart and you should consider naming them'), HELP_IDS.ARRAY_OF_NOT_UNIQUE)) : error('The array type is missing or having an invalid value for the required "of" property', HELP_IDS.ARRAY_OF_INVALID)]);
  const of2 = ofIsArray ? typeDef.of : [];
  const hasObjectTypesWithoutName = of2.some((type) => type.type === "object" && typeof type.name === "undefined");
  const hasBlockType = of2.some((ofType) => ofType.type === "block");
  if (hasBlockType && hasObjectTypesWithoutName) {
    problems.push(error("The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.", HELP_IDS.ARRAY_OF_INVALID));
  }
  const [primitiveTypes, objectTypes] = (0, import_partition.default)(of2, (ofType) => {
    var _a22;
    return isPrimitiveTypeName(ofType.type) || isPrimitiveTypeName((_a22 = visitorContext.getType(ofType.type)) == null ? void 0 : _a22.jsonType);
  });
  const isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0;
  if (isMixedArray) {
    const primitiveTypeNames = primitiveTypes.map((t3) => t3.type);
    const objectTypeNames = objectTypes.map((t3) => t3.type);
    problems.push(error("The array type's 'of' property can't have both object types and primitive types (found primitive type ".concat(pluralize(primitiveTypeNames), " ").concat((0, import_humanize_list.default)(primitiveTypeNames.map(quote$2)), " and object type").concat(pluralize(objectTypeNames), " ").concat((0, import_humanize_list.default)(objectTypeNames.map(quote$2)), ")"), HELP_IDS.ARRAY_OF_INVALID));
  }
  const list = (_a4 = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _a4.list;
  if (!isMixedArray && Array.isArray(list)) {
    const isArrayOfPrimitives2 = primitiveTypes.length > 0;
    if (isArrayOfPrimitives2) {
      list.forEach((option) => {
        var _a22;
        const value = (_a22 = option == null ? void 0 : option.value) != null ? _a22 : option;
        const isDeclared = primitiveTypes.some((primitiveType) => {
          return typeof value === visitorContext.getType(primitiveType.type).jsonType;
        });
        if (!isDeclared) {
          const formattedTypeList = (0, import_humanize_list.default)(primitiveTypes.map((t3) => t3.name || t3.type), {
            conjunction: "or"
          });
          problems.push(error("An invalid entry found in options.list: ".concat(format2(value), ". Must be either a value of type ").concat(formattedTypeList, ", or an object with {title: string, value: ").concat(formattedTypeList, "}"), HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID));
        }
      });
    } else {
      list.forEach((option) => {
        const optionTypeName = option._type || "object";
        const isDeclared = objectTypes.some((validObjectType) => isAssignable(optionTypeName, validObjectType));
        if (!isDeclared) {
          problems.push(error("An invalid entry found in options.list: ".concat(format2(option), '. Must be an object with "_type" set to ').concat((0, import_humanize_list.default)(objectTypes.map((t3) => t3.name || t3.type).map((t3) => t3 === "object" ? "undefined" : quote$2(t3)), {
            conjunction: "or"
          })), HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID));
        }
      });
    }
  }
  if (((_b4 = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _b4.list) && ((_c4 = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _c4.layout) === "tags") {
    problems.push(warning2("Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`."));
  }
  return {
    ...typeDef,
    of: of2.map(visitorContext.visit),
    _problems: problems
  };
};
var slug = (typeDef, visitorContext) => {
  const problems = [];
  if (typeDef.options && typeDef.options.slugifyFn) {
    problems.push(warning2('Heads up! The "slugifyFn" option has been renamed to "slugify".', HELP_IDS.SLUG_SLUGIFY_FN_RENAMED));
    typeDef.options.slugify = typeDef.options.slugifyFn;
  }
  return {
    ...typeDef,
    _problems: problems
  };
};
var file = (typeDef, visitorContext) => {
  const problems = [];
  const fields = typeDef.fields;
  if (fields) {
    problems.push(...validateFields(fields, {
      allowEmpty: true
    }));
  }
  const invalidFieldNames = Array.isArray(fields) ? fields == null ? void 0 : fields.filter((field) => field.name === "asset") : [];
  if (typeDef.options && typeof typeDef.options.metadata !== "undefined" && !Array.isArray(typeDef.options.metadata)) {
    problems.push(error("Invalid type for file `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID));
  } else if (invalidFieldNames.length > 0) {
    problems.push(error("The name `asset` is not a valid field name for type `file`."));
  }
  return {
    ...typeDef,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const {
        name,
        ...fieldTypeDef
      } = field;
      const {
        _problems,
        ...fieldType
      } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
var autoMeta = ["dimensions", "hasAlpha", "isOpaque"];
var image = (typeDef, visitorContext) => {
  const problems = [];
  const fields = typeDef.fields;
  if (fields) {
    problems.push(...validateFields(fields, {
      allowEmpty: true
    }));
  }
  let options = typeDef.options;
  const metadata = options == null ? void 0 : options.metadata;
  const superfluousMeta = Array.isArray(metadata) ? metadata.filter((meta) => autoMeta.includes(meta)) : [];
  const invalidFieldNames = ["asset", "hotspot", "crop"];
  const fieldsWithInvalidName = Array.isArray(fields) ? fields == null ? void 0 : fields.filter((field) => invalidFieldNames.includes(field.name)) : [];
  if (typeof metadata !== "undefined" && !Array.isArray(metadata)) {
    problems.push(error("Invalid type for image `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID));
  } else if (superfluousMeta.length > 0) {
    problems.push(warning2("Image `metadata` field contains superfluous properties (they are always included): ".concat(superfluousMeta.join(", "))));
    options = {
      ...options,
      metadata: metadata.filter((meta) => !autoMeta.includes(meta))
    };
  } else if (fieldsWithInvalidName.length > 0) {
    problems.push(error("The names `".concat(invalidFieldNames.join("`, `"), "` are invalid field names for type `image`.")));
  }
  return {
    ...typeDef,
    options,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const {
        name,
        ...fieldTypeDef
      } = field;
      const {
        _problems,
        ...fieldType
      } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
function isJSONTypeOf(type, jsonType, visitorContext) {
  if ("jsonType" in type) {
    return type.jsonType === jsonType;
  }
  const parentType = visitorContext.getType(type.type);
  if (!parentType) {
    throw new Error("Could not resolve jsonType of ".concat(type.name, ". No parent type found"));
  }
  return isJSONTypeOf(parentType, jsonType, visitorContext);
}
var getTypeOf = (thing) => Array.isArray(thing) ? "array" : typeof thing;
var quote$1 = (str) => '"'.concat(str, '"');
var allowedKeys = ["components", "lists", "marks", "name", "of", "options", "styles", "title", "type", "validation"];
var allowedMarkKeys = ["decorators", "annotations"];
var allowedStyleKeys = ["blockEditor", "title", "value", "component"];
var allowedDecoratorKeys = ["blockEditor", "title", "value", "icon", "component"];
var allowedListKeys = ["title", "value", "icon", "component"];
var supportedBuiltInObjectTypes = ["file", "image", "object", "reference"];
function validateBlockType(typeDef, visitorContext) {
  const problems = [];
  let styles = typeDef.styles;
  let lists = typeDef.lists;
  let marks = typeDef.marks;
  let members = typeDef.of;
  const disallowedKeys = Object.keys(typeDef).filter((key2) => !allowedKeys.includes(key2) && !key2.startsWith("_"));
  if (disallowedKeys.length > 0) {
    problems.push(error("Found unknown properties for block declaration: ".concat((0, import_humanize_list.default)(disallowedKeys.map(quote$1)))));
  }
  if (marks) {
    marks = validateMarks(typeDef.marks, visitorContext, problems);
  }
  if (styles) {
    styles = validateStyles(styles, visitorContext, problems);
  }
  if (lists) {
    lists = validateLists(lists, visitorContext, problems);
  }
  if (members) {
    members = validateMembers(members, visitorContext, problems);
  }
  return {
    ...(0, import_omit2.default)(typeDef, disallowedKeys),
    marks,
    styles,
    name: typeDef.name || typeDef.type,
    of: members,
    _problems: problems
  };
}
function validateMarks(marks, visitorContext, problems) {
  let decorators = marks.decorators;
  let annotations = marks.annotations;
  if (!(0, import_isPlainObject3.default)(marks)) {
    problems.push(error('"marks" declaration should be an object, got '.concat(getTypeOf(marks))));
    return problems;
  }
  const disallowedMarkKeys = Object.keys(marks).filter((key2) => !allowedMarkKeys.includes(key2) && !key2.startsWith("_"));
  if (disallowedMarkKeys.length > 0) {
    problems.push(error("Found unknown properties for block declaration: ".concat((0, import_humanize_list.default)(disallowedMarkKeys.map(quote$1)))));
  }
  if (decorators && !Array.isArray(decorators)) {
    problems.push(error('"marks.decorators" declaration should be an array, got '.concat(getTypeOf(decorators))));
  } else if (decorators) {
    decorators.filter((dec2) => !!dec2.blockEditor).forEach((dec2) => {
      dec2.icon = dec2.blockEditor.icon;
      dec2.component = dec2.blockEditor.render;
    });
    decorators = validateDecorators(decorators, visitorContext, problems);
  }
  if (annotations && !Array.isArray(annotations)) {
    problems.push(error('"marks.annotations" declaration should be an array, got '.concat(getTypeOf(annotations))));
  } else if (annotations) {
    annotations = validateAnnotations(annotations, visitorContext, problems);
  }
  return {
    ...marks,
    decorators,
    annotations
  };
}
function validateLists(lists, visitorContext, problems) {
  if (!Array.isArray(lists)) {
    problems.push(error('"lists" declaration should be an array, got '.concat(getTypeOf(lists))));
    return problems;
  }
  lists.forEach((list, index) => {
    if (!(0, import_isPlainObject3.default)(list)) {
      problems.push(error("List must be an object, got ".concat(getTypeOf(list))));
      return;
    }
    const name = list.value || "#".concat(index);
    const disallowedKeys = Object.keys(list).filter((key2) => !allowedListKeys.includes(key2) && !key2.startsWith("_"));
    if (disallowedKeys.length > 0) {
      problems.push(error("Found unknown properties for list ".concat(name, ": ").concat((0, import_humanize_list.default)(disallowedKeys.map(quote$1)))));
    }
    if (!list.value) {
      problems.push(error("List #".concat(index, ' is missing required "value" property')));
    } else if (typeof list.value !== "string") {
      problems.push(error("List type #".concat(index, ' has an invalid "value" property, expected string, got ').concat(getTypeOf(list.value))));
    } else if (!list.title) {
      problems.push(warning2("List type ".concat(name, ' is missing recommended "title" property')));
    }
  });
  return lists;
}
function validateStyles(styles, visitorContext, problems) {
  if (!Array.isArray(styles)) {
    problems.push(error('"styles" declaration should be an array, got '.concat(getTypeOf(styles))));
    return problems;
  }
  styles.forEach((style, index) => {
    if (!(0, import_isPlainObject3.default)(style)) {
      problems.push(error("Style must be an object, got ".concat(getTypeOf(style))));
      return;
    }
    const name = style.value || "#".concat(index);
    const disallowedKeys = Object.keys(style).filter((key2) => !allowedStyleKeys.includes(key2) && !key2.startsWith("_"));
    if (disallowedKeys.length > 0) {
      problems.push(error("Found unknown properties for style ".concat(name, ": ").concat((0, import_humanize_list.default)(disallowedKeys.map(quote$1)))));
    }
    if (!style.value) {
      problems.push(error("Style #".concat(index, ' is missing required "value" property')));
    } else if (typeof style.value !== "string") {
      problems.push(error("Style #".concat(index, ' has an invalid "value" property, expected string, got ').concat(getTypeOf(style.value))));
    } else if (!style.title) {
      problems.push(warning2("Style ".concat(name, ' is missing recommended "title" property')));
    }
    if (typeof style.blockEditor !== "undefined") {
      problems.push(warning2('Style has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.', HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY));
      style.component = style.component || style.blockEditor.render;
    }
  });
  return styles;
}
function validateDecorators(decorators, visitorContext, problems) {
  decorators.forEach((decorator, index) => {
    if (!(0, import_isPlainObject3.default)(decorator)) {
      problems.push(error("Annotation must be an object, got ".concat(getTypeOf(decorator))));
      return;
    }
    const name = decorator.value || "#".concat(index);
    const disallowedKeys = Object.keys(decorator).filter((key2) => !allowedDecoratorKeys.includes(key2) && !key2.startsWith("_"));
    if (disallowedKeys.length > 0) {
      problems.push(error("Found unknown properties for decorator ".concat(name, ": ").concat((0, import_humanize_list.default)(disallowedKeys.map(quote$1)))));
    }
    if (!decorator.value) {
      problems.push(error("Decorator #".concat(index, ' is missing required "value" property')));
    } else if (typeof decorator.value !== "string") {
      problems.push(error("Decorator #".concat(index, ' has an invalid "value" property, expected string, got ').concat(getTypeOf(decorator.value))));
    } else if (!decorator.title) {
      problems.push(warning2("Decorator ".concat(name, ' is missing recommended "title" property')));
    }
    if (typeof decorator.blockEditor !== "undefined") {
      problems.push(warning2('Decorator "'.concat(name, '" has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.'), HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY));
      decorator.icon = decorator.icon || decorator.blockEditor.icon;
      decorator.component = decorator.component || decorator.blockEditor.render;
    }
  });
  return decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
  return annotations.map((annotation) => {
    var _a4, _b4;
    if (!(0, import_isPlainObject3.default)(annotation)) {
      return {
        ...annotation,
        _problems: [error("Annotation must be an object, got ".concat(getTypeOf(annotation)))]
      };
    }
    const {
      _problems
    } = visitorContext.visit(annotation, visitorContext);
    const targetType = annotation.type && visitorContext.getType(annotation.type);
    if (targetType && !isJSONTypeOf(targetType, "object", visitorContext)) {
      _problems.push(error('Annotation cannot have type "'.concat(annotation.type, '" - annotation types must inherit from object')));
    }
    if (typeof annotation.blockEditor !== "undefined") {
      problems.push(warning2('Annotation has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.', HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY));
      annotation.icon = annotation.icon || annotation.blockEditor.icon;
      if (((_a4 = annotation.blockEditor) == null ? void 0 : _a4.render) && !((_b4 = annotation.components) == null ? void 0 : _b4.annotation)) {
        annotation.components = annotation.components || {};
        annotation.components.annotation = annotation.components.annotation || annotation.blockEditor.render;
      }
    }
    return {
      ...annotation,
      _problems
    };
  });
}
function validateMembers(members, visitorContext, problems) {
  if (!Array.isArray(members)) {
    problems.push(error('"of" declaration should be an array, got '.concat(getTypeOf(members))));
    return void 0;
  }
  return members.map((member) => {
    const {
      _problems
    } = visitorContext.visit(member, visitorContext);
    if (member.type === "object" && member.name && visitorContext.getType(member.name)) {
      return {
        ...member,
        _problems: [warning2('Found array member declaration with the same name as the global schema type "'.concat(member.name, `". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`), HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT)]
      };
    }
    let type = member;
    while (type && !type.jsonType) {
      type = visitorContext.getType(type.type);
    }
    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n));
    if (
      // Must be object-like type (to validate hoisted types)
      type && type.jsonType !== "object" || // Can't be a core type, or core object type that isn't supported (like 'span')
      nonObjectCoreTypes.some((coreName) => coreName === member.type)
    ) {
      return {
        ...member,
        _problems: [error("Block member types must be a supported object-like type. The following built-in types are supported: '".concat(supportedBuiltInObjectTypes.join("', '"), "'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}"), HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT)]
      };
    }
    return {
      ...member,
      _problems
    };
  });
}
function validateNonObjectFieldsProp(typeDef, visitorContext) {
  if (!("fields" in typeDef)) {
    return [];
  }
  let type = typeDef;
  while (type && !type.jsonType) {
    type = visitorContext.getType(type.type);
  }
  if (type && type.jsonType !== "object") {
    return [error('Type has propery "fields", but is not an object/document type.')];
  }
  return [];
}
var quote2 = (str) => '"'.concat(str, '"');
function validateTypeName(typeName, visitorContext) {
  const possibleTypeNames = visitorContext.getTypeNames();
  if (!typeName) {
    return [error("Type is missing a type. Valid types are: ".concat((0, import_humanize_list.default)(possibleTypeNames)), HELP_IDS.TYPE_MISSING_TYPE)];
  }
  if (typeof typeName !== "string") {
    return [error('Type has an invalid "type"-property - should be a string. Valid types are: '.concat((0, import_humanize_list.default)(possibleTypeNames)), HELP_IDS.TYPE_MISSING_TYPE)];
  }
  const isValid2 = possibleTypeNames.includes(typeName);
  if (!isValid2) {
    const suggestions = possibleTypeNames.map((possibleTypeName) => {
      return [(0, import_leven.default)(typeName, possibleTypeName), possibleTypeName];
    }).filter((_ref) => {
      let [distance2] = _ref;
      return distance2 < 3;
    }).map((_ref2) => {
      let [_, name] = _ref2;
      return name;
    });
    const suggestion = suggestions.length > 0 ? " Did you mean ".concat((0, import_humanize_list.default)(suggestions.map(quote2), {
      conjunction: "or"
    }), "?") : "";
    return [error("Unknown type: ".concat(typeName, ".").concat(suggestion, "\n\nValid types are: ").concat((0, import_humanize_list.default)(possibleTypeNames)))];
  }
  return [];
}
function validateDeprecatedProperties(type) {
  var _a4, _b4, _c4;
  const warnings = [];
  if (type == null ? void 0 : type.inputComponent) {
    warnings.push(warning2('The "inputComponent" property is deprecated. Use "components.input" instead.'));
  }
  if ((_a4 = type == null ? void 0 : type.preview) == null ? void 0 : _a4.component) {
    warnings.push(warning2('The "preview.component" property is deprecated. Use "components.preview" instead.'));
  }
  if (type == null ? void 0 : type.diffComponent) {
    warnings.push(warning2('The "diffComponent" property is deprecated. Use "components.diff" instead.'));
  }
  if ((_b4 = type == null ? void 0 : type.options) == null ? void 0 : _b4.editModal) {
    warnings.push(warning2('The "options.editModal" property is deprecated. Use "options.modal" instead.'));
  }
  if ((_c4 = type == null ? void 0 : type.options) == null ? void 0 : _c4.isHighlighted) {
    warnings.push(warning2('The "options.isHighlighted" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.'));
  }
  return warnings;
}
var common = (typeDef, visitorContext) => {
  return {
    ...typeDef,
    _problems: [...validateTypeName(typeDef.type, visitorContext), ...validateNonObjectFieldsProp(typeDef, visitorContext), ...validateDeprecatedProperties(typeDef)].filter(Boolean)
  };
};
var rootType = (typeDef, visitorContext) => {
  const hasName = Boolean(typeDef.name);
  if (!hasName && Object.keys(typeDef).length === 1) {
    return {
      ...typeDef,
      _problems: [error("Invalid/undefined type declaration, check declaration or the import/export of the schema type.", HELP_IDS.TYPE_INVALID)]
    };
  }
  const problems = [];
  if (looksLikeEsmModule(typeDef)) {
    problems.push(error("Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property", HELP_IDS.TYPE_IS_ESM_MODULE));
  } else if (!hasName) {
    problems.push(error("Missing type name", HELP_IDS.TYPE_MISSING_NAME));
  } else if (visitorContext.isReserved(typeDef.name)) {
    problems.push(error('Invalid type name: "'.concat(typeDef.name, '" is a reserved name.'), HELP_IDS.TYPE_NAME_RESERVED));
  }
  if (visitorContext.isDuplicate(typeDef.name)) {
    problems.push(error('Invalid type name: A type with name "'.concat(typeDef.name, '" is already defined in the schema.')));
  }
  problems.push(...validateComponent(typeDef));
  if ("title" in typeDef && typeof typeDef.title !== "string") {
    problems.push(warning2("Type title is not a string.", HELP_IDS.TYPE_TITLE_INVALID));
  }
  return {
    ...typeDef,
    _problems: problems
  };
};
function looksLikeEsmModule(typeDef) {
  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}
function normalizeToProp(typeDef) {
  if (Array.isArray(typeDef.to)) {
    return typeDef.to;
  }
  return typeDef.to ? [typeDef.to] : typeDef.to;
}
var VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
  const isValid2 = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name);
  return isValid2 || 'The provided dataset "'.concat(name, `" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`);
}
var crossDatasetReference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || (0, import_isPlainObject3.default)(typeDef.to);
  const normalizedTo = normalizeToProp(typeDef);
  const problems = (0, import_flatten.default)([isValidTo ? getDupes(normalizedTo, (t3) => "".concat(t3.name, ";").concat(t3.type)).map((dupes) => error("Found ".concat(dupes.length, ' members with same type, but not unique names "').concat(dupes[0].type, '" in reference. This makes it impossible to tell their values apart and you should consider naming them'), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)) : error('The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)]);
  if (isValidTo && normalizedTo.length === 0) {
    problems.push(error('The cross dataset reference type should define at least one referenced type. Please check the "to" property.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  }
  normalizedTo.forEach((crossDatasetTypeDef, index) => {
    if (!crossDatasetTypeDef.type) {
      problems.push(error("The referenced type at index ".concat(index, " must be named. Specify the name of the type you want to create references to."), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    if (!(0, import_isPlainObject3.default)(crossDatasetTypeDef.preview)) {
      problems.push(error('Missing required preview config for the referenced type "'.concat(crossDatasetTypeDef.type || "<unknown type>", '"'), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
  });
  if (typeof typeDef.dataset === "string") {
    const datasetValidation = isValidDatasetName(typeDef.dataset);
    if (datasetValidation !== true) {
      problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
  } else {
    problems.push(error("A cross dataset reference must specify a `dataset`", HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  }
  if (typeDef.studioUrl && typeof typeDef.studioUrl !== "function") {
    problems.push(error('The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  }
  problems.push(...getOptionErrors(typeDef));
  return {
    ...typeDef,
    _problems: problems
  };
};
function getOptionErrors(typeDef) {
  const {
    options
  } = typeDef;
  const problems = [];
  problems.push(...["filter", "filterParams"].filter((key2) => key2 in typeDef).map((key2) => error("`".concat(key2, "` is not allowed on a reference type definition - did you mean `options.").concat(key2, "`?"), HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION)));
  if (!options) {
    return problems;
  }
  if (!(0, import_isPlainObject3.default)(options)) {
    return problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS));
  }
  if (typeof options.filter === "function" && typeof options.filterParams !== "undefined") {
    return problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
  }
  if (typeof options.filter === "function" || !options.filter && !options.filterParams) {
    return problems;
  }
  if (typeof options.filter !== "string") {
    return problems.concat(error("If set, `filter` must be a string. Got ".concat(typeof options.filter)));
  }
  if (typeof options.filterParams !== "undefined" && !(0, import_isPlainObject3.default)(options.filterParams)) {
    return problems.concat(error("If set, `filterParams` must be an object."));
  }
  if (options.filterParams) {
    return problems.concat(Object.keys(options.filterParams).filter((key2) => key2.startsWith("__") || key2.startsWith("$")).map((key2) => error('Filter parameter cannot be prefixed with "$" or "__". Got '.concat(key2, '".'))));
  }
  return problems;
}
var typeVisitors = {
  array,
  object,
  slug,
  file,
  image,
  block: validateBlockType,
  document: documentVisitor,
  reference,
  crossDatasetReference
};
var getNoopVisitor = (visitorContext) => (schemaDef) => ({
  name: "<unnamed_type_@_index_".concat(visitorContext.index, ">"),
  ...schemaDef,
  _problems: []
});
function combine() {
  for (var _len = arguments.length, visitors = new Array(_len), _key = 0; _key < _len; _key++) {
    visitors[_key] = arguments[_key];
  }
  return (schemaType, visitorContext) => {
    return visitors.reduce((result, visitor) => {
      const res = visitor(result, visitorContext);
      return {
        ...res,
        _problems: result._problems.concat(res._problems)
      };
    }, {
      _problems: [],
      ...schemaType
    });
  };
}
function validateSchema(schemaTypes) {
  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {
    const typeVisitor = schemaDef && schemaDef.type && typeVisitors[schemaDef.type] || getNoopVisitor(visitorContext);
    if (visitorContext.isRoot) {
      return combine(rootType, common, typeVisitor)(schemaDef, visitorContext);
    }
    return combine(common, typeVisitor)(schemaDef, visitorContext);
  });
}
var ACTIONS_FLAG = "__experimental_actions";
var DEFAULT_ACTIONS = ["create", "update", "delete", "publish"];
var VALID_ACTIONS = DEFAULT_ACTIONS;
var readActions = (schemaType) => {
  return ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS;
};
var validateActions = (typeName, actions) => {
  if (!Array.isArray(actions)) {
    throw new Error("The value of <type>.".concat(ACTIONS_FLAG, " should be an array with any of the actions ").concat(VALID_ACTIONS.join(", ")));
  }
  const invalid = (0, import_difference2.default)(actions, VALID_ACTIONS);
  if (invalid.length > 0) {
    throw new Error("Invalid action".concat(invalid.length > 1 ? "s" : "", ' configured for schema type "').concat(typeName, '": ').concat(invalid.join(", "), ". Valid actions are: ").concat(VALID_ACTIONS.join(", ")));
  }
  return actions;
};
var resolveEnabledActions = (schemaType) => validateActions(schemaType.name, readActions(schemaType));
var isActionEnabled = (schemaType, action) => resolveEnabledActions(schemaType).includes(action);

// node_modules/sanity/lib/index.esm.js
var import_cloneDeep = __toESM(require_cloneDeep());
var import_get3 = __toESM(require_get());
var import_isPlainObject5 = __toESM(require_isPlainObject());
init_format();
var import_flatten5 = __toESM(require_flatten());
var import_uniqBy2 = __toESM(require_uniqBy());
var import_memoize = __toESM(require_memoize());

// node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug)
      return null;
    if (typeof args[0] === "string")
      args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events2, listener) {
    events2.split(" ").forEach((event) => {
      this.observers[event] = this.observers[event] || [];
      this.observers[event].push(listener);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event])
      return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event] = this.observers[event].filter((l) => l !== listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = [].concat(this.observers[event]);
      cloned.forEach((observer) => {
        observer(...args);
      });
    }
    if (this.observers["*"]) {
      const cloned = [].concat(this.observers["*"]);
      cloned.forEach((observer) => {
        observer.apply(observer, [event, ...args]);
      });
    }
  }
};
function defer2() {
  let res;
  let rej;
  const promise2 = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object2) {
  if (object2 == null)
    return "";
  return "" + object2;
}
function copy(a, s, t3) {
  a.forEach((m2) => {
    if (s[m2])
      t3[m2] = s[m2];
  });
}
function getLastOfPath(object2, path2, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object2 || typeof object2 === "string";
  }
  const stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    const key2 = cleanKey(stack.shift());
    if (!object2[key2] && Empty)
      object2[key2] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object2, key2)) {
      object2 = object2[key2];
    } else {
      object2 = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object2,
    k: cleanKey(stack.shift())
  };
}
function setPath(object2, path2, newValue) {
  const {
    obj,
    k
  } = getLastOfPath(object2, path2, Object);
  obj[k] = newValue;
}
function pushPath(object2, path2, newValue, concat2) {
  const {
    obj,
    k
  } = getLastOfPath(object2, path2, Object);
  obj[k] = obj[k] || [];
  if (concat2)
    obj[k] = obj[k].concat(newValue);
  if (!concat2)
    obj[k].push(newValue);
}
function getPath(object2, path2) {
  const {
    obj,
    k
  } = getLastOfPath(object2, path2);
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key2) {
  const value = getPath(data, key2);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key2);
}
function deepExtend(target, source, overwrite) {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
}
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key2, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0)
    return true;
  const r2 = new RegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r2.test(key2);
  if (!matched) {
    const ki = key2.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key2.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path2])
    return obj[path2];
  const paths = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      let j = 2;
      let p = paths.slice(i, i + j).join(keySeparator);
      let mix2 = current[p];
      while (mix2 === void 0 && paths.length > i + j) {
        j++;
        p = paths.slice(i, i + j).join(keySeparator);
        mix2 = current[p];
      }
      if (mix2 === void 0)
        return void 0;
      if (mix2 === null)
        return null;
      if (path2.endsWith(p)) {
        if (typeof mix2 === "string")
          return mix2;
        if (p && typeof mix2[p] === "string")
          return mix2[p];
      }
      const joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix2, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
function getCleanedCode(code) {
  if (code && code.indexOf("_") > 0)
    return code.replace("_", "-");
  return code;
}
var ResourceStore = class extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2 = [lng, ns];
    if (key2 && typeof key2 !== "string")
      path2 = path2.concat(key2);
    if (key2 && typeof key2 === "string")
      path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    }
    const result = getPath(this.data, path2);
    if (result || !ignoreJSONStructure || typeof key2 !== "string")
      return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key2, keySeparator);
  }
  addResource(lng, ns, key2, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key2)
      path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent)
      this.emit("added", lng, ns, key2, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources) {
      if (typeof resources[m2] === "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]")
        this.addResource(lng, ns, m2, resources[m2], {
          silent: true
        });
    }
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns)
      ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1")
      return {
        ...{},
        ...this.getResource(lng, ns)
      };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key2, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor])
        value = this.processors[processor].process(value, key2, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = class _Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng)
      this.language = lng;
  }
  exists(key2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key2 === void 0 || key2 === null) {
      return false;
    }
    const resolved = this.resolve(key2, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key2, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0)
      nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces2 = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key2.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key2, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key2.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key: key2,
          namespaces: namespaces2
        };
      }
      const parts = key2.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
        namespaces2 = parts.shift();
      key2 = parts.join(keySeparator);
    }
    if (typeof namespaces2 === "string")
      namespaces2 = [namespaces2];
    return {
      key: key2,
      namespaces: namespaces2
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object")
      options = {
        ...options
      };
    if (!options)
      options = {};
    if (keys === void 0 || keys === null)
      return "";
    if (!Array.isArray(keys))
      keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key: key2,
      namespaces: namespaces2
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces2[namespaces2.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key2}`,
            usedKey: key2,
            exactUsedKey: key2,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key2}`;
      }
      if (returnDetails) {
        return {
          res: key2,
          usedKey: key2,
          exactUsedKey: key2,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key2;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key2;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key2;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces2
        }) : `key '${key2} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = resType === "[object Array]";
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in res) {
          if (Object.prototype.hasOwnProperty.call(res, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            copy2[m2] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces2
              }
            });
            if (copy2[m2] === deepKey)
              copy2[m2] = res[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
      res = res.join(joinArrays);
      if (res)
        res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = _Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key2;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key2, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key2, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res)
            this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              this.pluralResolver.getSuffixes(language, options).forEach((suffix) => {
                send([language], key2 + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key2, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key2 && this.options.appendNamespaceToMissingKey)
        res = `${namespace}:${key2}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key2}` : key2, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key2, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation)
        this.interpolator.init({
          ...options,
          ...{
            interpolation: {
              ...this.options.interpolation,
              ...options.interpolation
            }
          }
        });
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables)
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft)
          options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
        options.lng = resolved.usedLng;
      if (options.nest !== false)
        res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key2[0]}`);
            return null;
          }
          return _this.translate(...args, key2);
        }, options);
      if (options.interpolation)
        this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key2, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys === "string")
      keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found))
        return;
      const extracted = this.extractFromKey(k, options);
      const key2 = extracted.key;
      usedKey = key2;
      let namespaces2 = extracted.namespaces;
      if (this.options.fallbackNS)
        namespaces2 = namespaces2.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces2.forEach((ns) => {
        if (this.isValidLookup(found))
          return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found))
            return;
          usedLng = code;
          const finalKeys = [key2];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key2, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling)
              pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key2 + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key2 + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key2 + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key2}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource)
      return this.i18nFormat.getResource(code, ns, key2, options);
    return this.resourceStore.getResource(code, ns, key2, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key2 of optionsKeys) {
        delete data[key2];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
function capitalize2(string3) {
  return string3.charAt(0).toUpperCase() + string3.slice(1);
}
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return null;
    const p = code.split("-");
    if (p.length === 2)
      return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x")
      return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (typeof code === "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1)
          p[1] = capitalize2(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2)
          p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2)
          p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1)
          p[1] = capitalize2(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1)
          p[2] = capitalize2(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes)
      return null;
    let found;
    codes.forEach((code) => {
      if (found)
        return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
        found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found)
          return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly))
          return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
            return;
          if (supportedLng.indexOf(lngOnly) === 0)
            return supportedLng;
        });
      });
    }
    if (!found)
      found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks)
      return [];
    if (typeof fallbacks === "function")
      fallbacks = fallbacks(code);
    if (typeof fallbacks === "string")
      fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
      return fallbacks;
    if (!code)
      return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found)
      found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found)
      found = fallbacks[this.formatLanguageCode(code)];
    if (!found)
      found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found)
      found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c)
        return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly")
        addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
        addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly")
        addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === "string") {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0)
        addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function(n) {
    return Number(n > 1);
  },
  2: function(n) {
    return Number(n != 1);
  },
  3: function(n) {
    return 0;
  },
  4: function(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function(n) {
    return Number(n >= 2);
  },
  10: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function(n) {
    return Number(n !== 0);
  },
  14: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var nonIntlVersions = ["v1", "v2", "v3"];
var intlVersions = ["v4"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  const rules = {};
  sets.forEach((set4) => {
    set4.lngs.forEach((l) => {
      rules[l] = {
        numbers: set4.nr,
        plurals: _rulesPluralsTypes[set4.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = class {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        return new Intl.PluralRules(getCleanedCode(code), {
          type: options.ordinal ? "ordinal" : "cardinal"
        });
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key2}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number2) => this.getSuffix(code, number2, options));
  }
  getSuffix(code, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
      }
      return this.getSuffixRetroCompatible(rule, count2);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count2) {
    const idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1)
        return "";
      if (typeof suffix === "number")
        return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
function deepFindWithDefaults(data, defaultData, key2) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key2);
  if (!path2 && ignoreJSONStructure && typeof key2 === "string") {
    path2 = deepFind(data, key2, keySeparator);
    if (path2 === void 0)
      path2 = deepFind(defaultData, key2, keySeparator);
  }
  return path2;
}
var Interpolator = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation)
      options.interpolation = {
        escapeValue: true
      };
    const iOpts = options.interpolation;
    this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
    this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
    this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
    this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options)
      this.init(this.options);
  }
  resetRegExp() {
    const regexpStr = `${this.prefix}(.+?)${this.suffix}`;
    this.regexp = new RegExp(regexpStr, "g");
    const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
    this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
    const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
    this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
  }
  interpolate(str, data, lng, options) {
    let match4;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function regexSafe(val) {
      return val.replace(/\$/g, "$$$$");
    }
    const handleFormat = (key2) => {
      if (key2.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key2, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key2
        }) : path2;
      }
      const p = key2.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match4 = todo.regex.exec(str)) {
        const matchedVar = match4[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match4, options);
            value = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match4[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match4[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match4[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match4;
    let value;
    let clonedOptions;
    function handleHasOptions(key2, inheritedOptions) {
      const sep = this.nestingOptionsSeparator;
      if (key2.indexOf(sep) < 0)
        return key2;
      const c = key2.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key2 = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions)
          clonedOptions = {
            ...inheritedOptions,
            ...clonedOptions
          };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key2}`, e2);
        return `${key2}${sep}${optionsString}`;
      }
      delete clonedOptions.defaultValue;
      return key2;
    }
    while (match4 = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match4[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match4[1])) {
        const r2 = match4[1].split(this.formatSeparator).map((elem) => elem.trim());
        match4[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match4[1].trim(), clonedOptions), clonedOptions);
      if (value && match4[0] === str && typeof value !== "string")
        return value;
      if (typeof value !== "string")
        value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match4[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match4[1].trim()
        }), value.trim());
      }
      str = str.replace(match4[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (!opt)
          return;
        const [key2, ...rest] = opt.split(":");
        const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key2.trim()])
          formatOptions[key2.trim()] = val;
        if (val === "false")
          formatOptions[key2.trim()] = false;
        if (val === "true")
          formatOptions[key2.trim()] = true;
        if (!isNaN(val))
          formatOptions[key2.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  const cache2 = {};
  return function invokeFormatter(val, lng, options) {
    const key2 = lng + JSON.stringify(options);
    let formatter = cache2[key2];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache2[key2] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format4, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format4.split(this.formatSeparator);
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
function removePending(q, name) {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}
var Connector = class extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces2, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces2.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0)
          ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0)
            pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0)
            pending[name] = true;
          if (toLoad[name] === void 0)
            toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0)
            toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces)
        toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err)
      this.emit("failedLoading", lng, ns, err);
    if (data) {
      this.store.addResourceBundle(lng, ns, data);
    }
    this.state[name] = err ? -1 : 2;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err)
        q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l])
            loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0)
                loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length)
      return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string")
      languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces2 === "string")
      namespaces2 = [namespaces2];
    const toLoad = this.queueLoad(languages, namespaces2, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length)
        callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces2, callback) {
    this.prepareLoading(languages, namespaces2, {}, callback);
  }
  reload(languages, namespaces2, callback) {
    this.prepareLoading(languages, namespaces2, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err)
        this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data)
        this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key2, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key2}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key2 === void 0 || key2 === null || key2 === "")
      return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key2, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key2, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key2, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0])
      return;
    this.store.addResource(languages[0], namespace, key2, fallbackValue);
  }
};
function get3() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key2) => {
          ret[key2] = options[key2];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value, format4, lng, options) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function noop2() {
}
function bindMemberFunctions(inst) {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = class _I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get3();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject)
        return null;
      if (typeof ClassOrObject === "function")
        return new ClassOrObject();
      return ClassOrObject;
    }
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init)
          s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init)
          s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init)
          m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback)
      callback = noop2;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev")
        this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer2();
    const load = () => {
      const finish = (err, t3) => {
        if (this.isInitialized && !this.initializedStoreOnce)
          this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone)
          this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t3);
        callback(err, t3);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function")
      usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng)
          return;
        if (lng === "cimode")
          return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode")
            return;
          if (toLoad.indexOf(l) < 0)
            toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language)
          this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer2();
    if (!lngs)
      lngs = this.languages;
    if (!ns)
      ns = this.options.ns;
    if (!callback)
      callback = noop2;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages)
      return;
    if (["cimode", "dev"].indexOf(l) > -1)
      return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1)
        continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer2();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback)
        callback(err, function() {
          return _this2.t(...arguments);
        });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector)
        lngs = [];
      const l = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language)
          this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
          this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key2, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key2, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key2)) {
        resultKey = key2.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key2}` : key2;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0)
        return preResult;
    }
    if (this.hasResourceBundle(lng, ns))
      return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
      return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer2();
    if (!this.options.ns) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    if (typeof ns === "string")
      ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0)
        this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer2();
    if (typeof lngs === "string")
      lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0);
    if (!newLngs.length) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng)
      lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng)
      return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get3());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new _I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore)
      delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone3 = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone3.logger = clone3.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone3[m2] = this[m2];
    });
    clone3.services = {
      ...this.services
    };
    clone3.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    if (forkResourceStore) {
      clone3.store = new ResourceStore(this.store.data, mergedOptions);
      clone3.services.resourceStore = clone3.store;
    }
    clone3.translator = new Translator(clone3.services, mergedOptions);
    clone3.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone3.emit(event, ...args);
    });
    clone3.init(mergedOptions, callback);
    clone3.translator.options = mergedOptions;
    clone3.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    return clone3;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t2 = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

// node_modules/sanity/lib/index.esm.js
init_observableCallback();
init_history();
var import_with_selector = __toESM(require_with_selector());
var import_escapeRegExp = __toESM(require_escapeRegExp());
init_esm4();
var import_image_url = __toESM(require_image_url_umd());
init_asset_utils_esm();
var import_uniqueId = __toESM(require_uniqueId());
var import_capitalize2 = __toESM(require_capitalize());
var import_compact2 = __toESM(require_compact());
var import_intersection2 = __toESM(require_intersection());
var import_keyBy = __toESM(require_keyBy());
var import_partition2 = __toESM(require_partition());
var import_toLower = __toESM(require_toLower());
var import_union = __toESM(require_union());
var import_uniq4 = __toESM(require_uniq());
var import_words = __toESM(require_words());
var import_flow = __toESM(require_flow());
var import_trim = __toESM(require_trim());
init_uuid();
var import_omit4 = __toESM(require_omit());

// node_modules/@sanity/logos/dist/index.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react48 = __toESM(require_react());
var GroqLogo = (0, import_react48.forwardRef)(function GroqLogo2(props2, ref) {
  return (0, import_jsx_runtime4.jsxs)("svg", {
    "data-sanity-icon": "groq-logo",
    height: "1em",
    viewBox: "0 0 304 64",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props2,
    ref,
    children: [(0, import_jsx_runtime4.jsx)("path", {
      d: "M32 0L0 32H32V0Z",
      fill: hues.magenta[400].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M32 32H0L32 64V32Z",
      fill: hues.green[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M64 32H32V64L64 32Z",
      fill: hues.purple[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M112 0L80 32H112V0Z",
      fill: hues.green[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M112 0H80V32L112 0Z",
      fill: hues.purple[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M112 32H80L112 64V32Z",
      fill: hues.yellow[200].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M144 64L112 32V64H144Z",
      fill: hues.blue[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M80 32V64H112L80 32Z",
      fill: hues.orange[400].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M112 0V32H144L112 0Z",
      fill: hues.magenta[400].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M192 0L160 32H192V0Z",
      fill: hues.yellow[200].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M192 32H160L192 64V32Z",
      fill: hues.orange[400].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M224 32H192V64L224 32Z",
      fill: hues.green[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M192 0V32H224L192 0Z",
      fill: hues.blue[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M272 0L240 32H272V0Z",
      fill: hues.purple[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M304 32L272 64H304V32Z",
      fill: hues.magenta[400].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M272 32H240L272 64V32Z",
      fill: hues.blue[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M304 32H272V64L304 32Z",
      fill: hues.yellow[200].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M272 0V32H304L272 0Z",
      fill: hues.green[300].hex
    })]
  });
});
var GroqMonogram = (0, import_react48.forwardRef)(function GroqMonogram2(props2, ref) {
  return (0, import_jsx_runtime4.jsxs)("svg", {
    "data-sanity-icon": "groq-monogram",
    width: "1em",
    height: "1em",
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props2,
    ref,
    children: [(0, import_jsx_runtime4.jsx)("rect", {
      width: "128",
      height: "128",
      rx: "8",
      fill: hues.green[950].hex
    }), (0, import_jsx_runtime4.jsx)("rect", {
      y: "32",
      width: "64",
      height: "64",
      fill: hues.green[800].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M64 32L32 64H64V32Z",
      fill: hues.magenta[400].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M64 64H32L64 96V64Z",
      fill: hues.green[300].hex
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M96 64H64V96L96 64Z",
      fill: hues.purple[300].hex
    })]
  });
});
var schemes = {
  light: [hues.red[200].hex, hues.red[300].hex, hues.red[500].hex],
  dark: [hues.gray[500].hex, hues.gray[300].hex, white.hex]
};
var SanityLogo = (0, import_react48.forwardRef)(function SanityLogo2(props2, ref) {
  const {
    dark,
    ...svgProps
  } = props2;
  const scheme = schemes[dark ? "dark" : "light"];
  return (0, import_jsx_runtime4.jsxs)("svg", {
    "data-sanity-icon": "sanity-logo",
    height: "1em",
    viewBox: "0 0 352 100",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...svgProps,
    ref,
    children: [(0, import_jsx_runtime4.jsx)("path", {
      d: "M311.14 57.234V80.0016H298.499V57.234",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M298.499 57.2341L319.889 20.0017H333.316L311.14 57.2341H298.499Z",
      fill: scheme[2]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M298.499 57.2341L276.515 20.0017H290.345L305.239 45.5161L298.499 57.2341Z",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M253.839 40.9625V80.0017H241.007V47.6275L253.839 40.9625Z",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M241.007 47.5944L273.538 30.9469L268.042 21.6519L241.007 34.8633V47.5944Z",
      fill: scheme[0]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M241.007 30.9469H221.404V20.0017H267.064L273.538 30.9469H253.839H241.007Z",
      fill: scheme[2]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M214.047 20.0017H201.311V80.0121H214.047V20.0017Z",
      fill: scheme[2]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M149.39 37.8712V80.0017H137.153V20.0017L149.39 37.8712Z",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M151.282 20.0017L178.231 60.9939V80.0017L137.153 20.0017H151.282Z",
      fill: scheme[2]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M178.231 57.9129V20.0017H190.467V80.0017H178.231V57.9129Z",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M82.1168 80.9834L112.102 65.3053L108.405 55.7303L88.6644 64.9362L82.1168 80.9834Z",
      fill: scheme[0]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M100.657 35.5422L82.1167 80.9834L72.5807 72.7745L94.6719 20.0017L100.657 35.5422Z",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M94.672 20.0017H107.312L130.69 80.0017H117.752L94.672 20.0017Z",
      fill: scheme[2]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M25.1347 26.926C25.1347 35.2811 30.3864 40.2524 40.9004 42.8738L52.0417 45.4117C61.9923 47.6571 68.0519 53.2341 68.0519 62.3203C68.1293 66.2787 66.8194 70.1429 64.3417 73.2654C64.3417 64.2002 59.5684 59.302 48.0551 56.3568L37.1158 53.913C28.3559 51.9495 21.5946 47.3647 21.5946 37.4952C21.5485 33.6839 22.7939 29.9658 25.1347 26.926",
      fill: scheme[2]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M57.4954 60.0957C62.2475 63.0827 64.3311 67.2602 64.3311 73.255C60.3977 78.2054 53.4875 80.9834 45.3655 80.9834C31.6941 80.9834 22.1262 74.3725 20 62.8842H33.1292C34.8196 68.1584 39.2952 70.6022 45.2698 70.6022C52.5626 70.6022 57.4104 66.7798 57.506 60.0748",
      fill: scheme[1]
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M31.9598 39.3124C29.7898 38.0455 28.0095 36.225 26.8079 34.0442C25.6062 31.8634 25.028 29.4036 25.1347 26.926C28.93 22.0174 35.5318 19.02 43.5794 19.02C57.506 19.02 65.5643 26.2472 67.5523 36.4195H54.9227C53.53 32.409 50.0431 29.2863 43.6858 29.2863C36.8926 29.2863 32.2575 33.1715 31.9917 39.3124",
      fill: scheme[1]
    })]
  });
});
var SANITY_MONOGRAM_COLOR = {
  bg1: hues.red[500].hex,
  bg2: hues.red[200].hex,
  fg: white.hex
};
var SanityMonogram = (0, import_react48.forwardRef)(function SanityMonogram2(props2, ref) {
  const {
    color: color3 = SANITY_MONOGRAM_COLOR,
    ...restProps
  } = props2;
  return (0, import_jsx_runtime4.jsxs)("svg", {
    "data-sanity-icon": "sanity-monogram",
    width: "1em",
    height: "1em",
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...restProps,
    ref,
    children: [(0, import_jsx_runtime4.jsx)("rect", {
      width: "128",
      height: "128",
      rx: "8",
      fill: color3.bg1
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M39.423 33.163C39.423 44.1615 46.3363 50.7056 60.1768 54.1564L74.843 57.4972C87.9418 60.453 95.9186 67.7945 95.9186 79.7554C96.0205 84.9662 94.2961 90.0531 91.0345 94.1635C91.0345 82.2301 84.751 75.7822 69.595 71.9052L55.1948 68.6882C43.6633 66.1035 34.7629 60.0681 34.7629 47.0761C34.7022 42.0589 36.3416 37.1644 39.423 33.163",
      fill: color3.fg
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M82.0221 76.827C88.2776 80.759 91.0206 86.2582 91.0206 94.1497C85.8426 100.666 76.7462 104.323 66.0545 104.323C48.0576 104.323 35.4626 95.6207 32.6637 80.4977H49.9468C52.172 87.4406 58.0636 90.6576 65.9285 90.6576C75.5287 90.6576 81.9102 85.6258 82.0361 76.7995",
      fill: color3.bg2
    }), (0, import_jsx_runtime4.jsx)("path", {
      d: "M48.4075 49.4682C45.551 47.8004 43.2074 45.404 41.6256 42.5332C40.0437 39.6624 39.2826 36.4244 39.4231 33.1629C44.4191 26.7013 53.1096 22.7556 63.7034 22.7556C82.0362 22.7556 92.6439 32.2693 95.2609 45.66H78.6355C76.8022 40.3807 72.2121 36.27 63.8434 36.27C54.9009 36.27 48.7993 41.3843 48.4495 49.4682",
      fill: color3.bg2
    })]
  });
});

// node_modules/@sanity/util/lib/content.esm.js
init_get_random_values_esm();
var hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function isDeepEmptyObject(value) {
  for (const key2 in value) {
    if (key2 === "_type" || key2 === "_key") {
      continue;
    }
    if (hasOwn(value, key2) && !isDeepEmpty(value[key2])) {
      return false;
    }
  }
  return true;
}
function isDeepEmptyArray(value) {
  for (let i = 0; i < value.length; i++) {
    if (!isDeepEmpty(value[i])) {
      return false;
    }
  }
  return true;
}
function isDeepEmpty(value) {
  if (value === void 0 || value === null) {
    return true;
  }
  const type = typeof value;
  if (Array.isArray(value)) {
    return isDeepEmptyArray(value);
  }
  if (type === "object") {
    return isDeepEmptyObject(value);
  }
  return false;
}
function isShallowEmptyObject(value) {
  for (const key2 in value) {
    if (key2 === "_type" || key2 === "_key") {
      continue;
    }
    if (hasOwn(value, key2) && value[key2] !== void 0) {
      return false;
    }
  }
  return true;
}
var getByteHexTable = (() => {
  let table;
  return () => {
    if (table) {
      return table;
    }
    table = [];
    for (let i = 0; i < 256; ++i) {
      table[i] = (i + 256).toString(16).substring(1);
    }
    return table;
  };
})();
function whatwgRNG() {
  let length2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  const rnds8 = new Uint8Array(length2);
  getRandomValues(rnds8);
  return rnds8;
}
function randomKey(length2) {
  const table = getByteHexTable();
  return whatwgRNG(length2).reduce((str, n) => str + table[n], "").slice(0, length2);
}
var toString2 = Object.prototype.toString;
function resolveJSType(val) {
  switch (toString2.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  if (typeof val == "object" && val && typeof val.length == "number") {
    try {
      if (typeof val.callee == "function") {
        return "arguments";
      }
    } catch (ex) {
      if (ex instanceof TypeError) {
        return "arguments";
      }
    }
  }
  if (val === null) {
    return "null";
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val && val.nodeType === 1) {
    return "element";
  }
  if (val === Object(val)) {
    return "object";
  }
  return typeof val;
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object") {
    return jsType;
  }
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}

// node_modules/@sanity/portable-text-editor/lib/index.esm.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react49 = __toESM(require_react());
init_esm5();
var import_debug3 = __toESM(require_browser3());
init_index_es2();
init_index_es();
var import_noop15 = __toESM(require_noop());
var import_omitBy2 = __toESM(require_omitBy());
var import_isUndefined2 = __toESM(require_isUndefined());
var import_get2 = __toESM(require_get());
var import_flatten3 = __toESM(require_flatten());
var import_isEqual2 = __toESM(require_isEqual());
var import_isObject = __toESM(require_isObject());
var import_isString = __toESM(require_isString());
var import_findIndex = __toESM(require_findIndex());
var import_omit3 = __toESM(require_omit());
var import_clone = __toESM(require_clone());
var import_uniq3 = __toESM(require_uniq());
var import_is_hotkey = __toESM(require_lib());

// node_modules/@sanity/block-tools/lib/index.esm.js
var import_flatten2 = __toESM(require_flatten());
init_get_random_values_esm();
var import_isEqual = __toESM(require_isEqual());
var import_uniq2 = __toESM(require_uniq());
function isRecord$12(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isPortableTextTextBlock2(value) {
  return isRecord$12(value) && typeof value._type === "string" && // block types can be named, so expect anything here.
  Array.isArray(value.children) && value.children.every((child) => isRecord$12(child)) && ("markDefs" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$12(def)) : false) && ("style" in value ? typeof value.style === "string" : true);
}
function isPortableTextSpan2(value) {
  return isRecord$12(value) && value._type === "span" && typeof value.text === "string" && ("marks" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark === "string") : true);
}
function isRecord4(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isObjectSchemaType2(type) {
  if (!isRecord4(type))
    return false;
  return type.jsonType === "object";
}
function isArraySchemaType2(type) {
  if (!isRecord4(type))
    return false;
  return type.jsonType === "array";
}
function isTitledListValue2(item) {
  return typeof item === "object" && item !== null && "title" in item && "value" in item;
}
function isSpanSchemaType2(type) {
  if (!isRecord4(type))
    return false;
  return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
function isBlockSchemaType2(type) {
  if (!isRecord4(type))
    return false;
  if (!Array.isArray(type.fields))
    return false;
  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField2);
  const maybeStyle = type.fields.find(isBlockStyleObjectField2);
  const maybeList = type.fields.find(isBlockListObjectField2);
  return isBlockChildrenObjectField2(maybeSpanChildren) && isBlockStyleObjectField2(maybeStyle) && isBlockListObjectField2(maybeList);
}
function isBlockStyleObjectField2(field) {
  if (!isRecord4(field))
    return false;
  if (field.name !== "style")
    return false;
  return isRecord4(field.type) && field.type.jsonType === "string";
}
function isBlockListObjectField2(field) {
  if (!isRecord4(field))
    return false;
  if (field.name !== "listItem")
    return false;
  return isRecord4(field.type) && field.type.jsonType === "string";
}
function isBlockChildrenObjectField2(field) {
  if (!isRecord4(field))
    return false;
  if (field.name !== "children")
    return false;
  if (!isArraySchemaType2(field.type))
    return false;
  return field.type.of.some(isSpanSchemaType2);
}
function findBlockType(type) {
  if (type.type) {
    return findBlockType(type.type);
  }
  if (type.name === "block") {
    return true;
  }
  return false;
}
function blockContentFeatures(blockContentType) {
  var _a4, _b4;
  if (!blockContentType) {
    throw new Error("Parameter 'blockContentType' required");
  }
  const blockType = blockContentType.of.find(findBlockType);
  if (!isBlockSchemaType2(blockType)) {
    throw new Error("'block' type is not defined in this schema (required).");
  }
  const ofType = (_b4 = (_a4 = blockType.fields.find(isBlockChildrenObjectField2)) == null ? void 0 : _a4.type) == null ? void 0 : _b4.of;
  if (!ofType) {
    throw new Error("No `of` declaration found for blocks `children` field");
  }
  const spanType = ofType.find((member) => member.name === "span");
  if (!spanType) {
    throw new Error("No `span` type found in `block` schema type `children` definition");
  }
  const inlineObjectTypes = ofType.filter((inlineType) => inlineType.name !== "span" && isObjectSchemaType2(inlineType));
  const blockObjectTypes = blockContentType.of.filter((memberType) => memberType.name !== blockType.name && isObjectSchemaType2(memberType));
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    annotations: resolveEnabledAnnotationTypes(spanType),
    lists: resolveEnabledListItems(blockType),
    types: {
      block: blockContentType,
      span: spanType,
      inlineObjects: inlineObjectTypes,
      blockObjects: blockObjectTypes
    }
  };
}
function resolveEnabledStyles(blockType) {
  const styleField = blockType.fields.find(isBlockStyleObjectField2);
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }
  const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options);
  if (textStyles.length === 0) {
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  }
  return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
  return spanType.annotations.map((annotation) => ({
    title: annotation.title,
    type: annotation,
    value: annotation.name,
    icon: annotation.icon
  }));
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  const listField = blockType.fields.find(isBlockListObjectField2);
  if (!listField) {
    throw new Error("A field with name 'list' is not defined in the block type (required).");
  }
  const listItems = getTitledListValuesFromEnumListOptions(listField.type.options);
  if (!listItems) {
    throw new Error("The list field need at least to be an empty array");
  }
  return listItems;
}
function getTitledListValuesFromEnumListOptions(options) {
  const list = options ? options.list : void 0;
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map((item) => isTitledListValue2(item) ? item : {
    title: item,
    value: item
  });
}
var toString3 = Object.prototype.toString;
function resolveJsType(val) {
  switch (toString3.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  if (val === null) {
    return "null";
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val && typeof val === "object" && "nodeType" in val && val.nodeType === 1) {
    return "element";
  }
  if (val === Object(val)) {
    return "object";
  }
  return typeof val;
}
function whatwgRNG2() {
  let length2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  const rnds8 = new Uint8Array(length2);
  getRandomValues(rnds8);
  return rnds8;
}
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substring(1);
}
function randomKey2(length2) {
  return whatwgRNG2(length2).reduce((str, n) => str + byteToHex[n], "").slice(0, length2);
}
var PRESERVE_WHITESPACE_TAGS = ["pre", "textarea", "code"];
var BLOCK_DEFAULT_STYLE = "normal";
var DEFAULT_BLOCK = Object.freeze({
  _type: "block",
  markDefs: [],
  style: BLOCK_DEFAULT_STYLE
});
var DEFAULT_SPAN = Object.freeze({
  _type: "span",
  marks: []
});
var HTML_BLOCK_TAGS = {
  p: DEFAULT_BLOCK,
  blockquote: {
    ...DEFAULT_BLOCK,
    style: "blockquote"
  }
};
var HTML_SPAN_TAGS = {
  span: {
    object: "text"
  }
};
var HTML_LIST_CONTAINER_TAGS = {
  ol: {
    object: null
  },
  ul: {
    object: null
  }
};
var HTML_HEADER_TAGS = {
  h1: {
    ...DEFAULT_BLOCK,
    style: "h1"
  },
  h2: {
    ...DEFAULT_BLOCK,
    style: "h2"
  },
  h3: {
    ...DEFAULT_BLOCK,
    style: "h3"
  },
  h4: {
    ...DEFAULT_BLOCK,
    style: "h4"
  },
  h5: {
    ...DEFAULT_BLOCK,
    style: "h5"
  },
  h6: {
    ...DEFAULT_BLOCK,
    style: "h6"
  }
};
var HTML_MISC_TAGS = {
  br: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE
  }
};
var HTML_DECORATOR_TAGS = {
  b: "strong",
  strong: "strong",
  i: "em",
  em: "em",
  u: "underline",
  s: "strike-through",
  strike: "strike-through",
  del: "strike-through",
  code: "code",
  sup: "sup",
  sub: "sub",
  ins: "ins",
  mark: "mark",
  small: "small"
};
var HTML_LIST_ITEM_TAGS = {
  li: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE,
    level: 1,
    listItem: "bullet"
  }
};
var ELEMENT_MAP = {
  ...HTML_BLOCK_TAGS,
  ...HTML_SPAN_TAGS,
  ...HTML_LIST_CONTAINER_TAGS,
  ...HTML_LIST_ITEM_TAGS,
  ...HTML_HEADER_TAGS,
  ...HTML_MISC_TAGS
};
(0, import_uniq2.default)(Object.values(ELEMENT_MAP).filter((tag) => "style" in tag).map((tag) => tag.style));
(0, import_uniq2.default)(Object.values(HTML_DECORATOR_TAGS));
var _XPathResult = {
  ANY_TYPE: 0,
  NUMBER_TYPE: 1,
  STRING_TYPE: 2,
  BOOLEAN_TYPE: 3,
  UNORDERED_NODE_ITERATOR_TYPE: 4,
  ORDERED_NODE_ITERATOR_TYPE: 5,
  UNORDERED_NODE_SNAPSHOT_TYPE: 6,
  ORDERED_NODE_SNAPSHOT_TYPE: 7,
  ANY_UNORDERED_NODE_TYPE: 8,
  FIRST_ORDERED_NODE_TYPE: 9
};
var preprocessWhitespace = (_, doc) => {
  function processNode(node) {
    var _a4, _b4;
    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(((_a4 = node.parentElement) == null ? void 0 : _a4.tagName.toLowerCase()) || "")) {
      node.textContent = ((_b4 = node.textContent) == null ? void 0 : _b4.replace(/\s\s+/g, " ").replace(/[\r\n]+/g, " ")) || "";
    } else {
      for (let i = 0; i < node.childNodes.length; i++) {
        processNode(node.childNodes[i]);
      }
    }
  }
  processNode(doc.body);
  return doc;
};
var unwantedWordDocumentPaths = ["/html/text()", "/html/head/text()", "/html/body/text()", "/html/body/ul/text()", "/html/body/ol/text()", "//comment()", "//style", "//xml", "//script", "//meta", "//link"];
var preprocessHTML = (html, doc) => {
  var _a4, _b4, _c4;
  const bodyTextNodes = doc.evaluate("/html/body/text()", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {
    const node = bodyTextNodes.snapshotItem(i);
    const text = node.textContent || "";
    if (text.replace(/[^\S\n]+$/g, "")) {
      const newNode = doc.createElement("span");
      newNode.appendChild(doc.createTextNode(text));
      (_a4 = node.parentNode) == null ? void 0 : _a4.replaceChild(newNode, node);
    } else {
      (_b4 = node.parentNode) == null ? void 0 : _b4.removeChild(node);
    }
  }
  const unwantedNodes = doc.evaluate(unwantedWordDocumentPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    if (!unwanted) {
      continue;
    }
    (_c4 = unwanted.parentNode) == null ? void 0 : _c4.removeChild(unwanted);
  }
  return doc;
};
var WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/;
var unwantedPaths = ["//o:p", "//span[@style='mso-list:Ignore']", "//span[@style='mso-list: Ignore']"];
var mappedPaths = ["//p[@class='MsoTocHeading']", "//p[@class='MsoTitle']", "//p[@class='MsoToaHeading']", "//p[@class='MsoSubtitle']", "//span[@class='MsoSubtleEmphasis']", "//span[@class='MsoIntenseEmphasis']"];
var elementMap = {
  MsoTocHeading: ["h3"],
  MsoTitle: ["h1"],
  MsoToaHeading: ["h2"],
  MsoSubtitle: ["h5"],
  MsoSubtleEmphasis: ["span", "em"],
  MsoIntenseEmphasis: ["span", "em", "strong"]
  // Remove cruft
};
function isWordHtml(html) {
  return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (html, doc) => {
  var _a4;
  if (!isWordHtml(html)) {
    return doc;
  }
  const unwantedNodes = doc.evaluate(unwantedPaths.join("|"), doc, (prefix) => {
    if (prefix === "o") {
      return "urn:schemas-microsoft-com:office:office";
    }
    return null;
  }, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    if (unwanted == null ? void 0 : unwanted.parentNode) {
      unwanted.parentNode.removeChild(unwanted);
    }
  }
  const mappedElements = doc.evaluate(mappedPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {
    const mappedElm = mappedElements.snapshotItem(i);
    const tags = elementMap[mappedElm.className];
    const text = new Text(mappedElm.textContent || "");
    if (!tags) {
      continue;
    }
    const parentElement = document.createElement(tags[0]);
    let parent = parentElement;
    let child = parentElement;
    tags.slice(1).forEach((tag) => {
      child = document.createElement(tag);
      parent.appendChild(child);
      parent = child;
    });
    child.appendChild(text);
    (_a4 = mappedElm == null ? void 0 : mappedElm.parentNode) == null ? void 0 : _a4.replaceChild(parentElement, mappedElm);
  }
  return doc;
};
var preprocessGDocs = (html, doc) => {
  var _a4;
  const gDocsRootNode = doc.evaluate('//b[contains(@id, "docs-internal-guid")]', doc, null, _XPathResult.ORDERED_NODE_ITERATOR_TYPE, null).iterateNext();
  if (gDocsRootNode) {
    const childNodes = doc.evaluate("//*", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {
      const elm = childNodes.snapshotItem(i);
      elm == null ? void 0 : elm.setAttribute("data-is-google-docs", "true");
    }
    (_a4 = doc.body.firstElementChild) == null ? void 0 : _a4.replaceWith(...Array.from(gDocsRootNode.childNodes));
    return doc;
  }
  return doc;
};
var preprocessors = [preprocessWhitespace, preprocessWord, preprocessGDocs, preprocessHTML];
function createRuleOptions(blockContentType) {
  const features2 = blockContentFeatures(blockContentType);
  const enabledBlockStyles = features2.styles.map((item) => item.value || item.title);
  const enabledSpanDecorators = features2.decorators.map((item) => item.value || item.title);
  const enabledBlockAnnotations = features2.annotations.map((item) => item.value || item.title || "");
  const enabledListTypes = features2.lists.map((item) => item.value || item.title || "");
  return {
    enabledBlockStyles,
    enabledSpanDecorators,
    enabledBlockAnnotations,
    enabledListTypes
  };
}
function tagName(el) {
  if (el && "tagName" in el) {
    return el.tagName.toLowerCase();
  }
  return void 0;
}
function preprocess(html, parseHtml) {
  const doc = parseHtml(normalizeHtmlBeforePreprocess(html));
  preprocessors.forEach((processor) => {
    processor(html, doc);
  });
  return doc;
}
function normalizeHtmlBeforePreprocess(html) {
  return html.trim();
}
function defaultParseHtml() {
  if (resolveJsType(DOMParser) === "undefined") {
    throw new Error("The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.");
  }
  return (html) => {
    return new DOMParser().parseFromString(html, "text/html");
  };
}
function flattenNestedBlocks(blocks2) {
  let depth = 0;
  const flattened = [];
  const traverse2 = (nodes) => {
    const toRemove = [];
    nodes.forEach((node) => {
      if (depth === 0) {
        flattened.push(node);
      }
      if (isPortableTextTextBlock2(node)) {
        if (depth > 0) {
          toRemove.push(node);
          flattened.push(node);
        }
        depth++;
        traverse2(node.children);
      }
      if (node._type === "__block") {
        toRemove.push(node);
        flattened.push(node.block);
      }
    });
    toRemove.forEach((node) => {
      nodes.splice(nodes.indexOf(node), 1);
    });
    depth--;
  };
  traverse2(blocks2);
  return flattened;
}
function nextSpan(block, index) {
  const next = block.children[index + 1];
  return next && next._type === "span" ? next : null;
}
function prevSpan(block, index) {
  const prev = block.children[index - 1];
  return prev && prev._type === "span" ? prev : null;
}
function isWhiteSpaceChar(text) {
  return ["", " "].includes(text);
}
function trimWhitespace(blocks2) {
  blocks2.forEach((block) => {
    if (!isPortableTextTextBlock2(block)) {
      return;
    }
    block.children.forEach((child, index) => {
      if (!isMinimalSpan(child)) {
        return;
      }
      const nextChild = nextSpan(block, index);
      const prevChild = prevSpan(block, index);
      if (index === 0) {
        child.text = child.text.replace(/^[^\S\n]+/g, "");
      }
      if (index === block.children.length - 1) {
        child.text = child.text.replace(/[^\S\n]+$/g, "");
      }
      if (/\s/.test(child.text.substring(child.text.length - 1)) && nextChild && isMinimalSpan(nextChild) && /\s/.test(nextChild.text.substring(0, 1))) {
        child.text = child.text.replace(/[^\S\n]+$/g, "");
      }
      if (/\s/.test(child.text.substring(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
        child.text = child.text.replace(/^[^\S\n]+/g, "");
      }
      if (!child.text) {
        block.children.splice(index, 1);
      }
      if (prevChild && (0, import_isEqual.default)(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
        prevChild.text += " ";
        block.children.splice(index, 1);
      } else if (nextChild && (0, import_isEqual.default)(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
        nextChild.text = " ".concat(nextChild.text);
        block.children.splice(index, 1);
      }
    });
  });
  return blocks2;
}
function ensureRootIsBlocks(blocks2) {
  return blocks2.reduce((memo5, node, i, original) => {
    if (node._type === "block") {
      memo5.push(node);
      return memo5;
    }
    if (node._type === "__block") {
      memo5.push(node.block);
      return memo5;
    }
    const lastBlock = memo5[memo5.length - 1];
    if (i > 0 && !isPortableTextTextBlock2(original[i - 1]) && isPortableTextTextBlock2(lastBlock)) {
      lastBlock.children.push(node);
      return memo5;
    }
    const block = {
      ...DEFAULT_BLOCK,
      children: [node]
    };
    memo5.push(block);
    return memo5;
  }, []);
}
function isNodeList(node) {
  return Object.prototype.toString.call(node) == "[object NodeList]";
}
function isMinimalSpan(node) {
  return node._type === "span";
}
function isMinimalBlock(node) {
  return node._type === "block";
}
function isPlaceholderDecorator(node) {
  return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
  return node._type === "__annotation";
}
function isElement2(node) {
  return node.nodeType === 1;
}
function resolveListItem(listNodeTagName, enabledListTypes) {
  if (listNodeTagName === "ul" && enabledListTypes.includes("bullet")) {
    return "bullet";
  }
  if (listNodeTagName === "ol" && enabledListTypes.includes("number")) {
    return "number";
  }
  return void 0;
}
function createHTMLRules(blockContentType, options) {
  return [
    // Text nodes
    {
      deserialize(el) {
        if (tagName(el) === "pre") {
          return void 0;
        }
        const isValidWhiteSpace = el.nodeType === 3 && (el.textContent || "").replace(/[\r\n]/g, " ").replace(/\s\s+/g, " ") === " " && el.nextSibling && el.nextSibling.nodeType !== 3 && el.previousSibling && el.previousSibling.nodeType !== 3;
        const isValidText = (isValidWhiteSpace || el.textContent !== " ") && tagName(el.parentNode) !== "body";
        if (el.nodeName === "#text" && isValidText) {
          return {
            ...DEFAULT_SPAN,
            marks: [],
            text: (el.textContent || "").replace(/\s\s+/g, " ")
          };
        }
        return void 0;
      }
    },
    // Pre element
    {
      deserialize(el) {
        if (tagName(el) !== "pre") {
          return void 0;
        }
        const isCodeEnabled = options.enabledBlockStyles.includes("code");
        return {
          _type: "block",
          style: "normal",
          markDefs: [],
          children: [{
            ...DEFAULT_SPAN,
            marks: isCodeEnabled ? ["code"] : [],
            text: el.textContent || ""
          }]
        };
      }
    },
    // Blockquote element
    {
      deserialize(el, next) {
        if (tagName(el) !== "blockquote") {
          return void 0;
        }
        const blocks2 = {
          ...HTML_BLOCK_TAGS,
          ...HTML_HEADER_TAGS
        };
        delete blocks2.blockquote;
        const children = [];
        el.childNodes.forEach((node, index) => {
          if (node.nodeType === 1 && Object.keys(blocks2).includes(node.localName.toLowerCase())) {
            if (!el.ownerDocument) {
              return;
            }
            const span = el.ownerDocument.createElement("span");
            span.appendChild(el.ownerDocument.createTextNode("\r"));
            node.childNodes.forEach((cn) => {
              span.appendChild(cn.cloneNode(true));
            });
            if (index !== el.childNodes.length) {
              span.appendChild(el.ownerDocument.createTextNode("\r"));
            }
            children.push(span);
          } else {
            children.push(node);
          }
        });
        return {
          _type: "block",
          style: "blockquote",
          markDefs: [],
          children: next(children)
        };
      }
    },
    // Block elements
    {
      deserialize(el, next) {
        const blocks2 = {
          ...HTML_BLOCK_TAGS,
          ...HTML_HEADER_TAGS
        };
        const tag = tagName(el);
        let block = tag ? blocks2[tag] : void 0;
        if (!block) {
          return void 0;
        }
        if (el.parentNode && tagName(el.parentNode) === "li") {
          return next(el.childNodes);
        }
        if (!options.enabledBlockStyles.includes(block.style)) {
          block = DEFAULT_BLOCK;
        }
        return {
          ...block,
          children: next(el.childNodes)
        };
      }
    },
    // Ignore span tags
    {
      deserialize(el, next) {
        const tag = tagName(el);
        if (!tag || !(tag in HTML_SPAN_TAGS)) {
          return void 0;
        }
        return next(el.childNodes);
      }
    },
    // Ignore div tags
    {
      deserialize(el, next) {
        const div = tagName(el) === "div";
        if (!div) {
          return void 0;
        }
        return next(el.childNodes);
      }
    },
    // Ignore list containers
    {
      deserialize(el, next) {
        const tag = tagName(el);
        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {
          return void 0;
        }
        return next(el.childNodes);
      }
    },
    // Deal with br's
    {
      deserialize(el) {
        if (tagName(el) === "br") {
          return {
            ...DEFAULT_SPAN,
            text: "\n"
          };
        }
        return void 0;
      }
    },
    // Deal with list items
    {
      deserialize(el, next, block) {
        const tag = tagName(el);
        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0;
        const parentTag = tagName(el.parentNode) || "";
        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {
          return void 0;
        }
        const enabledListItem = resolveListItem(parentTag, options.enabledListTypes);
        if (!enabledListItem) {
          return block({
            _type: "block",
            children: next(el.childNodes)
          });
        }
        listItem.listItem = enabledListItem;
        return {
          ...listItem,
          children: next(el.childNodes)
        };
      }
    },
    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize
    {
      deserialize(el, next) {
        const decorator = HTML_DECORATOR_TAGS[tagName(el) || ""];
        if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {
          return void 0;
        }
        return {
          _type: "__decorator",
          name: decorator,
          children: next(el.childNodes)
        };
      }
    },
    // Special case for hyperlinks, add annotation (if allowed by schema),
    // If not supported just write out the link text and href in plain text.
    {
      deserialize(el, next) {
        if (tagName(el) != "a") {
          return void 0;
        }
        const linkEnabled = options.enabledBlockAnnotations.includes("link");
        const href = isElement2(el) && el.getAttribute("href");
        if (!href) {
          return next(el.childNodes);
        }
        let markDef;
        if (linkEnabled) {
          markDef = {
            _key: randomKey2(12),
            _type: "link",
            href
          };
          return {
            _type: "__annotation",
            markDef,
            children: next(el.childNodes)
          };
        }
        return el.appendChild(el.ownerDocument.createTextNode(" (".concat(href, ")"))) && next(el.childNodes);
      }
    }
  ];
}
var LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
function isEmphasis(el) {
  const style = isElement2(el) && el.getAttribute("style");
  return /font-style:italic/.test(style || "");
}
function isStrong(el) {
  const style = isElement2(el) && el.getAttribute("style");
  return /font-weight:700/.test(style || "");
}
function isGoogleDocs(el) {
  return isElement2(el) && Boolean(el.getAttribute("data-is-google-docs"));
}
function getListItemStyle$1(el) {
  const parentTag = tagName(el.parentNode);
  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {
    return void 0;
  }
  return tagName(el.parentNode) === "ul" ? "bullet" : "number";
}
function getListItemLevel$1(el) {
  let level = 0;
  if (tagName(el) === "li") {
    let parentNode = el.parentNode;
    while (parentNode) {
      const parentTag = tagName(parentNode);
      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {
        level++;
      }
      parentNode = parentNode.parentNode;
    }
  } else {
    level = 1;
  }
  return level;
}
var blocks = {
  ...HTML_BLOCK_TAGS,
  ...HTML_HEADER_TAGS
};
function getBlockStyle(el, enabledBlockStyles) {
  const childTag = tagName(el.firstChild);
  const block = childTag && blocks[childTag];
  if (!block) {
    return BLOCK_DEFAULT_STYLE;
  }
  if (!enabledBlockStyles.includes(block.style)) {
    return BLOCK_DEFAULT_STYLE;
  }
  return block.style;
}
function createGDocsRules(_blockContentType, options) {
  return [{
    deserialize(el) {
      if (isElement2(el) && tagName(el) === "span" && isGoogleDocs(el)) {
        const span = {
          ...DEFAULT_SPAN,
          marks: [],
          text: el.textContent
        };
        if (isStrong(el)) {
          span.marks.push("strong");
        }
        if (isEmphasis(el)) {
          span.marks.push("em");
        }
        return span;
      }
      return void 0;
    }
  }, {
    deserialize(el, next) {
      var _a4;
      if (tagName(el) === "li" && isGoogleDocs(el)) {
        return {
          ...DEFAULT_BLOCK,
          listItem: getListItemStyle$1(el),
          level: getListItemLevel$1(el),
          style: getBlockStyle(el, options.enabledBlockStyles),
          children: next(((_a4 = el.firstChild) == null ? void 0 : _a4.childNodes) || [])
        };
      }
      return void 0;
    }
  }];
}
function getListItemStyle(el) {
  const style = isElement2(el) && el.getAttribute("style");
  if (!style) {
    return void 0;
  }
  if (!style.match(/lfo\d+/)) {
    return void 0;
  }
  return style.match("lfo1") ? "bullet" : "number";
}
function getListItemLevel(el) {
  const style = isElement2(el) && el.getAttribute("style");
  if (!style) {
    return void 0;
  }
  const levelMatch = style.match(/level\d+/);
  if (!levelMatch) {
    return void 0;
  }
  const [level] = levelMatch[0].match(/\d/) || [];
  const levelNum = level ? parseInt(level, 10) : 1;
  return levelNum || 1;
}
function isWordListElement(el) {
  return isElement2(el) && el.className ? el.className === "MsoListParagraphCxSpFirst" || el.className === "MsoListParagraphCxSpMiddle" || el.className === "MsoListParagraphCxSpLast" : false;
}
function createWordRules() {
  return [{
    deserialize(el, next) {
      if (tagName(el) === "p" && isWordListElement(el)) {
        return {
          ...DEFAULT_BLOCK,
          listItem: getListItemStyle(el),
          level: getListItemLevel(el),
          style: BLOCK_DEFAULT_STYLE,
          children: next(el.childNodes)
        };
      }
      return void 0;
    }
  }];
}
function createRules2(blockContentType, options) {
  return [...createWordRules(), ...createGDocsRules(blockContentType, options), ...createHTMLRules(blockContentType, options)];
}
var HtmlDeserializer = class {
  /**
   * Create a new serializer respecting a Sanity block content type's schema
   *
   * @param blockContentType - Schema type for array containing _at least_ a block child type
   * @param options - Options for the deserialization process
   */
  constructor(blockContentType) {
    var _this = this;
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this._markDefs = [];
    this.deserialize = (html) => {
      this._markDefs = [];
      const {
        parseHtml: parseHtml2
      } = this;
      const fragment = parseHtml2(html);
      const children = Array.from(fragment.childNodes);
      const blocks2 = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))));
      if (this._markDefs.length > 0) {
        blocks2.filter((block) => block._type === "block").forEach((block) => {
          block.markDefs = block.markDefs || [];
          block.markDefs = block.markDefs.concat(this._markDefs.filter((def) => {
            return (0, import_flatten2.default)(block.children.map((child) => child.marks || [])).includes(def._key);
          }));
        });
      }
      const type = this.blockContentType.of.find(findBlockType);
      if (!type) {
        return blocks2;
      }
      return blocks2.map((block) => {
        if (block._type === "block") {
          block._type = type.name;
        }
        return block;
      });
    };
    this.deserializeElements = function() {
      let elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let nodes = [];
      elements.forEach((element) => {
        nodes = nodes.concat(_this.deserializeElement(element));
      });
      return nodes;
    };
    this.deserializeElement = (element) => {
      var _a4, _b4;
      const next = (elements) => {
        if (isNodeList(elements)) {
          return this.deserializeElements(Array.from(elements));
        }
        if (Array.isArray(elements)) {
          return this.deserializeElements(elements);
        }
        if (!elements) {
          return void 0;
        }
        return this.deserializeElement(elements);
      };
      const block = (props2) => {
        return {
          _type: "__block",
          block: props2
        };
      };
      let node;
      for (let i = 0; i < this.rules.length; i++) {
        const rule = this.rules[i];
        if (!rule.deserialize) {
          continue;
        }
        const ret = rule.deserialize(element, next, block);
        const type = resolveJsType(ret);
        if (type !== "array" && type !== "object" && type !== "null" && type !== "undefined") {
          throw new Error('A rule returned an invalid deserialized representation: "'.concat(node, '".'));
        }
        if (ret === void 0) {
          continue;
        } else if (ret === null) {
          throw new Error("Deserializer rule returned `null`");
        } else if (Array.isArray(ret)) {
          node = ret;
        } else if (isPlaceholderDecorator(ret)) {
          node = this.deserializeDecorator(ret);
        } else if (isPlaceholderAnnotation(ret)) {
          node = this.deserializeAnnotation(ret);
        } else {
          node = ret;
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && "listItem" in ret) {
          let parent = (_a4 = element.parentNode) == null ? void 0 : _a4.parentNode;
          while (parent && tagName(parent) === "li") {
            parent = (_b4 = parent.parentNode) == null ? void 0 : _b4.parentNode;
            ret.level = ret.level ? ret.level + 1 : 1;
          }
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === "blockquote") {
          ret.children.forEach((child, index) => {
            if (isMinimalSpan(child) && child.text === "\r") {
              child.text = "\n\n";
              if (index === 0 || index === ret.children.length - 1) {
                ret.children.splice(index, 1);
              }
            }
          });
        }
        break;
      }
      return node || next(element.childNodes) || [];
    };
    this.deserializeDecorator = (decorator) => {
      const {
        name
      } = decorator;
      const applyDecorator = (node) => {
        if (isPlaceholderDecorator(node)) {
          return this.deserializeDecorator(node);
        } else if (isMinimalSpan(node)) {
          node.marks = node.marks || [];
          if (node.text.trim()) {
            node.marks.unshift(name);
          }
        } else if ("children" in node && Array.isArray(node.children)) {
          const block = node;
          block.children = block.children.map(applyDecorator);
        }
        return node;
      };
      return decorator.children.reduce((children, node) => {
        const ret = applyDecorator(node);
        if (Array.isArray(ret)) {
          return children.concat(ret);
        }
        children.push(ret);
        return children;
      }, []);
    };
    this.deserializeAnnotation = (annotation) => {
      const {
        markDef
      } = annotation;
      this._markDefs.push(markDef);
      const applyAnnotation = (node) => {
        if (isPlaceholderAnnotation(node)) {
          return this.deserializeAnnotation(node);
        } else if (isMinimalSpan(node)) {
          node.marks = node.marks || [];
          if (node.text.trim()) {
            node.marks.unshift(markDef._key);
          }
        } else if ("children" in node && Array.isArray(node.children)) {
          const block = node;
          block.children = block.children.map(applyAnnotation);
        }
        return node;
      };
      return annotation.children.reduce((children, node) => {
        const ret = applyAnnotation(node);
        if (Array.isArray(ret)) {
          return children.concat(ret);
        }
        children.push(ret);
        return children;
      }, []);
    };
    const {
      rules = []
    } = options;
    if (!blockContentType) {
      throw new Error("Parameter 'blockContentType' is required");
    }
    const standardRules = createRules2(blockContentType, createRuleOptions(blockContentType));
    this.rules = [...rules, ...standardRules];
    const parseHtml = options.parseHtml || defaultParseHtml();
    this.blockContentType = blockContentType;
    this.parseHtml = (html) => {
      const doc = preprocess(html, parseHtml);
      return doc.body;
    };
  }
};
function normalizeBlock(node) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (node._type !== (options.blockTypeName || "block")) {
    return "_key" in node ? node : {
      ...node,
      _key: randomKey2(12)
    };
  }
  const block = {
    _key: randomKey2(12),
    children: [],
    markDefs: [],
    ...node
  };
  const lastChild = block.children[block.children.length - 1];
  if (!lastChild) {
    block.children = [{
      _type: "span",
      _key: "".concat(block._key).concat(0),
      text: "",
      marks: []
    }];
    return block;
  }
  const usedMarkDefs = [];
  const allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : false;
  block.children = block.children.reduce((acc, child) => {
    const previousChild = acc[acc.length - 1];
    if (previousChild && isPortableTextSpan2(child) && isPortableTextSpan2(previousChild) && (0, import_isEqual.default)(previousChild.marks, child.marks)) {
      if (lastChild && lastChild === child && child.text === "" && block.children.length > 1) {
        return acc;
      }
      previousChild.text += child.text;
      return acc;
    }
    acc.push(child);
    return acc;
  }, []).map((child, index) => {
    if (!child) {
      throw new Error("missing child");
    }
    child._key = "".concat(block._key).concat(index);
    if (isPortableTextSpan2(child)) {
      if (!child.marks) {
        child.marks = [];
      } else if (allowedDecorators) {
        child.marks = child.marks.filter((mark) => {
          var _a4;
          const isAllowed = allowedDecorators.includes(mark);
          const isUsed = (_a4 = block.markDefs) == null ? void 0 : _a4.some((def) => def._key === mark);
          return isAllowed || isUsed;
        });
      }
      usedMarkDefs.push(...child.marks);
    }
    return child;
  });
  block.markDefs = (block.markDefs || []).filter((markDef) => usedMarkDefs.includes(markDef._key));
  return block;
}
function htmlToBlocks(html, blockContentType) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const deserializer = new HtmlDeserializer(blockContentType, options);
  return deserializer.deserialize(html).map((block) => normalizeBlock(block));
}

// node_modules/@sanity/portable-text-editor/lib/index.esm.js
var import_isPlainObject4 = __toESM(require_isPlainObject());
var import_throttle = __toESM(require_throttle());
var import_debounce = __toESM(require_debounce());
init_styled_components_browser_esm();
function compileType(rawType) {
  return Schema2.compile({
    name: "blockTypeSchema",
    types: [rawType]
  }).get(rawType.name);
}
function getPortableTextMemberSchemaTypes(portableTextType) {
  var _a4, _b4, _c4;
  if (!portableTextType) {
    throw new Error("Parameter 'portabletextType' missing (required)");
  }
  const blockType = (_a4 = portableTextType.of) == null ? void 0 : _a4.find(findBlockType2);
  if (!blockType) {
    throw new Error("Block type is not defined in this schema (required)");
  }
  const childrenField = (_b4 = blockType.fields) == null ? void 0 : _b4.find((field) => field.name === "children");
  if (!childrenField) {
    throw new Error("Children field for block type found in schema (required)");
  }
  const ofType = childrenField.type.of;
  if (!ofType) {
    throw new Error("Valid types for block children not found in schema (required)");
  }
  const spanType = ofType.find((memberType) => memberType.name === "span");
  if (!spanType) {
    throw new Error("Span type not found in schema (required)");
  }
  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== "span") || [];
  const blockObjectTypes = ((_c4 = portableTextType.of) == null ? void 0 : _c4.filter((field) => field.name !== blockType.name)) || [];
  return {
    styles: resolveEnabledStyles2(blockType),
    decorators: resolveEnabledDecorators2(spanType),
    lists: resolveEnabledListItems2(blockType),
    block: blockType,
    span: spanType,
    portableText: portableTextType,
    inlineObjects: inlineObjectTypes,
    blockObjects: blockObjectTypes,
    annotations: spanType.annotations
  };
}
function resolveEnabledStyles2(blockType) {
  var _a4, _b4, _c4;
  const styleField = (_a4 = blockType.fields) == null ? void 0 : _a4.find((btField) => btField.name === "style");
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }
  const textStyles = ((_b4 = styleField.type.options) == null ? void 0 : _b4.list) && ((_c4 = styleField.type.options.list) == null ? void 0 : _c4.filter((style) => style.value));
  if (!textStyles || textStyles.length === 0) {
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  }
  return textStyles;
}
function resolveEnabledDecorators2(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems2(blockType) {
  var _a4, _b4;
  const listField = (_a4 = blockType.fields) == null ? void 0 : _a4.find((btField) => btField.name === "listItem");
  if (!listField) {
    throw new Error("A field with name 'listItem' is not defined in the block type (required).");
  }
  const listItems = ((_b4 = listField.type.options) == null ? void 0 : _b4.list) && listField.type.options.list.filter((list) => list.value);
  if (!listItems) {
    throw new Error("The list field need at least to be an empty array");
  }
  return listItems;
}
function findBlockType2(type) {
  if (type.type) {
    return findBlockType2(type.type);
  }
  if (type.name === "block") {
    return type;
  }
  return null;
}
var rootName = "sanity-pte:";
(0, import_debug3.default)(rootName);
function debugWithName(name) {
  const namespace = "".concat(rootName).concat(name);
  if (import_debug3.default && import_debug3.default.enabled(namespace)) {
    return (0, import_debug3.default)(namespace);
  }
  return (0, import_debug3.default)(rootName);
}
var defaultKeyGenerator = () => randomKey(12);
var PortableTextEditorKeyGeneratorContext = (0, import_react49.createContext)(defaultKeyGenerator);
var usePortableTextEditorKeyGenerator = () => {
  const keyGenerator = (0, import_react49.useContext)(PortableTextEditorKeyGeneratorContext);
  if (keyGenerator === void 0) {
    throw new Error("The `usePortableTextEditorKeyGenerator` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return keyGenerator;
};
var IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap();
var IS_PROCESSING_LOCAL_CHANGES = /* @__PURE__ */ new WeakMap();
var IS_DRAGGING = /* @__PURE__ */ new WeakMap();
var IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap();
var IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap();
var IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap();
var KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap();
var KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap();
var SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap();
function isHighSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 56320 && charCode <= 57343;
}
function cloneDiff(diff4) {
  const [type, patch2] = diff4;
  return [type, patch2];
}
function getCommonOverlap(textA, textB) {
  let text1 = textA;
  let text2 = textB;
  const text1Length = text1.length;
  const text2Length = text2.length;
  if (text1Length === 0 || text2Length === 0) {
    return 0;
  }
  if (text1Length > text2Length) {
    text1 = text1.substring(text1Length - text2Length);
  } else if (text1Length < text2Length) {
    text2 = text2.substring(0, text1Length);
  }
  const textLength = Math.min(text1Length, text2Length);
  if (text1 === text2) {
    return textLength;
  }
  let best = 0;
  let length2 = 1;
  for (let found = 0; found !== -1; ) {
    const pattern = text1.substring(textLength - length2);
    found = text2.indexOf(pattern);
    if (found === -1) {
      return best;
    }
    length2 += found;
    if (found === 0 || text1.substring(textLength - length2) === text2.substring(0, length2)) {
      best = length2;
      length2++;
    }
  }
  return best;
}
function getCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1[0] !== text2[0]) {
    return 0;
  }
  let pointerMin = 0;
  let pointerMax = Math.min(text1.length, text2.length);
  let pointerMid = pointerMax;
  let pointerStart = 0;
  while (pointerMin < pointerMid) {
    if (text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid)) {
      pointerMin = pointerMid;
      pointerStart = pointerMin;
    } else {
      pointerMax = pointerMid;
    }
    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  }
  return pointerMid;
}
function getCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) {
    return 0;
  }
  let pointerMin = 0;
  let pointerMax = Math.min(text1.length, text2.length);
  let pointerMid = pointerMax;
  let pointerEnd = 0;
  while (pointerMin < pointerMid) {
    if (text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd)) {
      pointerMin = pointerMid;
      pointerEnd = pointerMin;
    } else {
      pointerMax = pointerMid;
    }
    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  }
  return pointerMid;
}
function cleanupSemantic(rawDiffs) {
  let diffs = rawDiffs.map((diff4) => cloneDiff(diff4));
  let hasChanges = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let lengthInsertions1 = 0;
  let lengthDeletions1 = 0;
  let lengthInsertions2 = 0;
  let lengthDeletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      lengthInsertions1 = lengthInsertions2;
      lengthDeletions1 = lengthDeletions2;
      lengthInsertions2 = 0;
      lengthDeletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT) {
        lengthInsertions2 += diffs[pointer][1].length;
      } else {
        lengthDeletions2 += diffs[pointer][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]);
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        lengthInsertions1 = 0;
        lengthDeletions1 = 0;
        lengthInsertions2 = 0;
        lengthDeletions2 = 0;
        lastEquality = null;
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge(diffs);
  }
  diffs = cleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlapLength1 = getCommonOverlap(deletion, insertion);
      const overlapLength2 = getCommonOverlap(insertion, deletion);
      if (overlapLength1 >= overlapLength2) {
        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
          diffs[pointer + 1][1] = insertion.substring(overlapLength1);
          pointer++;
        }
      } else if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
        diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);
        diffs[pointer - 1][0] = DIFF_INSERT;
        diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
        diffs[pointer + 1][0] = DIFF_DELETE;
        diffs[pointer + 1][1] = deletion.substring(overlapLength2);
        pointer++;
      }
      pointer++;
    }
    pointer++;
  }
  return diffs;
}
var nonAlphaNumericRegex = /[^a-zA-Z0-9]/;
var whitespaceRegex = /\s/;
var linebreakRegex = /[\r\n]/;
var blanklineEndRegex = /\n\r?\n$/;
var blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
  const diffs = rawDiffs.map((diff4) => cloneDiff(diff4));
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = getCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score2 = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score2 >= bestScore) {
          bestScore = score2;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
  return diffs;
}
function cleanupMerge(rawDiffs) {
  let diffs = rawDiffs.map((diff4) => cloneDiff(diff4));
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0;
  let countDelete = 0;
  let countInsert = 0;
  let textDelete = "";
  let textInsert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++;
        textInsert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        countDelete++;
        textDelete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (countDelete + countInsert > 1) {
          if (countDelete !== 0 && countInsert !== 0) {
            commonlength = getCommonPrefix(textInsert, textDelete);
            if (commonlength !== 0) {
              if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);
                pointer++;
              }
              textInsert = textInsert.substring(commonlength);
              textDelete = textDelete.substring(commonlength);
            }
            commonlength = getCommonSuffix(textInsert, textDelete);
            if (commonlength !== 0) {
              diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
              textInsert = textInsert.substring(0, textInsert.length - commonlength);
              textDelete = textDelete.substring(0, textDelete.length - commonlength);
            }
          }
          pointer -= countDelete + countInsert;
          diffs.splice(pointer, countDelete + countInsert);
          if (textDelete.length) {
            diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]);
            pointer++;
          }
          if (textInsert.length) {
            diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]);
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        countInsert = 0;
        countDelete = 0;
        textDelete = "";
        textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation");
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  let hasChanges = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        hasChanges = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge(diffs);
  }
  return diffs;
}
function trueCount() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs) {
  let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  let diffs = rawDiffs.map((diff4) => cloneDiff(diff4));
  let hasChanges = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let preIns = false;
  let preDel = false;
  let postIns = false;
  let postDel = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].length < editCost && (postIns || postDel)) {
        equalities[equalitiesLength++] = pointer;
        preIns = postIns;
        preDel = postDel;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      postIns = false;
      postDel = false;
    } else {
      if (diffs[pointer][0] === DIFF_DELETE) {
        postDel = true;
      } else {
        postIns = true;
      }
      if (lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]);
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (preIns && preDel) {
          postIns = true;
          postDel = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          postIns = false;
          postDel = false;
        }
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge(diffs);
  }
  return diffs;
}
function bisect(text1, text2, deadline) {
  const text1Length = text1.length;
  const text2Length = text2.length;
  const maxD = Math.ceil((text1Length + text2Length) / 2);
  const vOffset = maxD;
  const vLength = 2 * maxD;
  const v1 = new Array(vLength);
  const v2 = new Array(vLength);
  for (let x = 0; x < vLength; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[vOffset + 1] = 0;
  v2[vOffset + 1] = 0;
  const delta2 = text1Length - text2Length;
  const front = delta2 % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < maxD; d++) {
    if (Date.now() > deadline) {
      break;
    }
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1Offset = vOffset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
        x1 = v1[k1Offset + 1];
      } else {
        x1 = v1[k1Offset - 1] + 1;
      }
      let y1 = x1 - k1;
      while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1Offset] = x1;
      if (x1 > text1Length) {
        k1end += 2;
      } else if (y1 > text2Length) {
        k1start += 2;
      } else if (front) {
        const k2Offset = vOffset + delta2 - k1;
        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
          const x2 = text1Length - v2[k2Offset];
          if (x1 >= x2) {
            return bisectSplit(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2Offset = vOffset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
        x2 = v2[k2Offset + 1];
      } else {
        x2 = v2[k2Offset - 1] + 1;
      }
      let y2 = x2 - k2;
      while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2Offset] = x2;
      if (x2 > text1Length) {
        k2end += 2;
      } else if (y2 > text2Length) {
        k2start += 2;
      } else if (!front) {
        const k1Offset = vOffset + delta2 - k2;
        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
          const x1 = v1[k1Offset];
          const y1 = vOffset + x1 - k1Offset;
          x2 = text1Length - x2;
          if (x1 >= x2) {
            return bisectSplit(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}
function bisectSplit(text1, text2, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = doDiff(text1a, text2a, {
    checkLines: false,
    deadline
  });
  const diffsb = doDiff(text1b, text2b, {
    checkLines: false,
    deadline
  });
  return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2) {
  let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (timeout <= 0) {
    return null;
  }
  const longText = text1.length > text2.length ? text1 : text2;
  const shortText = text1.length > text2.length ? text2 : text1;
  if (longText.length < 4 || shortText.length * 2 < longText.length) {
    return null;
  }
  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4));
  const halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
  let halfMatch;
  if (halfMatch1 && halfMatch2) {
    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
  } else if (!halfMatch1 && !halfMatch2) {
    return null;
  } else if (!halfMatch2) {
    halfMatch = halfMatch1;
  } else if (!halfMatch1) {
    halfMatch = halfMatch2;
  }
  if (!halfMatch) {
    throw new Error("Unable to find a half match.");
  }
  let text1A;
  let text1B;
  let text2A;
  let text2B;
  if (text1.length > text2.length) {
    text1A = halfMatch[0];
    text1B = halfMatch[1];
    text2A = halfMatch[2];
    text2B = halfMatch[3];
  } else {
    text2A = halfMatch[0];
    text2B = halfMatch[1];
    text1A = halfMatch[2];
    text1B = halfMatch[3];
  }
  const midCommon = halfMatch[4];
  return [text1A, text1B, text2A, text2B, midCommon];
}
function halfMatchI(longText, shortText, i) {
  const seed = longText.slice(i, i + Math.floor(longText.length / 4));
  let j = -1;
  let bestCommon = "";
  let bestLongTextA;
  let bestLongTextB;
  let bestShortTextA;
  let bestShortTextB;
  while ((j = shortText.indexOf(seed, j + 1)) !== -1) {
    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j));
    const suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
    if (bestCommon.length < suffixLength + prefixLength) {
      bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength);
      bestLongTextA = longText.slice(0, i - suffixLength);
      bestLongTextB = longText.slice(i + prefixLength);
      bestShortTextA = shortText.slice(0, j - suffixLength);
      bestShortTextB = shortText.slice(j + prefixLength);
    }
  }
  if (bestCommon.length * 2 >= longText.length) {
    return [bestLongTextA || "", bestLongTextB || "", bestShortTextA || "", bestShortTextB || "", bestCommon || ""];
  }
  return null;
}
function charsToLines(diffs, lineArray) {
  for (let x = 0; x < diffs.length; x++) {
    const chars2 = diffs[x][1];
    const text = [];
    for (let y = 0; y < chars2.length; y++) {
      text[y] = lineArray[chars2.charCodeAt(y)];
    }
    diffs[x][1] = text.join("");
  }
}
function linesToChars(textA, textB) {
  const lineArray = [];
  const lineHash = {};
  lineArray[0] = "";
  function diffLinesToMunge(text) {
    let chars3 = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf("\n", lineStart);
      if (lineEnd === -1) {
        lineEnd = text.length - 1;
      }
      let line = text.slice(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
        chars3 += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text.slice(lineStart);
          lineEnd = text.length;
        }
        chars3 += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars3;
  }
  let maxLines = 4e4;
  const chars1 = diffLinesToMunge(textA);
  maxLines = 65535;
  const chars2 = diffLinesToMunge(textB);
  return {
    chars1,
    chars2,
    lineArray
  };
}
function doLineModeDiff(textA, textB, opts) {
  let text1 = textA;
  let text2 = textB;
  const a = linesToChars(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  let diffs = doDiff(text1, text2, {
    checkLines: false,
    deadline: opts.deadline
  });
  charsToLines(diffs, linearray);
  diffs = cleanupSemantic(diffs);
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0;
  let countDelete = 0;
  let countInsert = 0;
  let textDelete = "";
  let textInsert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++;
        textInsert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        countDelete++;
        textDelete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (countDelete >= 1 && countInsert >= 1) {
          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
          pointer = pointer - countDelete - countInsert;
          const aa = doDiff(textDelete, textInsert, {
            checkLines: false,
            deadline: opts.deadline
          });
          for (let j = aa.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, aa[j]);
          }
          pointer += aa.length;
        }
        countInsert = 0;
        countDelete = 0;
        textDelete = "";
        textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function computeDiff(text1, text2, opts) {
  let diffs;
  if (!text1) {
    return [[DIFF_INSERT, text2]];
  }
  if (!text2) {
    return [[DIFF_DELETE, text1]];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    if (text1.length > text2.length) {
      diffs[0][0] = DIFF_DELETE;
      diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  if (shorttext.length === 1) {
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  const halfMatch = findHalfMatch(text1, text2);
  if (halfMatch) {
    const text1A = halfMatch[0];
    const text1B = halfMatch[1];
    const text2A = halfMatch[2];
    const text2B = halfMatch[3];
    const midCommon = halfMatch[4];
    const diffsA = doDiff(text1A, text2A, opts);
    const diffsB = doDiff(text1B, text2B, opts);
    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
  }
  if (opts.checkLines && text1.length > 100 && text2.length > 100) {
    return doLineModeDiff(text1, text2, opts);
  }
  return bisect(text1, text2, opts.deadline);
}
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
  if (textA === null || textB === null) {
    throw new Error("Null input. (diff)");
  }
  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
  adjustDiffForSurrogatePairs(diffs);
  return diffs;
}
function doDiff(textA, textB, options) {
  let text1 = textA;
  let text2 = textB;
  if (text1 === text2) {
    return text1 ? [[DIFF_EQUAL, text1]] : [];
  }
  let commonlength = getCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = getCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  let diffs = computeDiff(text1, text2, options);
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diffs = cleanupMerge(diffs);
  return diffs;
}
function createDeadLine(timeout) {
  let t3 = 1;
  if (typeof timeout !== "undefined") {
    t3 = timeout <= 0 ? Number.MAX_VALUE : timeout;
  }
  return Date.now() + t3 * 1e3;
}
function createInternalOpts(opts) {
  return {
    checkLines: true,
    deadline: createDeadLine(opts.timeout || 1),
    ...opts
  };
}
function combineChar(data, char, dir2) {
  return dir2 === 1 ? data + char : char + data;
}
function splitChar(data, dir2) {
  return dir2 === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];
}
function hasSharedChar(diffs, i, j, dir2) {
  return dir2 === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir2) {
  const inv = dir2 === 1 ? -1 : 1;
  let insertIdx = null;
  let deleteIdx = null;
  let j = i + dir2;
  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir2) {
    const [op, text2] = diffs[j];
    if (text2.length === 0) {
      continue;
    }
    if (op === DIFF_INSERT) {
      if (insertIdx === null) {
        insertIdx = j;
      }
      continue;
    } else if (op === DIFF_DELETE) {
      if (deleteIdx === null) {
        deleteIdx = j;
      }
      continue;
    } else if (op === DIFF_EQUAL) {
      if (insertIdx === null && deleteIdx === null) {
        const [rest, char2] = splitChar(diffs[i][1], dir2);
        diffs[i][1] = rest;
        diffs[j][1] = combineChar(diffs[j][1], char2, inv);
        return;
      }
      break;
    }
  }
  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir2)) {
    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv);
    const [deleteText] = splitChar(diffs[deleteIdx][1], inv);
    diffs[insertIdx][1] = insertText;
    diffs[deleteIdx][1] = deleteText;
    diffs[i][1] = combineChar(diffs[i][1], insertChar, dir2);
    return;
  }
  const [text, char] = splitChar(diffs[i][1], dir2);
  diffs[i][1] = text;
  if (insertIdx === null) {
    diffs.splice(j, 0, [DIFF_INSERT, char]);
    if (deleteIdx !== null && deleteIdx >= j)
      deleteIdx++;
  } else {
    diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv);
  }
  if (deleteIdx === null) {
    diffs.splice(j, 0, [DIFF_DELETE, char]);
  } else {
    diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
  }
}
function adjustDiffForSurrogatePairs(diffs) {
  for (let i = 0; i < diffs.length; i++) {
    const [diffType, diffText] = diffs[i];
    if (diffText.length === 0)
      continue;
    const firstChar = diffText[0];
    const lastChar = diffText[diffText.length - 1];
    if (isHighSurrogate(lastChar) && diffType === DIFF_EQUAL) {
      deisolateChar(diffs, i, 1);
    }
    if (isLowSurrogate(firstChar) && diffType === DIFF_EQUAL) {
      deisolateChar(diffs, i, -1);
    }
  }
  for (let i = 0; i < diffs.length; i++) {
    if (diffs[i][1].length === 0) {
      diffs.splice(i, 1);
    }
  }
}
var DEFAULT_OPTIONS2 = {
  /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */
  threshold: 0.5,
  /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */
  distance: 1e3
};
function applyDefaults(options) {
  return {
    ...DEFAULT_OPTIONS2,
    ...options
  };
}
var MAX_BITS$1 = 32;
function bitap(text, pattern, loc) {
  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (pattern.length > MAX_BITS$1) {
    throw new Error("Pattern too long for this browser.");
  }
  const options = applyDefaults(opts);
  const s = getAlphabetFromPattern(pattern);
  function getBitapScore(e2, x) {
    const accuracy = e2 / pattern.length;
    const proximity = Math.abs(loc - x);
    if (!options.distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / options.distance;
  }
  let scoreThreshold = options.threshold;
  let bestLoc = text.indexOf(pattern, loc);
  if (bestLoc !== -1) {
    scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold);
    bestLoc = text.lastIndexOf(pattern, loc + pattern.length);
    if (bestLoc !== -1) {
      scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold);
    }
  }
  const matchmask = 1 << pattern.length - 1;
  bestLoc = -1;
  let binMin;
  let binMid;
  let binMax = pattern.length + text.length;
  let lastRd = [];
  for (let d = 0; d < pattern.length; d++) {
    binMin = 0;
    binMid = binMax;
    while (binMin < binMid) {
      if (getBitapScore(d, loc + binMid) <= scoreThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, loc - binMid + 1);
    const finish = Math.min(loc + binMid, text.length) + pattern.length;
    const rd = new Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (let j = finish; j >= start; j--) {
      const charMatch = s[text.charAt(j - 1)];
      if (d === 0) {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
      } else {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1];
      }
      if (rd[j] & matchmask) {
        const score2 = getBitapScore(d, j - 1);
        if (score2 <= scoreThreshold) {
          scoreThreshold = score2;
          bestLoc = j - 1;
          if (bestLoc > loc) {
            start = Math.max(1, 2 * loc - bestLoc);
          } else {
            break;
          }
        }
      }
    }
    if (getBitapScore(d + 1, loc) > scoreThreshold) {
      break;
    }
    lastRd = rd;
  }
  return bestLoc;
}
function getAlphabetFromPattern(pattern) {
  const s = {};
  for (let i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (let i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  }
  return s;
}
function match(text, pattern, searchLocation) {
  if (text === null || pattern === null || searchLocation === null) {
    throw new Error("Null input. (match())");
  }
  const loc = Math.max(0, Math.min(searchLocation, text.length));
  if (text === pattern) {
    return 0;
  } else if (!text.length) {
    return -1;
  } else if (text.substring(loc, loc + pattern.length) === pattern) {
    return loc;
  }
  return bitap(text, pattern, loc);
}
function createPatchObject(start1, start2) {
  return {
    diffs: [],
    start1,
    start2,
    utf8Start1: start1,
    utf8Start2: start2,
    length1: 0,
    length2: 0,
    utf8Length1: 0,
    utf8Length2: 0
  };
}
function diffText1(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join("");
}
function diffText2(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join("");
}
function countUtf8Bytes(str) {
  let bytes = 0;
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    if (typeof codePoint === "undefined") {
      throw new Error("Failed to get codepoint");
    }
    bytes += utf8len(codePoint);
  }
  return bytes;
}
function adjustIndiciesToUcs2(patches, base) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let byteOffset = 0;
  let idx = 0;
  function advanceTo(target) {
    for (; byteOffset < target; ) {
      const codePoint = base.codePointAt(idx);
      if (typeof codePoint === "undefined") {
        return idx;
      }
      byteOffset += utf8len(codePoint);
      if (codePoint > 65535) {
        idx += 2;
      } else {
        idx += 1;
      }
    }
    if (!options.allowExceedingIndices && byteOffset !== target) {
      throw new Error("Failed to determine byte offset");
    }
    return idx;
  }
  const adjusted = [];
  for (const patch2 of patches) {
    adjusted.push({
      diffs: patch2.diffs.map((diff4) => cloneDiff(diff4)),
      start1: advanceTo(patch2.start1),
      start2: advanceTo(patch2.start2),
      utf8Start1: patch2.utf8Start1,
      utf8Start2: patch2.utf8Start2,
      length1: patch2.length1,
      length2: patch2.length2,
      utf8Length1: patch2.utf8Length1,
      utf8Length2: patch2.utf8Length2
    });
  }
  return adjusted;
}
function utf8len(codePoint) {
  if (codePoint <= 127)
    return 1;
  if (codePoint <= 2047)
    return 2;
  if (codePoint <= 65535)
    return 3;
  return 4;
}
var MAX_BITS = 32;
var DEFAULT_MARGIN = 4;
var DEFAULT_OPTS = {
  margin: 4
};
function getDefaultOpts() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    ...DEFAULT_OPTS,
    ...opts
  };
}
function make(a, b, options) {
  if (typeof a === "string" && typeof b === "string") {
    let diffs = diff(a, b, {
      checkLines: true
    });
    if (diffs.length > 2) {
      diffs = cleanupSemantic(diffs);
      diffs = cleanupEfficiency(diffs);
    }
    return _make(a, diffs, getDefaultOpts(options));
  }
  if (a && Array.isArray(a) && typeof b === "undefined") {
    return _make(diffText1(a), a, getDefaultOpts(options));
  }
  if (typeof a === "string" && b && Array.isArray(b)) {
    return _make(a, b, getDefaultOpts(options));
  }
  throw new Error("Unknown call format to make()");
}
function _make(textA, diffs, options) {
  if (diffs.length === 0) {
    return [];
  }
  const patches = [];
  let patch2 = createPatchObject(0, 0);
  let patchDiffLength = 0;
  let charCount1 = 0;
  let charCount2 = 0;
  let utf8Count1 = 0;
  let utf8Count2 = 0;
  let prepatchText = textA;
  let postpatchText = textA;
  for (let x = 0; x < diffs.length; x++) {
    const currentDiff = diffs[x];
    const [diffType, diffText] = currentDiff;
    const diffTextLength = diffText.length;
    const diffByteLength = countUtf8Bytes(diffText);
    if (!patchDiffLength && diffType !== DIFF_EQUAL) {
      patch2.start1 = charCount1;
      patch2.start2 = charCount2;
      patch2.utf8Start1 = utf8Count1;
      patch2.utf8Start2 = utf8Count2;
    }
    switch (diffType) {
      case DIFF_INSERT:
        patch2.diffs[patchDiffLength++] = currentDiff;
        patch2.length2 += diffTextLength;
        patch2.utf8Length2 += diffByteLength;
        postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
        break;
      case DIFF_DELETE:
        patch2.length1 += diffTextLength;
        patch2.utf8Length1 += diffByteLength;
        patch2.diffs[patchDiffLength++] = currentDiff;
        postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
        break;
      case DIFF_EQUAL:
        if (diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1) {
          patch2.diffs[patchDiffLength++] = currentDiff;
          patch2.length1 += diffTextLength;
          patch2.length2 += diffTextLength;
          patch2.utf8Length1 += diffByteLength;
          patch2.utf8Length2 += diffByteLength;
        } else if (diffTextLength >= 2 * options.margin) {
          if (patchDiffLength) {
            addContext(patch2, prepatchText, options);
            patches.push(patch2);
            patch2 = createPatchObject(-1, -1);
            patchDiffLength = 0;
            prepatchText = postpatchText;
            charCount1 = charCount2;
            utf8Count1 = utf8Count2;
          }
        }
        break;
      default:
        throw new Error("Unknown diff type");
    }
    if (diffType !== DIFF_INSERT) {
      charCount1 += diffTextLength;
      utf8Count1 += diffByteLength;
    }
    if (diffType !== DIFF_DELETE) {
      charCount2 += diffTextLength;
      utf8Count2 += diffByteLength;
    }
  }
  if (patchDiffLength) {
    addContext(patch2, prepatchText, options);
    patches.push(patch2);
  }
  return patches;
}
function addContext(patch2, text, opts) {
  if (text.length === 0) {
    return;
  }
  let pattern = text.substring(patch2.start2, patch2.start2 + patch2.length1);
  let padding = 0;
  while (text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin) {
    padding += opts.margin;
    pattern = text.substring(patch2.start2 - padding, patch2.start2 + patch2.length1 + padding);
  }
  padding += opts.margin;
  let prefixStart = patch2.start2 - padding;
  if (prefixStart >= 1 && isLowSurrogate(text[prefixStart])) {
    prefixStart--;
  }
  const prefix = text.substring(prefixStart, patch2.start2);
  if (prefix) {
    patch2.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  const prefixLength = prefix.length;
  const prefixUtf8Length = countUtf8Bytes(prefix);
  let suffixEnd = patch2.start2 + patch2.length1 + padding;
  if (suffixEnd < text.length && isLowSurrogate(text[suffixEnd])) {
    suffixEnd++;
  }
  const suffix = text.substring(patch2.start2 + patch2.length1, suffixEnd);
  if (suffix) {
    patch2.diffs.push([DIFF_EQUAL, suffix]);
  }
  const suffixLength = suffix.length;
  const suffixUtf8Length = countUtf8Bytes(suffix);
  patch2.start1 -= prefixLength;
  patch2.start2 -= prefixLength;
  patch2.utf8Start1 -= prefixUtf8Length;
  patch2.utf8Start2 -= prefixUtf8Length;
  patch2.length1 += prefixLength + suffixLength;
  patch2.length2 += prefixLength + suffixLength;
  patch2.utf8Length1 += prefixUtf8Length + suffixUtf8Length;
  patch2.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
function levenshtein(diffs) {
  let leven2 = 0;
  let insertions = 0;
  let deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0];
    const data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        leven2 += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
  }
  leven2 += Math.max(insertions, deletions);
  return leven2;
}
function xIndex(diffs, loc) {
  let chars1 = 0;
  let chars2 = 0;
  let lastChars1 = 0;
  let lastChars2 = 0;
  let x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {
      break;
    }
    lastChars1 = chars1;
    lastChars2 = chars2;
  }
  if (diffs.length !== x && diffs[x][0] === DIFF_DELETE) {
    return lastChars2;
  }
  return lastChars2 + (loc - lastChars1);
}
function addPadding(patches) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
  const paddingLength = margin;
  let nullPadding = "";
  for (let x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }
  for (const p of patches) {
    p.start1 += paddingLength;
    p.start2 += paddingLength;
    p.utf8Start1 += paddingLength;
    p.utf8Start2 += paddingLength;
  }
  let patch2 = patches[0];
  let diffs = patch2.diffs;
  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) {
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch2.start1 -= paddingLength;
    patch2.start2 -= paddingLength;
    patch2.utf8Start1 -= paddingLength;
    patch2.utf8Start2 -= paddingLength;
    patch2.length1 += paddingLength;
    patch2.length2 += paddingLength;
    patch2.utf8Length1 += paddingLength;
    patch2.utf8Length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    const firstDiffLength = diffs[0][1].length;
    const extraLength = paddingLength - firstDiffLength;
    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1];
    patch2.start1 -= extraLength;
    patch2.start2 -= extraLength;
    patch2.utf8Start1 -= extraLength;
    patch2.utf8Start2 -= extraLength;
    patch2.length1 += extraLength;
    patch2.length2 += extraLength;
    patch2.utf8Length1 += extraLength;
    patch2.utf8Length2 += extraLength;
  }
  patch2 = patches[patches.length - 1];
  diffs = patch2.diffs;
  if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) {
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch2.length1 += paddingLength;
    patch2.length2 += paddingLength;
    patch2.utf8Length1 += paddingLength;
    patch2.utf8Length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch2.length1 += extraLength;
    patch2.length2 += extraLength;
    patch2.utf8Length1 += extraLength;
    patch2.utf8Length2 += extraLength;
  }
  return nullPadding;
}
function splitMax(patches) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
  const patchSize = MAX_BITS;
  for (let x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patchSize) {
      continue;
    }
    const bigpatch = patches[x];
    patches.splice(x--, 1);
    let start1 = bigpatch.start1;
    let start2 = bigpatch.start2;
    let preContext = "";
    while (bigpatch.diffs.length !== 0) {
      const patch2 = createPatchObject(start1 - preContext.length, start2 - preContext.length);
      let empty2 = true;
      if (preContext !== "") {
        const precontextByteCount = countUtf8Bytes(preContext);
        patch2.length1 = preContext.length;
        patch2.utf8Length1 = precontextByteCount;
        patch2.length2 = preContext.length;
        patch2.utf8Length2 = precontextByteCount;
        patch2.diffs.push([DIFF_EQUAL, preContext]);
      }
      while (bigpatch.diffs.length !== 0 && patch2.length1 < patchSize - margin) {
        const diffType = bigpatch.diffs[0][0];
        let diffText = bigpatch.diffs[0][1];
        let diffTextByteCount = countUtf8Bytes(diffText);
        if (diffType === DIFF_INSERT) {
          patch2.length2 += diffText.length;
          patch2.utf8Length2 += diffTextByteCount;
          start2 += diffText.length;
          const diff4 = bigpatch.diffs.shift();
          if (diff4) {
            patch2.diffs.push(diff4);
          }
          empty2 = false;
        } else if (diffType === DIFF_DELETE && patch2.diffs.length === 1 && patch2.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize) {
          patch2.length1 += diffText.length;
          patch2.utf8Length1 += diffTextByteCount;
          start1 += diffText.length;
          empty2 = false;
          patch2.diffs.push([diffType, diffText]);
          bigpatch.diffs.shift();
        } else {
          diffText = diffText.substring(0, patchSize - patch2.length1 - margin);
          diffTextByteCount = countUtf8Bytes(diffText);
          patch2.length1 += diffText.length;
          patch2.utf8Length1 += diffTextByteCount;
          start1 += diffText.length;
          if (diffType === DIFF_EQUAL) {
            patch2.length2 += diffText.length;
            patch2.utf8Length2 += diffTextByteCount;
            start2 += diffText.length;
          } else {
            empty2 = false;
          }
          patch2.diffs.push([diffType, diffText]);
          if (diffText === bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length);
          }
        }
      }
      preContext = diffText2(patch2.diffs);
      preContext = preContext.substring(preContext.length - margin);
      const postContext = diffText1(bigpatch.diffs).substring(0, margin);
      const postContextByteCount = countUtf8Bytes(postContext);
      if (postContext !== "") {
        patch2.length1 += postContext.length;
        patch2.length2 += postContext.length;
        patch2.utf8Length1 += postContextByteCount;
        patch2.utf8Length2 += postContextByteCount;
        if (patch2.diffs.length !== 0 && patch2.diffs[patch2.diffs.length - 1][0] === DIFF_EQUAL) {
          patch2.diffs[patch2.diffs.length - 1][1] += postContext;
        } else {
          patch2.diffs.push([DIFF_EQUAL, postContext]);
        }
      }
      if (!empty2) {
        patches.splice(++x, 0, patch2);
      }
    }
  }
}
function apply$4(patches, originalText) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof patches === "string") {
    throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
  }
  let text = originalText;
  if (patches.length === 0) {
    return [text, []];
  }
  const parsed = adjustIndiciesToUcs2(patches, text, {
    allowExceedingIndices: opts.allowExceedingIndices
  });
  const margin = opts.margin || DEFAULT_MARGIN;
  const deleteThreshold = opts.deleteThreshold || 0.4;
  const nullPadding = addPadding(parsed, margin);
  text = nullPadding + text + nullPadding;
  splitMax(parsed, margin);
  let delta2 = 0;
  const results = [];
  for (let x = 0; x < parsed.length; x++) {
    const expectedLoc = parsed[x].start2 + delta2;
    const text1 = diffText1(parsed[x].diffs);
    let startLoc;
    let endLoc = -1;
    if (text1.length > MAX_BITS) {
      startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc);
      if (startLoc !== -1) {
        endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS);
        if (endLoc === -1 || startLoc >= endLoc) {
          startLoc = -1;
        }
      }
    } else {
      startLoc = match(text, text1, expectedLoc);
    }
    if (startLoc === -1) {
      results[x] = false;
      delta2 -= parsed[x].length2 - parsed[x].length1;
    } else {
      results[x] = true;
      delta2 = startLoc - expectedLoc;
      let text2;
      if (endLoc === -1) {
        text2 = text.substring(startLoc, startLoc + text1.length);
      } else {
        text2 = text.substring(startLoc, endLoc + MAX_BITS);
      }
      if (text1 === text2) {
        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
      } else {
        let diffs = diff(text1, text2, {
          checkLines: false
        });
        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) {
          results[x] = false;
        } else {
          diffs = cleanupSemanticLossless(diffs);
          let index1 = 0;
          let index2 = 0;
          for (let y = 0; y < parsed[x].diffs.length; y++) {
            const mod = parsed[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {
              text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2);
            } else if (mod[0] === DIFF_DELETE) {
              text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
}
function stringify2(patches) {
  return patches.map(stringifyPatch).join("");
}
function stringifyPatch(patch2) {
  const {
    utf8Length1,
    utf8Length2,
    utf8Start1,
    utf8Start2,
    diffs
  } = patch2;
  let coords1;
  if (utf8Length1 === 0) {
    coords1 = "".concat(utf8Start1, ",0");
  } else if (utf8Length1 === 1) {
    coords1 = "".concat(utf8Start1 + 1);
  } else {
    coords1 = "".concat(utf8Start1 + 1, ",").concat(utf8Length1);
  }
  let coords2;
  if (utf8Length2 === 0) {
    coords2 = "".concat(utf8Start2, ",0");
  } else if (utf8Length2 === 1) {
    coords2 = "".concat(utf8Start2 + 1);
  } else {
    coords2 = "".concat(utf8Start2 + 1, ",").concat(utf8Length2);
  }
  const text = ["@@ -".concat(coords1, " +").concat(coords2, " @@\n")];
  let op;
  for (let x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        op = "+";
        break;
      case DIFF_DELETE:
        op = "-";
        break;
      case DIFF_EQUAL:
        op = " ";
        break;
      default:
        throw new Error("Unknown patch operation.");
    }
    text[x + 1] = "".concat(op + encodeURI(diffs[x][1]), "\n");
  }
  return text.join("").replace(/%20/g, " ");
}
var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse3(textline) {
  if (!textline) {
    return [];
  }
  const patches = [];
  const lines = textline.split("\n");
  let textPointer = 0;
  while (textPointer < lines.length) {
    const m2 = lines[textPointer].match(patchHeader);
    if (!m2) {
      throw new Error("Invalid patch string: ".concat(lines[textPointer]));
    }
    const patch2 = createPatchObject(toInt(m2[1]), toInt(m2[3]));
    patches.push(patch2);
    if (m2[2] === "") {
      patch2.start1--;
      patch2.utf8Start1--;
      patch2.length1 = 1;
      patch2.utf8Length1 = 1;
    } else if (m2[2] === "0") {
      patch2.length1 = 0;
      patch2.utf8Length1 = 0;
    } else {
      patch2.start1--;
      patch2.utf8Start1--;
      patch2.utf8Length1 = toInt(m2[2]);
      patch2.length1 = patch2.utf8Length1;
    }
    if (m2[4] === "") {
      patch2.start2--;
      patch2.utf8Start2--;
      patch2.length2 = 1;
      patch2.utf8Length2 = 1;
    } else if (m2[4] === "0") {
      patch2.length2 = 0;
      patch2.utf8Length2 = 0;
    } else {
      patch2.start2--;
      patch2.utf8Start2--;
      patch2.utf8Length2 = toInt(m2[4]);
      patch2.length2 = patch2.utf8Length2;
    }
    textPointer++;
    while (textPointer < lines.length) {
      const currentLine = lines[textPointer];
      const sign = currentLine.charAt(0);
      if (sign === "@") {
        break;
      }
      if (sign === "") {
        textPointer++;
        continue;
      }
      let line;
      try {
        line = decodeURI(currentLine.slice(1));
      } catch (ex) {
        throw new Error("Illegal escape in parse: ".concat(currentLine));
      }
      const utf8Diff = countUtf8Bytes(line) - line.length;
      if (sign === "-") {
        patch2.diffs.push([DIFF_DELETE, line]);
        patch2.length1 -= utf8Diff;
      } else if (sign === "+") {
        patch2.diffs.push([DIFF_INSERT, line]);
        patch2.length2 -= utf8Diff;
      } else if (sign === " ") {
        patch2.diffs.push([DIFF_EQUAL, line]);
        patch2.length1 -= utf8Diff;
        patch2.length2 -= utf8Diff;
      } else {
        throw new Error('Invalid patch mode "'.concat(sign, '" in: ').concat(line));
      }
      textPointer++;
    }
  }
  return patches;
}
function toInt(num) {
  return parseInt(num, 10);
}
function setIfMissing(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return {
    type: "setIfMissing",
    path: path2,
    value
  };
}
function diffMatchPatch$1(currentValue, nextValue) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const patches = make(currentValue, nextValue);
  const patch2 = stringify2(patches);
  return {
    type: "diffMatchPatch",
    path: path2,
    value: patch2
  };
}
function insert$1(items, position) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  return {
    type: "insert",
    path: path2,
    position,
    items
  };
}
function set2(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return {
    type: "set",
    path: path2,
    value
  };
}
function unset() {
  let path2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return {
    type: "unset",
    path: path2
  };
}
var EMPTY_MARKDEFS = [];
var EMPTY_MARKS$1 = [];
var VOID_CHILD_KEY = "void-child";
function keepObjectEquality(object2, keyMap) {
  const value = keyMap[object2._key];
  if (value && (0, import_isEqual2.default)(object2, value)) {
    return value;
  }
  keyMap[object2._key] = object2;
  return object2;
}
function toSlateValue(value, _ref) {
  let {
    schemaTypes
  } = _ref;
  let keyMap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (value && Array.isArray(value)) {
    return value.map((block) => {
      const {
        _type,
        _key,
        ...rest
      } = block;
      const voidChildren = [{
        _key: VOID_CHILD_KEY,
        _type: "span",
        text: "",
        marks: []
      }];
      const isPortableText2 = block && block._type === schemaTypes.block.name;
      if (isPortableText2) {
        const textBlock = block;
        let hasInlines = false;
        const hasMissingStyle = typeof textBlock.style === "undefined";
        const hasMissingMarkDefs = typeof textBlock.markDefs === "undefined";
        const hasMissingChildren = typeof textBlock.children === "undefined";
        const children = hasMissingChildren ? [{
          _type: schemaTypes.span.name,
          _key: defaultKeyGenerator(),
          text: "",
          marks: []
        }] : textBlock.children.map((child) => {
          const {
            _type: cType,
            _key: cKey,
            ...cRest
          } = child;
          if (cType !== "span") {
            hasInlines = true;
            return keepObjectEquality({
              _type: cType,
              _key: cKey,
              children: voidChildren,
              value: cRest,
              __inline: true
            }, keyMap);
          }
          if (cType === "span" && !("marks" in cRest)) {
            return keepObjectEquality({
              _key: cKey,
              _type: cType,
              ...cRest,
              marks: EMPTY_MARKS$1
            }, keyMap);
          }
          return child;
        });
        if (!hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && Element2.isElement(block)) {
          return block;
        }
        if (hasMissingStyle) {
          rest.style = schemaTypes.styles[0].value;
        }
        if (hasMissingMarkDefs) {
          rest.markDefs = EMPTY_MARKDEFS;
        }
        return keepObjectEquality({
          _type,
          _key,
          ...rest,
          children
        }, keyMap);
      }
      return keepObjectEquality({
        _type,
        _key,
        children: voidChildren,
        value: rest
      }, keyMap);
    });
  }
  return [];
}
function fromSlateValue(value, textBlockType) {
  let keyMap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return value.map((block) => {
    const {
      _key,
      _type
    } = block;
    if (!_key || !_type) {
      throw new Error("Not a valid block");
    }
    if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
      let hasInlines = false;
      const children = block.children.map((child) => {
        const {
          _type: _cType
        } = child;
        if ("value" in child && _cType !== "span") {
          hasInlines = true;
          const {
            value: v,
            _key: k,
            _type: t3,
            __inline: _i2,
            children: _c4,
            ...rest
          } = child;
          return keepObjectEquality({
            ...rest,
            ...v,
            _key: k,
            _type: t3
          }, keyMap);
        }
        return child;
      });
      if (!hasInlines) {
        return block;
      }
      return keepObjectEquality({
        ...block,
        children,
        _key,
        _type
      }, keyMap);
    }
    const blockValue = "value" in block && block.value;
    return keepObjectEquality({
      _key,
      _type,
      ...typeof blockValue === "object" ? blockValue : {}
    }, keyMap);
  });
}
function isEqualToEmptyEditor(children, schemaTypes) {
  var _a4;
  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && Element2.isElement(children[0]) && children[0]._type === schemaTypes.block.name && "style" in children[0] && children[0].style === schemaTypes.styles[0].value && !("listItem" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && Text2.isText(children[0].children[0]) && children[0].children[0]._type === "span" && !((_a4 = children[0].children[0].marks) == null ? void 0 : _a4.join("")) && children[0].children[0].text === "";
}
var debug$k = debugWithName("operationToPatches");
debug$k.enabled = false;
function createOperationToPatches(types3) {
  const textBlockName = types3.block.name;
  function insertTextPatch(editor2, operation, beforeValue) {
    if (debug$k.enabled) {
      debug$k("Operation", JSON.stringify(operation, null, 2));
    }
    const block = editor2.isTextBlock(editor2.children[operation.path[0]]) && editor2.children[operation.path[0]];
    if (!block) {
      throw new Error("Could not find block");
    }
    const textChild = editor2.isTextBlock(block) && editor2.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];
    if (!textChild) {
      throw new Error("Could not find child");
    }
    const path2 = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"];
    const prevBlock = beforeValue[operation.path[0]];
    const prevChild = editor2.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]];
    const prevText = editor2.isTextSpan(prevChild) ? prevChild.text : "";
    const patch2 = diffMatchPatch$1(prevText, textChild.text, path2);
    return patch2.value.length ? [patch2] : [];
  }
  function removeTextPatch(editor2, operation, beforeValue) {
    const block = editor2 && editor2.children[operation.path[0]];
    if (!block) {
      throw new Error("Could not find block");
    }
    const child = editor2.isTextBlock(block) && block.children[operation.path[1]] || void 0;
    const textChild = editor2.isTextSpan(child) ? child : void 0;
    if (child && !textChild) {
      throw new Error("Expected span");
    }
    if (!textChild) {
      throw new Error("Could not find child");
    }
    const path2 = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"];
    const beforeBlock = beforeValue[operation.path[0]];
    const prevTextChild = editor2.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]];
    const prevText = editor2.isTextSpan(prevTextChild) && prevTextChild.text;
    const patch2 = diffMatchPatch$1(prevText || "", textChild.text, path2);
    return patch2.value ? [patch2] : [];
  }
  function setNodePatch(editor2, operation) {
    if (operation.path.length === 1) {
      const block = editor2.children[operation.path[0]];
      if (typeof block._key !== "string") {
        throw new Error("Expected block to have a _key");
      }
      const setNode = (0, import_omitBy2.default)({
        ...editor2.children[operation.path[0]],
        ...operation.newProperties
      }, import_isUndefined2.default);
      return [set2(fromSlateValue([setNode], textBlockName)[0], [{
        _key: block._key
      }])];
    } else if (operation.path.length === 2) {
      const block = editor2.children[operation.path[0]];
      if (editor2.isTextBlock(block)) {
        const child = block.children[operation.path[1]];
        if (child) {
          const blockKey = block._key;
          const childKey = child._key;
          const patches = [];
          Object.keys(operation.newProperties).forEach((keyName) => {
            const val = (0, import_get2.default)(operation.newProperties, keyName);
            patches.push(set2(val, [{
              _key: blockKey
            }, "children", {
              _key: childKey
            }, keyName]));
          });
          return patches;
        }
        throw new Error("Could not find a valid child");
      }
      throw new Error("Could not find a valid block");
    } else {
      throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
    }
  }
  function insertNodePatch(editor2, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    const isTextBlock = editor2.isTextBlock(block);
    if (operation.path.length === 1) {
      const position = operation.path[0] === 0 ? "before" : "after";
      const beforeBlock = beforeValue[operation.path[0] - 1];
      const targetKey = operation.path[0] === 0 ? block == null ? void 0 : block._key : beforeBlock == null ? void 0 : beforeBlock._key;
      if (targetKey) {
        return [insert$1([fromSlateValue([operation.node], textBlockName)[0]], position, [{
          _key: targetKey
        }])];
      }
      return [setIfMissing(beforeValue, []), insert$1([fromSlateValue([operation.node], textBlockName)[0]], "before", [operation.path[0]])];
    } else if (isTextBlock && operation.path.length === 2 && editor2.children[operation.path[0]]) {
      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after";
      const node = {
        ...operation.node
      };
      if (!node._type && Text2.isText(node)) {
        node._type = "span";
        node.marks = [];
      }
      const blk = fromSlateValue([{
        _key: "bogus",
        _type: textBlockName,
        children: [node]
      }], textBlockName)[0];
      const child = blk.children[0];
      return [insert$1([child], position, [{
        _key: block._key
      }, "children", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {
        _key: block.children[operation.path[1] - 1]._key
      }])];
    }
    debug$k("Something was inserted into a void block. Not producing editor patches.");
    return [];
  }
  function splitNodePatch(editor2, operation, beforeValue) {
    const patches = [];
    const splitBlock = editor2.children[operation.path[0]];
    if (!editor2.isTextBlock(splitBlock)) {
      throw new Error("Block with path ".concat(JSON.stringify(operation.path[0]), " is not a text block and can't be split"));
    }
    if (operation.path.length === 1) {
      const oldBlock = beforeValue[operation.path[0]];
      if (editor2.isTextBlock(oldBlock)) {
        const targetValue = fromSlateValue([editor2.children[operation.path[0] + 1]], textBlockName)[0];
        if (targetValue) {
          patches.push(insert$1([targetValue], "after", [{
            _key: splitBlock._key
          }]));
          const spansToUnset = oldBlock.children.slice(operation.position);
          spansToUnset.forEach((span) => {
            const path2 = [{
              _key: oldBlock._key
            }, "children", {
              _key: span._key
            }];
            patches.push(unset(path2));
          });
        }
      }
      return patches;
    }
    if (operation.path.length === 2) {
      const splitSpan = splitBlock.children[operation.path[1]];
      if (editor2.isTextSpan(splitSpan)) {
        const targetSpans = fromSlateValue([{
          ...splitBlock,
          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
        }], textBlockName)[0].children;
        patches.push(insert$1(targetSpans, "after", [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }]));
        patches.push(set2(splitSpan.text, [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }, "text"]));
      }
      return patches;
    }
    return patches;
  }
  function removeNodePatch(editor2, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
      if (block && block._key) {
        return [unset([{
          _key: block._key
        }])];
      }
      throw new Error("Block not found");
    } else if (editor2.isTextBlock(block) && operation.path.length === 2) {
      const spanToRemove = editor2.isTextBlock(block) && block.children && block.children[operation.path[1]];
      if (spanToRemove) {
        return [unset([{
          _key: block._key
        }, "children", {
          _key: spanToRemove._key
        }])];
      }
      debug$k("Span not found in editor trying to remove node");
      return [];
    } else {
      debug$k("Not creating patch inside object block");
      return [];
    }
  }
  function mergeNodePatch(editor2, operation, beforeValue) {
    const patches = [];
    const block = beforeValue[operation.path[0]];
    const targetBlock = editor2.children[operation.path[0]];
    if (operation.path.length === 1) {
      if (block == null ? void 0 : block._key) {
        const newBlock = fromSlateValue([editor2.children[operation.path[0] - 1]], textBlockName)[0];
        patches.push(set2(newBlock, [{
          _key: newBlock._key
        }]));
        patches.push(unset([{
          _key: block._key
        }]));
      } else {
        throw new Error("Target key not found!");
      }
    } else if (operation.path.length === 2 && editor2.isTextBlock(targetBlock)) {
      const mergedSpan = editor2.isTextBlock(block) && block.children[operation.path[1]] || void 0;
      const targetSpan = targetBlock.children[operation.path[1] - 1];
      if (editor2.isTextSpan(targetSpan)) {
        patches.push(set2(targetSpan.text, [{
          _key: block._key
        }, "children", {
          _key: targetSpan._key
        }, "text"]));
        if (mergedSpan) {
          patches.push(unset([{
            _key: block._key
          }, "children", {
            _key: mergedSpan._key
          }]));
        }
      }
    } else {
      debug$k("Void nodes can't be merged, not creating any patches");
    }
    return patches;
  }
  function moveNodePatch(editor2, operation, beforeValue) {
    const patches = [];
    const block = beforeValue[operation.path[0]];
    const targetBlock = beforeValue[operation.newPath[0]];
    if (operation.path.length === 1) {
      const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
      patches.push(unset([{
        _key: block._key
      }]));
      patches.push(insert$1([fromSlateValue([block], textBlockName)[0]], position, [{
        _key: targetBlock._key
      }]));
    } else if (operation.path.length === 2 && editor2.isTextBlock(block) && editor2.isTextBlock(targetBlock)) {
      const child = block.children[operation.path[1]];
      const targetChild = targetBlock.children[operation.newPath[1]];
      const position = operation.newPath[1] === targetBlock.children.length ? "after" : "before";
      const childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
      patches.push(unset([{
        _key: block._key
      }, "children", {
        _key: child._key
      }]));
      patches.push(insert$1([childToInsert], position, [{
        _key: targetBlock._key
      }, "children", {
        _key: targetChild._key
      }]));
    }
    return patches;
  }
  return {
    insertNodePatch,
    insertTextPatch,
    mergeNodePatch,
    moveNodePatch,
    removeNodePatch,
    removeTextPatch,
    setNodePatch,
    splitNodePatch
  };
}
function createKeyedPath(point, value, types3) {
  const blockPath = [point.path[0]];
  if (!value) {
    return null;
  }
  const block = value[blockPath[0]];
  if (!block) {
    return null;
  }
  const keyedBlockPath = [{
    _key: block._key
  }];
  if (block._type !== types3.block.name) {
    return keyedBlockPath;
  }
  let keyedChildPath;
  const childPath = point.path.slice(0, 2);
  const child = Array.isArray(block.children) && block.children[childPath[1]];
  if (child) {
    keyedChildPath = ["children", {
      _key: child._key
    }];
  }
  return keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;
}
function createArrayedPath(point, editor2) {
  if (!editor2) {
    return [];
  }
  const [block, blockPath] = Array.from(Editor.nodes(editor2, {
    at: [],
    match: (n) => isKeySegment(point.path[0]) && n._key === point.path[0]._key
  }))[0] || [void 0, void 0];
  if (!block || !Element2.isElement(block)) {
    return [];
  }
  if (editor2.isVoid(block)) {
    return [blockPath[0], 0];
  }
  const childPath = [point.path[2]];
  const childIndex = block.children.findIndex((child) => (0, import_isEqual2.default)([{
    _key: child._key
  }], childPath));
  if (childIndex >= 0 && block.children[childIndex]) {
    const child = block.children[childIndex];
    if (Element2.isElement(child) && editor2.isVoid(child)) {
      return blockPath.concat(childIndex).concat(0);
    }
    return blockPath.concat(childIndex);
  }
  return blockPath;
}
function toPortableTextRange(value, range2, types3) {
  if (!range2) {
    return null;
  }
  let anchor = null;
  let focus = null;
  const anchorPath = range2.anchor && createKeyedPath(range2.anchor, value, types3);
  if (anchorPath && range2.anchor) {
    anchor = {
      path: anchorPath,
      offset: range2.anchor.offset
    };
  }
  const focusPath = range2.focus && createKeyedPath(range2.focus, value, types3);
  if (focusPath && range2.focus) {
    focus = {
      path: focusPath,
      offset: range2.focus.offset
    };
  }
  return anchor && focus ? {
    anchor,
    focus
  } : null;
}
function toSlateRange(selection, editor2) {
  if (!selection || !editor2) {
    return null;
  }
  const anchor = {
    path: createArrayedPath(selection.anchor, editor2),
    offset: selection.anchor.offset
  };
  const focus = {
    path: createArrayedPath(selection.focus, editor2),
    offset: selection.focus.offset
  };
  const range2 = anchor && focus ? {
    anchor,
    focus
  } : null;
  return range2;
}
function removeAllDocumentSelectionRanges(hasEditorSelection) {
  if (hasEditorSelection) {
    const domSelection = hasEditorSelection && window.getSelection();
    domSelection == null ? void 0 : domSelection.removeAllRanges();
  }
}
var debug$j = debugWithName("API:editable");
function createWithEditableAPI(portableTextEditor, types3, keyGenerator) {
  return function withEditableAPI(editor2) {
    portableTextEditor.setEditable({
      focus: () => {
        ReactEditor.focus(editor2);
      },
      blur: () => {
        ReactEditor.blur(editor2);
      },
      toggleMark: (mark) => {
        editor2.pteToggleMark(mark);
      },
      toggleList: (listStyle) => {
        editor2.pteToggleListItem(listStyle);
      },
      toggleBlockStyle: (blockStyle) => {
        editor2.pteToggleBlockStyle(blockStyle);
      },
      isMarkActive: (mark) => {
        try {
          return editor2.pteIsMarkActive(mark);
        } catch (err) {
          console.warn(err);
          return false;
        }
      },
      marks: () => {
        return {
          ...Editor.marks(editor2) || {}
        }.marks || [];
      },
      undo: () => editor2.undo(),
      redo: () => editor2.redo(),
      select: (selection) => {
        const slateSelection = toSlateRange(selection, editor2);
        if (slateSelection) {
          Transforms.select(editor2, slateSelection);
        } else {
          Transforms.deselect(editor2);
        }
        editor2.onChange();
      },
      focusBlock: () => {
        if (editor2.selection) {
          const block = Node2.descendant(editor2, editor2.selection.focus.path.slice(0, 1));
          if (block) {
            return fromSlateValue([block], types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2))[0];
          }
        }
        return void 0;
      },
      focusChild: () => {
        if (editor2.selection) {
          const block = Node2.descendant(editor2, editor2.selection.focus.path.slice(0, 1));
          if (block && editor2.isTextBlock(block)) {
            const ptBlock = fromSlateValue([block], types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2))[0];
            return ptBlock.children[editor2.selection.focus.path[1]];
          }
        }
        return void 0;
      },
      insertChild: (type, value) => {
        var _a4;
        if (!editor2.selection) {
          throw new Error("The editor has no selection");
        }
        const [focusBlock] = Array.from(Editor.nodes(editor2, {
          at: editor2.selection.focus.path.slice(0, 1),
          match: (n) => n._type === types3.block.name
        }))[0] || [void 0];
        if (!focusBlock) {
          throw new Error("No focused text block");
        }
        if (type.name !== types3.span.name && !types3.inlineObjects.some((t3) => t3.name === type.name)) {
          throw new Error("This type cannot be inserted as a child to a text block");
        }
        const block = toSlateValue([{
          _key: keyGenerator(),
          _type: types3.block.name,
          children: [{
            _key: keyGenerator(),
            _type: type.name,
            ...value ? value : {}
          }]
        }], portableTextEditor)[0];
        const child = block.children[0];
        const focusChildPath = editor2.selection.focus.path.slice(0, 2);
        const isSpanNode = child._type === types3.span.name;
        const focusNode = Node2.get(editor2, focusChildPath);
        if (isSpanNode && focusNode._type !== types3.span.name) {
          debug$j("Inserting span child next to inline object child, moving selection + 1");
          editor2.move({
            distance: 1,
            unit: "character"
          });
        }
        Transforms.insertNodes(editor2, child, {
          select: true,
          at: editor2.selection
        });
        editor2.onChange();
        return ((_a4 = toPortableTextRange(fromSlateValue(editor2.children, types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2)), editor2.selection, types3)) == null ? void 0 : _a4.focus.path) || [];
      },
      insertBlock: (type, value) => {
        var _a4;
        if (!editor2.selection) {
          throw new Error("The editor has no selection");
        }
        const block = toSlateValue([{
          _key: keyGenerator(),
          _type: type.name,
          ...value ? value : {}
        }], portableTextEditor)[0];
        Editor.insertNode(editor2, block);
        editor2.onChange();
        return ((_a4 = toPortableTextRange(fromSlateValue(editor2.children, types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2)), editor2.selection, types3)) == null ? void 0 : _a4.focus.path) || [];
      },
      hasBlockStyle: (style) => {
        try {
          return editor2.pteHasBlockStyle(style);
        } catch (err) {
          return false;
        }
      },
      hasListStyle: (listStyle) => {
        try {
          return editor2.pteHasListStyle(listStyle);
        } catch (err) {
          return false;
        }
      },
      isVoid: (element) => {
        return ![types3.block.name, types3.span.name].includes(element._type);
      },
      findByPath: (path2) => {
        const slatePath = toSlateRange({
          focus: {
            path: path2,
            offset: 0
          },
          anchor: {
            path: path2,
            offset: 0
          }
        }, editor2);
        if (slatePath) {
          const [block, blockPath] = Editor.node(editor2, slatePath.focus.path.slice(0, 1));
          if (block && blockPath && typeof block._key === "string") {
            if (path2.length === 1 && slatePath.focus.path.length === 1) {
              return [fromSlateValue([block], types3.block.name)[0], [{
                _key: block._key
              }]];
            }
            const ptBlock = fromSlateValue([block], types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2))[0];
            if (editor2.isTextBlock(ptBlock)) {
              const ptChild = ptBlock.children[slatePath.focus.path[1]];
              if (ptChild) {
                return [ptChild, [{
                  _key: block._key
                }, "children", {
                  _key: ptChild._key
                }]];
              }
            }
          }
        }
        return [void 0, void 0];
      },
      findDOMNode: (element) => {
        let node;
        try {
          const [item] = Array.from(Editor.nodes(editor2, {
            at: [],
            match: (n) => n._key === element._key
          }) || [])[0] || [void 0];
          node = ReactEditor.toDOMNode(editor2, item);
        } catch (err) {
        }
        return node;
      },
      activeAnnotations: () => {
        var _a4;
        if (!editor2.selection || editor2.selection.focus.path.length < 2) {
          return [];
        }
        try {
          const activeAnnotations = [];
          const spans = Editor.nodes(editor2, {
            at: editor2.selection,
            match: (node) => Text2.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
          });
          for (const [span, path2] of spans) {
            const [block] = Editor.node(editor2, path2, {
              depth: 1
            });
            if (editor2.isTextBlock(block)) {
              (_a4 = block.markDefs) == null ? void 0 : _a4.forEach((def) => {
                if (Text2.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                  activeAnnotations.push(def);
                }
              });
            }
          }
          return activeAnnotations;
        } catch (err) {
          return [];
        }
      },
      addAnnotation: (type, value) => {
        const {
          selection
        } = editor2;
        if (selection) {
          const [block] = Editor.node(editor2, selection.focus, {
            depth: 1
          });
          if (Element2.isElement(block) && block._type === types3.block.name) {
            const annotationKey = keyGenerator();
            if (editor2.isTextBlock(block)) {
              Transforms.setNodes(editor2, {
                markDefs: [...block.markDefs || [], {
                  _type: type.name,
                  _key: annotationKey,
                  ...value
                }]
              }, {
                at: selection.focus
              });
              editor2.onChange();
              if (Range.isCollapsed(selection)) {
                editor2.pteExpandToWord();
                editor2.onChange();
              }
              const [textNode] = Editor.node(editor2, selection.focus, {
                depth: 2
              });
              if (editor2.selection) {
                Editor.withoutNormalizing(editor2, () => {
                  Transforms.setNodes(editor2, {}, {
                    match: Text2.isText,
                    split: true
                  });
                  if (editor2.selection && Text2.isText(textNode)) {
                    Transforms.setNodes(editor2, {
                      marks: [...textNode.marks || [], annotationKey]
                    }, {
                      at: editor2.selection,
                      match: (n) => n._type === types3.span.name
                    });
                    editor2.onChange();
                  }
                });
                Editor.normalize(editor2);
                editor2.onChange();
                const newSelection = toPortableTextRange(fromSlateValue(editor2.children, types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2)), editor2.selection, types3);
                if (newSelection && typeof block._key === "string") {
                  Editor.withoutNormalizing(editor2, () => {
                    if (editor2.selection) {
                      Transforms.insertNodes(editor2, [{
                        _type: "span",
                        text: "",
                        marks: [],
                        _key: keyGenerator()
                      }], {
                        at: Range.end(editor2.selection)
                      });
                      editor2.onChange();
                    }
                  });
                  return {
                    spanPath: newSelection.focus.path,
                    markDefPath: [{
                      _key: block._key
                    }, "markDefs", {
                      _key: annotationKey
                    }]
                  };
                }
              }
            }
          }
        }
        return void 0;
      },
      delete: (selection, options) => {
        if (selection) {
          const range2 = toSlateRange(selection, editor2);
          const hasRange = range2 && range2.anchor.path.length > 0 && range2.focus.path.length > 0;
          if (!hasRange) {
            throw new Error("Invalid range");
          }
          if (range2) {
            if (!(options == null ? void 0 : options.mode) || (options == null ? void 0 : options.mode) === "selected") {
              debug$j("Deleting content in selection");
              Transforms.delete(editor2, {
                at: range2,
                hanging: true,
                voids: true
              });
              editor2.onChange();
              return;
            }
            if ((options == null ? void 0 : options.mode) === "blocks") {
              debug$j("Deleting blocks touched by selection");
              Transforms.removeNodes(editor2, {
                at: range2,
                voids: true,
                match: (node) => {
                  return editor2.isTextBlock(node) || !editor2.isTextBlock(node) && Element2.isElement(node);
                }
              });
            }
            if ((options == null ? void 0 : options.mode) === "children") {
              debug$j("Deleting children touched by selection");
              Transforms.removeNodes(editor2, {
                at: range2,
                voids: true,
                match: (node) => {
                  return node._type === types3.span.name || // Text children
                  !editor2.isTextBlock(node) && Element2.isElement(node);
                }
              });
            }
            if (editor2.children.length === 0) {
              editor2.children = [editor2.createPlaceholderBlock()];
            }
            editor2.onChange();
          }
        }
      },
      removeAnnotation: (type) => {
        let {
          selection
        } = editor2;
        debug$j("Removing annotation", type);
        if (selection) {
          if (Range.isCollapsed(selection)) {
            const [node, nodePath] = Editor.node(editor2, selection, {
              depth: 2
            });
            if (Text2.isText(node) && node.marks && typeof node.text === "string") {
              Transforms.select(editor2, nodePath);
              selection = editor2.selection;
            }
          }
          Editor.withoutNormalizing(editor2, () => {
            if (selection && Range.isExpanded(selection)) {
              selection = editor2.selection;
              if (!selection) {
                return;
              }
              Transforms.setNodes(editor2, {}, {
                match: Text2.isText,
                split: true
              });
              editor2.onChange();
              const spans = [...Editor.nodes(editor2, {
                at: selection,
                match: (node) => Text2.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
              })];
              spans.forEach((_ref2) => {
                let [span, path2] = _ref2;
                var _a4;
                const [block] = Editor.node(editor2, path2, {
                  depth: 1
                });
                if (editor2.isTextBlock(block)) {
                  (_a4 = block.markDefs) == null ? void 0 : _a4.filter((def) => def._type === type.name).forEach((def) => {
                    if (Text2.isText(span) && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                      const newMarks = [...(span.marks || []).filter((mark) => mark !== def._key)];
                      Transforms.setNodes(editor2, {
                        marks: newMarks
                      }, {
                        at: path2,
                        voids: false,
                        split: false
                      });
                    }
                  });
                }
              });
            }
          });
          Editor.normalize(editor2);
          editor2.onChange();
        }
      },
      getSelection: () => {
        let ptRange = null;
        if (editor2.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor2.selection);
          if (existing) {
            return existing;
          }
          ptRange = toPortableTextRange(fromSlateValue(editor2.children, types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2)), editor2.selection, types3);
          SLATE_TO_PORTABLE_TEXT_RANGE.set(editor2.selection, ptRange);
        }
        return ptRange;
      },
      getValue: () => {
        return fromSlateValue(editor2.children, types3.block.name, KEY_TO_VALUE_ELEMENT.get(editor2));
      },
      isCollapsedSelection: () => {
        return !!editor2.selection && Range.isCollapsed(editor2.selection);
      },
      isExpandedSelection: () => {
        return !!editor2.selection && Range.isExpanded(editor2.selection);
      },
      insertBreak: () => {
        editor2.insertBreak();
        editor2.onChange();
      }
    });
    return editor2;
  };
}
function createWithMaxBlocks(maxBlocks) {
  return function withMaxBlocks(editor2) {
    const {
      apply: apply3
    } = editor2;
    editor2.apply = (operation) => {
      const rows = maxBlocks;
      if (rows > 0 && editor2.children.length >= rows) {
        if ((operation.type === "insert_node" || operation.type === "split_node") && operation.path.length === 1) {
          return;
        }
      }
      apply3(operation);
    };
    return editor2;
  };
}
var PRESERVE_KEYS = /* @__PURE__ */ new WeakMap();
function withPreserveKeys(editor2, fn) {
  const prev = isPreservingKeys(editor2);
  PRESERVE_KEYS.set(editor2, true);
  fn();
  PRESERVE_KEYS.set(editor2, prev);
}
function isPreservingKeys(editor2) {
  return PRESERVE_KEYS.get(editor2);
}
function createWithObjectKeys(schemaTypes, keyGenerator) {
  return function withKeys(editor2) {
    PRESERVE_KEYS.set(editor2, false);
    const {
      apply: apply3,
      normalizeNode
    } = editor2;
    editor2.apply = (operation) => {
      if (operation.type === "split_node") {
        operation.properties = {
          ...operation.properties,
          _key: keyGenerator()
        };
      }
      if (operation.type === "insert_node") {
        const withNewKey = !isPreservingKeys(editor2) || !("_key" in operation.node);
        if (!Editor.isEditor(operation.node)) {
          operation.node = {
            ...operation.node,
            ...withNewKey ? {
              _key: keyGenerator()
            } : {}
          };
        }
      }
      apply3(operation);
    };
    editor2.normalizeNode = (entry) => {
      const [node, path2] = entry;
      if (Element2.isElement(node) && node._type === schemaTypes.block.name) {
        if (!node._key) {
          Transforms.setNodes(editor2, {
            _key: keyGenerator()
          }, {
            at: path2
          });
        }
        for (const [child, childPath] of Node2.children(editor2, path2)) {
          if (!child._key) {
            Transforms.setNodes(editor2, {
              _key: keyGenerator()
            }, {
              at: childPath
            });
            return;
          }
        }
      }
      normalizeNode(entry);
    };
    return editor2;
  };
}
var PATCHING = /* @__PURE__ */ new WeakMap();
function withoutPatching(editor2, fn) {
  const prev = isPatching(editor2);
  PATCHING.set(editor2, false);
  fn();
  PATCHING.set(editor2, prev);
}
function isPatching(editor2) {
  return PATCHING.get(editor2);
}
var BEFORE = "before";
var AFTER = "after";
function insert(array3, position, index) {
  if (position !== BEFORE && position !== AFTER) {
    throw new Error('Invalid position "'.concat(position, '", must be either ').concat(BEFORE, " or ").concat(AFTER));
  }
  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }
  const items = flatten3(...args);
  if (array3.length === 0) {
    return items;
  }
  const len = array3.length;
  const idx = Math.abs((len + index) % len) % len;
  const normalizedIdx = position === "after" ? idx + 1 : idx;
  const copy2 = array3.slice();
  copy2.splice(normalizedIdx, 0, ...flatten3(items));
  return copy2;
}
function flatten3() {
  for (var _len3 = arguments.length, values2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    values2[_key3] = arguments[_key3];
  }
  return values2.reduce((prev, item) => prev.concat(item), []);
}
var hasOwn2 = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function move(arr, from2, to) {
  const nextValue = arr.slice();
  const val = nextValue[from2];
  nextValue.splice(from2, 1);
  nextValue.splice(to, 0, val);
  return nextValue;
}
function findTargetIndex(array3, pathSegment) {
  if (typeof pathSegment === "number") {
    return pathSegment;
  }
  const index = (0, import_findIndex.default)(array3, pathSegment);
  return index === -1 ? false : index;
}
function apply$3(value, patch2) {
  const nextValue = value.slice();
  if (patch2.path.length === 0) {
    if (patch2.type === "setIfMissing") {
      if (!Array.isArray(patch2.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return value === void 0 ? patch2.value : value;
    } else if (patch2.type === "set") {
      if (!Array.isArray(patch2.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return patch2.value;
    } else if (patch2.type === "unset") {
      return void 0;
    } else if (patch2.type === "move") {
      if (!patch2.value || !hasOwn2(patch2.value, "from") || !hasOwn2(patch2.value, "to")) {
        throw new Error(`Invalid value of 'move' patch. Expected a value with "from" and "to" indexes, instead got: `.concat(JSON.stringify(patch2.value)));
      }
      return move(nextValue, patch2.value.from, patch2.value.to);
    }
    throw new Error("Invalid array operation: ".concat(patch2.type));
  }
  const [head, ...tail] = patch2.path;
  const index = findTargetIndex(value, head);
  if (index === false) {
    return nextValue;
  }
  if (tail.length === 0) {
    if (patch2.type === "insert") {
      const {
        position,
        items
      } = patch2;
      return insert(value, position, index, items);
    } else if (patch2.type === "unset") {
      if (typeof index !== "number") {
        throw new Error('Expected array index to be a number, instead got "'.concat(index, '"'));
      }
      nextValue.splice(index, 1);
      return nextValue;
    }
  }
  nextValue[index] = _apply(nextValue[index], {
    ...patch2,
    path: tail
  });
  return nextValue;
}
function apply$2(value, patch2) {
  const nextValue = (0, import_clone.default)(value);
  if (patch2.path.length === 0) {
    if (patch2.type === "set") {
      if (!(0, import_isObject.default)(patch2.value)) {
        throw new Error("Cannot set value of an object to a non-object");
      }
      return patch2.value;
    } else if (patch2.type === "unset") {
      return void 0;
    } else if (patch2.type === "setIfMissing") {
      return value === void 0 ? patch2.value : value;
    }
    throw new Error("Invalid object operation: ".concat(patch2.type));
  }
  const [head, ...tail] = patch2.path;
  if (typeof head !== "string") {
    throw new Error("Expected field name to be a string, instad got: ".concat(head));
  }
  if (tail.length === 0 && patch2.type === "unset") {
    return (0, import_omit3.default)(nextValue, head);
  }
  nextValue[head] = _apply(nextValue[head], {
    ...patch2,
    path: tail
  });
  return nextValue;
}
var OPERATIONS$1 = {
  replace(_currentValue, nextValue) {
    return nextValue;
  },
  set(_currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(_currentValue, _nextValue) {
    return void 0;
  },
  inc(currentValue, nextValue) {
    return currentValue + nextValue;
  },
  dec(currentValue, nextValue) {
    return currentValue - nextValue;
  }
};
var SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function apply$1(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES$1.includes(patch2.type)) {
    throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch2.type), '" for primitives. This is most likely a bug.'));
  }
  if (patch2.path.length > 0) {
    throw new Error('Cannot apply deep operations on primitive values. Received patch with type "'.concat(patch2.type, '" and path "').concat(patch2.path.map((path2) => JSON.stringify(path2)).join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
  }
  return OPERATIONS$1[patch2.type](value, patch2.value);
}
var OPERATIONS = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
    return void 0;
  },
  diffMatchPatch(currentValue, nextValue) {
    const [result] = apply$4(parse3(nextValue), currentValue, {
      allowExceedingIndices: true
    });
    return result;
  }
};
var SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function apply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES.includes(patch2.type)) {
    throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch2.type), '" for string. This is most likely a bug.'));
  }
  if (patch2.path.length > 0) {
    throw new Error('Cannot apply deep operations on string values. Received patch with type "'.concat(patch2.type, '" and path "').concat(patch2.path.join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
  }
  const func = OPERATIONS[patch2.type];
  if (func) {
    return func(value, patch2.value);
  }
  throw new Error("Unknown patch type");
}
function applyAll(value, patches) {
  return patches.reduce(_apply, value);
}
function applyPatch(value, patch2) {
  if (Array.isArray(value)) {
    return apply$3(value, patch2);
  }
  if ((0, import_isString.default)(value)) {
    return apply(value, patch2);
  }
  if ((0, import_isObject.default)(value)) {
    return apply$2(value, patch2);
  }
  return apply$1(value, patch2);
}
function _apply(value, patch2) {
  const res = applyPatch(value, patch2);
  return res;
}
var debug$i = debugWithName("applyPatches");
var debugVerbose$3 = debug$i.enabled && true;
function createApplyPatch(schemaTypes) {
  let previousPatch;
  return function(editor2, patch2) {
    let changed = false;
    if (debugVerbose$3) {
      debug$i("\n\nNEW PATCH =============================================================");
      debug$i(JSON.stringify(patch2, null, 2));
    }
    try {
      switch (patch2.type) {
        case "insert":
          changed = insertPatch(editor2, patch2, schemaTypes);
          break;
        case "unset":
          changed = unsetPatch(editor2, patch2, previousPatch);
          break;
        case "set":
          changed = setPatch(editor2, patch2);
          break;
        case "diffMatchPatch":
          changed = diffMatchPatch(editor2, patch2);
          break;
        default:
          debug$i("Unhandled patch", patch2.type);
      }
    } catch (err) {
      console.error(err);
    }
    previousPatch = patch2;
    return changed;
  };
}
function diffMatchPatch(editor2, patch2) {
  const {
    block,
    child,
    childPath
  } = findBlockAndChildFromPath(editor2, patch2.path);
  if (!block) {
    debug$i("Block not found");
    return false;
  }
  if (!child || !childPath) {
    debug$i("Child not found");
    return false;
  }
  const isSpanTextDiffMatchPatch = block && editor2.isTextBlock(block) && patch2.path.length === 4 && patch2.path[1] === "children" && patch2.path[3] === "text";
  if (!isSpanTextDiffMatchPatch || !Text2.isText(child)) {
    return false;
  }
  const patches = parse3(patch2.value);
  const [newValue] = apply$4(patches, child.text, {
    allowExceedingIndices: true
  });
  const diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);
  debugState(editor2, "before");
  let offset2 = 0;
  for (const [op, text] of diff$1) {
    if (op === DIFF_INSERT) {
      editor2.apply({
        type: "insert_text",
        path: childPath,
        offset: offset2,
        text
      });
      offset2 += text.length;
    } else if (op === DIFF_DELETE) {
      editor2.apply({
        type: "remove_text",
        path: childPath,
        offset: offset2,
        text
      });
    } else if (op === DIFF_EQUAL) {
      offset2 += text.length;
    }
  }
  debugState(editor2, "after");
  return true;
}
function insertPatch(editor2, patch2, schemaTypes) {
  const {
    block: targetBlock,
    child: targetChild,
    blockPath: targetBlockPath,
    childPath: targetChildPath
  } = findBlockAndChildFromPath(editor2, patch2.path);
  if (!targetBlock || !targetBlockPath) {
    debug$i("Block not found");
    return false;
  }
  if (patch2.path.length > 1 && patch2.path[1] !== "children") {
    debug$i("Ignoring patch targeting void value");
    return false;
  }
  if (patch2.path.length === 1) {
    const {
      items: items2,
      position: position2
    } = patch2;
    const blocksToInsert = toSlateValue(items2, {
      schemaTypes
    }, KEY_TO_SLATE_ELEMENT.get(editor2));
    const targetBlockIndex = targetBlockPath[0];
    const normalizedIdx2 = position2 === "after" ? targetBlockIndex + 1 : targetBlockIndex;
    debug$i("Inserting blocks at path [".concat(normalizedIdx2, "]"));
    debugState(editor2, "before");
    Transforms.insertNodes(editor2, blocksToInsert, {
      at: [normalizedIdx2]
    });
    debugState(editor2, "after");
    return true;
  }
  const {
    items,
    position
  } = patch2;
  if (!targetChild || !targetChildPath) {
    debug$i("Child not found");
    return false;
  }
  const childrenToInsert = targetBlock && toSlateValue([{
    ...targetBlock,
    children: items
  }], {
    schemaTypes
  }, KEY_TO_SLATE_ELEMENT.get(editor2));
  const targetChildIndex = targetChildPath[1];
  const normalizedIdx = position === "after" ? targetChildIndex + 1 : targetChildIndex;
  const childInsertPath = [targetChildPath[0], normalizedIdx];
  debug$i("Inserting children at path ".concat(childInsertPath));
  debugState(editor2, "before");
  if (childrenToInsert && Element2.isElement(childrenToInsert[0])) {
    Transforms.insertNodes(editor2, childrenToInsert[0].children, {
      at: childInsertPath
    });
  }
  debugState(editor2, "after");
  return true;
}
function setPatch(editor2, patch2) {
  let value = patch2.value;
  if (typeof patch2.path[3] === "string") {
    value = {};
    value[patch2.path[3]] = patch2.value;
  }
  const {
    block,
    blockPath,
    child,
    childPath
  } = findBlockAndChildFromPath(editor2, patch2.path);
  if (!block) {
    debug$i("Block not found");
    return false;
  }
  const isTextBlock = editor2.isTextBlock(block);
  if (isTextBlock && patch2.path.length > 1 && patch2.path[1] !== "children") {
    debug$i("Ignoring setting void value");
    return false;
  }
  debugState(editor2, "before");
  if (isTextBlock && child && childPath) {
    if (Text2.isText(value) && Text2.isText(child)) {
      const newText = child.text;
      const oldText = value.text;
      if (oldText !== newText) {
        debug$i("Setting text property");
        editor2.apply({
          type: "remove_text",
          path: childPath,
          offset: 0,
          text: newText
        });
        editor2.apply({
          type: "insert_text",
          path: childPath,
          offset: 0,
          text: value.text
        });
        editor2.onChange();
      }
    } else {
      debug$i("Setting non-text property");
      editor2.apply({
        type: "set_node",
        path: childPath,
        properties: {},
        newProperties: value
      });
    }
    return true;
  } else if (Element2.isElement(block) && patch2.path.length === 1 && blockPath) {
    debug$i("Setting block property");
    const {
      children,
      ...nextRest
    } = value;
    const {
      children: prevChildren,
      ...prevRest
    } = block || {
      children: void 0
    };
    editor2.apply({
      type: "set_node",
      path: blockPath,
      properties: {
        ...prevRest
      },
      newProperties: nextRest
    });
    block.children.forEach((c, cIndex) => {
      editor2.apply({
        type: "remove_node",
        path: blockPath.concat(cIndex),
        node: c
      });
    });
    if (Array.isArray(children)) {
      children.forEach((c, cIndex) => {
        editor2.apply({
          type: "insert_node",
          path: blockPath.concat(cIndex),
          node: c
        });
      });
    }
  } else if (block && "value" in block) {
    const newVal = applyAll([block.value], [patch2])[0];
    Transforms.setNodes(editor2, {
      ...block,
      value: newVal
    }, {
      at: blockPath
    });
    return true;
  }
  debugState(editor2, "after");
  return true;
}
function unsetPatch(editor2, patch2, previousPatch) {
  if (patch2.path.length === 0) {
    debug$i("Removing everything");
    debugState(editor2, "before");
    const previousSelection = editor2.selection;
    Transforms.deselect(editor2);
    editor2.children.forEach((c, i) => {
      Transforms.removeNodes(editor2, {
        at: [i]
      });
    });
    Transforms.insertNodes(editor2, editor2.createPlaceholderBlock());
    if (previousSelection) {
      Transforms.select(editor2, {
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        }
      });
    }
    editor2.onChange();
    debugState(editor2, "after");
    return true;
  }
  const {
    block,
    blockPath,
    child,
    childPath
  } = findBlockAndChildFromPath(editor2, patch2.path);
  if (patch2.path.length === 1) {
    if (!block || !blockPath) {
      debug$i("Block not found");
      return false;
    }
    const blockIndex = blockPath[0];
    debug$i("Removing block at path [".concat(blockIndex, "]"));
    debugState(editor2, "before");
    Transforms.removeNodes(editor2, {
      at: [blockIndex]
    });
    debugState(editor2, "after");
    return true;
  }
  if (editor2.isTextBlock(block) && patch2.path[1] === "children" && patch2.path.length === 3) {
    if (!child || !childPath) {
      debug$i("Child not found");
      return false;
    }
    const childIndex = childPath[1];
    debug$i("Unsetting child at path ".concat(JSON.stringify(childPath)));
    debugState(editor2, "before");
    if (debugVerbose$3) {
      debug$i("Removing child at path ".concat(JSON.stringify([childPath, childIndex])));
    }
    Transforms.removeNodes(editor2, {
      at: childPath
    });
    debugState(editor2, "after");
    return true;
  }
  return false;
}
function isKeyedSegment(segment) {
  return typeof segment === "object" && "_key" in segment;
}
function debugState(editor2, stateName) {
  if (!debugVerbose$3) {
    return;
  }
  debug$i("Children ".concat(stateName, ":"), JSON.stringify(editor2.children, null, 2));
  debug$i("Selection ".concat(stateName, ": "), JSON.stringify(editor2.selection, null, 2));
}
function findBlockFromPath(editor2, path2) {
  let blockIndex = -1;
  const block = editor2.children.find((node, index) => {
    const isMatch = isKeyedSegment(path2[0]) ? node._key === path2[0]._key : index === path2[0];
    if (isMatch) {
      blockIndex = index;
    }
    return isMatch;
  });
  if (!block) {
    return {};
  }
  return {
    block,
    path: [blockIndex]
  };
}
function findBlockAndChildFromPath(editor2, path2) {
  const {
    block,
    path: blockPath
  } = findBlockFromPath(editor2, path2);
  if (!(Element2.isElement(block) && path2[1] === "children")) {
    return {
      block,
      blockPath,
      child: void 0,
      childPath: void 0
    };
  }
  let childIndex = -1;
  const child = block.children.find((node, index) => {
    const isMatch = isKeyedSegment(path2[2]) ? node._key === path2[2]._key : index === path2[2];
    if (isMatch) {
      childIndex = index;
    }
    return isMatch;
  });
  if (!child) {
    return {
      block,
      blockPath,
      child: void 0,
      childPath: void 0
    };
  }
  return {
    block,
    child,
    blockPath,
    childPath: blockPath == null ? void 0 : blockPath.concat(childIndex)
  };
}
function withRemoteChanges(editor2, fn) {
  const prev = isChangingRemotely(editor2) || false;
  IS_PROCESSING_REMOTE_CHANGES.set(editor2, true);
  fn();
  IS_PROCESSING_REMOTE_CHANGES.set(editor2, prev);
}
function isChangingRemotely(editor2) {
  return IS_PROCESSING_REMOTE_CHANGES.get(editor2);
}
function isChangingLocally(editor2) {
  return IS_PROCESSING_LOCAL_CHANGES.get(editor2);
}
var debug$h = debugWithName("plugin:withUndoRedo");
var debugVerbose$2 = debug$h.enabled && false;
var SAVING = /* @__PURE__ */ new WeakMap();
var REMOTE_PATCHES = /* @__PURE__ */ new WeakMap();
var UNDO_STEP_LIMIT = 1e3;
var isSaving = (editor2) => {
  const state = SAVING.get(editor2);
  return state === void 0 ? true : state;
};
var getRemotePatches = (editor2) => {
  if (!REMOTE_PATCHES.get(editor2)) {
    REMOTE_PATCHES.set(editor2, []);
  }
  return REMOTE_PATCHES.get(editor2) || [];
};
function createWithUndoRedo(options) {
  const {
    readOnly,
    patches$,
    blockSchemaType
  } = options;
  return (editor2) => {
    let previousSnapshot = fromSlateValue(editor2.children, blockSchemaType.name);
    const remotePatches = getRemotePatches(editor2);
    if (patches$) {
      editor2.subscriptions.push(() => {
        debug$h("Subscribing to patches");
        const sub2 = patches$.subscribe((_ref3) => {
          let {
            patches,
            snapshot
          } = _ref3;
          let reset = false;
          patches.forEach((patch2) => {
            if (!reset && patch2.origin !== "local" && remotePatches) {
              if (patch2.type === "unset" && patch2.path.length === 0) {
                debug$h("Someone else cleared the content, resetting undo/redo history");
                editor2.history = {
                  undos: [],
                  redos: []
                };
                remotePatches.splice(0, remotePatches.length);
                SAVING.set(editor2, true);
                reset = true;
                return;
              }
              remotePatches.push({
                patch: patch2,
                time: /* @__PURE__ */ new Date(),
                snapshot,
                previousSnapshot
              });
            }
          });
          previousSnapshot = snapshot;
        });
        return () => {
          debug$h("Unsubscribing to patches");
          sub2.unsubscribe();
        };
      });
    }
    editor2.history = {
      undos: [],
      redos: []
    };
    const {
      apply: apply3
    } = editor2;
    editor2.apply = (op) => {
      if (readOnly) {
        apply3(op);
        return;
      }
      const {
        operations,
        history: history2
      } = editor2;
      const {
        undos
      } = history2;
      const step = undos[undos.length - 1];
      const lastOp = step && step.operations && step.operations[step.operations.length - 1];
      const overwrite = shouldOverwrite(op, lastOp);
      const save = isSaving(editor2);
      let merge2 = true;
      if (save) {
        if (!step) {
          merge2 = false;
        } else if (operations.length === 0) {
          merge2 = shouldMerge(op, lastOp) || overwrite;
        }
        if (step && merge2) {
          step.operations.push(op);
        } else {
          const newStep = {
            operations: [...editor2.selection === null ? [] : [createSelectOperation(editor2)], op],
            timestamp: /* @__PURE__ */ new Date()
          };
          undos.push(newStep);
          debug$h("Created new undo step", step);
        }
        while (undos.length > UNDO_STEP_LIMIT) {
          undos.shift();
        }
        if (shouldClear(op)) {
          history2.redos = [];
        }
      }
      apply3(op);
    };
    editor2.undo = () => {
      if (readOnly) {
        return;
      }
      const {
        undos
      } = editor2.history;
      if (undos.length > 0) {
        const step = undos[undos.length - 1];
        debug$h("Undoing", step);
        if (step.operations.length > 0) {
          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach((item) => {
            transformedOperations = (0, import_flatten3.default)(transformedOperations.map((op) => transformOperation(editor2, item.patch, op, item.snapshot, item.previousSnapshot)));
          });
          removeAllDocumentSelectionRanges(!!editor2.selection);
          try {
            Editor.withoutNormalizing(editor2, () => {
              withoutSaving(editor2, () => {
                transformedOperations.map(Operation.inverse).reverse().forEach((op) => {
                  editor2.apply(op);
                });
              });
            });
            editor2.normalize();
            editor2.onChange();
          } catch (err) {
            debug$h("Could not perform undo step", err);
            remotePatches.splice(0, remotePatches.length);
            Transforms.deselect(editor2);
            editor2.history = {
              undos: [],
              redos: []
            };
            SAVING.set(editor2, true);
            editor2.onChange();
            return;
          }
          editor2.history.redos.push(step);
          editor2.history.undos.pop();
        }
      }
    };
    editor2.redo = () => {
      if (readOnly) {
        return;
      }
      const {
        redos
      } = editor2.history;
      if (redos.length > 0) {
        const step = redos[redos.length - 1];
        debug$h("Redoing", step);
        if (step.operations.length > 0) {
          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach((item) => {
            transformedOperations = (0, import_flatten3.default)(transformedOperations.map((op) => transformOperation(editor2, item.patch, op, item.snapshot, item.previousSnapshot)));
          });
          removeAllDocumentSelectionRanges(!!editor2.selection);
          try {
            Editor.withoutNormalizing(editor2, () => {
              withoutSaving(editor2, () => {
                transformedOperations.forEach((op) => {
                  editor2.apply(op);
                });
              });
            });
            editor2.normalize();
            editor2.onChange();
          } catch (err) {
            debug$h("Could not perform redo step", err);
            remotePatches.splice(0, remotePatches.length);
            Transforms.deselect(editor2);
            editor2.history = {
              undos: [],
              redos: []
            };
            SAVING.set(editor2, true);
            editor2.onChange();
            return;
          }
          editor2.history.undos.push(step);
          editor2.history.redos.pop();
        }
      }
    };
    return editor2;
  };
}
function transformOperation(editor2, patch2, operation, snapshot, previousSnapshot) {
  if (debugVerbose$2) {
    debug$h("Adjusting '".concat(operation.type, "' operation paths for '").concat(patch2.type, "' patch"));
    debug$h("Operation ".concat(JSON.stringify(operation)));
    debug$h("Patch ".concat(JSON.stringify(patch2)));
  }
  const transformedOperation = {
    ...operation
  };
  if (patch2.type === "insert" && patch2.path.length === 1) {
    const insertBlockIndex = (snapshot || []).findIndex((blk) => (0, import_isEqual2.default)({
      _key: blk._key
    }, patch2.path[0]));
    debug$h("Adjusting block path (+".concat(patch2.items.length, ") for '").concat(transformedOperation.type, "' operation and patch '").concat(patch2.type, "'"));
    return [adjustBlockPath(transformedOperation, patch2.items.length, insertBlockIndex)];
  }
  if (patch2.type === "unset" && patch2.path.length === 1) {
    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => (0, import_isEqual2.default)({
      _key: blk._key
    }, patch2.path[0]));
    if ("path" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex) {
      debug$h("Skipping transformation that targeted removed block");
      return [];
    }
    if (debugVerbose$2) {
      debug$h("Selection ".concat(JSON.stringify(editor2.selection)));
      debug$h("Adjusting block path (-1) for '".concat(transformedOperation.type, "' operation and patch '").concat(patch2.type, "'"));
    }
    return [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];
  }
  if (patch2.type === "unset" && patch2.path.length === 0) {
    debug$h("Adjusting selection for unset everything patch and ".concat(operation.type, " operation"));
    return [];
  }
  if (patch2.type === "diffMatchPatch") {
    const operationTargetBlock = findOperationTargetBlock(editor2, transformedOperation);
    if (!operationTargetBlock || !(0, import_isEqual2.default)({
      _key: operationTargetBlock._key
    }, patch2.path[0])) {
      return [transformedOperation];
    }
    const diffPatches = parse3(patch2.value);
    diffPatches.forEach((diffPatch) => {
      var _a4, _b4, _c4, _d4;
      let adjustOffsetBy = 0;
      let changedOffset = diffPatch.utf8Start1;
      const {
        diffs
      } = diffPatch;
      diffs.forEach((diff4, index) => {
        const [diffType, text] = diff4;
        if (diffType === DIFF_INSERT) {
          adjustOffsetBy += text.length;
          changedOffset += text.length;
        } else if (diffType === DIFF_DELETE) {
          adjustOffsetBy -= text.length;
          changedOffset -= text.length;
        } else if (diffType === DIFF_EQUAL) {
          if (!diffs.slice(index).every((_ref4) => {
            let [dType] = _ref4;
            return dType === DIFF_EQUAL;
          })) {
            changedOffset += text.length;
          }
        }
      });
      if (transformedOperation.type === "insert_text") {
        if (changedOffset < transformedOperation.offset) {
          transformedOperation.offset += adjustOffsetBy;
        }
      }
      if (transformedOperation.type === "remove_text") {
        if (changedOffset <= transformedOperation.offset - transformedOperation.text.length) {
          transformedOperation.offset += adjustOffsetBy;
        }
      }
      if (transformedOperation.type === "set_selection") {
        const currentFocus = ((_a4 = transformedOperation.properties) == null ? void 0 : _a4.focus) ? {
          ...transformedOperation.properties.focus
        } : void 0;
        const currentAnchor = ((_b4 = transformedOperation == null ? void 0 : transformedOperation.properties) == null ? void 0 : _b4.anchor) ? {
          ...transformedOperation.properties.anchor
        } : void 0;
        const newFocus = ((_c4 = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _c4.focus) ? {
          ...transformedOperation.newProperties.focus
        } : void 0;
        const newAnchor = ((_d4 = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _d4.anchor) ? {
          ...transformedOperation.newProperties.anchor
        } : void 0;
        if (currentFocus && currentAnchor || newFocus && newAnchor) {
          const points = [currentFocus, currentAnchor, newFocus, newAnchor];
          points.forEach((point) => {
            if (point && changedOffset < point.offset) {
              point.offset += adjustOffsetBy;
            }
          });
          if (currentFocus && currentAnchor) {
            transformedOperation.properties = {
              focus: currentFocus,
              anchor: currentAnchor
            };
          }
          if (newFocus && newAnchor) {
            transformedOperation.newProperties = {
              focus: newFocus,
              anchor: newAnchor
            };
          }
        }
      }
    });
    return [transformedOperation];
  }
  return [transformedOperation];
}
function adjustBlockPath(operation, level, blockIndex) {
  var _a4, _b4, _c4, _d4;
  const transformedOperation = {
    ...operation
  };
  if (blockIndex >= 0 && transformedOperation.type !== "set_selection" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {
    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];
    transformedOperation.path = newPath;
  }
  if (transformedOperation.type === "set_selection") {
    const currentFocus = ((_a4 = transformedOperation.properties) == null ? void 0 : _a4.focus) ? {
      ...transformedOperation.properties.focus
    } : void 0;
    const currentAnchor = ((_b4 = transformedOperation == null ? void 0 : transformedOperation.properties) == null ? void 0 : _b4.anchor) ? {
      ...transformedOperation.properties.anchor
    } : void 0;
    const newFocus = ((_c4 = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _c4.focus) ? {
      ...transformedOperation.newProperties.focus
    } : void 0;
    const newAnchor = ((_d4 = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _d4.anchor) ? {
      ...transformedOperation.newProperties.anchor
    } : void 0;
    if (currentFocus && currentAnchor || newFocus && newAnchor) {
      const points = [currentFocus, currentAnchor, newFocus, newAnchor];
      points.forEach((point) => {
        if (point && point.path[0] >= blockIndex + level && point.path[0] + level > -1) {
          point.path = [point.path[0] + level, ...point.path.slice(1)];
        }
      });
      if (currentFocus && currentAnchor) {
        transformedOperation.properties = {
          focus: currentFocus,
          anchor: currentAnchor
        };
      }
      if (newFocus && newAnchor) {
        transformedOperation.newProperties = {
          focus: newFocus,
          anchor: newAnchor
        };
      }
    }
  }
  return transformedOperation;
}
var shouldMerge = (op, prev) => {
  if (op.type === "set_selection") {
    return true;
  }
  if (prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path) && op.text !== " ") {
    return true;
  }
  if (prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {
    return true;
  }
  return false;
};
var shouldOverwrite = (op, prev) => {
  if (prev && op.type === "set_selection" && prev.type === "set_selection") {
    return true;
  }
  return false;
};
var shouldClear = (op) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};
function withoutSaving(editor2, fn) {
  const prev = isSaving(editor2);
  SAVING.set(editor2, false);
  fn();
  SAVING.set(editor2, prev);
}
function createSelectOperation(editor2) {
  return {
    type: "set_selection",
    properties: {
      ...editor2.selection
    },
    newProperties: {
      ...editor2.selection
    }
  };
}
function findOperationTargetBlock(editor2, operation) {
  let block;
  if (operation.type === "set_selection" && editor2.selection) {
    block = editor2.children[editor2.selection.focus.path[0]];
  } else if ("path" in operation) {
    block = editor2.children[operation.path[0]];
  }
  return block;
}
var debug$g = debugWithName("plugin:withPatches");
function createWithPatches(_ref5) {
  let {
    change$,
    patches$,
    patchFunctions,
    readOnly,
    schemaTypes
  } = _ref5;
  let previousChildren;
  const applyPatch5 = createApplyPatch(schemaTypes);
  return function withPatches(editor2) {
    IS_PROCESSING_REMOTE_CHANGES.set(editor2, false);
    PATCHING.set(editor2, true);
    previousChildren = [...editor2.children];
    const {
      apply: apply3
    } = editor2;
    let bufferedPatches = [];
    const handleBufferedRemotePatches = () => {
      if (bufferedPatches.length === 0) {
        return;
      }
      const patches = bufferedPatches;
      bufferedPatches = [];
      let changed = false;
      withRemoteChanges(editor2, () => {
        Editor.withoutNormalizing(editor2, () => {
          withoutPatching(editor2, () => {
            withoutSaving(editor2, () => {
              withPreserveKeys(editor2, () => {
                patches.forEach((patch2) => {
                  if (patch2.type === "insert" || patch2.type === "unset") {
                    removeAllDocumentSelectionRanges(!!editor2.selection);
                  }
                  if (debug$g.enabled)
                    debug$g("Handling remote patch ".concat(JSON.stringify(patch2)));
                  changed = applyPatch5(editor2, patch2);
                });
              });
            });
          });
        });
        if (changed) {
          editor2.normalize();
          editor2.onChange();
        }
      });
    };
    const handlePatches = (_ref6) => {
      let {
        patches
      } = _ref6;
      const remotePatches = patches.filter((p) => p.origin !== "local");
      if (remotePatches.length === 0) {
        return;
      }
      bufferedPatches = bufferedPatches.concat(remotePatches);
      handleBufferedRemotePatches();
    };
    if (patches$) {
      editor2.subscriptions.push(() => {
        debug$g("Subscribing to patches$");
        const sub2 = patches$.subscribe(handlePatches);
        return () => {
          debug$g("Unsubscribing to patches$");
          sub2.unsubscribe();
        };
      });
    }
    editor2.apply = (operation) => {
      if (readOnly) {
        apply3(operation);
        return editor2;
      }
      let patches = [];
      previousChildren = editor2.children;
      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);
      apply3(operation);
      const editorIsEmpty = isEqualToEmptyEditor(editor2.children, schemaTypes);
      if (!isPatching(editor2)) {
        return editor2;
      }
      if (editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection") {
        patches.push(insert$1(previousChildren, "before", [0]));
      }
      switch (operation.type) {
        case "insert_text":
          patches = [...patches, ...patchFunctions.insertTextPatch(editor2, operation, previousChildren)];
          break;
        case "remove_text":
          patches = [...patches, ...patchFunctions.removeTextPatch(editor2, operation, previousChildren)];
          break;
        case "remove_node":
          patches = [...patches, ...patchFunctions.removeNodePatch(editor2, operation, previousChildren)];
          break;
        case "split_node":
          patches = [...patches, ...patchFunctions.splitNodePatch(editor2, operation, previousChildren)];
          break;
        case "insert_node":
          patches = [...patches, ...patchFunctions.insertNodePatch(editor2, operation, previousChildren)];
          break;
        case "set_node":
          patches = [...patches, ...patchFunctions.setNodePatch(editor2, operation, previousChildren)];
          break;
        case "merge_node":
          patches = [...patches, ...patchFunctions.mergeNodePatch(editor2, operation, previousChildren)];
          break;
        case "move_node":
          patches = [...patches, ...patchFunctions.moveNodePatch(editor2, operation, previousChildren)];
          break;
      }
      if (!editorWasEmpty && editorIsEmpty && ["merge_node", "set_node", "remove_text", "remove_node"].includes(operation.type)) {
        patches = [...patches, unset([])];
        change$.next({
          type: "unset",
          previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor2))
        });
      }
      if (editorWasEmpty && patches.length > 0) {
        patches = [setIfMissing([], []), ...patches];
      }
      if (patches.length > 0) {
        patches.forEach((patch2) => {
          change$.next({
            type: "patch",
            patch: {
              ...patch2,
              origin: "local"
            }
          });
        });
      }
      return editor2;
    };
    return editor2;
  };
}
var debug$f = debugWithName("plugin:withPlaceholderBlock");
function createWithPlaceholderBlock(_ref7) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref7;
  return function withPlaceholderBlock(editor2) {
    editor2.createPlaceholderBlock = () => {
      debug$f("Creating placeholder block");
      return {
        _type: schemaTypes.block.name,
        _key: keyGenerator(),
        style: schemaTypes.styles[0].value || "normal",
        markDefs: [],
        children: [{
          _type: "span",
          _key: keyGenerator(),
          text: "",
          marks: []
        }]
      };
    };
    return editor2;
  };
}
var debug$e = debugWithName("plugin:withPortableTextBlockStyle");
function createWithPortableTextBlockStyle(types3) {
  const defaultStyle = types3.styles[0].value;
  return function withPortableTextBlockStyle(editor2) {
    const {
      normalizeNode
    } = editor2;
    editor2.normalizeNode = (nodeEntry) => {
      normalizeNode(nodeEntry);
      const [, path2] = nodeEntry;
      for (const op of editor2.operations) {
        if (op.type === "split_node" && op.path.length === 1 && editor2.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path2[0] && !Path.equals(path2, op.path)) {
          const [child] = Editor.node(editor2, [op.path[0] + 1, 0]);
          if (Text2.isText(child) && child.text === "") {
            debug$e("Normalizing split node to ".concat(defaultStyle, " style"), op);
            Transforms.setNodes(editor2, {
              style: defaultStyle
            }, {
              at: [op.path[0] + 1],
              voids: false
            });
            break;
          }
        }
      }
    };
    editor2.pteHasBlockStyle = (style) => {
      if (!editor2.selection) {
        return false;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => editor2.isTextBlock(node) && node.style === style
      })];
      if (selectedBlocks.length > 0) {
        return true;
      }
      return false;
    };
    editor2.pteToggleBlockStyle = (blockStyle) => {
      if (!editor2.selection) {
        return;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => editor2.isTextBlock(node)
      })];
      selectedBlocks.forEach((_ref8) => {
        let [node, path2] = _ref8;
        if (editor2.isTextBlock(node) && node.style === blockStyle) {
          debug$e("Unsetting block style '".concat(blockStyle, "'"));
          Transforms.setNodes(editor2, {
            ...node,
            style: defaultStyle
          }, {
            at: path2
          });
        } else {
          if (blockStyle) {
            debug$e("Setting style '".concat(blockStyle, "'"));
          } else {
            debug$e("Setting default style", defaultStyle);
          }
          Transforms.setNodes(editor2, {
            ...node,
            style: blockStyle || defaultStyle
          }, {
            at: path2
          });
        }
      });
      editor2.onChange();
    };
    return editor2;
  };
}
var debug$d = debugWithName("plugin:withPortableTextLists");
var MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(types3) {
  return function withPortableTextLists(editor2) {
    editor2.pteToggleListItem = (listItemStyle) => {
      const isActive = editor2.pteHasListStyle(listItemStyle);
      if (isActive) {
        debug$d("Remove list item '".concat(listItemStyle, "'"));
        editor2.pteUnsetListItem(listItemStyle);
      } else {
        debug$d("Add list item '".concat(listItemStyle, "'"));
        editor2.pteSetListItem(listItemStyle);
      }
    };
    editor2.pteUnsetListItem = (listItemStyle) => {
      if (!editor2.selection) {
        return;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => Element2.isElement(node) && node._type === types3.block.name
      })];
      selectedBlocks.forEach((_ref9) => {
        let [node, path2] = _ref9;
        if (editor2.isListBlock(node)) {
          const {
            listItem,
            level,
            ...rest
          } = node;
          const newNode = {
            ...rest,
            listItem: void 0,
            level: void 0
          };
          debug$d("Unsetting list '".concat(listItemStyle, "'"));
          Transforms.setNodes(editor2, newNode, {
            at: path2
          });
        }
      });
    };
    editor2.pteSetListItem = (listItemStyle) => {
      if (!editor2.selection) {
        return;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => editor2.isTextBlock(node)
      })];
      selectedBlocks.forEach((_ref10) => {
        let [node, path2] = _ref10;
        debug$d("Setting list '".concat(listItemStyle, "'"));
        Transforms.setNodes(editor2, {
          ...node,
          level: 1,
          listItem: listItemStyle || types3.lists[0] && types3.lists[0].value
        }, {
          at: path2
        });
      });
    };
    editor2.pteEndList = () => {
      if (!editor2.selection) {
        return false;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => Element2.isElement(node) && editor2.isListBlock(node) && node.children.length === 1 && Text2.isText(node.children[0]) && node.children[0].text === ""
      })];
      if (selectedBlocks.length === 0) {
        return false;
      }
      selectedBlocks.forEach((_ref11) => {
        let [node, path2] = _ref11;
        if (Element2.isElement(node)) {
          debug$d("Unset list");
          Transforms.setNodes(editor2, {
            ...node,
            level: void 0,
            listItem: void 0
          }, {
            at: path2
          });
        }
      });
      return true;
    };
    editor2.pteIncrementBlockLevels = (reverse) => {
      if (!editor2.selection) {
        return false;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => !!editor2.isListBlock(node)
      })];
      if (selectedBlocks.length === 0) {
        return false;
      }
      selectedBlocks.forEach((_ref12) => {
        let [node, path2] = _ref12;
        if (editor2.isListBlock(node)) {
          let level = node.level || 1;
          if (reverse) {
            level--;
            debug$d("Decrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
          } else {
            level++;
            debug$d("Incrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
          }
          Transforms.setNodes(editor2, {
            level: Math.min(MAX_LIST_LEVEL, Math.max(1, level))
          }, {
            at: path2
          });
        }
      });
      return true;
    };
    editor2.pteHasListStyle = (listStyle) => {
      if (!editor2.selection) {
        return false;
      }
      const selectedBlocks = [...Editor.nodes(editor2, {
        at: editor2.selection,
        match: (node) => editor2.isListBlock(node) && node.listItem === listStyle
      })];
      if (selectedBlocks.length > 0) {
        return true;
      }
      return false;
    };
    return editor2;
  };
}
var debug$c = debugWithName("plugin:withPortableTextMarkModel");
function createWithPortableTextMarkModel(types3, change$) {
  return function withPortableTextMarkModel(editor2) {
    const {
      apply: apply3,
      normalizeNode
    } = editor2;
    const decorators = types3.decorators.map((t3) => t3.value);
    const forceNewSelection = () => {
      if (editor2.selection) {
        Transforms.select(editor2, {
          ...editor2.selection
        });
        editor2.selection = {
          ...editor2.selection
        };
      }
      const ptRange = toPortableTextRange(editor2.children, editor2.selection, types3);
      change$.next({
        type: "selection",
        selection: ptRange
      });
    };
    editor2.normalizeNode = (nodeEntry) => {
      normalizeNode(nodeEntry);
      if (editor2.operations.some((op) => ["insert_node", "insert_text", "merge_node", "remove_node", "remove_text", "set_node"].includes(op.type))) {
        mergeSpans(editor2);
      }
      const [node, path2] = nodeEntry;
      const isSpan = Text2.isText(node) && node._type === types3.span.name;
      const isTextBlock = editor2.isTextBlock(node);
      if (isSpan || isTextBlock) {
        if (isSpan && !Array.isArray(node.marks)) {
          debug$c("Adding .marks to span node");
          Transforms.setNodes(editor2, {
            marks: []
          }, {
            at: path2
          });
          editor2.onChange();
        }
        for (const op of editor2.operations) {
          if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === types3.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
            const [targetBlock, targetPath] = Editor.node(editor2, [op.path[0] - 1]);
            debug$c("Copying markDefs over to merged block", op);
            if (editor2.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              const newMarkDefs = (0, import_uniq3.default)([...oldDefs, ...op.properties.markDefs]);
              const isNormalized = (0, import_isEqual2.default)(newMarkDefs, targetBlock.markDefs);
              if (!isNormalized) {
                Transforms.setNodes(editor2, {
                  markDefs: newMarkDefs
                }, {
                  at: targetPath,
                  voids: false
                });
                editor2.onChange();
              }
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && Element2.isElementProps(op.properties) && op.properties._type === types3.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] + 1 < editor2.children.length) {
            const [targetBlock, targetPath] = Editor.node(editor2, [op.path[0] + 1]);
            debug$c("Copying markDefs over to split block", op);
            if (editor2.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              Transforms.setNodes(editor2, {
                markDefs: (0, import_uniq3.default)([...oldDefs, ...op.properties.markDefs])
              }, {
                at: targetPath,
                voids: false
              });
              editor2.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 2 && op.properties._type === types3.span.name && "marks" in op.properties && Array.isArray(op.properties.marks) && op.properties.marks.length > 0 && op.path[0] + 1 < editor2.children.length) {
            const [child, childPath] = Editor.node(editor2, [op.path[0] + 1, 0]);
            if (Text2.isText(child) && child.text === "" && Array.isArray(child.marks) && child.marks.length > 0) {
              Transforms.setNodes(editor2, {
                marks: []
              }, {
                at: childPath,
                voids: false
              });
              editor2.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && op.properties._type === types3.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0) {
            const [block, blockPath] = Editor.node(editor2, [op.path[0]]);
            if (editor2.isTextBlock(block) && block.children.length === 1 && block.markDefs && block.markDefs.length > 0 && Text2.isText(block.children[0]) && block.children[0].text === "" && (!block.children[0].marks || block.children[0].marks.length === 0)) {
              Transforms.setNodes(editor2, {
                markDefs: []
              }, {
                at: blockPath
              });
              editor2.onChange();
            }
          }
        }
        if (isSpan && Array.isArray(node.marks) && (!node.marks || node.marks.length > 0 && node.text === "")) {
          Transforms.setNodes(editor2, {
            marks: []
          }, {
            at: path2,
            voids: false
          });
          editor2.onChange();
        }
      }
      if (isTextBlock && editor2.operations.some((op) => ["split_node", "remove_node", "remove_text", "merge_node"].includes(op.type))) {
        normalizeMarkDefs(editor2);
      }
    };
    editor2.apply = (op) => {
      var _a4, _b4;
      if (op.type === "insert_text") {
        const {
          selection
        } = editor2;
        if (selection && Range.isCollapsed(selection) && ((_b4 = (_a4 = Editor.marks(editor2)) == null ? void 0 : _a4.marks) == null ? void 0 : _b4.some((mark) => !decorators.includes(mark)))) {
          const [node] = Array.from(Editor.nodes(editor2, {
            mode: "lowest",
            at: selection.focus,
            match: (n) => n._type === types3.span.name,
            voids: false
          }))[0] || [void 0];
          if (Text2.isText(node) && node.text.length === selection.focus.offset && Array.isArray(node.marks) && node.marks.length > 0) {
            apply3(op);
            Transforms.splitNodes(editor2, {
              match: Text2.isText,
              at: {
                ...selection.focus,
                offset: selection.focus.offset
              }
            });
            const marksWithoutAnnotationMarks = ({
              ...Editor.marks(editor2) || {}
            }.marks || []).filter((mark) => decorators.includes(mark));
            Transforms.setNodes(editor2, {
              marks: marksWithoutAnnotationMarks
            }, {
              at: Path.next(selection.focus.path)
            });
            debug$c("Inserting text at end of annotation");
            return;
          }
        }
      }
      apply3(op);
    };
    editor2.addMark = (mark) => {
      if (editor2.selection) {
        if (Range.isExpanded(editor2.selection)) {
          Transforms.setNodes(editor2, {}, {
            match: Text2.isText,
            split: true
          });
          const splitTextNodes = [...Editor.nodes(editor2, {
            at: editor2.selection,
            match: Text2.isText
          })];
          const shouldRemoveMark = (0, import_flatten3.default)(splitTextNodes.map((item) => item[0]).map((node) => node.marks)).includes(mark);
          if (shouldRemoveMark) {
            editor2.removeMark(mark);
            return editor2;
          }
          Editor.withoutNormalizing(editor2, () => {
            splitTextNodes.forEach((_ref13) => {
              let [node, path2] = _ref13;
              const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];
              Transforms.setNodes(editor2, {
                marks
              }, {
                at: path2,
                match: Text2.isText,
                split: true,
                hanging: true
              });
            });
          });
          Editor.normalize(editor2);
        } else {
          const existingMarks = {
            ...Editor.marks(editor2) || {}
          }.marks || [];
          const marks = {
            ...Editor.marks(editor2) || {},
            marks: [...existingMarks, mark]
          };
          editor2.marks = marks;
          forceNewSelection();
          return editor2;
        }
        editor2.onChange();
        forceNewSelection();
      }
      return editor2;
    };
    editor2.removeMark = (mark) => {
      const {
        selection
      } = editor2;
      if (selection) {
        if (Range.isExpanded(selection)) {
          Editor.withoutNormalizing(editor2, () => {
            Transforms.setNodes(editor2, {}, {
              match: Text2.isText,
              split: true
            });
            if (editor2.selection) {
              const splitTextNodes = [...Editor.nodes(editor2, {
                at: editor2.selection,
                match: Text2.isText
              })];
              splitTextNodes.forEach((_ref14) => {
                let [node, path2] = _ref14;
                const block = editor2.children[path2[0]];
                if (Element2.isElement(block) && block.children.includes(node)) {
                  Transforms.setNodes(editor2, {
                    marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                    _type: "span"
                  }, {
                    at: path2
                  });
                }
              });
            }
          });
          Editor.normalize(editor2);
        } else {
          const existingMarks = {
            ...Editor.marks(editor2) || {}
          }.marks || [];
          const marks = {
            ...Editor.marks(editor2) || {},
            marks: existingMarks.filter((eMark) => eMark !== mark)
          };
          editor2.marks = {
            marks: marks.marks,
            _type: "span"
          };
          forceNewSelection();
          return editor2;
        }
        editor2.onChange();
        forceNewSelection();
      }
      return editor2;
    };
    editor2.pteIsMarkActive = (mark) => {
      if (!editor2.selection) {
        return false;
      }
      let existingMarks = {
        ...Editor.marks(editor2) || {}
      }.marks || [];
      if (Range.isExpanded(editor2.selection)) {
        Array.from(Editor.nodes(editor2, {
          match: Text2.isText,
          at: editor2.selection
        })).forEach((n) => {
          const [node] = n;
          existingMarks = (0, import_uniq3.default)([...existingMarks, ...node.marks || []]);
        });
      }
      return existingMarks.includes(mark);
    };
    editor2.pteToggleMark = (mark) => {
      const isActive = editor2.pteIsMarkActive(mark);
      if (isActive) {
        debug$c("Remove mark '".concat(mark, "'"));
        Editor.removeMark(editor2, mark);
      } else {
        debug$c("Add mark '".concat(mark, "'"));
        Editor.addMark(editor2, mark, true);
      }
    };
    return editor2;
  };
  function mergeSpans(editor2) {
    const {
      selection
    } = editor2;
    if (selection) {
      for (const [node, path2] of Array.from(Editor.nodes(editor2, {
        at: Editor.range(editor2, [selection.anchor.path[0]], [selection.focus.path[0]])
      })).reverse()) {
        const [parent] = path2.length > 1 ? Editor.node(editor2, Path.parent(path2)) : [void 0];
        const nextPath = [path2[0], path2[1] + 1];
        if (editor2.isTextBlock(parent)) {
          const nextNode = parent.children[nextPath[1]];
          if (Text2.isText(node) && Text2.isText(nextNode) && (0, import_isEqual2.default)(nextNode.marks, node.marks)) {
            debug$c("Merging spans");
            Transforms.mergeNodes(editor2, {
              at: nextPath,
              voids: true
            });
            editor2.onChange();
          }
        }
      }
    }
  }
  function normalizeMarkDefs(editor2) {
    const {
      selection
    } = editor2;
    if (selection) {
      const blocks2 = Editor.nodes(editor2, {
        at: selection,
        match: (n) => n._type === types3.block.name
      });
      for (const [block, path2] of blocks2) {
        if (editor2.isTextBlock(block)) {
          const newMarkDefs = (block.markDefs || []).filter((def) => {
            return block.children.find((child) => {
              return Text2.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key);
            });
          });
          if (!(0, import_isEqual2.default)(newMarkDefs, block.markDefs)) {
            debug$c("Removing markDef not in use");
            Transforms.setNodes(editor2, {
              markDefs: newMarkDefs
            }, {
              at: path2
            });
            editor2.onChange();
          }
        }
      }
    }
  }
}
var debug$b = debugWithName("plugin:withPortableTextSelections");
var debugVerbose$1 = debug$b.enabled && false;
function createWithPortableTextSelections(change$, types3) {
  let prevSelection = null;
  return function withPortableTextSelections(editor2) {
    const emitPortableTextSelection = () => {
      if (prevSelection !== editor2.selection) {
        let ptRange = null;
        if (editor2.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor2.selection);
          if (existing) {
            ptRange = existing;
          } else {
            const value = editor2.children;
            ptRange = toPortableTextRange(value, editor2.selection, types3);
            SLATE_TO_PORTABLE_TEXT_RANGE.set(editor2.selection, ptRange);
          }
        }
        if (debugVerbose$1) {
          debug$b("Emitting selection ".concat(JSON.stringify(ptRange || null), " (").concat(JSON.stringify(editor2.selection), ")"));
        }
        if (ptRange) {
          change$.next({
            type: "selection",
            selection: ptRange
          });
        } else {
          change$.next({
            type: "selection",
            selection: null
          });
        }
      }
      prevSelection = editor2.selection;
    };
    const {
      onChange
    } = editor2;
    editor2.onChange = () => {
      const hasChanges = editor2.operations.length > 0;
      onChange();
      if (hasChanges) {
        emitPortableTextSelection();
      }
    };
    return editor2;
  };
}
var debug$a = debugWithName("plugin:withSchemaTypes");
function createWithSchemaTypes(_ref15) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref15;
  return function withSchemaTypes(editor2) {
    editor2.isTextBlock = (value) => {
      return isPortableTextTextBlock(value) && value._type === schemaTypes.block.name;
    };
    editor2.isTextSpan = (value) => {
      return isPortableTextSpan(value) && value._type == schemaTypes.span.name;
    };
    editor2.isListBlock = (value) => {
      return isPortableTextListBlock(value) && value._type === schemaTypes.block.name;
    };
    editor2.isVoid = (element) => {
      return schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type));
    };
    editor2.isInline = (element) => {
      const inlineSchemaTypes = schemaTypes.inlineObjects.map((obj) => obj.name);
      return inlineSchemaTypes.includes(element._type) && "__inline" in element && element.__inline === true;
    };
    const {
      normalizeNode
    } = editor2;
    editor2.normalizeNode = (entry) => {
      const [node, path2] = entry;
      if (node._type === void 0 && path2.length === 2) {
        debug$a("Setting span type on text node without a type");
        const span = node;
        const key2 = span._key || keyGenerator();
        Transforms.setNodes(editor2, {
          ...span,
          _type: schemaTypes.span.name,
          _key: key2
        }, {
          at: path2
        });
      }
      normalizeNode(entry);
    };
    return editor2;
  };
}
var debug$9 = debugWithName("plugin:withUtils");
function createWithUtils(_ref16) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref16;
  return function withUtils(editor2) {
    editor2.pteExpandToWord = () => {
      const {
        selection
      } = editor2;
      if (selection && !Range.isExpanded(selection)) {
        const [textNode] = Editor.node(editor2, selection.focus, {
          depth: 2
        });
        if (!textNode || !Text2.isText(textNode) || textNode.text.length === 0) {
          debug$9("pteExpandToWord: Can't expand to word here");
          return;
        }
        const {
          focus
        } = selection;
        const focusOffset = focus.offset;
        const charsBefore = textNode.text.slice(0, focusOffset);
        const charsAfter = textNode.text.slice(focusOffset, -1);
        const isEmpty3 = (str) => str.match(/\s/g);
        const whiteSpaceBeforeIndex = charsBefore.split("").reverse().findIndex((str) => isEmpty3(str));
        const newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0;
        const whiteSpaceAfterIndex = charsAfter.split("").findIndex((obj) => isEmpty3(obj));
        const newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);
        if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {
          debug$9("pteExpandToWord: Expanding to focused word");
          Transforms.setSelection(editor2, {
            anchor: {
              ...selection.anchor,
              offset: newStartOffset
            },
            focus: {
              ...selection.focus,
              offset: newEndOffset
            }
          });
          return;
        }
        debug$9("pteExpandToWord: Can't expand to word here");
      }
    };
    return editor2;
  };
}
var debug$8 = debugWithName("plugin:withHotKeys");
var DEFAULT_HOTKEYS = {
  marks: {
    "mod+b": "strong",
    "mod+i": "em",
    "mod+u": "underline",
    "mod+'": "code"
  },
  custom: {}
};
function createWithHotkeys(types3, keyGenerator, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"];
  const activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;
  const createEmptyBlock = () => toSlateValue([{
    _type: types3.block.name,
    _key: keyGenerator(),
    style: "normal",
    markDefs: [],
    children: [{
      _type: "span",
      _key: keyGenerator(),
      text: "",
      marks: []
    }]
  }], portableTextEditor)[0];
  return function withHotKeys(editor2) {
    editor2.pteWithHotKeys = (event) => {
      var _a4, _b4;
      Object.keys(activeHotkeys).forEach((cat) => {
        if (cat === "marks") {
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }
            if ((0, import_is_hotkey.default)(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$8("HotKey ".concat(hotkey, " to toggle ").concat(mark));
                editor2.pteToggleMark(mark);
              }
            }
          }
        }
        if (cat === "custom") {
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }
            if ((0, import_is_hotkey.default)(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
        }
      });
      const isEnter = (0, import_is_hotkey.default)("enter", event.nativeEvent);
      const isTab = (0, import_is_hotkey.default)("tab", event.nativeEvent);
      const isShiftEnter = (0, import_is_hotkey.default)("shift+enter", event.nativeEvent);
      const isShiftTab = (0, import_is_hotkey.default)("shift+tab", event.nativeEvent);
      const isBackspace = (0, import_is_hotkey.default)("backspace", event.nativeEvent);
      const isDelete = (0, import_is_hotkey.default)("delete", event.nativeEvent);
      if (isBackspace && editor2.selection && editor2.selection.focus.path[0] > 0 && Range.isCollapsed(editor2.selection)) {
        const prevPath = Path.previous(editor2.selection.focus.path.slice(0, 1));
        const prevBlock = Node2.descendant(editor2, prevPath);
        const focusBlock = Node2.descendant(editor2, editor2.selection.focus.path.slice(0, 1));
        if (prevBlock && focusBlock && Editor.isVoid(editor2, prevBlock) && editor2.selection.focus.offset === 0) {
          debug$8("Preventing deleting void block above");
          event.preventDefault();
          event.stopPropagation();
          const isTextBlock = isPortableTextTextBlock(focusBlock);
          const isEmptyFocusBlock = isTextBlock && focusBlock.children.length === 1 && ((_b4 = (_a4 = focusBlock.children) == null ? void 0 : _a4[0]) == null ? void 0 : _b4.text) === "";
          if (!isTextBlock || isEmptyFocusBlock) {
            Transforms.removeNodes(editor2, {
              match: (n) => n === focusBlock
            });
            Transforms.select(editor2, prevPath);
            editor2.onChange();
            return;
          }
          if (isTextBlock && !isEmptyFocusBlock) {
            Transforms.select(editor2, prevPath);
            editor2.onChange();
            return;
          }
          return;
        }
      }
      if (isDelete && editor2.selection && editor2.selection.focus.offset === 0 && Range.isCollapsed(editor2.selection) && editor2.children[editor2.selection.focus.path[0] + 1]) {
        const nextBlock = Node2.descendant(editor2, Path.next(editor2.selection.focus.path.slice(0, 1)));
        const focusBlockPath = editor2.selection.focus.path.slice(0, 1);
        const focusBlock = Node2.descendant(editor2, focusBlockPath);
        if (nextBlock && focusBlock && !Editor.isVoid(editor2, focusBlock) && Editor.isVoid(editor2, nextBlock)) {
          debug$8("Preventing deleting void block below");
          event.preventDefault();
          event.stopPropagation();
          Transforms.removeNodes(editor2, {
            match: (n) => n === focusBlock
          });
          Transforms.select(editor2, focusBlockPath);
          editor2.onChange();
          return;
        }
      }
      if ((isTab || isShiftTab) && editor2.selection) {
        const [focusChild] = Editor.node(editor2, editor2.selection.focus, {
          depth: 2
        });
        const [focusBlock] = isPortableTextSpan(focusChild) ? Editor.node(editor2, editor2.selection.focus, {
          depth: 1
        }) : [];
        const hasAnnotationFocus = focusChild && isPortableTextTextBlock(focusBlock) && isPortableTextSpan(focusChild) && (focusChild.marks || []).filter((m2) => (focusBlock.markDefs || []).map((def) => def._key).includes(m2)).length > 0;
        const [start] = Range.edges(editor2.selection);
        const atStartOfNode = Editor.isStart(editor2, start, start.path);
        if (focusChild && isPortableTextSpan(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor2.pteIncrementBlockLevels(isShiftTab)) {
          event.preventDefault();
        }
      }
      if (isEnter && !isShiftEnter && editor2.selection) {
        const focusBlockPath = editor2.selection.focus.path.slice(0, 1);
        const focusBlock = Node2.descendant(editor2, focusBlockPath);
        if (editor2.isListBlock(focusBlock)) {
          if (editor2.pteEndList()) {
            event.preventDefault();
          }
          return;
        }
        if (editor2.isTextBlock(focusBlock) && focusBlock.style && focusBlock.style !== types3.styles[0].value) {
          const [, end] = Range.edges(editor2.selection);
          const endAtEndOfNode = Editor.isEnd(editor2, end, end.path);
          if (endAtEndOfNode) {
            Editor.insertNode(editor2, createEmptyBlock());
            event.preventDefault();
            editor2.onChange();
            return;
          }
        }
        if (focusBlock && Editor.isVoid(editor2, focusBlock)) {
          Editor.insertNode(editor2, createEmptyBlock());
          event.preventDefault();
          editor2.onChange();
          return;
        }
        event.preventDefault();
        editor2.insertBreak();
        editor2.onChange();
      }
      if (isShiftEnter) {
        event.preventDefault();
        editor2.insertText("\n");
        return;
      }
      if ((0, import_is_hotkey.default)("mod+z", event.nativeEvent)) {
        event.preventDefault();
        editor2.undo();
        return;
      }
      if ((0, import_is_hotkey.default)("mod+y", event.nativeEvent) || (0, import_is_hotkey.default)("mod+shift+z", event.nativeEvent)) {
        event.preventDefault();
        editor2.redo();
      }
    };
    return editor2;
  };
}
function validateValue(value, types3, keyGenerator) {
  let resolution = null;
  let valid = true;
  const validChildTypes = [types3.span.name, ...types3.inlineObjects.map((t3) => t3.name)];
  const validBlockTypes = [types3.block.name, ...types3.blockObjects.map((t3) => t3.name)];
  if (value === void 0) {
    return {
      valid: true,
      resolution: null,
      value
    };
  }
  if (!Array.isArray(value) || value.length === 0) {
    return {
      valid: false,
      resolution: {
        patches: [unset([])],
        description: "Editor value must be an array of Portable Text blocks, or undefined.",
        action: "Unset the value",
        item: value,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-array.description",
          action: "inputs.portable-text.invalid-value.not-an-array.action"
        }
      },
      value
    };
  }
  if (value.some((blk, index) => {
    if (!(0, import_isPlainObject4.default)(blk)) {
      resolution = {
        patches: [unset([index])],
        description: "Block must be an object, got ".concat(String(blk)),
        action: "Unset invalid item",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-object.description",
          action: "inputs.portable-text.invalid-value.not-an-object.action",
          values: {
            index
          }
        }
      };
      return true;
    }
    if (!blk._key || typeof blk._key !== "string") {
      resolution = {
        patches: [set2({
          ...blk,
          _key: keyGenerator()
        }, [index])],
        description: "Block at index ".concat(index, " is missing required _key."),
        action: "Set the block with a random _key value",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-key.description",
          action: "inputs.portable-text.invalid-value.missing-key.action",
          values: {
            index
          }
        }
      };
      return true;
    }
    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      if (blk._type === "block") {
        const currentBlockTypeName = types3.block.name;
        resolution = {
          patches: [set2({
            ...blk,
            _type: currentBlockTypeName
          }, [{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
          action: "Use type '".concat(currentBlockTypeName, "'"),
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.incorrect-block-type.description",
            action: "inputs.portable-text.invalid-value.incorrect-block-type.action",
            values: {
              key: blk._key,
              expectedTypeName: currentBlockTypeName
            }
          }
        };
        return true;
      }
      if (!blk._type && isPortableTextTextBlock({
        ...blk,
        _type: types3.block.name
      })) {
        resolution = {
          patches: [set2({
            ...blk,
            _type: types3.block.name
          }, [{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' is missing a type name. According to the schema, the block type name is '").concat(types3.block.name, "'"),
          action: "Use type '".concat(types3.block.name, "'"),
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-block-type.description",
            action: "inputs.portable-text.invalid-value.missing-block-type.action",
            values: {
              key: blk._key,
              expectedTypeName: types3.block.name
            }
          }
        };
        return true;
      }
      if (!blk._type) {
        resolution = {
          patches: [unset([{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' is missing an _type property"),
          action: "Remove the block",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-type.description",
            action: "inputs.portable-text.invalid-value.missing-type.action",
            values: {
              key: blk._key
            }
          }
        };
        return true;
      }
      resolution = {
        patches: [unset([{
          _key: blk._key
        }])],
        description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.disallowed-type.description",
          action: "inputs.portable-text.invalid-value.disallowed-type.action",
          values: {
            key: blk._key,
            typeName: blk._type
          }
        }
      };
      return true;
    }
    if (blk._type === types3.block.name) {
      const textBlock = blk;
      if (!textBlock.children || !Array.isArray(textBlock.children)) {
        resolution = {
          patches: [unset([{
            _key: textBlock._key
          }])],
          description: "Text block with _key '".concat(textBlock._key, "' has a missing or invalid required property 'children'."),
          action: "Remove the block",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-children.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-children.action",
            values: {
              key: textBlock._key
            }
          }
        };
        return true;
      }
      if (!blk.markDefs || !Array.isArray(blk.markDefs)) {
        resolution = {
          patches: [set2({
            ...textBlock,
            markDefs: []
          }, [{
            _key: textBlock._key
          }])],
          description: "Block has a missing or invalid required property 'markDefs'.",
          action: "Add empty markDefs array",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action",
            values: {
              key: textBlock._key
            }
          }
        };
        return true;
      }
      const allUsedMarks = (0, import_uniq3.default)((0, import_flatten3.default)(textBlock.children.filter((cld) => cld._type === types3.span.name).map((cld) => cld.marks || [])));
      const annotationMarks = allUsedMarks.filter((mark) => !types3.decorators.map((dec2) => dec2.value).includes(mark));
      const orphanedMarks = annotationMarks.filter((mark) => textBlock.markDefs ? !textBlock.markDefs.find((def) => def._key === mark) : false);
      if (orphanedMarks.length > 0) {
        const spanChildren = textBlock.children.filter((cld) => cld._type === types3.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));
        if (spanChildren) {
          const orphaned = orphanedMarks.join(", ");
          resolution = {
            patches: spanChildren.map((child) => {
              return set2((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{
                _key: blk._key
              }, "children", {
                _key: child._key
              }, "marks"]);
            }),
            description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphaned, ") not supported by the current content model."),
            action: "Remove invalid marks",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-marks.description",
              action: "inputs.portable-text.invalid-value.orphaned-marks.action",
              values: {
                key: blk._key,
                orphanedMarks
              }
            }
          };
          return true;
        }
      }
      if (textBlock.children && textBlock.children.length === 0) {
        const newSpan = {
          _type: types3.span.name,
          _key: keyGenerator(),
          text: ""
        };
        resolution = {
          patches: [insert$1([newSpan], "after", [{
            _key: blk._key
          }, "children", 0])],
          description: "Children for text block with _key '".concat(blk._key, "' is empty."),
          action: "Insert an empty text",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.empty-children.description",
            action: "inputs.portable-text.invalid-value.empty-children.action",
            values: {
              key: blk._key
            }
          }
        };
        return true;
      }
      if (textBlock.children.some((child, cIndex) => {
        if (!(0, import_isPlainObject4.default)(child)) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", cIndex])],
            description: "Child at index '".concat(cIndex, "' in block with key '").concat(blk._key, "' is not an object."),
            action: "Remove the item",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.non-object-child.description",
              action: "inputs.portable-text.invalid-value.non-object-child.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          };
          return true;
        }
        if (!child._key || typeof child._key !== "string") {
          const newChild = {
            ...child,
            _key: keyGenerator()
          };
          resolution = {
            patches: [set2(newChild, [{
              _key: blk._key
            }, "children", cIndex])],
            description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
            action: "Set a new random _key on the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.missing-child-key.description",
              action: "inputs.portable-text.invalid-value.missing-child-key.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          };
          return true;
        }
        if (!child._type) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing '_type' property."),
            action: "Remove the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.missing-child-type.description",
              action: "inputs.portable-text.invalid-value.missing-child-type.action",
              values: {
                key: blk._key,
                childKey: child._key
              }
            }
          };
          return true;
        }
        if (!validChildTypes.includes(child._type)) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
            action: "Remove the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.disallowed-child-type.description",
              action: "inputs.portable-text.invalid-value.disallowed-child-type.action",
              values: {
                key: blk._key,
                childKey: child._key,
                childType: child._type
              }
            }
          };
          return true;
        }
        if (child._type === types3.span.name && typeof child.text !== "string") {
          resolution = {
            patches: [set2({
              ...child,
              text: ""
            }, [{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has missing or invalid text property!"),
            action: "Write an empty text property to the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.invalid-span-text.description",
              action: "inputs.portable-text.invalid-value.invalid-span-text.action",
              values: {
                key: blk._key,
                childKey: child._key
              }
            }
          };
          return true;
        }
        return false;
      })) {
        valid = false;
      }
    }
    return false;
  })) {
    valid = false;
  }
  return {
    valid,
    resolution,
    value
  };
}
var debug$7 = debugWithName("plugin:withInsertData");
function createWithInsertData(change$, schemaTypes, keyGenerator) {
  return function withInsertData(editor2) {
    const blockTypeName = schemaTypes.block.name;
    const spanTypeName = schemaTypes.span.name;
    const toPlainText = (blocks2) => {
      return blocks2.map((block) => {
        var _a4;
        if (editor2.isTextBlock(block)) {
          return block.children.map((child) => {
            var _a22;
            if (child._type === spanTypeName) {
              return child.text;
            }
            return "[".concat(((_a22 = schemaTypes.inlineObjects.find((t3) => t3.name === child._type)) == null ? void 0 : _a22.title) || "Object", "]");
          }).join("");
        }
        return "[".concat(((_a4 = schemaTypes.blockObjects.find((t3) => t3.name === block._type)) == null ? void 0 : _a4.title) || "Object", "]");
      }).join("\n\n");
    };
    editor2.setFragmentData = (data, originEvent) => {
      const {
        selection
      } = editor2;
      if (!selection) {
        return;
      }
      const [start, end] = Range.edges(selection);
      const startVoid = Editor.void(editor2, {
        at: start.path
      });
      const endVoid = Editor.void(editor2, {
        at: end.path
      });
      if (Range.isCollapsed(selection) && !startVoid) {
        return;
      }
      const domRange = ReactEditor.toDOMRange(editor2, selection);
      let contents = domRange.cloneContents();
      if (endVoid) {
        const [voidNode] = endVoid;
        const r2 = domRange.cloneRange();
        const domNode = ReactEditor.toDOMNode(editor2, voidNode);
        r2.setEndAfter(domNode);
        contents = r2.cloneContents();
      }
      Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
        const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
        zw.textContent = isNewline ? "\n" : "";
      });
      Array.from(contents.querySelectorAll("*")).forEach((elm) => {
        elm.removeAttribute("contentEditable");
        elm.removeAttribute("data-slate-inline");
        elm.removeAttribute("data-slate-leaf");
        elm.removeAttribute("data-slate-node");
        elm.removeAttribute("data-slate-spacer");
        elm.removeAttribute("data-slate-string");
        elm.removeAttribute("data-slate-zero-width");
        elm.removeAttribute("draggable");
        for (const key2 in elm.attributes) {
          if (elm.hasAttribute(key2)) {
            elm.removeAttribute(key2);
          }
        }
      });
      const div = contents.ownerDocument.createElement("div");
      div.appendChild(contents);
      div.setAttribute("hidden", "true");
      contents.ownerDocument.body.appendChild(div);
      const asHTML = div.innerHTML;
      contents.ownerDocument.body.removeChild(div);
      const fragment = editor2.getFragment();
      const portableText = fromSlateValue(fragment, blockTypeName);
      const asJSON = JSON.stringify(portableText);
      const asPlainText = toPlainText(portableText);
      data.clearData();
      data.setData("text/plain", asPlainText);
      data.setData("text/html", asHTML);
      data.setData("application/json", asJSON);
      data.setData("application/x-portable-text", asJSON);
      debug$7("text", asPlainText);
      data.setData("application/x-portable-text-event-origin", originEvent || "external");
      debug$7("Set fragment data", asJSON, asHTML);
    };
    editor2.insertPortableTextData = (data) => {
      var _a4;
      if (!editor2.selection) {
        return false;
      }
      const pText = data.getData("application/x-portable-text");
      const origin = data.getData("application/x-portable-text-event-origin");
      debug$7("Inserting portable text from ".concat(origin, " event"), pText);
      if (pText) {
        const parsed = JSON.parse(pText);
        if (Array.isArray(parsed) && parsed.length > 0) {
          const slateValue = _regenerateKeys(editor2, toSlateValue(parsed, {
            schemaTypes
          }), keyGenerator, spanTypeName);
          const validation2 = validateValue(parsed, schemaTypes, keyGenerator);
          if (!validation2.valid) {
            const errorDescription = "".concat((_a4 = validation2.resolution) == null ? void 0 : _a4.description);
            change$.next({
              type: "error",
              level: "warning",
              name: "pasteError",
              description: errorDescription,
              data: validation2
            });
            debug$7("Invalid insert result", validation2);
            return false;
          }
          _insertFragment(editor2, slateValue, schemaTypes);
          return true;
        }
      }
      return false;
    };
    editor2.insertTextOrHTMLData = (data) => {
      var _a4;
      if (!editor2.selection) {
        debug$7("No selection, not inserting");
        return false;
      }
      change$.next({
        type: "loading",
        isLoading: true
      });
      const html = data.getData("text/html");
      const text = data.getData("text/plain");
      if (html || text) {
        debug$7("Inserting data", data);
        let portableText;
        let fragment;
        let insertedType;
        if (html) {
          portableText = htmlToBlocks(html, schemaTypes.portableText).map((block) => normalizeBlock(block, {
            blockTypeName
          }));
          fragment = toSlateValue(portableText, {
            schemaTypes
          });
          insertedType = "HTML";
        } else {
          const blocks2 = escapeHtml(text).split(/\n{2,}/).map((line) => line ? "<p>".concat(line.replace(/(?:\r\n|\r|\n)/g, "<br/>"), "</p>") : "<p></p>").join("");
          const textToHtml = "<html><body>".concat(blocks2, "</body></html>");
          portableText = htmlToBlocks(textToHtml, schemaTypes.portableText).map((block) => normalizeBlock(block, {
            blockTypeName
          }));
          fragment = toSlateValue(portableText, {
            schemaTypes
          });
          insertedType = "text";
        }
        const validation2 = validateValue(portableText, schemaTypes, keyGenerator);
        if (!validation2.valid) {
          const errorDescription = "Could not validate the resulting portable text to insert.\n".concat((_a4 = validation2.resolution) == null ? void 0 : _a4.description, "\nTry to insert as plain text (shift-paste) instead.");
          change$.next({
            type: "error",
            level: "warning",
            name: "pasteError",
            description: errorDescription,
            data: validation2
          });
          debug$7("Invalid insert result", validation2);
          return false;
        }
        debug$7("Inserting ".concat(insertedType, " fragment at ").concat(JSON.stringify(editor2.selection)));
        _insertFragment(editor2, fragment, schemaTypes);
        change$.next({
          type: "loading",
          isLoading: false
        });
        return true;
      }
      change$.next({
        type: "loading",
        isLoading: false
      });
      return false;
    };
    editor2.insertData = (data) => {
      if (!editor2.insertPortableTextData(data)) {
        editor2.insertTextOrHTMLData(data);
      }
    };
    editor2.insertFragmentData = (data) => {
      const fragment = data.getData("application/x-portable-text");
      if (fragment) {
        const parsed = JSON.parse(fragment);
        editor2.insertFragment(parsed);
        return true;
      }
      return false;
    };
    return editor2;
  };
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(str) {
  return String(str).replace(/[&<>"'`=/]/g, (s) => entityMap[s]);
}
function _regenerateKeys(editor2, fragment, keyGenerator, spanTypeName) {
  return fragment.map((node) => {
    const newNode = {
      ...node
    };
    if (editor2.isTextBlock(newNode)) {
      newNode.markDefs = (newNode.markDefs || []).map((def) => {
        const oldKey = def._key;
        const newKey = keyGenerator();
        newNode.children = newNode.children.map((child) => child._type === spanTypeName && editor2.isTextSpan(child) ? {
          ...child,
          marks: child.marks && child.marks.includes(oldKey) ? (
            // eslint-disable-next-line max-nested-callbacks
            [...child.marks].filter((mark) => mark !== oldKey).concat(newKey)
          ) : child.marks
        } : child);
        return {
          ...def,
          _key: newKey
        };
      });
    }
    const nodeWithNewKeys = {
      ...newNode,
      _key: keyGenerator()
    };
    if (editor2.isTextBlock(nodeWithNewKeys)) {
      nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({
        ...child,
        _key: keyGenerator()
      }));
    }
    return nodeWithNewKeys;
  });
}
function _insertFragment(editor2, fragment, schemaTypes) {
  if (!editor2.selection) {
    return;
  }
  const [focusBlock, focusPath] = Editor.node(editor2, editor2.selection, {
    depth: 1
  });
  if (editor2.isTextBlock(focusBlock) && editor2.isTextBlock(fragment[0])) {
    const {
      markDefs
    } = focusBlock;
    debug$7("Mixing markDefs of focusBlock and fragments[0] block", markDefs, fragment[0].markDefs);
    if (!(0, import_isEqual2.default)(markDefs, fragment[0].markDefs)) {
      Transforms.setNodes(editor2, {
        markDefs: (0, import_uniq3.default)([...fragment[0].markDefs || [], ...markDefs || []])
      }, {
        at: focusPath,
        mode: "lowest",
        voids: false
      });
    }
  }
  const isPasteToEmptyEditor = isEqualToEmptyEditor(editor2.children, schemaTypes);
  if (isPasteToEmptyEditor) {
    Transforms.splitNodes(editor2, {
      at: [0, 0]
    });
    editor2.insertFragment(fragment);
    Transforms.removeNodes(editor2, {
      at: [0]
    });
  } else {
    editor2.insertFragment(fragment);
  }
  editor2.onChange();
}
var originalFnMap = /* @__PURE__ */ new WeakMap();
var withPlugins = (editor2, options) => {
  const e2 = editor2;
  const {
    keyGenerator,
    portableTextEditor,
    patches$,
    readOnly,
    maxBlocks
  } = options;
  const {
    schemaTypes,
    change$
  } = portableTextEditor;
  e2.subscriptions = [];
  if (e2.destroy) {
    e2.destroy();
  } else {
    originalFnMap.set(e2, {
      apply: e2.apply,
      onChange: e2.onChange,
      normalizeNode: e2.normalizeNode
    });
  }
  const operationToPatches = createOperationToPatches(schemaTypes);
  const withObjectKeys = createWithObjectKeys(schemaTypes, keyGenerator);
  const withSchemaTypes = createWithSchemaTypes({
    schemaTypes,
    keyGenerator
  });
  const withEditableAPI = createWithEditableAPI(portableTextEditor, schemaTypes, keyGenerator);
  const withPatches = createWithPatches({
    change$,
    keyGenerator,
    patches$,
    patchFunctions: operationToPatches,
    readOnly,
    schemaTypes
  });
  const withMaxBlocks = createWithMaxBlocks(maxBlocks || -1);
  const withPortableTextLists = createWithPortableTextLists(schemaTypes);
  const withUndoRedo = createWithUndoRedo({
    readOnly,
    patches$,
    blockSchemaType: schemaTypes.block
  });
  const withPortableTextMarkModel = createWithPortableTextMarkModel(schemaTypes, change$);
  const withPortableTextBlockStyle = createWithPortableTextBlockStyle(schemaTypes);
  const withPlaceholderBlock = createWithPlaceholderBlock({
    keyGenerator,
    schemaTypes
  });
  const withUtils = createWithUtils({
    keyGenerator,
    schemaTypes
  });
  const withPortableTextSelections = createWithPortableTextSelections(change$, schemaTypes);
  e2.destroy = () => {
    const originalFunctions = originalFnMap.get(e2);
    if (!originalFunctions) {
      throw new Error("Could not find pristine versions of editor functions");
    }
    e2.apply = originalFunctions.apply;
    e2.history = {
      undos: [],
      redos: []
    };
    e2.normalizeNode = originalFunctions.normalizeNode;
    e2.onChange = originalFunctions.onChange;
  };
  if (readOnly) {
    return {
      editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPlaceholderBlock(withPortableTextLists(withPortableTextSelections(withEditableAPI(e2))))))))),
      subscribe: () => import_noop15.default
    };
  }
  return {
    editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(withEditableAPI(e2)))))))))))),
    subscribe: () => {
      const unsubscribes = [];
      editor2.subscriptions.forEach((subscribeFn) => {
        unsubscribes.push(subscribeFn());
      });
      return () => {
        unsubscribes.forEach((unsubscribeFn) => {
          unsubscribeFn();
        });
      };
    }
  };
};
var debug$6 = debugWithName("component:PortableTextEditor:SlateContainer");
function SlateContainer(props2) {
  const {
    patches$,
    portableTextEditor,
    readOnly,
    maxBlocks,
    keyGenerator
  } = props2;
  const [slateEditor, subscribe] = (0, import_react49.useMemo)(() => {
    debug$6("Creating new Slate editor instance");
    const {
      editor: editor2,
      subscribe: _sub
    } = withPlugins(withReact(createEditor()), {
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
    KEY_TO_VALUE_ELEMENT.set(editor2, {});
    KEY_TO_SLATE_ELEMENT.set(editor2, {});
    return [editor2, _sub];
  }, []);
  (0, import_react49.useEffect)(() => {
    const unsubscribe = subscribe();
    return () => {
      unsubscribe();
    };
  }, [subscribe]);
  (0, import_react49.useEffect)(() => {
    debug$6("Re-initializing plugin chain");
    withPlugins(slateEditor, {
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
  }, [keyGenerator, portableTextEditor, maxBlocks, readOnly, patches$, slateEditor]);
  const initialValue = (0, import_react49.useMemo)(() => {
    return [slateEditor.createPlaceholderBlock()];
  }, [slateEditor]);
  (0, import_react49.useEffect)(() => {
    return () => {
      debug$6("Destroying Slate editor");
      slateEditor.destroy();
    };
  }, [slateEditor]);
  return (0, import_jsx_runtime5.jsx)(Slate, {
    editor: slateEditor,
    initialValue,
    children: props2.children
  });
}
var PortableTextEditorSelectionContext = (0, import_react49.createContext)(null);
var usePortableTextEditorSelection = () => {
  const selection = (0, import_react49.useContext)(PortableTextEditorSelectionContext);
  if (selection === void 0) {
    throw new Error("The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return selection;
};
var PortableTextEditorContext = (0, import_react49.createContext)(null);
var usePortableTextEditor = () => {
  const editor2 = (0, import_react49.useContext)(PortableTextEditorContext);
  if (!editor2) {
    throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return editor2;
};
var PortableTextEditorValueContext = (0, import_react49.createContext)(void 0);
var PortableTextEditorReadOnlyContext = (0, import_react49.createContext)(false);
var usePortableTextEditorReadOnlyStatus = () => {
  const readOnly = (0, import_react49.useContext)(PortableTextEditorReadOnlyContext);
  if (readOnly === void 0) {
    throw new Error("The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return readOnly;
};
var debug$5 = debugWithName("hook:useSyncValue");
var CURRENT_VALUE = /* @__PURE__ */ new WeakMap();
function useSyncValue(props2) {
  const {
    portableTextEditor,
    readOnly,
    keyGenerator
  } = props2;
  const {
    change$,
    schemaTypes
  } = portableTextEditor;
  const previousValue = (0, import_react49.useRef)();
  const slateEditor = useSlate();
  const updateValueFunctionRef = (0, import_react49.useRef)();
  const updateFromCurrentValue = (0, import_react49.useCallback)(() => {
    const currentValue = CURRENT_VALUE.get(portableTextEditor);
    if (previousValue.current === currentValue) {
      debug$5("Value is the same object as previous, not need to sync");
      return;
    }
    if (updateValueFunctionRef.current && currentValue) {
      debug$5("Updating the value debounced");
      updateValueFunctionRef.current(currentValue);
    }
  }, [portableTextEditor]);
  const updateValueDebounced = (0, import_react49.useCallback)((0, import_debounce.default)(updateFromCurrentValue, 1e3, {
    trailing: true,
    leading: false
  }), [updateFromCurrentValue]);
  return (0, import_react49.useMemo)(() => {
    const updateFunction = (value) => {
      CURRENT_VALUE.set(portableTextEditor, value);
      const isProcessingLocalChanges = isChangingLocally(slateEditor);
      const isProcessingRemoteChanges = isChangingRemotely(slateEditor);
      if (!readOnly) {
        if (isProcessingLocalChanges) {
          debug$5("Has local changes, not syncing value right now");
          updateValueDebounced();
          return;
        }
        if (isProcessingRemoteChanges) {
          debug$5("Has remote changes, not syncing value right now");
          updateValueDebounced();
          return;
        }
      }
      let isChanged = false;
      let isValid2 = true;
      const hadSelection = !!slateEditor.selection;
      if (!value || value.length === 0) {
        debug$5("Value is empty");
        Editor.withoutNormalizing(slateEditor, () => {
          withoutSaving(slateEditor, () => {
            withoutPatching(slateEditor, () => {
              if (hadSelection) {
                Transforms.deselect(slateEditor);
              }
              const childrenLength = slateEditor.children.length;
              slateEditor.children.forEach((_, index) => {
                Transforms.removeNodes(slateEditor, {
                  at: [childrenLength - 1 - index]
                });
              });
              Transforms.insertNodes(slateEditor, slateEditor.createPlaceholderBlock(), {
                at: [0]
              });
              if (hadSelection) {
                Transforms.select(slateEditor, [0, 0]);
              }
            });
          });
        });
        isChanged = true;
      }
      if (value && value.length > 0) {
        const slateValueFromProps = toSlateValue(value, {
          schemaTypes
        });
        Editor.withoutNormalizing(slateEditor, () => {
          withRemoteChanges(slateEditor, () => {
            withoutSaving(slateEditor, () => {
              withoutPatching(slateEditor, () => {
                const childrenLength = slateEditor.children.length;
                if (slateValueFromProps.length < childrenLength) {
                  for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--) {
                    Transforms.removeNodes(slateEditor, {
                      at: [i]
                    });
                  }
                  isChanged = true;
                }
                slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {
                  const oldBlock = slateEditor.children[currentBlockIndex];
                  const hasChanges = oldBlock && !(0, import_isEqual2.default)(currentBlock, oldBlock);
                  if (hasChanges && isValid2) {
                    const validationValue = [value[currentBlockIndex]];
                    const validation2 = validateValue(validationValue, schemaTypes, keyGenerator);
                    if (validation2.valid) {
                      if (oldBlock._key === currentBlock._key) {
                        if (debug$5.enabled)
                          debug$5("Updating block", oldBlock, currentBlock);
                        _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex);
                      } else {
                        if (debug$5.enabled)
                          debug$5("Replacing block", oldBlock, currentBlock);
                        _replaceBlock(slateEditor, currentBlock, currentBlockIndex);
                      }
                      isChanged = true;
                    } else {
                      change$.next({
                        type: "invalidValue",
                        resolution: validation2.resolution,
                        value
                      });
                      isValid2 = false;
                    }
                  }
                  if (!oldBlock && isValid2) {
                    const validationValue = [value[currentBlockIndex]];
                    const validation2 = validateValue(validationValue, schemaTypes, keyGenerator);
                    if (debug$5.enabled)
                      debug$5("Validating and inserting new block in the end of the value", currentBlock);
                    if (validation2.valid) {
                      withPreserveKeys(slateEditor, () => {
                        Transforms.insertNodes(slateEditor, currentBlock, {
                          at: [currentBlockIndex]
                        });
                      });
                    } else {
                      debug$5("Invalid", validation2);
                      change$.next({
                        type: "invalidValue",
                        resolution: validation2.resolution,
                        value
                      });
                      isValid2 = false;
                    }
                  }
                });
              });
            });
          });
        });
      }
      if (!isValid2) {
        debug$5("Invalid value, returning");
        return;
      }
      if (isChanged) {
        debug$5("Server value changed, syncing editor");
        try {
          slateEditor.onChange();
        } catch (err) {
          console.error(err);
          change$.next({
            type: "invalidValue",
            resolution: null,
            value
          });
          return;
        }
        if (hadSelection && !slateEditor.selection) {
          Transforms.select(slateEditor, {
            anchor: {
              path: [0, 0],
              offset: 0
            },
            focus: {
              path: [0, 0],
              offset: 0
            }
          });
          slateEditor.onChange();
        }
        change$.next({
          type: "value",
          value
        });
      } else {
        debug$5("Server value and editor value is equal, no need to sync.");
      }
      previousValue.current = value;
    };
    updateValueFunctionRef.current = updateFunction;
    return updateFunction;
  }, [change$, keyGenerator, portableTextEditor, readOnly, schemaTypes, slateEditor, updateValueDebounced]);
}
function _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {
  const currentSelection = slateEditor.selection;
  const selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;
  if (selectionFocusOnBlock) {
    Transforms.deselect(slateEditor);
  }
  Transforms.removeNodes(slateEditor, {
    at: [currentBlockIndex]
  });
  withPreserveKeys(slateEditor, () => {
    Transforms.insertNodes(slateEditor, currentBlock, {
      at: [currentBlockIndex]
    });
  });
  if (selectionFocusOnBlock) {
    Transforms.select(slateEditor, currentSelection);
  }
}
function _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {
  Transforms.setNodes(slateEditor, currentBlock, {
    at: [currentBlockIndex]
  });
  if (slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {
    const oldBlockChildrenLength = oldBlock.children.length;
    if (currentBlock.children.length < oldBlockChildrenLength) {
      Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {
        const childIndex = oldBlockChildrenLength - 1 - index;
        if (childIndex > 0) {
          debug$5("Removing child");
          Transforms.removeNodes(slateEditor, {
            at: [currentBlockIndex, childIndex]
          });
        }
      });
    }
    currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {
      const oldBlockChild = oldBlock.children[currentBlockChildIndex];
      const isChildChanged = !(0, import_isEqual2.default)(currentBlockChild, oldBlockChild);
      const isTextChanged = !(0, import_isEqual2.default)(currentBlockChild.text, oldBlockChild == null ? void 0 : oldBlockChild.text);
      const path2 = [currentBlockIndex, currentBlockChildIndex];
      if (isChildChanged) {
        if (currentBlockChild._key === (oldBlockChild == null ? void 0 : oldBlockChild._key)) {
          debug$5("Updating changed child", currentBlockChild, oldBlockChild);
          Transforms.setNodes(slateEditor, currentBlockChild, {
            at: path2
          });
          const isSpanNode = Text2.isText(currentBlockChild) && currentBlockChild._type === "span" && Text2.isText(oldBlockChild) && oldBlockChild._type === "span";
          if (isSpanNode && isTextChanged) {
            Transforms.delete(slateEditor, {
              at: {
                focus: {
                  path: path2,
                  offset: 0
                },
                anchor: {
                  path: path2,
                  offset: oldBlockChild.text.length
                }
              }
            });
            Transforms.insertText(slateEditor, currentBlockChild.text, {
              at: path2
            });
            slateEditor.onChange();
          } else if (!isSpanNode) {
            debug$5("Updating changed inline object child", currentBlockChild);
            Transforms.setNodes(slateEditor, {
              _key: VOID_CHILD_KEY
            }, {
              at: [...path2, 0],
              voids: true
            });
          }
        } else if (oldBlockChild) {
          debug$5("Replacing child", currentBlockChild);
          Transforms.removeNodes(slateEditor, {
            at: [currentBlockIndex, currentBlockChildIndex]
          });
          withPreserveKeys(slateEditor, () => {
            Transforms.insertNodes(slateEditor, currentBlockChild, {
              at: [currentBlockIndex, currentBlockChildIndex]
            });
          });
          slateEditor.onChange();
        } else if (!oldBlockChild) {
          debug$5("Inserting new child", currentBlockChild);
          withPreserveKeys(slateEditor, () => {
            Transforms.insertNodes(slateEditor, currentBlockChild, {
              at: [currentBlockIndex, currentBlockChildIndex]
            });
            slateEditor.onChange();
          });
        }
      }
    });
  }
}
var debug$4 = debugWithName("component:PortableTextEditor:Synchronizer");
var debugVerbose = debug$4.enabled && false;
var FLUSH_PATCHES_THROTTLED_MS = false ? 500 : 1e3;
function Synchronizer(props2) {
  const {
    change$,
    portableTextEditor,
    onChange,
    keyGenerator,
    readOnly,
    value
  } = props2;
  const [selection, setSelection] = (0, import_react49.useState)(null);
  const pendingPatches = (0, import_react49.useRef)([]);
  const syncValue = useSyncValue({
    keyGenerator,
    onChange,
    portableTextEditor,
    readOnly
  });
  const slateEditor = useSlate();
  (0, import_react49.useEffect)(() => {
    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, false);
  }, [slateEditor]);
  const onFlushPendingPatches = (0, import_react49.useCallback)(() => {
    if (pendingPatches.current.length > 0) {
      debug$4("Flushing pending patches");
      if (debugVerbose) {
        debug$4("Patches:\n".concat(JSON.stringify(pendingPatches.current, null, 2)));
      }
      const snapshot = PortableTextEditor.getValue(portableTextEditor);
      change$.next({
        type: "mutation",
        patches: pendingPatches.current,
        snapshot
      });
      pendingPatches.current = [];
    }
    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, false);
  }, [slateEditor, portableTextEditor, change$]);
  const onFlushPendingPatchesThrottled = (0, import_react49.useMemo)(() => {
    return (0, import_throttle.default)(() => {
      if (Editor.isNormalizing(slateEditor)) {
        onFlushPendingPatches();
        return;
      }
      onFlushPendingPatchesThrottled();
    }, FLUSH_PATCHES_THROTTLED_MS, {
      leading: false,
      trailing: true
    });
  }, [onFlushPendingPatches, slateEditor]);
  (0, import_react49.useEffect)(() => {
    return () => {
      onFlushPendingPatches();
    };
  }, [onFlushPendingPatches]);
  (0, import_react49.useEffect)(() => {
    debug$4("Subscribing to editor changes$");
    const sub2 = change$.subscribe((next) => {
      switch (next.type) {
        case "patch":
          IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, true);
          pendingPatches.current.push(next.patch);
          onFlushPendingPatchesThrottled();
          onChange(next);
          break;
        case "selection":
          (0, import_react49.startTransition)(() => {
            if (debugVerbose)
              debug$4("Setting selection");
            setSelection(next.selection);
          });
          onChange(next);
          break;
        default:
          onChange(next);
      }
    });
    return () => {
      debug$4("Unsubscribing to changes$");
      sub2.unsubscribe();
    };
  }, [change$, onChange, onFlushPendingPatchesThrottled, slateEditor]);
  const handleOnline = (0, import_react49.useCallback)(() => {
    debug$4("Editor is online, syncing from props.value");
    change$.next({
      type: "connection",
      value: "online"
    });
    syncValue(value);
  }, [change$, syncValue, value]);
  const handleOffline = (0, import_react49.useCallback)(() => {
    debug$4("Editor is offline");
    change$.next({
      type: "connection",
      value: "offline"
    });
  }, [change$]);
  (0, import_react49.useEffect)(() => {
    if (portableTextEditor.props.patches$) {
      window.addEventListener("online", handleOnline);
      window.addEventListener("offline", handleOffline);
    }
    return () => {
      if (portableTextEditor.props.patches$) {
        window.removeEventListener("online", handleOnline);
        window.removeEventListener("offline", handleOffline);
      }
    };
  });
  const isInitialValueFromProps = (0, import_react49.useRef)(true);
  (0, import_react49.useEffect)(() => {
    debug$4("Value from props changed, syncing new value");
    syncValue(value);
    if (isInitialValueFromProps.current) {
      change$.next({
        type: "loading",
        isLoading: false
      });
      change$.next({
        type: "ready"
      });
      isInitialValueFromProps.current = false;
    }
  }, [change$, syncValue, value]);
  return (0, import_jsx_runtime5.jsx)(PortableTextEditorKeyGeneratorContext.Provider, {
    value: keyGenerator,
    children: (0, import_jsx_runtime5.jsx)(PortableTextEditorContext.Provider, {
      value: portableTextEditor,
      children: (0, import_jsx_runtime5.jsx)(PortableTextEditorValueContext.Provider, {
        value,
        children: (0, import_jsx_runtime5.jsx)(PortableTextEditorReadOnlyContext.Provider, {
          value: readOnly,
          children: (0, import_jsx_runtime5.jsx)(PortableTextEditorSelectionContext.Provider, {
            value: selection,
            children: props2.children
          })
        })
      })
    })
  });
}
var debug$3 = debugWithName("component:PortableTextEditor");
var PortableTextEditor = class extends import_react49.default.Component {
  constructor(props2) {
    super(props2);
    this.change$ = new Subject();
    this.setEditable = (editable) => {
      this.editable = {
        ...this.editable,
        ...editable
      };
    };
    if (!props2.schemaType) {
      throw new Error('PortableTextEditor: missing "type" property');
    }
    if (props2.incomingPatches$) {
      console.warn("The prop 'incomingPatches$' is deprecated and renamed to 'patches$'");
    }
    this.change$.next({
      type: "loading",
      isLoading: true
    });
    this.schemaTypes = getPortableTextMemberSchemaTypes(props2.schemaType.hasOwnProperty("jsonType") ? props2.schemaType : compileType(props2.schemaType));
  }
  componentDidUpdate(prevProps) {
    if (this.props.schemaType !== prevProps.schemaType) {
      this.schemaTypes = getPortableTextMemberSchemaTypes(this.props.schemaType.hasOwnProperty("jsonType") ? this.props.schemaType : compileType(this.props.schemaType));
    }
  }
  render() {
    const {
      onChange,
      value,
      children,
      patches$,
      incomingPatches$
    } = this.props;
    const {
      change$
    } = this;
    const _patches$ = incomingPatches$ || patches$;
    const maxBlocks = typeof this.props.maxBlocks === "undefined" ? void 0 : parseInt(this.props.maxBlocks.toString(), 10) || void 0;
    const readOnly = Boolean(this.props.readOnly);
    const keyGenerator = this.props.keyGenerator || defaultKeyGenerator;
    return (0, import_jsx_runtime5.jsx)(SlateContainer, {
      keyGenerator,
      maxBlocks,
      patches$: _patches$,
      portableTextEditor: this,
      readOnly,
      children: (0, import_jsx_runtime5.jsx)(Synchronizer, {
        change$,
        keyGenerator,
        onChange,
        portableTextEditor: this,
        readOnly,
        value,
        children
      })
    });
  }
};
PortableTextEditor.activeAnnotations = (editor2) => {
  return editor2 && editor2.editable ? editor2.editable.activeAnnotations() : [];
};
PortableTextEditor.addAnnotation = (editor2, type, value) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.addAnnotation(type, value);
};
PortableTextEditor.blur = (editor2) => {
  var _a4;
  debug$3("Host blurred");
  (_a4 = editor2.editable) == null ? void 0 : _a4.blur();
};
PortableTextEditor.delete = (editor2, selection, options) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.delete(selection, options);
};
PortableTextEditor.findDOMNode = (editor2, element) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.findDOMNode(element);
};
PortableTextEditor.findByPath = (editor2, path2) => {
  var _a4;
  return ((_a4 = editor2.editable) == null ? void 0 : _a4.findByPath(path2)) || [];
};
PortableTextEditor.focus = (editor2) => {
  var _a4;
  debug$3("Host requesting focus");
  (_a4 = editor2.editable) == null ? void 0 : _a4.focus();
};
PortableTextEditor.focusBlock = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.focusBlock();
};
PortableTextEditor.focusChild = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.focusChild();
};
PortableTextEditor.getSelection = (editor2) => {
  return editor2.editable ? editor2.editable.getSelection() : null;
};
PortableTextEditor.getValue = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.getValue();
};
PortableTextEditor.hasBlockStyle = (editor2, blockStyle) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.hasBlockStyle(blockStyle);
};
PortableTextEditor.hasListStyle = (editor2, listStyle) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.hasListStyle(listStyle);
};
PortableTextEditor.isCollapsedSelection = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.isCollapsedSelection();
};
PortableTextEditor.isExpandedSelection = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.isExpandedSelection();
};
PortableTextEditor.isMarkActive = (editor2, mark) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.isMarkActive(mark);
};
PortableTextEditor.insertChild = (editor2, type, value) => {
  var _a4;
  debug$3("Host inserting child");
  return (_a4 = editor2.editable) == null ? void 0 : _a4.insertChild(type, value);
};
PortableTextEditor.insertBlock = (editor2, type, value) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.insertBlock(type, value);
};
PortableTextEditor.insertBreak = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.insertBreak();
};
PortableTextEditor.isVoid = (editor2, element) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.isVoid(element);
};
PortableTextEditor.isObjectPath = (editor2, path2) => {
  if (!path2 || !Array.isArray(path2))
    return false;
  const isChildObjectEditPath = path2.length > 3 && path2[1] === "children";
  const isBlockObjectEditPath = path2.length > 1 && path2[1] !== "children";
  return isBlockObjectEditPath || isChildObjectEditPath;
};
PortableTextEditor.marks = (editor2) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.marks();
};
PortableTextEditor.select = (editor2, selection) => {
  var _a4;
  debug$3("Host setting selection", selection);
  (_a4 = editor2.editable) == null ? void 0 : _a4.select(selection);
};
PortableTextEditor.removeAnnotation = (editor2, type) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.removeAnnotation(type);
};
PortableTextEditor.toggleBlockStyle = (editor2, blockStyle) => {
  var _a4;
  debug$3("Host is toggling block style");
  return (_a4 = editor2.editable) == null ? void 0 : _a4.toggleBlockStyle(blockStyle);
};
PortableTextEditor.toggleList = (editor2, listStyle) => {
  var _a4;
  return (_a4 = editor2.editable) == null ? void 0 : _a4.toggleList(listStyle);
};
PortableTextEditor.toggleMark = (editor2, mark) => {
  var _a4;
  debug$3("Host toggling mark", mark);
  (_a4 = editor2.editable) == null ? void 0 : _a4.toggleMark(mark);
};
function normalizePoint(point, value) {
  if (!point || !value) {
    return null;
  }
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] === "object" && "_key" in point.path[0] && point.path[0]._key;
  const childKey = typeof point.path[2] === "object" && "_key" in point.path[2] && point.path[2]._key;
  const block = value.find((blk) => blk._key === blockKey);
  if (block) {
    newPath.push({
      _key: block._key
    });
  } else {
    return null;
  }
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0) {
      return null;
    }
    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);
    if (child) {
      newPath.push("children");
      newPath.push({
        _key: child._key
      });
      newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    } else {
      return null;
    }
  }
  return {
    path: newPath,
    offset: newOffset
  };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0) {
    return null;
  }
  let newAnchor = null;
  let newFocus = null;
  const {
    anchor,
    focus
  } = selection;
  if (anchor && value.find((blk) => (0, import_isEqual2.default)({
    _key: blk._key
  }, anchor.path[0]))) {
    newAnchor = normalizePoint(anchor, value);
  }
  if (focus && value.find((blk) => (0, import_isEqual2.default)({
    _key: blk._key
  }, focus.path[0]))) {
    newFocus = normalizePoint(focus, value);
  }
  if (newAnchor && newFocus) {
    return {
      anchor: newAnchor,
      focus: newFocus
    };
  }
  return null;
}
function DefaultAnnotation(props2) {
  const handleClick = (0, import_react49.useCallback)(() => alert(JSON.stringify(props2.annotation)), [props2.annotation]);
  return (0, import_jsx_runtime5.jsx)("span", {
    style: {
      color: "blue"
    },
    onClick: handleClick,
    children: props2.children
  });
}
var debug$2 = debugWithName("components:Leaf");
var EMPTY_MARKS = [];
var Leaf = (props2) => {
  const {
    attributes,
    children,
    leaf,
    schemaTypes,
    renderChild,
    renderDecorator: renderDecorator2,
    renderAnnotation
  } = props2;
  const spanRef = import_react49.default.useRef(null);
  const portableTextEditor = usePortableTextEditor();
  const blockSelected = useSelected();
  const [focused, setFocused] = (0, import_react49.useState)(false);
  const [selected, setSelected] = (0, import_react49.useState)(false);
  const block = children.props.parent;
  const path2 = (0, import_react49.useMemo)(() => block ? [{
    _key: block == null ? void 0 : block._key
  }, "children", {
    _key: leaf._key
  }] : [], [block, leaf._key]);
  const decoratorValues = (0, import_react49.useMemo)(() => schemaTypes.decorators.map((dec2) => dec2.value), [schemaTypes.decorators]);
  const marks = (0, import_react49.useMemo)(() => (0, import_uniq3.default)((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]);
  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS;
  const annotations = (0, import_react49.useMemo)(() => annotationMarks.map((mark) => {
    var _a4;
    return !decoratorValues.includes(mark) && ((_a4 = block == null ? void 0 : block.markDefs) == null ? void 0 : _a4.find((def) => def._key === mark));
  }).filter(Boolean), [annotationMarks, block, decoratorValues]);
  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;
  (0, import_react49.useEffect)(() => {
    if (!shouldTrackSelectionAndFocus) {
      setFocused(false);
      return;
    }
    const sel = PortableTextEditor.getSelection(portableTextEditor);
    if (sel && (0, import_isEqual2.default)(sel.focus.path, path2) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
      (0, import_react49.startTransition)(() => {
        setFocused(true);
      });
    }
  }, [shouldTrackSelectionAndFocus, path2, portableTextEditor]);
  const setSelectedFromRange = (0, import_react49.useCallback)(() => {
    if (!shouldTrackSelectionAndFocus) {
      return;
    }
    debug$2("Setting selection and focus from range");
    const winSelection = window.getSelection();
    if (!winSelection) {
      setSelected(false);
      return;
    }
    if (winSelection && winSelection.rangeCount > 0) {
      const range2 = winSelection.getRangeAt(0);
      if (spanRef.current && range2.intersectsNode(spanRef.current)) {
        setSelected(true);
      } else {
        setSelected(false);
      }
    } else {
      setSelected(false);
    }
  }, [shouldTrackSelectionAndFocus]);
  (0, import_react49.useEffect)(() => {
    if (!shouldTrackSelectionAndFocus) {
      return void 0;
    }
    const sub2 = portableTextEditor.change$.subscribe((next) => {
      if (next.type === "blur") {
        setFocused(false);
        setSelected(false);
        return;
      }
      if (next.type === "focus") {
        const sel = PortableTextEditor.getSelection(portableTextEditor);
        if (sel && (0, import_isEqual2.default)(sel.focus.path, path2) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
          setFocused(true);
        }
        setSelectedFromRange();
        return;
      }
      if (next.type === "selection") {
        if (next.selection && (0, import_isEqual2.default)(next.selection.focus.path, path2) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
          setFocused(true);
        } else {
          setFocused(false);
        }
        setSelectedFromRange();
      }
    });
    return () => {
      sub2.unsubscribe();
    };
  }, [path2, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]);
  (0, import_react49.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);
  const content = (0, import_react49.useMemo)(() => {
    let returnedChildren = children;
    if (Text2.isText(leaf) && leaf._type === schemaTypes.span.name) {
      marks.forEach((mark) => {
        const schemaType = schemaTypes.decorators.find((dec2) => dec2.value === mark);
        if (schemaType && renderDecorator2) {
          const _props = Object.defineProperty({
            children: returnedChildren,
            editorElementRef: spanRef,
            focused,
            path: path2,
            selected,
            schemaType,
            value: mark
          }, "type", {
            enumerable: false,
            get() {
              console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
              return schemaType;
            }
          });
          returnedChildren = renderDecorator2(_props);
        }
      });
      if (block && annotations.length > 0) {
        annotations.forEach((annotation) => {
          const schemaType = schemaTypes.annotations.find((t3) => t3.name === annotation._type);
          if (schemaType) {
            if (renderAnnotation) {
              const _props = Object.defineProperty({
                block,
                children: returnedChildren,
                editorElementRef: spanRef,
                focused,
                path: path2,
                selected,
                schemaType,
                value: annotation
              }, "type", {
                enumerable: false,
                get() {
                  console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
                  return schemaType;
                }
              });
              returnedChildren = (0, import_jsx_runtime5.jsx)("span", {
                ref: spanRef,
                children: renderAnnotation(_props)
              });
            } else {
              returnedChildren = (0, import_jsx_runtime5.jsx)(DefaultAnnotation, {
                annotation,
                children: (0, import_jsx_runtime5.jsx)("span", {
                  ref: spanRef,
                  children: returnedChildren
                })
              });
            }
          }
        });
      }
      if (block && renderChild) {
        const child = block.children.find((_child) => _child._key === leaf._key);
        if (child) {
          const defaultRendered = (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, {
            children: returnedChildren
          });
          const _props = Object.defineProperty({
            annotations,
            children: defaultRendered,
            editorElementRef: spanRef,
            focused,
            path: path2,
            schemaType: schemaTypes.span,
            selected,
            value: child
          }, "type", {
            enumerable: false,
            get() {
              console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
              return schemaTypes.span;
            }
          });
          returnedChildren = renderChild(_props);
        }
      }
    }
    return returnedChildren;
  }, [annotations, block, children, focused, leaf, marks, path2, renderAnnotation, renderChild, renderDecorator2, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);
  return (0, import_react49.useMemo)(() => (0, import_jsx_runtime5.jsx)("span", {
    ...attributes,
    ref: spanRef,
    children: content
  }, leaf._key), [leaf, attributes, content]);
};
var DefaultObject = (props2) => {
  return (0, import_jsx_runtime5.jsx)("div", {
    children: (0, import_jsx_runtime5.jsx)("pre", {
      children: JSON.stringify(props2.value, null, 2)
    })
  });
};
var __freeze2 = Object.freeze;
var __defProp2 = Object.defineProperty;
var __template2 = (cooked, raw) => __freeze2(__defProp2(cooked, "raw", {
  value: __freeze2(raw || cooked.slice())
}));
var _a2;
var _b2;
var _c2;
var _d2;
var DefaultBlockObject = st.div(_a2 || (_a2 = __template2(["\n  user-select: none;\n  border: ", ";\n"])), (props2) => {
  if (props2.selected) {
    return "1px solid blue";
  }
  return "1px solid transparent";
});
st.span(_b2 || (_b2 = __template2(["\n  background: #999;\n  border: ", ";\n"])), (props2) => {
  if (props2.selected) {
    return "1px solid blue";
  }
  return "1px solid transparent";
});
var DefaultListItem = st.div(_c2 || (_c2 = __template2(["\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ", ";\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '", "';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ", ";\n    counter-reset: ", ";\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ", ";\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n"])), (props2) => getLeftPositionForListLevel(props2.listLevel), (props2) => getContentForListLevelAndStyle(props2.listLevel, props2.listStyle), (props2) => getCounterIncrementForListLevel(props2.listLevel), (props2) => getCounterResetForListLevel(props2.listLevel), (props2) => getCounterContentForListLevel(props2.listLevel));
var DefaultListItemInner = st.div(_d2 || (_d2 = __template2([""])));
function getLeftPositionForListLevel(level) {
  switch (Number(level)) {
    case 1:
      return "1.5em";
    case 2:
      return "3em";
    case 3:
      return "4.5em";
    case 4:
      return "6em";
    case 5:
      return "7.5em";
    case 6:
      return "9em";
    case 7:
      return "10.5em";
    case 8:
      return "12em";
    case 9:
      return "13.5em";
    case 10:
      return "15em";
    default:
      return "0em";
  }
}
var bullets = ["", "", ""];
function getContentForListLevelAndStyle(level, style) {
  const normalizedLevel = (level - 1) % 3;
  if (style === "bullet") {
    return bullets[normalizedLevel];
  }
  return "*";
}
function getCounterIncrementForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemNumber";
    case 2:
      return "listItemAlpha";
    case 3:
      return "listItemRoman";
    case 4:
      return "listItemNumberNext";
    case 5:
      return "listItemLetterNext";
    case 6:
      return "listItemRomanNext";
    case 7:
      return "listItemNumberNextNext";
    case 8:
      return "listItemAlphaNextNext";
    case 9:
      return "listItemRomanNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterResetForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemAlpha";
    case 2:
      return "listItemRoman";
    case 3:
      return "listItemNumberNext";
    case 4:
      return "listItemLetterNext";
    case 5:
      return "listItemRomanNext";
    case 6:
      return "listItemNumberNextNext";
    case 7:
      return "listItemAlphaNextNext";
    case 8:
      return "listItemRomanNextNext";
    case 9:
      return "listItemNumberNextNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterContentForListLevel(level) {
  switch (level) {
    case 1:
      return "counter(listItemNumber) '. '";
    case 2:
      return "counter(listItemAlpha, lower-alpha) '. '";
    case 3:
      return "counter(listItemRoman, lower-roman) '. '";
    case 4:
      return "counter(listItemNumberNext) '. '";
    case 5:
      return "counter(listItemLetterNext, lower-alpha) '. '";
    case 6:
      return "counter(listItemRomanNext, lower-roman) '. '";
    case 7:
      return "counter(listItemNumberNextNext) '. '";
    case 8:
      return "counter(listItemAlphaNextNext, lower-alpha) '. '";
    case 9:
      return "counter(listItemRomanNextNext, lower-roman) '. '";
    default:
      return "counter(listItemNumberNextNextNext) '. '";
  }
}
var debug$12 = debugWithName("components:DraggableBlock");
var DraggableBlock = (_ref17) => {
  let {
    children,
    element,
    readOnly,
    blockRef
  } = _ref17;
  const editor2 = useSlateStatic();
  const dragGhostRef = (0, import_react49.useRef)();
  const [isDragOver, setIsDragOver] = (0, import_react49.useState)(false);
  const isVoid = (0, import_react49.useMemo)(() => Editor.isVoid(editor2, element), [editor2, element]);
  const isInline = (0, import_react49.useMemo)(() => Editor.isInline(editor2, element), [editor2, element]);
  const [blockElement, setBlockElement] = (0, import_react49.useState)(null);
  (0, import_react49.useEffect)(() => setBlockElement(blockRef ? blockRef.current : ReactEditor.toDOMNode(editor2, element)), [editor2, element, blockRef]);
  const handleDragOver = (0, import_react49.useCallback)((event) => {
    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor2);
    if (!isMyDragOver || !blockElement) {
      return;
    }
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    IS_DRAGGING_ELEMENT_TARGET.set(editor2, element);
    const elementRect = blockElement.getBoundingClientRect();
    const offset2 = elementRect.top;
    const height = elementRect.height;
    const Y = event.pageY;
    const loc = Math.abs(offset2 - Y);
    let position = "bottom";
    if (element === editor2.children[0]) {
      position = "top";
    } else if (loc < height / 2) {
      position = "top";
      IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor2, position);
    } else {
      position = "bottom";
      IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor2, position);
    }
    if (isMyDragOver === element) {
      event.dataTransfer.dropEffect = "none";
      return;
    }
    setIsDragOver(true);
  }, [blockElement, editor2, element]);
  const handleDragLeave = (0, import_react49.useCallback)(() => {
    setIsDragOver(false);
  }, []);
  const handleDragEnd = (0, import_react49.useCallback)((event) => {
    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor2);
    if (targetBlock) {
      IS_DRAGGING.set(editor2, false);
      event.preventDefault();
      event.stopPropagation();
      IS_DRAGGING_ELEMENT_TARGET.delete(editor2);
      if (dragGhostRef.current) {
        debug$12("Removing drag ghost");
        document.body.removeChild(dragGhostRef.current);
      }
      const dragPosition2 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor2);
      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor2);
      let targetPath = ReactEditor.findPath(editor2, targetBlock);
      const myPath = ReactEditor.findPath(editor2, element);
      const isBefore2 = Path.isBefore(myPath, targetPath);
      if (dragPosition2 === "bottom" && !isBefore2) {
        if (targetPath[0] >= editor2.children.length - 1) {
          debug$12("target is already at the bottom, not moving");
          return;
        }
        const originalPath = targetPath;
        targetPath = Path.next(targetPath);
        debug$12("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
      }
      if (dragPosition2 === "top" && isBefore2 && targetPath[0] !== editor2.children.length - 1) {
        const originalPath = targetPath;
        targetPath = Path.previous(targetPath);
        debug$12("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
      }
      if (Path.equals(targetPath, myPath)) {
        event.preventDefault();
        debug$12("targetPath and myPath is the same, not moving");
        return;
      }
      debug$12("Moving element ".concat(element._key, " from path ").concat(JSON.stringify(myPath), " to ").concat(JSON.stringify(targetPath), " (").concat(dragPosition2, ")"));
      Transforms.moveNodes(editor2, {
        at: myPath,
        to: targetPath
      });
      editor2.onChange();
      return;
    }
    debug$12("No target element, not doing anything");
  }, [editor2, element]);
  const handleDrop = (0, import_react49.useCallback)((event) => {
    if (IS_DRAGGING_BLOCK_ELEMENT.get(editor2)) {
      debug$12("On drop (prevented)", element);
      event.preventDefault();
      event.stopPropagation();
      setIsDragOver(false);
    }
  }, [editor2, element]);
  const handleDrag = (0, import_react49.useCallback)((event) => {
    if (!isVoid) {
      IS_DRAGGING_BLOCK_ELEMENT.delete(editor2);
      return;
    }
    IS_DRAGGING.set(editor2, true);
    IS_DRAGGING_BLOCK_ELEMENT.set(editor2, element);
    event.stopPropagation();
    const target = event.target;
    if (target instanceof HTMLElement) {
      target.style.opacity = "1";
    }
  }, [editor2, element, isVoid]);
  const handleDragStart = (0, import_react49.useCallback)((event) => {
    if (!isVoid || isInline) {
      debug$12("Not dragging block");
      IS_DRAGGING_BLOCK_ELEMENT.delete(editor2);
      IS_DRAGGING.set(editor2, false);
      return;
    }
    debug$12("Drag start");
    IS_DRAGGING.set(editor2, true);
    if (event.dataTransfer) {
      event.dataTransfer.setData("application/portable-text", "something");
      event.dataTransfer.effectAllowed = "move";
    }
    if (blockElement && blockElement instanceof HTMLElement) {
      let dragGhost = blockElement.cloneNode(true);
      const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
      if (customGhost) {
        dragGhost = customGhost;
      }
      dragGhost.setAttribute("data-dragged", "");
      if (document.body) {
        dragGhostRef.current = dragGhost;
        dragGhost.style.position = "absolute";
        dragGhost.style.left = "-99999px";
        dragGhost.style.boxSizing = "border-box";
        document.body.appendChild(dragGhost);
        const rect = blockElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        dragGhost.style.width = "".concat(rect.width, "px");
        dragGhost.style.height = "".concat(rect.height, "px");
        event.dataTransfer.setDragImage(dragGhost, x, y);
      }
    }
    handleDrag(event);
  }, [blockElement, editor2, handleDrag, isInline, isVoid]);
  const isDraggingOverFirstBlock = isDragOver && editor2.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor2);
  const isDraggingOverLastBlock = isDragOver && editor2.children[editor2.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor2);
  const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor2);
  const isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "top";
  const isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "bottom";
  const dropIndicator = (0, import_react49.useMemo)(() => (0, import_jsx_runtime5.jsx)("div", {
    className: "pt-drop-indicator",
    style: {
      position: "absolute",
      width: "100%",
      height: 1,
      borderBottom: "1px solid currentColor",
      zIndex: 5
    }
  }), []);
  if (readOnly) {
    return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, {
      children
    });
  }
  return (0, import_jsx_runtime5.jsxs)("div", {
    draggable: isVoid,
    onDragStart: handleDragStart,
    onDrag: handleDrag,
    onDragOver: handleDragOver,
    onDragLeave: handleDragLeave,
    onDragEnd: handleDragEnd,
    onDrop: handleDrop,
    children: [isDraggingOverTop && dropIndicator, children, isDraggingOverBottom && dropIndicator]
  });
};
debugWithName("components:Element");
var EMPTY_ANNOTATIONS = [];
var inlineBlockStyle = {
  display: "inline-block"
};
var Element3 = (_ref18) => {
  let {
    attributes,
    children,
    element,
    schemaTypes,
    readOnly,
    renderBlock,
    renderChild,
    renderListItem: renderListItem2,
    renderStyle: renderStyle2,
    spellCheck
  } = _ref18;
  const editor2 = useSlateStatic();
  const selected = useSelected();
  const blockRef = (0, import_react49.useRef)(null);
  const inlineBlockObjectRef = (0, import_react49.useRef)(null);
  const focused = selected && editor2.selection && Range.isCollapsed(editor2.selection) || false;
  const value = (0, import_react49.useMemo)(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor2))[0], [editor2, element, schemaTypes.block.name]);
  let renderedBlock = children;
  let className;
  const blockPath = (0, import_react49.useMemo)(() => [{
    _key: element._key
  }], [element]);
  if (typeof element._type !== "string") {
    throw new Error("Expected element to have a _type property");
  }
  if (typeof element._key !== "string") {
    throw new Error("Expected element to have a _key property");
  }
  if (editor2.isInline(element)) {
    const path2 = ReactEditor.findPath(editor2, element);
    const [block2] = Editor.node(editor2, path2, {
      depth: 1
    });
    const schemaType2 = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);
    if (!schemaType2) {
      throw new Error("Could not find type for inline block element");
    }
    if (Element2.isElement(block2)) {
      const elmPath = [{
        _key: block2._key
      }, "children", {
        _key: element._key
      }];
      return (0, import_jsx_runtime5.jsxs)("span", {
        ...attributes,
        children: [children, (0, import_jsx_runtime5.jsxs)("span", {
          draggable: !readOnly,
          className: "pt-inline-object",
          ref: inlineBlockObjectRef,
          style: inlineBlockStyle,
          contentEditable: false,
          children: [renderChild && renderChild({
            annotations: EMPTY_ANNOTATIONS,
            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.
            children: (0, import_jsx_runtime5.jsx)(DefaultObject, {
              value
            }),
            editorElementRef: inlineBlockObjectRef,
            focused,
            path: elmPath,
            schemaType: schemaType2,
            selected,
            type: schemaType2,
            value
          }), !renderChild && (0, import_jsx_runtime5.jsx)(DefaultObject, {
            value
          })]
        }, element._key)]
      });
    }
    throw new Error("Block not found!");
  }
  if (element._type === schemaTypes.block.name) {
    className = "pt-block pt-text-block";
    const isListItem = "listItem" in element;
    const style = "style" in element && element.style || "normal";
    className = "pt-block pt-text-block pt-text-block-style-".concat(style);
    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);
    if (renderStyle2 && blockStyleType) {
      renderedBlock = renderStyle2({
        block: element,
        children,
        focused,
        selected,
        value: style,
        path: blockPath,
        schemaType: blockStyleType,
        editorElementRef: blockRef
      });
    }
    let level;
    if (isListItem) {
      if (typeof element.level === "number") {
        level = element.level;
      }
      className += " pt-list-item pt-list-item-".concat(element.listItem, " pt-list-item-level-").concat(level || 1);
    }
    if (editor2.isListBlock(value) && isListItem && element.listItem) {
      const listType = schemaTypes.lists.find((item) => item.value === element.listItem);
      if (renderListItem2 && listType) {
        renderedBlock = renderListItem2({
          block: value,
          children: renderedBlock,
          focused,
          selected,
          value: element.listItem,
          path: blockPath,
          schemaType: listType,
          level: value.level || 1,
          editorElementRef: blockRef
        });
      } else {
        renderedBlock = (0, import_jsx_runtime5.jsx)(DefaultListItem, {
          listStyle: value.listItem || schemaTypes.lists[0].value,
          listLevel: value.level || 1,
          children: (0, import_jsx_runtime5.jsx)(DefaultListItemInner, {
            children: renderedBlock
          })
        });
      }
    }
    const renderProps = Object.defineProperty({
      children: renderedBlock,
      editorElementRef: blockRef,
      focused,
      level,
      listItem: isListItem ? element.listItem : void 0,
      path: blockPath,
      selected,
      style,
      schemaType: schemaTypes.block,
      value
    }, "type", {
      enumerable: false,
      get() {
        console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
        return schemaTypes.block;
      }
    });
    const propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;
    return (0, import_jsx_runtime5.jsx)("div", {
      ...attributes,
      className,
      spellCheck,
      children: (0, import_jsx_runtime5.jsx)(DraggableBlock, {
        element,
        readOnly,
        blockRef,
        children: (0, import_jsx_runtime5.jsx)("div", {
          ref: blockRef,
          children: propsOrDefaultRendered
        })
      })
    }, element._key);
  }
  const schemaType = schemaTypes.blockObjects.find((_type) => _type.name === element._type);
  if (!schemaType) {
    throw new Error("Could not find schema type for block element of _type ".concat(element._type));
  }
  className = "pt-block pt-object-block";
  const block = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor2))[0];
  let renderedBlockFromProps;
  if (renderBlock) {
    const _props = Object.defineProperty({
      children: (0, import_jsx_runtime5.jsx)(DefaultObject, {
        value
      }),
      editorElementRef: blockRef,
      focused,
      path: blockPath,
      schemaType,
      selected,
      value: block
    }, "type", {
      enumerable: false,
      get() {
        console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
        return schemaType;
      }
    });
    renderedBlockFromProps = renderBlock(_props);
  }
  return (0, import_jsx_runtime5.jsxs)("div", {
    ...attributes,
    className,
    children: [children, (0, import_jsx_runtime5.jsxs)(DraggableBlock, {
      element,
      readOnly,
      blockRef,
      children: [renderedBlockFromProps && (0, import_jsx_runtime5.jsx)("div", {
        ref: blockRef,
        contentEditable: false,
        children: renderedBlockFromProps
      }), !renderedBlockFromProps && (0, import_jsx_runtime5.jsx)(DefaultBlockObject, {
        selected,
        children: (0, import_jsx_runtime5.jsx)(DefaultObject, {
          value
        })
      })]
    })]
  }, element._key);
};
var useIsomorphicEffect2 = typeof window === "undefined" ? import_react49.useEffect : import_react49.useLayoutEffect;
function useForwardedRef2(ref) {
  const innerRef = (0, import_react49.useRef)(null);
  useIsomorphicEffect2(() => {
    if (!ref)
      return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
var debug2 = debugWithName("component:Editable");
var PLACEHOLDER_STYLE = {
  opacity: 0.5,
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none",
  left: 0,
  right: 0
};
var EMPTY_DECORATORS = [];
var PortableTextEditable = (0, import_react49.forwardRef)(function PortableTextEditable2(props2, forwardedRef) {
  const {
    hotkeys,
    onBlur,
    onFocus,
    onBeforeInput,
    onPaste,
    onCopy,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator: renderDecorator2,
    renderListItem: renderListItem2,
    renderPlaceholder,
    renderStyle: renderStyle2,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props2;
  const portableTextEditor = usePortableTextEditor();
  const readOnly = usePortableTextEditorReadOnlyStatus();
  const keyGenerator = usePortableTextEditorKeyGenerator();
  const ref = useForwardedRef2(forwardedRef);
  const [editableElement, setEditableElement] = (0, import_react49.useState)(null);
  const [hasInvalidValue, setHasInvalidValue] = (0, import_react49.useState)(false);
  const {
    change$,
    schemaTypes
  } = portableTextEditor;
  const slateEditor = useSlate();
  const blockTypeName = schemaTypes.block.name;
  const withInsertData = (0, import_react49.useMemo)(() => createWithInsertData(change$, schemaTypes, keyGenerator), [change$, keyGenerator, schemaTypes]);
  const withHotKeys = (0, import_react49.useMemo)(() => createWithHotkeys(schemaTypes, keyGenerator, portableTextEditor, hotkeys), [hotkeys, keyGenerator, portableTextEditor, schemaTypes]);
  (0, import_react49.useMemo)(() => {
    if (readOnly) {
      debug2("Editable is in read only mode");
      return withInsertData(slateEditor);
    }
    debug2("Editable is in edit mode");
    return withInsertData(withHotKeys(slateEditor));
  }, [readOnly, slateEditor, withHotKeys, withInsertData]);
  const renderElement = (0, import_react49.useCallback)((eProps) => (0, import_jsx_runtime5.jsx)(Element3, {
    ...eProps,
    readOnly,
    renderBlock,
    renderChild,
    renderListItem: renderListItem2,
    renderStyle: renderStyle2,
    schemaTypes,
    spellCheck
  }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem2, renderStyle2]);
  const renderLeaf = (0, import_react49.useCallback)((lProps) => {
    const rendered = (0, import_jsx_runtime5.jsx)(Leaf, {
      ...lProps,
      schemaTypes,
      renderAnnotation,
      renderChild,
      renderDecorator: renderDecorator2,
      readOnly
    });
    if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === "") {
      return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, {
        children: [(0, import_jsx_runtime5.jsx)("span", {
          style: PLACEHOLDER_STYLE,
          contentEditable: false,
          children: renderPlaceholder()
        }), rendered]
      });
    }
    return rendered;
  }, [readOnly, renderAnnotation, renderChild, renderDecorator2, renderPlaceholder, schemaTypes]);
  const restoreSelectionFromProps = (0, import_react49.useCallback)(() => {
    if (propsSelection) {
      debug2("Selection from props ".concat(JSON.stringify(propsSelection)));
      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));
      if (normalizedSelection !== null) {
        debug2("Normalized selection from props ".concat(JSON.stringify(normalizedSelection)));
        const slateRange = toSlateRange(normalizedSelection, slateEditor);
        if (slateRange) {
          Transforms.select(slateEditor, slateRange);
          if (!slateEditor.operations.some((o) => o.type === "set_selection")) {
            change$.next({
              type: "selection",
              selection: normalizedSelection
            });
          }
          slateEditor.onChange();
        }
      }
    }
  }, [propsSelection, slateEditor, blockTypeName, change$]);
  (0, import_react49.useEffect)(() => {
    debug2("Subscribing to editor changes$");
    const sub2 = change$.subscribe((next) => {
      switch (next.type) {
        case "ready":
          restoreSelectionFromProps();
          break;
        case "invalidValue":
          setHasInvalidValue(true);
          break;
        case "value":
          setHasInvalidValue(false);
          break;
      }
    });
    return () => {
      debug2("Unsubscribing to changes$");
      sub2.unsubscribe();
    };
  }, [change$, restoreSelectionFromProps]);
  (0, import_react49.useEffect)(() => {
    if (propsSelection && !hasInvalidValue) {
      restoreSelectionFromProps();
    }
  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);
  const handleCopy = (0, import_react49.useCallback)((event) => {
    if (onCopy) {
      const result = onCopy(event);
      if (result !== void 0) {
        event.preventDefault();
      }
    }
  }, [onCopy]);
  const handlePaste = (0, import_react49.useCallback)((event) => {
    event.preventDefault();
    if (!slateEditor.selection) {
      return;
    }
    if (!onPaste) {
      debug2("Pasting normally");
      slateEditor.insertData(event.clipboardData);
      return;
    }
    new Promise((resolve) => {
      const value = PortableTextEditor.getValue(portableTextEditor);
      const ptRange = toPortableTextRange(value, slateEditor.selection, schemaTypes);
      const path2 = (ptRange == null ? void 0 : ptRange.focus.path) || [];
      resolve(onPaste({
        event,
        value,
        path: path2,
        schemaTypes
      }));
    }).then((result) => {
      debug2("Custom paste function from client resolved", result);
      change$.next({
        type: "loading",
        isLoading: true
      });
      if (!result || !result.insert) {
        debug2("No result from custom paste handler, pasting normally");
        slateEditor.insertData(event.clipboardData);
        return;
      }
      if (result && result.insert) {
        slateEditor.insertFragment(toSlateValue(result.insert, {
          schemaTypes
        }));
        change$.next({
          type: "loading",
          isLoading: false
        });
        return;
      }
      console.warn("Your onPaste function returned something unexpected:", result);
    }).catch((error2) => {
      change$.next({
        type: "loading",
        isLoading: false
      });
      console.error(error2);
      return error2;
    });
  }, [change$, onPaste, portableTextEditor, schemaTypes, slateEditor]);
  const handleOnFocus = (0, import_react49.useCallback)((event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (!event.isDefaultPrevented()) {
      const selection = PortableTextEditor.getSelection(portableTextEditor);
      if (selection === null) {
        Transforms.select(slateEditor, Editor.start(slateEditor, []));
        slateEditor.onChange();
      }
      change$.next({
        type: "focus",
        event
      });
      const newSelection = PortableTextEditor.getSelection(portableTextEditor);
      if (selection === newSelection) {
        change$.next({
          type: "selection",
          selection
        });
      }
    }
  }, [onFocus, portableTextEditor, change$, slateEditor]);
  const handleOnBlur = (0, import_react49.useCallback)((event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (!event.isPropagationStopped()) {
      change$.next({
        type: "blur",
        event
      });
    }
  }, [change$, onBlur]);
  const handleOnBeforeInput = (0, import_react49.useCallback)((event) => {
    if (onBeforeInput) {
      onBeforeInput(event);
    }
  }, [onBeforeInput]);
  const validateSelection = (0, import_react49.useCallback)(() => {
    if (!slateEditor.selection) {
      return;
    }
    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor);
    const {
      activeElement
    } = root;
    if (ref.current !== activeElement) {
      return;
    }
    const window2 = ReactEditor.getWindow(slateEditor);
    const domSelection = window2.getSelection();
    if (!domSelection) {
      return;
    }
    const existingDOMRange = domSelection.getRangeAt(0);
    try {
      const newDOMRange = ReactEditor.toDOMRange(slateEditor, slateEditor.selection);
      if (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) {
        debug2("DOM range out of sync, validating selection");
        domSelection == null ? void 0 : domSelection.removeAllRanges();
        domSelection.addRange(newDOMRange);
      }
    } catch (error2) {
      debug2("Could not resolve selection, selecting top document");
      Transforms.deselect(slateEditor);
      if (slateEditor.children.length > 0) {
        Transforms.select(slateEditor, [0, 0]);
      }
      slateEditor.onChange();
    }
  }, [ref, slateEditor]);
  (0, import_react49.useEffect)(() => {
    if (editableElement) {
      const mutationObserver = new MutationObserver(validateSelection);
      mutationObserver.observe(editableElement, {
        attributeOldValue: false,
        attributes: false,
        characterData: false,
        childList: true,
        subtree: true
      });
      return () => {
        mutationObserver.disconnect();
      };
    }
    return void 0;
  }, [validateSelection, editableElement]);
  const handleKeyDown = (0, import_react49.useCallback)((event) => {
    if (props2.onKeyDown) {
      props2.onKeyDown(event);
    }
    if (!event.isDefaultPrevented()) {
      slateEditor.pteWithHotKeys(event);
    }
  }, [props2, slateEditor]);
  const scrollSelectionIntoViewToSlate = (0, import_react49.useMemo)(() => {
    if (scrollSelectionIntoView === void 0) {
      return void 0;
    }
    if (scrollSelectionIntoView === null) {
      return import_noop15.default;
    }
    return (editor2, domRange) => {
      scrollSelectionIntoView(portableTextEditor, domRange);
    };
  }, [portableTextEditor, scrollSelectionIntoView]);
  const decorate = (0, import_react49.useCallback)(() => {
    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {
      return [{
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        },
        placeholder: true
      }];
    }
    return EMPTY_DECORATORS;
  }, [schemaTypes, slateEditor]);
  (0, import_react49.useEffect)(() => {
    ref.current = ReactEditor.toDOMNode(slateEditor, slateEditor);
    setEditableElement(ref.current);
  }, [slateEditor, ref]);
  if (!portableTextEditor) {
    return null;
  }
  return hasInvalidValue ? null : (0, import_jsx_runtime5.jsx)(Editable, {
    ...restProps,
    autoFocus: false,
    className: restProps.className || "pt-editable",
    decorate,
    onBlur: handleOnBlur,
    onCopy: handleCopy,
    onDOMBeforeInput: handleOnBeforeInput,
    onFocus: handleOnFocus,
    onKeyDown: handleKeyDown,
    onPaste: handlePaste,
    readOnly,
    renderPlaceholder: void 0,
    renderElement,
    renderLeaf,
    scrollSelectionIntoView: scrollSelectionIntoViewToSlate
  });
});

// node_modules/sanity/lib/index.esm.js
var import_orderBy = __toESM(require_orderBy());

// node_modules/@sanity/diff-match-patch/dist/index.js
function isHighSurrogate2(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate2(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 56320 && charCode <= 57343;
}
function cloneDiff2(diff4) {
  const [type, patch2] = diff4;
  return [type, patch2];
}
function getCommonOverlap2(textA, textB) {
  let text1 = textA;
  let text2 = textB;
  const text1Length = text1.length;
  const text2Length = text2.length;
  if (text1Length === 0 || text2Length === 0) {
    return 0;
  }
  if (text1Length > text2Length) {
    text1 = text1.substring(text1Length - text2Length);
  } else if (text1Length < text2Length) {
    text2 = text2.substring(0, text1Length);
  }
  const textLength = Math.min(text1Length, text2Length);
  if (text1 === text2) {
    return textLength;
  }
  let best = 0;
  let length2 = 1;
  for (let found = 0; found !== -1; ) {
    const pattern = text1.substring(textLength - length2);
    found = text2.indexOf(pattern);
    if (found === -1) {
      return best;
    }
    length2 += found;
    if (found === 0 || text1.substring(textLength - length2) === text2.substring(0, length2)) {
      best = length2;
      length2++;
    }
  }
  return best;
}
function getCommonPrefix2(text1, text2) {
  if (!text1 || !text2 || text1[0] !== text2[0]) {
    return 0;
  }
  let pointerMin = 0;
  let pointerMax = Math.min(text1.length, text2.length);
  let pointerMid = pointerMax;
  let pointerStart = 0;
  while (pointerMin < pointerMid) {
    if (text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid)) {
      pointerMin = pointerMid;
      pointerStart = pointerMin;
    } else {
      pointerMax = pointerMid;
    }
    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  }
  return pointerMid;
}
function getCommonSuffix2(text1, text2) {
  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) {
    return 0;
  }
  let pointerMin = 0;
  let pointerMax = Math.min(text1.length, text2.length);
  let pointerMid = pointerMax;
  let pointerEnd = 0;
  while (pointerMin < pointerMid) {
    if (text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd)) {
      pointerMin = pointerMid;
      pointerEnd = pointerMin;
    } else {
      pointerMax = pointerMid;
    }
    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  }
  return pointerMid;
}
function cleanupSemantic2(rawDiffs) {
  let diffs = rawDiffs.map((diff4) => cloneDiff2(diff4));
  let hasChanges = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let lengthInsertions1 = 0;
  let lengthDeletions1 = 0;
  let lengthInsertions2 = 0;
  let lengthDeletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL2) {
      equalities[equalitiesLength++] = pointer;
      lengthInsertions1 = lengthInsertions2;
      lengthDeletions1 = lengthDeletions2;
      lengthInsertions2 = 0;
      lengthDeletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT2) {
        lengthInsertions2 += diffs[pointer][1].length;
      } else {
        lengthDeletions2 += diffs[pointer][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE2, lastEquality]);
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT2;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        lengthInsertions1 = 0;
        lengthDeletions1 = 0;
        lengthInsertions2 = 0;
        lengthDeletions2 = 0;
        lastEquality = null;
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge2(diffs);
  }
  diffs = cleanupSemanticLossless2(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE2 && diffs[pointer][0] === DIFF_INSERT2) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlapLength1 = getCommonOverlap2(deletion, insertion);
      const overlapLength2 = getCommonOverlap2(insertion, deletion);
      if (overlapLength1 >= overlapLength2) {
        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, [DIFF_EQUAL2, insertion.substring(0, overlapLength1)]);
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
          diffs[pointer + 1][1] = insertion.substring(overlapLength1);
          pointer++;
        }
      } else if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
        diffs.splice(pointer, 0, [DIFF_EQUAL2, deletion.substring(0, overlapLength2)]);
        diffs[pointer - 1][0] = DIFF_INSERT2;
        diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
        diffs[pointer + 1][0] = DIFF_DELETE2;
        diffs[pointer + 1][1] = deletion.substring(overlapLength2);
        pointer++;
      }
      pointer++;
    }
    pointer++;
  }
  return diffs;
}
var nonAlphaNumericRegex2 = /[^a-zA-Z0-9]/;
var whitespaceRegex2 = /\s/;
var linebreakRegex2 = /[\r\n]/;
var blanklineEndRegex2 = /\n\r?\n$/;
var blanklineStartRegex2 = /^\r?\n\r?\n/;
function cleanupSemanticLossless2(rawDiffs) {
  const diffs = rawDiffs.map((diff4) => cloneDiff2(diff4));
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex2);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex2);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex2);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex2);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex2);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex2);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex2);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex2);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL2 && diffs[pointer + 1][0] === DIFF_EQUAL2) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = getCommonSuffix2(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score2 = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score2 >= bestScore) {
          bestScore = score2;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
  return diffs;
}
function cleanupMerge2(rawDiffs) {
  let diffs = rawDiffs.map((diff4) => cloneDiff2(diff4));
  diffs.push([DIFF_EQUAL2, ""]);
  let pointer = 0;
  let countDelete = 0;
  let countInsert = 0;
  let textDelete = "";
  let textInsert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT2:
        countInsert++;
        textInsert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE2:
        countDelete++;
        textDelete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL2:
        if (countDelete + countInsert > 1) {
          if (countDelete !== 0 && countInsert !== 0) {
            commonlength = getCommonPrefix2(textInsert, textDelete);
            if (commonlength !== 0) {
              if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL2) {
                diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL2, textInsert.substring(0, commonlength)]);
                pointer++;
              }
              textInsert = textInsert.substring(commonlength);
              textDelete = textDelete.substring(commonlength);
            }
            commonlength = getCommonSuffix2(textInsert, textDelete);
            if (commonlength !== 0) {
              diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
              textInsert = textInsert.substring(0, textInsert.length - commonlength);
              textDelete = textDelete.substring(0, textDelete.length - commonlength);
            }
          }
          pointer -= countDelete + countInsert;
          diffs.splice(pointer, countDelete + countInsert);
          if (textDelete.length) {
            diffs.splice(pointer, 0, [DIFF_DELETE2, textDelete]);
            pointer++;
          }
          if (textInsert.length) {
            diffs.splice(pointer, 0, [DIFF_INSERT2, textInsert]);
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL2) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        countInsert = 0;
        countDelete = 0;
        textDelete = "";
        textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation");
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  let hasChanges = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL2 && diffs[pointer + 1][0] === DIFF_EQUAL2) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        hasChanges = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge2(diffs);
  }
  return diffs;
}
function trueCount2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency2(rawDiffs) {
  let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  let diffs = rawDiffs.map((diff4) => cloneDiff2(diff4));
  let hasChanges = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let preIns = false;
  let preDel = false;
  let postIns = false;
  let postDel = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL2) {
      if (diffs[pointer][1].length < editCost && (postIns || postDel)) {
        equalities[equalitiesLength++] = pointer;
        preIns = postIns;
        preDel = postDel;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      postIns = false;
      postDel = false;
    } else {
      if (diffs[pointer][0] === DIFF_DELETE2) {
        postDel = true;
      } else {
        postIns = true;
      }
      if (lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount2(preIns, preDel, postIns, postDel) === 3)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE2, lastEquality]);
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT2;
        equalitiesLength--;
        lastEquality = null;
        if (preIns && preDel) {
          postIns = true;
          postDel = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          postIns = false;
          postDel = false;
        }
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge2(diffs);
  }
  return diffs;
}
function bisect2(text1, text2, deadline) {
  const text1Length = text1.length;
  const text2Length = text2.length;
  const maxD = Math.ceil((text1Length + text2Length) / 2);
  const vOffset = maxD;
  const vLength = 2 * maxD;
  const v1 = new Array(vLength);
  const v2 = new Array(vLength);
  for (let x = 0; x < vLength; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[vOffset + 1] = 0;
  v2[vOffset + 1] = 0;
  const delta2 = text1Length - text2Length;
  const front = delta2 % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < maxD; d++) {
    if (Date.now() > deadline) {
      break;
    }
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1Offset = vOffset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
        x1 = v1[k1Offset + 1];
      } else {
        x1 = v1[k1Offset - 1] + 1;
      }
      let y1 = x1 - k1;
      while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1Offset] = x1;
      if (x1 > text1Length) {
        k1end += 2;
      } else if (y1 > text2Length) {
        k1start += 2;
      } else if (front) {
        const k2Offset = vOffset + delta2 - k1;
        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
          const x2 = text1Length - v2[k2Offset];
          if (x1 >= x2) {
            return bisectSplit2(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2Offset = vOffset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
        x2 = v2[k2Offset + 1];
      } else {
        x2 = v2[k2Offset - 1] + 1;
      }
      let y2 = x2 - k2;
      while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2Offset] = x2;
      if (x2 > text1Length) {
        k2end += 2;
      } else if (y2 > text2Length) {
        k2start += 2;
      } else if (!front) {
        const k1Offset = vOffset + delta2 - k2;
        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
          const x1 = v1[k1Offset];
          const y1 = vOffset + x1 - k1Offset;
          x2 = text1Length - x2;
          if (x1 >= x2) {
            return bisectSplit2(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [[DIFF_DELETE2, text1], [DIFF_INSERT2, text2]];
}
function bisectSplit2(text1, text2, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = doDiff2(text1a, text2a, {
    checkLines: false,
    deadline
  });
  const diffsb = doDiff2(text1b, text2b, {
    checkLines: false,
    deadline
  });
  return diffs.concat(diffsb);
}
function findHalfMatch2(text1, text2) {
  let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (timeout <= 0) {
    return null;
  }
  const longText = text1.length > text2.length ? text1 : text2;
  const shortText = text1.length > text2.length ? text2 : text1;
  if (longText.length < 4 || shortText.length * 2 < longText.length) {
    return null;
  }
  const halfMatch1 = halfMatchI2(longText, shortText, Math.ceil(longText.length / 4));
  const halfMatch2 = halfMatchI2(longText, shortText, Math.ceil(longText.length / 2));
  let halfMatch;
  if (halfMatch1 && halfMatch2) {
    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
  } else if (!halfMatch1 && !halfMatch2) {
    return null;
  } else if (!halfMatch2) {
    halfMatch = halfMatch1;
  } else if (!halfMatch1) {
    halfMatch = halfMatch2;
  }
  if (!halfMatch) {
    throw new Error("Unable to find a half match.");
  }
  let text1A;
  let text1B;
  let text2A;
  let text2B;
  if (text1.length > text2.length) {
    text1A = halfMatch[0];
    text1B = halfMatch[1];
    text2A = halfMatch[2];
    text2B = halfMatch[3];
  } else {
    text2A = halfMatch[0];
    text2B = halfMatch[1];
    text1A = halfMatch[2];
    text1B = halfMatch[3];
  }
  const midCommon = halfMatch[4];
  return [text1A, text1B, text2A, text2B, midCommon];
}
function halfMatchI2(longText, shortText, i) {
  const seed = longText.slice(i, i + Math.floor(longText.length / 4));
  let j = -1;
  let bestCommon = "";
  let bestLongTextA;
  let bestLongTextB;
  let bestShortTextA;
  let bestShortTextB;
  while ((j = shortText.indexOf(seed, j + 1)) !== -1) {
    const prefixLength = getCommonPrefix2(longText.slice(i), shortText.slice(j));
    const suffixLength = getCommonSuffix2(longText.slice(0, i), shortText.slice(0, j));
    if (bestCommon.length < suffixLength + prefixLength) {
      bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength);
      bestLongTextA = longText.slice(0, i - suffixLength);
      bestLongTextB = longText.slice(i + prefixLength);
      bestShortTextA = shortText.slice(0, j - suffixLength);
      bestShortTextB = shortText.slice(j + prefixLength);
    }
  }
  if (bestCommon.length * 2 >= longText.length) {
    return [bestLongTextA || "", bestLongTextB || "", bestShortTextA || "", bestShortTextB || "", bestCommon || ""];
  }
  return null;
}
function charsToLines2(diffs, lineArray) {
  for (let x = 0; x < diffs.length; x++) {
    const chars2 = diffs[x][1];
    const text = [];
    for (let y = 0; y < chars2.length; y++) {
      text[y] = lineArray[chars2.charCodeAt(y)];
    }
    diffs[x][1] = text.join("");
  }
}
function linesToChars2(textA, textB) {
  const lineArray = [];
  const lineHash = {};
  lineArray[0] = "";
  function diffLinesToMunge(text) {
    let chars3 = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf("\n", lineStart);
      if (lineEnd === -1) {
        lineEnd = text.length - 1;
      }
      let line = text.slice(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
        chars3 += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text.slice(lineStart);
          lineEnd = text.length;
        }
        chars3 += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars3;
  }
  let maxLines = 4e4;
  const chars1 = diffLinesToMunge(textA);
  maxLines = 65535;
  const chars2 = diffLinesToMunge(textB);
  return {
    chars1,
    chars2,
    lineArray
  };
}
function doLineModeDiff2(textA, textB, opts) {
  let text1 = textA;
  let text2 = textB;
  const a = linesToChars2(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  let diffs = doDiff2(text1, text2, {
    checkLines: false,
    deadline: opts.deadline
  });
  charsToLines2(diffs, linearray);
  diffs = cleanupSemantic2(diffs);
  diffs.push([DIFF_EQUAL2, ""]);
  let pointer = 0;
  let countDelete = 0;
  let countInsert = 0;
  let textDelete = "";
  let textInsert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT2:
        countInsert++;
        textInsert += diffs[pointer][1];
        break;
      case DIFF_DELETE2:
        countDelete++;
        textDelete += diffs[pointer][1];
        break;
      case DIFF_EQUAL2:
        if (countDelete >= 1 && countInsert >= 1) {
          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
          pointer = pointer - countDelete - countInsert;
          const aa = doDiff2(textDelete, textInsert, {
            checkLines: false,
            deadline: opts.deadline
          });
          for (let j = aa.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, aa[j]);
          }
          pointer += aa.length;
        }
        countInsert = 0;
        countDelete = 0;
        textDelete = "";
        textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function computeDiff2(text1, text2, opts) {
  let diffs;
  if (!text1) {
    return [[DIFF_INSERT2, text2]];
  }
  if (!text2) {
    return [[DIFF_DELETE2, text1]];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [[DIFF_INSERT2, longtext.substring(0, i)], [DIFF_EQUAL2, shorttext], [DIFF_INSERT2, longtext.substring(i + shorttext.length)]];
    if (text1.length > text2.length) {
      diffs[0][0] = DIFF_DELETE2;
      diffs[2][0] = DIFF_DELETE2;
    }
    return diffs;
  }
  if (shorttext.length === 1) {
    return [[DIFF_DELETE2, text1], [DIFF_INSERT2, text2]];
  }
  const halfMatch = findHalfMatch2(text1, text2);
  if (halfMatch) {
    const text1A = halfMatch[0];
    const text1B = halfMatch[1];
    const text2A = halfMatch[2];
    const text2B = halfMatch[3];
    const midCommon = halfMatch[4];
    const diffsA = doDiff2(text1A, text2A, opts);
    const diffsB = doDiff2(text1B, text2B, opts);
    return diffsA.concat([[DIFF_EQUAL2, midCommon]], diffsB);
  }
  if (opts.checkLines && text1.length > 100 && text2.length > 100) {
    return doLineModeDiff2(text1, text2, opts);
  }
  return bisect2(text1, text2, opts.deadline);
}
var DIFF_DELETE2 = -1;
var DIFF_INSERT2 = 1;
var DIFF_EQUAL2 = 0;
function diff2(textA, textB, opts) {
  if (textA === null || textB === null) {
    throw new Error("Null input. (diff)");
  }
  const diffs = doDiff2(textA, textB, createInternalOpts2(opts || {}));
  adjustDiffForSurrogatePairs2(diffs);
  return diffs;
}
function doDiff2(textA, textB, options) {
  let text1 = textA;
  let text2 = textB;
  if (text1 === text2) {
    return text1 ? [[DIFF_EQUAL2, text1]] : [];
  }
  let commonlength = getCommonPrefix2(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = getCommonSuffix2(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  let diffs = computeDiff2(text1, text2, options);
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL2, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL2, commonsuffix]);
  }
  diffs = cleanupMerge2(diffs);
  return diffs;
}
function createDeadLine2(timeout) {
  let t3 = 1;
  if (typeof timeout !== "undefined") {
    t3 = timeout <= 0 ? Number.MAX_VALUE : timeout;
  }
  return Date.now() + t3 * 1e3;
}
function createInternalOpts2(opts) {
  return {
    checkLines: true,
    deadline: createDeadLine2(opts.timeout || 1),
    ...opts
  };
}
function combineChar2(data, char, dir2) {
  return dir2 === 1 ? data + char : char + data;
}
function splitChar2(data, dir2) {
  return dir2 === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];
}
function hasSharedChar2(diffs, i, j, dir2) {
  return dir2 === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar2(diffs, i, dir2) {
  const inv = dir2 === 1 ? -1 : 1;
  let insertIdx = null;
  let deleteIdx = null;
  let j = i + dir2;
  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir2) {
    const [op, text2] = diffs[j];
    if (text2.length === 0) {
      continue;
    }
    if (op === DIFF_INSERT2) {
      if (insertIdx === null) {
        insertIdx = j;
      }
      continue;
    } else if (op === DIFF_DELETE2) {
      if (deleteIdx === null) {
        deleteIdx = j;
      }
      continue;
    } else if (op === DIFF_EQUAL2) {
      if (insertIdx === null && deleteIdx === null) {
        const [rest, char2] = splitChar2(diffs[i][1], dir2);
        diffs[i][1] = rest;
        diffs[j][1] = combineChar2(diffs[j][1], char2, inv);
        return;
      }
      break;
    }
  }
  if (insertIdx !== null && deleteIdx !== null && hasSharedChar2(diffs, insertIdx, deleteIdx, dir2)) {
    const [insertText, insertChar] = splitChar2(diffs[insertIdx][1], inv);
    const [deleteText] = splitChar2(diffs[deleteIdx][1], inv);
    diffs[insertIdx][1] = insertText;
    diffs[deleteIdx][1] = deleteText;
    diffs[i][1] = combineChar2(diffs[i][1], insertChar, dir2);
    return;
  }
  const [text, char] = splitChar2(diffs[i][1], dir2);
  diffs[i][1] = text;
  if (insertIdx === null) {
    diffs.splice(j, 0, [DIFF_INSERT2, char]);
    if (deleteIdx !== null && deleteIdx >= j)
      deleteIdx++;
  } else {
    diffs[insertIdx][1] = combineChar2(diffs[insertIdx][1], char, inv);
  }
  if (deleteIdx === null) {
    diffs.splice(j, 0, [DIFF_DELETE2, char]);
  } else {
    diffs[deleteIdx][1] = combineChar2(diffs[deleteIdx][1], char, inv);
  }
}
function adjustDiffForSurrogatePairs2(diffs) {
  for (let i = 0; i < diffs.length; i++) {
    const [diffType, diffText] = diffs[i];
    if (diffText.length === 0)
      continue;
    const firstChar = diffText[0];
    const lastChar = diffText[diffText.length - 1];
    if (isHighSurrogate2(lastChar) && diffType === DIFF_EQUAL2) {
      deisolateChar2(diffs, i, 1);
    }
    if (isLowSurrogate2(firstChar) && diffType === DIFF_EQUAL2) {
      deisolateChar2(diffs, i, -1);
    }
  }
  for (let i = 0; i < diffs.length; i++) {
    if (diffs[i][1].length === 0) {
      diffs.splice(i, 1);
    }
  }
}
var DEFAULT_OPTIONS3 = {
  /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */
  threshold: 0.5,
  /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */
  distance: 1e3
};
function applyDefaults2(options) {
  return {
    ...DEFAULT_OPTIONS3,
    ...options
  };
}
var MAX_BITS$12 = 32;
function bitap2(text, pattern, loc) {
  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (pattern.length > MAX_BITS$12) {
    throw new Error("Pattern too long for this browser.");
  }
  const options = applyDefaults2(opts);
  const s = getAlphabetFromPattern2(pattern);
  function getBitapScore(e2, x) {
    const accuracy = e2 / pattern.length;
    const proximity = Math.abs(loc - x);
    if (!options.distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / options.distance;
  }
  let scoreThreshold = options.threshold;
  let bestLoc = text.indexOf(pattern, loc);
  if (bestLoc !== -1) {
    scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold);
    bestLoc = text.lastIndexOf(pattern, loc + pattern.length);
    if (bestLoc !== -1) {
      scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold);
    }
  }
  const matchmask = 1 << pattern.length - 1;
  bestLoc = -1;
  let binMin;
  let binMid;
  let binMax = pattern.length + text.length;
  let lastRd = [];
  for (let d = 0; d < pattern.length; d++) {
    binMin = 0;
    binMid = binMax;
    while (binMin < binMid) {
      if (getBitapScore(d, loc + binMid) <= scoreThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, loc - binMid + 1);
    const finish = Math.min(loc + binMid, text.length) + pattern.length;
    const rd = new Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (let j = finish; j >= start; j--) {
      const charMatch = s[text.charAt(j - 1)];
      if (d === 0) {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
      } else {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1];
      }
      if (rd[j] & matchmask) {
        const score2 = getBitapScore(d, j - 1);
        if (score2 <= scoreThreshold) {
          scoreThreshold = score2;
          bestLoc = j - 1;
          if (bestLoc > loc) {
            start = Math.max(1, 2 * loc - bestLoc);
          } else {
            break;
          }
        }
      }
    }
    if (getBitapScore(d + 1, loc) > scoreThreshold) {
      break;
    }
    lastRd = rd;
  }
  return bestLoc;
}
function getAlphabetFromPattern2(pattern) {
  const s = {};
  for (let i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (let i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  }
  return s;
}
function match2(text, pattern, searchLocation) {
  if (text === null || pattern === null || searchLocation === null) {
    throw new Error("Null input. (match())");
  }
  const loc = Math.max(0, Math.min(searchLocation, text.length));
  if (text === pattern) {
    return 0;
  } else if (!text.length) {
    return -1;
  } else if (text.substring(loc, loc + pattern.length) === pattern) {
    return loc;
  }
  return bitap2(text, pattern, loc);
}
function createPatchObject2(start1, start2) {
  return {
    diffs: [],
    start1,
    start2,
    utf8Start1: start1,
    utf8Start2: start2,
    length1: 0,
    length2: 0,
    utf8Length1: 0,
    utf8Length2: 0
  };
}
function diffText12(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT2) {
      text[x] = diffs[x][1];
    }
  }
  return text.join("");
}
function diffText22(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE2) {
      text[x] = diffs[x][1];
    }
  }
  return text.join("");
}
function countUtf8Bytes2(str) {
  let bytes = 0;
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    if (typeof codePoint === "undefined") {
      throw new Error("Failed to get codepoint");
    }
    bytes += utf8len2(codePoint);
  }
  return bytes;
}
function adjustIndiciesToUcs22(patches, base) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let byteOffset = 0;
  let idx = 0;
  function advanceTo(target) {
    for (; byteOffset < target; ) {
      const codePoint = base.codePointAt(idx);
      if (typeof codePoint === "undefined") {
        return idx;
      }
      byteOffset += utf8len2(codePoint);
      if (codePoint > 65535) {
        idx += 2;
      } else {
        idx += 1;
      }
    }
    if (!options.allowExceedingIndices && byteOffset !== target) {
      throw new Error("Failed to determine byte offset");
    }
    return idx;
  }
  const adjusted = [];
  for (const patch2 of patches) {
    adjusted.push({
      diffs: patch2.diffs.map((diff4) => cloneDiff2(diff4)),
      start1: advanceTo(patch2.start1),
      start2: advanceTo(patch2.start2),
      utf8Start1: patch2.utf8Start1,
      utf8Start2: patch2.utf8Start2,
      length1: patch2.length1,
      length2: patch2.length2,
      utf8Length1: patch2.utf8Length1,
      utf8Length2: patch2.utf8Length2
    });
  }
  return adjusted;
}
function utf8len2(codePoint) {
  if (codePoint <= 127)
    return 1;
  if (codePoint <= 2047)
    return 2;
  if (codePoint <= 65535)
    return 3;
  return 4;
}
var MAX_BITS2 = 32;
var DEFAULT_MARGIN2 = 4;
var DEFAULT_OPTS2 = {
  margin: 4
};
function getDefaultOpts2() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    ...DEFAULT_OPTS2,
    ...opts
  };
}
function make2(a, b, options) {
  if (typeof a === "string" && typeof b === "string") {
    let diffs = diff2(a, b, {
      checkLines: true
    });
    if (diffs.length > 2) {
      diffs = cleanupSemantic2(diffs);
      diffs = cleanupEfficiency2(diffs);
    }
    return _make2(a, diffs, getDefaultOpts2(options));
  }
  if (a && Array.isArray(a) && typeof b === "undefined") {
    return _make2(diffText12(a), a, getDefaultOpts2(options));
  }
  if (typeof a === "string" && b && Array.isArray(b)) {
    return _make2(a, b, getDefaultOpts2(options));
  }
  throw new Error("Unknown call format to make()");
}
function _make2(textA, diffs, options) {
  if (diffs.length === 0) {
    return [];
  }
  const patches = [];
  let patch2 = createPatchObject2(0, 0);
  let patchDiffLength = 0;
  let charCount1 = 0;
  let charCount2 = 0;
  let utf8Count1 = 0;
  let utf8Count2 = 0;
  let prepatchText = textA;
  let postpatchText = textA;
  for (let x = 0; x < diffs.length; x++) {
    const currentDiff = diffs[x];
    const [diffType, diffText] = currentDiff;
    const diffTextLength = diffText.length;
    const diffByteLength = countUtf8Bytes2(diffText);
    if (!patchDiffLength && diffType !== DIFF_EQUAL2) {
      patch2.start1 = charCount1;
      patch2.start2 = charCount2;
      patch2.utf8Start1 = utf8Count1;
      patch2.utf8Start2 = utf8Count2;
    }
    switch (diffType) {
      case DIFF_INSERT2:
        patch2.diffs[patchDiffLength++] = currentDiff;
        patch2.length2 += diffTextLength;
        patch2.utf8Length2 += diffByteLength;
        postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
        break;
      case DIFF_DELETE2:
        patch2.length1 += diffTextLength;
        patch2.utf8Length1 += diffByteLength;
        patch2.diffs[patchDiffLength++] = currentDiff;
        postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
        break;
      case DIFF_EQUAL2:
        if (diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1) {
          patch2.diffs[patchDiffLength++] = currentDiff;
          patch2.length1 += diffTextLength;
          patch2.length2 += diffTextLength;
          patch2.utf8Length1 += diffByteLength;
          patch2.utf8Length2 += diffByteLength;
        } else if (diffTextLength >= 2 * options.margin) {
          if (patchDiffLength) {
            addContext2(patch2, prepatchText, options);
            patches.push(patch2);
            patch2 = createPatchObject2(-1, -1);
            patchDiffLength = 0;
            prepatchText = postpatchText;
            charCount1 = charCount2;
            utf8Count1 = utf8Count2;
          }
        }
        break;
      default:
        throw new Error("Unknown diff type");
    }
    if (diffType !== DIFF_INSERT2) {
      charCount1 += diffTextLength;
      utf8Count1 += diffByteLength;
    }
    if (diffType !== DIFF_DELETE2) {
      charCount2 += diffTextLength;
      utf8Count2 += diffByteLength;
    }
  }
  if (patchDiffLength) {
    addContext2(patch2, prepatchText, options);
    patches.push(patch2);
  }
  return patches;
}
function addContext2(patch2, text, opts) {
  if (text.length === 0) {
    return;
  }
  let pattern = text.substring(patch2.start2, patch2.start2 + patch2.length1);
  let padding = 0;
  while (text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS2 - opts.margin - opts.margin) {
    padding += opts.margin;
    pattern = text.substring(patch2.start2 - padding, patch2.start2 + patch2.length1 + padding);
  }
  padding += opts.margin;
  let prefixStart = patch2.start2 - padding;
  if (prefixStart >= 1 && isLowSurrogate2(text[prefixStart])) {
    prefixStart--;
  }
  const prefix = text.substring(prefixStart, patch2.start2);
  if (prefix) {
    patch2.diffs.unshift([DIFF_EQUAL2, prefix]);
  }
  const prefixLength = prefix.length;
  const prefixUtf8Length = countUtf8Bytes2(prefix);
  let suffixEnd = patch2.start2 + patch2.length1 + padding;
  if (suffixEnd < text.length && isLowSurrogate2(text[suffixEnd])) {
    suffixEnd++;
  }
  const suffix = text.substring(patch2.start2 + patch2.length1, suffixEnd);
  if (suffix) {
    patch2.diffs.push([DIFF_EQUAL2, suffix]);
  }
  const suffixLength = suffix.length;
  const suffixUtf8Length = countUtf8Bytes2(suffix);
  patch2.start1 -= prefixLength;
  patch2.start2 -= prefixLength;
  patch2.utf8Start1 -= prefixUtf8Length;
  patch2.utf8Start2 -= prefixUtf8Length;
  patch2.length1 += prefixLength + suffixLength;
  patch2.length2 += prefixLength + suffixLength;
  patch2.utf8Length1 += prefixUtf8Length + suffixUtf8Length;
  patch2.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
function levenshtein2(diffs) {
  let leven2 = 0;
  let insertions = 0;
  let deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0];
    const data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT2:
        insertions += data.length;
        break;
      case DIFF_DELETE2:
        deletions += data.length;
        break;
      case DIFF_EQUAL2:
        leven2 += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
  }
  leven2 += Math.max(insertions, deletions);
  return leven2;
}
function xIndex2(diffs, loc) {
  let chars1 = 0;
  let chars2 = 0;
  let lastChars1 = 0;
  let lastChars2 = 0;
  let x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT2) {
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE2) {
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {
      break;
    }
    lastChars1 = chars1;
    lastChars2 = chars2;
  }
  if (diffs.length !== x && diffs[x][0] === DIFF_DELETE2) {
    return lastChars2;
  }
  return lastChars2 + (loc - lastChars1);
}
function addPadding2(patches) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN2;
  const paddingLength = margin;
  let nullPadding = "";
  for (let x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }
  for (const p of patches) {
    p.start1 += paddingLength;
    p.start2 += paddingLength;
    p.utf8Start1 += paddingLength;
    p.utf8Start2 += paddingLength;
  }
  let patch2 = patches[0];
  let diffs = patch2.diffs;
  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL2) {
    diffs.unshift([DIFF_EQUAL2, nullPadding]);
    patch2.start1 -= paddingLength;
    patch2.start2 -= paddingLength;
    patch2.utf8Start1 -= paddingLength;
    patch2.utf8Start2 -= paddingLength;
    patch2.length1 += paddingLength;
    patch2.length2 += paddingLength;
    patch2.utf8Length1 += paddingLength;
    patch2.utf8Length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    const firstDiffLength = diffs[0][1].length;
    const extraLength = paddingLength - firstDiffLength;
    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1];
    patch2.start1 -= extraLength;
    patch2.start2 -= extraLength;
    patch2.utf8Start1 -= extraLength;
    patch2.utf8Start2 -= extraLength;
    patch2.length1 += extraLength;
    patch2.length2 += extraLength;
    patch2.utf8Length1 += extraLength;
    patch2.utf8Length2 += extraLength;
  }
  patch2 = patches[patches.length - 1];
  diffs = patch2.diffs;
  if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL2) {
    diffs.push([DIFF_EQUAL2, nullPadding]);
    patch2.length1 += paddingLength;
    patch2.length2 += paddingLength;
    patch2.utf8Length1 += paddingLength;
    patch2.utf8Length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch2.length1 += extraLength;
    patch2.length2 += extraLength;
    patch2.utf8Length1 += extraLength;
    patch2.utf8Length2 += extraLength;
  }
  return nullPadding;
}
function splitMax2(patches) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN2;
  const patchSize = MAX_BITS2;
  for (let x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patchSize) {
      continue;
    }
    const bigpatch = patches[x];
    patches.splice(x--, 1);
    let start1 = bigpatch.start1;
    let start2 = bigpatch.start2;
    let preContext = "";
    while (bigpatch.diffs.length !== 0) {
      const patch2 = createPatchObject2(start1 - preContext.length, start2 - preContext.length);
      let empty2 = true;
      if (preContext !== "") {
        const precontextByteCount = countUtf8Bytes2(preContext);
        patch2.length1 = preContext.length;
        patch2.utf8Length1 = precontextByteCount;
        patch2.length2 = preContext.length;
        patch2.utf8Length2 = precontextByteCount;
        patch2.diffs.push([DIFF_EQUAL2, preContext]);
      }
      while (bigpatch.diffs.length !== 0 && patch2.length1 < patchSize - margin) {
        const diffType = bigpatch.diffs[0][0];
        let diffText = bigpatch.diffs[0][1];
        let diffTextByteCount = countUtf8Bytes2(diffText);
        if (diffType === DIFF_INSERT2) {
          patch2.length2 += diffText.length;
          patch2.utf8Length2 += diffTextByteCount;
          start2 += diffText.length;
          const diff4 = bigpatch.diffs.shift();
          if (diff4) {
            patch2.diffs.push(diff4);
          }
          empty2 = false;
        } else if (diffType === DIFF_DELETE2 && patch2.diffs.length === 1 && patch2.diffs[0][0] === DIFF_EQUAL2 && diffText.length > 2 * patchSize) {
          patch2.length1 += diffText.length;
          patch2.utf8Length1 += diffTextByteCount;
          start1 += diffText.length;
          empty2 = false;
          patch2.diffs.push([diffType, diffText]);
          bigpatch.diffs.shift();
        } else {
          diffText = diffText.substring(0, patchSize - patch2.length1 - margin);
          diffTextByteCount = countUtf8Bytes2(diffText);
          patch2.length1 += diffText.length;
          patch2.utf8Length1 += diffTextByteCount;
          start1 += diffText.length;
          if (diffType === DIFF_EQUAL2) {
            patch2.length2 += diffText.length;
            patch2.utf8Length2 += diffTextByteCount;
            start2 += diffText.length;
          } else {
            empty2 = false;
          }
          patch2.diffs.push([diffType, diffText]);
          if (diffText === bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length);
          }
        }
      }
      preContext = diffText22(patch2.diffs);
      preContext = preContext.substring(preContext.length - margin);
      const postContext = diffText12(bigpatch.diffs).substring(0, margin);
      const postContextByteCount = countUtf8Bytes2(postContext);
      if (postContext !== "") {
        patch2.length1 += postContext.length;
        patch2.length2 += postContext.length;
        patch2.utf8Length1 += postContextByteCount;
        patch2.utf8Length2 += postContextByteCount;
        if (patch2.diffs.length !== 0 && patch2.diffs[patch2.diffs.length - 1][0] === DIFF_EQUAL2) {
          patch2.diffs[patch2.diffs.length - 1][1] += postContext;
        } else {
          patch2.diffs.push([DIFF_EQUAL2, postContext]);
        }
      }
      if (!empty2) {
        patches.splice(++x, 0, patch2);
      }
    }
  }
}
function apply2(patches, originalText) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof patches === "string") {
    throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
  }
  let text = originalText;
  if (patches.length === 0) {
    return [text, []];
  }
  const parsed = adjustIndiciesToUcs22(patches, text, {
    allowExceedingIndices: opts.allowExceedingIndices
  });
  const margin = opts.margin || DEFAULT_MARGIN2;
  const deleteThreshold = opts.deleteThreshold || 0.4;
  const nullPadding = addPadding2(parsed, margin);
  text = nullPadding + text + nullPadding;
  splitMax2(parsed, margin);
  let delta2 = 0;
  const results = [];
  for (let x = 0; x < parsed.length; x++) {
    const expectedLoc = parsed[x].start2 + delta2;
    const text1 = diffText12(parsed[x].diffs);
    let startLoc;
    let endLoc = -1;
    if (text1.length > MAX_BITS2) {
      startLoc = match2(text, text1.substring(0, MAX_BITS2), expectedLoc);
      if (startLoc !== -1) {
        endLoc = match2(text, text1.substring(text1.length - MAX_BITS2), expectedLoc + text1.length - MAX_BITS2);
        if (endLoc === -1 || startLoc >= endLoc) {
          startLoc = -1;
        }
      }
    } else {
      startLoc = match2(text, text1, expectedLoc);
    }
    if (startLoc === -1) {
      results[x] = false;
      delta2 -= parsed[x].length2 - parsed[x].length1;
    } else {
      results[x] = true;
      delta2 = startLoc - expectedLoc;
      let text2;
      if (endLoc === -1) {
        text2 = text.substring(startLoc, startLoc + text1.length);
      } else {
        text2 = text.substring(startLoc, endLoc + MAX_BITS2);
      }
      if (text1 === text2) {
        text = text.substring(0, startLoc) + diffText22(parsed[x].diffs) + text.substring(startLoc + text1.length);
      } else {
        let diffs = diff2(text1, text2, {
          checkLines: false
        });
        if (text1.length > MAX_BITS2 && levenshtein2(diffs) / text1.length > deleteThreshold) {
          results[x] = false;
        } else {
          diffs = cleanupSemanticLossless2(diffs);
          let index1 = 0;
          let index2 = 0;
          for (let y = 0; y < parsed[x].diffs.length; y++) {
            const mod = parsed[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL2) {
              index2 = xIndex2(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT2) {
              text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2);
            } else if (mod[0] === DIFF_DELETE2) {
              text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex2(diffs, index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE2) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
}
function stringify3(patches) {
  return patches.map(stringifyPatch2).join("");
}
function stringifyPatch2(patch2) {
  const {
    utf8Length1,
    utf8Length2,
    utf8Start1,
    utf8Start2,
    diffs
  } = patch2;
  let coords1;
  if (utf8Length1 === 0) {
    coords1 = "".concat(utf8Start1, ",0");
  } else if (utf8Length1 === 1) {
    coords1 = "".concat(utf8Start1 + 1);
  } else {
    coords1 = "".concat(utf8Start1 + 1, ",").concat(utf8Length1);
  }
  let coords2;
  if (utf8Length2 === 0) {
    coords2 = "".concat(utf8Start2, ",0");
  } else if (utf8Length2 === 1) {
    coords2 = "".concat(utf8Start2 + 1);
  } else {
    coords2 = "".concat(utf8Start2 + 1, ",").concat(utf8Length2);
  }
  const text = ["@@ -".concat(coords1, " +").concat(coords2, " @@\n")];
  let op;
  for (let x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT2:
        op = "+";
        break;
      case DIFF_DELETE2:
        op = "-";
        break;
      case DIFF_EQUAL2:
        op = " ";
        break;
      default:
        throw new Error("Unknown patch operation.");
    }
    text[x + 1] = "".concat(op + encodeURI(diffs[x][1]), "\n");
  }
  return text.join("").replace(/%20/g, " ");
}
var patchHeader2 = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse4(textline) {
  if (!textline) {
    return [];
  }
  const patches = [];
  const lines = textline.split("\n");
  let textPointer = 0;
  while (textPointer < lines.length) {
    const m2 = lines[textPointer].match(patchHeader2);
    if (!m2) {
      throw new Error("Invalid patch string: ".concat(lines[textPointer]));
    }
    const patch2 = createPatchObject2(toInt2(m2[1]), toInt2(m2[3]));
    patches.push(patch2);
    if (m2[2] === "") {
      patch2.start1--;
      patch2.utf8Start1--;
      patch2.length1 = 1;
      patch2.utf8Length1 = 1;
    } else if (m2[2] === "0") {
      patch2.length1 = 0;
      patch2.utf8Length1 = 0;
    } else {
      patch2.start1--;
      patch2.utf8Start1--;
      patch2.utf8Length1 = toInt2(m2[2]);
      patch2.length1 = patch2.utf8Length1;
    }
    if (m2[4] === "") {
      patch2.start2--;
      patch2.utf8Start2--;
      patch2.length2 = 1;
      patch2.utf8Length2 = 1;
    } else if (m2[4] === "0") {
      patch2.length2 = 0;
      patch2.utf8Length2 = 0;
    } else {
      patch2.start2--;
      patch2.utf8Start2--;
      patch2.utf8Length2 = toInt2(m2[4]);
      patch2.length2 = patch2.utf8Length2;
    }
    textPointer++;
    while (textPointer < lines.length) {
      const currentLine = lines[textPointer];
      const sign = currentLine.charAt(0);
      if (sign === "@") {
        break;
      }
      if (sign === "") {
        textPointer++;
        continue;
      }
      let line;
      try {
        line = decodeURI(currentLine.slice(1));
      } catch (ex) {
        throw new Error("Illegal escape in parse: ".concat(currentLine));
      }
      const utf8Diff = countUtf8Bytes2(line) - line.length;
      if (sign === "-") {
        patch2.diffs.push([DIFF_DELETE2, line]);
        patch2.length1 -= utf8Diff;
      } else if (sign === "+") {
        patch2.diffs.push([DIFF_INSERT2, line]);
        patch2.length2 -= utf8Diff;
      } else if (sign === " ") {
        patch2.diffs.push([DIFF_EQUAL2, line]);
        patch2.length1 -= utf8Diff;
        patch2.length2 -= utf8Diff;
      } else {
        throw new Error('Invalid patch mode "'.concat(sign, '" in: ').concat(line));
      }
      textPointer++;
    }
  }
  return patches;
}
function toInt2(num) {
  return parseInt(num, 10);
}

// node_modules/@sanity/util/lib/legacyDateFormat.esm.js
init_moment();
function format3(input, format22) {
  return moment_default(input).format(format22);
}
function parse5(dateString, format22) {
  const parsed = moment_default(dateString, format22, true);
  if (parsed.isValid()) {
    return {
      isValid: true,
      date: parsed.toDate()
    };
  }
  return {
    isValid: false,
    error: 'Invalid date. Must be on the format "'.concat(format22, '"')
  };
}

// node_modules/sanity/lib/index.esm.js
var import_xor = __toESM(require_xor());

// node_modules/sanity-diff-patch/dist/index.js
function pathToString(path2) {
  return path2.reduce((target, segment, i) => {
    if (Array.isArray(segment)) {
      return "".concat(target, "[").concat(segment.join(":"), "]");
    }
    if (isKeyedObject2(segment)) {
      return "".concat(target, '[_key=="').concat(segment._key, '"]');
    }
    if (typeof segment === "number") {
      return "".concat(target, "[").concat(segment, "]");
    } else if (typeof segment === "string" && /^\d+$/.test(segment)) {
      return "".concat(target, '["').concat(segment, '"]');
    }
    if (typeof segment === "string") {
      const separator = i === 0 ? "" : ".";
      return "".concat(target).concat(separator).concat(segment);
    }
    throw new Error('Unsupported path segment "'.concat(segment, '"'));
  }, "");
}
function isKeyedObject2(obj) {
  return typeof obj === "object" && typeof obj._key === "string";
}
var DiffError = class extends Error {
  constructor(message, path2, value) {
    const serializedPath = pathToString(path2);
    super("".concat(message, " (at '").concat(serializedPath, "')"));
    this.path = path2;
    this.serializedPath = serializedPath;
    this.value = value;
  }
};
var idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;
var propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
var propStartPattern = /^[a-z_]/i;
function validateProperty(property, value, path2) {
  if (!propStartPattern.test(property)) {
    throw new DiffError("Keys must start with a letter (a-z)", path2.concat(property), value);
  }
  if (!propPattern.test(property)) {
    throw new DiffError("Keys can only contain letters, numbers and underscores", path2.concat(property), value);
  }
  if (property === "_key" || property === "_ref" || property === "_type") {
    if (typeof value !== "string") {
      throw new DiffError("Keys must be strings", path2.concat(property), value);
    }
    if (!idPattern.test(value)) {
      throw new DiffError("Invalid key - use less exotic characters", path2.concat(property), value);
    }
  }
  return property;
}
var ignoredKeys = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
var defaultOptions3 = {
  hideWarnings: false,
  diffMatchPatch: {
    enabled: true,
    // Only use diff-match-patch if target string is longer than this threshold
    lengthThresholdAbsolute: 30,
    // Only use generated diff-match-patch if the patch length is less than or equal to
    // (targetString * relative). Example: A 100 character target with a relative factor
    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,
    // it will fall back to a regular `set` patch.
    lengthThresholdRelative: 1.2
  }
};
function mergeOptions(options) {
  return {
    ...defaultOptions3,
    ...options,
    diffMatchPatch: {
      ...defaultOptions3.diffMatchPatch,
      ...options.diffMatchPatch || {}
    }
  };
}
function diffItem(itemA, itemB) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOptions3;
  let path2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  let patches = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
  if (itemA === itemB) {
    return patches;
  }
  const aType = Array.isArray(itemA) ? "array" : typeof itemA;
  const bType = Array.isArray(itemB) ? "array" : typeof itemB;
  const aIsUndefined = aType === "undefined";
  const bIsUndefined = bType === "undefined";
  if (aIsUndefined && !bIsUndefined) {
    patches.push({
      op: "set",
      path: path2,
      value: itemB
    });
    return patches;
  }
  if (!aIsUndefined && bIsUndefined) {
    patches.push({
      op: "unset",
      path: path2
    });
    return patches;
  }
  const options = mergeOptions(opts);
  const dataType = aIsUndefined ? bType : aType;
  const isContainer = dataType === "object" || dataType === "array";
  if (!isContainer) {
    return diffPrimitive(itemA, itemB, options, path2, patches);
  }
  if (aType !== bType) {
    patches.push({
      op: "set",
      path: path2,
      value: itemB
    });
    return patches;
  }
  return dataType === "array" ? diffArray(itemA, itemB, options, path2, patches) : diffObject(itemA, itemB, options, path2, patches);
}
function diffObject(itemA, itemB, options, path2, patches) {
  const atRoot = path2.length === 0;
  const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key2) => validateProperty(key2, itemA[key2], path2));
  const aKeysLength = aKeys.length;
  const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key2) => validateProperty(key2, itemB[key2], path2));
  const bKeysLength = bKeys.length;
  for (let i = 0; i < aKeysLength; i++) {
    const key2 = aKeys[i];
    if (!(key2 in itemB)) {
      patches.push({
        op: "unset",
        path: path2.concat(key2)
      });
    }
  }
  for (let i = 0; i < bKeysLength; i++) {
    const key2 = bKeys[i];
    diffItem(itemA[key2], itemB[key2], options, path2.concat([key2]), patches);
  }
  return patches;
}
function diffArray(itemA, itemB, options, path2, patches) {
  if (itemB.length > itemA.length) {
    patches.push({
      op: "insert",
      after: path2.concat([-1]),
      items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path2, i, options))
    });
  }
  if (itemB.length < itemA.length) {
    const isSingle = itemA.length - itemB.length === 1;
    const unsetItems = itemA.slice(itemB.length);
    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {
      patches.push({
        op: "unset",
        path: path2.concat([isSingle ? itemB.length : [itemB.length, ""]])
      });
    } else {
      patches.push(...unsetItems.map((item) => ({
        op: "unset",
        path: path2.concat({
          _key: item._key
        })
      })));
    }
  }
  for (let i = 0; i < itemB.length; i++) {
    if (Array.isArray(itemB[i])) {
      throw new DiffError("Multi-dimensional arrays not supported", path2.concat(i), itemB[i]);
    }
  }
  const overlapping = Math.min(itemA.length, itemB.length);
  const segmentA = itemA.slice(0, overlapping);
  const segmentB = itemB.slice(0, overlapping);
  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path2, patches) : diffArrayByIndex(segmentA, segmentB, options, path2, patches);
}
function diffArrayByIndex(itemA, itemB, options, path2, patches) {
  for (let i = 0; i < itemA.length; i++) {
    diffItem(itemA[i], nullifyUndefined(itemB[i], path2, i, options), options, path2.concat(i), patches);
  }
  return patches;
}
function diffArrayByKey(itemA, itemB, options, path2, patches) {
  const keyedA = indexByKey(itemA);
  const keyedB = indexByKey(itemB);
  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {
    return diffArrayByIndex(itemA, itemB, options, path2, patches);
  }
  for (let i = 0; i < keyedB.keys.length; i++) {
    const key2 = keyedB.keys[i];
    const valueA = keyedA.index[key2];
    const valueB = nullifyUndefined(keyedB.index[key2], path2, i, options);
    diffItem(valueA, valueB, options, path2.concat({
      _key: key2
    }), patches);
  }
  return patches;
}
function getDiffMatchPatch(itemA, itemB, options, path2) {
  const {
    enabled,
    lengthThresholdRelative,
    lengthThresholdAbsolute
  } = options.diffMatchPatch;
  const segment = path2[path2.length - 1];
  if (!enabled || // Don't use for anything but strings
  typeof itemA !== "string" || typeof itemB !== "string" || // Don't use for `_key`, `_ref` etc
  typeof segment === "string" && segment[0] === "_" || // Don't use on short strings
  itemB.length < lengthThresholdAbsolute) {
    return void 0;
  }
  let strPatch = "";
  try {
    const patch2 = diff2(itemA, itemB);
    const diff4 = cleanupEfficiency2(patch2);
    strPatch = stringify3(make2(diff4));
  } catch (err) {
    return void 0;
  }
  return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {
    op: "diffMatchPatch",
    path: path2,
    value: strPatch
  };
}
function diffPrimitive(itemA, itemB, options, path2, patches) {
  const dmp = getDiffMatchPatch(itemA, itemB, options, path2);
  patches.push(dmp || {
    op: "set",
    path: path2,
    value: itemB
  });
  return patches;
}
function isNotIgnoredKey(key2) {
  return ignoredKeys.indexOf(key2) === -1;
}
function isUniquelyKeyed(arr) {
  const keys = [];
  for (let i = 0; i < arr.length; i++) {
    const key2 = getKey(arr[i]);
    if (!key2 || keys.indexOf(key2) !== -1) {
      return false;
    }
    keys.push(key2);
  }
  return true;
}
function getKey(obj) {
  return typeof obj === "object" && obj !== null && obj._key;
}
function indexByKey(arr) {
  return arr.reduce((acc, item) => {
    acc.keys.push(item._key);
    acc.index[item._key] = item;
    return acc;
  }, {
    keys: [],
    index: {}
  });
}
function arrayIsEqual(itemA, itemB) {
  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item);
}
function nullifyUndefined(item, path2, index, options) {
  if (typeof item !== "undefined") {
    return item;
  }
  if (!options.hideWarnings) {
    const serializedPath = pathToString(path2.concat(index));
    console.warn("undefined value in array converted to null (at '".concat(serializedPath, "')"));
  }
  return null;
}
function isRevisionLocked(options) {
  return Boolean(options.ifRevisionID);
}
function yes(_) {
  return true;
}

// node_modules/sanity/lib/index.esm.js
var import_groupBy = __toESM(require_groupBy());
init_dist();
init_get_random_values_esm();
init_sortable_esm();
init_core_esm();
init_utilities_esm();
init_modifiers_esm();
init_isValid();
var import_exif_component = __toESM(require_exif_component());
var import_find3 = __toESM(require_find());
var import_range = __toESM(require_range());
var import_speakingurl = __toESM(require_speakingurl());
var import_difference3 = __toESM(require_difference());
var import_castArray2 = __toESM(require_castArray());
var import_pick3 = __toESM(require_pick());

// node_modules/@sanity/mutator/lib/index.esm.js
var import_flatten4 = __toESM(require_flatten());
var import_compact = __toESM(require_compact());
var import_isEqual3 = __toESM(require_isEqual());
var import_min = __toESM(require_min());
var import_max = __toESM(require_max());
init_uuid();
var import_debug4 = __toESM(require_browser4());
var digitChar = /[0-9]/;
var attributeCharMatcher = /^[a-zA-Z0-9_]$/;
var attributeFirstCharMatcher = /^[a-zA-Z_]$/;
var symbols = {
  // NOTE: These are compared against in order of definition,
  // thus '==' must come before '=', '>=' before '>', etc.
  operator: ["..", ".", ",", ":", "?"],
  comparator: [">=", "<=", "<", ">", "==", "!="],
  keyword: ["$", "@"],
  boolean: ["true", "false"],
  paren: ["[", "]"]
};
var symbolClasses = Object.keys(symbols);
var Tokenizer = class {
  constructor(path2) {
    this.source = path2;
    this.length = path2.length;
    this.i = 0;
    this.tokenizers = [this.tokenizeSymbol, this.tokenizeIdentifier, this.tokenizeNumber, this.tokenizeQuoted].map((fn) => fn.bind(this));
  }
  tokenize() {
    const result = [];
    while (!this.EOF()) {
      this.chompWhitespace();
      let token = null;
      const found = this.tokenizers.some((tokenizer) => {
        token = tokenizer();
        return Boolean(token);
      });
      if (!found || !token) {
        throw new Error("Invalid tokens in jsonpath '".concat(this.source, "' @ ").concat(this.i));
      }
      result.push(token);
    }
    return result;
  }
  takeWhile(fn) {
    const start = this.i;
    let result = "";
    while (!this.EOF()) {
      const nextChar = fn(this.source[this.i]);
      if (nextChar === null) {
        break;
      }
      result += nextChar;
      this.i++;
    }
    if (this.i === start) {
      return null;
    }
    return result;
  }
  EOF() {
    return this.i >= this.length;
  }
  peek() {
    if (this.EOF()) {
      return null;
    }
    return this.source[this.i];
  }
  consume(str) {
    if (this.i + str.length > this.length) {
      throw new Error("Expected ".concat(str, " at end of jsonpath"));
    }
    if (str === this.source.slice(this.i, this.i + str.length)) {
      this.i += str.length;
    } else {
      throw new Error('Expected "'.concat(str, '", but source contained "').concat(this.source.slice()));
    }
  }
  // Tries to match the upcoming bit of string with the provided string. If it matches, returns
  // the string, then advances the read pointer to the next bit. If not, returns null and nothing
  // happens.
  tryConsume(str) {
    if (this.i + str.length > this.length) {
      return null;
    }
    if (str === this.source.slice(this.i, this.i + str.length)) {
      this.i += str.length;
      return str;
    }
    return null;
  }
  chompWhitespace() {
    this.takeWhile((char) => {
      return char === " " ? "" : null;
    });
  }
  tokenizeQuoted() {
    const quote4 = this.peek();
    if (quote4 === "'" || quote4 === '"') {
      this.consume(quote4);
      let escape2 = false;
      const inner = this.takeWhile((char) => {
        if (escape2) {
          escape2 = false;
          return char;
        }
        if (char === "\\") {
          escape2 = true;
          return "";
        }
        if (char != quote4) {
          return char;
        }
        return null;
      });
      this.consume(quote4);
      return {
        type: "quoted",
        value: inner,
        quote: quote4 === '"' ? "double" : "single"
      };
    }
    return null;
  }
  tokenizeIdentifier() {
    let first2 = true;
    const identifier = this.takeWhile((char) => {
      if (first2) {
        first2 = false;
        return char.match(attributeFirstCharMatcher) ? char : null;
      }
      return char.match(attributeCharMatcher) ? char : null;
    });
    if (identifier !== null) {
      return {
        type: "identifier",
        name: identifier
      };
    }
    return null;
  }
  tokenizeNumber() {
    const start = this.i;
    let dotSeen = false;
    let digitSeen = false;
    let negative = false;
    if (this.peek() === "-") {
      negative = true;
      this.consume("-");
    }
    const number2 = this.takeWhile((char) => {
      if (char === "." && !dotSeen && digitSeen) {
        dotSeen = true;
        return char;
      }
      digitSeen = true;
      return char.match(digitChar) ? char : null;
    });
    if (number2 !== null) {
      return {
        type: "number",
        value: negative ? -number2 : +number2,
        raw: negative ? "-".concat(number2) : number2
      };
    }
    this.i = start;
    return null;
  }
  tokenizeSymbol() {
    for (const symbolClass of symbolClasses) {
      const patterns = symbols[symbolClass];
      const symbol = patterns.find((pattern) => this.tryConsume(pattern));
      if (symbol) {
        return {
          type: symbolClass,
          symbol
        };
      }
    }
    return null;
  }
};
function tokenize(jsonpath) {
  return new Tokenizer(jsonpath).tokenize();
}
var Parser = class {
  constructor(path2) {
    this.tokens = tokenize(path2);
    this.length = this.tokens.length;
    this.i = 0;
  }
  parse() {
    return this.parsePath();
  }
  EOF() {
    return this.i >= this.length;
  }
  // Look at upcoming token
  peek() {
    if (this.EOF()) {
      return null;
    }
    return this.tokens[this.i];
  }
  consume() {
    const result = this.peek();
    this.i += 1;
    return result;
  }
  // Return next token if it matches the pattern
  probe(pattern) {
    const token = this.peek();
    if (!token) {
      return null;
    }
    const record2 = token;
    const match4 = Object.keys(pattern).every((key2) => {
      return key2 in token && pattern[key2] === record2[key2];
    });
    return match4 ? token : null;
  }
  // Return and consume next token if it matches the pattern
  match(pattern) {
    return this.probe(pattern) ? this.consume() : null;
  }
  parseAttribute() {
    const token = this.match({
      type: "identifier"
    });
    if (token && token.type === "identifier") {
      return {
        type: "attribute",
        name: token.name
      };
    }
    const quoted = this.match({
      type: "quoted",
      quote: "single"
    });
    if (quoted && quoted.type === "quoted") {
      return {
        type: "attribute",
        name: quoted.value || ""
      };
    }
    return null;
  }
  parseAlias() {
    if (this.match({
      type: "keyword",
      symbol: "@"
    }) || this.match({
      type: "keyword",
      symbol: "$"
    })) {
      return {
        type: "alias",
        target: "self"
      };
    }
    return null;
  }
  parseNumber() {
    const token = this.match({
      type: "number"
    });
    if (token && token.type === "number") {
      return {
        type: "number",
        value: token.value
      };
    }
    return null;
  }
  parseNumberValue() {
    const expr = this.parseNumber();
    if (expr) {
      return expr.value;
    }
    return null;
  }
  parseSliceSelector() {
    const start = this.i;
    const rangeStart = this.parseNumberValue();
    const colon1 = this.match({
      type: "operator",
      symbol: ":"
    });
    if (!colon1) {
      if (rangeStart === null) {
        this.i = start;
        return null;
      }
      return {
        type: "index",
        value: rangeStart
      };
    }
    const result = {
      type: "range",
      start: rangeStart,
      end: this.parseNumberValue()
    };
    const colon2 = this.match({
      type: "operator",
      symbol: ":"
    });
    if (colon2) {
      result.step = this.parseNumberValue();
    }
    if (result.start === null && result.end === null) {
      this.i = start;
      return null;
    }
    return result;
  }
  parseValueReference() {
    return this.parseAttribute() || this.parseSliceSelector();
  }
  parseLiteralValue() {
    const literalString = this.match({
      type: "quoted",
      quote: "double"
    });
    if (literalString && literalString.type === "quoted") {
      return {
        type: "string",
        value: literalString.value || ""
      };
    }
    const literalBoolean = this.match({
      type: "boolean"
    });
    if (literalBoolean && literalBoolean.type === "boolean") {
      return {
        type: "boolean",
        value: literalBoolean.symbol === "true"
      };
    }
    return this.parseNumber();
  }
  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
  // on lhs.
  parseFilterExpression() {
    const start = this.i;
    const expr = this.parseAttribute() || this.parseAlias();
    if (!expr) {
      return null;
    }
    if (this.match({
      type: "operator",
      symbol: "?"
    })) {
      return {
        type: "constraint",
        operator: "?",
        lhs: expr
      };
    }
    const binOp = this.match({
      type: "comparator"
    });
    if (!binOp || binOp.type !== "comparator") {
      this.i = start;
      return null;
    }
    const lhs = expr;
    const rhs = this.parseLiteralValue();
    if (!rhs) {
      throw new Error("Operator ".concat(binOp.symbol, " needs a literal value at the right hand side"));
    }
    return {
      type: "constraint",
      operator: binOp.symbol,
      lhs,
      rhs
    };
  }
  parseExpression() {
    return this.parseFilterExpression() || this.parseValueReference();
  }
  parseUnion() {
    if (!this.match({
      type: "paren",
      symbol: "["
    })) {
      return null;
    }
    const terms = [];
    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
    while (expr) {
      terms.push(expr);
      if (this.match({
        type: "paren",
        symbol: "]"
      })) {
        break;
      }
      if (!this.match({
        type: "operator",
        symbol: ","
      })) {
        throw new Error("Expected ]");
      }
      expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
      if (!expr) {
        throw new Error("Expected expression following ','");
      }
    }
    return {
      type: "union",
      nodes: terms
    };
  }
  parseRecursive() {
    if (!this.match({
      type: "operator",
      symbol: ".."
    })) {
      return null;
    }
    const subpath = this.parsePath();
    if (!subpath) {
      throw new Error("Expected path following '..' operator");
    }
    return {
      type: "recursive",
      term: subpath
    };
  }
  parsePath() {
    const nodes = [];
    const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();
    if (!expr) {
      return null;
    }
    nodes.push(expr);
    while (!this.EOF()) {
      if (this.match({
        type: "operator",
        symbol: "."
      })) {
        const attr = this.parseAttribute();
        if (!attr) {
          throw new Error("Expected attribute name following '.");
        }
        nodes.push(attr);
        continue;
      } else if (this.probe({
        type: "paren",
        symbol: "["
      })) {
        const union2 = this.parseUnion();
        if (!union2) {
          throw new Error("Expected union following '['");
        }
        nodes.push(union2);
      } else {
        const recursive = this.parseRecursive();
        if (recursive) {
          nodes.push(recursive);
        }
        break;
      }
    }
    if (nodes.length === 1) {
      return nodes[0];
    }
    return {
      type: "path",
      nodes
    };
  }
};
function parseJsonPath(path2) {
  const parsed = new Parser(path2).parse();
  if (!parsed) {
    throw new Error('Failed to parse JSON path "'.concat(path2, '"'));
  }
  return parsed;
}
function descend$1(tail) {
  const [head, newTail] = splitIfPath(tail);
  if (!head) {
    throw new Error("Head cannot be null");
  }
  return spreadIfUnionHead(head, newTail);
}
function splitIfPath(tail) {
  if (tail.type !== "path") {
    return [tail, null];
  }
  const nodes = tail.nodes;
  if (nodes.length === 0) {
    return [null, null];
  }
  if (nodes.length === 1) {
    return [nodes[0], null];
  }
  return [nodes[0], {
    type: "path",
    nodes: nodes.slice(1)
  }];
}
function concatPaths(path1, path2) {
  if (!path1 && !path2) {
    return null;
  }
  const nodes1 = path1 ? path1.nodes : [];
  const nodes2 = path2 ? path2.nodes : [];
  return {
    type: "path",
    nodes: nodes1.concat(nodes2)
  };
}
function spreadIfUnionHead(head, tail) {
  if (head.type !== "union") {
    return [[head, tail]];
  }
  return head.nodes.map((node) => {
    if (node.type === "path") {
      const [subHead, subTail] = splitIfPath(node);
      return [subHead, concatPaths(subTail, tail)];
    }
    return [node, tail];
  });
}
function toPath2(expr) {
  return toPathInner(expr, false);
}
function toPathInner(expr, inUnion) {
  switch (expr.type) {
    case "attribute":
      return expr.name;
    case "alias":
      return expr.target === "self" ? "@" : "$";
    case "number":
      return "".concat(expr.value);
    case "range": {
      const result = [];
      if (!inUnion) {
        result.push("[");
      }
      if (expr.start) {
        result.push("".concat(expr.start));
      }
      result.push(":");
      if (expr.end) {
        result.push("".concat(expr.end));
      }
      if (expr.step) {
        result.push(":".concat(expr.step));
      }
      if (!inUnion) {
        result.push("]");
      }
      return result.join("");
    }
    case "index":
      if (inUnion) {
        return "".concat(expr.value);
      }
      return "[".concat(expr.value, "]");
    case "constraint": {
      const rhs = expr.rhs ? " ".concat(toPathInner(expr.rhs, false)) : "";
      const inner = "".concat(toPathInner(expr.lhs, false), " ").concat(expr.operator).concat(rhs);
      if (inUnion) {
        return inner;
      }
      return "[".concat(inner, "]");
    }
    case "string":
      return JSON.stringify(expr.value);
    case "path": {
      const result = [];
      const nodes = expr.nodes.slice();
      while (nodes.length > 0) {
        const node = nodes.shift();
        if (node) {
          result.push(toPath2(node));
        }
        const upcoming = nodes[0];
        if (upcoming && toPathInner(upcoming, false)[0] !== "[") {
          result.push(".");
        }
      }
      return result.join("");
    }
    case "union":
      return "[".concat(expr.nodes.map((e2) => toPathInner(e2, true)).join(","), "]");
    default:
      throw new Error("Unknown node type ".concat(expr.type));
    case "recursive":
      return "..".concat(toPathInner(expr.term, false));
  }
}
var Expression = class _Expression {
  constructor(expr) {
    if (!expr) {
      throw new Error("Attempted to create Expression from null-value");
    }
    if ("expr" in expr) {
      this.expr = expr.expr;
    } else {
      this.expr = expr;
    }
    if (!("type" in this.expr)) {
      throw new Error("Attempt to create Expression for expression with no type");
    }
  }
  isPath() {
    return this.expr.type === "path";
  }
  isUnion() {
    return this.expr.type === "union";
  }
  isCollection() {
    return this.isPath() || this.isUnion();
  }
  isConstraint() {
    return this.expr.type === "constraint";
  }
  isRecursive() {
    return this.expr.type === "recursive";
  }
  isExistenceConstraint() {
    return this.expr.type === "constraint" && this.expr.operator === "?";
  }
  isIndex() {
    return this.expr.type === "index";
  }
  isRange() {
    return this.expr.type === "range";
  }
  expandRange(probe) {
    const probeLength = () => {
      if (!probe) {
        throw new Error("expandRange() required a probe that was not passed");
      }
      return probe.length();
    };
    let start = "start" in this.expr ? this.expr.start || 0 : 0;
    start = interpretNegativeIndex(start, probe);
    let end = "end" in this.expr ? this.expr.end || probeLength() : probeLength();
    end = interpretNegativeIndex(end, probe);
    const step = "step" in this.expr ? this.expr.step || 1 : 1;
    return {
      start,
      end,
      step
    };
  }
  isAttributeReference() {
    return this.expr.type === "attribute";
  }
  // Is a range or index -> something referencing indexes
  isIndexReference() {
    return this.isIndex() || this.isRange();
  }
  name() {
    return "name" in this.expr ? this.expr.name : "";
  }
  isSelfReference() {
    return this.expr.type === "alias" && this.expr.target === "self";
  }
  constraintTargetIsSelf() {
    return this.expr.type === "constraint" && this.expr.lhs.type === "alias" && this.expr.lhs.target === "self";
  }
  constraintTargetIsAttribute() {
    return this.expr.type === "constraint" && this.expr.lhs.type === "attribute";
  }
  testConstraint(probe) {
    const expr = this.expr;
    if (expr.type === "constraint" && expr.lhs.type === "alias" && expr.lhs.target === "self") {
      if (probe.containerType() !== "primitive") {
        return false;
      }
      if (expr.type === "constraint" && expr.operator === "?") {
        return true;
      }
      const lhs2 = probe.get();
      const rhs2 = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
      return testBinaryOperator(lhs2, expr.operator, rhs2);
    }
    if (expr.type !== "constraint") {
      return false;
    }
    const lhs = expr.lhs;
    if (!lhs) {
      throw new Error("No LHS of expression");
    }
    if (lhs.type !== "attribute") {
      throw new Error("Constraint target ".concat(lhs.type, " not supported"));
    }
    if (probe.containerType() !== "object") {
      return false;
    }
    const lhsValue = probe.getAttribute(lhs.name);
    if (lhsValue === void 0 || lhsValue === null || lhsValue.containerType() !== "primitive") {
      return false;
    }
    if (this.isExistenceConstraint()) {
      return true;
    }
    const rhs = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
    return testBinaryOperator(lhsValue.get(), expr.operator, rhs);
  }
  pathNodes() {
    return this.expr.type === "path" ? this.expr.nodes : [this.expr];
  }
  prepend(node) {
    if (!node) {
      return this;
    }
    return new _Expression({
      type: "path",
      nodes: node.pathNodes().concat(this.pathNodes())
    });
  }
  concat(other) {
    return other ? other.prepend(this) : this;
  }
  descend() {
    return descend$1(this.expr).map((headTail) => {
      const [head, tail] = headTail;
      return {
        head: head ? new _Expression(head) : null,
        tail: tail ? new _Expression(tail) : null
      };
    });
  }
  unwrapRecursive() {
    if (this.expr.type !== "recursive") {
      throw new Error("Attempt to unwrap recursive on type ".concat(this.expr.type));
    }
    return new _Expression(this.expr.term);
  }
  toIndicies(probe) {
    if (this.expr.type !== "index" && this.expr.type !== "range") {
      throw new Error("Node cannot be converted to indexes");
    }
    if (this.expr.type === "index") {
      return [interpretNegativeIndex(this.expr.value, probe)];
    }
    const result = [];
    const range2 = this.expandRange(probe);
    let {
      start,
      end
    } = range2;
    if (range2.step < 0) {
      [start, end] = [end, start];
    }
    for (let i = start; i < end; i++) {
      result.push(i);
    }
    return result;
  }
  toFieldReferences() {
    if (this.isIndexReference()) {
      return this.toIndicies();
    }
    if (this.expr.type === "attribute") {
      return [this.expr.name];
    }
    throw new Error("Can't convert ".concat(this.expr.type, " to field references"));
  }
  toString() {
    return toPath2(this.expr);
  }
  static fromPath(path2) {
    const parsed = parseJsonPath(path2);
    if (!parsed) {
      throw new Error('Failed to parse path "'.concat(path2, '"'));
    }
    return new _Expression(parsed);
  }
  static attributeReference(name) {
    return new _Expression({
      type: "attribute",
      name
    });
  }
  static indexReference(i) {
    return new _Expression({
      type: "index",
      value: i
    });
  }
};
function testBinaryOperator(lhsValue, operator, rhsValue) {
  switch (operator) {
    case ">":
      return lhsValue > rhsValue;
    case ">=":
      return lhsValue >= rhsValue;
    case "<":
      return lhsValue < rhsValue;
    case "<=":
      return lhsValue <= rhsValue;
    case "==":
      return lhsValue === rhsValue;
    case "!=":
      return lhsValue !== rhsValue;
    default:
      throw new Error("Unsupported binary operator ".concat(operator));
  }
}
function interpretNegativeIndex(index, probe) {
  if (index >= 0) {
    return index;
  }
  if (!probe) {
    throw new Error("interpretNegativeIndex() must have a probe when < 0");
  }
  return index + probe.length();
}
var Descender = class _Descender {
  constructor(head, tail) {
    this.head = head;
    this.tail = tail;
  }
  // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head
  iterate(probe) {
    let result = [this];
    if (this.head && this.head.isConstraint()) {
      let anyConstraints = true;
      while (anyConstraints) {
        result = (0, import_flatten4.default)(result.map((descender) => {
          return descender.iterateConstraints(probe);
        }));
        anyConstraints = result.some((descender) => {
          return descender.head && descender.head.isConstraint();
        });
      }
    }
    return result;
  }
  isRecursive() {
    return Boolean(this.head && this.head.isRecursive());
  }
  hasArrived() {
    return this.head === null && this.tail === null;
  }
  extractRecursives() {
    if (this.head && this.head.isRecursive()) {
      const term = this.head.unwrapRecursive();
      return new _Descender(null, term.concat(this.tail)).descend();
    }
    return [];
  }
  iterateConstraints(probe) {
    const head = this.head;
    if (head === null || !head.isConstraint()) {
      return [this];
    }
    const result = [];
    if (probe.containerType() === "primitive" && head.constraintTargetIsSelf()) {
      if (head.testConstraint(probe)) {
        result.push(...this.descend());
      }
      return result;
    }
    if (probe.containerType() === "array") {
      const length2 = probe.length();
      for (let i = 0; i < length2; i++) {
        const constraint = probe.getIndex(i);
        if (constraint && head.testConstraint(constraint)) {
          result.push(new _Descender(new Expression({
            type: "index",
            value: i
          }), this.tail));
        }
      }
      return result;
    }
    if (probe.containerType() === "object") {
      if (head.constraintTargetIsSelf()) {
        return [];
      }
      if (head.testConstraint(probe)) {
        return this.descend();
      }
      return result;
    }
    return result;
  }
  descend() {
    if (!this.tail) {
      return [new _Descender(null, null)];
    }
    return this.tail.descend().map((ht) => {
      return new _Descender(ht.head, ht.tail);
    });
  }
  toString() {
    const result = ["<"];
    if (this.head) {
      result.push(this.head.toString());
    }
    result.push("|");
    if (this.tail) {
      result.push(this.tail.toString());
    }
    result.push(">");
    return result.join("");
  }
};
var Matcher = class _Matcher {
  constructor(active, parent) {
    this.active = active || [];
    if (parent) {
      this.recursives = parent.recursives;
      this.payload = parent.payload;
    } else {
      this.recursives = [];
    }
    this.extractRecursives();
  }
  setPayload(payload) {
    this.payload = payload;
    return this;
  }
  // Moves any recursive descenders onto the recursive track, removing them from
  // the active set
  extractRecursives() {
    this.active = this.active.filter((descender) => {
      if (descender.isRecursive()) {
        this.recursives.push(...descender.extractRecursives());
        return false;
      }
      return true;
    });
  }
  // Find recursives that are relevant now and should be considered part of the active set
  activeRecursives(probe) {
    return this.recursives.filter((descender) => {
      const head = descender.head;
      if (!head) {
        return false;
      }
      if (head.isConstraint()) {
        return true;
      }
      if (probe.containerType() === "array" && head.isIndexReference()) {
        return true;
      }
      if (probe.containerType() === "object") {
        return head.isAttributeReference() && probe.hasAttribute(head.name());
      }
      return false;
    });
  }
  match(probe) {
    return this.iterate(probe).extractMatches(probe);
  }
  iterate(probe) {
    const newActiveSet = [];
    this.active.concat(this.activeRecursives(probe)).forEach((descender) => {
      newActiveSet.push(...descender.iterate(probe));
    });
    return new _Matcher(newActiveSet, this);
  }
  // Returns true if any of the descenders in the active or recursive set
  // consider the current state a final destination
  isDestination() {
    return this.active.some((descender) => descender.hasArrived());
  }
  hasRecursives() {
    return this.recursives.length > 0;
  }
  // Returns any payload delivieries and leads that needs to be followed to complete
  // the process.
  extractMatches(probe) {
    const leads = [];
    const targets = [];
    this.active.forEach((descender) => {
      if (descender.hasArrived()) {
        targets.push(new Expression({
          type: "alias",
          target: "self"
        }));
        return;
      }
      const descenderHead = descender.head;
      if (!descenderHead) {
        return;
      }
      if (probe.containerType() === "array" && !descenderHead.isIndexReference()) {
        return;
      }
      if (probe.containerType() === "object" && !descenderHead.isAttributeReference()) {
        return;
      }
      if (descender.tail) {
        const matcher = new _Matcher(descender.descend(), this);
        descenderHead.toFieldReferences().forEach(() => {
          leads.push({
            target: descenderHead,
            matcher
          });
        });
      } else {
        targets.push(descenderHead);
      }
    });
    if (this.hasRecursives()) {
      const recursivesMatcher = new _Matcher([], this);
      if (probe.containerType() === "array") {
        const length2 = probe.length();
        for (let i = 0; i < length2; i++) {
          leads.push({
            target: Expression.indexReference(i),
            matcher: recursivesMatcher
          });
        }
      } else if (probe.containerType() === "object") {
        probe.attributeKeys().forEach((name) => {
          leads.push({
            target: Expression.attributeReference(name),
            matcher: recursivesMatcher
          });
        });
      }
    }
    return targets.length > 0 ? {
      leads,
      delivery: {
        targets,
        payload: this.payload
      }
    } : {
      leads
    };
  }
  static fromPath(jsonpath) {
    const path2 = parseJsonPath(jsonpath);
    if (!path2) {
      throw new Error('Failed to parse path from "'.concat(jsonpath, '"'));
    }
    const descender = new Descender(null, new Expression(path2));
    return new _Matcher(descender.descend());
  }
};
function isRecord$13(value) {
  return value !== null && typeof value === "object";
}
var PlainProbe = class _PlainProbe {
  constructor(value, path2) {
    this._value = value;
    this.path = path2 || [];
  }
  containerType() {
    if (Array.isArray(this._value)) {
      return "array";
    } else if (this._value !== null && typeof this._value === "object") {
      return "object";
    }
    return "primitive";
  }
  length() {
    if (!Array.isArray(this._value)) {
      throw new Error("Won't return length of non-indexable _value");
    }
    return this._value.length;
  }
  getIndex(i) {
    if (!Array.isArray(this._value)) {
      return false;
    }
    if (i >= this.length()) {
      return null;
    }
    return new _PlainProbe(this._value[i], this.path.concat(i));
  }
  hasAttribute(key2) {
    if (!isRecord$13(this._value)) {
      return false;
    }
    return this._value.hasOwnProperty(key2);
  }
  attributeKeys() {
    return isRecord$13(this._value) ? Object.keys(this._value) : [];
  }
  getAttribute(key2) {
    if (!isRecord$13(this._value)) {
      throw new Error("getAttribute only applies to plain objects");
    }
    if (!this.hasAttribute(key2)) {
      return null;
    }
    return new _PlainProbe(this._value[key2], this.path.concat(key2));
  }
  get() {
    return this._value;
  }
};
function extractAccessors(path2, value) {
  const result = [];
  const matcher = Matcher.fromPath(path2).setPayload(function appendResult(values2) {
    result.push(...values2);
  });
  const accessor = new PlainProbe(value);
  descend(matcher, accessor);
  return result;
}
function descend(matcher, accessor) {
  const {
    leads,
    delivery
  } = matcher.match(accessor);
  leads.forEach((lead) => {
    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {
      descend(lead.matcher, childAccessor);
    });
  });
  if (delivery) {
    delivery.targets.forEach((target) => {
      if (typeof delivery.payload === "function") {
        delivery.payload(accessorsFromTarget(target, accessor));
      }
    });
  }
}
function accessorsFromTarget(target, accessor) {
  const result = [];
  if (target.isIndexReference()) {
    target.toIndicies(accessor).forEach((i) => {
      result.push(accessor.getIndex(i));
    });
  } else if (target.isAttributeReference()) {
    result.push(accessor.getAttribute(target.name()));
  } else if (target.isSelfReference()) {
    result.push(accessor);
  } else {
    throw new Error("Unable to derive accessor for target ".concat(target.toString()));
  }
  return (0, import_compact.default)(result);
}
function extractWithPath(path2, value) {
  const accessors = extractAccessors(path2, value);
  return accessors.map((acc) => ({
    path: acc.path,
    value: acc.get()
  }));
}
var IS_DOTTABLE = /^[a-z_$]+/;
function arrayToJSONMatchPath(pathArray) {
  let path2 = "";
  pathArray.forEach((segment, index) => {
    path2 += stringifySegment(segment, index === 0);
  });
  return path2;
}
function stringifySegment(segment, hasLeading) {
  if (typeof segment === "number") {
    return "[".concat(segment, "]");
  }
  if (isRecord$13(segment)) {
    const seg = segment;
    return Object.keys(segment).map((key2) => isPrimitiveValue(seg[key2]) ? "[".concat(key2, '=="').concat(seg[key2], '"]') : "").join("");
  }
  if (typeof segment === "string" && IS_DOTTABLE.test(segment)) {
    return hasLeading ? segment : ".".concat(segment);
  }
  return "['".concat(segment, "']");
}
function isPrimitiveValue(val) {
  switch (typeof val) {
    case "number":
    case "string":
    case "boolean":
      return true;
    default:
      return false;
  }
}
var SetPatch = class {
  constructor(id4, path2, value) {
    this.id = id4;
    this.path = path2;
    this.value = value;
  }
  apply(targets, accessor) {
    let result = accessor;
    targets.forEach((target) => {
      if (target.isSelfReference()) {
        result = result.set(this.value);
      } else if (target.isIndexReference()) {
        target.toIndicies(accessor).forEach((i) => {
          result = result.setIndex(i, this.value);
        });
      } else if (target.isAttributeReference()) {
        if (result.containerType() === "primitive") {
          result = result.set({
            [target.name()]: this.value
          });
        } else {
          result = result.setAttribute(target.name(), this.value);
        }
      } else {
        throw new Error("Unable to apply to target ".concat(target.toString()));
      }
    });
    return result;
  }
};
function performIncrement(previousValue, delta2) {
  if (typeof previousValue !== "number" || !Number.isFinite(previousValue)) {
    return previousValue;
  }
  return previousValue + delta2;
}
var IncPatch = class {
  constructor(id4, path2, value) {
    this.path = path2;
    this.value = value;
    this.id = id4;
  }
  apply(targets, accessor) {
    let result = accessor;
    if (result.containerType() === "primitive") {
      return result;
    }
    for (const target of targets) {
      if (target.isIndexReference()) {
        for (const index of target.toIndicies(accessor)) {
          const item = result.getIndex(index);
          if (!item) {
            continue;
          }
          const previousValue = item.get();
          result = result.setIndex(index, performIncrement(previousValue, this.value));
        }
        continue;
      }
      if (target.isAttributeReference()) {
        const attribute = result.getAttribute(target.name());
        if (!attribute) {
          continue;
        }
        const previousValue = attribute.get();
        result = result.setAttribute(target.name(), performIncrement(previousValue, this.value));
        continue;
      }
      throw new Error("Unable to apply to target ".concat(target.toString()));
    }
    return result;
  }
};
function targetsToIndicies(targets, accessor) {
  const result = [];
  targets.forEach((target) => {
    if (target.isIndexReference()) {
      result.push(...target.toIndicies(accessor));
    }
  });
  return result.sort();
}
var InsertPatch = class {
  constructor(id4, location, path2, items) {
    this.id = id4;
    this.location = location;
    this.path = path2;
    this.items = items;
  }
  apply(targets, accessor) {
    let result = accessor;
    if (accessor.containerType() !== "array") {
      throw new Error("Attempt to apply insert patch to non-array value");
    }
    switch (this.location) {
      case "before": {
        const pos = minIndex(targets, accessor);
        result = result.insertItemsAt(pos, this.items);
        break;
      }
      case "after": {
        const pos = maxIndex(targets, accessor);
        result = result.insertItemsAt(pos + 1, this.items);
        break;
      }
      case "replace": {
        const indicies = targetsToIndicies(targets, accessor);
        result = result.unsetIndices(indicies);
        result = result.insertItemsAt(indicies[0], this.items);
        break;
      }
      default: {
        throw new Error("Unsupported location atm: ".concat(this.location));
      }
    }
    return result;
  }
};
function minIndex(targets, accessor) {
  let result = (0, import_min.default)(targetsToIndicies(targets, accessor)) || 0;
  targets.forEach((target) => {
    if (target.isRange()) {
      const {
        start
      } = target.expandRange();
      if (start < result) {
        result = start;
      }
    }
  });
  return result;
}
function maxIndex(targets, accessor) {
  let result = (0, import_max.default)(targetsToIndicies(targets, accessor)) || 0;
  targets.forEach((target) => {
    if (target.isRange()) {
      const {
        end
      } = target.expandRange();
      if (end > result) {
        result = end;
      }
    }
  });
  return result;
}
var SetIfMissingPatch = class {
  constructor(id4, path2, value) {
    this.id = id4;
    this.path = path2;
    this.value = value;
  }
  apply(targets, accessor) {
    let result = accessor;
    targets.forEach((target) => {
      if (target.isIndexReference())
        ;
      else if (target.isAttributeReference()) {
        if (result.containerType() === "primitive") {
          result = result.set({
            [target.name()]: this.value
          });
        } else if (!result.hasAttribute(target.name())) {
          result = accessor.setAttribute(target.name(), this.value);
        }
      } else {
        throw new Error("Unable to apply to target ".concat(target.toString()));
      }
    });
    return result;
  }
};
var UnsetPatch = class {
  constructor(id4, path2) {
    this.id = id4;
    this.path = path2;
  }
  // eslint-disable-next-line class-methods-use-this
  apply(targets, accessor) {
    let result = accessor;
    switch (accessor.containerType()) {
      case "array":
        result = result.unsetIndices(targetsToIndicies(targets, accessor));
        break;
      case "object":
        targets.forEach((target) => {
          result = result.unsetAttribute(target.name());
        });
        break;
      default:
        throw new Error("Target value is neither indexable or an object. This error should potentially just be silently ignored?");
    }
    return result;
  }
};
function applyPatch2(patch2, oldValue) {
  if (typeof oldValue !== "string")
    return oldValue;
  const [result] = apply2(patch2, oldValue, {
    allowExceedingIndices: true
  });
  return result;
}
var DiffMatchPatch = class {
  constructor(id4, path2, dmpPatchSrc) {
    this.id = id4;
    this.path = path2;
    this.dmpPatch = parse4(dmpPatchSrc);
  }
  apply(targets, accessor) {
    let result = accessor;
    if (result.containerType() === "primitive") {
      return result;
    }
    for (const target of targets) {
      if (target.isIndexReference()) {
        for (const index of target.toIndicies(accessor)) {
          const item = result.getIndex(index);
          if (!item) {
            continue;
          }
          const oldValue = item.get();
          const nextValue = applyPatch2(this.dmpPatch, oldValue);
          result = result.setIndex(index, nextValue);
        }
        continue;
      }
      if (target.isAttributeReference() && result.hasAttribute(target.name())) {
        const attribute = result.getAttribute(target.name());
        if (!attribute) {
          continue;
        }
        const oldValue = attribute.get();
        const nextValue = applyPatch2(this.dmpPatch, oldValue);
        result = result.setAttribute(target.name(), nextValue);
        continue;
      }
      throw new Error("Unable to apply diffMatchPatch to target ".concat(target.toString()));
    }
    return result;
  }
};
function parsePatch(patch2) {
  const result = [];
  if (Array.isArray(patch2)) {
    return patch2.reduce((r2, p) => r2.concat(parsePatch(p)), result);
  }
  const {
    set: set4,
    setIfMissing: setIfMissing3,
    unset: unset3,
    diffMatchPatch: diffMatchPatch3,
    inc: inc2,
    dec: dec2,
    insert: insert3
  } = patch2;
  if (setIfMissing3) {
    Object.keys(setIfMissing3).forEach((path2) => {
      result.push(new SetIfMissingPatch(patch2.id, path2, setIfMissing3[path2]));
    });
  }
  if (set4) {
    Object.keys(set4).forEach((path2) => {
      result.push(new SetPatch(patch2.id, path2, set4[path2]));
    });
  }
  if (unset3) {
    unset3.forEach((path2) => {
      result.push(new UnsetPatch(patch2.id, path2));
    });
  }
  if (diffMatchPatch3) {
    Object.keys(diffMatchPatch3).forEach((path2) => {
      result.push(new DiffMatchPatch(patch2.id, path2, diffMatchPatch3[path2]));
    });
  }
  if (inc2) {
    Object.keys(inc2).forEach((path2) => {
      result.push(new IncPatch(patch2.id, path2, inc2[path2]));
    });
  }
  if (dec2) {
    Object.keys(dec2).forEach((path2) => {
      result.push(new IncPatch(patch2.id, path2, -dec2[path2]));
    });
  }
  if (insert3) {
    let location;
    let path2;
    const spec = insert3;
    if ("before" in spec) {
      location = "before";
      path2 = spec.before;
    } else if ("after" in spec) {
      location = "after";
      path2 = spec.after;
    } else if ("replace" in spec) {
      location = "replace";
      path2 = spec.replace;
    } else {
      throw new Error("Invalid insert patch");
    }
    result.push(new InsertPatch(patch2.id, location, path2, spec.items));
  }
  return result;
}
var ImmutableAccessor = class _ImmutableAccessor {
  constructor(value, path2) {
    this._value = value;
    this.path = path2 || [];
  }
  containerType() {
    if (Array.isArray(this._value)) {
      return "array";
    } else if (this._value !== null && typeof this._value === "object") {
      return "object";
    }
    return "primitive";
  }
  // Common reader, supported by all containers
  get() {
    return this._value;
  }
  // Array reader
  length() {
    if (!Array.isArray(this._value)) {
      throw new Error("Won't return length of non-indexable _value");
    }
    return this._value.length;
  }
  getIndex(i) {
    if (!Array.isArray(this._value)) {
      return false;
    }
    if (i >= this.length()) {
      return null;
    }
    return new _ImmutableAccessor(this._value[i], this.path.concat(i));
  }
  // Object reader
  hasAttribute(key2) {
    return isRecord5(this._value) ? this._value.hasOwnProperty(key2) : false;
  }
  attributeKeys() {
    return isRecord5(this._value) ? Object.keys(this._value) : [];
  }
  getAttribute(key2) {
    if (!isRecord5(this._value)) {
      throw new Error("getAttribute only applies to plain objects");
    }
    if (!this.hasAttribute(key2)) {
      return null;
    }
    return new _ImmutableAccessor(this._value[key2], this.path.concat(key2));
  }
  // Common writer, supported by all containers
  set(value) {
    return value === this._value ? this : new _ImmutableAccessor(value, this.path);
  }
  // array writer interface
  setIndex(i, value) {
    if (!Array.isArray(this._value)) {
      throw new Error("setIndex only applies to arrays");
    }
    if (Object.is(value, this._value[i])) {
      return this;
    }
    const nextValue = this._value.slice();
    nextValue[i] = value;
    return new _ImmutableAccessor(nextValue, this.path);
  }
  setIndexAccessor(i, accessor) {
    return this.setIndex(i, accessor.get());
  }
  unsetIndices(indices) {
    if (!Array.isArray(this._value)) {
      throw new Error("unsetIndices only applies to arrays");
    }
    const length2 = this._value.length;
    const nextValue = [];
    for (let i = 0; i < length2; i++) {
      if (indices.indexOf(i) === -1) {
        nextValue.push(this._value[i]);
      }
    }
    return new _ImmutableAccessor(nextValue, this.path);
  }
  insertItemsAt(pos, items) {
    if (!Array.isArray(this._value)) {
      throw new Error("insertItemsAt only applies to arrays");
    }
    let nextValue;
    if (this._value.length === 0 && pos === 0) {
      nextValue = items;
    } else {
      nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos));
    }
    return new _ImmutableAccessor(nextValue, this.path);
  }
  // Object writer interface
  setAttribute(key2, value) {
    if (!isRecord5(this._value)) {
      throw new Error("Unable to set attribute of non-object container");
    }
    if (Object.is(value, this._value[key2])) {
      return this;
    }
    const nextValue = Object.assign({}, this._value, {
      [key2]: value
    });
    return new _ImmutableAccessor(nextValue, this.path);
  }
  setAttributeAccessor(key2, accessor) {
    return this.setAttribute(key2, accessor.get());
  }
  unsetAttribute(key2) {
    if (!isRecord5(this._value)) {
      throw new Error("Unable to unset attribute of non-object container");
    }
    const nextValue = Object.assign({}, this._value);
    delete nextValue[key2];
    return new _ImmutableAccessor(nextValue, this.path);
  }
};
function isRecord5(value) {
  return value !== null && typeof value === "object";
}
var Patcher = class {
  constructor(patch2) {
    this.patches = parsePatch(patch2);
  }
  apply(value) {
    const accessor = new ImmutableAccessor(value);
    return this.applyViaAccessor(accessor).get();
  }
  // If you want to use your own accessor implementation, you can use this method
  // to invoke the patcher. Since all subsequent accessors for children of this accessor
  // are obtained through the methods in the accessors, you retain full control of the
  // implementation throguhgout the application. Have a look in ImmutableAccessor
  // to see an example of how accessors are implemented.
  applyViaAccessor(accessor) {
    let result = accessor;
    const idAccessor = accessor.getAttribute("_id");
    if (!idAccessor) {
      throw new Error("Cannot apply patch to document with no _id");
    }
    const id4 = idAccessor.get();
    for (const patch2 of this.patches) {
      if (patch2.id !== id4) {
        continue;
      }
      const matcher = Matcher.fromPath(patch2.path).setPayload(patch2);
      result = process3(matcher, result);
    }
    return result;
  }
};
function process3(matcher, accessor) {
  const isSetPatch = matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch;
  let result = accessor;
  const {
    leads,
    delivery
  } = matcher.match(accessor);
  leads.forEach((lead) => {
    if (lead.target.isIndexReference()) {
      lead.target.toIndicies().forEach((i) => {
        const item = result.getIndex(i);
        if (!item) {
          throw new Error("Index out of bounds");
        }
        result = result.setIndexAccessor(i, process3(lead.matcher, item));
      });
    } else if (lead.target.isAttributeReference()) {
      if (isSetPatch && result.containerType() === "primitive") {
        result = result.set({});
      }
      let oldValueAccessor = result.getAttribute(lead.target.name());
      if (!oldValueAccessor && isSetPatch) {
        result = result.setAttribute(lead.target.name(), {});
        oldValueAccessor = result.getAttribute(lead.target.name());
      }
      if (!oldValueAccessor) {
        return;
      }
      const newValueAccessor = process3(lead.matcher, oldValueAccessor);
      if (oldValueAccessor !== newValueAccessor) {
        result = result.setAttributeAccessor(lead.target.name(), newValueAccessor);
      }
    } else {
      throw new Error("Unable to handle target ".concat(lead.target.toString()));
    }
  });
  if (delivery && isPatcher(delivery.payload)) {
    const patch2 = delivery.payload;
    result = patch2.apply(delivery.targets, result);
  }
  return result;
}
function isPatcher(payload) {
  return Boolean(payload && typeof payload === "object" && payload !== null && "apply" in payload && typeof payload.apply === "function");
}
var luid = v4_default;
var debug3 = (0, import_debug4.default)("mutator-document");
var Mutation = class _Mutation {
  constructor(options) {
    this.params = options;
  }
  get transactionId() {
    return this.params.transactionId;
  }
  get transition() {
    return this.params.transition;
  }
  get identity() {
    return this.params.identity;
  }
  get previousRev() {
    return this.params.previousRev;
  }
  get resultRev() {
    return this.params.resultRev;
  }
  get mutations() {
    return this.params.mutations;
  }
  get timestamp() {
    if (typeof this.params.timestamp === "string") {
      return new Date(this.params.timestamp);
    }
    return void 0;
  }
  get effects() {
    return this.params.effects;
  }
  assignRandomTransactionId() {
    this.params.transactionId = luid();
    this.params.resultRev = this.params.transactionId;
  }
  appliesToMissingDocument() {
    if (typeof this._appliesToMissingDocument !== "undefined") {
      return this._appliesToMissingDocument;
    }
    const firstMut = this.mutations[0];
    if (firstMut) {
      this._appliesToMissingDocument = Boolean(firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace);
    } else {
      this._appliesToMissingDocument = true;
    }
    return this._appliesToMissingDocument;
  }
  // Compiles all mutations into a handy function
  compile() {
    const operations = [];
    this.mutations.forEach((mutation) => {
      if (mutation.create) {
        const create = mutation.create || {};
        operations.push((doc) => {
          if (doc) {
            return doc;
          }
          return Object.assign(create, {
            _createdAt: create._createdAt || this.params.timestamp
          });
        });
        return;
      }
      if (mutation.createIfNotExists) {
        const createIfNotExists = mutation.createIfNotExists || {};
        operations.push((doc) => doc === null ? Object.assign(createIfNotExists, {
          _createdAt: createIfNotExists._createdAt || this.params.timestamp
        }) : doc);
        return;
      }
      if (mutation.createOrReplace) {
        const createOrReplace = mutation.createOrReplace || {};
        operations.push(() => Object.assign(createOrReplace, {
          _createdAt: createOrReplace._createdAt || this.params.timestamp
        }));
        return;
      }
      if (mutation.delete) {
        operations.push(() => null);
        return;
      }
      if (mutation.patch) {
        if ("query" in mutation.patch) {
          return;
        }
        const patch2 = new Patcher(mutation.patch);
        operations.push((doc) => patch2.apply(doc));
        return;
      }
      throw new Error("Unsupported mutation ".concat(JSON.stringify(mutation, null, 2)));
    });
    if (typeof this.params.timestamp === "string") {
      operations.push((doc) => {
        return doc ? Object.assign(doc, {
          _updatedAt: this.params.timestamp
        }) : null;
      });
    }
    const prevRev = this.previousRev;
    const rev = this.resultRev || this.transactionId;
    this.compiled = (doc) => {
      if (prevRev && doc && prevRev !== doc._rev) {
        throw new Error("Previous revision for this mutation was ".concat(prevRev, ", but the document revision is ").concat(doc._rev));
      }
      let result = doc;
      for (const operation of operations) {
        result = operation(result);
      }
      if (result && rev) {
        if (result === doc) {
          result = Object.assign({}, doc);
        }
        result._rev = rev;
      }
      return result;
    };
  }
  apply(document2) {
    debug3("Applying mutation %O to document %O", this.mutations, document2);
    if (!this.compiled) {
      this.compile();
    }
    const result = this.compiled(document2);
    debug3("  => %O", result);
    return result;
  }
  static applyAll(document2, mutations) {
    return mutations.reduce((doc, mutation) => mutation.apply(doc), document2);
  }
  // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation
  // any metadata like transactionId is ignored and must be submitted by the client. It is assumed
  // that all mutations are on the same document.
  // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!
  static squash(document2, mutations) {
    const squashed = mutations.reduce((result, mutation) => result.concat(...mutation.mutations), []);
    return new _Mutation({
      mutations: squashed
    });
  }
};
var Document2 = class {
  constructor(doc) {
    this.incoming = [];
    this.submitted = [];
    this.pending = [];
    this.inconsistentAt = null;
    this.lastStagedAt = null;
    this.reset(doc);
    this.HEAD = doc;
    this.EDGE = doc;
  }
  // Reset the state of the Document, used to recover from unsavory states by reloading the document
  reset(doc) {
    this.incoming = [];
    this.submitted = [];
    this.pending = [];
    this.inconsistentAt = null;
    this.HEAD = doc;
    this.EDGE = doc;
    this.considerIncoming();
    this.updateConsistencyFlag();
  }
  // Call when a mutation arrives from Sanity
  arrive(mutation) {
    this.incoming.push(mutation);
    this.considerIncoming();
    this.updateConsistencyFlag();
  }
  // Call to signal that we are submitting a mutation. Returns a callback object with a
  // success and failure handler that must be called according to the outcome of our
  // submission.
  stage(mutation, silent) {
    if (!mutation.transactionId) {
      throw new Error("Mutations _must_ have transactionId when submitted");
    }
    this.lastStagedAt = /* @__PURE__ */ new Date();
    debug3("Staging mutation %s (pushed to pending)", mutation.transactionId);
    this.pending.push(mutation);
    this.EDGE = mutation.apply(this.EDGE);
    if (this.onMutation && !silent) {
      this.onMutation({
        mutation,
        document: this.EDGE,
        remote: false
      });
    }
    const txnId = mutation.transactionId;
    this.updateConsistencyFlag();
    return {
      success: () => {
        this.pendingSuccessfullySubmitted(txnId);
        this.updateConsistencyFlag();
      },
      failure: () => {
        this.pendingFailed(txnId);
        this.updateConsistencyFlag();
      }
    };
  }
  // Call to check if everything is nice and quiet and there are no unresolved mutations.
  // Means this model thinks both HEAD and EDGE is up to date with what the server sees.
  isConsistent() {
    return !this.inconsistentAt;
  }
  // Private
  // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there
  // are applicable patches to be applied
  considerIncoming() {
    let mustRebase = false;
    let nextMut;
    const rebaseMutations = [];
    if (this.HEAD && this.HEAD._updatedAt) {
      const updatedAt = new Date(this.HEAD._updatedAt);
      if (this.incoming.find((mut) => mut.timestamp && mut.timestamp < updatedAt)) {
        this.incoming = this.incoming.filter((mut) => mut.timestamp && mut.timestamp < updatedAt);
      }
    }
    let protect = 0;
    do {
      if (this.HEAD) {
        const HEAD = this.HEAD;
        nextMut = HEAD._rev ? this.incoming.find((mut) => mut.previousRev === HEAD._rev) : void 0;
      } else {
        nextMut = this.incoming.find((mut) => mut.appliesToMissingDocument());
      }
      if (nextMut) {
        const applied = this.applyIncoming(nextMut);
        mustRebase = mustRebase || applied;
        if (mustRebase) {
          rebaseMutations.push(nextMut);
        }
        if (protect++ > 10) {
          throw new Error("Mutator stuck flushing incoming mutations. Probably stuck here: ".concat(JSON.stringify(nextMut)));
        }
      }
    } while (nextMut);
    if (this.incoming.length > 0 && debug3.enabled) {
      debug3("Unable to apply mutations %s", this.incoming.map((mut) => mut.transactionId).join(", "));
    }
    if (mustRebase) {
      this.rebase(rebaseMutations);
    }
  }
  // check current consistency state, update flag and invoke callback if needed
  updateConsistencyFlag() {
    const wasConsistent = this.isConsistent();
    const isConsistent = this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0;
    if (isConsistent) {
      this.inconsistentAt = null;
    } else if (!this.inconsistentAt) {
      this.inconsistentAt = /* @__PURE__ */ new Date();
    }
    if (wasConsistent != isConsistent && this.onConsistencyChanged) {
      if (isConsistent) {
        debug3("Buffered document is inconsistent");
      } else {
        debug3("Buffered document is consistent");
      }
      this.onConsistencyChanged(isConsistent);
    }
  }
  // apply an incoming patch that has been prequalified as the next in line for this document
  applyIncoming(mut) {
    if (!mut) {
      return false;
    }
    if (!mut.transactionId) {
      throw new Error("Received incoming mutation without a transaction ID");
    }
    debug3("Applying mutation %s -> %s to rev %s", mut.previousRev, mut.resultRev, this.HEAD && this.HEAD._rev);
    this.HEAD = mut.apply(this.HEAD);
    if (this.onRemoteMutation) {
      this.onRemoteMutation(mut);
    }
    this.incoming = this.incoming.filter((m2) => m2.transactionId !== mut.transactionId);
    if (this.hasUnresolvedMutations()) {
      const needRebase = this.consumeUnresolved(mut.transactionId);
      if (debug3.enabled) {
        debug3("Incoming mutation ".concat(mut.transactionId, " appeared while there were pending or submitted local mutations"));
        debug3("Submitted txnIds: ".concat(this.submitted.map((m2) => m2.transactionId).join(", ")));
        debug3("Pending txnIds: ".concat(this.pending.map((m2) => m2.transactionId).join(", ")));
        debug3("needRebase === %s", needRebase);
      }
      return needRebase;
    }
    debug3("Remote mutation %s arrived w/o any pending or submitted local mutations", mut.transactionId);
    this.EDGE = this.HEAD;
    if (this.onMutation) {
      this.onMutation({
        mutation: mut,
        document: this.EDGE,
        remote: true
      });
    }
    return false;
  }
  /**
   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have
   * mutations that are still waiting to be either submitted, or to be confirmed by the server.
   *
   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise
   */
  hasUnresolvedMutations() {
    return this.submitted.length > 0 || this.pending.length > 0;
  }
  /**
   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from
   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,
   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in
   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of
   * order in terms of our optimistic version, so a rebase is needed.
   *
   * @param txnId - Transaction ID of the remote mutation
   * @returns true if rebase is needed, false otherwise
   */
  consumeUnresolved(txnId) {
    if (this.submitted.length === 0 && this.pending.length === 0) {
      return false;
    }
    if (this.submitted.length !== 0) {
      if (this.submitted[0].transactionId === txnId) {
        debug3("Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer", txnId);
        this.submitted.shift();
        return false;
      }
    } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) {
      debug3("Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer", txnId);
      this.pending.shift();
      return false;
    }
    debug3("The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d", this.pending.length, this.submitted.length);
    this.submitted = this.submitted.filter((mut) => mut.transactionId !== txnId);
    this.pending = this.pending.filter((mut) => mut.transactionId !== txnId);
    debug3("After scrubbing: Pending: %d, Submitted: %d", this.pending.length, this.submitted.length);
    return true;
  }
  pendingSuccessfullySubmitted(pendingTxnId) {
    if (this.pending.length === 0) {
      return;
    }
    const first2 = this.pending[0];
    if (first2.transactionId === pendingTxnId) {
      this.pending.shift();
      this.submitted.push(first2);
      return;
    }
    let justSubmitted;
    const stillPending = [];
    this.pending.forEach((mutation) => {
      if (mutation.transactionId === pendingTxnId) {
        justSubmitted = mutation;
        return;
      }
      stillPending.push(mutation);
    });
    if (justSubmitted) {
      this.submitted.push(justSubmitted);
    }
    this.pending = stillPending;
    this.rebase([]);
  }
  pendingFailed(pendingTxnId) {
    this.pending = this.pending.filter((mutation) => mutation.transactionId !== pendingTxnId);
    this.rebase([]);
  }
  rebase(incomingMutations) {
    const oldEdge = this.EDGE;
    this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending));
    if (oldEdge !== null && this.EDGE !== null) {
      oldEdge._rev = this.EDGE._rev;
    }
    const changed = !(0, import_isEqual3.default)(this.EDGE, oldEdge);
    if (changed && this.onRebase) {
      this.onRebase(this.EDGE, incomingMutations, this.pending);
    }
  }
};
var SquashingBuffer = class {
  constructor(doc) {
    this.out = [];
    if (doc) {
      debug3("Reset mutation buffer to rev %s", doc._rev);
    } else {
      debug3("Reset mutation buffer state to document being deleted");
    }
    this.staged = [];
    this.setOperations = {};
    this.documentPresent = false;
    this.BASIS = doc;
    this.PRESTAGE = doc;
  }
  add(mut) {
    mut.mutations.forEach((op) => this.addOperation(op));
  }
  hasChanges() {
    return this.out.length > 0 || Object.keys(this.setOperations).length > 0;
  }
  /**
   * Extracts the mutations in this buffer.
   * After this is done, the buffer lifecycle is over and the client should
   * create an new one with the new, updated BASIS.
   *
   * @param txnId - Transaction ID
   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise
   */
  purge(txnId) {
    this.stashStagedOperations();
    let result = null;
    if (this.out.length > 0) {
      debug3("Purged mutation buffer");
      result = new Mutation({
        mutations: this.out,
        resultRev: txnId,
        transactionId: txnId
      });
    }
    this.out = [];
    this.documentPresent = false;
    return result;
  }
  addOperation(op) {
    var _a4;
    if (op.patch && op.patch.set && "id" in op.patch && op.patch.id === ((_a4 = this.PRESTAGE) == null ? void 0 : _a4._id) && Object.keys(op.patch).length === 2) {
      const setPatch2 = op.patch.set;
      const unoptimizable = {};
      for (const path2 of Object.keys(setPatch2)) {
        if (setPatch2.hasOwnProperty(path2)) {
          if (!this.optimiseSetOperation(path2, setPatch2[path2])) {
            unoptimizable[path2] = setPatch2[path2];
          }
        }
      }
      if (Object.keys(unoptimizable).length > 0) {
        debug3("Unoptimizable set-operation detected, purging optimization buffer");
        this.staged.push({
          patch: {
            id: this.PRESTAGE._id,
            set: unoptimizable
          }
        });
        this.stashStagedOperations();
      }
      return;
    }
    if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {
      if (!this.documentPresent) {
        this.staged.push(op);
        this.documentPresent = true;
        this.stashStagedOperations();
      }
      return;
    }
    debug3("Unoptimizable mutation detected, purging optimization buffer");
    this.staged.push(op);
    this.stashStagedOperations();
  }
  /**
     * Attempt to perform one single set operation in an optimised manner, return value
     * reflects whether or not the operation could be performed.
  
     * @param path - The JSONPath to the set operation in question
     * @param nextValue - The value to be set
     * @returns True of optimized, false otherwise
     */
  optimiseSetOperation(path2, nextValue) {
    if (typeof nextValue === "object") {
      return false;
    }
    const matches = extractWithPath(path2, this.PRESTAGE);
    if (matches.length !== 1) {
      return false;
    }
    const match4 = matches[0];
    if (typeof match4.value === "object") {
      return false;
    }
    if (!this.PRESTAGE) {
      return false;
    }
    let op = null;
    if (match4.value === nextValue) {
      op = null;
    } else if (typeof match4.value === "string" && typeof nextValue === "string") {
      try {
        const patch2 = stringify3(make2(match4.value, nextValue));
        op = {
          patch: {
            id: this.PRESTAGE._id,
            diffMatchPatch: {
              [path2]: patch2
            }
          }
        };
      } catch {
        return false;
      }
    } else {
      op = {
        patch: {
          id: this.PRESTAGE._id,
          set: {
            [path2]: nextValue
          }
        }
      };
    }
    const canonicalPath = arrayToJSONMatchPath(match4.path);
    if (op) {
      this.setOperations[canonicalPath] = op;
    } else {
      delete this.setOperations[canonicalPath];
    }
    return true;
  }
  stashStagedOperations() {
    const nextOps = [];
    Object.keys(this.setOperations).forEach((key2) => {
      const op = this.setOperations[key2];
      if (op) {
        nextOps.push(op);
      }
    });
    nextOps.push(...this.staged);
    if (nextOps.length > 0) {
      this.PRESTAGE = new Mutation({
        mutations: nextOps
      }).apply(this.PRESTAGE);
      this.staged = [];
      this.setOperations = {};
    }
    this.out.push(...nextOps);
  }
  /**
   * Rebases given the new base-document
   *
   * @param newBasis - New base document to rebase on
   * @returns New "edge" document with buffered changes integrated
   */
  rebase(newBasis) {
    this.stashStagedOperations();
    if (newBasis === null) {
      this.out = [];
      this.BASIS = newBasis;
      this.PRESTAGE = newBasis;
      this.documentPresent = false;
    } else {
      this.BASIS = newBasis;
      if (this.out) {
        this.PRESTAGE = new Mutation({
          mutations: this.out
        }).apply(this.BASIS);
      } else {
        this.PRESTAGE = this.BASIS;
      }
    }
    return this.PRESTAGE;
  }
};
var ONE_MINUTE = 1e3 * 60;
var Commit = class {
  constructor(mutations, _ref) {
    let {
      resolve,
      reject
    } = _ref;
    this.mutations = mutations;
    this.tries = 0;
    this.resolve = resolve;
    this.reject = reject;
  }
  apply(doc) {
    return Mutation.applyAll(doc, this.mutations);
  }
  squash(doc) {
    const result = Mutation.squash(doc, this.mutations);
    result.assignRandomTransactionId();
    return result;
  }
};
var mutReducerFn = (acc, mut) => acc.concat(mut.mutations);
var BufferedDocument = class {
  constructor(doc) {
    this.committerRunning = false;
    this.buffer = new SquashingBuffer(doc);
    this.document = new Document2(doc);
    this.document.onMutation = (msg2) => this.handleDocMutation(msg2);
    this.document.onRemoteMutation = (mut) => this.onRemoteMutation && this.onRemoteMutation(mut);
    this.document.onRebase = (edge, remoteMutations, localMutations) => this.handleDocRebase(edge, remoteMutations, localMutations);
    this.document.onConsistencyChanged = (msg2) => this.handleDocConsistencyChanged(msg2);
    this.LOCAL = doc;
    this.mutations = [];
    this.commits = [];
  }
  // Used to reset the state of the local document model. If the model has been inconsistent
  // for too long, it has probably missed a notification, and should reload the document from the server
  reset(doc) {
    if (doc) {
      debug3("Document state reset to revision %s", doc._rev);
    } else {
      debug3("Document state reset to being deleted");
    }
    this.document.reset(doc);
    this.rebase([], []);
    this.handleDocConsistencyChanged(this.document.isConsistent());
  }
  // Add a change to the buffer
  add(mutation) {
    if (this.onConsistencyChanged) {
      this.onConsistencyChanged(false);
    }
    debug3("Staged local mutation");
    this.buffer.add(mutation);
    const oldLocal = this.LOCAL;
    this.LOCAL = mutation.apply(this.LOCAL);
    if (this.onMutation && oldLocal !== this.LOCAL) {
      debug3("onMutation fired");
      this.onMutation({
        mutation,
        document: this.LOCAL,
        remote: false
      });
      if (this.LOCAL === null && this.onDelete) {
        this.onDelete(this.LOCAL);
      }
    }
  }
  // Call when a mutation arrives from Sanity
  arrive(mutation) {
    debug3("Remote mutation arrived %s -> %s", mutation.previousRev, mutation.resultRev);
    if (mutation.previousRev === mutation.resultRev) {
      throw new Error("Mutation ".concat(mutation.transactionId, " has previousRev === resultRev (").concat(mutation.previousRev, ")"));
    }
    return this.document.arrive(mutation);
  }
  // Submit all mutations in the buffer to be committed
  commit() {
    return new Promise((resolve, reject) => {
      if (!this.buffer.hasChanges()) {
        resolve();
        return;
      }
      debug3("Committing local changes");
      const pendingMutations = this.buffer.purge();
      this.commits.push(new Commit(pendingMutations ? [pendingMutations] : [], {
        resolve,
        reject
      }));
      this.buffer = new SquashingBuffer(this.LOCAL);
      this.performCommits();
    });
  }
  // Starts the committer that will try to committ all staged commits to the database
  // by calling the commitHandler. Will keep running until all commits are successfully
  // committed.
  performCommits() {
    if (!this.commitHandler) {
      throw new Error("No commitHandler configured for this BufferedDocument");
    }
    if (this.committerRunning) {
      return;
    }
    this._cycleCommitter();
  }
  // TODO: Error handling, right now retries after every error
  _cycleCommitter() {
    const commit2 = this.commits.shift();
    if (!commit2) {
      this.committerRunning = false;
      return;
    }
    this.committerRunning = true;
    const squashed = commit2.squash(this.LOCAL);
    const docResponder = this.document.stage(squashed, true);
    const responder = {
      success: () => {
        debug3("Commit succeeded");
        docResponder.success();
        commit2.resolve();
        this._cycleCommitter();
      },
      failure: () => {
        debug3("Commit failed");
        commit2.tries += 1;
        if (this.LOCAL !== null) {
          this.commits.unshift(commit2);
        }
        docResponder.failure();
        if (commit2.tries < 200) {
          setTimeout(() => this._cycleCommitter(), Math.min(commit2.tries * 1e3, ONE_MINUTE));
        }
      },
      cancel: (error2) => {
        this.commits.forEach((comm) => comm.reject(error2));
        this.commits = [];
        this.reset(this.document.HEAD);
        this.buffer = new SquashingBuffer(this.LOCAL);
        this.committerRunning = false;
      }
    };
    debug3("Posting commit");
    if (this.commitHandler) {
      this.commitHandler({
        mutation: squashed,
        success: responder.success,
        failure: responder.failure,
        cancel: responder.cancel
      });
    }
  }
  handleDocRebase(edge, remoteMutations, localMutations) {
    this.rebase(remoteMutations, localMutations);
  }
  handleDocumentDeleted() {
    debug3("Document deleted");
    if (this.LOCAL !== null && this.onDelete) {
      this.onDelete(this.LOCAL);
    }
    this.commits = [];
    this.mutations = [];
  }
  handleDocMutation(msg2) {
    if (this.commits.length === 0 && !this.buffer.hasChanges()) {
      debug3("Document mutated from remote with no local changes");
      this.LOCAL = this.document.EDGE;
      this.buffer = new SquashingBuffer(this.LOCAL);
      if (this.onMutation) {
        this.onMutation(msg2);
      }
      return;
    }
    debug3("Document mutated from remote with local changes");
    if (this.document.EDGE === null) {
      this.handleDocumentDeleted();
    }
    this.rebase([msg2.mutation], []);
  }
  rebase(remoteMutations, localMutations) {
    debug3("Rebasing document");
    if (this.document.EDGE === null) {
      this.handleDocumentDeleted();
    }
    const oldLocal = this.LOCAL;
    this.LOCAL = this.commits.reduce((doc, commit2) => commit2.apply(doc), this.document.EDGE);
    this.LOCAL = this.buffer.rebase(this.LOCAL);
    if (oldLocal !== null && this.LOCAL !== null) {
      oldLocal._rev = this.LOCAL._rev;
    }
    const changed = !(0, import_isEqual3.default)(this.LOCAL, oldLocal);
    if (changed && this.onRebase) {
      this.onRebase(this.LOCAL, remoteMutations.reduce(mutReducerFn, []), localMutations.reduce(mutReducerFn, []));
    }
  }
  handleDocConsistencyChanged(isConsistent) {
    if (!this.onConsistencyChanged) {
      return;
    }
    const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges();
    if (isConsistent && !hasLocalChanges) {
      this.onConsistencyChanged(true);
    }
    if (!isConsistent) {
      this.onConsistencyChanged(false);
    }
  }
};

// node_modules/sanity/lib/index.esm.js
var import_assignWith = __toESM(require_assignWith());
var import_identity2 = __toESM(require_identity());
var import_values = __toESM(require_values());
var import_json_reduce = __toESM(require_reduce());
init_esm6();

// node_modules/groq-js/dist/1.mjs
var __defProp$52 = Object.defineProperty;
var __defNormalProp$5 = (obj, key2, value) => key2 in obj ? __defProp$52(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField$5 = (obj, key2, value) => {
  __defNormalProp$5(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
function escapeRegExp(string3) {
  return string3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function pathRegExp(pattern) {
  const re = [];
  for (const part of pattern.split(".")) {
    if (part === "*") {
      re.push("[^.]+");
    } else if (part === "**") {
      re.push(".*");
    } else {
      re.push(escapeRegExp(part));
    }
  }
  return new RegExp("^".concat(re.join("."), "$"));
}
var Path2 = class {
  constructor(pattern) {
    __publicField$5(this, "pattern");
    __publicField$5(this, "patternRe");
    this.pattern = pattern;
    this.patternRe = pathRegExp(pattern);
  }
  matches(str) {
    return this.patternRe.test(str);
  }
  toJSON() {
    return this.pattern;
  }
};
var __defProp$42 = Object.defineProperty;
var __defNormalProp$4 = (obj, key2, value) => key2 in obj ? __defProp$42(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField$4 = (obj, key2, value) => {
  __defNormalProp$4(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var StreamValue = class {
  constructor(generator) {
    __publicField$4(this, "type", "stream");
    __publicField$4(this, "generator");
    __publicField$4(this, "ticker");
    __publicField$4(this, "isDone");
    __publicField$4(this, "data");
    this.generator = generator;
    this.ticker = null;
    this.isDone = false;
    this.data = [];
  }
  // eslint-disable-next-line class-methods-use-this
  isArray() {
    return true;
  }
  async get() {
    const result = [];
    for await (const value of this) {
      result.push(await value.get());
    }
    return result;
  }
  async *[Symbol.asyncIterator]() {
    let i = 0;
    while (true) {
      for (; i < this.data.length; i++) {
        yield this.data[i];
      }
      if (this.isDone) {
        return;
      }
      await this._nextTick();
    }
  }
  _nextTick() {
    if (this.ticker) {
      return this.ticker;
    }
    let currentResolver;
    const setupTicker = () => {
      this.ticker = new Promise((resolve) => {
        currentResolver = resolve;
      });
    };
    const tick = () => {
      currentResolver();
      setupTicker();
    };
    const fetch2 = async () => {
      for await (const value of this.generator()) {
        this.data.push(value);
        tick();
      }
      this.isDone = true;
      tick();
    };
    setupTicker();
    fetch2();
    return this.ticker;
  }
};
var RFC3339_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([-+]\d{2}:\d{2}))$/;
function parseRFC3339(str) {
  if (RFC3339_REGEX.test(str)) {
    return new Date(str);
  }
  return null;
}
function formatRFC3339(d) {
  const year = addLeadingZero(d.getUTCFullYear(), 4);
  const month = addLeadingZero(d.getUTCMonth() + 1, 2);
  const day = addLeadingZero(d.getUTCDate(), 2);
  const hour = addLeadingZero(d.getUTCHours(), 2);
  const minute = addLeadingZero(d.getUTCMinutes(), 2);
  const second = addLeadingZero(d.getUTCSeconds(), 2);
  let fractionalSecond = "";
  const millis = d.getMilliseconds();
  if (millis != 0) {
    fractionalSecond = ".".concat(addLeadingZero(millis, 3));
  }
  return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond, "Z");
}
function addLeadingZero(num, targetLength) {
  let str = num.toString();
  while (str.length < targetLength) {
    str = "0".concat(str);
  }
  return str;
}
var __defProp$32 = Object.defineProperty;
var __defNormalProp$3 = (obj, key2, value) => key2 in obj ? __defProp$32(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField$3 = (obj, key2, value) => {
  __defNormalProp$3(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var StaticValue = class {
  constructor(data, type) {
    __publicField$3(this, "data");
    __publicField$3(this, "type");
    this.data = data;
    this.type = type;
  }
  isArray() {
    return this.type === "array";
  }
  // eslint-disable-next-line require-await
  async get() {
    return this.data;
  }
  [Symbol.asyncIterator]() {
    if (Array.isArray(this.data)) {
      return function* (data) {
        for (const element of data) {
          yield fromJS(element);
        }
      }(this.data);
    }
    throw new Error("Cannot iterate over: ".concat(this.type));
  }
};
var NULL_VALUE = new StaticValue(null, "null");
var TRUE_VALUE = new StaticValue(true, "boolean");
var FALSE_VALUE = new StaticValue(false, "boolean");
var DateTime = class _DateTime {
  constructor(date) {
    __publicField$3(this, "date");
    this.date = date;
  }
  static parseToValue(str) {
    const date = parseRFC3339(str);
    if (date) {
      return new StaticValue(new _DateTime(date), "datetime");
    }
    return NULL_VALUE;
  }
  equals(other) {
    return this.date.getTime() == other.date.getTime();
  }
  add(secs) {
    const copy2 = new Date(this.date.getTime());
    copy2.setTime(copy2.getTime() + secs * 1e3);
    return new _DateTime(copy2);
  }
  difference(other) {
    return (this.date.getTime() - other.date.getTime()) / 1e3;
  }
  compareTo(other) {
    return this.date.getTime() - other.date.getTime();
  }
  toString() {
    return formatRFC3339(this.date);
  }
  toJSON() {
    return this.toString();
  }
};
function fromNumber(num) {
  if (Number.isFinite(num)) {
    return new StaticValue(num, "number");
  }
  return NULL_VALUE;
}
function fromString2(str) {
  return new StaticValue(str, "string");
}
function fromDateTime(dt) {
  return new StaticValue(dt, "datetime");
}
function fromPath(path2) {
  return new StaticValue(path2, "path");
}
function isIterator(obj) {
  return obj && typeof obj.next === "function";
}
function fromJS(val) {
  if (isIterator(val)) {
    return new StreamValue(async function* () {
      for await (const value of val) {
        yield fromJS(value);
      }
    });
  } else if (val === null || val === void 0) {
    return NULL_VALUE;
  }
  return new StaticValue(val, getType(val));
}
function getType(data) {
  if (data === null || typeof data === "undefined") {
    return "null";
  }
  if (Array.isArray(data)) {
    return "array";
  }
  if (data instanceof Path2) {
    return "path";
  }
  if (data instanceof DateTime) {
    return "datetime";
  }
  return typeof data;
}
function isEqual5(a, b) {
  if (a.type === "string" && b.type === "string" || a.type === "boolean" && b.type === "boolean" || a.type === "null" && b.type === "null" || a.type === "number" && b.type === "number") {
    return a.data === b.data;
  }
  if (a.type === "datetime" && b.type === "datetime") {
    return a.data.equals(b.data);
  }
  return false;
}
var CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g;
var CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\/?";:{}|[\]+<>\s-])+/g;
var EDGE_CHARS = /(\b\.+|\.+\b)/g;
var MAX_TERM_LENGTH = 1024;
function matchText(tokens, patterns) {
  if (tokens.length === 0 || patterns.length === 0) {
    return false;
  }
  return patterns.every((pattern) => pattern(tokens));
}
function matchTokenize(text) {
  return text.replace(EDGE_CHARS, "").match(CHARS) || [];
}
function matchAnalyzePattern(text) {
  const termsRe = matchPatternRegex(text);
  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));
}
function matchPatternRegex(text) {
  const terms = text.replace(EDGE_CHARS, "").match(CHARS_WITH_WILDCARD) || [];
  return terms.map((term) => new RegExp("^".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\*/g, ".*"), "$"), "i"));
}
async function gatherText(value, cb) {
  if (value.type === "string") {
    cb(value.data);
    return true;
  }
  if (value.isArray()) {
    let success = true;
    for await (const part of value) {
      if (part.type === "string") {
        cb(part.data);
      } else {
        success = false;
      }
    }
    return success;
  }
  return false;
}
var TYPE_ORDER = {
  datetime: 1,
  number: 2,
  string: 3,
  boolean: 4
};
function partialCompare(a, b) {
  const aType = getType(a);
  const bType = getType(b);
  if (aType !== bType) {
    return null;
  }
  switch (aType) {
    case "number":
    case "boolean":
      return a - b;
    case "string":
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    case "datetime":
      return a.compareTo(b);
    default:
      return null;
  }
}
function totalCompare(a, b) {
  const aType = getType(a);
  const bType = getType(b);
  const aTypeOrder = TYPE_ORDER[aType] || 100;
  const bTypeOrder = TYPE_ORDER[bType] || 100;
  if (aTypeOrder !== bTypeOrder) {
    return aTypeOrder - bTypeOrder;
  }
  let result = partialCompare(a, b);
  if (result === null) {
    result = 0;
  }
  return result;
}
var operators = {
  "==": function eq(left, right) {
    return isEqual5(left, right) ? TRUE_VALUE : FALSE_VALUE;
  },
  "!=": function neq(left, right) {
    return isEqual5(left, right) ? FALSE_VALUE : TRUE_VALUE;
  },
  ">": function gt(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result > 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  ">=": function gte(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  "<": function lt(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result < 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  "<=": function lte(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  // eslint-disable-next-line func-name-matching
  in: async function inop(left, right) {
    if (right.type === "path") {
      if (left.type !== "string") {
        return NULL_VALUE;
      }
      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;
    }
    if (right.isArray()) {
      for await (const b of right) {
        if (isEqual5(left, b)) {
          return TRUE_VALUE;
        }
      }
      return FALSE_VALUE;
    }
    return NULL_VALUE;
  },
  match: async function match3(left, right) {
    let tokens = [];
    let patterns = [];
    await gatherText(left, (part) => {
      tokens = tokens.concat(matchTokenize(part));
    });
    const didSucceed = await gatherText(right, (part) => {
      patterns = patterns.concat(matchAnalyzePattern(part));
    });
    if (!didSucceed) {
      return FALSE_VALUE;
    }
    const matched = matchText(tokens, patterns);
    return matched ? TRUE_VALUE : FALSE_VALUE;
  },
  "+": function plus(left, right) {
    if (left.type === "datetime" && right.type === "number") {
      return fromDateTime(left.data.add(right.data));
    }
    if (left.type === "number" && right.type === "number") {
      return fromNumber(left.data + right.data);
    }
    if (left.type === "string" && right.type === "string") {
      return fromString2(left.data + right.data);
    }
    if (left.type === "object" && right.type === "object") {
      return fromJS({
        ...left.data,
        ...right.data
      });
    }
    if (left.type === "array" && right.type === "array") {
      return fromJS(left.data.concat(right.data));
    }
    if (left.isArray() && right.isArray()) {
      return new StreamValue(async function* () {
        for await (const val of left) {
          yield val;
        }
        for await (const val of right) {
          yield val;
        }
      });
    }
    return NULL_VALUE;
  },
  "-": function minus(left, right) {
    if (left.type === "datetime" && right.type === "number") {
      return fromDateTime(left.data.add(-right.data));
    }
    if (left.type === "datetime" && right.type === "datetime") {
      return fromNumber(left.data.difference(right.data));
    }
    if (left.type === "number" && right.type === "number") {
      return fromNumber(left.data - right.data);
    }
    return NULL_VALUE;
  },
  "*": numericOperator((a, b) => a * b),
  "/": numericOperator((a, b) => a / b),
  "%": numericOperator((a, b) => a % b),
  "**": numericOperator((a, b) => Math.pow(a, b))
};
function numericOperator(impl) {
  return function(left, right) {
    if (left.type === "number" && right.type === "number") {
      const result = impl(left.data, right.data);
      return fromNumber(result);
    }
    return NULL_VALUE;
  };
}
var __defProp$22 = Object.defineProperty;
var __defNormalProp$2 = (obj, key2, value) => key2 in obj ? __defProp$22(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField$2 = (obj, key2, value) => {
  __defNormalProp$2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var Scope = class _Scope {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(params, source, value, context, parent) {
    __publicField$2(this, "params");
    __publicField$2(this, "source");
    __publicField$2(this, "value");
    __publicField$2(this, "parent");
    __publicField$2(this, "context");
    __publicField$2(this, "isHidden", false);
    this.params = params;
    this.source = source;
    this.value = value;
    this.context = context;
    this.parent = parent;
  }
  createNested(value) {
    if (this.isHidden) {
      return new _Scope(this.params, this.source, value, this.context, this.parent);
    }
    return new _Scope(this.params, this.source, value, this.context, this);
  }
  createHidden(value) {
    const result = this.createNested(value);
    result.isHidden = true;
    return result;
  }
};
function evaluate(node, scope) {
  let execute2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : evaluate;
  const func = EXECUTORS[node.type];
  return func(node, scope, execute2);
}
function promiselessApply(value, cb) {
  if ("then" in value) {
    return value.then(cb);
  }
  return cb(value);
}
var EXECUTORS = {
  This(_, scope) {
    return scope.value;
  },
  Selector() {
    throw new Error("Selectors can not be evaluated");
  },
  Everything(_, scope) {
    return scope.source;
  },
  Parameter(_ref, scope) {
    let {
      name
    } = _ref;
    return fromJS(scope.params[name]);
  },
  Context(_ref2, scope) {
    let {
      key: key2
    } = _ref2;
    if (key2 === "before" || key2 === "after") {
      const value = scope.context[key2];
      return value || NULL_VALUE;
    }
    throw new Error("unknown context key: ".concat(key2));
  },
  Parent(_ref3, scope) {
    let {
      n
    } = _ref3;
    let current = scope;
    for (let i = 0; i < n; i++) {
      if (!current.parent) {
        return NULL_VALUE;
      }
      current = current.parent;
    }
    return current.value;
  },
  OpCall(_ref4, scope, execute2) {
    let {
      op,
      left,
      right
    } = _ref4;
    const func = operators[op];
    if (!func) {
      throw new Error("Unknown operator: ".concat(op));
    }
    const leftValue = execute2(left, scope);
    const rightValue = execute2(right, scope);
    if ("then" in leftValue || "then" in rightValue) {
      return (async () => func(await leftValue, await rightValue))();
    }
    return func(leftValue, rightValue);
  },
  async Select(_ref5, scope, execute2) {
    let {
      alternatives,
      fallback
    } = _ref5;
    for (const alt of alternatives) {
      const altCond = await execute2(alt.condition, scope);
      if (altCond.type === "boolean" && altCond.data === true) {
        return execute2(alt.value, scope);
      }
    }
    if (fallback) {
      return execute2(fallback, scope);
    }
    return NULL_VALUE;
  },
  async InRange(_ref6, scope, execute2) {
    let {
      base,
      left,
      right,
      isInclusive
    } = _ref6;
    const value = await execute2(base, scope);
    const leftValue = await execute2(left, scope);
    const rightValue = await execute2(right, scope);
    const leftCmp = partialCompare(await value.get(), await leftValue.get());
    if (leftCmp === null) {
      return NULL_VALUE;
    }
    const rightCmp = partialCompare(await value.get(), await rightValue.get());
    if (rightCmp === null) {
      return NULL_VALUE;
    }
    if (isInclusive) {
      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;
    }
    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  async Filter(_ref7, scope, execute2) {
    let {
      base,
      expr
    } = _ref7;
    const baseValue = await execute2(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of baseValue) {
        const newScope = scope.createNested(elem);
        const exprValue = await execute2(expr, newScope);
        if (exprValue.type === "boolean" && exprValue.data === true) {
          yield elem;
        }
      }
    });
  },
  async Projection(_ref8, scope, execute2) {
    let {
      base,
      expr
    } = _ref8;
    const baseValue = await execute2(base, scope);
    if (baseValue.type !== "object") {
      return NULL_VALUE;
    }
    const newScope = scope.createNested(baseValue);
    return execute2(expr, newScope);
  },
  FuncCall(_ref9, scope, execute2) {
    let {
      func,
      args
    } = _ref9;
    return func(args, scope, execute2);
  },
  async PipeFuncCall(_ref10, scope, execute2) {
    let {
      func,
      base,
      args
    } = _ref10;
    const baseValue = await execute2(base, scope);
    return func(baseValue, args, scope, execute2);
  },
  async AccessAttribute(_ref11, scope, execute2) {
    let {
      base,
      name
    } = _ref11;
    let value = scope.value;
    if (base) {
      value = await execute2(base, scope);
    }
    if (value.type === "object") {
      if (value.data.hasOwnProperty(name)) {
        return fromJS(value.data[name]);
      }
    }
    return NULL_VALUE;
  },
  async AccessElement(_ref12, scope, execute2) {
    let {
      base,
      index
    } = _ref12;
    const baseValue = await execute2(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    const data = await baseValue.get();
    const finalIndex = index < 0 ? index + data.length : index;
    return fromJS(data[finalIndex]);
  },
  async Slice(_ref13, scope, execute2) {
    let {
      base,
      left,
      right,
      isInclusive
    } = _ref13;
    const baseValue = await execute2(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    const array3 = await baseValue.get();
    let leftIdx = left;
    let rightIdx = right;
    if (leftIdx < 0) {
      leftIdx = array3.length + leftIdx;
    }
    if (rightIdx < 0) {
      rightIdx = array3.length + rightIdx;
    }
    if (isInclusive) {
      rightIdx++;
    }
    if (leftIdx < 0) {
      leftIdx = 0;
    }
    if (rightIdx < 0) {
      rightIdx = 0;
    }
    return fromJS(array3.slice(leftIdx, rightIdx));
  },
  async Deref(_ref14, scope, execute2) {
    let {
      base
    } = _ref14;
    const value = await execute2(base, scope);
    if (!scope.source.isArray()) {
      return NULL_VALUE;
    }
    if (value.type !== "object") {
      return NULL_VALUE;
    }
    const id4 = value.data._ref;
    if (typeof id4 !== "string") {
      return NULL_VALUE;
    }
    if (scope.context.dereference) {
      return fromJS(await scope.context.dereference({
        _ref: id4
      }));
    }
    for await (const doc of scope.source) {
      if (doc.type === "object" && id4 === doc.data._id) {
        return doc;
      }
    }
    return NULL_VALUE;
  },
  Value(_ref15) {
    let {
      value
    } = _ref15;
    return fromJS(value);
  },
  Group(_ref16, scope, execute2) {
    let {
      base
    } = _ref16;
    return execute2(base, scope);
  },
  async Object(_ref17, scope, execute2) {
    let {
      attributes
    } = _ref17;
    const result = {};
    for (const attr of attributes) {
      const attrType = attr.type;
      switch (attr.type) {
        case "ObjectAttributeValue": {
          const value = await execute2(attr.value, scope);
          result[attr.name] = await value.get();
          break;
        }
        case "ObjectConditionalSplat": {
          const cond = await execute2(attr.condition, scope);
          if (cond.type !== "boolean" || cond.data === false) {
            continue;
          }
          const value = await execute2(attr.value, scope);
          if (value.type === "object") {
            Object.assign(result, value.data);
          }
          break;
        }
        case "ObjectSplat": {
          const value = await execute2(attr.value, scope);
          if (value.type === "object") {
            Object.assign(result, value.data);
          }
          break;
        }
        default:
          throw new Error("Unknown node type: ".concat(attrType));
      }
    }
    return fromJS(result);
  },
  Array(_ref18, scope, execute2) {
    let {
      elements
    } = _ref18;
    return new StreamValue(async function* () {
      for (const element of elements) {
        const value = await execute2(element.value, scope);
        if (element.isSplat) {
          if (value.isArray()) {
            for await (const v of value) {
              yield v;
            }
          }
        } else {
          yield value;
        }
      }
    });
  },
  Tuple() {
    throw new Error("tuples can not be evaluated");
  },
  async Or(_ref19, scope, execute2) {
    let {
      left,
      right
    } = _ref19;
    const leftValue = await execute2(left, scope);
    const rightValue = await execute2(right, scope);
    if (leftValue.type === "boolean") {
      if (leftValue.data === true) {
        return TRUE_VALUE;
      }
    }
    if (rightValue.type === "boolean") {
      if (rightValue.data === true) {
        return TRUE_VALUE;
      }
    }
    if (leftValue.type !== "boolean" || rightValue.type !== "boolean") {
      return NULL_VALUE;
    }
    return FALSE_VALUE;
  },
  async And(_ref20, scope, execute2) {
    let {
      left,
      right
    } = _ref20;
    const leftValue = await execute2(left, scope);
    const rightValue = await execute2(right, scope);
    if (leftValue.type === "boolean") {
      if (leftValue.data === false) {
        return FALSE_VALUE;
      }
    }
    if (rightValue.type === "boolean") {
      if (rightValue.data === false) {
        return FALSE_VALUE;
      }
    }
    if (leftValue.type !== "boolean" || rightValue.type !== "boolean") {
      return NULL_VALUE;
    }
    return TRUE_VALUE;
  },
  async Not(_ref21, scope, execute2) {
    let {
      base
    } = _ref21;
    const value = await execute2(base, scope);
    if (value.type !== "boolean") {
      return NULL_VALUE;
    }
    return value.data ? FALSE_VALUE : TRUE_VALUE;
  },
  Neg(_ref22, scope, execute2) {
    let {
      base
    } = _ref22;
    return promiselessApply(execute2(base, scope), (value) => {
      if (value.type !== "number") {
        return NULL_VALUE;
      }
      return fromNumber(-value.data);
    });
  },
  Pos(_ref23, scope, execute2) {
    let {
      base
    } = _ref23;
    return promiselessApply(execute2(base, scope), (value) => {
      if (value.type !== "number") {
        return NULL_VALUE;
      }
      return fromNumber(value.data);
    });
  },
  Asc() {
    return NULL_VALUE;
  },
  Desc() {
    return NULL_VALUE;
  },
  async ArrayCoerce(_ref24, scope, execute2) {
    let {
      base
    } = _ref24;
    const value = await execute2(base, scope);
    return value.isArray() ? value : NULL_VALUE;
  },
  async Map(_ref25, scope, execute2) {
    let {
      base,
      expr
    } = _ref25;
    const value = await execute2(base, scope);
    if (!value.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of value) {
        const newScope = scope.createHidden(elem);
        yield await execute2(expr, newScope);
      }
    });
  },
  async FlatMap(_ref26, scope, execute2) {
    let {
      base,
      expr
    } = _ref26;
    const value = await execute2(base, scope);
    if (!value.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of value) {
        const newScope = scope.createHidden(elem);
        const innerValue = await execute2(expr, newScope);
        if (innerValue.isArray()) {
          for await (const inner of innerValue) {
            yield inner;
          }
        } else {
          yield innerValue;
        }
      }
    });
  }
};
function evaluateQuery(tree) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const root = fromJS(options.root);
  const dataset2 = fromJS(options.dataset);
  const params = {
    ...options.params
  };
  const scope = new Scope(params, dataset2, root, {
    timestamp: options.timestamp || /* @__PURE__ */ new Date(),
    identity: options.identity === void 0 ? "me" : options.identity,
    sanity: options.sanity,
    after: options.after ? fromJS(options.after) : null,
    before: options.before ? fromJS(options.before) : null,
    dereference: options.dereference
  }, null);
  return evaluate(tree, scope);
}
function canConstantEvaluate(node) {
  switch (node.type) {
    case "Group":
      return canConstantEvaluate(node.base);
    case "Value":
    case "Parameter":
      return true;
    case "Pos":
    case "Neg":
      return canConstantEvaluate(node.base);
    case "OpCall":
      switch (node.op) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "**":
          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);
        default:
          return false;
      }
    default:
      return false;
  }
}
var DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {
  timestamp: /* @__PURE__ */ new Date(0),
  identity: "me",
  before: null,
  after: null
}, null);
function tryConstantEvaluate(node) {
  if (!canConstantEvaluate(node)) {
    return null;
  }
  return constantEvaluate(node);
}
function constantEvaluate(node) {
  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);
  if ("then" in value) {
    throw new Error("BUG: constant evaluate should never return a promise");
  }
  return value;
}
async function portableTextContent(value) {
  if (value.type === "object") {
    return blockText(value.data);
  } else if (value.isArray()) {
    const texts = await arrayText(value);
    if (texts.length > 0) {
      return texts.join("\n\n");
    }
  }
  return null;
}
async function arrayText(value) {
  let result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  for await (const block of value) {
    if (block.type === "object") {
      const text = blockText(block.data);
      if (text !== null)
        result.push(text);
    } else if (block.isArray()) {
      await arrayText(block, result);
    }
  }
  return result;
}
function blockText(obj) {
  if (typeof obj._type !== "string")
    return null;
  const children = obj.children;
  if (!Array.isArray(children))
    return null;
  let result = "";
  for (const child of children) {
    if (child && typeof child === "object" && typeof child._type === "string" && child._type === "span" && typeof child.text === "string") {
      result += child.text;
    }
  }
  return result;
}
var BM25k = 1.2;
async function evaluateScore(node, scope, execute2) {
  if (node.type === "OpCall" && node.op === "match") {
    return evaluateMatchScore(node.left, node.right, scope, execute2);
  }
  if (node.type === "FuncCall" && node.name === "boost") {
    const innerScore = await evaluateScore(node.args[0], scope, execute2);
    const boost2 = await execute2(node.args[1], scope);
    if (boost2.type === "number" && innerScore > 0) {
      return innerScore + boost2.data;
    }
    return 0;
  }
  switch (node.type) {
    case "Or": {
      const leftScore = await evaluateScore(node.left, scope, execute2);
      const rightScore = await evaluateScore(node.right, scope, execute2);
      return leftScore + rightScore;
    }
    case "And": {
      const leftScore = await evaluateScore(node.left, scope, execute2);
      const rightScore = await evaluateScore(node.right, scope, execute2);
      if (leftScore === 0 || rightScore === 0)
        return 0;
      return leftScore + rightScore;
    }
    default: {
      const res = await execute2(node, scope);
      return res.type === "boolean" && res.data === true ? 1 : 0;
    }
  }
}
async function evaluateMatchScore(left, right, scope, execute2) {
  const text = await execute2(left, scope);
  const pattern = await execute2(right, scope);
  let tokens = [];
  let terms = [];
  await gatherText(text, (part) => {
    tokens = tokens.concat(matchTokenize(part));
  });
  const didSucceed = await gatherText(pattern, (part) => {
    terms = terms.concat(matchPatternRegex(part));
  });
  if (!didSucceed) {
    return 0;
  }
  if (tokens.length === 0 || terms.length === 0) {
    return 0;
  }
  let score2 = 0;
  for (const re of terms) {
    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);
    score2 += freq * (BM25k + 1) / (freq + BM25k);
  }
  return score2;
}
function hasReference(value, pathSet) {
  switch (getType(value)) {
    case "array":
      for (const v of value) {
        if (hasReference(v, pathSet)) {
          return true;
        }
      }
      break;
    case "object":
      if (value._ref) {
        return pathSet.has(value._ref);
      }
      for (const v of Object.values(value)) {
        if (hasReference(v, pathSet)) {
          return true;
        }
      }
      break;
  }
  return false;
}
function countUTF8(str) {
  let count2 = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    if (code >= 55296 && code <= 56319) {
      continue;
    }
    count2++;
  }
  return count2;
}
var _global = {};
_global.anywhere = async function anywhere() {
  throw new Error("not implemented");
};
_global.anywhere.arity = 1;
_global.coalesce = async function coalesce(args, scope, execute2) {
  for (const arg of args) {
    const value = await execute2(arg, scope);
    if (value.type !== "null") {
      return value;
    }
  }
  return NULL_VALUE;
};
_global.count = async function count(args, scope, execute2) {
  const inner = await execute2(args[0], scope);
  if (!inner.isArray()) {
    return NULL_VALUE;
  }
  let num = 0;
  for await (const _ of inner) {
    num++;
  }
  return fromNumber(num);
};
_global.count.arity = 1;
_global.dateTime = async function dateTime(args, scope, execute2) {
  const val = await execute2(args[0], scope);
  if (val.type === "datetime") {
    return val;
  }
  if (val.type !== "string") {
    return NULL_VALUE;
  }
  return DateTime.parseToValue(val.data);
};
_global.dateTime.arity = 1;
_global.defined = async function defined(args, scope, execute2) {
  const inner = await execute2(args[0], scope);
  return inner.type === "null" ? FALSE_VALUE : TRUE_VALUE;
};
_global.defined.arity = 1;
_global.identity = async function identity2(args, scope) {
  return fromString2(scope.context.identity);
};
_global.identity.arity = 0;
_global.length = async function length(args, scope, execute2) {
  const inner = await execute2(args[0], scope);
  if (inner.type === "string") {
    return fromNumber(countUTF8(inner.data));
  }
  if (inner.isArray()) {
    let num = 0;
    for await (const _ of inner) {
      num++;
    }
    return fromNumber(num);
  }
  return NULL_VALUE;
};
_global.length.arity = 1;
_global.path = async function path(args, scope, execute2) {
  const inner = await execute2(args[0], scope);
  if (inner.type !== "string") {
    return NULL_VALUE;
  }
  return fromPath(new Path2(inner.data));
};
_global.path.arity = 1;
_global.string = async function string(args, scope, execute2) {
  const value = await execute2(args[0], scope);
  switch (value.type) {
    case "number":
    case "string":
    case "boolean":
    case "datetime":
      return fromString2("".concat(value.data));
    default:
      return NULL_VALUE;
  }
};
_global.string.arity = 1;
_global.references = async function references(args, scope, execute2) {
  const pathSet = /* @__PURE__ */ new Set();
  for (const arg of args) {
    const path2 = await execute2(arg, scope);
    if (path2.type === "string") {
      pathSet.add(path2.data);
    } else if (path2.isArray()) {
      for await (const elem of path2) {
        if (elem.type === "string") {
          pathSet.add(elem.data);
        }
      }
    }
  }
  if (pathSet.size === 0) {
    return FALSE_VALUE;
  }
  const scopeValue = await scope.value.get();
  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;
};
_global.references.arity = (c) => c >= 1;
_global.round = async function round(args, scope, execute2) {
  const value = await execute2(args[0], scope);
  if (value.type !== "number") {
    return NULL_VALUE;
  }
  const num = value.data;
  let prec = 0;
  if (args.length === 2) {
    const precValue = await execute2(args[1], scope);
    if (precValue.type !== "number" || precValue.data < 0 || !Number.isInteger(precValue.data)) {
      return NULL_VALUE;
    }
    prec = precValue.data;
  }
  if (prec === 0) {
    if (num < 0) {
      return fromNumber(-Math.round(-num));
    }
    return fromNumber(Math.round(num));
  }
  return fromNumber(Number(num.toFixed(prec)));
};
_global.round.arity = (count2) => count2 >= 1 && count2 <= 2;
_global.now = async function now(args, scope) {
  return fromString2(scope.context.timestamp.toISOString());
};
_global.now.arity = 0;
_global.boost = async function boost() {
  throw new Error("unexpected boost call");
};
_global.boost.arity = 2;
var string2 = {};
string2.lower = async function(args, scope, execute2) {
  const value = await execute2(args[0], scope);
  if (value.type !== "string") {
    return NULL_VALUE;
  }
  return fromString2(value.data.toLowerCase());
};
string2.lower.arity = 1;
string2.upper = async function(args, scope, execute2) {
  const value = await execute2(args[0], scope);
  if (value.type !== "string") {
    return NULL_VALUE;
  }
  return fromString2(value.data.toUpperCase());
};
string2.upper.arity = 1;
string2.split = async function(args, scope, execute2) {
  const str = await execute2(args[0], scope);
  if (str.type !== "string") {
    return NULL_VALUE;
  }
  const sep = await execute2(args[1], scope);
  if (sep.type !== "string") {
    return NULL_VALUE;
  }
  if (str.data.length === 0) {
    return fromJS([]);
  }
  if (sep.data.length === 0) {
    return fromJS(Array.from(str.data));
  }
  return fromJS(str.data.split(sep.data));
};
string2.split.arity = 2;
_global.lower = string2.lower;
_global.upper = string2.upper;
string2.startsWith = async function(args, scope, execute2) {
  const str = await execute2(args[0], scope);
  if (str.type !== "string") {
    return NULL_VALUE;
  }
  const prefix = await execute2(args[1], scope);
  if (prefix.type !== "string") {
    return NULL_VALUE;
  }
  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;
};
string2.startsWith.arity = 2;
var array2 = {};
array2.join = async function(args, scope, execute2) {
  const arr = await execute2(args[0], scope);
  if (!arr.isArray()) {
    return NULL_VALUE;
  }
  const sep = await execute2(args[1], scope);
  if (sep.type !== "string") {
    return NULL_VALUE;
  }
  let buf = "";
  let needSep = false;
  for await (const elem of arr) {
    if (needSep) {
      buf += sep.data;
    }
    switch (elem.type) {
      case "number":
      case "string":
      case "boolean":
      case "datetime":
        buf += "".concat(elem.data);
        break;
      default:
        return NULL_VALUE;
    }
    needSep = true;
  }
  return fromJS(buf);
};
array2.join.arity = 2;
array2.compact = async function(args, scope, execute2) {
  const arr = await execute2(args[0], scope);
  if (!arr.isArray()) {
    return NULL_VALUE;
  }
  return new StreamValue(async function* () {
    for await (const elem of arr) {
      if (elem.type !== "null") {
        yield elem;
      }
    }
  });
};
array2.compact.arity = 1;
array2.unique = async function(args, scope, execute2) {
  const value = await execute2(args[0], scope);
  if (!value.isArray()) {
    return NULL_VALUE;
  }
  return new StreamValue(async function* () {
    const added = /* @__PURE__ */ new Set();
    for await (const iter of value) {
      switch (iter.type) {
        case "number":
        case "string":
        case "boolean":
        case "datetime":
          if (!added.has(iter.data)) {
            added.add(iter.data);
            yield iter;
          }
          break;
        default:
          yield iter;
      }
    }
  });
};
array2.unique.arity = 1;
var pt = {};
pt.text = async function(args, scope, execute2) {
  const value = await execute2(args[0], scope);
  const text = await portableTextContent(value);
  if (text === null) {
    return NULL_VALUE;
  }
  return fromString2(text);
};
pt.text.arity = 1;
var sanity = {};
sanity.projectId = async function(args, scope) {
  if (scope.context.sanity) {
    return fromString2(scope.context.sanity.projectId);
  }
  return NULL_VALUE;
};
sanity.dataset = async function(args, scope) {
  if (scope.context.sanity) {
    return fromString2(scope.context.sanity.dataset);
  }
  return NULL_VALUE;
};
var pipeFunctions = {};
pipeFunctions.order = async function order(base, args, scope, execute2) {
  await true;
  if (!base.isArray()) {
    return NULL_VALUE;
  }
  const mappers = [];
  const directions = [];
  let n = 0;
  for (let mapper of args) {
    let direction = "asc";
    if (mapper.type === "Desc") {
      direction = "desc";
      mapper = mapper.base;
    } else if (mapper.type === "Asc") {
      mapper = mapper.base;
    }
    mappers.push(mapper);
    directions.push(direction);
    n++;
  }
  const aux = [];
  let idx = 0;
  for await (const value of base) {
    const newScope = scope.createNested(value);
    const tuple = [await value.get(), idx];
    for (let i = 0; i < n; i++) {
      const result = await execute2(mappers[i], newScope);
      tuple.push(await result.get());
    }
    aux.push(tuple);
    idx++;
  }
  aux.sort((aTuple, bTuple) => {
    for (let i = 0; i < n; i++) {
      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);
      if (directions[i] === "desc") {
        c = -c;
      }
      if (c !== 0) {
        return c;
      }
    }
    return aTuple[1] - bTuple[1];
  });
  return fromJS(aux.map((v) => v[0]));
};
pipeFunctions.order.arity = (count2) => count2 >= 1;
pipeFunctions.score = async function score(base, args, scope, execute2) {
  if (!base.isArray())
    return NULL_VALUE;
  const unknown = [];
  const scored = [];
  for await (const value of base) {
    if (value.type !== "object") {
      unknown.push(await value.get());
      continue;
    }
    const newScope = scope.createNested(value);
    let valueScore = typeof value.data._score === "number" ? value.data._score : 0;
    for (const arg of args) {
      valueScore += await evaluateScore(arg, newScope, execute2);
    }
    const newObject = Object.assign({}, value.data, {
      _score: valueScore
    });
    scored.push(newObject);
  }
  scored.sort((a, b) => b._score - a._score);
  return fromJS(scored);
};
pipeFunctions.score.arity = (count2) => count2 >= 1;
var delta = {};
delta.operation = async function(args, scope) {
  const hasBefore = scope.context.before !== null;
  const hasAfter = scope.context.after !== null;
  if (hasBefore && hasAfter) {
    return fromString2("update");
  }
  if (hasAfter) {
    return fromString2("create");
  }
  if (hasBefore) {
    return fromString2("delete");
  }
  return NULL_VALUE;
};
delta.changedAny = () => {
  throw new Error("not implemented");
};
delta.changedAny.arity = 1;
delta.changedAny.mode = "delta";
delta.changedOnly = () => {
  throw new Error("not implemented");
};
delta.changedOnly.arity = 1;
delta.changedOnly.mode = "delta";
var diff3 = {};
diff3.changedAny = () => {
  throw new Error("not implemented");
};
diff3.changedAny.arity = 3;
diff3.changedOnly = () => {
  throw new Error("not implemented");
};
diff3.changedOnly.arity = 3;
var math = {};
math.min = async function(args, scope, execute2) {
  const arr = await execute2(args[0], scope);
  if (!arr.isArray()) {
    return NULL_VALUE;
  }
  let n;
  for await (const elem of arr) {
    if (elem.type === "null")
      continue;
    if (elem.type !== "number") {
      return NULL_VALUE;
    }
    if (n === void 0 || elem.data < n) {
      n = elem.data;
    }
  }
  return fromJS(n);
};
math.min.arity = 1;
math.max = async function(args, scope, execute2) {
  const arr = await execute2(args[0], scope);
  if (!arr.isArray()) {
    return NULL_VALUE;
  }
  let n;
  for await (const elem of arr) {
    if (elem.type === "null")
      continue;
    if (elem.type !== "number") {
      return NULL_VALUE;
    }
    if (n === void 0 || elem.data > n) {
      n = elem.data;
    }
  }
  return fromJS(n);
};
math.max.arity = 1;
math.sum = async function(args, scope, execute2) {
  const arr = await execute2(args[0], scope);
  if (!arr.isArray()) {
    return NULL_VALUE;
  }
  let n = 0;
  for await (const elem of arr) {
    if (elem.type === "null")
      continue;
    if (elem.type !== "number") {
      return NULL_VALUE;
    }
    n += elem.data;
  }
  return fromJS(n);
};
math.sum.arity = 1;
math.avg = async function(args, scope, execute2) {
  const arr = await execute2(args[0], scope);
  if (!arr.isArray()) {
    return NULL_VALUE;
  }
  let n = 0;
  let c = 0;
  for await (const elem of arr) {
    if (elem.type === "null")
      continue;
    if (elem.type !== "number") {
      return NULL_VALUE;
    }
    n += elem.data;
    c++;
  }
  if (c === 0) {
    return NULL_VALUE;
  }
  return fromJS(n / c);
};
math.avg.arity = 1;
var dateTime2 = {};
dateTime2.now = async function now2(args, scope, execute2) {
  return fromDateTime(new DateTime(scope.context.timestamp));
};
dateTime2.now.arity = 0;
var namespaces = {
  global: _global,
  string: string2,
  array: array2,
  pt,
  delta,
  diff: diff3,
  sanity,
  math,
  dateTime: dateTime2
};
var __defProp$12 = Object.defineProperty;
var __defNormalProp$1 = (obj, key2, value) => key2 in obj ? __defProp$12(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField$1 = (obj, key2, value) => {
  __defNormalProp$1(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var MarkProcessor = class {
  constructor(string3, marks, parseOptions2) {
    __publicField$1(this, "string");
    __publicField$1(this, "marks");
    __publicField$1(this, "index");
    __publicField$1(this, "parseOptions");
    __publicField$1(this, "allowBoost", false);
    this.string = string3;
    this.marks = marks;
    this.index = 0;
    this.parseOptions = parseOptions2;
  }
  hasMark() {
    let pos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.index + pos < this.marks.length;
  }
  getMark() {
    let pos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.marks[this.index + pos];
  }
  shift() {
    this.index += 1;
  }
  process(visitor) {
    const mark = this.marks[this.index];
    this.shift();
    const func = visitor[mark.name];
    if (!func) {
      throw new Error("Unknown handler: ".concat(mark.name));
    }
    return func.call(visitor, this, mark);
  }
  processString() {
    this.shift();
    return this.processStringEnd();
  }
  processStringEnd() {
    const prev = this.marks[this.index - 1];
    const curr = this.marks[this.index];
    this.shift();
    return this.string.slice(prev.position, curr.position);
  }
  slice(len) {
    const pos = this.marks[this.index].position;
    return this.string.slice(pos, pos + len);
  }
};
var WS = /^([\t\n\v\f\r \u0085\u00A0]|(\/\/[^\n]*\n))+/;
var NUM = /^\d+/;
var IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;
var PREC_PAIR = 1;
var PREC_OR = 2;
var PREC_AND = 3;
var PREC_COMP = 4;
var PREC_ORDER = 4;
var PREC_ADD = 6;
var PREC_SUB = 6;
var PREC_MUL = 7;
var PREC_DIV = 7;
var PREC_MOD = 7;
var PREC_POW = 8;
var PREC_POS = 10;
var PREC_NOT = 10;
var PREC_NEG = 8;
function parse$1(str) {
  let pos = 0;
  pos = skipWS(str, pos);
  let result = parseExpr(str, pos, 0);
  if (result.type === "error")
    return result;
  pos = skipWS(str, result.position);
  if (pos !== str.length) {
    if (result.failPosition) {
      pos = result.failPosition - 1;
    }
    return {
      type: "error",
      position: pos
    };
  }
  delete result.position;
  delete result.failPosition;
  return result;
}
function parseExpr(str, pos, level) {
  let startPos = pos;
  let token = str[pos];
  let marks;
  switch (token) {
    case "+": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);
      if (rhs.type === "error")
        return rhs;
      marks = [{
        name: "pos",
        position: startPos
      }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "-": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);
      if (rhs.type === "error")
        return rhs;
      marks = [{
        name: "neg",
        position: startPos
      }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "(": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);
      if (rhs.type === "error")
        return rhs;
      pos = skipWS(str, rhs.position);
      switch (str[pos]) {
        case ",": {
          marks = [{
            name: "tuple",
            position: startPos
          }].concat(rhs.marks);
          pos = skipWS(str, pos + 1);
          while (true) {
            rhs = parseExpr(str, pos, 0);
            if (rhs.type === "error")
              return rhs;
            pos = skipWS(str, rhs.position);
            if (str[pos] !== ",")
              break;
            pos = skipWS(str, pos + 1);
          }
          if (str[pos] !== ")")
            return {
              type: "error",
              position: pos
            };
          pos++;
          marks.push({
            name: "tuple_end",
            position: pos
          });
          break;
        }
        case ")": {
          pos++;
          marks = [{
            name: "group",
            position: startPos
          }].concat(rhs.marks);
          break;
        }
        default:
          return {
            type: "error",
            position: pos
          };
      }
      break;
    }
    case "!": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);
      if (rhs.type === "error")
        return rhs;
      marks = [{
        name: "not",
        position: startPos
      }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "{": {
      let result = parseObject(str, pos);
      if (result.type === "error")
        return result;
      marks = result.marks;
      pos = result.position;
      break;
    }
    case "[":
      marks = [{
        name: "array",
        position: pos
      }];
      pos = skipWS(str, pos + 1);
      if (str[pos] !== "]") {
        while (true) {
          if (str.slice(pos, pos + 3) === "...") {
            marks.push({
              name: "array_splat",
              position: pos
            });
            pos = skipWS(str, pos + 3);
          }
          let res = parseExpr(str, pos, 0);
          if (res.type === "error")
            return res;
          marks = marks.concat(res.marks);
          pos = res.position;
          pos = skipWS(str, pos);
          if (str[pos] !== ",")
            break;
          pos = skipWS(str, pos + 1);
          if (str[pos] === "]")
            break;
        }
      }
      if (str[pos] === "]") {
        pos++;
        marks.push({
          name: "array_end",
          position: pos
        });
      } else {
        return {
          type: "error",
          position: pos
        };
      }
      break;
    case "'":
    case '"': {
      let result = parseString(str, pos);
      if (result.type === "error")
        return result;
      marks = result.marks;
      pos = result.position;
      break;
    }
    case "^": {
      pos++;
      marks = [];
      while (str[pos] === "." && str[pos + 1] === "^") {
        marks.push({
          name: "dblparent",
          position: startPos
        });
        pos += 2;
      }
      marks.push({
        name: "parent",
        position: startPos
      });
      break;
    }
    case "@":
      marks = [{
        name: "this",
        position: startPos
      }];
      pos++;
      break;
    case "*":
      marks = [{
        name: "everything",
        position: startPos
      }];
      pos++;
      break;
    case "$": {
      let identLen = parseRegex(str, pos + 1, IDENT);
      if (identLen) {
        pos += 1 + identLen;
        marks = [{
          name: "param",
          position: startPos
        }, {
          name: "ident",
          position: startPos + 1
        }, {
          name: "ident_end",
          position: pos
        }];
      }
      break;
    }
    default: {
      let numLen = parseRegex(str, pos, NUM);
      if (numLen) {
        pos += numLen;
        let name = "integer";
        if (str[pos] === ".") {
          let fracLen = parseRegex(str, pos + 1, NUM);
          if (fracLen) {
            name = "float";
            pos += 1 + fracLen;
          }
        }
        if (str[pos] === "e" || str[pos] === "E") {
          name = "sci";
          pos++;
          if (str[pos] === "+" || str[pos] === "-") {
            pos++;
          }
          let expLen = parseRegex(str, pos, NUM);
          if (!expLen)
            return {
              type: "error",
              position: pos
            };
          pos += expLen;
        }
        marks = [{
          name,
          position: startPos
        }, {
          name: name + "_end",
          position: pos
        }];
        break;
      }
      let identLen = parseRegex(str, pos, IDENT);
      if (identLen) {
        pos += identLen;
        switch (str[pos]) {
          case ":":
          case "(": {
            let result = parseFuncCall(str, startPos, pos);
            if (result.type === "error")
              return result;
            marks = result.marks;
            pos = result.position;
            break;
          }
          default: {
            marks = [{
              name: "this_attr",
              position: startPos
            }, {
              name: "ident",
              position: startPos
            }, {
              name: "ident_end",
              position: pos
            }];
          }
        }
        break;
      }
    }
  }
  if (!marks) {
    return {
      type: "error",
      position: pos
    };
  }
  let lhsLevel = 12;
  let trav;
  loop:
    while (true) {
      let innerPos = skipWS(str, pos);
      if (innerPos === str.length) {
        pos = innerPos;
        break;
      }
      trav = parseTraversal(str, innerPos);
      if (trav.type === "success") {
        marks.unshift({
          name: "traverse",
          position: startPos
        });
        while (trav.type === "success") {
          marks = marks.concat(trav.marks);
          pos = trav.position;
          trav = parseTraversal(str, skipWS(str, pos));
        }
        marks.push({
          name: "traversal_end",
          position: pos
        });
        continue;
      }
      let token2 = str[innerPos];
      switch (token2) {
        case "=": {
          let nextToken = str[innerPos + 1];
          switch (nextToken) {
            case ">": {
              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);
              if (rhs.type === "error")
                return rhs;
              marks = marks.concat(rhs.marks);
              marks.unshift({
                name: "pair",
                position: startPos
              });
              pos = rhs.position;
              lhsLevel = PREC_PAIR;
              break;
            }
            case "=": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);
              if (rhs.type === "error")
                return rhs;
              marks.unshift({
                name: "comp",
                position: startPos
              });
              marks.push({
                name: "op",
                position: innerPos
              }, {
                name: "op_end",
                position: innerPos + 2
              });
              marks = marks.concat(rhs.marks);
              pos = rhs.position;
              lhsLevel = PREC_COMP;
              break;
            }
            default:
              break loop;
          }
          break;
        }
        case "+": {
          if (level > PREC_ADD || lhsLevel < PREC_ADD)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({
            name: "add",
            position: startPos
          });
          pos = rhs.position;
          lhsLevel = PREC_ADD;
          break;
        }
        case "-": {
          if (level > PREC_SUB || lhsLevel < PREC_SUB)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({
            name: "sub",
            position: startPos
          });
          pos = rhs.position;
          lhsLevel = PREC_SUB;
          break;
        }
        case "*": {
          if (str[innerPos + 1] === "*") {
            if (level > PREC_POW || lhsLevel <= PREC_POW)
              break loop;
            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);
            if (rhs2.type === "error")
              return rhs2;
            marks = marks.concat(rhs2.marks);
            marks.unshift({
              name: "pow",
              position: startPos
            });
            pos = rhs2.position;
            lhsLevel = PREC_POW;
            break;
          }
          if (level > PREC_MUL || lhsLevel < PREC_MUL)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({
            name: "mul",
            position: startPos
          });
          pos = rhs.position;
          lhsLevel = PREC_MUL;
          break;
        }
        case "/": {
          if (level > PREC_DIV || lhsLevel < PREC_DIV)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({
            name: "div",
            position: startPos
          });
          pos = rhs.position;
          lhsLevel = PREC_DIV;
          break;
        }
        case "%": {
          if (level > PREC_MOD || lhsLevel < PREC_MOD)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({
            name: "mod",
            position: startPos
          });
          pos = rhs.position;
          lhsLevel = PREC_MOD;
          break;
        }
        case "<":
        case ">": {
          if (level > PREC_COMP || lhsLevel <= PREC_COMP)
            break loop;
          let nextPos = innerPos + 1;
          if (str[nextPos] === "=") {
            nextPos++;
          }
          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);
          if (rhs.type === "error")
            return rhs;
          marks.unshift({
            name: "comp",
            position: startPos
          });
          marks.push({
            name: "op",
            position: innerPos
          }, {
            name: "op_end",
            position: nextPos
          });
          marks = marks.concat(rhs.marks);
          pos = rhs.position;
          lhsLevel = PREC_COMP;
          break;
        }
        case "|": {
          if (str[innerPos + 1] === "|") {
            if (level > PREC_OR || lhsLevel < PREC_OR)
              break loop;
            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);
            if (rhs.type === "error")
              return rhs;
            marks = marks.concat(rhs.marks);
            marks.unshift({
              name: "or",
              position: startPos
            });
            pos = rhs.position;
            lhsLevel = PREC_OR;
          } else {
            if (level > 11 || lhsLevel < 11)
              break loop;
            let identPos = skipWS(str, innerPos + 1);
            let identLen = parseRegex(str, identPos, IDENT);
            if (!identLen)
              return {
                type: "error",
                position: identPos
              };
            pos = identPos + identLen;
            if (str[pos] === "(" || str[pos] === ":") {
              let result = parseFuncCall(str, identPos, pos);
              if (result.type === "error")
                return result;
              marks = marks.concat(result.marks);
              marks.unshift({
                name: "pipecall",
                position: startPos
              });
              pos = result.position;
              lhsLevel = 11;
            }
          }
          break;
        }
        case "&": {
          if (str[innerPos + 1] != "&")
            break loop;
          if (level > PREC_AND || lhsLevel < PREC_AND)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({
            name: "and",
            position: startPos
          });
          pos = rhs.position;
          lhsLevel = PREC_AND;
          break;
        }
        case "!": {
          if (str[innerPos + 1] !== "=")
            break loop;
          if (level > PREC_COMP || lhsLevel <= PREC_COMP)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);
          if (rhs.type === "error")
            return rhs;
          marks.unshift({
            name: "comp",
            position: startPos
          });
          marks.push({
            name: "op",
            position: innerPos
          }, {
            name: "op_end",
            position: innerPos + 2
          });
          marks = marks.concat(rhs.marks);
          pos = rhs.position;
          lhsLevel = PREC_COMP;
          break;
        }
        case "d": {
          if (str.slice(innerPos, innerPos + 4) !== "desc")
            break loop;
          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)
            break loop;
          marks.unshift({
            name: "desc",
            position: startPos
          });
          pos = innerPos + 4;
          lhsLevel = PREC_ORDER;
          break;
        }
        case "a": {
          if (str.slice(innerPos, innerPos + 3) !== "asc")
            break loop;
          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)
            break loop;
          marks.unshift({
            name: "asc",
            position: startPos
          });
          pos = innerPos + 3;
          lhsLevel = PREC_ORDER;
          break;
        }
        default: {
          let ident = parseRegexStr(str, innerPos, IDENT);
          switch (ident) {
            case "in": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              pos = skipWS(str, innerPos + 2);
              let isGroup = false;
              if (str[pos] === "(") {
                isGroup = true;
                pos = skipWS(str, pos + 1);
              }
              let rangePos = pos;
              let result = parseExpr(str, pos, PREC_COMP + 1);
              if (result.type === "error")
                return result;
              pos = skipWS(str, result.position);
              if (str[pos] === "." && str[pos + 1] === ".") {
                let type = "inc_range";
                if (str[pos + 2] === ".") {
                  type = "exc_range";
                  pos = skipWS(str, pos + 3);
                } else {
                  pos = skipWS(str, pos + 2);
                }
                let rhs = parseExpr(str, pos, PREC_COMP + 1);
                if (rhs.type === "error")
                  return rhs;
                marks.unshift({
                  name: "in_range",
                  position: startPos
                });
                marks = marks.concat({
                  name: type,
                  position: rangePos
                }, result.marks, rhs.marks);
                pos = rhs.position;
              } else {
                marks.unshift({
                  name: "comp",
                  position: startPos
                });
                marks.push({
                  name: "op",
                  position: innerPos
                }, {
                  name: "op_end",
                  position: innerPos + 2
                });
                marks = marks.concat(result.marks);
              }
              if (isGroup) {
                pos = skipWS(str, pos);
                if (str[pos] !== ")")
                  return {
                    type: "error",
                    position: pos
                  };
                pos++;
              }
              lhsLevel = PREC_COMP;
              break;
            }
            case "match": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);
              if (rhs.type === "error")
                return rhs;
              marks.unshift({
                name: "comp",
                position: startPos
              });
              marks.push({
                name: "op",
                position: innerPos
              }, {
                name: "op_end",
                position: innerPos + 5
              });
              marks = marks.concat(rhs.marks);
              pos = rhs.position;
              lhsLevel = 4;
              break;
            }
            default: {
              break loop;
            }
          }
        }
      }
    }
  let failPosition = (trav == null ? void 0 : trav.type) === "error" && trav.position;
  return {
    type: "success",
    marks,
    position: pos,
    failPosition
  };
}
function parseTraversal(str, pos) {
  let startPos = pos;
  switch (str[pos]) {
    case ".": {
      pos = skipWS(str, pos + 1);
      let identStart = pos;
      let identLen2 = parseRegex(str, pos, IDENT);
      if (!identLen2)
        return {
          type: "error",
          position: pos
        };
      pos += identLen2;
      return {
        type: "success",
        marks: [{
          name: "attr_access",
          position: startPos
        }, {
          name: "ident",
          position: identStart
        }, {
          name: "ident_end",
          position: pos
        }],
        position: pos
      };
    }
    case "-":
      if (str[pos + 1] !== ">")
        return {
          type: "error",
          position: pos
        };
      let marks = [{
        name: "deref",
        position: startPos
      }];
      pos += 2;
      let identPos = skipWS(str, pos);
      let identLen = parseRegex(str, identPos, IDENT);
      if (identLen) {
        pos = identPos + identLen;
        marks.push({
          name: "deref_attr",
          position: identPos
        }, {
          name: "ident",
          position: identPos
        }, {
          name: "ident_end",
          position: pos
        });
      }
      return {
        type: "success",
        marks,
        position: pos
      };
    case "[": {
      pos = skipWS(str, pos + 1);
      if (str[pos] === "]") {
        return {
          type: "success",
          marks: [{
            name: "array_postfix",
            position: startPos
          }],
          position: pos + 1
        };
      }
      let rangePos = pos;
      let result = parseExpr(str, pos, 0);
      if (result.type === "error")
        return result;
      pos = skipWS(str, result.position);
      if (str[pos] === "." && str[pos + 1] === ".") {
        let type = "inc_range";
        if (str[pos + 2] === ".") {
          type = "exc_range";
          pos += 3;
        } else {
          pos += 2;
        }
        pos = skipWS(str, pos);
        let rhs = parseExpr(str, pos, 0);
        if (rhs.type === "error")
          return rhs;
        pos = skipWS(str, rhs.position);
        if (str[pos] !== "]")
          return {
            type: "error",
            position: pos
          };
        return {
          type: "success",
          marks: [{
            name: "slice",
            position: startPos
          }, {
            name: type,
            position: rangePos
          }].concat(result.marks, rhs.marks),
          position: pos + 1
        };
      }
      if (str[pos] !== "]")
        return {
          type: "error",
          position: pos
        };
      return {
        type: "success",
        marks: [{
          name: "square_bracket",
          position: startPos
        }].concat(result.marks),
        position: pos + 1
      };
    }
    case "|": {
      pos = skipWS(str, pos + 1);
      if (str[pos] === "{") {
        let result = parseObject(str, pos);
        if (result.type === "error")
          return result;
        result.marks.unshift({
          name: "projection",
          position: startPos
        });
        return result;
      }
      break;
    }
    case "{": {
      let result = parseObject(str, pos);
      if (result.type === "error")
        return result;
      result.marks.unshift({
        name: "projection",
        position: startPos
      });
      return result;
    }
  }
  return {
    type: "error",
    position: pos
  };
}
function parseFuncCall(str, startPos, pos) {
  let marks = [];
  marks.push({
    name: "func_call",
    position: startPos
  });
  if (str[pos] === ":" && str[pos + 1] === ":") {
    marks.push({
      name: "namespace",
      position: startPos
    });
    marks.push({
      name: "ident",
      position: startPos
    }, {
      name: "ident_end",
      position: pos
    });
    pos = skipWS(str, pos + 2);
    let nameLen = parseRegex(str, pos, IDENT);
    if (!nameLen)
      return {
        type: "error",
        position: pos
      };
    marks.push({
      name: "ident",
      position: pos
    }, {
      name: "ident_end",
      position: pos + nameLen
    });
    pos = skipWS(str, pos + nameLen);
    if (str[pos] !== "(")
      return {
        type: "error",
        position: pos
      };
    pos++;
    pos = skipWS(str, pos);
  } else {
    marks.push({
      name: "ident",
      position: startPos
    }, {
      name: "ident_end",
      position: pos
    });
    pos = skipWS(str, pos + 1);
  }
  let lastPos = pos;
  if (str[pos] !== ")") {
    while (true) {
      let result = parseExpr(str, pos, 0);
      if (result.type === "error")
        return result;
      marks = marks.concat(result.marks);
      lastPos = result.position;
      pos = skipWS(str, result.position);
      if (str[pos] !== ",")
        break;
      pos = skipWS(str, pos + 1);
      if (str[pos] === ")")
        break;
    }
  }
  if (str[pos] !== ")") {
    return {
      type: "error",
      position: pos
    };
  }
  marks.push({
    name: "func_args_end",
    position: lastPos
  });
  return {
    type: "success",
    marks,
    position: pos + 1
  };
}
function parseObject(str, pos) {
  let marks = [{
    name: "object",
    position: pos
  }];
  pos = skipWS(str, pos + 1);
  while (str[pos] !== "}") {
    let pairPos = pos;
    if (str.slice(pos, pos + 3) === "...") {
      pos = skipWS(str, pos + 3);
      if (str[pos] !== "}" && str[pos] !== ",") {
        let expr = parseExpr(str, pos, 0);
        if (expr.type === "error")
          return expr;
        marks.push({
          name: "object_splat",
          position: pairPos
        });
        marks = marks.concat(expr.marks);
        pos = expr.position;
      } else {
        marks.push({
          name: "object_splat_this",
          position: pairPos
        });
      }
    } else {
      let expr = parseExpr(str, pos, 0);
      if (expr.type === "error")
        return expr;
      let nextPos = skipWS(str, expr.position);
      if (expr.marks[0].name === "str" && str[nextPos] === ":") {
        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);
        if (value.type === "error")
          return value;
        marks.push({
          name: "object_pair",
          position: pairPos
        });
        marks = marks.concat(expr.marks, value.marks);
        pos = value.position;
      } else {
        marks = marks.concat({
          name: "object_expr",
          position: pos
        }, expr.marks);
        pos = expr.position;
      }
    }
    pos = skipWS(str, pos);
    if (str[pos] !== ",")
      break;
    pos = skipWS(str, pos + 1);
  }
  if (str[pos] !== "}") {
    return {
      type: "error",
      position: pos
    };
  }
  pos++;
  marks.push({
    name: "object_end",
    position: pos
  });
  return {
    type: "success",
    marks,
    position: pos
  };
}
function parseString(str, pos) {
  let token = str[pos];
  pos = pos + 1;
  const marks = [{
    name: "str",
    position: pos
  }];
  str:
    for (; ; pos++) {
      if (pos > str.length)
        return {
          type: "error",
          position: pos
        };
      switch (str[pos]) {
        case token: {
          marks.push({
            name: "str_end",
            position: pos
          });
          pos++;
          break str;
        }
        case "\\": {
          marks.push({
            name: "str_pause",
            position: pos
          });
          if (str[pos + 1] === "u") {
            if (str[pos + 2] === "{") {
              marks.push({
                name: "unicode_hex",
                position: pos + 3
              });
              pos = str.indexOf("}", pos + 3);
              marks.push({
                name: "unicode_hex_end",
                position: pos
              });
            } else {
              marks.push({
                name: "unicode_hex",
                position: pos + 2
              });
              marks.push({
                name: "unicode_hex_end",
                position: pos + 6
              });
              pos += 5;
            }
          } else {
            marks.push({
              name: "single_escape",
              position: pos + 1
            });
            pos += 1;
          }
          marks.push({
            name: "str_start",
            position: pos + 1
          });
        }
      }
    }
  return {
    type: "success",
    marks,
    position: pos
  };
}
function skipWS(str, pos) {
  return pos + parseRegex(str, pos, WS);
}
function parseRegex(str, pos, re) {
  let m2 = re.exec(str.slice(pos));
  return m2 ? m2[0].length : 0;
}
function parseRegexStr(str, pos, re) {
  let m2 = re.exec(str.slice(pos));
  return m2 ? m2[0] : null;
}
function join(a, b) {
  return (base) => b(a(base));
}
function map2(inner) {
  return (base) => ({
    type: "Map",
    base,
    expr: inner({
      type: "This"
    })
  });
}
function flatMap3(inner) {
  return (base) => ({
    type: "FlatMap",
    base,
    expr: inner({
      type: "This"
    })
  });
}
function traverseArray(build, right) {
  if (!right) {
    return {
      type: "a-a",
      build
    };
  }
  switch (right.type) {
    case "a-a":
      return {
        type: "a-a",
        build: join(build, right.build)
      };
    case "a-b":
      return {
        type: "a-b",
        build: join(build, right.build)
      };
    case "b-b":
      return {
        type: "a-a",
        build: join(build, map2(right.build))
      };
    case "b-a":
      return {
        type: "a-a",
        build: join(build, flatMap3(right.build))
      };
    default:
      throw new Error("unknown type: ".concat(right.type));
  }
}
function traversePlain(mapper, right) {
  if (!right) {
    return {
      type: "b-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
    case "b-a":
      return {
        type: "b-a",
        build: join(mapper, right.build)
      };
    case "a-b":
    case "b-b":
      return {
        type: "b-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error("unknown type: ".concat(right.type));
  }
}
function traverseElement(mapper, right) {
  if (!right) {
    return {
      type: "a-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
    case "b-a":
      return {
        type: "a-a",
        build: join(mapper, right.build)
      };
    case "a-b":
    case "b-b":
      return {
        type: "a-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error("unknown type: ".concat(right.type));
  }
}
function traverseProjection(mapper, right) {
  if (!right) {
    return {
      type: "b-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
      return {
        type: "a-a",
        build: join(map2(mapper), right.build)
      };
    case "a-b":
      return {
        type: "a-b",
        build: join(map2(mapper), right.build)
      };
    case "b-a":
      return {
        type: "b-a",
        build: join(mapper, right.build)
      };
    case "b-b":
      return {
        type: "b-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error("unknown type: ".concat(right.type));
  }
}
var __defProp3 = Object.defineProperty;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp3(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField2 = (obj, key2, value) => {
  __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var ESCAPE_SEQUENCE = {
  "'": "'",
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
};
function expandHex(str) {
  const charCode = parseInt(str, 16);
  return String.fromCharCode(charCode);
}
var GroqQueryError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField2(this, "name", "GroqQueryError");
  }
};
var EXPR_BUILDER = {
  group(p) {
    const inner = p.process(EXPR_BUILDER);
    return {
      type: "Group",
      base: inner
    };
  },
  everything() {
    return {
      type: "Everything"
    };
  },
  this() {
    return {
      type: "This"
    };
  },
  parent() {
    return {
      type: "Parent",
      n: 1
    };
  },
  dblparent(p) {
    const next = p.process(EXPR_BUILDER);
    return {
      type: "Parent",
      n: next.n + 1
    };
  },
  traverse(p) {
    const base = p.process(EXPR_BUILDER);
    const traversalList = [];
    while (p.getMark().name !== "traversal_end") {
      traversalList.push(p.process(TRAVERSE_BUILDER));
    }
    p.shift();
    let traversal = null;
    for (let i = traversalList.length - 1; i >= 0; i--) {
      traversal = traversalList[i](traversal);
    }
    if (base.type === "Everything" || base.type === "Array" || base.type === "PipeFuncCall") {
      traversal = traverseArray((val) => val, traversal);
    }
    if (traversal === null)
      throw new Error("BUG: unexpected empty traversal");
    return traversal.build(base);
  },
  this_attr(p) {
    const name = p.processString();
    if (name === "null") {
      return {
        type: "Value",
        value: null
      };
    }
    if (name === "true") {
      return {
        type: "Value",
        value: true
      };
    }
    if (name === "false") {
      return {
        type: "Value",
        value: false
      };
    }
    return {
      type: "AccessAttribute",
      name
    };
  },
  neg(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Neg",
      base
    };
  },
  pos(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Pos",
      base
    };
  },
  add(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "+",
      left,
      right
    };
  },
  sub(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "-",
      left,
      right
    };
  },
  mul(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "*",
      left,
      right
    };
  },
  div(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "/",
      left,
      right
    };
  },
  mod(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "%",
      left,
      right
    };
  },
  pow(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "**",
      left,
      right
    };
  },
  comp(p) {
    const left = p.process(EXPR_BUILDER);
    const op = p.processString();
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op,
      left,
      right
    };
  },
  in_range(p) {
    const base = p.process(EXPR_BUILDER);
    const isInclusive = p.getMark().name === "inc_range";
    p.shift();
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "InRange",
      base,
      left,
      right,
      isInclusive
    };
  },
  str(p) {
    let value = "";
    loop:
      while (p.hasMark()) {
        const mark = p.getMark();
        switch (mark.name) {
          case "str_end":
            value += p.processStringEnd();
            break loop;
          case "str_pause":
            value += p.processStringEnd();
            break;
          case "str_start":
            p.shift();
            break;
          case "single_escape": {
            const char = p.slice(1);
            p.shift();
            value += ESCAPE_SEQUENCE[char];
            break;
          }
          case "unicode_hex":
            p.shift();
            value += expandHex(p.processStringEnd());
            break;
          default:
            throw new Error("unexpected mark: ".concat(mark.name));
        }
      }
    return {
      type: "Value",
      value
    };
  },
  integer(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  float(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  sci(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  object(p) {
    const attributes = [];
    while (p.getMark().name !== "object_end") {
      attributes.push(p.process(OBJECT_BUILDER));
    }
    p.shift();
    return {
      type: "Object",
      attributes
    };
  },
  array(p) {
    const elements = [];
    while (p.getMark().name !== "array_end") {
      let isSplat = false;
      if (p.getMark().name === "array_splat") {
        isSplat = true;
        p.shift();
      }
      const value = p.process(EXPR_BUILDER);
      elements.push({
        type: "ArrayElement",
        value,
        isSplat
      });
    }
    p.shift();
    return {
      type: "Array",
      elements
    };
  },
  tuple(p) {
    const members = [];
    while (p.getMark().name !== "tuple_end") {
      members.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    return {
      type: "Tuple",
      members
    };
  },
  func_call(p) {
    let namespace = "global";
    if (p.getMark().name === "namespace") {
      p.shift();
      namespace = p.processString();
    }
    const name = p.processString();
    if (namespace === "global" && name === "select") {
      const result = {
        type: "Select",
        alternatives: []
      };
      while (p.getMark().name !== "func_args_end") {
        if (p.getMark().name === "pair") {
          if (result.fallback)
            throw new GroqQueryError("unexpected argument to select()");
          p.shift();
          const condition = p.process(EXPR_BUILDER);
          const value = p.process(EXPR_BUILDER);
          result.alternatives.push({
            type: "SelectAlternative",
            condition,
            value
          });
        } else {
          if (result.fallback)
            throw new GroqQueryError("unexpected argument to select()");
          const value = p.process(EXPR_BUILDER);
          result.fallback = value;
        }
      }
      p.shift();
      return result;
    }
    const args = [];
    while (p.getMark().name !== "func_args_end") {
      if (argumentShouldBeSelector(namespace, name, args.length)) {
        p.process(SELECTOR_BUILDER);
        args.push({
          type: "Selector"
        });
      } else {
        args.push(p.process(EXPR_BUILDER));
      }
    }
    p.shift();
    if (namespace === "global" && (name === "before" || name === "after")) {
      if (p.parseOptions.mode === "delta") {
        return {
          type: "Context",
          key: name
        };
      }
    }
    if (namespace === "global" && name === "boost" && !p.allowBoost)
      throw new GroqQueryError("unexpected boost");
    const funcs = namespaces[namespace];
    if (!funcs) {
      throw new GroqQueryError("Undefined namespace: ".concat(namespace));
    }
    const func = funcs[name];
    if (!func) {
      throw new GroqQueryError("Undefined function: ".concat(name));
    }
    if (func.arity !== void 0) {
      validateArity(name, func.arity, args.length);
    }
    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {
      throw new GroqQueryError("Undefined function: ".concat(name));
    }
    return {
      type: "FuncCall",
      func,
      namespace,
      name,
      args
    };
  },
  pipecall(p) {
    const base = p.process(EXPR_BUILDER);
    p.shift();
    let namespace = "global";
    if (p.getMark().name === "namespace") {
      p.shift();
      namespace = p.processString();
    }
    if (namespace !== "global") {
      throw new GroqQueryError("Undefined namespace: ".concat(namespace));
    }
    const name = p.processString();
    const args = [];
    const oldAllowBoost = p.allowBoost;
    if (name === "score") {
      p.allowBoost = true;
    }
    for (; ; ) {
      const markName = p.getMark().name;
      if (markName === "func_args_end") {
        break;
      }
      if (name === "order") {
        if (markName === "asc") {
          p.shift();
          args.push({
            type: "Asc",
            base: p.process(EXPR_BUILDER)
          });
          continue;
        } else if (markName === "desc") {
          p.shift();
          args.push({
            type: "Desc",
            base: p.process(EXPR_BUILDER)
          });
          continue;
        }
      }
      args.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    p.allowBoost = oldAllowBoost;
    const func = pipeFunctions[name];
    if (!func) {
      throw new GroqQueryError("Undefined pipe function: ".concat(name));
    }
    if (func.arity) {
      validateArity(name, func.arity, args.length);
    }
    return {
      type: "PipeFuncCall",
      func,
      base,
      name,
      args
    };
  },
  pair(p) {
    throw new GroqQueryError("unexpected =>");
  },
  and(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "And",
      left,
      right
    };
  },
  or(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "Or",
      left,
      right
    };
  },
  not(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Not",
      base
    };
  },
  asc(p) {
    throw new GroqQueryError("unexpected asc");
  },
  desc(p) {
    throw new GroqQueryError("unexpected desc");
  },
  param(p) {
    const name = p.processString();
    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {
      return {
        type: "Value",
        value: p.parseOptions.params[name]
      };
    }
    return {
      type: "Parameter",
      name
    };
  }
};
var OBJECT_BUILDER = {
  object_expr(p) {
    if (p.getMark().name === "pair") {
      p.shift();
      const condition = p.process(EXPR_BUILDER);
      const value2 = p.process(EXPR_BUILDER);
      return {
        type: "ObjectConditionalSplat",
        condition,
        value: value2
      };
    }
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectAttributeValue",
      name: extractPropertyKey(value),
      value
    };
  },
  object_pair(p) {
    const name = p.process(EXPR_BUILDER);
    if (name.type !== "Value")
      throw new Error("name must be string");
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectAttributeValue",
      name: name.value,
      value
    };
  },
  object_splat(p) {
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectSplat",
      value
    };
  },
  object_splat_this() {
    return {
      type: "ObjectSplat",
      value: {
        type: "This"
      }
    };
  }
};
var TRAVERSE_BUILDER = {
  square_bracket(p) {
    const expr = p.process(EXPR_BUILDER);
    const value = tryConstantEvaluate(expr);
    if (value && value.type === "number") {
      return (right) => traverseElement((base) => ({
        type: "AccessElement",
        base,
        index: value.data
      }), right);
    }
    if (value && value.type === "string") {
      return (right) => traversePlain((base) => ({
        type: "AccessAttribute",
        base,
        name: value.data
      }), right);
    }
    return (right) => traverseArray((base) => ({
      type: "Filter",
      base,
      expr
    }), right);
  },
  slice(p) {
    const isInclusive = p.getMark().name === "inc_range";
    p.shift();
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    const leftValue = tryConstantEvaluate(left);
    const rightValue = tryConstantEvaluate(right);
    if (!leftValue || !rightValue || leftValue.type !== "number" || rightValue.type !== "number") {
      throw new GroqQueryError("slicing must use constant numbers");
    }
    return (rhs) => traverseArray((base) => ({
      type: "Slice",
      base,
      left: leftValue.data,
      right: rightValue.data,
      isInclusive
    }), rhs);
  },
  projection(p) {
    const obj = p.process(EXPR_BUILDER);
    return (right) => traverseProjection((base) => ({
      type: "Projection",
      base,
      expr: obj
    }), right);
  },
  attr_access(p) {
    const name = p.processString();
    return (right) => traversePlain((base) => ({
      type: "AccessAttribute",
      base,
      name
    }), right);
  },
  deref(p) {
    let attr = null;
    if (p.getMark().name === "deref_attr") {
      p.shift();
      attr = p.processString();
    }
    const wrap5 = (base) => attr ? {
      type: "AccessAttribute",
      base,
      name: attr
    } : base;
    return (right) => traversePlain((base) => wrap5({
      type: "Deref",
      base
    }), right);
  },
  array_postfix(p) {
    return (right) => traverseArray((base) => ({
      type: "ArrayCoerce",
      base
    }), right);
  }
};
var SELECTOR_BUILDER = {
  group(p) {
    p.process(SELECTOR_BUILDER);
    return null;
  },
  everything() {
    throw new Error("Invalid selector syntax");
  },
  this() {
    throw new Error("Invalid selector syntax");
  },
  parent() {
    throw new Error("Invalid selector syntax");
  },
  dblparent(p) {
    throw new Error("Invalid selector syntax");
  },
  traverse(p) {
    p.process(SELECTOR_BUILDER);
    while (p.getMark().name !== "traversal_end") {
      p.process(TRAVERSE_BUILDER);
    }
    p.shift();
    return null;
  },
  this_attr(p) {
    p.processString();
    return null;
  },
  neg(p) {
    throw new Error("Invalid selector syntax");
  },
  pos(p) {
    throw new Error("Invalid selector syntax");
  },
  add(p) {
    throw new Error("Invalid selector syntax");
  },
  sub(p) {
    throw new Error("Invalid selector syntax");
  },
  mul(p) {
    throw new Error("Invalid selector syntax");
  },
  div(p) {
    throw new Error("Invalid selector syntax");
  },
  mod(p) {
    throw new Error("Invalid selector syntax");
  },
  pow(p) {
    throw new Error("Invalid selector syntax");
  },
  comp(p) {
    throw new Error("Invalid selector syntax");
  },
  in_range(p) {
    throw new Error("Invalid selector syntax");
  },
  str(p) {
    throw new Error("Invalid selector syntax");
  },
  integer(p) {
    throw new Error("Invalid selector syntax");
  },
  float(p) {
    throw new Error("Invalid selector syntax");
  },
  sci(p) {
    throw new Error("Invalid selector syntax");
  },
  object(p) {
    throw new Error("Invalid selector syntax");
  },
  array(p) {
    throw new Error("Invalid selector syntax");
  },
  tuple(p) {
    throw new Error("Invalid selector syntax");
  },
  func_call(p, mark) {
    const func = EXPR_BUILDER.func_call(p, mark);
    if (func.name === "anywhere" && func.args.length === 1)
      return null;
    throw new Error("Invalid selector syntax");
  },
  pipecall(p) {
    throw new Error("Invalid selector syntax");
  },
  pair(p) {
    throw new Error("Invalid selector syntax");
  },
  and(p) {
    throw new Error("Invalid selector syntax");
  },
  or(p) {
    throw new Error("Invalid selector syntax");
  },
  not(p) {
    throw new Error("Invalid selector syntax");
  },
  asc(p) {
    throw new Error("Invalid selector syntax");
  },
  desc(p) {
    throw new Error("Invalid selector syntax");
  },
  param(p) {
    throw new Error("Invalid selector syntax");
  }
};
function extractPropertyKey(node) {
  if (node.type === "AccessAttribute" && !node.base) {
    return node.name;
  }
  if (node.type === "Deref" || node.type === "Map" || node.type === "Projection" || node.type === "Slice" || node.type === "Filter" || node.type === "AccessElement" || node.type === "ArrayCoerce") {
    return extractPropertyKey(node.base);
  }
  throw new GroqQueryError("Cannot determine property key for type: ".concat(node.type));
}
function validateArity(name, arity, count2) {
  if (typeof arity === "number") {
    if (count2 !== arity) {
      throw new GroqQueryError("Incorrect number of arguments to function ".concat(name, "(). Expected ").concat(arity, ", got ").concat(count2, "."));
    }
  } else if (arity) {
    if (!arity(count2)) {
      throw new GroqQueryError("Incorrect number of arguments to function ".concat(name, "()."));
    }
  }
}
function argumentShouldBeSelector(namespace, functionName, argCount) {
  const functionsRequiringSelectors = ["changedAny", "changedOnly"];
  return namespace == "diff" && argCount == 2 && functionsRequiringSelectors.includes(functionName);
}
var GroqSyntaxError = class extends Error {
  constructor(position) {
    super("Syntax error in GROQ query at position ".concat(position));
    __publicField2(this, "position");
    __publicField2(this, "name", "GroqSyntaxError");
    this.position = position;
  }
};
function parse6(input) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const result = parse$1(input);
  if (result.type === "error") {
    throw new GroqSyntaxError(result.position);
  }
  const processor = new MarkProcessor(input, result.marks, options);
  return processor.process(EXPR_BUILDER);
}

// node_modules/sanity/lib/index.esm.js
init_operators2();

// node_modules/mendoza/dist/index.js
var __defProp$13 = Object.defineProperty;
var __defNormalProp$12 = (obj, key2, value) => key2 in obj ? __defProp$13(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField$12 = (obj, key2, value) => {
  __defNormalProp$12(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var OPS = ["Value", "Copy", "Blank", "ReturnIntoArray", "ReturnIntoObject", "ReturnIntoObjectSameKey", "PushField", "PushElement", "PushParent", "Pop", "PushFieldCopy", "PushFieldBlank", "PushElementCopy", "PushElementBlank", "ReturnIntoObjectPop", "ReturnIntoObjectSameKeyPop", "ReturnIntoArrayPop", "ObjectSetFieldValue", "ObjectCopyField", "ObjectDeleteField", "ArrayAppendValue", "ArrayAppendSlice", "StringAppendString", "StringAppendSlice"];
var Patcher2 = class {
  constructor(model, root, patch2) {
    __publicField$12(this, "model");
    __publicField$12(this, "root");
    __publicField$12(this, "patch");
    __publicField$12(this, "i");
    __publicField$12(this, "inputStack");
    __publicField$12(this, "outputStack");
    this.model = model;
    this.root = root;
    this.patch = patch2;
    this.i = 0;
    this.inputStack = [];
    this.outputStack = [];
  }
  read() {
    return this.patch[this.i++];
  }
  process() {
    this.inputStack.push({
      value: this.root
    });
    this.outputStack.push({
      value: this.root
    });
    for (; this.i < this.patch.length; ) {
      let opcode = this.read();
      let op = OPS[opcode];
      if (!op)
        throw new Error("Unknown opcode: ".concat(opcode));
      let processor = "process".concat(op);
      this[processor].apply(this);
    }
    let entry = this.outputStack.pop();
    return this.finalizeOutput(entry);
  }
  inputEntry() {
    return this.inputStack[this.inputStack.length - 1];
  }
  inputKey(entry, idx) {
    if (!entry.keys) {
      entry.keys = this.model.objectGetKeys(entry.value).sort();
    }
    return entry.keys[idx];
  }
  outputEntry() {
    return this.outputStack[this.outputStack.length - 1];
  }
  outputArray() {
    let entry = this.outputEntry();
    if (!entry.writeValue) {
      entry.writeValue = this.model.copyArray(entry.value);
    }
    return entry.writeValue;
  }
  outputObject() {
    let entry = this.outputEntry();
    if (!entry.writeValue) {
      entry.writeValue = this.model.copyObject(entry.value);
    }
    return entry.writeValue;
  }
  outputString() {
    let entry = this.outputEntry();
    if (!entry.writeValue) {
      entry.writeValue = this.model.copyString(entry.value);
    }
    return entry.writeValue;
  }
  finalizeOutput(entry) {
    if (entry.writeValue) {
      return this.model.finalize(entry.writeValue);
    } else {
      return entry.value;
    }
  }
  // Processors:
  processValue() {
    let value = this.model.wrap(this.read());
    this.outputStack.push({
      value
    });
  }
  processCopy() {
    let input = this.inputEntry();
    this.outputStack.push({
      value: input.value
    });
  }
  processBlank() {
    this.outputStack.push({
      value: null
    });
  }
  processReturnIntoArray() {
    let entry = this.outputStack.pop();
    let result = this.finalizeOutput(entry);
    let arr = this.outputArray();
    this.model.arrayAppendValue(arr, result);
  }
  processReturnIntoObject() {
    let key2 = this.read();
    let entry = this.outputStack.pop();
    let result = this.finalizeOutput(entry);
    result = this.model.markChanged(result);
    let obj = this.outputObject();
    this.model.objectSetField(obj, key2, result);
  }
  processReturnIntoObjectSameKey() {
    let input = this.inputEntry();
    let entry = this.outputStack.pop();
    let result = this.finalizeOutput(entry);
    let obj = this.outputObject();
    this.model.objectSetField(obj, input.key, result);
  }
  processPushField() {
    let idx = this.read();
    let entry = this.inputEntry();
    let key2 = this.inputKey(entry, idx);
    let value = this.model.objectGetField(entry.value, key2);
    this.inputStack.push({
      value,
      key: key2
    });
  }
  processPushElement() {
    let idx = this.read();
    let entry = this.inputEntry();
    let value = this.model.arrayGetElement(entry.value, idx);
    this.inputStack.push({
      value
    });
  }
  processPop() {
    this.inputStack.pop();
  }
  processPushFieldCopy() {
    this.processPushField();
    this.processCopy();
  }
  processPushFieldBlank() {
    this.processPushField();
    this.processBlank();
  }
  processPushElementCopy() {
    this.processPushElement();
    this.processCopy();
  }
  processPushElementBlank() {
    this.processPushElement();
    this.processBlank();
  }
  processReturnIntoObjectPop() {
    this.processReturnIntoObject();
    this.processPop();
  }
  processReturnIntoObjectSameKeyPop() {
    this.processReturnIntoObjectSameKey();
    this.processPop();
  }
  processReturnIntoArrayPop() {
    this.processReturnIntoArray();
    this.processPop();
  }
  processObjectSetFieldValue() {
    this.processValue();
    this.processReturnIntoObject();
  }
  processObjectCopyField() {
    this.processPushField();
    this.processCopy();
    this.processReturnIntoObjectSameKey();
    this.processPop();
  }
  processObjectDeleteField() {
    let idx = this.read();
    let entry = this.inputEntry();
    let key2 = this.inputKey(entry, idx);
    let obj = this.outputObject();
    this.model.objectDeleteField(obj, key2);
  }
  processArrayAppendValue() {
    let value = this.model.wrap(this.read());
    let arr = this.outputArray();
    this.model.arrayAppendValue(arr, value);
  }
  processArrayAppendSlice() {
    let left = this.read();
    let right = this.read();
    let str = this.outputArray();
    let val = this.inputEntry().value;
    this.model.arrayAppendSlice(str, val, left, right);
  }
  processStringAppendString() {
    let value = this.model.wrap(this.read());
    let str = this.outputString();
    this.model.stringAppendValue(str, value);
  }
  processStringAppendSlice() {
    let left = this.read();
    let right = this.read();
    let str = this.outputString();
    let val = this.inputEntry().value;
    this.model.stringAppendSlice(str, val, left, right);
  }
};
function utf8charSize(code) {
  if (code >> 16) {
    return 4;
  } else if (code >> 11) {
    return 3;
  } else if (code >> 7) {
    return 2;
  } else {
    return 1;
  }
}
function utf8stringSize(str) {
  let b = 0;
  for (let i = 0; i < str.length; i++) {
    let code = str.codePointAt(i);
    let size2 = utf8charSize(code);
    if (size2 == 4)
      i++;
    b += size2;
  }
  return b;
}
function utf8resolveIndex(str, idx) {
  let start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let byteCount = start;
  let ucsIdx = 0;
  for (ucsIdx = start; byteCount < idx; ucsIdx++) {
    let code = str.codePointAt(ucsIdx);
    let size2 = utf8charSize(code);
    if (size2 === 4)
      ucsIdx++;
    byteCount += size2;
  }
  return ucsIdx;
}
function commonPrefix(str, str2) {
  let len = Math.min(str.length, str2.length);
  let b = 0;
  for (let i = 0; i < len; ) {
    let aPoint = str.codePointAt(i);
    let bPoint = str2.codePointAt(i);
    if (aPoint !== bPoint)
      return b;
    let size2 = utf8charSize(aPoint);
    b += size2;
    i += size2 === 4 ? 2 : 1;
  }
  return b;
}
function commonSuffix(str, str2) {
  let prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let len = Math.min(str.length, str2.length) - prefix;
  let b = 0;
  for (let i = 0; i < len; ) {
    let aPoint = str.codePointAt(str.length - 1 - i);
    let bPoint = str2.codePointAt(str2.length - 1 - i);
    if (aPoint !== bPoint)
      return b;
    let size2 = utf8charSize(aPoint);
    b += size2;
    i += size2 === 4 ? 2 : 1;
  }
  return b;
}
var __defProp4 = Object.defineProperty;
var __defNormalProp3 = (obj, key2, value) => key2 in obj ? __defProp4(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField3 = (obj, key2, value) => {
  __defNormalProp3(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var IncrementalModel = class {
  constructor(meta) {
    __publicField3(this, "meta");
    this.meta = meta;
  }
  wrap(data) {
    return this.wrapWithMeta(data, this.meta, this.meta);
  }
  wrapWithMeta(data, startMeta) {
    let endMeta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.meta;
    return {
      data,
      startMeta,
      endMeta
    };
  }
  asObject(value) {
    if (!value.content) {
      let fields = {};
      for (let [key2, val] of Object.entries(value.data)) {
        fields[key2] = this.wrapWithMeta(val, value.startMeta);
      }
      value.content = {
        type: "object",
        fields
      };
    }
    return value.content;
  }
  asArray(value) {
    if (!value.content) {
      let elements = value.data.map((item) => this.wrapWithMeta(item, value.startMeta));
      let metas = elements.map(() => this.meta);
      value.content = {
        type: "array",
        elements,
        metas
      };
    }
    return value.content;
  }
  asString(value) {
    if (!value.content) {
      let str = value.data;
      let part = {
        value: str,
        utf8size: utf8stringSize(str),
        uses: [],
        startMeta: value.startMeta,
        endMeta: value.endMeta
      };
      value.content = this.stringFromParts([part]);
    }
    return value.content;
  }
  stringFromParts(parts) {
    let str = {
      type: "string",
      parts
    };
    for (let part of parts) {
      part.uses.push(str);
    }
    return str;
  }
  objectGetKeys(value) {
    if (value.content) {
      return Object.keys(value.content.fields);
    } else {
      return Object.keys(value.data);
    }
  }
  objectGetField(value, key2) {
    let obj = this.asObject(value);
    return obj.fields[key2];
  }
  arrayGetElement(value, idx) {
    let arr = this.asArray(value);
    return arr.elements[idx];
  }
  finalize(content) {
    this.updateEndMeta(content);
    return {
      content,
      startMeta: this.meta,
      endMeta: this.meta
    };
  }
  markChanged(value) {
    return this.wrap(unwrap(value));
  }
  updateEndMeta(content) {
    if (content.type == "string") {
      for (let part of content.parts) {
        part.endMeta = this.meta;
      }
    } else {
      if (content.type === "array") {
        for (let val of content.elements) {
          if (val.content && val.endMeta !== this.meta) {
            this.updateEndMeta(val.content);
          }
          val.endMeta = this.meta;
        }
      } else {
        for (let val of Object.values(content.fields)) {
          if (val.content && val.endMeta !== this.meta) {
            this.updateEndMeta(val.content);
          }
          val.endMeta = this.meta;
        }
      }
    }
  }
  copyString(value) {
    if (value) {
      let other = this.asString(value);
      return this.stringFromParts(other.parts.slice());
    } else {
      return {
        type: "string",
        parts: []
      };
    }
  }
  copyObject(value) {
    let obj = {
      type: "object",
      fields: {}
    };
    if (value) {
      let other = this.asObject(value);
      Object.assign(obj.fields, other.fields);
    }
    return obj;
  }
  copyArray(value) {
    let arr = value ? this.asArray(value) : null;
    let elements = arr ? arr.elements : [];
    let metas = arr ? arr.metas : [];
    return {
      type: "array",
      elements,
      metas
    };
  }
  objectSetField(target, key2, value) {
    target.fields[key2] = value;
  }
  objectDeleteField(target, key2) {
    delete target.fields[key2];
  }
  arrayAppendValue(target, value) {
    target.elements.push(value);
    target.metas.push(this.meta);
  }
  arrayAppendSlice(target, source, left, right) {
    let arr = this.asArray(source);
    let samePosition = arr.elements.length === left;
    target.elements.push(...arr.elements.slice(left, right));
    if (samePosition) {
      target.metas.push(...arr.metas.slice(left, right));
    } else {
      for (let i = left; i < right; i++) {
        target.metas.push(this.meta);
      }
    }
  }
  stringAppendValue(target, value) {
    let str = this.asString(value);
    for (let part of str.parts) {
      this.stringAppendPart(target, part);
    }
  }
  stringAppendPart(target, part) {
    target.parts.push(part);
    part.uses.push(target);
  }
  resolveStringPart(str, from2, len) {
    if (len === 0)
      return from2;
    for (let i = from2; i < str.parts.length; i++) {
      let part = str.parts[i];
      if (len === part.utf8size) {
        return i + 1;
      }
      if (len < part.utf8size) {
        this.splitString(part, len);
        return i + 1;
      }
      len -= part.utf8size;
    }
    throw new Error("splitting string out of bounds");
  }
  splitString(part, idx) {
    let leftValue;
    let rightValue;
    let leftSize = idx;
    let rightSize = part.utf8size - leftSize;
    if (part.utf8size !== part.value.length) {
      let byteCount = 0;
      for (idx = 0; byteCount < leftSize; idx++) {
        let code = part.value.codePointAt(idx);
        let size2 = utf8charSize(code);
        if (size2 === 4)
          idx++;
        byteCount += size2;
      }
    }
    leftValue = part.value.slice(0, idx);
    rightValue = part.value.slice(idx);
    let newPart = {
      value: rightValue,
      utf8size: rightSize,
      uses: part.uses.slice(),
      startMeta: part.startMeta,
      endMeta: part.endMeta
    };
    part.value = leftValue;
    part.utf8size = leftSize;
    for (let use2 of part.uses) {
      let ndx = use2.parts.indexOf(part);
      if (ndx === -1)
        throw new Error("bug: mismatch between string parts and use.");
      use2.parts.splice(ndx + 1, 0, newPart);
    }
  }
  stringAppendSlice(target, source, left, right) {
    let str = this.asString(source);
    let firstPart = this.resolveStringPart(str, 0, left);
    let lastPart = this.resolveStringPart(str, firstPart, right - left);
    for (let i = firstPart; i < lastPart; i++) {
      let part = str.parts[i];
      this.stringAppendPart(target, part);
    }
  }
};
function wrap2(data, meta) {
  return {
    data,
    startMeta: meta,
    endMeta: meta
  };
}
function unwrap(value) {
  if (typeof value.data !== "undefined")
    return value.data;
  let result;
  let content = value.content;
  switch (content.type) {
    case "string":
      result = content.parts.map((part) => part.value).join("");
      break;
    case "array":
      result = content.elements.map((val) => unwrap(val));
      break;
    case "object": {
      result = {};
      for (let [key2, val] of Object.entries(content.fields)) {
        result[key2] = unwrap(val);
      }
    }
  }
  value.data = result;
  return result;
}
function getType2(value) {
  if (value.content)
    return value.content.type;
  if (Array.isArray(value.data))
    return "array";
  if (value.data === null)
    return "null";
  return typeof value.data;
}
function rebaseValue(left, right) {
  let leftType = getType2(left);
  let rightType = getType2(right);
  if (leftType !== rightType)
    return right;
  let leftModel = new IncrementalModel(left.endMeta);
  let rightModel = new IncrementalModel(right.endMeta);
  switch (leftType) {
    case "object": {
      let leftObj = leftModel.asObject(left);
      let rightObj = rightModel.asObject(right);
      let identicalFieldCount = 0;
      let leftFieldCount = Object.keys(leftObj.fields).length;
      let rightFieldCount = Object.keys(rightObj.fields).length;
      for (let [key2, rightVal] of Object.entries(rightObj.fields)) {
        let leftVal = leftObj.fields[key2];
        if (leftVal) {
          rightObj.fields[key2] = rebaseValue(leftVal, rightVal);
          if (rightObj.fields[key2] === leftVal) {
            identicalFieldCount++;
          }
        }
      }
      let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;
      return isIdentical ? left : right;
    }
    case "array": {
      let leftArr = leftModel.asArray(left);
      let rightArr = rightModel.asArray(right);
      if (leftArr.elements.length !== rightArr.elements.length) {
        break;
      }
      let numRebased = 0;
      for (let i = 0; i < rightArr.elements.length; i++) {
        rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);
        if (rightArr.elements[i] !== leftArr.elements[i]) {
          numRebased++;
        }
      }
      return numRebased === 0 ? left : right;
    }
    case "null":
    case "boolean":
    case "number": {
      if (unwrap(left) === unwrap(right))
        return left;
      break;
    }
    case "string": {
      let leftRaw = unwrap(left);
      let rightRaw = unwrap(right);
      if (leftRaw === rightRaw)
        return left;
      let result = rightModel.copyString(null);
      let prefix = commonPrefix(leftRaw, rightRaw);
      let suffix = commonSuffix(leftRaw, rightRaw, prefix);
      let rightLen = utf8stringSize(rightRaw);
      let leftLen = utf8stringSize(leftRaw);
      if (0 < prefix) {
        rightModel.stringAppendSlice(result, left, 0, prefix);
      }
      if (prefix < rightLen - suffix) {
        rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);
      }
      if (leftLen - suffix < leftLen) {
        rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
      }
      let value = rightModel.finalize(result);
      if (unwrap(value) !== rightRaw)
        throw new Error("incorrect string rebase");
      return value;
    }
  }
  return right;
}
function applyPatch$1(left, patch2, startMeta) {
  let model = new IncrementalModel(startMeta);
  let patcher = new Patcher2(model, left, patch2);
  return patcher.process();
}
var incrementalPatcher = Object.freeze({
  __proto__: null,
  applyPatch: applyPatch$1,
  getType: getType2,
  rebaseValue,
  unwrap,
  wrap: wrap2
});
var SimpleModel = class {
  wrap(data) {
    return data;
  }
  finalize(b) {
    if (Array.isArray(b)) {
      return b;
    } else {
      return b.data;
    }
  }
  markChanged(value) {
    return value;
  }
  objectGetKeys(value) {
    return Object.keys(value);
  }
  objectGetField(value, key2) {
    return value[key2];
  }
  arrayGetElement(value, idx) {
    return value[idx];
  }
  copyObject(value) {
    let res = {
      type: "object",
      data: {}
    };
    if (value !== null) {
      for (let [key2, val] of Object.entries(value)) {
        res.data[key2] = val;
      }
    }
    return res;
  }
  copyArray(value) {
    if (value === null)
      return [];
    return value.slice();
  }
  copyString(value) {
    return {
      type: "string",
      data: value === null ? "" : value
    };
  }
  objectSetField(target, key2, value) {
    target.data[key2] = value;
  }
  objectDeleteField(target, key2) {
    delete target.data[key2];
  }
  arrayAppendValue(target, value) {
    target.push(value);
  }
  arrayAppendSlice(target, source, left, right) {
    target.push(...source.slice(left, right));
  }
  stringAppendSlice(target, source, left, right) {
    const sourceString = source;
    const leftPos = utf8resolveIndex(sourceString, left);
    const rightPos = utf8resolveIndex(sourceString, right, leftPos);
    target.data += sourceString.slice(leftPos, rightPos);
  }
  stringAppendValue(target, value) {
    target.data += value;
  }
};
function applyPatch3(left, patch2) {
  let root = left;
  let patcher = new Patcher2(new SimpleModel(), root, patch2);
  return patcher.process();
}

// node_modules/@sanity/diff/lib/index.esm.js
function replaceProperty(parent, prop, value) {
  delete parent[prop];
  parent[prop] = value;
  return value;
}
function getLongestCommonSubsequence(previous, next) {
  const matrix = getLengthMatrix(previous, next);
  const result = backtrack(matrix, previous, next);
  return result;
}
function getLengthMatrix(previous, next) {
  const len1 = previous.length;
  const len2 = next.length;
  let x = 0;
  let y = 0;
  const matrix = new Array(len1 + 1);
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (previous[x - 1] === next[y - 1]) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
}
function backtrack(matrix, previous, next) {
  let prevIndex = previous.length;
  let nextIndex = next.length;
  const subsequence = {
    sequence: [],
    prevIndices: [],
    nextIndices: []
  };
  while (prevIndex !== 0 && nextIndex !== 0) {
    const areEqual = previous[prevIndex - 1] === next[nextIndex - 1];
    if (areEqual) {
      subsequence.sequence.unshift(previous[prevIndex - 1]);
      subsequence.prevIndices.unshift(prevIndex - 1);
      subsequence.nextIndices.unshift(nextIndex - 1);
      --prevIndex;
      --nextIndex;
    } else {
      const valueAtMatrixAbove = matrix[prevIndex][nextIndex - 1];
      const valueAtMatrixLeft = matrix[prevIndex - 1][nextIndex];
      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --nextIndex;
      } else {
        --prevIndex;
      }
    }
  }
  return subsequence;
}
function diffArray2(fromInput, toInput, options) {
  if (fromInput === toInput) {
    const fromValue = fromInput.value;
    const toValue = toInput.value;
    return {
      type: "array",
      action: "unchanged",
      isChanged: false,
      fromValue,
      toValue,
      get items() {
        const items2 = diffExactByPosition(fromInput, toInput, options);
        if (!items2)
          throw new Error("invariant broken: equivalent input, but diff detected");
        return replaceProperty(this, "items", items2);
      }
    };
  }
  const keyedA = indexByKey2(fromInput);
  const keyedB = indexByKey2(toInput);
  if (keyedA && keyedB) {
    return diffArrayByKey2(fromInput, keyedA, toInput, keyedB);
  }
  const items = diffExactByPosition(fromInput, toInput, options);
  if (items)
    return buildArrayDiff(fromInput, toInput, items, false);
  return diffArrayByReinsert(fromInput, toInput);
}
function buildArrayDiff(fromInput, toInput, items, isChanged) {
  const fromValue = fromInput.value;
  const toValue = toInput.value;
  return isChanged ? {
    type: "array",
    action: "changed",
    isChanged: true,
    fromValue,
    toValue,
    items,
    annotation: toInput.annotation
  } : {
    type: "array",
    action: "unchanged",
    isChanged: false,
    fromValue,
    toValue,
    items
  };
}
function diffExactByPosition(fromInput, toInput, options) {
  if (fromInput.length !== toInput.length) {
    return void 0;
  }
  const items = [];
  for (let idx = 0; idx < fromInput.length; idx++) {
    const diff4 = diffInput(fromInput.at(idx), toInput.at(idx), options);
    if (diff4.isChanged) {
      return void 0;
    }
    items.push({
      fromIndex: idx,
      toIndex: idx,
      hasMoved: false,
      diff: diff4,
      annotation: toInput.annotationAt(idx)
    });
  }
  return items;
}
function diffArrayByReinsert(fromInput, toInput, options) {
  const items = [];
  for (let idx = 0; idx < toInput.length; idx++) {
    const input = toInput.at(idx);
    items.push({
      fromIndex: void 0,
      toIndex: idx,
      hasMoved: false,
      diff: addedInput(input, void 0),
      annotation: input.annotation
    });
  }
  for (let idx = 0; idx < fromInput.length; idx++) {
    const input = fromInput.at(idx);
    items.push({
      fromIndex: idx,
      toIndex: void 0,
      hasMoved: false,
      diff: removedInput(input, void 0),
      annotation: input.annotation
    });
  }
  return buildArrayDiff(fromInput, toInput, items, true);
}
function diffArrayByKey2(fromArray, fromKeyIndex, toArray3, toKeyIndex, options) {
  const items = [];
  let isChanged = false;
  function diffCommon(key2, fromIndex, toIndex, hasMoved) {
    deletePositionInIndex(fromKeyIndex.index, key2, fromIndex);
    deletePositionInIndex(toKeyIndex.index, key2, toIndex);
    const fromInput = fromArray.at(fromIndex);
    const toInput = toArray3.at(toIndex);
    const diff4 = diffInput(fromInput, toInput);
    items.push({
      fromIndex,
      toIndex,
      hasMoved,
      diff: diff4,
      annotation: toArray3.annotationAt(toIndex)
    });
    if (diff4.isChanged || fromIndex !== toIndex) {
      isChanged = true;
    }
  }
  const lcs = getLongestCommonSubsequence(fromKeyIndex.keys, toKeyIndex.keys);
  for (let fromIndex = 0; fromIndex < fromKeyIndex.keys.length; fromIndex++) {
    const key2 = fromKeyIndex.keys[fromIndex];
    const subsequenceIdx = lcs.prevIndices.indexOf(fromIndex);
    if (subsequenceIdx !== -1) {
      diffCommon(key2, fromIndex, lcs.nextIndices[subsequenceIdx], false);
      continue;
    }
    const toIndexes = toKeyIndex.index.get(key2);
    const toIndex = toIndexes && toIndexes.find((idx) => !lcs.nextIndices.includes(idx));
    if (toIndex !== void 0) {
      diffCommon(key2, fromIndex, toIndex, true);
      continue;
    }
    const input = fromArray.at(fromIndex);
    items.push({
      fromIndex,
      toIndex: void 0,
      hasMoved: false,
      diff: removedInput(input, void 0),
      annotation: fromArray.annotationAt(fromIndex)
    });
    isChanged = true;
  }
  for (const positions of toKeyIndex.index.values()) {
    for (const toIndex of positions) {
      const input = toArray3.at(toIndex);
      items.push({
        fromIndex: void 0,
        toIndex,
        hasMoved: false,
        diff: addedInput(input, void 0),
        annotation: toArray3.annotationAt(toIndex)
      });
    }
    isChanged = true;
  }
  items.sort(compareItemDiff);
  return buildArrayDiff(fromArray, toArray3, items, isChanged);
}
function compareItemDiff(a, b) {
  if (a.toIndex !== void 0 && b.toIndex !== void 0) {
    return a.toIndex - b.toIndex;
  }
  if (a.fromIndex !== void 0 && b.fromIndex !== void 0) {
    return a.fromIndex - b.fromIndex;
  }
  if (a.fromIndex !== void 0 && b.toIndex !== void 0) {
    return -1;
  }
  if (a.toIndex !== void 0 && b.fromIndex !== void 0) {
    return 1;
  }
  throw new Error("invalid item diff comparison");
}
function deletePositionInIndex(index, key2, pos) {
  const positions = index.get(key2);
  deleteArrayValue(positions, pos);
  if (positions.length === 0) {
    index.delete(key2);
  }
}
function deleteArrayValue(arr, value) {
  const idx = arr.indexOf(value);
  if (idx === -1)
    throw new Error("value not found");
  arr.splice(idx, 1);
}
function indexByKey2(arr) {
  const index = /* @__PURE__ */ new Map();
  const keys = [];
  const length2 = arr.length;
  for (let i = 0; i < length2; i++) {
    const item = arr.at(i);
    let key2 = null;
    switch (item.type) {
      case "string":
        key2 = "s".concat(item.value);
        break;
      case "number":
        key2 = item.value;
        break;
      case "boolean":
        key2 = item.value;
        break;
      case "null":
        key2 = "n";
        break;
      case "object":
        {
          const keyField = item.get("_key");
          if (keyField && keyField.type === "string") {
            key2 = "k".concat(keyField.value);
            if (index.has(key2))
              return void 0;
          }
        }
        break;
    }
    if (key2 === null)
      return void 0;
    keys.push(key2);
    let positions = index.get(key2);
    if (!positions) {
      positions = [];
      index.set(key2, positions);
    }
    positions.push(i);
  }
  return {
    keys,
    index
  };
}
function removedArray(input, toValue, options) {
  return {
    type: "array",
    action: "removed",
    isChanged: true,
    fromValue: input.value,
    toValue,
    annotation: input.annotation,
    get items() {
      const items = [];
      for (let i = 0; i < input.length; i++) {
        const item = input.at(i);
        items.push({
          fromIndex: i,
          toIndex: void 0,
          hasMoved: false,
          diff: removedInput(item, void 0),
          annotation: input.annotationAt(i)
        });
      }
      return replaceProperty(this, "items", items);
    }
  };
}
function addedArray(input, fromValue, options) {
  return {
    type: "array",
    action: "added",
    isChanged: true,
    fromValue,
    toValue: input.value,
    annotation: input.annotation,
    get items() {
      const items = [];
      for (let i = 0; i < input.length; i++) {
        const item = input.at(i);
        items.push({
          fromIndex: void 0,
          toIndex: i,
          hasMoved: false,
          diff: addedInput(item, void 0),
          annotation: input.annotationAt(i)
        });
      }
      return replaceProperty(this, "items", items);
    }
  };
}
function diffString(fromInput, toInput, options) {
  const fromValue = fromInput.value;
  const toValue = toInput.value;
  if (fromValue === toValue) {
    return {
      type: "string",
      action: "unchanged",
      isChanged: false,
      fromValue,
      toValue,
      segments: [{
        type: "stringSegment",
        action: "unchanged",
        text: fromValue
      }]
    };
  }
  return {
    type: "string",
    action: "changed",
    isChanged: true,
    fromValue,
    toValue,
    annotation: toInput.annotation,
    // Compute and memoize string segments only when accessed
    get segments() {
      const segments = buildSegments(fromInput, toInput);
      return replaceProperty(this, "segments", segments);
    }
  };
}
function buildSegments(fromInput, toInput) {
  const segments = [];
  const dmpDiffs = cleanupSemantic2(diff2(fromInput.value, toInput.value));
  let fromIdx = 0;
  let toIdx = 0;
  for (const [op, text] of dmpDiffs) {
    switch (op) {
      case DIFF_EQUAL2:
        segments.push({
          type: "stringSegment",
          action: "unchanged",
          text
        });
        fromIdx += text.length;
        toIdx += text.length;
        break;
      case DIFF_DELETE2:
        for (const segment of fromInput.sliceAnnotation(fromIdx, fromIdx + text.length)) {
          segments.push({
            type: "stringSegment",
            action: "removed",
            text: segment.text,
            annotation: segment.annotation
          });
        }
        fromIdx += text.length;
        break;
      case DIFF_INSERT2:
        for (const segment of toInput.sliceAnnotation(toIdx, toIdx + text.length)) {
          segments.push({
            type: "stringSegment",
            action: "added",
            text: segment.text,
            annotation: segment.annotation
          });
        }
        toIdx += text.length;
        break;
      default:
        throw new Error('Unhandled diff-match-patch operation "'.concat(op, '"'));
    }
  }
  return segments;
}
function removedString(input, toValue, options) {
  return {
    type: "string",
    action: "removed",
    isChanged: true,
    fromValue: input.value,
    toValue,
    annotation: input.annotation,
    get segments() {
      const segments = input.sliceAnnotation(0, input.value.length).map((segment) => ({
        type: "stringSegment",
        action: "removed",
        ...segment
      }));
      return replaceProperty(this, "segments", segments);
    }
  };
}
function addedString(input, fromValue, options) {
  return {
    type: "string",
    action: "added",
    isChanged: true,
    fromValue,
    toValue: input.value,
    annotation: input.annotation,
    get segments() {
      const segments = input.sliceAnnotation(0, input.value.length).map((segment) => ({
        type: "stringSegment",
        action: "added",
        ...segment
      }));
      return replaceProperty(this, "segments", segments);
    }
  };
}
function diffTypeChange(fromInput, toInput, options) {
  return {
    type: "typeChange",
    action: "changed",
    isChanged: true,
    fromType: fromInput.type,
    fromValue: fromInput.value,
    fromDiff: removedInput(fromInput, void 0),
    toType: toInput.type,
    toValue: toInput.value,
    toDiff: addedInput(toInput, void 0),
    annotation: toInput.annotation
  };
}
var ignoredFields = /* @__PURE__ */ new Set(["_id", "_type", "_createdAt", "_updatedAt", "_rev", "_weak"]);
function diffObject2(fromInput, toInput, options) {
  const fields = {};
  let isChanged = false;
  for (const key2 of fromInput.keys) {
    if (ignoredFields.has(key2))
      continue;
    const fromField = fromInput.get(key2);
    const toField = toInput.get(key2);
    if (toField) {
      const fieldDiff = diffInput(fromField, toField, options);
      fields[key2] = fieldDiff;
      if (fieldDiff.isChanged)
        isChanged = true;
    } else {
      fields[key2] = removedInput(fromField, void 0);
      isChanged = true;
    }
  }
  for (const key2 of toInput.keys) {
    if (ignoredFields.has(key2))
      continue;
    if (fromInput.get(key2))
      continue;
    const toField = toInput.get(key2);
    fields[key2] = addedInput(toField, void 0);
    isChanged = true;
  }
  const fromValue = fromInput.value;
  const toValue = toInput.value;
  if (!isChanged) {
    return {
      type: "object",
      action: "unchanged",
      isChanged: false,
      fromValue,
      toValue,
      fields
    };
  }
  return {
    type: "object",
    action: "changed",
    isChanged: true,
    fromValue,
    toValue,
    fields,
    annotation: toInput.annotation
  };
}
function removedObject(input, toValue, options) {
  return {
    type: "object",
    action: "removed",
    isChanged: true,
    fromValue: input.value,
    toValue,
    annotation: input.annotation,
    get fields() {
      const fields = {};
      for (const key2 of input.keys) {
        const value = input.get(key2);
        fields[key2] = removedInput(value, void 0);
      }
      return replaceProperty(this, "fields", fields);
    }
  };
}
function addedObject(input, fromValue, options) {
  return {
    type: "object",
    action: "added",
    isChanged: true,
    fromValue,
    toValue: input.value,
    annotation: input.annotation,
    get fields() {
      const fields = {};
      for (const key2 of input.keys) {
        const value = input.get(key2);
        fields[key2] = addedInput(value, void 0);
      }
      return replaceProperty(this, "fields", fields);
    }
  };
}
function diffNumber(fromInput, toInput, options) {
  const fromValue = fromInput.value;
  const toValue = toInput.value;
  const type = fromInput.type;
  if (fromValue === toValue)
    return {
      type,
      action: "unchanged",
      fromValue,
      toValue,
      isChanged: false
    };
  return {
    type: fromInput.type,
    action: "changed",
    isChanged: true,
    fromValue,
    toValue,
    annotation: toInput.annotation
  };
}
function diffBoolean(fromInput, toInput, options) {
  const fromValue = fromInput.value;
  const toValue = toInput.value;
  const type = fromInput.type;
  if (fromValue === toValue)
    return {
      type,
      action: "unchanged",
      fromValue,
      toValue,
      isChanged: false
    };
  return {
    type: fromInput.type,
    action: "changed",
    isChanged: true,
    fromValue,
    toValue,
    annotation: toInput.annotation
  };
}
function diffInput(fromInput, toInput) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (fromInput.type !== toInput.type) {
    if (fromInput.type === "null") {
      return addedInput(toInput, null);
    }
    if (toInput.type === "null") {
      return removedInput(fromInput, null);
    }
    return diffTypeChange(fromInput, toInput);
  }
  return diffWithType(fromInput.type, fromInput, toInput, options);
}
function diffWithType(type, fromInput, toInput, options) {
  switch (type) {
    case "null":
      return {
        type: "null",
        action: "unchanged",
        isChanged: false,
        toValue: null,
        fromValue: null
      };
    case "boolean":
      return diffBoolean(fromInput, toInput);
    case "number":
      return diffNumber(fromInput, toInput);
    case "string":
      return diffString(fromInput, toInput);
    case "array":
      return diffArray2(fromInput, toInput, options);
    case "object":
      return diffObject2(fromInput, toInput, options);
    default:
      throw new Error('Unhandled diff type "'.concat(type, '"'));
  }
}
function removedInput(input, toValue, options) {
  switch (input.type) {
    case "null":
      return {
        type: "null",
        action: "removed",
        isChanged: true,
        fromValue: null,
        toValue,
        annotation: input.annotation
      };
    case "boolean":
      return {
        type: "boolean",
        action: "removed",
        isChanged: true,
        fromValue: input.value,
        toValue,
        annotation: input.annotation
      };
    case "number":
      return {
        type: "number",
        action: "removed",
        isChanged: true,
        fromValue: input.value,
        toValue,
        annotation: input.annotation
      };
    case "string":
      return removedString(input, toValue);
    case "array":
      return removedArray(input, toValue);
    case "object":
      return removedObject(input, toValue);
    default:
      throw new Error("Unhandled diff type");
  }
}
function addedInput(input, fromValue, options) {
  switch (input.type) {
    case "null":
      return {
        type: "null",
        action: "added",
        isChanged: true,
        fromValue,
        toValue: null,
        annotation: input.annotation
      };
    case "boolean":
      return {
        type: "boolean",
        action: "added",
        isChanged: true,
        fromValue,
        toValue: input.value,
        annotation: input.annotation
      };
    case "number":
      return {
        type: "number",
        action: "added",
        isChanged: true,
        fromValue,
        toValue: input.value,
        annotation: input.annotation
      };
    case "string":
      return addedString(input, fromValue);
    case "array":
      return addedArray(input, fromValue);
    case "object":
      return addedObject(input, fromValue);
    default:
      throw new Error("Unhandled diff type");
  }
}
var ArrayWrapper = class {
  constructor(value, annotation) {
    this.type = "array";
    this.elements = [];
    this.annotation = annotation;
    this.value = value;
    this.length = value.length;
  }
  at(idx) {
    if (idx >= this.length)
      throw new Error("out of bounds");
    const input = this.elements[idx];
    if (input) {
      return input;
    }
    return this.elements[idx] = wrap3(this.value[idx], this.annotation);
  }
  annotationAt() {
    return this.annotation;
  }
};
var ObjectWrapper = class {
  constructor(value, annotation) {
    this.type = "object";
    this.fields = {};
    this.value = value;
    this.annotation = annotation;
    this.keys = Object.keys(value);
  }
  get(key2) {
    const input = this.fields[key2];
    if (input) {
      return input;
    }
    if (!this.value.hasOwnProperty(key2)) {
      return void 0;
    }
    const raw = this.value[key2];
    return this.fields[key2] = wrap3(raw, this.annotation);
  }
};
var StringWrapper = class {
  constructor(value, annotation) {
    this.type = "string";
    this.value = value;
    this.annotation = annotation;
  }
  sliceAnnotation(start, end) {
    return [{
      text: this.value.slice(start, end),
      annotation: this.annotation
    }];
  }
};
var BasicWrapper = class {
  constructor(type, value, annotation) {
    this.type = type;
    this.value = value;
    this.annotation = annotation;
  }
};
function wrap3(input, annotation) {
  if (Array.isArray(input)) {
    return new ArrayWrapper(input, annotation);
  } else if (input === null) {
    return new BasicWrapper("null", input, annotation);
  }
  const type = typeof input;
  switch (type) {
    case "number":
      return new BasicWrapper(type, input, annotation);
    case "boolean":
      return new BasicWrapper(type, input, annotation);
    case "object":
      return new ObjectWrapper(input, annotation);
    case "string":
      return new StringWrapper(input, annotation);
    default:
      throw new Error("cannot wrap value of type: ".concat(type));
  }
}

// node_modules/sanity/lib/index.esm.js
init_polished_esm();
var import_dataloader = __toESM(require_dataloader());
var import_raf = __toESM(require_raf());
init_index_browser();
var import_sample = __toESM(require_sample());

// node_modules/color2k/dist/index.exports.import.es.mjs
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
var ColorError = class extends Error {
  constructor(color3) {
    super(`Failed to parse color: "${color3}"`);
  }
};
var ColorError$1 = ColorError;
function parseToRgba(color3) {
  if (typeof color3 !== "string")
    throw new ColorError$1(color3);
  if (color3.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color3.trim();
  normalizedColor = namedColorRegex.test(color3) ? nameToHex(color3) : color3;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s)
      throw new ColorError$1(color3);
    if (guard(0, 100, l) !== l)
      throw new ColorError$1(color3);
    return [...hslToRgb2(h, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color3);
}
function hash(str) {
  let hash3 = 5381;
  let i = str.length;
  while (i) {
    hash3 = hash3 * 33 ^ str.charCodeAt(--i);
  }
  return (hash3 >>> 0) % 2341;
}
var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key2 = colorToInt(next.substring(0, 3));
  const hex2 = colorToInt(next.substring(3)).toString(16);
  let prefix = "";
  for (let i = 0; i < 6 - hex2.length; i++) {
    prefix += "0";
  }
  acc[key2] = `${prefix}${hex2}`;
  return acc;
}, {});
function nameToHex(color3) {
  const normalizedColorName = color3.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color3);
  return `#${result}`;
}
var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
var namedColorRegex = /^[a-z]+$/i;
var roundColor = (color3) => {
  return Math.round(color3 * 255);
};
var hslToRgb2 = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red2 = chroma;
    green2 = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red2 = secondComponent;
    green2 = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green2 = chroma;
    blue2 = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green2 = secondComponent;
    blue2 = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red2 = secondComponent;
    blue2 = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red2 = chroma;
    blue2 = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red2 + lightnessModification;
  const finalGreen = green2 + lightnessModification;
  const finalBlue = blue2 + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function parseToHsla(color3) {
  const [red2, green2, blue2, alpha2] = parseToRgba(color3).map((value, index) => (
    // 3rd index is alpha channel which is already normalized
    index === 3 ? value : value / 255
  ));
  const max2 = Math.max(red2, green2, blue2);
  const min2 = Math.min(red2, green2, blue2);
  const lightness = (max2 + min2) / 2;
  if (max2 === min2)
    return [0, 0, lightness, alpha2];
  const delta2 = max2 - min2;
  const saturation = lightness > 0.5 ? delta2 / (2 - max2 - min2) : delta2 / (max2 + min2);
  const hue = 60 * (red2 === max2 ? (green2 - blue2) / delta2 + (green2 < blue2 ? 6 : 0) : green2 === max2 ? (blue2 - red2) / delta2 + 2 : (red2 - green2) / delta2 + 4);
  return [hue, saturation, lightness, alpha2];
}
function hsla2(hue, saturation, lightness, alpha2) {
  return `hsla(${(hue % 360).toFixed()}, ${guard(0, 100, saturation * 100).toFixed()}%, ${guard(0, 100, lightness * 100).toFixed()}%, ${parseFloat(guard(0, 1, alpha2).toFixed(3))})`;
}
function darken(color3, amount) {
  const [hue, saturation, lightness, alpha2] = parseToHsla(color3);
  return hsla2(hue, saturation, lightness - amount, alpha2);
}
function getLuminance2(color3) {
  if (color3 === "transparent")
    return 0;
  function f(x) {
    const channel = x / 255;
    return channel <= 0.04045 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
  }
  const [r2, g, b] = parseToRgba(color3);
  return 0.2126 * f(r2) + 0.7152 * f(g) + 0.0722 * f(b);
}
function getContrast(color1, color22) {
  const luminance1 = getLuminance2(color1);
  const luminance2 = getLuminance2(color22);
  return luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05);
}
var guidelines = {
  decorative: 1.5,
  readable: 3,
  aa: 4.5,
  aaa: 7
};
function hasBadContrast(color3, standard = "aa", background = "#fff") {
  return getContrast(color3, background) < guidelines[standard];
}
function lighten(color3, amount) {
  return darken(color3, -amount);
}
function readableColorIsBlack(color3) {
  return getLuminance2(color3) > 0.179;
}
function readableColor(color3) {
  return readableColorIsBlack(color3) ? "#000" : "#fff";
}

// node_modules/sanity/lib/index.esm.js
var import_client2 = __toESM(require_client());
var import_is_hotkey2 = __toESM(require_lib());
var import_intersection3 = __toESM(require_intersection());
var import_isEmpty = __toESM(require_isEmpty());
var import_server = __toESM(require_server_browser());
var import_isEqual5 = __toESM(require_isEqual());
var import_upperFirst = __toESM(require_upperFirst());
var import_debug5 = __toESM(require_browser());
var import_isObject2 = __toESM(require_isObject());
var import_findIndex2 = __toESM(require_findIndex());
var import_clone2 = __toESM(require_clone());
var import_omit5 = __toESM(require_omit());
var import_startCase3 = __toESM(require_startCase());

// node_modules/use-hot-module-reload/dist/use-hot-module-reload.esm.mjs
var import_react50 = __toESM(require_react(), 1);
var isModule = (() => {
  try {
    return typeof import.meta !== "undefined";
  } catch (err) {
    return false;
  }
})();
var hasHMR = () => {
  try {
    return Boolean(isModule && (import.meta.hot || import.meta.webpackHot));
  } catch (err) {
    return false;
  }
};
function useHotModuleReload(callback) {
  if (!hasHMR) {
    return void 0;
  }
  return typeof import.meta.webpackHot === "undefined" ? useViteHotModuleReload(callback) : useWebpackHotModuleReload(callback);
}
function useWebpackHotModuleReload(callback) {
  (0, import_react50.useEffect)(() => {
    if (import.meta.webpackHot) {
      const statusHandler = (status) => status === "idle" ? callback() : void 0;
      import.meta.webpackHot.addStatusHandler(statusHandler);
      return () => {
        var _a4;
        return (_a4 = import.meta.webpackHot) == null ? void 0 : _a4.removeStatusHandler(statusHandler);
      };
    }
    return void 0;
  }, [callback]);
}
function useViteHotModuleReload(callback) {
  (0, import_react50.useEffect)(() => {
    if (import.meta.hot) {
      const disposers = /* @__PURE__ */ new Set();
      import.meta.hot.on("vite:beforeUpdate", () => {
        let flushTimeout;
        let hasSeenScheduledUpdate = window.__vite_plugin_react_timeout > 0;
        const refreshProber = setInterval(() => {
          const now3 = window.__vite_plugin_react_timeout;
          if (hasSeenScheduledUpdate && now3 === 0) {
            complete();
          } else if (!hasSeenScheduledUpdate && now3 > 0) {
            hasSeenScheduledUpdate = true;
          }
        }, 10);
        const fallbackTimeout = setTimeout(complete, 1e3, "fallback");
        function clear() {
          clearInterval(refreshProber);
          clearTimeout(fallbackTimeout);
          clearTimeout(flushTimeout);
        }
        function complete() {
          clear();
          flushTimeout = setTimeout(callback, 50);
        }
        disposers.add(clear);
      });
      return () => {
        disposers.forEach((disposer) => disposer());
        disposers.clear();
      };
    }
    return void 0;
  }, [callback]);
}

// node_modules/sanity/lib/index.esm.js
function noop$5() {
}
function NoopTracker(_ref2) {
  let { children } = _ref2;
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children });
}
function createNoopTrackerScope() {
  return { useReportedValues: noop$5, Tracker: NoopTracker, useReporter: noop$5 };
}
function isFunc(value) {
  return typeof value === "function";
}
function read(value) {
  return isFunc(value) ? value() : value;
}
var noop$4 = () => void 0;
function createUseReporter(Context2) {
  return function useReporter2(id4, value) {
    let isEqual7 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Object.is;
    const { add, update, remove: remove2 } = import_react51.default.useContext(Context2);
    const previous = import_react51.default.useRef();
    import_react51.default.useLayoutEffect(() => {
      if (id4 === null) {
        return noop$4;
      }
      const current = read(value);
      add(id4, current);
      previous.current = current;
      return () => {
        remove2(id4);
      };
    }, [add, id4, remove2, value]);
    import_react51.default.useLayoutEffect(() => {
      const current = read(value);
      if (typeof previous.current !== "undefined" && !isEqual7(previous.current, current) && id4 !== null) {
        update(id4, current);
      }
      previous.current = current;
    });
  };
}
function createStore() {
  const reportedValues = /* @__PURE__ */ new Map();
  const { publish: publish2, subscribe } = createPubSub();
  const debouncedPublish = (0, import_debounce2.default)(publish2, 10, { trailing: true });
  const read2 = () => Array.from(reportedValues.entries());
  function add(id4, value) {
    if (reportedValues.has(id4))
      ;
    reportedValues.set(id4, value);
    debouncedPublish(read2());
  }
  function update(id4, value) {
    if (!reportedValues.has(id4))
      ;
    reportedValues.set(id4, value);
    debouncedPublish(read2());
  }
  function remove2(id4) {
    if (!reportedValues.has(id4))
      ;
    reportedValues.delete(id4);
    debouncedPublish(read2());
  }
  return { add, remove: remove2, update, read: read2, subscribe };
}
var didWarn = false;
var useReporterGuard = (id22) => {
  if (!didWarn) {
    console.warn(new Error('No context provided for reporter. Make sure that the component calling "useReporter('.concat(id22, ', ...)", is wrapped in a <Tracker> element')));
  }
  didWarn = true;
};
function useReportedValueGuard() {
  if (!didWarn) {
    console.warn(new Error('No context provided for reporter. Make sure that the component calling "useReportedValues()", is wrapped inside a <Tracker> element'));
  }
  didWarn = true;
  return [];
}
var useSubscribeGuard = () => {
  if (!didWarn) {
    console.warn(new Error('No context provided for reporter. Make sure that the component calling "useReportedValues()", is wrapped inside a <Tracker> element'));
  }
  didWarn = true;
  return () => {
  };
};
var DEFAULT_CONTEXT = { add: useReporterGuard, update: useReporterGuard, remove: useReporterGuard, subscribe: useSubscribeGuard, read: useReportedValueGuard };
var id$1 = 0;
var getNextId = () => ++id$1;
function createTrackerScope() {
  const Context2 = import_react51.default.createContext(DEFAULT_CONTEXT);
  function useReportedValues2() {
    const context = import_react51.default.useContext(Context2);
    const [values2, setValues2] = import_react51.default.useState(context.read());
    import_react51.default.useLayoutEffect(() => {
      setValues2(context.read());
      return context.subscribe(setValues2);
    }, [context]);
    return values2;
  }
  function Tracker2(props2) {
    const store = import_react51.default.useMemo(() => createStore(), []);
    return (0, import_jsx_runtime6.jsx)(Context2.Provider, { value: store, children: props2.children });
  }
  const useReporter2 = createUseReporter(Context2);
  return { Tracker: Tracker2, useReportedValues: useReportedValues2, useReporter: useReporter2, useAutoIdReporter: function(value) {
    let isEqual7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object.is;
    return useReporter2("element-".concat(import_react51.default.useRef(getNextId()).current), value, isEqual7);
  } };
}
var CORNER_RADIUS = 4;
var INTERACTIVE_STROKE_WIDTH = 16;
var CONNECTOR_MARGIN = 8;
var ARROW_MARGIN_X = 8;
var ARROW_MARGIN_Y = 2;
var ARROW_SIZE = 4;
var ARROW_THRESHOLD = 12;
var STROKE_WIDTH$2 = 2;
var DEBUG$1 = false;
var DEBUG_LAYER_BOUNDS = false;
var trackerScope = createTrackerScope();
var Tracker$1 = trackerScope.Tracker;
var useReportedValues$1 = trackerScope.useReportedValues;
var useReporter$1 = trackerScope.useReporter;
var ConnectorContext = (0, import_react51.createContext)({ isReviewChangesOpen: false, onOpenReviewChanges: () => void 0, onSetFocus: () => void 0 });
var ChangeFieldWrapper = (props2) => {
  const ref = import_react51.default.useRef(null);
  const { onSetFocus } = import_react51.default.useContext(ConnectorContext);
  const [isHover, setHover] = import_react51.default.useState(false);
  const onMouseEnter = import_react51.default.useCallback(() => {
    setHover(true);
  }, []);
  const onMouseLeave = import_react51.default.useCallback(() => {
    setHover(false);
  }, []);
  useReporter$1(
    "change-".concat(toString(props2.path)),
    () => ({ element: ref.current, path: props2.path, isChanged: true, hasFocus: false, hasHover: isHover, hasRevertHover: props2.hasHover }),
    // note: deepCompare should be ok here since we're not comparing deep values
    import_react_fast_compare.default
  );
  const handleClick = (0, import_react51.useCallback)((event) => {
    setFocusWithStopPropagation(event, onSetFocus, props2.path);
  }, [onSetFocus, props2.path]);
  return (0, import_jsx_runtime6.jsx)("div", { ref, onClick: handleClick, onMouseLeave, onMouseEnter, children: props2.children });
};
function setFocusWithStopPropagation(event, onSetFocus, path2) {
  event.stopPropagation();
  onSetFocus(path2);
}
function useUnique2(value) {
  const valueRef = (0, import_react51.useRef)(value);
  if (!(0, import_isEqual4.default)(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
function createHookFromObservableFactory(observableFactory, initialValue) {
  const initialLoadingTuple = [initialValue, true];
  const initialResult = { type: "tuple", tuple: initialLoadingTuple };
  return function useLoadableFromCreateLoadable(_arg) {
    const memoArg = useUnique2(_arg);
    const result = useMemoObservable(() => of(memoArg).pipe(switchMap((arg) => concat(of({ type: "loading" }), observableFactory(arg).pipe(map((value) => ({ type: "value", value }))))), scan((_ref3, next) => {
      let [prevValue] = _ref3;
      if (next.type === "loading")
        return [prevValue, true];
      return [next.value, false];
    }, initialLoadingTuple), distinctUntilChanged((_ref4, _ref5) => {
      let [prevValue, prevIsLoading] = _ref4;
      let [nextValue, nextIsLoading] = _ref5;
      if (prevValue !== nextValue)
        return false;
      if (prevIsLoading !== nextIsLoading)
        return false;
      return true;
    }), map((tuple) => ({ type: "tuple", tuple })), catchError((error2) => of({ type: "error", error: error2 }))), [memoArg], initialResult);
    if (result.type === "error")
      throw result.error;
    return result.tuple;
  };
}
function isNonNullable$3(value) {
  return value !== null && value !== void 0;
}
var DRAFTS_FOLDER = "drafts";
var DRAFTS_PREFIX = "".concat(DRAFTS_FOLDER, ".");
function documentIdEquals(documentId, equalsDocumentId) {
  return getPublishedId(documentId) === getPublishedId(equalsDocumentId);
}
function isDraft(document2) {
  return isDraftId(document2._id);
}
function isDraftId(id4) {
  return id4.startsWith(DRAFTS_PREFIX);
}
function getIdPair(id4) {
  return { draftId: getDraftId(id4), publishedId: getPublishedId(id4) };
}
function isPublishedId(id4) {
  return !isDraftId(id4);
}
function getDraftId(id4) {
  return isDraftId(id4) ? id4 : DRAFTS_PREFIX + id4;
}
function getPublishedId(id4) {
  return isDraftId(id4) ? id4.slice(DRAFTS_PREFIX.length) : id4;
}
function createDraftFrom(document2) {
  return { ...document2, _id: getDraftId(document2._id) };
}
function newDraftFrom(document2) {
  return { ...document2, _id: DRAFTS_PREFIX };
}
function createPublishedFrom(document2) {
  return { ...document2, _id: getPublishedId(document2._id) };
}
function collate(documents) {
  const byId = documents.reduce((res, doc) => {
    const publishedId = getPublishedId(doc._id);
    let entry = res.get(publishedId);
    if (!entry) {
      entry = { id: publishedId, type: doc._type, published: void 0, draft: void 0 };
      res.set(publishedId, entry);
    }
    entry[publishedId === doc._id ? "published" : "draft"] = doc;
    return res;
  }, /* @__PURE__ */ new Map());
  return Array.from(byId.values());
}
function removeDupes(documents) {
  return collate(documents).map((entry) => entry.draft || entry.published).filter(isNonNullable$3);
}
var EMPTY_OBJECT = Object.freeze({});
var EMPTY_ARRAY$b = Object.freeze([]);
function getGlobalScope2() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof window !== "undefined")
    return window;
  if (typeof self !== "undefined")
    return self;
  if (typeof global !== "undefined")
    return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
var globalScope2 = getGlobalScope2();
function isArray(value) {
  return Array.isArray(value);
}
function isRecord$4(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function isString3(value) {
  return typeof value === "string";
}
function isTruthy(value) {
  return Boolean(value);
}
var ResizeObserver4 = typeof document === "object" && typeof window === "object" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver2;
var createSharedResizeObserver = () => {
  const event = createPubSub();
  const resizeObserver2 = new ResizeObserver4((entries) => event.publish(entries));
  return { observe: (element, observer, options) => {
    const unsubscribe = event.subscribe((entries) => {
      const entry = entries.find((e2) => e2.target === element);
      if (entry) {
        observer(entry);
      }
    });
    resizeObserver2.observe(element, options);
    return () => {
      unsubscribe();
      resizeObserver2.unobserve(element);
    };
  } };
};
var resizeObserver = createSharedResizeObserver();
var BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function _isSanityDocumentTypeDefinition(def) {
  return def.type === "document" && BUNDLED_DOC_TYPES.includes(def.name);
}
function _isCustomDocumentTypeDefinition(def) {
  return def.type === "document" && !_isSanityDocumentTypeDefinition(def);
}
var GROQ_KEYWORDS = ["match", "in", "asc", "desc", "true", "false", "null"];
var VALID_FIELD = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
var fieldNeedsEscape = (fieldName) => !VALID_FIELD.test(fieldName) || GROQ_KEYWORDS.includes(fieldName);
var escapeField = (fieldName) => '["'.concat(fieldName, '"]');
var escapeFirst = (fieldName) => "@".concat(escapeField(fieldName));
var isEmptyArray = (value) => Array.isArray(value) && value.length === 0;
var joinPath = (pathArray) => {
  let path2 = "";
  for (let i = 0; i < pathArray.length; i++) {
    const pathSegment = pathArray[i];
    if (isEmptyArray(pathSegment)) {
      path2 += "[]";
      continue;
    }
    if (typeof pathSegment === "number") {
      path2 += "[".concat(pathSegment, "]");
      continue;
    }
    const isFirst = i === 0;
    const needsEscape = fieldNeedsEscape(pathSegment);
    if (needsEscape) {
      path2 = isFirst ? escapeFirst(pathSegment) : "".concat(path2).concat(escapeField(pathSegment));
    } else {
      path2 = isFirst ? pathSegment : "".concat(path2, ".").concat(pathSegment);
    }
  }
  return path2;
};
var supportsTouch = isTouchDevice$1();
function isTouchDevice$1() {
  if (typeof window === "undefined")
    return false;
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
var FONT_SANS_SERIF = "-apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, \\'Helvetica Neue\\', Helvetica, Arial, system-ui, sans-serif";
var FONT_MONOSPACE = "-apple-system-ui-monospace, \\'SF Mono\\', Menlo, Monaco, Consolas, monospace";
var uncaughtErrorHandler = () => (
  // prettier-ignore
  ["window.onerror = function(m,u,l,c,e) {", "var p=window.location.port;", "var h=window.location.protocol+'//'+window.location.hostname+(p?':'+p:'');", "var r=document.getElementById('sanity');", "while(r.firstChild){r.removeChild(r.firstChild);}", "var s=document.createElement('style');", "s.appendChild(document.createTextNode('", "html,body,#sanityBody,#sanity,#sanityError{height:100%;}", "body{-webkit-font-smoothing:antialiased;margin:0;}", "#sanityError{position:fixed;top:0;left:0;width:100%;height:100%;overflow:auto;background-color:#fff;color:#121923;font-family:".concat(FONT_SANS_SERIF, ";font-size:16px;line-height:21px;min-height:100%;}"), "#sanityError>div{background-color:#fff;max-width:960px;margin:0 auto;padding:47px 32px 52px;}", "@media(min-width:512px){", "#sanityError>div{", "padding:47px 84px;", "}", "}", "#sanityError button{-webkit-font-smoothing:inherit;font:inherit;font-weight:500;background-color:#2276FC;color:#fff;padding:7px 12px;border-radius:3px;border:0;}", "#sanityError button:hover{background-color:#1E63D0;}", "#sanityError button:active{background-color:#1B50A5;}", "'));", "document.head.appendChild(s);", "var f=document.createElement('div');", "f.id='sanityError';", "f.innerHTML='", "<div>", '<h1 style="font-size:21px;line-height:27px;margin: 0 0 10px;">Unhandled error</h1>', '<p style="color:#66758D;margin:10px 0 14px;">Encountered an unhandled error in this Studio.</p>', '<button class="sanity-error-handler__reload-btn" type="button">Reload page</button>', '<pre style="background-color:#FDEBEA;color:#C3362C;font-size:13px;line-height:17px;padding:8px 12px;border-radius:3px;margin:32px 0 0;overflow:auto;">', '<code style="font-family:'.concat(FONT_MONOSPACE, ';">'), "'+e.stack.replaceAll(h,'')+'", "</code>", "</pre>", "</div>", "';", "var b=f.querySelector('.sanity-error-handler__reload-btn');", "if(b){", "b.onclick=function() {", "window.location.reload();", "}", "};", "r.appendChild(f);", "};"].join("")
);
var segmenter = typeof Intl === "object" && "Segmenter" in Intl ? new Intl.Segmenter() : void 0;
function sliceString(str, start, end) {
  if (end < start) {
    throw new Error("End must be greater than start, use `String.prototype.slice()` for negative values");
  }
  if (!segmenter) {
    return str.slice(start, end);
  }
  let i = 0;
  let sliced = "";
  for (const value of segmenter.segment(str)) {
    if (i === end) {
      return sliced;
    }
    sliced += value.segment;
    i++;
  }
  return sliced;
}
function truncateString(str, maxLength) {
  const truncated = sliceString(str, 0, maxLength);
  return truncated === str ? truncated : "".concat(truncated, "");
}
var LOADING_STATE$1 = { isLoading: true, value: void 0, error: null };
function useLoadable(value$, initialValue) {
  const initial = typeof initialValue === "undefined" ? LOADING_STATE$1 : { isLoading: false, value: initialValue, error: null };
  return useMemoObservable(() => value$.pipe(asLoadable()), [value$], initial);
}
function asLoadable() {
  return (value$) => value$.pipe(map((value) => ({ isLoading: false, value, error: null })), catchError((error2) => of({ isLoading: false, value: void 0, error: error2 })));
}
function userHasRole(user, roleId) {
  return user !== null && user.roles.some((role) => role.name === roleId);
}
function useThrottledCallback(callback, wait, options) {
  const throttledCallback = (0, import_react51.useMemo)(() => (0, import_throttle2.default)(callback, wait, options), [callback, options, wait]);
  return throttledCallback;
}
var _a$2x;
var DEBUG_MODE$1 = typeof process === "undefined" ? false : (_a$2x = process == null ? void 0 : process.env) == null ? void 0 : _a$2x.SANITY_STUDIO_DEBUG_I18N;
var DEBUG_I18N = Boolean(DEBUG_MODE$1);
var debugWrappers = { reverse: (str) => "".concat(str), triangles: (str) => " ".concat(str, " ") };
function maybeWrapT(t3) {
  const wrapper = DEBUG_MODE$1 === "reverse" || DEBUG_MODE$1 === "triangles" ? debugWrappers[DEBUG_MODE$1] : null;
  return wrapper ? function() {
    return wrapper(t3(...arguments));
  } : t3;
}
var translationOptionOverrides = {
  // We're manually forcing a re-render with the locale key in the LocaleProvider,
  // so we don't need to bind to the i18n instance for language change events.
  bindI18n: false
};
function useTranslation2(ns, options) {
  const { t: t3 } = useTranslation(ns, options ? { keyPrefix: options.keyPrefix, lng: options.lng, ...translationOptionOverrides } : translationOptionOverrides);
  return { t: maybeWrapT(t3) };
}
var __freeze$2v = Object.freeze;
var __defProp$2v = Object.defineProperty;
var __template$2v = (cooked, raw) => __freeze$2v(__defProp$2v(cooked, "raw", { value: __freeze$2v(raw || cooked.slice()) }));
var _a$2w;
var _b$18;
var _c$E;
var _d$p;
var _e$b;
var _f$9;
var _g$7;
var _h$4;
var _i$2;
var animationSpeed = 250;
var ChangeBarWrapper$1 = st.div((_ref6) => {
  let { $changed, $disabled, $isReviewChangeOpen } = _ref6;
  if ($disabled)
    return nt(_a$2w || (_a$2w = __template$2v(["\n        ", " {\n          display: none;\n        }\n      "])), ChangeBar);
  return nt(_d$p || (_d$p = __template$2v(["\n      --change-bar-offset: 2px;\n\n      display: flex;\n      position: relative;\n\n      @media (hover: hover) {\n        &:hover {\n          z-index: 10;\n        }\n      }\n\n      /* hide when field is not changed */\n      ", "\n\n      /* hide hover effect when review changes is open */\n      ", "\n    "])), !$changed && nt(_b$18 || (_b$18 = __template$2v(["\n        ", " {\n          opacity: 0;\n          pointer-events: none;\n        }\n      "])), ChangeBar), $isReviewChangeOpen && nt(_c$E || (_c$E = __template$2v(["\n        ", " {\n          opacity: 0;\n        }\n      "])), ChangeBarButton));
});
var FieldWrapper = st.div(_e$b || (_e$b = __template$2v(["\n  flex-grow: 1;\n  min-width: 0;\n"])));
var ChangeBar = st.div(_f$9 || (_f$9 = __template$2v(["\n  position: relative;\n  opacity: 1;\n  transition: opacity 100ms;\n  z-index: ", ";\n"])), (_ref7) => {
  let { $zIndex } = _ref7;
  return $zIndex;
});
var ChangeBarMarker = st.div((_ref8) => {
  let { theme } = _ref8;
  const notSelectedColor = theme.sanity.color.spot.yellow;
  const screenMedium = theme.sanity.media[0];
  return nt(_g$7 || (_g$7 = __template$2v(["\n    position: absolute;\n    top: 0;\n    left: var(--change-bar-offset);\n    width: 2px;\n    bottom: 0;\n    background-color: ", ";\n    border-radius: 1px;\n\n    @media (min-width: ", "px) {\n      display: unset;\n    }\n  "])), notSelectedColor, screenMedium);
});
var ChangeBarButton = st.button((_ref9) => {
  let { theme, $withHoverEffect } = _ref9;
  const notSelectedColor = theme.sanity.color.spot.yellow;
  return nt(_i$2 || (_i$2 = __template$2v(["\n      appearance: none;\n      border: 0;\n      outline: 0;\n      display: block;\n      padding: 0;\n      background: transparent;\n      opacity: 0;\n      position: absolute;\n      height: 100%;\n      cursor: pointer;\n      pointer-events: all;\n      left: calc(-0.25rem + var(--change-bar-offset));\n      width: 1rem;\n      transition: opacity ", "ms;\n\n      &:focus {\n        border: 0;\n        outline: 0;\n      }\n\n      &:after {\n        content: '';\n        width: 16px;\n        height: calc(100% + 14px);\n        display: block;\n        position: absolute;\n        top: -7px;\n        left: -3px;\n        border-radius: 8px;\n        background: ", ";\n      }\n\n      &:focus {\n        border: 0;\n        outline: 0;\n      }\n\n      ", "\n    "])), animationSpeed, notSelectedColor, $withHoverEffect && nt(_h$4 || (_h$4 = __template$2v(["\n        @media (hover: hover) {\n          &:hover {\n            opacity: 0.2;\n          }\n        }\n      "]))));
});
function ElementWithChangeBar(props2) {
  const { children, disabled, isChanged, withHoverEffect = true } = props2;
  const { onOpenReviewChanges, isReviewChangesOpen } = import_react51.default.useContext(ConnectorContext);
  const { zIndex } = useLayer();
  const { t: t3 } = useTranslation2();
  const changeBar = (0, import_react51.useMemo)(() => disabled || !isChanged ? null : (0, import_jsx_runtime6.jsxs)(ChangeBar, { "data-testid": "change-bar", $zIndex: zIndex, children: [(0, import_jsx_runtime6.jsx)(ChangeBarMarker, { "data-testid": "change-bar__marker" }), (0, import_jsx_runtime6.jsx)(ChangeBarButton, { "aria-label": t3("changes.change-bar.aria-label"), "data-testid": "change-bar__button", onClick: isReviewChangesOpen ? void 0 : onOpenReviewChanges, tabIndex: -1, type: "button", $withHoverEffect: withHoverEffect })] }), [disabled, isChanged, isReviewChangesOpen, onOpenReviewChanges, t3, withHoverEffect, zIndex]);
  return (0, import_jsx_runtime6.jsxs)(ChangeBarWrapper$1, { "data-testid": "change-bar-wrapper", $changed: isChanged, $disabled: disabled, $isReviewChangeOpen: isReviewChangesOpen, children: [(0, import_jsx_runtime6.jsx)(FieldWrapper, { "data-testid": "change-bar__field-wrapper", children }), changeBar] });
}
var ChangeBarWrapper = (0, import_react51.memo)(function ChangeBarWrapper2(props2) {
  const { children, disabled, hasFocus, isChanged, onMouseEnter: onMouseEnterProp, onMouseLeave: onMouseLeaveProp, path: path2 = EMPTY_ARRAY$b, withHoverEffect, ...restProps } = props2;
  const layer = useLayer();
  const [hasHover, setHover] = (0, import_react51.useState)(false);
  const onMouseEnter = (0, import_react51.useCallback)((event) => {
    onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
    setHover(true);
  }, [onMouseEnterProp]);
  const onMouseLeave = (0, import_react51.useCallback)((event) => {
    onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
    setHover(false);
  }, [onMouseLeaveProp]);
  const ref = (0, import_react51.useRef)(null);
  useReporter$1(
    disabled ? null : "field-".concat(toString(path2)),
    () => ({ element: ref.current, path: path2, isChanged, hasFocus, hasHover, zIndex: layer.zIndex }),
    import_react_fast_compare.default
    // note: deepCompare should be ok here since we're not comparing deep values
  );
  return (0, import_jsx_runtime6.jsx)("div", { ...restProps, ref, onMouseEnter, onMouseLeave, children: (0, import_jsx_runtime6.jsx)(ElementWithChangeBar, { isChanged, disabled, withHoverEffect, children }) });
});
function ChangeIndicator(props2) {
  const { children, hasFocus, isChanged, path: path2, withHoverEffect, ...restProps } = props2;
  return (0, import_jsx_runtime6.jsx)(ChangeBarWrapper, { ...restProps, path: path2, hasFocus, isChanged, withHoverEffect, children });
}
var ChangeIndicatorContext = import_react51.default.createContext({ path: [], fullPath: [], focusPath: [], isChanged: false });
var ScrollContext = import_react51.default.createContext(null);
function useOnScroll(callback) {
  const parentContext = import_react51.default.useContext(ScrollContext);
  import_react51.default.useEffect(() => {
    return parentContext == null ? void 0 : parentContext.subscribe(callback);
  }, [callback, parentContext]);
}
var noop$3 = () => void 0;
var ScrollContainer = import_react51.default.forwardRef(function ScrollContainer2(props2, ref) {
  const { as = "div", onScroll, ...rest } = props2;
  const forwardedRef = useForwardedRef(ref);
  const parentContext = (0, import_react51.useContext)(ScrollContext);
  const childContext = (0, import_react51.useMemo)(() => createPubSub(), []);
  (0, import_react51.useEffect)(() => {
    if (onScroll) {
      return childContext.subscribe(onScroll);
    }
    return noop$3;
  }, [childContext, onScroll]);
  (0, import_react51.useEffect)(() => {
    if (parentContext) {
      return childContext.subscribe(parentContext.publish);
    }
    return noop$3;
  }, [parentContext, childContext]);
  (0, import_react51.useEffect)(() => {
    const handleScroll = (event) => {
      childContext.publish(event);
    };
    const el = forwardedRef.current;
    if (!el) {
      return void 0;
    }
    el.addEventListener("scroll", handleScroll, { passive: true, capture: true });
    return () => {
      el.removeEventListener("scroll", handleScroll);
    };
  }, [childContext, forwardedRef]);
  return (0, import_jsx_runtime6.jsx)(ScrollContext.Provider, { value: childContext, children: import_react51.default.createElement(as, { ref: forwardedRef, "data-testid": "scroll-container", ...rest }) });
});
function ScrollMonitor(_ref10) {
  let { onScroll, children } = _ref10;
  useOnScroll(onScroll);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children });
}
function findMostSpecificTarget(targetType, id4, values2) {
  const pathString = id4.slice(id4.indexOf("-") + 1) || "[]";
  const path2 = fromString(pathString);
  const exactId = "".concat(targetType, "-").concat(toString(path2));
  if (values2.has(exactId)) {
    return values2.get(exactId);
  }
  let mostSpecific;
  for (const [targetId, target] of values2) {
    if (!("path" in target) || !targetId.startsWith(targetType)) {
      continue;
    }
    const numEqual = numEqualSegments(path2, target.path);
    const lastPathSegment = target.path[target.path.length - 1];
    const pathOnlyDiffersByKey = numEqual === target.path.length - 1 && isKeyedObject(lastPathSegment);
    if (numEqual === 0) {
      continue;
    } else if (numEqual !== target.path.length && !pathOnlyDiffersByKey) {
      continue;
    }
    mostSpecific = target;
    if (numEqual === path2.length) {
      break;
    }
  }
  return mostSpecific;
}
function isChangeBar(v) {
  return v[0] !== "changePanel";
}
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("scroll");
}
function isScrollable(el) {
  const scrollableContent = el.scrollHeight !== el.offsetHeight || el.scrollWidth !== el.offsetWidth;
  return scrollableContent && hasOverflowScroll(el);
}
var SCROLL_INTO_VIEW_TOP_PADDING = -15;
function scrollIntoView(field) {
  const element = field.element;
  let parentElementWithScroll = element;
  while (!isScrollable(parentElementWithScroll)) {
    parentElementWithScroll = parentElementWithScroll.parentElement;
    if (!parentElementWithScroll) {
      return;
    }
  }
  parentElementWithScroll.scroll({ top: parentElementWithScroll.scrollTop + field.rect.top - field.bounds.top + SCROLL_INTO_VIEW_TOP_PADDING, left: 0, behavior: "smooth" });
}
var getOffsetsTo$1 = (source, target) => {
  const bounds = { top: 0, left: 0, height: target.offsetHeight, width: target.offsetWidth };
  const rect = { top: 0, left: 0, height: source.offsetHeight, width: source.offsetWidth };
  let foundScrollContainer = false;
  let el = source;
  while (el && el !== target && target.contains(el)) {
    if (foundScrollContainer) {
      bounds.top += el.offsetTop;
      bounds.left += el.offsetLeft;
    }
    if (hasOverflowScroll(el)) {
      bounds.top = el.offsetTop;
      bounds.height = el.offsetHeight;
      bounds.left = el.offsetLeft;
      bounds.width = el.offsetWidth;
      foundScrollContainer = true;
    }
    rect.top += el.offsetTop - el.scrollTop;
    rect.left += el.offsetLeft - el.scrollLeft;
    el = el.offsetParent;
  }
  return { rect, bounds };
};
function arrowPath(x, y, dir2) {
  return ["M ".concat(x - ARROW_SIZE, " ").concat(y - ARROW_SIZE * dir2, " "), "L ".concat(x, " ").concat(y), "L ".concat(x + ARROW_SIZE, " ").concat(y - ARROW_SIZE * dir2)].join("");
}
function moveTo(x, y) {
  return "M".concat(x, " ").concat(y);
}
function lineTo(x, y) {
  return "L".concat(x, " ").concat(y);
}
function join2(strings) {
  let delim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return strings.join(delim);
}
function quadCurve(x1, y1, x, y) {
  return "Q".concat(x1, " ").concat(y1, " ").concat(x, " ").concat(y);
}
function generateConnectorPath(line) {
  const { from: from2, to } = line;
  const { left: fromX, top: fromY } = from2;
  const { left: toX, top: toY } = to;
  const cmds = [];
  const r1 = Math.min(CORNER_RADIUS, Math.abs(fromY - toY) / 2);
  if (from2.isAbove) {
    cmds.push(moveTo(fromX + ARROW_MARGIN_X, fromY - ARROW_THRESHOLD + ARROW_MARGIN_Y), lineTo(fromX + ARROW_MARGIN_X, fromY - CORNER_RADIUS), quadCurve(fromX + ARROW_MARGIN_X, fromY, fromX + ARROW_MARGIN_X + CORNER_RADIUS, fromY));
  } else if (from2.isBelow) {
    cmds.push(moveTo(fromX + ARROW_MARGIN_X, fromY + ARROW_THRESHOLD - ARROW_MARGIN_Y), lineTo(fromX + ARROW_MARGIN_X, fromY + CORNER_RADIUS), quadCurve(fromX + ARROW_MARGIN_X, fromY, fromX + ARROW_MARGIN_X + CORNER_RADIUS, fromY));
  } else {
    cmds.push(moveTo(fromX, fromY));
  }
  if (to.isAbove) {
    if (fromY < to.bounds.top) {
      cmds.push(lineTo(to.bounds.left - 8 - r1, fromY), quadCurve(to.bounds.left - 8, fromY, to.bounds.left - 8, fromY + r1), lineTo(to.bounds.left - 8, toY - r1), quadCurve(to.bounds.left - 8, toY, to.bounds.left - 8 + r1, toY), lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, toY), quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X, toY - CORNER_RADIUS), lineTo(to.bounds.left + ARROW_MARGIN_X, toY - ARROW_THRESHOLD + ARROW_MARGIN_Y));
    } else {
      cmds.push(lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, fromY), quadCurve(to.bounds.left + ARROW_MARGIN_X, fromY, to.bounds.left + ARROW_MARGIN_X, fromY - CORNER_RADIUS), lineTo(to.bounds.left + ARROW_MARGIN_X, toY - ARROW_THRESHOLD + ARROW_MARGIN_Y));
    }
  } else if (to.isBelow) {
    if (fromY > to.bounds.top + to.bounds.height) {
      cmds.push(lineTo(to.bounds.left - ARROW_MARGIN_X - r1, fromY), quadCurve(to.bounds.left - ARROW_MARGIN_X, fromY, to.bounds.left - ARROW_MARGIN_X, fromY - r1), lineTo(to.bounds.left - ARROW_MARGIN_X, toY + r1), quadCurve(to.bounds.left - ARROW_MARGIN_X, toY, to.bounds.left - ARROW_MARGIN_X + r1, toY), lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, toY), quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X, toY + CORNER_RADIUS), lineTo(to.bounds.left + ARROW_MARGIN_X, toY + ARROW_THRESHOLD - ARROW_MARGIN_Y));
    } else {
      cmds.push(lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, fromY), quadCurve(to.bounds.left + ARROW_MARGIN_X, fromY, to.bounds.left + ARROW_MARGIN_X, fromY + CORNER_RADIUS), lineTo(to.bounds.left + ARROW_MARGIN_X, toY + ARROW_THRESHOLD - ARROW_MARGIN_Y));
    }
  } else if (fromY < toY) {
    cmds.push(lineTo(to.bounds.left + ARROW_MARGIN_X - r1, fromY), quadCurve(to.bounds.left + ARROW_MARGIN_X, fromY, to.bounds.left + ARROW_MARGIN_X, fromY + r1), lineTo(to.bounds.left + ARROW_MARGIN_X, toY - r1), quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X + r1, toY), lineTo(toX, toY));
  } else {
    cmds.push(lineTo(to.bounds.left + ARROW_MARGIN_X - r1, fromY), quadCurve(to.bounds.left + ARROW_MARGIN_X, fromY, to.bounds.left + ARROW_MARGIN_X, fromY - r1), lineTo(to.bounds.left + ARROW_MARGIN_X, toY + r1), quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X + r1, toY), lineTo(toX, toY));
  }
  return join2(cmds);
}
function getConnectorLinePoint(rect, bounds) {
  const centerY = rect.top + rect.height / 2;
  const isAbove = rect.top + rect.height < bounds.top + ARROW_MARGIN_Y;
  const isBelow = rect.top > bounds.top + bounds.height - ARROW_MARGIN_Y;
  return { bounds, left: rect.left, top: centerY, centerY, startY: rect.top + CONNECTOR_MARGIN, endY: rect.top + rect.height - CONNECTOR_MARGIN, isAbove, isBelow, outOfBounds: isAbove || isBelow };
}
function mapConnectorToLine(connector) {
  const fromBounds = { top: connector.from.bounds.top + ARROW_THRESHOLD, bottom: connector.from.bounds.top + connector.from.bounds.height - ARROW_THRESHOLD, left: connector.from.bounds.left, right: connector.from.bounds.left + connector.from.bounds.width, width: connector.from.bounds.width, height: connector.from.bounds.height - ARROW_THRESHOLD * 2 };
  const from2 = getConnectorLinePoint(connector.from.rect, fromBounds);
  from2.left = connector.from.rect.left + connector.from.rect.width + 1;
  const toBounds = { top: connector.to.bounds.top + ARROW_THRESHOLD, bottom: connector.to.bounds.top + connector.to.bounds.height - ARROW_THRESHOLD, left: connector.to.bounds.left, right: connector.to.bounds.left + connector.to.bounds.width, width: connector.to.bounds.width, height: connector.to.bounds.height - ARROW_THRESHOLD * 2 };
  const to = getConnectorLinePoint(connector.to.rect, toBounds);
  const maxStartY = Math.max(to.startY, from2.startY);
  from2.top = Math.min(maxStartY, from2.endY);
  if (from2.top < toBounds.top) {
    from2.top = Math.min(toBounds.top, from2.endY);
  } else if (from2.top > toBounds.bottom) {
    from2.top = Math.max(toBounds.bottom, from2.startY);
  }
  to.top = Math.min(maxStartY, to.endY);
  if (to.top < fromBounds.top) {
    to.top = Math.min(fromBounds.top, to.endY);
  } else if (to.top > fromBounds.bottom) {
    to.top = Math.max(fromBounds.bottom, to.startY);
  }
  from2.top = Math.min(Math.max(from2.top, fromBounds.top), fromBounds.bottom);
  to.top = Math.min(Math.max(to.top, toBounds.top), toBounds.bottom);
  return { from: from2, to };
}
function ClampedRect(props2) {
  const { bounds, ...rest } = props2;
  const x = Math.max(bounds.left, props2.left);
  const y = Math.max(props2.top, bounds.top);
  const height = Math.max(0, props2.height - (y - props2.top));
  const width = Math.max(0, props2.width - (x - props2.left));
  return (0, import_jsx_runtime6.jsx)("rect", { ...rest, x, y, height, width });
}
var __freeze$2u = Object.freeze;
var __defProp$2u = Object.defineProperty;
var __template$2u = (cooked, raw) => __freeze$2u(__defProp$2u(cooked, "raw", { value: __freeze$2u(raw || cooked.slice()) }));
var _a$2v;
var _b$17;
var _c$D;
var _d$o;
st.rect(_a$2v || (_a$2v = __template$2u(["\n  stroke: #ccc;\n  fill: none;\n  pointer-events: none;\n  stroke-linecap: round;\n"])));
var ConnectorPath = st.path((_ref11) => {
  let { theme } = _ref11;
  const strokeColor = theme.sanity.color.spot.yellow;
  return nt(_b$17 || (_b$17 = __template$2u(["\n    fill: none;\n    pointer-events: none;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    stroke: ", ";\n  "])), strokeColor);
});
var InteractivePath = st.path((_ref12) => {
  let { theme } = _ref12;
  const strokeColor = theme.sanity.color.spot.yellow;
  return nt(_c$D || (_c$D = __template$2u(["\n    fill: none;\n    pointer-events: stroke;\n    stroke: ", ";\n    cursor: pointer;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    opacity: 0;\n\n    &:hover {\n      opacity: 0.2;\n    }\n  "])), strokeColor);
});
var RightBarWrapper = st(ClampedRect)((_ref13) => {
  let { theme } = _ref13;
  const strokeColor = theme.sanity.color.spot.yellow;
  return nt(_d$o || (_d$o = __template$2u(["\n    stroke: none;\n    pointer-events: none;\n    fill: ", ";\n  "])), strokeColor);
});
var Connector2 = (0, import_react51.memo)(function Connector22(_ref14) {
  let { from: from2, to } = _ref14;
  const line = mapConnectorToLine({ from: from2, to });
  if (line.from.outOfBounds && line.to.outOfBounds) {
    return null;
  }
  const linePathDescription = generateConnectorPath(line);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(InteractivePath, { d: linePathDescription, strokeWidth: INTERACTIVE_STROKE_WIDTH }), (0, import_jsx_runtime6.jsx)(ConnectorPath, { d: linePathDescription, strokeWidth: STROKE_WIDTH$2 }), (0, import_jsx_runtime6.jsx)(RightBarWrapper, { top: to.rect.top, left: to.rect.left, height: to.rect.height, width: STROKE_WIDTH$2, bounds: to.bounds }), line.from.isAbove && (0, import_jsx_runtime6.jsx)(ConnectorPath, { d: arrowPath(line.from.left + ARROW_MARGIN_X, line.from.bounds.top - ARROW_THRESHOLD + ARROW_MARGIN_Y, -1), strokeWidth: STROKE_WIDTH$2 }), line.from.isBelow && (0, import_jsx_runtime6.jsx)(ConnectorPath, { d: arrowPath(line.from.left + ARROW_MARGIN_X, line.from.bounds.top + line.from.bounds.height + ARROW_THRESHOLD - ARROW_MARGIN_Y, 1), strokeWidth: STROKE_WIDTH$2 }), line.to.isAbove && (0, import_jsx_runtime6.jsx)(ConnectorPath, { d: arrowPath(line.to.bounds.left + ARROW_MARGIN_X, line.to.bounds.top - ARROW_THRESHOLD + ARROW_MARGIN_Y, -1), strokeWidth: STROKE_WIDTH$2 }), line.to.isBelow && (0, import_jsx_runtime6.jsx)(ConnectorPath, { d: arrowPath(line.to.bounds.left + ARROW_MARGIN_X, line.to.bounds.top + line.to.bounds.height + ARROW_THRESHOLD - ARROW_MARGIN_Y, 1), strokeWidth: STROKE_WIDTH$2 }), DEBUG$1] });
});
function useResizeObserver(element, onResize) {
  (0, import_react51.useEffect)(() => resizeObserver.observe(element, onResize), [element, onResize]);
}
var __freeze$2t = Object.freeze;
var __defProp$2t = Object.defineProperty;
var __template$2t = (cooked, raw) => __freeze$2t(__defProp$2t(cooked, "raw", { value: __freeze$2t(raw || cooked.slice()) }));
var _a$2u;
var SvgWrapper = st.svg(_a$2u || (_a$2u = __template$2t(["\n  pointer-events: none;\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n"])));
function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [];
  const changeBarsWithFocus = [];
  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged) {
      continue;
    }
    const [id4, reportedChangeBar] = value;
    if (id4 === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }
  const isHoverConnector = changeBarsWithHover.length > 0;
  const changeBars = isHoverConnector ? changeBarsWithHover : changeBarsWithFocus;
  const connectors = changeBars.map((_ref15) => {
    let [id4] = _ref15;
    const field = findMostSpecificTarget("field", id4, byId);
    const change = findMostSpecificTarget("change", id4, byId);
    if (!field || !change)
      return null;
    return { field: { id: id4, ...field }, change: { id: id4, ...change } };
  }).filter(isNonNullable$3).map((_ref16) => {
    let { field, change } = _ref16;
    return { hasHover: field.hasHover || change.hasHover, hasFocus: field.hasFocus, hasRevertHover: change.hasRevertHover, field: { ...field, ...getOffsetsTo$1(field.element, rootElement) }, change: { ...change, ...getOffsetsTo$1(change.element, rootElement) } };
  });
  return { connectors, isHoverConnector };
}
function ConnectorsOverlay(props2) {
  const { rootElement, onSetFocus } = props2;
  const [hovered, setHovered] = import_react51.default.useState(null);
  const allReportedValues = useReportedValues$1();
  const byId = (0, import_react51.useMemo)(() => new Map(allReportedValues), [allReportedValues]);
  const [{ connectors }, setState] = (0, import_react51.useState)(() => getState(allReportedValues, hovered, byId, rootElement));
  const visibleConnectors = (0, import_react51.useMemo)(() => (0, import_sortBy.default)(connectors, (c) => 0 - c.field.path.length).slice(0, 1), [connectors]);
  const handleScrollOrResize = (0, import_react51.useCallback)(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  useResizeObserver(rootElement, handleScrollOrResize);
  return (0, import_jsx_runtime6.jsx)(ScrollMonitor, { onScroll: handleScrollOrResize, children: (0, import_jsx_runtime6.jsx)(SvgWrapper, { style: { zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex }, children: visibleConnectors.map((_ref17) => {
    let { field, change } = _ref17;
    if (!change) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(ConnectorGroup, { field, change, onSetFocus, setHovered }, field.id);
  }) }) });
}
function ConnectorGroup(props2) {
  const { change, field, onSetFocus, setHovered } = props2;
  const onConnectorClick = (0, import_react51.useCallback)(() => {
    scrollIntoView(field);
    scrollIntoView(change);
    onSetFocus(field.path);
  }, [field, change, onSetFocus]);
  const handleMouseEnter = (0, import_react51.useCallback)(() => setHovered(field.id), [field, setHovered]);
  const handleMouseLeave = (0, import_react51.useCallback)(() => setHovered(null), [setHovered]);
  const from2 = (0, import_react51.useMemo)(() => ({ rect: { left: field.rect.left + 2, top: field.rect.top, height: field.rect.height, width: field.rect.width }, bounds: field.bounds }), [field.bounds, field.rect]);
  const to = (0, import_react51.useMemo)(() => ({ rect: change.rect, bounds: change.bounds }), [change.bounds, change.rect]);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)("g", { onClick: onConnectorClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: (0, import_jsx_runtime6.jsx)(Connector2, { from: from2, to }) }), DEBUG_LAYER_BOUNDS] });
}
function EnabledChangeConnectorRoot(_ref18) {
  let { children, className, isReviewChangesOpen, onOpenReviewChanges, onSetFocus, ...restProps } = _ref18;
  const [rootElement, setRootElement] = import_react51.default.useState();
  const contextValue = (0, import_react51.useMemo)(() => ({ isReviewChangesOpen, onOpenReviewChanges, onSetFocus }), [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]);
  return (0, import_jsx_runtime6.jsx)(ConnectorContext.Provider, { value: contextValue, children: (0, import_jsx_runtime6.jsx)(Tracker$1, { children: (0, import_jsx_runtime6.jsxs)(ScrollContainer, { ...restProps, ref: setRootElement, className, children: [children, rootElement && (0, import_jsx_runtime6.jsx)(ConnectorsOverlay, { rootElement, onSetFocus })] }) }) });
}
function DisabledChangeConnectorRoot(_ref19) {
  let { children, className } = _ref19;
  return (0, import_jsx_runtime6.jsx)(ScrollContainer, { className, children });
}
var ChangeConnectorRoot = EnabledChangeConnectorRoot;
function focusRingBorderStyle$2(border2) {
  return "inset 0 0 0 ".concat(border2.width, "px ").concat(border2.color);
}
function focusRingStyle$2(opts) {
  const { base, border: border2, focusRing } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border2 && focusRingBorderStyle$2(border2), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
var __freeze$2s = Object.freeze;
var __defProp$2s = Object.defineProperty;
var __template$2s = (cooked, raw) => __freeze$2s(__defProp$2s(cooked, "raw", { value: __freeze$2s(raw || cooked.slice()) }));
var _a$2t;
var _b$16;
var _c$C;
var _d$n;
var LIST_ITEM_DATA_ATTR_ACTIVE = "data-active";
var LIST_ITEM_INTERACTIVE_SELECTOR = "a,button";
var FocusOverlayDiv = st.div((_ref20) => {
  let { theme, offset: offset2 } = _ref20;
  return nt(_a$2t || (_a$2t = __template$2s(["\n    bottom: ", "px;\n    border-radius: ", ";\n    left: ", "px;\n    pointer-events: none;\n    position: absolute;\n    right: ", "px;\n    top: ", "px;\n    z-index: 2;\n\n    ", ":focus-visible & {\n      box-shadow: ", ";\n    }\n  "])), -offset2, rem(theme.sanity.radius[1]), -offset2, -offset2, -offset2, VirtualListBox, focusRingStyle$2({ base: theme.sanity.color.base, focusRing: theme.sanity.focusRing }));
});
var PointerOverlayDiv = st.div(_b$16 || (_b$16 = __template$2s(["\n  bottom: 0;\n  display: none;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1;\n\n  @media (hover: hover) {\n    &[data-enabled='true'] {\n      display: block;\n    }\n  }\n"])));
var VirtualListBox = st(Box)(_c$C || (_c$C = __template$2s(["\n  height: 100%;\n  outline: none;\n  overflow-x: hidden;\n  overflow-y: auto;\n  overscroll-behavior: contain;\n  width: 100%;\n"])));
var VirtualListChildBox = st(Box).attrs((_ref21) => {
  let { $height } = _ref21;
  return { style: { height: "".concat($height, "px") } };
})(_d$n || (_d$n = __template$2s(["\n  position: relative;\n  width: 100%;\n"])));
var CommandList = (0, import_react51.forwardRef)(function CommandList2(_ref22, ref) {
  let { activeItemDataAttr = LIST_ITEM_DATA_ATTR_ACTIVE, ariaLabel, ariaMultiselectable = false, autoFocus, canReceiveFocus, fixedHeight, focusRingOffset = 0, getItemDisabled, getItemKey: getItemKey2, getItemSelected, initialIndex, initialScrollAlign = "start", inputElement, itemHeight, items, onEndReached, onEndReachedIndexOffset = 0, onlyShowSelectionWhenActive, overscan, renderItem, wrapAround = true, ...responsivePaddingProps } = _ref22;
  const isMountedRef = (0, import_react51.useRef)(false);
  const commandListId = (0, import_react51.useRef)((0, import_react51.useId)());
  const activeIndexRef = (0, import_react51.useRef)(initialIndex != null ? initialIndex : 0);
  const [childContainerElement, setChildContainerElement] = (0, import_react51.useState)(null);
  const [hovered, setHovered] = (0, import_react51.useState)(false);
  const [pointerOverlayElement, setPointerOverlayElement] = (0, import_react51.useState)(null);
  const [virtualListElement, setVirtualListElement] = (0, import_react51.useState)(null);
  const handleChange = (0, import_react51.useCallback)((v) => {
    if (!onEndReached)
      return;
    const [lastItem] = [...v.getVirtualItems()].reverse();
    if (!lastItem)
      return;
    const reachedEnd = lastItem.index >= items.length - onEndReachedIndexOffset - 1;
    if (reachedEnd && isMountedRef.current) {
      onEndReached();
    }
  }, [onEndReached, items.length, onEndReachedIndexOffset]);
  const virtualizer = useVirtualizer({ count: items.length, getItemKey: getItemKey2, getScrollElement: () => virtualListElement, estimateSize: () => itemHeight, onChange: handleChange, overscan });
  const itemIndices = (0, import_react51.useMemo)(() => {
    let i = -1;
    return items.reduce((acc, _, index) => {
      var _a22, _b22;
      const disabled = (_a22 = getItemDisabled == null ? void 0 : getItemDisabled(index)) != null ? _a22 : false;
      const selected = (_b22 = getItemSelected == null ? void 0 : getItemSelected(index)) != null ? _b22 : false;
      if (!disabled) {
        i += 1;
      }
      acc[index] = { activeIndex: disabled ? null : i, disabled, selected };
      return acc;
    }, []);
  }, [getItemDisabled, getItemSelected, items]);
  const activeItemCount = (0, import_react51.useMemo)(() => itemIndices.filter((v) => !v.disabled).length, [itemIndices]);
  const enableChildContainerPointerEvents = (0, import_react51.useCallback)((enabled) => pointerOverlayElement == null ? void 0 : pointerOverlayElement.setAttribute("data-enabled", (!enabled).toString()), [pointerOverlayElement]);
  const getChildDescendantId = (0, import_react51.useCallback)((index) => "".concat(commandListId.current, "-item-").concat(index), []);
  const getCommandListChildrenId = (0, import_react51.useCallback)(() => "".concat(commandListId.current, "-children"), []);
  const showChildrenActiveState = (0, import_react51.useCallback)(() => {
    const hasFocus = [inputElement, virtualListElement].some((el) => document.activeElement === el);
    if (onlyShowSelectionWhenActive && !hasFocus && !hovered) {
      return;
    }
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    childElements == null ? void 0 : childElements.forEach((child) => {
      var _a22, _b22, _c22;
      const virtualIndex = Number((_a22 = child.dataset) == null ? void 0 : _a22.index);
      const targetIndex = (_b22 = itemIndices[virtualIndex]) == null ? void 0 : _b22.activeIndex;
      (_c22 = child.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR)) == null ? void 0 : _c22.toggleAttribute(activeItemDataAttr, targetIndex === activeIndexRef.current);
    });
  }, [activeItemDataAttr, childContainerElement == null ? void 0 : childContainerElement.children, hovered, inputElement, itemIndices, onlyShowSelectionWhenActive, virtualListElement]);
  const hideChildrenActiveState = (0, import_react51.useCallback)(() => {
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    childElements == null ? void 0 : childElements.forEach((child) => {
      var _a22;
      (_a22 = child.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR)) == null ? void 0 : _a22.toggleAttribute(activeItemDataAttr, false);
    });
  }, [activeItemDataAttr, childContainerElement == null ? void 0 : childContainerElement.children]);
  const refreshChildrenActiveStateThrottled = (0, import_react51.useMemo)(() => {
    return (0, import_throttle3.default)(showChildrenActiveState, 200);
  }, [showChildrenActiveState]);
  const handleUpdateActiveDescendant = (0, import_react51.useCallback)(() => {
    const activeIndex = activeIndexRef == null ? void 0 : activeIndexRef.current;
    if (items.length > 0) {
      inputElement == null ? void 0 : inputElement.setAttribute("aria-activedescendant", getChildDescendantId(activeIndex));
      virtualListElement == null ? void 0 : virtualListElement.setAttribute("aria-activedescendant", getChildDescendantId(activeIndex));
    } else {
      inputElement == null ? void 0 : inputElement.removeAttribute("aria-activedescendant");
      virtualListElement == null ? void 0 : virtualListElement.removeAttribute("aria-activedescendant");
    }
  }, [getChildDescendantId, inputElement, items.length, virtualListElement]);
  const handleGetTopIndex = (0, import_react51.useCallback)(() => {
    var _a22, _b22;
    const childContainerParentElement = childContainerElement == null ? void 0 : childContainerElement.parentElement;
    if (childContainerElement && childContainerParentElement) {
      const offset2 = childContainerParentElement.getBoundingClientRect().top - childContainerElement.getBoundingClientRect().top;
      return (_b22 = (_a22 = virtualizer.getVirtualItemForOffset(offset2)) == null ? void 0 : _a22.index) != null ? _b22 : -1;
    }
    return -1;
  }, [childContainerElement, virtualizer]);
  const setActiveIndex = (0, import_react51.useCallback)((_ref23) => {
    let { index, scrollAlign, scrollIntoView: scrollIntoView2 = true } = _ref23;
    activeIndexRef.current = index;
    handleUpdateActiveDescendant();
    showChildrenActiveState();
    if (scrollIntoView2) {
      const virtualListIndex = itemIndices.findIndex((i) => i.activeIndex === index);
      if (virtualListIndex > -1) {
        virtualizer.scrollToIndex(virtualListIndex, scrollAlign ? { align: scrollAlign } : {});
      }
    }
  }, [handleUpdateActiveDescendant, itemIndices, showChildrenActiveState, virtualizer]);
  const selectAdjacentItemIndex = (0, import_react51.useCallback)((direction) => {
    let nextIndex = -1;
    const lastIndex = activeItemCount - 1;
    if (direction === "next") {
      const wrapAroundIndex = wrapAround ? 0 : lastIndex;
      nextIndex = activeIndexRef.current < activeItemCount - 1 ? activeIndexRef.current + 1 : wrapAroundIndex;
    }
    if (direction === "previous") {
      const wrapAroundIndex = wrapAround ? lastIndex : 0;
      nextIndex = activeIndexRef.current > 0 ? activeIndexRef.current - 1 : wrapAroundIndex;
    }
    setActiveIndex({ index: nextIndex, scrollIntoView: true });
    enableChildContainerPointerEvents(false);
  }, [activeItemCount, enableChildContainerPointerEvents, setActiveIndex, wrapAround]);
  const focusElement = (0, import_react51.useCallback)((type) => {
    switch (type) {
      case "input":
        inputElement == null ? void 0 : inputElement.focus();
        break;
      case "list":
        virtualListElement == null ? void 0 : virtualListElement.focus();
        break;
    }
  }, [inputElement, virtualListElement]);
  const focusInputElement = (0, import_react51.useCallback)(() => {
    inputElement == null ? void 0 : inputElement.focus();
  }, [inputElement]);
  const focusListElement = (0, import_react51.useCallback)(() => {
    virtualListElement == null ? void 0 : virtualListElement.focus();
  }, [virtualListElement]);
  const handleChildMouseEnter = (0, import_react51.useCallback)((index) => () => {
    setActiveIndex({ index, scrollIntoView: false });
  }, [setActiveIndex]);
  const handleFocus = (0, import_react51.useCallback)(() => {
    showChildrenActiveState();
  }, [showChildrenActiveState]);
  const handleKeyDown = (0, import_react51.useCallback)((type) => (event) => {
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    if (!childElements.length) {
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      focusElement(type);
      selectAdjacentItemIndex("next");
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      focusElement(type);
      selectAdjacentItemIndex("previous");
    }
    if (event.key === "Enter") {
      event.preventDefault();
      focusElement(type);
      const currentElement = childElements.find((el) => Number(el.dataset.index) === itemIndices.findIndex((i) => i.activeIndex === activeIndexRef.current));
      if (currentElement) {
        const clickableElement = currentElement == null ? void 0 : currentElement.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR);
        clickableElement == null ? void 0 : clickableElement.click();
      }
    }
  }, [childContainerElement == null ? void 0 : childContainerElement.children, focusElement, itemIndices, selectAdjacentItemIndex]);
  const handleKeyDownInput = (0, import_react51.useCallback)((event) => handleKeyDown("input")(event), [handleKeyDown]);
  const handleKeyDownList = (0, import_react51.useCallback)((event) => handleKeyDown("list")(event), [handleKeyDown]);
  const handleVirtualListMouseEnter = (0, import_react51.useCallback)(() => {
    if (onlyShowSelectionWhenActive) {
      showChildrenActiveState();
      setHovered(true);
    }
  }, [onlyShowSelectionWhenActive, showChildrenActiveState]);
  const handleVirtualListMouseLeave = (0, import_react51.useCallback)(() => {
    if (onlyShowSelectionWhenActive) {
      hideChildrenActiveState();
      setHovered(false);
    }
  }, [hideChildrenActiveState, onlyShowSelectionWhenActive]);
  (0, import_react51.useImperativeHandle)(ref, () => {
    return { focusInputElement() {
      focusInputElement();
    }, focusListElement() {
      focusListElement();
    }, getTopIndex() {
      return handleGetTopIndex();
    }, scrollToIndex(index) {
      setActiveIndex({ index });
      enableChildContainerPointerEvents(true);
    } };
  }, [enableChildContainerPointerEvents, focusInputElement, focusListElement, handleGetTopIndex, setActiveIndex]);
  (0, import_react51.useEffect)(() => {
    if (typeof initialIndex !== "undefined" && !isMountedRef.current) {
      setActiveIndex({ index: initialIndex, scrollAlign: initialScrollAlign, scrollIntoView: true });
    }
    isMountedRef.current = true;
  }, [initialIndex, initialScrollAlign, onlyShowSelectionWhenActive, setActiveIndex]);
  (0, import_react51.useEffect)(() => {
    function handleMouseEvent() {
      enableChildContainerPointerEvents(true);
    }
    virtualListElement == null ? void 0 : virtualListElement.addEventListener("mousemove", handleMouseEvent);
    virtualListElement == null ? void 0 : virtualListElement.addEventListener("wheel", handleMouseEvent, { passive: true });
    return () => {
      virtualListElement == null ? void 0 : virtualListElement.removeEventListener("mousemove", handleMouseEvent);
      virtualListElement == null ? void 0 : virtualListElement.removeEventListener("wheel", handleMouseEvent);
    };
  }, [enableChildContainerPointerEvents, virtualListElement]);
  (0, import_react51.useEffect)(() => {
    inputElement == null ? void 0 : inputElement.addEventListener("focus", handleFocus);
    inputElement == null ? void 0 : inputElement.addEventListener("keydown", handleKeyDownInput);
    virtualListElement == null ? void 0 : virtualListElement.addEventListener("focus", handleFocus);
    virtualListElement == null ? void 0 : virtualListElement.addEventListener("keydown", handleKeyDownList);
    return () => {
      inputElement == null ? void 0 : inputElement.removeEventListener("focus", handleFocus);
      inputElement == null ? void 0 : inputElement.removeEventListener("keydown", handleKeyDownInput);
      virtualListElement == null ? void 0 : virtualListElement.removeEventListener("focus", handleFocus);
      virtualListElement == null ? void 0 : virtualListElement.removeEventListener("keydown", handleKeyDownList);
    };
  }, [canReceiveFocus, handleFocus, handleKeyDown, handleKeyDownInput, handleKeyDownList, hideChildrenActiveState, inputElement, showChildrenActiveState, virtualListElement]);
  (0, import_react51.useEffect)(() => {
    handleUpdateActiveDescendant();
  }, [handleUpdateActiveDescendant, items]);
  (0, import_react51.useEffect)(() => {
    const mutationObserver = new MutationObserver(refreshChildrenActiveStateThrottled);
    if (childContainerElement) {
      mutationObserver.observe(childContainerElement, { childList: true, subtree: true });
    }
    return () => {
      mutationObserver.disconnect();
    };
  }, [childContainerElement, refreshChildrenActiveStateThrottled]);
  (0, import_react51.useEffect)(() => {
    inputElement == null ? void 0 : inputElement.setAttribute("aria-autocomplete", "list");
    inputElement == null ? void 0 : inputElement.setAttribute("aria-expanded", "true");
    inputElement == null ? void 0 : inputElement.setAttribute("aria-controls", getCommandListChildrenId());
    inputElement == null ? void 0 : inputElement.setAttribute("role", "combobox");
  }, [getCommandListChildrenId, inputElement]);
  (0, import_react51.useEffect)(() => {
    if (autoFocus) {
      focusElement(autoFocus);
    }
  }, [autoFocus, canReceiveFocus, focusListElement, focusInputElement, focusElement]);
  const rootTabIndex = canReceiveFocus ? 0 : -1;
  return (0, import_jsx_runtime6.jsxs)(VirtualListBox, { id: getCommandListChildrenId(), onMouseEnter: handleVirtualListMouseEnter, onMouseLeave: handleVirtualListMouseLeave, ref: setVirtualListElement, sizing: "border", tabIndex: rootTabIndex, ...responsivePaddingProps, children: [canReceiveFocus && (0, import_jsx_runtime6.jsx)(FocusOverlayDiv, { offset: focusRingOffset }), (0, import_jsx_runtime6.jsx)(PointerOverlayDiv, { "aria-hidden": "true", "data-enabled": true, ref: setPointerOverlayElement }), virtualizer && (0, import_jsx_runtime6.jsx)(VirtualListChildBox, { forwardedAs: "ul", $height: virtualizer.getTotalSize(), "aria-label": ariaLabel, "aria-multiselectable": ariaMultiselectable, flex: 1, ref: setChildContainerElement, role: "listbox", children: virtualizer.getVirtualItems().map((virtualRow) => {
    const virtualIndex = virtualRow.index;
    const { activeIndex, disabled, selected } = itemIndices[virtualIndex];
    const itemToRender = renderItem(items[virtualIndex], { activeIndex, disabled, selected, virtualIndex });
    const clonedItem = (0, import_react51.cloneElement)(itemToRender, { tabIndex: -1 });
    const activeAriaAttributes = typeof activeIndex === "number" && !disabled ? { "aria-posinset": activeIndex + 1, ...ariaMultiselectable ? { "aria-selected": selected.toString() } : {}, "aria-setsize": activeItemCount, id: getChildDescendantId(activeIndex), role: "option", onMouseEnter: handleChildMouseEnter(activeIndex) } : {};
    return (0, import_jsx_runtime6.jsx)(Stack, { as: "li", "data-index": virtualIndex, ref: fixedHeight ? void 0 : virtualizer.measureElement, style: { flex: 1, ...fixedHeight ? { height: "".concat(virtualRow.size, "px") } : {}, left: 0, position: "absolute", top: 0, transform: "translateY(".concat(virtualRow.start, "px)"), width: "100%" }, tabIndex: -1, ...activeAriaAttributes, children: clonedItem }, virtualRow.key);
  }) })] });
});
var NoJsStyles = "\n.sanity-app-no-js__root {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  background: #fff;\n}\n\n.sanity-app-no-js__content {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  font-family: helvetica, arial, sans-serif;\n}\n";
function NoJavascript() {
  return (0, import_jsx_runtime6.jsx)("noscript", { children: (0, import_jsx_runtime6.jsx)("div", { className: "sanity-app-no-js__root", children: (0, import_jsx_runtime6.jsxs)("div", { className: "sanity-app-no-js__content", children: [(0, import_jsx_runtime6.jsx)("style", { type: "text/css", children: NoJsStyles }), (0, import_jsx_runtime6.jsx)("h1", { children: "JavaScript disabled" }), (0, import_jsx_runtime6.jsxs)("p", { children: ["Please ", (0, import_jsx_runtime6.jsx)("a", { href: "https://www.enable-javascript.com/", children: "enable JavaScript" }), " in your browser and reload the page to proceed."] })] }) }) });
}
var errorHandlerScript = `
;(function () {
  var _caughtErrors = []

  var errorChannel = (function () {
    var subscribers = []

    function publish(msg) {
      for (var i = 0; i < subscribers.length; i += 1) {
        subscribers[i](msg)
      }
    }

    function subscribe(subscriber) {
      subscribers.push(subscriber)

      return function () {
        var idx = subscribers.indexOf(subscriber)

        if (idx > -1) {
          subscribers.splice(idx, 1)
        }
      }
    }

    return {publish, subscribe, subscribers}
  })()

  // NOTE: Store the error channel instance in the global scope so that the Studio application can
  // access it and subscribe to errors.
  window.__sanityErrorChannel = {
    subscribe: errorChannel.subscribe,
  }

  function _nextTick(callback) {
    setTimeout(callback, 0)
  }

  function _handleError(error, params) {
    _nextTick(function () {
      // - If there are error channel subscribers, then we notify them (no console error).
      // - If there are no subscribers, then we log the error to the console and render the error overlay.
      if (errorChannel.subscribers.length) {
        errorChannel.publish({error, params})
      } else {
        console.error(error)

        _renderErrorOverlay(error, params)
      }
    })
  }

  var ERROR_BOX_STYLE = [
    'background: #fff',
    'border-radius: 6px',
    'box-sizing: border-box',
    'color: #121923',
    'flex: 1',
    "font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif",
    'font-size: 16px',
    'line-height: 21px',
    'margin: 0 auto',
    'max-width: 960px',
    'overflow: auto',
    'padding: 20px',
    'width: 100%',
  ].join(';')

  var ERROR_CODE_STYLE = [
    'color: #972E2A',
    "font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace",
    'font-size: 13px',
    'line-height: 17px',
    'margin: 0',
  ].join(';')

  function _renderErrorOverlay(error, params) {
    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')
    var colno = params.event.colno
    var lineno = params.event.lineno
    var filename = params.event.filename

    errorElement.id = '__sanityError'
    errorElement.innerHTML = [
      '<div style="' + ERROR_BOX_STYLE + '">',
      '<div style="font-weight: 700;">Uncaught error: ' + error.message + '</div>',
      '<div style="color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;">' +
        filename +
        ':' +
        lineno +
        ':' +
        colno +
        '</div>',
      '<pre style="' + ERROR_CODE_STYLE + '">' + error.stack + '</pre>',
      '</div>',
    ].join('')

    errorElement.style.position = 'fixed'
    errorElement.style.zIndex = 1000000
    errorElement.style.top = 0
    errorElement.style.left = 0
    errorElement.style.right = 0
    errorElement.style.bottom = 0
    errorElement.style.padding = '20px'
    errorElement.style.background = 'rgba(16,17,18,0.66)'
    errorElement.style.display = 'flex'
    errorElement.style.alignItems = 'center'
    errorElement.style.justifyContent = 'center'

    document.body.appendChild(errorElement)
  }

  // NOTE:
  // Yes  we're attaching 2 error listeners below 
  // This is because React makes the same error throw twice (in development mode).
  // See: https://github.com/facebook/react/issues/10384

  // Error listener #1
  window.onerror = function (event, source, lineno, colno, error) {
    _nextTick(function () {
      if (_caughtErrors.indexOf(error) !== -1) return

      _caughtErrors.push(error)

      _handleError(error, {
        event,
        lineno,
        colno,
        source,
      })

      _nextTick(function () {
        var idx = _caughtErrors.indexOf(error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    // IMPORTANT: this callback must return \`true\` to prevent the error from being rendered in
    // the browsers console.
    return true
  }

  // Error listener #2
  window.addEventListener('error', function (event) {
    if (_caughtErrors.indexOf(event.error) !== -1) return true

    _caughtErrors.push(event.error)

    _handleError(event.error, {
      event,
      lineno: event.lineno,
      colno: event.colno,
    })

    _nextTick(function () {
      _nextTick(function () {
        var idx = _caughtErrors.indexOf(event.error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    return true
  })
})()
`;
function GlobalErrorHandler() {
  return (0, import_jsx_runtime6.jsx)("script", { dangerouslySetInnerHTML: { __html: errorHandlerScript } });
}
function Favicons(_ref24) {
  let { basePath } = _ref24;
  const base = "".concat(basePath.replace(/\/+$/, ""), "/static");
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)("link", { rel: "icon", href: "".concat(base, "/favicon.ico"), sizes: "any" }), (0, import_jsx_runtime6.jsx)("link", { rel: "icon", href: "".concat(base, "/favicon.svg"), type: "image/svg+xml" }), (0, import_jsx_runtime6.jsx)("link", { rel: "apple-touch-icon", href: "".concat(base, "/apple-touch-icon.png") }), (0, import_jsx_runtime6.jsx)("link", { rel: "manifest", href: "".concat(base, "/manifest.webmanifest") })] });
}
var globalStyles = "\n  html {\n    background-color: #f1f3f6;\n  }\n  html,\n  body,\n  #sanity {\n    height: 100%;\n  }\n  body {\n    margin: 0;\n    -webkit-font-smoothing: antialiased;\n  }\n";
var EMPTY_ARRAY$a = [];
function DefaultDocument(props2) {
  const { entryPath, css = EMPTY_ARRAY$a, basePath = "/" } = props2;
  return (0, import_jsx_runtime6.jsxs)("html", { lang: "en", children: [(0, import_jsx_runtime6.jsxs)("head", { children: [(0, import_jsx_runtime6.jsx)("meta", { charSet: "utf-8" }), (0, import_jsx_runtime6.jsx)("meta", { name: "viewport", content: "width=device-width, initial-scale=1, viewport-fit=cover" }), (0, import_jsx_runtime6.jsx)("meta", { name: "robots", content: "noindex" }), (0, import_jsx_runtime6.jsx)("meta", { name: "referrer", content: "same-origin" }), (0, import_jsx_runtime6.jsx)(Favicons, { basePath }), (0, import_jsx_runtime6.jsx)("title", { children: "Sanity Studio" }), (0, import_jsx_runtime6.jsx)(GlobalErrorHandler, {}), css.map((href) => (0, import_jsx_runtime6.jsx)("link", { rel: "stylesheet", href }, href)), (0, import_jsx_runtime6.jsx)("style", { children: globalStyles })] }), (0, import_jsx_runtime6.jsxs)("body", { children: [(0, import_jsx_runtime6.jsx)("div", { id: "sanity" }), (0, import_jsx_runtime6.jsx)("script", { type: "module", src: entryPath }), (0, import_jsx_runtime6.jsx)(NoJavascript, {})] })] });
}
var actionIds = /* @__PURE__ */ new WeakMap();
var counter = 0;
function getHookId(actionHook) {
  const cachedId = actionIds.get(actionHook);
  if (cachedId)
    return cachedId;
  const id4 = "".concat(actionHook.name || actionHook.displayName || "<anonymous>", "-").concat(counter++);
  actionIds.set(actionHook, id4);
  return id4;
}
function useShallowCompareMemoize(value) {
  const ref = (0, import_react51.useRef)(void 0);
  if (!(0, import_shallow_equals.default)(value, ref.current)) {
    ref.current = value;
  }
  return [ref.current];
}
function useShallowCompareEffect(callback, dependencies) {
  (0, import_react51.useEffect)(callback, useShallowCompareMemoize(dependencies));
}
var HookStateContainer = (0, import_react51.memo)(function HookStateContainer2(props2) {
  const { hook, args, id: id4, onNext, onReset, onRequestUpdate } = props2;
  const hookState = hook({ ...args, onComplete: () => {
    onReset(id4);
  } });
  useShallowCompareEffect(() => {
    onNext(id4, hookState);
    onRequestUpdate();
    return () => {
      onNext(id4, null);
      onRequestUpdate();
    };
  }, hookState);
  return null;
}, (prev, next) => prev.args === next.args);
var requestIdleCallbackShim$1 = (callback) => {
  const start = Date.now();
  return setTimeout(() => {
    callback({ didTimeout: false, timeRemaining() {
      return Math.max(0, Date.now() - start);
    } });
  }, 1);
};
var cancelIdleCallbackShim$1 = (handle) => {
  return clearTimeout(handle);
};
var _requestIdleCallback = typeof requestIdleCallback === "undefined" ? requestIdleCallbackShim$1 : requestIdleCallback;
var _cancelIdleCallback = typeof cancelIdleCallback === "undefined" ? cancelIdleCallbackShim$1 : cancelIdleCallback;
var throttleOptions = { trailing: true };
function GetHookCollectionState(props2) {
  const { hooks, args, children, onReset } = props2;
  const statesRef = (0, import_react51.useRef)({});
  const [tickId, setTick] = (0, import_react51.useState)(0);
  const [keys, setKeys] = (0, import_react51.useState)({});
  const ricHandle = (0, import_react51.useRef)(null);
  const handleRequestUpdate = (0, import_react51.useCallback)(() => {
    if (ricHandle.current) {
      _cancelIdleCallback(ricHandle.current);
    }
    ricHandle.current = _requestIdleCallback(() => {
      ricHandle.current = null;
      setTick((tick) => tick + 1);
    });
  }, []);
  const handleRequestUpdateThrottled = useThrottledCallback(handleRequestUpdate, 60, throttleOptions);
  const handleNext = (0, import_react51.useCallback)((id4, hookState) => {
    if (hookState === null) {
      delete statesRef.current[id4];
    } else {
      const current = statesRef.current[id4];
      statesRef.current[id4] = { ...current, value: hookState };
    }
  }, []);
  const handleReset = (0, import_react51.useCallback)((id4) => {
    setKeys((currentKeys) => ({ ...currentKeys, [id4]: (currentKeys[id4] || 0) + 1 }));
    if (onReset) {
      onReset();
    }
  }, [onReset]);
  const hookIds = (0, import_react51.useMemo)(() => hooks.map((hook) => getHookId(hook)), [hooks]);
  const states = (0, import_react51.useMemo)(
    () => hookIds.map((id4) => {
      var _a4;
      return (_a4 = statesRef.current[id4]) == null ? void 0 : _a4.value;
    }).filter(isNonNullable$3),
    // eslint-disable-next-line react-hooks/exhaustive-deps -- tickId is used to refresh the memo, before it can be removed it needs to be investigated what impact it has
    [hookIds, tickId]
  );
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [hooks.map((hook) => {
    const id4 = getHookId(hook);
    const key2 = keys[id4] || 0;
    return (0, import_jsx_runtime6.jsx)(HookStateContainer, { hook, id: id4, args, onNext: handleNext, onRequestUpdate: handleRequestUpdateThrottled, onReset: handleReset }, "".concat(id4, "-").concat(key2));
  }), children({ states })] });
}
function Hotkeys3(_ref25) {
  let { makePlatformAware = true, keys: hotKeys = [], ...props2 } = _ref25;
  const keys = makePlatformAware ? hotKeys.map(platformifyKey) : hotKeys;
  return (0, import_jsx_runtime6.jsx)(Hotkeys, { ...props2, keys });
}
var IS_APPLE_DEVICE = typeof navigator === "undefined" || typeof navigator.platform !== "string" ? false : /Mac|iPod|iPhone|iPad/.test(navigator.platform || "");
function platformifyKey(key2) {
  const lowerKey = key2.toLowerCase();
  if (lowerKey === "alt" && IS_APPLE_DEVICE) {
    return matchCase(key2, "option");
  }
  if (lowerKey === "option" && !IS_APPLE_DEVICE) {
    return matchCase(key2, "alt");
  }
  return key2;
}
function matchCase(original, target) {
  const orgLength = original.length;
  return target.replace(/./g, (char, i) => {
    return i < orgLength && original[i] === original[i].toUpperCase() ? char.toUpperCase() : char;
  });
}
var OPEN_TAG_RE = /^<(?<tag>[^\s\d<][^/?><]+)\/?>/;
var CLOSE_TAG_RE = /<\/(?<tag>[^>]+)>/;
var SELF_CLOSING_RE = /<[^>]+\/>/;
var VALID_COMPONENT_NAME_RE = /^[A-Z][A-Za-z0-9]+$/;
var VALID_HTML_TAG_NAME_RE = /^[a-z]+$/;
function isSelfClosing(tag) {
  return SELF_CLOSING_RE.test(tag);
}
function matchOpenTag(input) {
  return input.match(OPEN_TAG_RE);
}
function matchCloseTag(input) {
  return input.match(CLOSE_TAG_RE);
}
function validateTagName(tagName2) {
  const isValidComponentName = VALID_COMPONENT_NAME_RE.test(tagName2);
  if (isValidComponentName) {
    return;
  }
  const isValidHtmlTagName = VALID_HTML_TAG_NAME_RE.test(tagName2);
  if (isValidHtmlTagName) {
    return;
  }
  throw new Error(tagName2.trim() === tagName2 ? 'Invalid tag "<'.concat(tagName2, '>". Tag names must be lowercase HTML tags or start with an uppercase letter and can only include letters and numbers.') : 'Invalid tag "<'.concat(tagName2, '>". No whitespace allowed in tags.'));
}
function simpleParser(input) {
  const tokens = [];
  let text = "";
  let openTag = "";
  let remainder = input;
  while (remainder.length > 0) {
    if (!openTag && remainder[0] === "<") {
      const match4 = matchOpenTag(remainder);
      if (match4) {
        const tagName2 = match4.groups.tag;
        validateTagName(tagName2);
        if (text) {
          tokens.push({ type: "text", text });
          text = "";
        }
        if (isSelfClosing(match4[0])) {
          tokens.push({ type: "tagOpen", selfClosing: true, name: tagName2 });
        } else {
          tokens.push({ type: "tagOpen", name: tagName2 });
          openTag = tagName2;
        }
        remainder = remainder.substring(match4[0].length);
      } else {
        text += remainder[0];
        remainder = remainder.substring(1);
      }
    } else if (openTag && remainder[0] === "<" && remainder[1] !== "<") {
      const match4 = matchCloseTag(remainder);
      if (match4) {
        const tagName2 = match4.groups.tag;
        if (remainder[1] !== "/") {
          throw new Error("Expected closing tag for <".concat(openTag, ">, but found new opening tag <").concat(tagName2, ">. Nested tags is not supported."));
        }
        if (tagName2 !== openTag) {
          throw new Error("Expected closing tag for <".concat(openTag, ">, but found closing tag </").concat(tagName2, "> instead. Make sure each opening tag has a matching closing tag."));
        }
        if (text) {
          tokens.push({ type: "text", text });
          text = "";
        }
        tokens.push({ type: "tagClose", name: tagName2 });
        openTag = "";
        remainder = remainder.substring(match4[0].length);
      } else {
        text += remainder[0];
        remainder = remainder.substring(1);
      }
    } else {
      text += remainder[0];
      remainder = remainder.substring(1);
    }
  }
  if (openTag) {
    throw new Error("No matching closing tag for <".concat(openTag, '> found. Either make it self closing (e.g. "<').concat(openTag, '/>") or close it (e.g "<').concat(openTag, ">...</").concat(openTag, '>").'));
  }
  if (text) {
    tokens.push({ type: "text", text });
  }
  return tokens;
}
var COMPONENT_NAME_RE = /^[A-Z]/;
var RECOGNIZED_HTML_TAGS = ["abbr", "address", "cite", "code", "del", "em", "ins", "kbd", "q", "samp", "strong", "sub", "sup"];
function render(tokens, componentMap) {
  const [head, ...tail] = tokens;
  if (!head) {
    return null;
  }
  if (head.type === "text") {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [head.text, render(tail, componentMap)] });
  }
  if (head.type === "tagOpen" && head.selfClosing) {
    const Component3 = componentMap[head.name];
    if (!Component3) {
      throw new Error("Component not found: ".concat(head.name));
    }
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Component3, {}), render(tail, componentMap)] });
  }
  if (head.type === "tagOpen" && !head.selfClosing) {
    const nextCloseIdx = tail.findIndex((token) => token.type === "tagClose");
    const nextClose = tail[nextCloseIdx];
    if (nextClose) {
      if (head.name !== nextClose.name) {
        throw new Error("Nested tags is not allowed");
      }
    }
    const Component3 = componentMap[head.name];
    if (!Component3 && COMPONENT_NAME_RE.test(head.name)) {
      throw new Error("Component not defined: ".concat(head.name));
    }
    if (!Component3 && !RECOGNIZED_HTML_TAGS.includes(head.name)) {
      throw new Error('HTML tag "'.concat(head.name, '" is not allowed'));
    }
    const children = tail.slice(0, nextCloseIdx);
    const remaining = tail.slice(nextCloseIdx + 1);
    return Component3 ? (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Component3, { children: render(children, componentMap) }), render(remaining, componentMap)] }) : (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [import_react51.default.createElement(head.name, {}, render(children, componentMap)), render(remaining, componentMap)] });
  }
  return null;
}
function Translate(props2) {
  const translated = props2.t(props2.i18nKey, { context: props2.context, replace: props2.values, count: props2.values && "count" in props2.values && typeof props2.values.count === "number" ? props2.values.count : void 0 });
  const tokens = (0, import_react51.useMemo)(() => simpleParser(translated), [translated]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: render(tokens, props2.components || {}) });
}
var intlCache = (() => {
  const caches = { dateTimeFormat: createCache(), listFormat: createCache(), numberFormat: createCache(), relativeTimeFormat: createCache() };
  function dateTimeFormat(locale, options) {
    const key2 = getCacheId(locale, options);
    let instance2 = caches.dateTimeFormat[key2];
    if (instance2) {
      return instance2;
    }
    instance2 = new Intl.DateTimeFormat(locale, options);
    caches.dateTimeFormat[key2] = instance2;
    return instance2;
  }
  function listFormat(locale, options) {
    const key2 = getCacheId(locale, options);
    let instance2 = caches.listFormat[key2];
    if (instance2) {
      return instance2;
    }
    instance2 = new Intl.ListFormat(locale, options);
    caches.listFormat[key2] = instance2;
    return instance2;
  }
  function numberFormat(locale, options) {
    const key2 = getCacheId(locale, options);
    let instance2 = caches.numberFormat[key2];
    if (instance2) {
      return instance2;
    }
    instance2 = new Intl.NumberFormat(locale, options);
    caches.numberFormat[key2] = instance2;
    return instance2;
  }
  function relativeTimeFormat(locale, options) {
    const key2 = getCacheId(locale, options);
    let instance2 = caches.relativeTimeFormat[key2];
    if (instance2) {
      return instance2;
    }
    instance2 = new Intl.RelativeTimeFormat(locale, options);
    caches.relativeTimeFormat[key2] = instance2;
    return instance2;
  }
  return { dateTimeFormat, listFormat, numberFormat, relativeTimeFormat };
})();
function createCache() {
  return /* @__PURE__ */ Object.create(null);
}
function getCacheId(locale, options) {
  return "".concat(locale, "-").concat(JSON.stringify(orderedProps(options)));
}
function orderedProps(obj) {
  const segments = [];
  for (const [key2, value] of Object.entries(obj)) {
    segments.push("".concat(key2, "=").concat(JSON.stringify(value)));
  }
  return segments.sort().join("\n");
}
var LocaleContext = (0, import_react51.createContext)(void 0);
function useCurrentLocale() {
  return useLocale().currentLocale;
}
function useLocale() {
  const context = (0, import_react51.useContext)(LocaleContext);
  if (!context) {
    throw new Error("Sanity LocaleContext value missing. Is this hook being used outside LocaleContext.Provider?");
  }
  return context;
}
function useIntlListFormat() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const currentLocale = useCurrentLocale();
  return intlCache.listFormat(currentLocale, options);
}
var EMPTY_ARRAY$9 = [];
function InsufficientPermissionsMessage(_ref26) {
  let { currentUser, context } = _ref26;
  const { t: t3 } = useTranslation2();
  const list = useIntlListFormat({ style: "short", type: "unit" });
  const roles = (currentUser == null ? void 0 : currentUser.roles) || EMPTY_ARRAY$9;
  const Roles = (0, import_react51.useCallback)(() => (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: list.formatToParts(roles.map((role) => role.title || (0, import_startCase2.default)(role.name))).map((i, index) => i.type === "element" ? (
    // eslint-disable-next-line react/no-array-index-key
    (0, import_jsx_runtime6.jsx)("code", { children: i.value }, "".concat(i.value, "-").concat(index))
  ) : (
    // eslint-disable-next-line react/no-array-index-key
    (0, import_jsx_runtime6.jsx)(import_react51.Fragment, { children: i.value }, "".concat(i.value, "-").concat(index))
  )) }), [roles, list]);
  return (0, import_jsx_runtime6.jsxs)(Box, { padding: 2, children: [(0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(AccessDeniedIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: t3("insufficient-permissions-message.title") })] }), (0, import_jsx_runtime6.jsx)(Inline, { marginTop: 4, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { i18nKey: "insufficient-permissions-message.not-authorized-explanation", t: t3, context }) }) }), (0, import_jsx_runtime6.jsx)(Inline, { marginTop: 4, marginBottom: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { i18nKey: "insufficient-permissions-message.roles", t: t3, components: { Roles } }) }) })] });
}
function IntentButton(props2) {
  return props2.disabled ? (0, import_jsx_runtime6.jsx)(Button, { ...props2, as: "a", role: "link", "aria-disabled": "true" }) : (0, import_jsx_runtime6.jsx)(Button, { ...props2, as: IntentLink });
}
var StyledContainer = st(Container)((props2) => {
  const { theme } = props2;
  const { container, media } = theme.sanity;
  return _responsive(media, props2.$width, (val) => ({
    // Make sure that the Container gets the correct width when used inside a popover.
    width: val === "auto" ? "none" : rem(container[val]),
    // Make sure that the Container width is constrained by available space.
    maxWidth: "100%"
  }));
});
var PopoverContainer$1 = import_react51.default.forwardRef(function PopoverContainer2(props2, ref) {
  const { width, ...restProps } = props2;
  const widthArr = useArrayProp(width);
  return (0, import_jsx_runtime6.jsx)(StyledContainer, { ...restProps, "data-ui": "PopoverContainer", $width: widthArr, ref });
});
var __freeze$2r = Object.freeze;
var __defProp$2r = Object.defineProperty;
var __template$2r = (cooked, raw) => __freeze$2r(__defProp$2r(cooked, "raw", { value: __freeze$2r(raw || cooked.slice()) }));
var _a$2s;
var _b$15;
var StyledPopover$3 = st(Popover)(() => {
  return nt(_a$2s || (_a$2s = __template$2r(["\n    // Make the popover scrollable if it overflows the viewport\n    [data-ui='Popover__wrapper'] {\n      overflow: auto;\n    }\n  "])));
});
var StickyLayer = st(Layer)((props2) => {
  const radii = props2.theme.sanity.radius[3];
  return nt(_b$15 || (_b$15 = __template$2r(["\n    position: sticky;\n    top: 0;\n    width: 100%;\n    background: var(--card-bg-color);\n    border-bottom: 1px solid var(--card-border-color);\n    border-top-left-radius: ", "px;\n    border-top-right-radius: ", "px;\n  "])), radii, radii);
});
function PopoverDialog(props2) {
  const { children, header, onClose, referenceElement, containerRef, width } = props2;
  const handleClose = (0, import_react51.useCallback)(() => {
    onClose();
    referenceElement == null ? void 0 : referenceElement.focus();
  }, [onClose, referenceElement]);
  const content = (0, import_jsx_runtime6.jsx)(PopoverContainer$1, { width, children: (0, import_jsx_runtime6.jsx)(es2015_default, { autoFocus: true, children: (0, import_jsx_runtime6.jsxs)(Stack, { ref: containerRef, children: [(0, import_jsx_runtime6.jsx)(StickyLayer, { children: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, paddingLeft: 3, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", weight: "semibold", children: header }) }), (0, import_jsx_runtime6.jsx)(Button, { icon: CloseIcon, mode: "bleed", onClick: handleClose })] }) }) }), children] }) }) });
  return (0, import_jsx_runtime6.jsx)(StyledPopover$3, { portal: true, constrainSize: true, content, open: true, referenceElement });
}
var __freeze$2q = Object.freeze;
var __defProp$2q = Object.defineProperty;
var __template$2q = (cooked, raw) => __freeze$2q(__defProp$2q(cooked, "raw", { value: __freeze$2q(raw || cooked.slice()) }));
var _a$2r;
var StyledCard$2 = st(Card)(() => {
  return nt(_a$2r || (_a$2r = __template$2q(["\n    /* this is a hack to avoid layout jumps while previews are loading\n    there's probably better ways of solving this */\n    min-height: 35px;\n\n    /* TextWithTone uses its own logic to set color, and we therefore need */\n    /* to override this logic in order to set the correct color in different states */\n    &[data-selected],\n    &[data-pressed],\n    &:active {\n      [data-ui='TextWithTone'] {\n        color: inherit;\n      }\n    }\n  "])));
});
var PreviewCardContext = (0, import_react51.createContext)({ selected: false });
function usePreviewCard() {
  const context = (0, import_react51.useContext)(PreviewCardContext);
  if (!context) {
    throw new Error("PreviewCard: missing context value");
  }
  return context;
}
var PreviewCard$1 = (0, import_react51.forwardRef)(function PreviewCard2(props2, ref) {
  const { children, selected, as, ...restProps } = props2;
  return (0, import_jsx_runtime6.jsx)(StyledCard$2, { "data-ui": "PreviewCard", ...restProps, forwardedAs: as, ref, selected, children: (0, import_jsx_runtime6.jsx)(PreviewCardContext.Provider, { value: { selected }, children }) });
});
function useIntlNumberFormat() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const currentLocale = useCurrentLocale();
  return intlCache.numberFormat(currentLocale, options);
}
function useIntlDateTimeFormat() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const currentLocale = useCurrentLocale();
  return intlCache.dateTimeFormat(currentLocale, options);
}
var GlobalStyle = at((_ref27) => {
  let { theme } = _ref27;
  const { color: color3, fonts: fonts2 } = theme.sanity;
  return { html: { backgroundColor: color3.base.bg }, "#sanity": { fontFamily: fonts2.text.family } };
});
var UserColorManagerContext = (0, import_react51.createContext)(null);
function useUserColorManager() {
  const userColorManager = (0, import_react51.useContext)(UserColorManagerContext);
  if (!userColorManager) {
    throw new Error("UserColorManager: missing context value");
  }
  return userColorManager;
}
function useUserColor(userId) {
  const manager = useUserColorManager();
  return useMemoObservable(userId ? manager.listen(userId) : empty(), [userId], manager.get(null));
}
var DEFAULT_CURRENT_USER_HUE = "purple";
var USER_COLOR_EXCLUDE_HUES = ["green", "red", "gray"];
var defaultHues = COLOR_HUES.filter((hue) => !USER_COLOR_EXCLUDE_HUES.includes(hue));
var getTints = (scheme) => {
  const isDarkScheme = scheme === "dark";
  return { background: isDarkScheme ? "900" : "100", border: isDarkScheme ? "700" : "300", text: isDarkScheme ? "200" : "700" };
};
var getDefaultColors = (scheme) => {
  const { background, border: border2, text } = getTints(scheme);
  return defaultHues.reduce((colors2, hue) => {
    colors2[hue] = { name: hue, background: hues[hue][background].hex, border: hues[hue][border2].hex, text: hues[hue][text].hex, tints: hues[hue] };
    return colors2;
  }, {});
};
var getAnonymousColor = (scheme) => {
  const { background, border: border2, text } = getTints(scheme);
  return { name: "gray", background: hues.gray[background].hex, border: hues.gray[border2].hex, text: hues.gray[text].hex, tints: hues.gray };
};
function createUserColorManager(options) {
  const { anonymousColor: anonymousColorProp, colors: colors2, currentUserColor: currentUserColorProp, scheme } = options;
  const userColors = colors2 || getDefaultColors(scheme);
  const anonymousColor = anonymousColorProp || getAnonymousColor(scheme);
  const currentUserColor = currentUserColorProp || DEFAULT_CURRENT_USER_HUE;
  if (!userColors.hasOwnProperty(currentUserColor)) {
    throw new Error("'colors' must contain 'currentUserColor' (".concat(currentUserColor, ")"));
  }
  const userColorKeys = Object.keys(userColors);
  const subscriptions = /* @__PURE__ */ new Map();
  const previouslyAssigned = /* @__PURE__ */ new Map();
  const assignedCounts = userColorKeys.reduce((counts, color3) => {
    counts[color3] = 0;
    return counts;
  }, {});
  const assigned = /* @__PURE__ */ new Map();
  let currentUserId;
  if (options == null ? void 0 : options.userStore) {
    options.userStore.me.subscribe((user) => setCurrentUser(user ? user.id : null));
  }
  return { get: get6, listen: listen2 };
  function get6(userId) {
    if (!userId) {
      return anonymousColor;
    }
    return userColors[getUserHue(userId)];
  }
  function getUserHue(userId) {
    if (userId === currentUserId) {
      return currentUserColor;
    }
    const assignedHue = assigned.get(userId);
    if (assignedHue) {
      return assignedHue;
    }
    const prevHue = previouslyAssigned.get(userId);
    if (prevHue && (assignedCounts[prevHue] === 0 || !hasUnusedColor())) {
      return assignHue(userId, prevHue);
    }
    const preferredHue = getPreferredHue(userId);
    if (assignedCounts[preferredHue] === 0) {
      return assignHue(userId, preferredHue);
    }
    return assignHue(userId, getLeastUsedHue(prevHue));
  }
  function listen2(userId) {
    let subscription = subscriptions.get(userId);
    if (subscription) {
      return subscription;
    }
    const hue = getUserHue(userId);
    subscription = getObservableColor(userId, hue);
    subscriptions.set(userId, subscription);
    return subscription;
  }
  function assignHue(userId, hue) {
    assigned.set(userId, hue);
    previouslyAssigned.set(userId, hue);
    assignedCounts[hue]++;
    return hue;
  }
  function unassignHue(userId, hue) {
    assigned.delete(userId);
    assignedCounts[hue]--;
  }
  function getUnusedColor() {
    return userColorKeys.find((colorHue) => assignedCounts[colorHue] === 0);
  }
  function hasUnusedColor() {
    return Boolean(getUnusedColor());
  }
  function getLeastUsedHue(tieBreakerPreference) {
    let leastUses = Infinity;
    let leastUsed = [];
    userColorKeys.forEach((colorHue) => {
      const uses = assignedCounts[colorHue];
      if (uses === leastUses) {
        leastUsed.push(colorHue);
      } else if (uses < leastUses) {
        leastUses = uses;
        leastUsed = [colorHue];
      }
    });
    return tieBreakerPreference && leastUsed.includes(tieBreakerPreference) ? tieBreakerPreference : leastUsed[0];
  }
  function getObservableColor(userId, hue) {
    return new Observable((subscriber) => {
      const userColor = userColors[hue];
      subscriber.next(userColor);
      return () => {
        subscriptions.delete(userId);
        unassignHue(userId, hue);
      };
    }).pipe(shareReplay({ refCount: true }));
  }
  function setCurrentUser(userId) {
    currentUserId = userId;
    assignedCounts[currentUserColor] += userId ? 1 : -1;
  }
  function getPreferredHue(userId) {
    let hash3 = 0;
    for (let i = 0; i < userId.length; i++) {
      hash3 = (hash3 << 5) - hash3 + userId.charCodeAt(i) | 0;
    }
    return userColorKeys[Math.abs(hash3) % userColorKeys.length];
  }
}
function UserColorManagerProvider(_ref28) {
  let { children, manager: managerFromProps } = _ref28;
  const { scheme } = useColorScheme();
  const manager = (0, import_react51.useMemo)(() => {
    return managerFromProps || createUserColorManager({ scheme });
  }, [managerFromProps, scheme]);
  return (0, import_jsx_runtime6.jsx)(UserColorManagerContext.Provider, { value: manager, children });
}
function defineConfig(config) {
  return config;
}
function createConfig(config) {
  return defineConfig(config);
}
function validatePlugin(pluginResult) {
  const messages = ["projectId" in pluginResult && "`projectId` not allowed in plugin configuration", "dataset" in pluginResult && "`dataset` not allowed in plugin configuration"].filter(import_isString2.default);
  if (messages.length)
    throw new Error("Invalid plugin configuration:\n".concat(messages.map((message) => "	".concat(message)).join("\n")));
}
function definePlugin(arg) {
  if (typeof arg === "function") {
    const pluginFactory = arg;
    return (options) => {
      const result = pluginFactory(options);
      validatePlugin(result);
      return result;
    };
  }
  validatePlugin(arg);
  return () => arg;
}
function createPlugin(arg) {
  return definePlugin(arg);
}
function defineDocumentFieldAction(fieldAction) {
  return fieldAction;
}
var documentFieldActionsReducer = (prev, _ref29, context) => {
  let { document: document2 } = _ref29;
  const documentFieldActions = document2 == null ? void 0 : document2.unstable_fieldActions;
  if (!documentFieldActions)
    return prev;
  if (typeof documentFieldActions === "function")
    return documentFieldActions(prev, context);
  if (Array.isArray(documentFieldActions))
    return [...prev, ...documentFieldActions];
  throw new Error("Expected `document.unstable_fieldActions` to be an array or a function, but received ".concat(typeof documentFieldActions));
};
var initialDocumentFieldActions = [];
function defineDocumentInspector(inspector) {
  return inspector;
}
var ValidationError = class ValidationError2 {
  constructor(message) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.message = message;
    this.paths = options.paths || [];
    this.children = options.children;
    this.operation = options.operation;
  }
  cloneWithMessage(msg2) {
    return new ValidationError2(msg2, { paths: this.paths, children: this.children, operation: this.operation });
  }
};
function escapeRegex(string3) {
  return string3.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
}
function pathToString$1() {
  let path2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return path2.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === "number") {
      return "".concat(target, "[").concat(segment, "]");
    }
    if (segmentType === "string") {
      const separator = i === 0 ? "" : ".";
      return "".concat(target).concat(separator).concat(segment);
    }
    if (isKeyedObject(segment)) {
      return "".concat(target, '[_key=="').concat(segment._key, '"]');
    }
    throw new Error('Unsupported path segment "'.concat(segment, '"'));
  }, "");
}
function isNonNullable$2(t3) {
  return t3 !== null || t3 !== void 0;
}
function convertToValidationMarker(validatorResult, level, context) {
  var _a4;
  if (!context) {
    throw new Error("missing context");
  }
  if (validatorResult === true)
    return [];
  if (Array.isArray(validatorResult)) {
    return validatorResult.flatMap((child) => convertToValidationMarker(child, level, context)).filter(isNonNullable$2);
  }
  if (typeof validatorResult === "string") {
    return convertToValidationMarker(new ValidationError(validatorResult), level, context);
  }
  if (!(validatorResult instanceof ValidationError)) {
    if (typeof (validatorResult == null ? void 0 : validatorResult.message) !== "string") {
      throw new Error("".concat(pathToString$1(context.path), ": Validator must return 'true' if valid or an error message as a string on errors"));
    }
    return convertToValidationMarker(new ValidationError(validatorResult.message, validatorResult), level, context);
  }
  const results = [];
  if (!((_a4 = validatorResult.paths) == null ? void 0 : _a4.length)) {
    return [{ level: level || "error", item: validatorResult, path: context.path || [] }];
  }
  return results.concat(validatorResult.paths.map((path2) => ({ path: (context.path || []).concat(path2), level: level || "error", item: validatorResult })));
}
function localizeMessage(message, i18n) {
  const { currentLocale: locale } = i18n;
  if (message[locale]) {
    return message[locale];
  }
  if (locale.includes("-")) {
    const language = locale.split("-", 1)[0];
    if (message[language]) {
      return message[language];
    }
  }
  return message["en-US"] || message["en-GB"] || message.en || "Unknown validation error (not localized)";
}
function isLocalizedMessages(message) {
  return message !== true && typeof message !== "undefined" && typeof message !== "string" && (0, import_isPlainObject5.default)(message) && !("message" in message);
}
var _toString = {}.toString;
var builtIns = [Object, Function, Array, String, Boolean, Number, Date, RegExp, Error];
function isBuiltIn(_constructor) {
  for (let i = 0; i < builtIns.length; i++) {
    if (builtIns[i] === _constructor)
      return true;
  }
  return false;
}
function typeString(obj) {
  const stringType = _toString.call(obj).slice(8, -1);
  if (obj === null || obj === void 0)
    return stringType.toLowerCase();
  const constructorType = obj.constructor;
  if (constructorType && !isBuiltIn(constructorType))
    return constructorType.name;
  return stringType;
}
function deepEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(a) != Array.isArray(b)) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    const keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length) {
      return false;
    }
    if (a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }
    if (a instanceof Date != b instanceof Date) {
      return false;
    }
    if (a instanceof RegExp && b instanceof RegExp) {
      return a.toString() == b.toString();
    }
    if (a instanceof RegExp != b instanceof RegExp) {
      return false;
    }
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] === "_key") {
        continue;
      }
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key2 = keys[i];
      if (key2 === "_key") {
        continue;
      }
      if (!deepEquals(a[key2], b[key2])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var SLOW_VALIDATOR_TIMEOUT = 5e3;
var formatValidationErrors = (options) => {
  var _a4;
  let message;
  if (options.message) {
    message = options.message;
  } else if (options.results.length === 1) {
    message = (_a4 = options.results[0]) == null ? void 0 : _a4.item.message;
  } else {
    const messages = options.results.map((err) => err.item.message);
    const type = options.operation === "AND" ? "conjunction" : "disjunction";
    const key2 = "{{messages, list}}";
    message = options.i18n.t(key2, { messages, formatParams: { messages: { style: "long", type } } });
  }
  return new ValidationError(message, { children: options.results.length > 1 ? options.results : void 0, operation: options.operation });
};
var genericValidators = { type: (expectedType, value, message, _ref30) => {
  let { i18n } = _ref30;
  const actualType = typeString(value);
  if (actualType !== expectedType && actualType !== "undefined") {
    return message || i18n.t("validation:generic.incorrect-type", { actualType, expectedType });
  }
  return true;
}, presence: (expected, value, message, _ref31) => {
  let { i18n } = _ref31;
  if (value === void 0 && expected === "required") {
    return message || i18n.t("validation:generic.required");
  }
  return true;
}, all: async (children, value, message, context) => {
  const resolved = await Promise.all(children.map((child) => child.validate(value, context)));
  const results = resolved.flat();
  if (results.length === 0) {
    return true;
  }
  return formatValidationErrors({ message, results, operation: "AND", i18n: context.i18n });
}, either: async (children, value, message, context) => {
  const resolved = await Promise.all(children.map((child) => child.validate(value, context)));
  const results = resolved.flat();
  if (results.length < children.length) {
    return true;
  }
  return formatValidationErrors({ message, results, operation: "OR", i18n: context.i18n });
}, valid: (allowedValues, actual, message, _ref32) => {
  let { i18n } = _ref32;
  const valueType = typeof actual;
  if (valueType === "undefined") {
    return true;
  }
  const value = (valueType === "number" || valueType === "string") && "".concat(actual);
  const strValue = value && value.length > 30 ? "".concat(value.slice(0, 30), "") : value;
  return allowedValues.some((expected) => deepEquals(expected, actual)) ? true : message || i18n.t("validation:generic.not-allowed", value ? { context: "hint", replace: { hint: strValue } } : {});
}, custom: async (fn, value, message, context) => {
  const slowTimer = setTimeout(() => {
    console.warn("Custom validator at ".concat(pathToString$1(context.path), " has taken more than ").concat(SLOW_VALIDATOR_TIMEOUT, "ms to respond"));
  }, SLOW_VALIDATOR_TIMEOUT);
  let result;
  try {
    result = await fn(value, context);
  } finally {
    clearTimeout(slowTimer);
  }
  if (isLocalizedMessages(result)) {
    return localizeMessage(result, context.i18n);
  }
  if (typeof result === "string") {
    return message || result;
  }
  return result;
} };
var booleanValidators = { ...genericValidators, presence: (flag, value, message, _ref33) => {
  let { i18n } = _ref33;
  if (flag === "required" && typeof value !== "boolean") {
    return message || i18n.t("validation:generic.required", { context: "boolean" });
  }
  return true;
} };
var precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/;
var numberValidators = { ...genericValidators, integer: (_unused, value, message, _ref34) => {
  let { i18n } = _ref34;
  if (!Number.isInteger(value)) {
    return message || i18n.t("validation:number.non-integer");
  }
  return true;
}, precision: (limit, value, message, _ref35) => {
  let { i18n } = _ref35;
  if (value === void 0)
    return true;
  const places = value.toString().match(precisionRx);
  const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
  if (decimals > limit) {
    return message || i18n.t("validation:number.maximum-precision", { limit });
  }
  return true;
}, min: (minNumber, value, message, _ref36) => {
  let { i18n } = _ref36;
  if (value >= minNumber) {
    return true;
  }
  return message || i18n.t("validation:number.minimum", { minNumber });
}, max: (maxNumber, value, message, _ref37) => {
  let { i18n } = _ref37;
  if (value <= maxNumber) {
    return true;
  }
  return message || i18n.t("validation:number.maximum", { maxNumber });
}, greaterThan: (threshold, value, message, _ref38) => {
  let { i18n } = _ref38;
  if (value > threshold) {
    return true;
  }
  return message || i18n.t("validation:number.greater-than", { threshold });
}, lessThan: (threshold, value, message, _ref39) => {
  let { i18n } = _ref39;
  if (value < threshold) {
    return true;
  }
  return message || i18n.t("validation:number.less-than", { threshold });
} };
var DUMMY_ORIGIN = "http://sanity";
var isRelativeUrl = (url) => /^\.*\//.test(url);
var emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var stringValidators = { ...genericValidators, min: (minLength, value, message, _ref40) => {
  let { i18n } = _ref40;
  if (!value || value.length >= minLength) {
    return true;
  }
  return message || i18n.t("validation:string.minimum-length", { minLength });
}, max: (maxLength, value, message, _ref41) => {
  let { i18n } = _ref41;
  if (!value || value.length <= maxLength) {
    return true;
  }
  return message || i18n.t("validation:string.maximum-length", { maxLength });
}, length: (wantedLength, value, message, _ref42) => {
  let { i18n } = _ref42;
  const strValue = value || "";
  if (strValue.length === wantedLength) {
    return true;
  }
  return message || i18n.t("validation:string.exact-length", { wantedLength });
}, uri: (constraints, value, message, _ref43) => {
  let { i18n } = _ref43;
  const strValue = value || "";
  if (!strValue) {
    return true;
  }
  const { options } = constraints;
  const { allowCredentials, relativeOnly } = options;
  const allowRelative = options.allowRelative || relativeOnly;
  let url;
  try {
    url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue);
  } catch (err) {
    return message || i18n.t("validation:string.url.invalid");
  }
  if (relativeOnly && url.origin !== DUMMY_ORIGIN) {
    return message || i18n.t("validation:string.url.not-relative");
  }
  if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue)) {
    return message || i18n.t("validation:string.url.not-absolute");
  }
  if (!allowCredentials && (url.username || url.password)) {
    return message || i18n.t("validation:string.url.includes-credentials");
  }
  const urlScheme = url.protocol.replace(/:$/, "");
  const matchesAllowedScheme = options.scheme.some((scheme) => scheme.test(urlScheme));
  if (!matchesAllowedScheme) {
    return message || i18n.t("validation:string.url.disallowed-scheme", { scheme: urlScheme });
  }
  return true;
}, stringCasing: (casing, value, message, _ref44) => {
  let { i18n } = _ref44;
  const strValue = value || "";
  if (casing === "uppercase" && strValue !== strValue.toLocaleUpperCase()) {
    return message || i18n.t("validation:string.uppercase");
  }
  if (casing === "lowercase" && strValue !== strValue.toLocaleLowerCase()) {
    return message || i18n.t("validation:string.lowercase");
  }
  return true;
}, presence: (flag, value, message, _ref45) => {
  let { i18n } = _ref45;
  if (flag === "required" && !value) {
    return message || i18n.t("validation:generic.required", { context: "string" });
  }
  return true;
}, regex: (options, value, message, _ref46) => {
  let { i18n } = _ref46;
  const { pattern, name, invert } = options;
  const regName = name || "".concat(pattern.toString());
  const strValue = value || "";
  pattern.lastIndex = 0;
  const matches = pattern.test(strValue);
  if (!invert && !matches || invert && matches) {
    if (message) {
      return message;
    }
    return invert ? i18n.t("validation:string.regex-match", { name: regName }) : i18n.t("validation:string.regex-does-not-match", { name: regName });
  }
  return true;
}, email: (_unused, value, message, _ref47) => {
  let { i18n } = _ref47;
  const strValue = "".concat(value || "").trim();
  if (!strValue || emailRegex.test(strValue)) {
    return true;
  }
  return message || i18n.t("validation:string.email");
} };
var arrayValidators = { ...genericValidators, min: (minLength, value, message, _ref48) => {
  let { i18n, type } = _ref48;
  if (!value || value.length >= minLength) {
    return true;
  }
  const context = isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
  return message || i18n.t("validation:array.minimum-length", { minLength, context });
}, max: (maxLength, value, message, _ref49) => {
  let { i18n, type } = _ref49;
  if (!value || value.length <= maxLength) {
    return true;
  }
  const context = isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
  return message || i18n.t("validation:array.maximum-length", { maxLength, context });
}, length: (wantedLength, value, message, _ref50) => {
  let { i18n, type } = _ref50;
  if (!value || value.length === wantedLength) {
    return true;
  }
  const context = isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
  return message || i18n.t("validation:array.exact-length", { wantedLength, context });
}, presence: (flag, value, message, _ref51) => {
  let { i18n } = _ref51;
  if (flag === "required" && !value) {
    return message || i18n.t("validation:generic.required", { context: "array" });
  }
  return true;
}, valid: (allowedValues, values2, message, _ref52) => {
  let { i18n } = _ref52;
  const valueType = typeof values2;
  if (valueType === "undefined") {
    return true;
  }
  const paths = [];
  for (let i = 0; i < values2.length; i++) {
    const value = values2[i];
    if (allowedValues.some((expected) => deepEquals(expected, value))) {
      continue;
    }
    const pathSegment = value && value._key ? { _key: value._key } : i;
    paths.push([pathSegment]);
  }
  return paths.length === 0 ? true : new ValidationError(message || i18n.t("validation:generic.not-allowed"), { paths });
}, unique: (_unused, value, message, _ref53) => {
  let { i18n } = _ref53;
  const dupeIndices = [];
  if (!value) {
    return true;
  }
  for (let x = 0; x < value.length; x++) {
    for (let y = x + 1; y < value.length; y++) {
      const itemA = value[x];
      const itemB = value[y];
      if (!deepEquals(itemA, itemB)) {
        continue;
      }
      if (dupeIndices.indexOf(x) === -1) {
        dupeIndices.push(x);
      }
      if (dupeIndices.indexOf(y) === -1) {
        dupeIndices.push(y);
      }
    }
  }
  const paths = dupeIndices.map((idx) => {
    const item = value[idx];
    const pathSegment = item && item._key ? { _key: item._key } : idx;
    return [pathSegment];
  });
  return dupeIndices.length > 0 ? new ValidationError(message || i18n.t("validation:array.item-duplicate"), { paths }) : true;
} };
var metaKeys = ["_key", "_type", "_weak"];
var objectValidators = { ...genericValidators, presence: (expected, value, message, _ref54) => {
  let { i18n } = _ref54;
  if (expected !== "required") {
    return true;
  }
  const keys = value && Object.keys(value).filter((key2) => !metaKeys.includes(key2));
  if (value === void 0 || keys && keys.length === 0) {
    return message || i18n.t("validation:generic.required", { context: "object" });
  }
  return true;
}, reference: async (_unused, value, message, context) => {
  if (!value) {
    return true;
  }
  const { type, getDocumentExists, i18n } = context;
  if (!isReference(value)) {
    return message || i18n.t("validation:object.not-reference");
  }
  if (!type) {
    throw new Error("`type` was not provided in validation context");
  }
  if ("weak" in type && type.weak) {
    return true;
  }
  if (!getDocumentExists) {
    throw new Error("`getDocumentExists` was not provided in validation context");
  }
  const exists2 = await getDocumentExists({ id: value._ref });
  if (!exists2) {
    return i18n.t("validation:object.reference-not-published", { documentId: value._ref });
  }
  return true;
}, assetRequired: (flag, value, message, _ref55) => {
  let { i18n } = _ref55;
  if (!value || !value.asset || !value.asset._ref) {
    return message || i18n.t("validation:object.asset-required", { context: flag.assetType || "" });
  }
  return true;
} };
function isRecord$3(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
var isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
var getFormattedDate = function() {
  let type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let value = arguments.length > 1 ? arguments[1] : void 0;
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let format4 = "yyyy-MM-dd";
  if (options && options.dateFormat) {
    format4 = options.dateFormat;
  }
  if (type === "date") {
    return format(new Date(value), format4);
  }
  if (options && options.timeFormat) {
    format4 += " ".concat(options.timeFormat);
  } else {
    format4 += " HH:mm";
  }
  return format(new Date(value), format4);
};
function parseDate(date) {
  let throwOnError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!date)
    return null;
  if (date === "now")
    return /* @__PURE__ */ new Date();
  const parsed = new Date(date);
  const isInvalid = isNaN(parsed.getTime());
  if (isInvalid && throwOnError) {
    throw new Error('Unable to parse "'.concat(date, '" to a date'));
  }
  return isInvalid ? null : parsed;
}
var dateValidators = { ...genericValidators, type: (_unused, value, message, _ref56) => {
  let { i18n } = _ref56;
  if (typeof value === "undefined" || isoDate.test("".concat(value))) {
    return true;
  }
  return message || i18n.t("validation:date.invalid-format");
}, min: (minDate, value, message, _ref57) => {
  let { type, i18n } = _ref57;
  const dateVal = parseDate(value);
  if (!dateVal) {
    return true;
  }
  if (!value || dateVal >= parseDate(minDate, true)) {
    return true;
  }
  if (!type) {
    throw new Error("`type` was not provided in validation context.");
  }
  const dateTimeOptions = isRecord$3(type.options) ? type.options : {};
  return message || // Note that the `minDate` passed here is _formatted_, while the raw value provided to the
  // validator is available as `providedMinDate`. This because the formatted date is likely
  // what the developer wants to present to the user
  i18n.t("validation:date.minimum", { minDate: getFormattedDate(type.name, minDate, dateTimeOptions), providedMinDate: minDate });
}, max: (maxDate, value, message, _ref58) => {
  let { type, i18n } = _ref58;
  const dateVal = parseDate(value);
  if (!dateVal) {
    return true;
  }
  if (!value || dateVal <= parseDate(maxDate, true)) {
    return true;
  }
  if (!type) {
    throw new Error("`type` was not provided in validation context.");
  }
  const dateTimeOptions = isRecord$3(type.options) ? type.options : {};
  return message || // Note that the `maxDate` passed here is _formatted_, while the raw value provided to the
  // validator is available as `providedMaxDate`. This because the formatted date is likely
  // what the developer wants to present to the user
  i18n.t("validation:date.maximum", { maxDate: getFormattedDate(type.name, maxDate, dateTimeOptions), providedMaxDate: maxDate });
} };
var _a$2q;
var typeValidators = { Boolean: booleanValidators, Number: numberValidators, String: stringValidators, Array: arrayValidators, Object: objectValidators, Date: dateValidators };
var getBaseType = (type) => {
  return type && type.type ? getBaseType(type.type) : type;
};
var isFieldRef = (constraint) => {
  if (typeof constraint !== "object" || !constraint)
    return false;
  return constraint.type === Rule.FIELD_REF;
};
var EMPTY_ARRAY$8 = [];
var FIELD_REF = Symbol("FIELD_REF");
var ruleConstraintTypes$1 = ["Array", "Boolean", "Date", "Number", "Object", "String"];
var Rule = (_a$2q = class {
  constructor(typeDef) {
    this._type = void 0;
    this._level = void 0;
    this._required = void 0;
    this._typeDef = void 0;
    this._message = void 0;
    this._rules = [];
    this._fieldRules = void 0;
    this.valueOfField = _a$2q.valueOfField.bind(_a$2q);
    this._typeDef = typeDef;
    this.reset();
  }
  _mergeRequired(next) {
    if (this._required === "required" || next._required === "required")
      return "required";
    if (this._required === "optional" || next._required === "optional")
      return "optional";
    return void 0;
  }
  error(message) {
    const rule = this.clone();
    rule._level = "error";
    rule._message = message || void 0;
    return rule;
  }
  warning(message) {
    const rule = this.clone();
    rule._level = "warning";
    rule._message = message || void 0;
    return rule;
  }
  info(message) {
    const rule = this.clone();
    rule._level = "info";
    rule._message = message || void 0;
    return rule;
  }
  reset() {
    this._type = this._type || void 0;
    this._rules = (this._rules || []).filter((rule) => rule.flag === "type");
    this._message = void 0;
    this._required = void 0;
    this._level = "error";
    this._fieldRules = void 0;
    return this;
  }
  isRequired() {
    return this._required === "required";
  }
  clone() {
    const rule = new _a$2q();
    rule._type = this._type;
    rule._message = this._message;
    rule._required = this._required;
    rule._rules = (0, import_cloneDeep.default)(this._rules);
    rule._level = this._level;
    rule._fieldRules = this._fieldRules;
    rule._typeDef = this._typeDef;
    return rule;
  }
  cloneWithRules(rules) {
    const rule = this.clone();
    const newRules = /* @__PURE__ */ new Set();
    rules.forEach((curr) => {
      if (curr.flag === "type") {
        rule._type = curr.constraint;
      }
      newRules.add(curr.flag);
    });
    rule._rules = rule._rules.filter((curr) => {
      const disallowDuplicate = ["type", "uri", "email"].includes(curr.flag);
      const isDuplicate = newRules.has(curr.flag);
      return !(disallowDuplicate && isDuplicate);
    }).concat(rules);
    return rule;
  }
  merge(rule) {
    if (this._type && rule._type && this._type !== rule._type) {
      throw new Error("merge() failed: conflicting types");
    }
    const newRule = this.cloneWithRules(rule._rules);
    newRule._type = this._type || rule._type;
    newRule._message = this._message || rule._message;
    newRule._required = this._mergeRequired(rule);
    newRule._level = this._level === "error" ? rule._level : this._level;
    return newRule;
  }
  // Validation flag setters
  type(targetType) {
    const type = "".concat(targetType.slice(0, 1).toUpperCase()).concat(targetType.slice(1));
    if (!ruleConstraintTypes$1.includes(type)) {
      throw new Error('Unknown type "'.concat(targetType, '"'));
    }
    const rule = this.cloneWithRules([{ flag: "type", constraint: type }]);
    rule._type = type;
    return rule;
  }
  all(children) {
    return this.cloneWithRules([{ flag: "all", constraint: children }]);
  }
  either(children) {
    return this.cloneWithRules([{ flag: "either", constraint: children }]);
  }
  // Shared rules
  optional() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "optional" }]);
    rule._required = "optional";
    return rule;
  }
  required() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "required" }]);
    rule._required = "required";
    return rule;
  }
  custom(fn) {
    return this.cloneWithRules([{ flag: "custom", constraint: fn }]);
  }
  min(len) {
    return this.cloneWithRules([{ flag: "min", constraint: len }]);
  }
  max(len) {
    return this.cloneWithRules([{ flag: "max", constraint: len }]);
  }
  length(len) {
    return this.cloneWithRules([{ flag: "length", constraint: len }]);
  }
  valid(value) {
    const values2 = Array.isArray(value) ? value : [value];
    return this.cloneWithRules([{ flag: "valid", constraint: values2 }]);
  }
  // Numbers only
  integer() {
    return this.cloneWithRules([{ flag: "integer" }]);
  }
  precision(limit) {
    return this.cloneWithRules([{ flag: "precision", constraint: limit }]);
  }
  positive() {
    return this.cloneWithRules([{ flag: "min", constraint: 0 }]);
  }
  negative() {
    return this.cloneWithRules([{ flag: "lessThan", constraint: 0 }]);
  }
  greaterThan(num) {
    return this.cloneWithRules([{ flag: "greaterThan", constraint: num }]);
  }
  lessThan(num) {
    return this.cloneWithRules([{ flag: "lessThan", constraint: num }]);
  }
  // String only
  uppercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "uppercase" }]);
  }
  lowercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "lowercase" }]);
  }
  regex(pattern, a, b) {
    var _a22, _b4;
    const name = typeof a === "string" ? a : (_a22 = a == null ? void 0 : a.name) != null ? _a22 : b == null ? void 0 : b.name;
    const invert = typeof a === "string" ? false : (_b4 = a == null ? void 0 : a.invert) != null ? _b4 : b == null ? void 0 : b.invert;
    const constraint = { pattern, name, invert: invert || false };
    return this.cloneWithRules([{ flag: "regex", constraint }]);
  }
  email() {
    return this.cloneWithRules([{ flag: "email" }]);
  }
  uri(opts) {
    const optsScheme = (opts == null ? void 0 : opts.scheme) || ["http", "https"];
    const schemes2 = Array.isArray(optsScheme) ? optsScheme : [optsScheme];
    if (!schemes2.length) {
      throw new Error("scheme must have at least 1 scheme specified");
    }
    const constraint = { options: { scheme: schemes2.map((scheme) => {
      if (!(scheme instanceof RegExp) && typeof scheme !== "string") {
        throw new Error("scheme must be a RegExp or a String");
      }
      return typeof scheme === "string" ? new RegExp("^".concat(escapeRegex(scheme), "$")) : scheme;
    }), allowRelative: (opts == null ? void 0 : opts.allowRelative) || false, relativeOnly: (opts == null ? void 0 : opts.relativeOnly) || false, allowCredentials: (opts == null ? void 0 : opts.allowCredentials) || false } };
    return this.cloneWithRules([{ flag: "uri", constraint }]);
  }
  // Array only
  unique() {
    return this.cloneWithRules([{ flag: "unique" }]);
  }
  // Objects only
  reference() {
    return this.cloneWithRules([{ flag: "reference" }]);
  }
  fields(rules) {
    if (this._type !== "Object") {
      throw new Error("fields() can only be called on an object type");
    }
    const rule = this.cloneWithRules([]);
    rule._fieldRules = rules;
    return rule;
  }
  assetRequired() {
    const base = getBaseType(this._typeDef);
    let assetType;
    if (base && ["image", "file"].includes(base.name)) {
      assetType = base.name === "image" ? "image" : "file";
    } else {
      assetType = "asset";
    }
    return this.cloneWithRules([{ flag: "assetRequired", constraint: { assetType } }]);
  }
  async validate(value, context) {
    if (!context) {
      throw new Error("missing context");
    }
    const valueIsEmpty = value === null || value === void 0;
    if (valueIsEmpty && this._required === "optional") {
      return EMPTY_ARRAY$8;
    }
    const rules = (
      // Run only the _custom_ functions if the rule is not set to required or optional
      this._required === void 0 && valueIsEmpty ? this._rules.filter((curr) => curr.flag === "custom") : this._rules
    );
    const validators = this._type && typeValidators[this._type] || genericValidators;
    const results = await Promise.all(rules.map(async (curr) => {
      if (curr.flag === void 0) {
        throw new Error('Invalid rule, did not contain "flag"-property');
      }
      const validator = validators[curr.flag];
      if (!validator) {
        const forType = this._type ? 'type "'.concat(this._type, '"') : "rule without declared type";
        throw new Error('Validator for flag "'.concat(curr.flag, '" not found for ').concat(forType));
      }
      let specConstraint = "constraint" in curr ? curr.constraint : null;
      if (isFieldRef(specConstraint)) {
        specConstraint = (0, import_get3.default)(context.parent, specConstraint.path);
      }
      const message = isLocalizedMessages(this._message) ? localizeMessage(this._message, context.i18n) : this._message;
      let result;
      try {
        result = await validator(specConstraint, value, message, context);
      } catch (err) {
        const errorFromException = new ValidationError("".concat(pathToString$1(context.path), ": Exception occurred while validating value: ").concat(err.message));
        return convertToValidationMarker(errorFromException, "error", context);
      }
      return convertToValidationMarker(result, this._level, context);
    }));
    return results.flat();
  }
}, _a$2q.FIELD_REF = FIELD_REF, _a$2q.array = (def) => new _a$2q(def).type("Array"), _a$2q.object = (def) => new _a$2q(def).type("Object"), _a$2q.string = (def) => new _a$2q(def).type("String"), _a$2q.number = (def) => new _a$2q(def).type("Number"), _a$2q.boolean = (def) => new _a$2q(def).type("Boolean"), _a$2q.dateTime = (def) => new _a$2q(def).type("Date"), _a$2q.valueOfField = (path2) => ({ type: FIELD_REF, path: path2 }), _a$2q);
var studioLocaleNamespace = "studio";
var validationLocaleNamespace = "validation";
function defineLocaleResourceBundle(bundle) {
  return bundle;
}
function defineLocale(locale) {
  return locale;
}
function isStaticResourceBundle(bundle) {
  return !("then" in bundle.resources && typeof bundle.resources.then === "function");
}
function defineLocalesResources(namespace, resources) {
  return resources;
}
function removeUndefinedLocaleResources(resources) {
  const result = {};
  for (const key2 in resources) {
    if (typeof resources[key2] !== "undefined") {
      result[key2] = resources[key2];
    }
  }
  return result;
}
var studioLocaleStrings = defineLocalesResources("studio", {
  /** Menu item for deleting the asset */
  "asset-source.asset-list.menu.delete": "Delete",
  /** Menu item for showing where a particular asset is used */
  "asset-source.asset-list.menu.show-usage": "Show usage",
  /** Header in usage dialog for file assets */
  "asset-source.asset-usage-dialog.header_file": "Documents using file",
  /** Header in usage dialog for image assets */
  "asset-source.asset-usage-dialog.header_image": "Documents using image",
  /** Text shown in usage dialog when loading documents using the selected asset */
  "asset-source.asset-usage-dialog.loading": "Loading",
  /** Text for cancel action in delete-asset dialog */
  "asset-source.delete-dialog.action.cancel": "Cancel",
  /** Text for "confirm delete" action in delete-asset dialog */
  "asset-source.delete-dialog.action.delete": "Delete",
  /** Dialog header for delete-asset dialog when deleting a file */
  "asset-source.delete-dialog.header_file": "Delete file",
  /** Dialog header for delete-asset dialog when deleting an image */
  "asset-source.delete-dialog.header_image": "Delete image",
  /** Text shown in delete dialog when loading documents using the selected asset */
  "asset-source.delete-dialog.loading": "Loading",
  /** Message confirming to delete *named* file */
  "asset-source.delete-dialog.usage-list.confirm-delete-file_named": "You are about to delete the file <strong>{{filename}}}</strong> and its metadata. Are you sure?",
  /** Message confirming to delete *unnamed* file */
  "asset-source.delete-dialog.usage-list.confirm-delete-file_unnamed": "You are about to delete the file and its metadata. Are you sure?",
  /** Message confirming to delete *named* image */
  "asset-source.delete-dialog.usage-list.confirm-delete-image_named": "You are about to delete the image <strong>{{filename}}</strong> and its metadata. Are you sure?",
  /** Message confirming to delete *unnamed* image */
  "asset-source.delete-dialog.usage-list.confirm-delete-image_unnamed": "You are about to delete the image and its metadata. Are you sure?",
  /** Alt text showing on image preview in delete asset dialog  */
  "asset-source.delete-dialog.usage-list.image-preview-alt": "Preview of image",
  /** Warning message showing when *named* file can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-file-is-in-use_named": "{{filename}} cannot be deleted because it's being used. In order to delete this file, you first need to remove all uses of it.",
  /** Warning message showing when *unnamed* file can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-file-is-in-use_unnamed": "This file cannot be deleted because it's being used. In order to delete it, you first need to remove all uses of it.",
  /** Warning message showing when *named* image can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-image-is-in-use_named": "{{filename}} cannot be deleted because it's being used. In order to delete this image, you first need to remove all uses of it.",
  /** Warning message showing when *unnamed* image can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-image-is-in-use_unnamed": "This image cannot be deleted because it's being used. In order to delete it, you first need to remove all uses of it.",
  /** Text shown when the list of assets only include a specific set of types */
  "asset-source.dialog.accept-message": "Only showing assets of accepted types: <strong>{{acceptTypes}}</strong>",
  /** Keys shared between both image asset source and file asset source */
  /** Select asset dialog title for files */
  "asset-source.dialog.default-title_file": "Select file",
  /** Select asset dialog title for images */
  "asset-source.dialog.default-title_image": "Select image",
  /** Select asset dialog load more items */
  "asset-source.dialog.load-more": "Load more",
  /** Text shown when selecting a file but there's no files to select from */
  "asset-source.dialog.no-assets_file": "No files",
  /** Text shown when selecting an image but there's no images to select from */
  "asset-source.dialog.no-assets_image": "No images",
  "asset-source.file.asset-list.action.delete.disabled-cannot-delete-current-file": "Cannot delete currently selected file",
  "asset-source.file.asset-list.action.delete.text": "Delete",
  "asset-source.file.asset-list.action.delete.title": "Delete file",
  "asset-source.file.asset-list.action.select-file.title": "Select the file {{filename}}",
  "asset-source.file.asset-list.action.show-usage.title": "Show usage",
  "asset-source.file.asset-list.delete-failed": "File could not be deleted",
  "asset-source.file.asset-list.delete-successful": "File was deleted",
  "asset-source.file.asset-list.header.date-added": "Date added",
  /** File asset source */
  "asset-source.file.asset-list.header.filename": "Filename",
  "asset-source.file.asset-list.header.size": "Size",
  "asset-source.file.asset-list.header.type": "Type",
  /** Text displayed on button or menu invoking the file asset source */
  "asset-source.file.title": "Uplaoded files",
  "asset-source.image.asset-list.delete-failed": "Image could not be deleted",
  /** Image asset source */
  "asset-source.image.asset-list.delete-successful": "Image was deleted",
  /** Text displayed on button or menu invoking the image asset source */
  "asset-source.image.title": "Uploaded images",
  "asset-source.usage-list.documents-using-file_named_one": "One document is using file <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-file_named_other": "{{count}} documents are using file <code>{{filename}}</code>",
  /** Text shown in usage dialog for a file asset when there are zero, one or more documents using the *named* file **/
  "asset-source.usage-list.documents-using-file_named_zero": "No documents are using file <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-file_unnamed_one": "One document is using this file",
  "asset-source.usage-list.documents-using-file_unnamed_other": "{{count}} documents are using this file",
  /** Text shown in usage dialog for a file asset when there are zero, one or more documents using the *unnamed* file **/
  "asset-source.usage-list.documents-using-file_unnamed_zero": "No documents are using this file",
  "asset-source.usage-list.documents-using-image_named_one": "One document is using image <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-image_named_other": "{{count}} documents are using image <code>{{filename}}</code>",
  /** Text shown in usage dialog for an image asset when there are zero, one or more documents using the *named* image **/
  "asset-source.usage-list.documents-using-image_named_zero": "No documents are using image <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-image_unnamed_one": "One document is using this image",
  "asset-source.usage-list.documents-using-image_unnamed_other": "{{count}} documents are using this image",
  /** Text shown in usage dialog for an image asset when there are zero, one or more documents using the *unnamed* image **/
  "asset-source.usage-list.documents-using-image_unnamed_zero": "No documents are using this image",
  /** Action message for navigating to next month */
  "calendar.action.go-to-next-month": "Go to next month",
  /** Action message for navigating to next year */
  "calendar.action.go-to-next-year": "Go to next year",
  /** Action message for navigating to previous month */
  "calendar.action.go-to-previous-month": "Go to previous month",
  /** Action message for navigating to previous year */
  "calendar.action.go-to-previous-year": "Go to previous year",
  /* Label for navigating the calendar to "today", without _selecting_ today. Short form, eg `Today`, not `Go to today` */
  "calendar.action.go-to-today": "Today",
  /* Accessibility label for navigating the calendar to "today", without _selecting_ today */
  "calendar.action.go-to-today-aria-label": "Go to today",
  /* Label for navigating the calendar to "tomorrow", without _selecting_ tomorrow. Short form, eg `Tomorrow`, not `Go to tomorrow` */
  "calendar.action.go-to-tomorrow": "Tomorrow",
  /* Label for navigating the calendar to "yesterday", without _selecting_ yesterday. Short form, eg `Yesterday`, not `Go to yesterday` */
  "calendar.action.go-to-yesterday": "Yesterday",
  /** Label for switch that controls whether or not to include time in given timestamp */
  "calendar.action.include-time-label": "Include time",
  /** Action message for selecting the hour */
  "calendar.action.select-hour": "Select hour",
  /** Action message for selecting the minute */
  "calendar.action.select-minute": "Select minute",
  /** Action message for setting to the current time */
  "calendar.action.set-to-current-time": "Set to current time",
  /** Label for selecting an hour preset. Receives a `time` param as a string on hh:mm format and a `date` param as a Date instance denoting the preset date */
  "calendar.action.set-to-time-preset": "{{time}} on {{date, datetime}}",
  /** Error message displayed in calendar when entered date is not the correct format */
  "calendar.error.must-be-in-format": "Must be in the format <Emphasis>{{exampleDate}}</Emphasis>",
  /** Month name for April */
  "calendar.month-names.april": "April",
  /** Month name for August */
  "calendar.month-names.august": "August",
  /** Month name for December */
  "calendar.month-names.december": "December",
  /** Month name for February */
  "calendar.month-names.february": "February",
  /** Month name for January */
  "calendar.month-names.january": "January",
  /** Month name for July */
  "calendar.month-names.july": "July",
  /** Month name for June */
  "calendar.month-names.june": "June",
  /** Month name for March */
  "calendar.month-names.march": "March",
  /** Month name for May */
  "calendar.month-names.may": "May",
  /** Month name for November */
  "calendar.month-names.november": "November",
  /** Month name for October */
  "calendar.month-names.october": "October",
  /** Month name for September */
  "calendar.month-names.september": "September",
  /** Short weekday name for Friday */
  "calendar.weekday-names.short.friday": "Fri",
  /** Short weekday name for Monday */
  "calendar.weekday-names.short.monday": "Mon",
  /** Short weekday name for Saturdayday */
  "calendar.weekday-names.short.saturday": "Sat",
  /** Short weekday name for Sunday */
  "calendar.weekday-names.short.sunday": "Sun",
  /** Short weekday name for Thursday */
  "calendar.weekday-names.short.thursday": "Thu",
  /** Short weekday name for Tuesday */
  "calendar.weekday-names.short.tuesday": "Tue",
  /** Short weekday name for Wednesday */
  "calendar.weekday-names.short.wednesday": "Wed",
  /** Label for the close button label in Review Changes pane */
  "changes.action.close-label": "Close review changes",
  /** Cancel label for revert button prompt action */
  "changes.action.revert-all-cancel": "Cancel",
  /** Revert all confirm label for revert button action - used on prompt button + review changes pane */
  "changes.action.revert-all-confirm": "Revert all",
  /** Prompt for reverting all changes in document in Review Changes pane. Includes a count of changes. */
  "changes.action.revert-all-description": "Are you sure you want to revert all {{count}} changes?",
  /** Prompt for confirming revert change (singular) label for field change action */
  "changes.action.revert-changes-confirm-change_one": "Revert change",
  /** Revert for confirming revert (plural) label for field change action */
  "changes.action.revert-changes-confirm-change_other": "Revert changes",
  /** Prompt for reverting changes for a field change */
  "changes.action.revert-changes-description": "Are you sure you want to revert the changes?",
  /** Prompt for reverting changes for a group change, eg multiple changes */
  "changes.action.revert-changes-description_one": "Are you sure you want to revert the change?",
  /** Label for when the action of the change was to set something that was previously empty, eg a field was given a value, an array item was added, an asset was selected or similar */
  "changes.added-label": "Added",
  /** Array diff: An item was added in a given position (`{{position}}`) */
  "changes.array.item-added-in-position": "Added in position {{position}}",
  "changes.array.item-moved_down_one": "Moved {{count}} position down",
  "changes.array.item-moved_down_other": "Moved {{count}} positions down",
  /**
  * Array diff: An item was moved within the array.
  * Receives `{{count}}` representing number of positions it moved.
  * Context is the direction of the move, either `up` or `down`.
  */
  "changes.array.item-moved_up_one": "Moved {{count}} position up",
  "changes.array.item-moved_up_other": "Moved {{count}} positions up",
  /** Array diff: An item was removed from a given position (`{{position}}`) */
  "changes.array.item-removed-from-position": "Removed from position {{position}}",
  /** Accessibility label for the "change bar" shown when there are edits on a field-level */
  "changes.change-bar.aria-label": "Review changes",
  /** Label for when the action of the change was _not_ an add/remove, eg a text field changed value, an image was changed from one asset to another or similar */
  "changes.changed-label": "Changed",
  /** Label and text for tooltip that indicates the authors of the changes */
  "changes.changes-by-author": "Changes by",
  /** Additional text shown in development mode when a diff component crashes during rendering */
  "changes.error-boundary.developer-info": "Check the developer console for more information",
  /** Text shown when a diff component crashes during rendering, triggering the error boundary */
  "changes.error-boundary.title": "Rendering the changes to this field caused an error",
  /** Error message shown when the value of a field is not the expected one */
  "changes.error.incorrect-type-message": 'Value error: Value is of type "<code>{{actualType}}</code>", expected "<code>{{expectedType}}</code>"',
  /** File diff: Fallback title for the meta info section when there is no original filename to use  */
  "changes.file.meta-info-fallback-title": "Untitled",
  /** Image diff: Text shown in tooltip when hovering hotspot that has changed in diff view */
  "changes.image.crop-changed": "Crop changed",
  /** Image diff: Text shown if the previous image asset was deleted (shouldn't theoretically happen) */
  "changes.image.deleted": "Image deleted",
  /** Image diff: Text shown if the image failed to be loaded when previewing it */
  "changes.image.error-loading-image": "Error loading image",
  /** Image diff: Text shown in tooltip when hovering hotspot that has changed in diff view */
  "changes.image.hotspot-changed": "Hotspot changed",
  /** Image diff: Fallback title for the meta info section when there is no original filename to use  */
  "changes.image.meta-info-fallback-title": "Untitled",
  /** Image diff: Text shown if no asset has been set for the field (but has metadata changes) */
  "changes.image.no-asset-set": "Image not set",
  /** Image diff: Text shown when the from/to state has/had no image */
  "changes.image.no-image-placeholder": "(no image)",
  /** Label for the "from" value in the change inspector */
  "changes.inspector.from-label": "From",
  /** Label for the "meta" (field path, action etc) information in the change inspector */
  "changes.inspector.meta-label": "Meta",
  /** Label for the "to" value in the change inspector */
  "changes.inspector.to-label": "To",
  /** Loading author of change in the differences tooltip in the review changes pane */
  "changes.loading-author": "Loading",
  /** Loading changes in Review Changes Pane */
  "changes.loading-changes": "Loading changes",
  /** No Changes description in the Review Changes pane */
  "changes.no-changes-description": "Edit the document or select an older version in the timeline to see a list of changes appear in this panel.",
  /** No Changes title in the Review Changes pane */
  "changes.no-changes-title": "There are no changes",
  /** Portable Text diff: An annotation was added */
  "changes.portable-text.annotation_added": "Added annotation",
  /** Portable Text diff: An annotation was changed */
  "changes.portable-text.annotation_changed": "Changed annotation",
  /** Portable Text diff: An annotation was removed */
  "changes.portable-text.annotation_removed": "Removed annotation",
  /** Portable Text diff: An annotation was left unchanged */
  "changes.portable-text.annotation_unchanged": "Unchanged annotation",
  /** Portable Text diff: A block changed from one style to another (eg `normal` to `h1` or similar) */
  "changes.portable-text.block-style-changed": 'Changed block style from "{{fromStyle}}" to "{{toStyle}}"',
  /** Portable Text diff: Change formatting of text (setting/unsetting marks, eg bold/italic etc) */
  "changes.portable-text.changed-formatting": "Changed formatting",
  /** Portable Text diff: An empty inline object is part of a change */
  "changes.portable-text.empty-inline-object": "Empty {{inlineObjectType}}",
  /** Portable Text diff: An empty object is the result of adding/removing an annotation */
  "changes.portable-text.empty-object-annotation": "Empty {{annotationType}}",
  /** Portable Text diff: Added a block containing no text (eg empty block) */
  "changes.portable-text.empty-text_added": "Added empty text",
  /** Portable Text diff: Changed a block that contained no text (eg empty block) */
  "changes.portable-text.empty-text_changed": "Changed empty text",
  /** Portable Text diff: Removed a block containing no text (eg empty block) */
  "changes.portable-text.empty-text_removed": "Removed empty text",
  /** Portable Text diff: An inline object was added */
  "changes.portable-text.inline-object_added": "Added inline object",
  /** Portable Text diff: An inline object was changed */
  "changes.portable-text.inline-object_changed": "Changed inline object",
  /** Portable Text diff: An inline object was removed */
  "changes.portable-text.inline-object_removed": "Removed inline object",
  /** Portable Text diff: An inline object was left unchanged */
  "changes.portable-text.inline-object_unchanged": "Unchanged inline object",
  /** Portable Text diff: Added a chunk of text */
  "changes.portable-text.text_added": "Added text",
  /** Portable Text diff: Removed a chunk of text */
  "changes.portable-text.text_removed": "Removed text",
  /** Portable Text diff: Annotation has an unknown schema type */
  "changes.portable-text.unknown-annotation-schema-type": "Unknown schema type",
  /** Portable Text diff: Inline object has an unknown schema type */
  "changes.portable-text.unknown-inline-object-schema-type": "Unknown schema type",
  /** Label for when the action of the change was a removal, eg a field was cleared, an array item was removed, an asset was deselected or similar */
  "changes.removed-label": "Removed",
  /** Title for the Review Changes pane */
  "changes.title": "Review changes",
  /** The value of the <code>_key</code> property must be a unique string. */
  "form.error.duplicate-keys-alert.details.additional-description": "The value of the <code>_key</code> property must be a unique string.",
  /** This usually happens when items are created using an API client, and the <code>_key</code> property of each elements has been generated non-uniquely. */
  "form.error.duplicate-keys-alert.details.description": "This usually happens when items are created using an API client, and the <code>_key</code> property of each elements has been generated non-uniquely.",
  /** Developer info */
  "form.error.duplicate-keys-alert.details.title": "Developer info",
  /** Generate unique keys */
  "form.error.duplicate-keys-alert.generate-button.text": "Generate unique keys",
  /** Several items in this list share the same identifier (key). Every item must have an unique identifier. */
  "form.error.duplicate-keys-alert.summary": "Several items in this list share the same identifier (key). Every item must have an unique identifier.",
  /** Non-unique keys */
  "form.error.duplicate-keys-alert.title": "Non-unique keys",
  /** Error text shown when a field with a given name cannot be found in the schema or is conditionally hidden but explicitly told to render  */
  "form.error.field-not-found": 'Field "{{fieldName}}" not found among members  verify that it is defined in the schema and that it has not been conditionally hidden.',
  /** Add missing keys */
  "form.error.missing-keys-alert.add-button.text": "Add missing keys",
  /** The value of the <code>_key</code> property must be a unique string. */
  "form.error.missing-keys-alert.details.additional-description": "The value of the <code>_key</code> property must be a unique string.",
  /** This usually happens when items are created using an API client, and the <code>_key</code> property has not been included. */
  "form.error.missing-keys-alert.details.description": "This usually happens when items are created using an API client, and the <code>_key</code> property has not been included.",
  /** Developer info */
  "form.error.missing-keys-alert.details.title": "Developer info",
  /** Some items in the list are missing their keys. This must be fixed in order to edit the list. */
  "form.error.missing-keys-alert.summary": "Some items in the list are missing their keys. This must be fixed in order to edit the list.",
  /** Missing keys */
  "form.error.missing-keys-alert.title": "Missing keys",
  /** This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list. */
  "form.error.mixed-array-alert.details.description": "This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list.",
  /** Developer info */
  "form.error.mixed-array-alert.details.title": "Developer info",
  /**  Remove non-object values */
  "form.error.mixed-array-alert.remove-button.text": "Remove non-object values",
  /** Some items in this list are not objects. This must be fixed in order to edit the list. */
  "form.error.mixed-array-alert.summary": "Some items in this list are not objects. This must be fixed in order to edit the list.",
  /** Invalid list values */
  "form.error.mixed-array-alert.title": "Invalid list values",
  /** Error text shown when form is unable to find an array item at a given indexed path */
  "form.error.no-array-item-at-index": "No array item at index <code>{{index}}</code> found at path <code>{{path}}</code>",
  /** Error text shown when form is unable to find an array item at a given keyed path */
  "form.error.no-array-item-at-key": 'No array item with `_key` <code>"{{key}}"</code> found at path <code>{{path}}</code>',
  /** Fallback title shown above field if it has no defined title */
  "form.field.untitled-field-label": "Untitled",
  /** Fallback title shown above fieldset if it has no defined title */
  "form.field.untitled-fieldset-label": "Untitled",
  /** Accessibility label for the icon that indicates the field has a validation error */
  "form.validation.has-error-aria-label": "Has error",
  /** Accessibility label for the icon that indicates the field has validation information */
  "form.validation.has-info-aria-label": "Has information",
  /** Accessibility label for the icon that indicates the field has a validation warning */
  "form.validation.has-warning-aria-label": "Has warning",
  /** Text shown when summarizing validation information, when the field has one or more errors */
  "form.validation.summary.errors-count_one": "{{count}} error",
  "form.validation.summary.errors-count_other": "{{count}} errors",
  /** Text shown when summarizing validation information, when the field has one or more warnings */
  "form.validation.summary.warnings-count_one": "{{count}} warning",
  "form.validation.summary.warnings-count_other": "{{count}} warnings",
  /**
  * Label for "contact sales" call to action
  * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
  */
  "help-resources.action.contact-sales": "Contact sales",
  /**
  * Label for "help and support" call to action
  * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
  */
  "help-resources.action.help-and-support": "Help and support",
  /**
  * Label for "join our community" call to action
  * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
  */
  "help-resources.action.join-our-community": "Join our community",
  /** Information for what the latest sanity version is */
  "help-resources.latest-sanity-version": "Latest version is {{latestVersion}}",
  /** Information for what studio version the current studio is running */
  "help-resources.studio-version": "Sanity Studio version {{studioVersion}}",
  /** Title for help and resources menus */
  "help-resources.title": "Help and resources",
  /** Text for file input button in upload placeholder */
  "input.files.common.upload-placeholder.file-input-button.text": "Upload",
  /** Uploading <FileName/> */
  "input.files.common.upload-progress": "Uploading <FileName/>",
  /** The referenced document cannot be opened, because the URL failed to be resolved */
  "input.reference.document-cannot-be-opened.failed-to-resolve-url": "This document cannot be opened (unable to resolve URL to Studio)",
  /** Label for adding item after a specific array item */
  "inputs.array.action.add-after": "Add item after",
  /** Label for adding item before a specific array item */
  "inputs.array.action.add-before": "Add item before",
  /** Label for adding array item action when the schema allows for only one schema type */
  "inputs.array.action.add-item": "Add item",
  /**
  * Label for adding one array item action when the schema allows for multiple schema types,
  * eg. will prompt the user to select a type once triggered
  */
  "inputs.array.action.add-item-select-type": "Add item...",
  /** Label for duplicating an array item  */
  "inputs.array.action.duplicate": "Duplicate",
  /** Label for editing the item of a specific type, eg "Edit Person" */
  "inputs.array.action.edit": "Edit {{itemTypeTitle}}",
  /** Label for removing an array item action  */
  "inputs.array.action.remove": "Remove",
  /** Label for removing action when an array item has an error  */
  "inputs.array.action.remove-invalid-item": "Remove",
  /** Label for viewing the item of a specific type, eg "View Person" */
  "inputs.array.action.view": "View {{itemTypeTitle}}",
  /** Error description for the array item tooltip that explains that the current item can still be moved or deleted but not edited since the schema definition is not found */
  "inputs.array.error.can-delete-but-no-edit-description": "You can still move or delete this item, but it cannot be edited since the schema definition for its type is nowhere to be found.",
  /** Error label for toast when array could not resolve the initial value */
  "inputs.array.error.cannot-resolve-initial-value-title": "Unable to resolve initial value for type: {{schemaTypeTitle}}: {{errorMessage}}.",
  /** Error label for toast when trying to upload one array item of a type that cannot be converted to array */
  "inputs.array.error.cannot-upload-unable-to-convert_one": "The following item can't be uploaded because there's no known conversion from content type to array item:",
  /** Error label for toast when trying to upload multiple array items of a type that cannot be converted to array */
  "inputs.array.error.cannot-upload-unable-to-convert_other": "The following items can't be uploaded because there's no known conversion from content types to array item:",
  /** Error description for the array item tooltip that explains that the current type item is not valid for the list  */
  "inputs.array.error.current-schema-not-declare-description": "The current schema does not declare items of type <code>{{typeName}}</code> as valid for this list. This could mean that the type has been removed as a valid item type, or that someone else has added it to their own local schema that is not yet deployed.",
  /** Error description to show how the item is being represented in the json format */
  "inputs.array.error.json-representation-description": "JSON representation of this item:",
  /** Error description for the array item tooltip that explains what the error means with more context */
  "inputs.array.error.type-is-incompatible-prompt": "Item of type <code>{{typeName}}</code> not valid for this list",
  /** Error title for when an item type within an array input is incompatible, used in the tooltip */
  "inputs.array.error.type-is-incompatible-title": "Why is this happening?",
  /** Error label for unexpected errors in the Array Input */
  "inputs.array.error.unexpected-error": "Unexpected Error: {{error}}",
  /** Label for when the array input doesn't have any items */
  "inputs.array.no-items-label": "No items",
  /** Label for read only array fields */
  "inputs.array.read-only-label": "This field is read-only",
  /** Label for when the array input is resolving the initial value for the item */
  "inputs.array.resolving-initial-value": "Resolving initial value",
  /** Placeholder value for datetime input */
  "inputs.datetime.placeholder": "e.g. {{example}}",
  /** Acessibility label for button to open file options menu */
  "inputs.file.actions-menu.file-options.aria-label": "Open file options menu",
  /** Browse */
  "inputs.file.browse-button.text": "Browse",
  /** Select file */
  "inputs.file.dialog.title": "Select file",
  /** Unknown member kind: `{{kind}}` */
  "inputs.file.error.unknown-member-kind": "Unknown member kind: {{kind}}",
  /** The value of this field is not a valid file. Resetting this field will let you choose a new file. */
  "inputs.file.invalid-file-warning.description": "The value of this field is not a valid file. Resetting this field will let you choose a new file.",
  /** Reset value */
  "inputs.file.invalid-file-warning.reset-button.text": "Reset value",
  /** Invalid file value */
  "inputs.file.invalid-file-warning.title": "Invalid file value",
  /** Select */
  "inputs.file.multi-browse-button.text": "Select",
  /** The upload could not be completed at this time. */
  "inputs.file.upload-failed.description": "The upload could not be completed at this time.",
  /** Upload failed */
  "inputs.file.upload-failed.title": "Upload failed",
  /** Clear field */
  "inputs.files.common.actions-menu.clear-field.label": "Clear field",
  /** Copy URL */
  "inputs.files.common.actions-menu.copy-url.label": "Copy URL",
  /** Download */
  "inputs.files.common.actions-menu.download.label": "Download",
  /** The URL is copied to the clipboard */
  "inputs.files.common.actions-menu.notification.url-copied": "The URL is copied to the clipboard",
  /** Replace */
  "inputs.files.common.actions-menu.replace.label": "Replace",
  /** Upload */
  "inputs.files.common.actions-menu.upload.label": "Upload",
  /** Drop to upload */
  "inputs.files.common.drop-message.drop-to-upload": "Drop to upload",
  /** Drop to upload `{{count}}` file */
  "inputs.files.common.drop-message.drop-to-upload-multi_one": "Drop to upload {{count}} file",
  /** Drop to upload `{{count}}` files */
  "inputs.files.common.drop-message.drop-to-upload-multi_other": "Drop to upload {{count}} files",
  /** Can't upload this file here */
  "inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message_one": "Can't upload this file here",
  /** Can't upload any of these files here */
  "inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message_other": "Can't upload any of these files here",
  /** `{{count}}` file can't be uploaded here */
  "inputs.files.common.drop-message.drop-to-upload.rejected-file-message_one": "{{count}} file can't be uploaded here",
  /** `{{count}}` files can't be uploaded here */
  "inputs.files.common.drop-message.drop-to-upload.rejected-file-message_other": "{{count}} files can't be uploaded here",
  /** Cannot upload `{{count}}` files */
  "inputs.files.common.placeholder.cannot-upload-some-files_one": "Cannot upload file",
  "inputs.files.common.placeholder.cannot-upload-some-files_other": "Cannot upload {{count}} files",
  /** Drag or paste type here */
  "inputs.files.common.placeholder.drag-or-paste-to-upload_file": "Drag or paste file here",
  /** Drag or paste image here */
  "inputs.files.common.placeholder.drag-or-paste-to-upload_image": "Drag or paste image here",
  /** Drop to upload file */
  "inputs.files.common.placeholder.drop-to-upload_file": "Drop to upload file",
  /** Drop to upload image */
  "inputs.files.common.placeholder.drop-to-upload_image": "Drop to upload image",
  /** Read only */
  "inputs.files.common.placeholder.read-only": "Read only",
  /** Can't upload files here */
  "inputs.files.common.placeholder.upload-not-supported": "Can't upload files here",
  /** Clear upload */
  "inputs.files.common.stale-upload-warning.clear": "Clear upload",
  /** An upload has made no progress for at least `{{staleThresholdMinutes}}` minutes and likely got interrupted. You can safely clear the incomplete upload and try uploading again. */
  "inputs.files.common.stale-upload-warning.description": "An upload has made no progress for at least {{staleThresholdMinutes}} minutes and likely got interrupted. You can safely clear the incomplete upload and try uploading again.",
  /** Incomplete upload */
  "inputs.files.common.stale-upload-warning.title": "Incomplete upload",
  /** Tooltip text for action to crop image */
  "inputs.image.actions-menu.crop-image-tooltip": "Crop image",
  /** Accessibility label for button to open image edit dialog */
  "inputs.image.actions-menu.edit-details.aria-label": "Open image edit dialog",
  /** Accessibility label for button to open image options menu */
  "inputs.image.actions-menu.options.aria-label": "Open image options menu",
  /** Select */
  "inputs.image.browse-menu.text": "Select",
  /** Cannot upload this file here */
  "inputs.image.drag-overlay.cannot-upload-here": "Cannot upload this file here",
  /** Drop image to upload */
  "inputs.image.drag-overlay.drop-to-upload-image": "Drop image to upload",
  /** This field is read only */
  "inputs.image.drag-overlay.this-field-is-read-only": "This field is read only",
  /** Unknown member kind: `{{kind}}` */
  "inputs.image.error.unknown-member-kind": "Unknown member kind: {{kind}}",
  /** Edit hotspot and crop */
  "inputs.image.hotspot-dialog.title": "Edit hotspot and crop",
  /** The value of this field is not a valid image. Resetting this field will let you choose a new image. */
  "inputs.image.invalid-image-warning.description": "The value of this field is not a valid image. Resetting this field will let you choose a new image.",
  /** Reset value */
  "inputs.image.invalid-image-warning.reset-button.text": "Reset value",
  /** Invalid image value */
  "inputs.image.invalid-image-warning.title": "Invalid image value",
  /** Preview of uploaded image */
  "inputs.image.preview-uploaded-image": "Preview of uploaded image",
  /** The upload could not be completed at this time. */
  "inputs.image.upload-error.description": "The upload could not be completed at this time.",
  /** Upload failed */
  "inputs.image.upload-error.title": "Upload failed",
  /** Adjust the rectangle to crop image. Adjust the circle to specify the area that should always be visible. */
  "inputs.imagetool.description": "Adjust the rectangle to crop image. Adjust the circle to specify the area that should always be visible.",
  /** Error: `{{errorMessage}}` */
  "inputs.imagetool.load-error": "Error: {{errorMessage}}",
  /** Loading image */
  "inputs.imagetool.loading": "Loading image",
  /** Hotspot & Crop */
  "inputs.imagetool.title": "Hotspot & Crop",
  /** Convert to <code>`{{targetType}}`</code> */
  "inputs.invalid-value.convert-button.text": "Convert to <code>{{targetType}}</code>",
  /** The current value (<code>`{{actualType}}`</code>) */
  "inputs.invalid-value.current-type": "The current value (<code>{{actualType}}</code>)",
  /** The property value is stored as a value type that does not match the expected type. */
  "inputs.invalid-value.description": "The property value is stored as a value type that does not match the expected type.",
  /** The value of this property must be of type <code>`{{validType}}`</code> according to the schema. */
  "inputs.invalid-value.details.description": "The value of this property must be of type <code>{{validType}}</code> according to the schema.",
  /** Only the following types are valid here according to schema: */
  "inputs.invalid-value.details.multi-type-description": "Only the following types are valid here according to schema:",
  /** Mismatching value types typically occur when the schema has recently been changed. */
  "inputs.invalid-value.details.possible-reason": "Mismatching value types typically occur when the schema has recently been changed.",
  /** Developer info */
  "inputs.invalid-value.details.title": "Developer info",
  /** -- Invalid Value Input -- */
  /** Reset value */
  "inputs.invalid-value.reset-button.text": "Reset value",
  /** Invalid property value */
  "inputs.invalid-value.title": "Invalid property value",
  /** Field groups */
  "inputs.object.field-group-tabs.aria-label": "Field groups",
  /** Read-only field description */
  "inputs.object.unknown-fields.read-only.description": "This field is <strong>read only</strong> according to the documents schema and cannot be unset. If you want to be able to unset this in Studio, make sure you remove the <code>readOnly</code> field from the enclosing type in the schema.",
  /** Remove field */
  "inputs.object.unknown-fields.remove-field-button.text": "Remove field",
  /** Encountered `{{count}}` fields that are not defined in the schema. */
  "inputs.object.unknown-fields.warning.description_one": "Encountered a field that is not defined in the schema.",
  "inputs.object.unknown-fields.warning.description_other": "Encountered {{count}} fields that are not defined in the schema.",
  /** Detailed description of unknown field warning */
  "inputs.object.unknown-fields.warning.details.description_one": "This field is not defined in the schema, which could mean that the field definition has been removed or that someone else has added it to their own local project and have not deployed their changes yet.",
  "inputs.object.unknown-fields.warning.details.description_other": "These fields are not defined in the documents schema, which could mean that the field definitions have been removed or that someone else has added them to their own local project and have not deployed their changes yet.",
  /** Developer info */
  "inputs.object.unknown-fields.warning.details.title": "Developer info",
  /** Unknown field found */
  "inputs.object.unknown-fields.warning.title_one": "Unknown field found",
  "inputs.object.unknown-fields.warning.title_other": "Unknown fields found",
  /** Collapse the editor to save screen space  */
  "inputs.portable-text.action.collapse-editor": "Collapse editor",
  /** Label for action to edit an existing annotation */
  "inputs.portable-text.action.edit-annotation": "Edit annotation",
  /** Expand the editor to give more editing space */
  "inputs.portable-text.action.expand-editor": "Expand editor",
  /** Label label for action to insert a block of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-block": "Insert {{typeName}}",
  /** Accessibility label for action to insert a block of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-block-aria-label": "Insert {{typeName}} (block)",
  /** Label for action to insert an inline object of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-inline-object": "Insert {{typeName}}",
  /** Accessibility label for action to insert an inline object of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-inline-object-aria-label": "Insert {{typeName}} (inline)",
  /** Label for action to remove an annotation */
  "inputs.portable-text.action.remove-annotation": "Remove annotation",
  /** Label for activate on focus with context of click and not focused */
  "inputs.portable-text.activate-on-focus-message_click": "Click to activate",
  /** Label for activate on focus with context of click and focused */
  "inputs.portable-text.activate-on-focus-message_click-focused": "Click or press space to activate",
  /** Label for activate on focus with context of tap and not focused */
  "inputs.portable-text.activate-on-focus-message_tap": "Tap to activate",
  /** Title for dialog that allows editing an annotation */
  "inputs.portable-text.annotation-editor.title": "Edit {{schemaType}}",
  /** Title of the default "link" annotation */
  "inputs.portable-text.annotation.link": "Link",
  /** Label for action to edit a block item, in the case where it is editable */
  "inputs.portable-text.block.edit": "Edit",
  /** Accessibility label for the button that opens the actions menu on blocks */
  "inputs.portable-text.block.open-menu-aria-label": "Open menu",
  /** Label for action to open a reference, in the case of block-level reference types */
  "inputs.portable-text.block.open-reference": "Open reference",
  /** Label for action to remove a block item */
  "inputs.portable-text.block.remove": "Remove",
  /** Label for action to view a block item, in the case where it is read-only and thus cannot be edited */
  "inputs.portable-text.block.view": "View",
  /** Title of the "code" decorator */
  "inputs.portable-text.decorator.code": "Code",
  /** Title of the "em" (emphasis) decorator */
  "inputs.portable-text.decorator.emphasis": "Italic",
  /** Title of the "strike-through" decorator */
  "inputs.portable-text.decorator.strike-through": "Strike",
  /** Title of the "strong" decorator */
  "inputs.portable-text.decorator.strong": "Strong",
  /** Title of the "underline" decorator */
  "inputs.portable-text.decorator.underline": "Underline",
  /** Placeholder text for when the editor is empty */
  "inputs.portable-text.empty-placeholder": "Empty",
  /** Label for action to edit an inline object item */
  "inputs.portable-text.inline-object.edit": "Edit object",
  /** Label for action to remove an inline object item */
  "inputs.portable-text.inline-object.remove": "Remove object",
  /** Disclaimer text shown on invalid Portable Text value, when an action is available to unblock the user, but it is not guaranteed to be safe */
  "inputs.portable-text.invalid-value.action-disclaimer": "NOTE: Its generally safe to perform the action above, but if you are in doubt, get in touch with those responsible for configuring your studio.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` of type `{{childType}}` which is not allowed by the schema definition */
  "inputs.portable-text.invalid-value.disallowed-child-type.action": "Remove the object",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` of type `{{childType}}` which is not allowed by the schema definition */
  "inputs.portable-text.invalid-value.disallowed-child-type.description": "Child with key {{childKey}} of block with key <code>{{key}}</code> is of type <code>{{childType}}</code>, which is not allowed by the schema.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a type (`{{typeName}}`) that is not an allowed block type for this field */
  "inputs.portable-text.invalid-value.disallowed-type.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a type (`{{typeName}}`) that is not an allowed block type for this field */
  "inputs.portable-text.invalid-value.disallowed-type.description": "Block with key <code>{{key}}</code> is of type <code>{{typeName}}</code>, which is not allowed by the schema.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains no children */
  "inputs.portable-text.invalid-value.empty-children.action": "Insert empty text span",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains no children */
  "inputs.portable-text.invalid-value.empty-children.description": "Text block with key <code>{{key}}</code> has no text spans.",
  /** Label for the button to ignore invalid values in the Portable Text editor */
  "inputs.portable-text.invalid-value.ignore-button.text": "Ignore",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a `_type` property that is set to `block`, but the block type defined in schema has a different name (`{{expectedTypeName}}`) */
  "inputs.portable-text.invalid-value.incorrect-block-type.action": "Use type <code>{{expectedTypeName}}</code>",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a `_type` property that is set to `block`, but the block type defined in schema has a different name (`{{expectedTypeName}}`) */
  "inputs.portable-text.invalid-value.incorrect-block-type.description": "Block with key <code>{{key}}</code> has an invalid type name. According to the schema, it should be <code>{{expectedTypeName}}</code>.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a span with key `{{childKey}}` that has a missing or invalid `text` property */
  "inputs.portable-text.invalid-value.invalid-span-text.action": "Set empty text value",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a span with key `{{childKey}}` that has a missing or invalid `text` property */
  "inputs.portable-text.invalid-value.invalid-span-text.description": "Span with key {{childKey}} of block with key <code>{{key}}</code> has a missing or invalid <code>text</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property, but seems to be a block of type `{{expectedTypeName}}` */
  "inputs.portable-text.invalid-value.missing-block-type.action": "Use type <code>{{expectedTypeName}}</code>",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property, but seems to be a block of type `{{expectedTypeName}}` */
  "inputs.portable-text.invalid-value.missing-block-type.description": "Block with key <code>{{key}}</code> is missing a type name. According to the schema, it should be <code>{{expectedTypeName}}</code>.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child at `{{index}}` which is missing `_key` property */
  "inputs.portable-text.invalid-value.missing-child-key.action": "Assign random key",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child at `{{index}}` which is missing `_key` property */
  "inputs.portable-text.invalid-value.missing-child-key.description": "Child at index <code>{{index}}</code> of block with key <code>{{key}}</code> is missing <code>_key</code> property.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` which is missing a `_type` property */
  "inputs.portable-text.invalid-value.missing-child-type.action": "Remove the object",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` which is missing a `_type` property */
  "inputs.portable-text.invalid-value.missing-child-type.description": "Child with key {{childKey}} of block with key <code>{{key}}</code> is missing <code>_type</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child at `{{index}}` is missing the required `_key` property */
  "inputs.portable-text.invalid-value.missing-key.action": "Assign random key",
  /** Text explaining that the Portable Text field value is invalid, when child at `{{index}}` is missing the required `_key` property */
  "inputs.portable-text.invalid-value.missing-key.description": "Block at index <code>{{index}}</code> is missing required <code>_key</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `children` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-children.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `children` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-children.description": "Text block with key <code>{{key}}</code> has an invalid or missing `children` property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `markDefs` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action": "Add property",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `markDefs` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description": "Text block with key <code>{{key}}</code> has an invalid or missing `markDefs` property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property  */
  "inputs.portable-text.invalid-value.missing-type.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property  */
  "inputs.portable-text.invalid-value.missing-type.description": "Block with key <code>{{key}}</code> is missing a type name.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains a non-object child at index `{{index}}` */
  "inputs.portable-text.invalid-value.non-object-child.action": "Remove the item",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains a non-object child at index `{{index}}` */
  "inputs.portable-text.invalid-value.non-object-child.description": "Child at index <code>{{index}}</code> of block with key <code>{{key}}</code> is not an object.",
  /** Action presented when the Portable Text field value is invalid, when the Portable Text field is not an array, or the array is empty */
  "inputs.portable-text.invalid-value.not-an-array.action": "Unset the value",
  /** Text explaining that the Portable Text field value is invalid, when the Portable Text field is not an array, or the array is empty */
  "inputs.portable-text.invalid-value.not-an-array.description": "Value must be an array of Portable Text blocks, or undefined.",
  /** Action presented when the Portable Text field value is invalid, when child at `{{index}}` is not an object */
  "inputs.portable-text.invalid-value.not-an-object.action": "Remove item",
  /** Text explaining that the Portable Text field value is invalid, when child at `{{index}}` is not an object */
  "inputs.portable-text.invalid-value.not-an-object.description": "Item at <code>{{index}}</code> is not an object,.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains marks (`{{orphanedMarks}}`) that are not supported by the current schema */
  "inputs.portable-text.invalid-value.orphaned-marks.action": "Remove disallowed marks",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains marks (`{{orphanedMarks}}`) that are not supported by the current schema */
  "inputs.portable-text.invalid-value.orphaned-marks.description": "Text block with key <code>{{key}}</code> contains marks <code>({{orphanedMarks, list}})</code> that are not allowed by the schema.",
  /** Title for the alert indicating that the Portable Text field has an invalid value */
  "inputs.portable-text.invalid-value.title": "Invalid Portable Text value",
  /** Title of "bulleted" list type */
  "inputs.portable-text.list-type.bullet": "Bulleted list",
  /** Title of numbered list type */
  "inputs.portable-text.list-type.number": "Numbered list",
  /** Title of the "h1" block style */
  "inputs.portable-text.style.h1": "Heading 1",
  /** Title of the "h2" block style */
  "inputs.portable-text.style.h2": "Heading 2",
  /** Title of the "h3" block style */
  "inputs.portable-text.style.h3": "Heading 3",
  /** Title of the "h4" block style */
  "inputs.portable-text.style.h4": "Heading 4",
  /** Title of the "h5" block style */
  "inputs.portable-text.style.h5": "Heading 5",
  /** Title of the "h6" block style */
  "inputs.portable-text.style.h6": "Heading 6",
  /** Title shown when multiple blocks of varying styles is selected */
  "inputs.portable-text.style.multiple": "Multiple",
  /** Title of fallback when no style is given for a block */
  "inputs.portable-text.style.none": "No style",
  /** Title of the "normal" block style */
  "inputs.portable-text.style.normal": "Normal",
  /** Title of the "quote" block style */
  "inputs.portable-text.style.quote": "Quote",
  /** Label for action to create a new document from the reference input, when there are multiple templates or document types to choose from */
  "inputs.reference.action-create-new-document-select": "Create new",
  /** Label for action to clear the current value of the reference field */
  "inputs.reference.action.clear": "Clear",
  /** Label for action to create a new document from the reference input */
  "inputs.reference.action.create-new-document": "Create new",
  /** Label for action to duplicate the current item to a new item (used within arrays) */
  "inputs.reference.action.duplicate": "Duplicate",
  /** Label for action that opens the referenced document in a new tab */
  "inputs.reference.action.open-in-new-tab": "Open in new tab",
  /** Label for action to remove the reference from an array */
  "inputs.reference.action.remove": "Remove",
  /** Label for action to replace the current value of the field */
  "inputs.reference.action.replace": "Replace",
  /** Label for action to cancel a previously initiated replace action  */
  "inputs.reference.action.replace-cancel": "Cancel replace",
  /** The cross-dataset reference field currently has a reference, but the feature has been disabled since it was created. This explains what can/cannot be done in its current state. */
  "inputs.reference.cross-dataset.feature-disabled-actions": "You can still clear this field's existing reference, but it cannot be changed to a different document as long as the feature is disabled.",
  /** A cross-dataset reference field exists but the feature has been disabled. A <DocumentationLink> component is available. */
  "inputs.reference.cross-dataset.feature-disabled-description": "This feature has been disabled. Read how to enable it in <DocumentationLink>the documentation</DocumentationLink>.",
  /** Title for a warning telling the user that the current project does not have the "cross dataset references" feature */
  "inputs.reference.cross-dataset.feature-unavailable-title": "Unavailable feature: Cross dataset reference",
  /** The cross-dataset reference points to a document with an invalid type  */
  "inputs.reference.cross-dataset.invalid-type": "The referenced document is of invalid type ({{typeName}}) <JsonValue/>",
  /** The referenced document will open in a new tab (due to external studio) */
  "inputs.reference.document-opens-in-new-tab": "This document opens in a new tab",
  /** Error title for when the document is unavailable (for any possible reason) */
  "inputs.reference.error.document-unavailable-title": "Document unavailable",
  /** Error title for when the referenced document failed to be loaded */
  "inputs.reference.error.failed-to-load-document-title": "Failed to load referenced document",
  /** Error title for when the reference search returned a document that is not an allowed type for the field */
  "inputs.reference.error.invalid-search-result-type-title": `Search returned a type that's not valid for this reference: "{{returnedType}}"`,
  /** Error description for when the document referenced is not one of the types declared as allowed target types in schema */
  "inputs.reference.error.invalid-type-description": "Referenced document (<code>{{documentId}}</code>) is of type <code>{{actualType}}</code>. According to the schema, referenced documents can only be of type <AllowedTypes />.",
  /** Error title for when the document referenced is not one of the types declared as allowed target types in schema */
  "inputs.reference.error.invalid-type-title": "Document of invalid type",
  /** Error description for when the user does not have permissions to read the referenced document */
  "inputs.reference.error.missing-read-permissions-description": "The referenced document could not be accessed due to insufficient permissions",
  /** Error title for when the user does not have permissions to read the referenced document */
  "inputs.reference.error.missing-read-permissions-title": "Insufficient permissions",
  /** Error description for when the current reference value points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document-description": "The referenced document does not exist (ID: <code>{{documentId}}</code>). You can either remove the reference or replace it with another document.",
  /** Error title for when the current reference value points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document-title": "Not found",
  /** Label for button that clears the reference when it points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document.clear-button-label": "Clear",
  /** Error title for when the search for a reference failed. Note that the message sent by the backend may not be localized. */
  "inputs.reference.error.search-failed-title": "Reference search failed",
  /** Alternative text for the image shown in cross-dataset reference input */
  "inputs.reference.image-preview-alt-text": "Image preview of referenced document",
  /** Description for alert shown when a reference in a live-edit document is marked as being weak, the referenced document exists, AND the reference is supposed to be have been strengthened on publish */
  "inputs.reference.incomplete-reference.finalize-action-description": "<strong>{{referencedDocument}}</strong> is published and this reference should now be finalized.",
  /** Title for alert shown when a reference in a live-edit document is marked as being weak, the referenced document exists, AND the reference is supposed to be have been strengthened on publish */
  "inputs.reference.incomplete-reference.finalize-action-title": "Finalize reference",
  /** Description for alert shown when a reference in a live-edit document points to a document that exists and has been published, but the reference is still marked as weak */
  "inputs.reference.incomplete-reference.strengthen-action-description": "<strong>{{referencedDocument}}</strong> is published and this reference should now be converted to a strong reference.",
  /** Title for alert shown when a reference in a live-edit document points to a document that exists and has been published, but the reference is still marked as weak */
  "inputs.reference.incomplete-reference.strengthen-action-title": "Convert to strong reference",
  /** Label for button that triggers the action that strengthen a reference */
  "inputs.reference.incomplete-reference.strengthen-button-label": "Convert to strong reference",
  /** Label for button that triggers a retry attempt for reference metadata  */
  "inputs.reference.metadata-error.retry-button-label": "Retry",
  /** Title for alert shown when reference metadata fails to be loaded */
  "inputs.reference.metadata-error.title": "Unable to load reference metadata",
  /** Message shown when no documents were found that matched the given search string */
  "inputs.reference.no-results-for-query": "No results for <strong>{{searchTerm}}</strong>",
  /** Text for tooltip showing when a document was edited, using relative time (eg "how long ago was it edited?") */
  "inputs.reference.preview.edited-at-time": "Edited <RelativeTime/>",
  /** Accessibility label for icon indicating that document does _not_ have any unpublished changes */
  "inputs.reference.preview.has-no-unpublished-changes-aria-label": "No unpublished edits",
  /** Accessibility label for icon indicating that document has unpublished changes */
  "inputs.reference.preview.has-unpublished-changes-aria-label": "Edited",
  /** Accessibility label for icon indicating that document does _not_ have a published version */
  "inputs.reference.preview.is-not-published-aria-label": "Not published",
  /** Accessibility label for icon indicating that document has a published version */
  "inputs.reference.preview.is-published-aria-label": "Published",
  /** Text for tooltip indicating that a document has no unpublished edits */
  "inputs.reference.preview.no-unpublished-edits": "No unpublished edits",
  /** Text for tooltip indicating that a document has not yet been published */
  "inputs.reference.preview.not-published": "Not published",
  /** Text for tooltip showing when a document was published, using relative time (eg "how long ago was it published?") */
  "inputs.reference.preview.published-at-time": "Published <RelativeTime/>",
  /** The referenced document no longer exist and might have been deleted (for weak references) */
  "inputs.reference.referenced-document-does-not-exist": "The referenced document no longer exist and might have been deleted (document ID: <code>{{documentId}}</code>).",
  /** The referenced document could not be displayed to the user because of insufficient permissions */
  "inputs.reference.referenced-document-insufficient-permissions": "The referenced document could not be accessed due to insufficient permissions",
  /** Label for when the reference input is resolving the initial value for an item */
  "inputs.reference.resolving-initial-value": "Resolving initial value",
  /** Placeholder shown in a reference input with no current value */
  "inputs.reference.search-placeholder": "Type to search",
  /** Explanation of the consequences of leaving the reference as strong instead of weak */
  "inputs.reference.strength-mismatch.is-strong-consquences": "It will not be possible to delete the reference document without first removing this reference or converting it to weak.",
  /** Description for alert shown when a reference is supposed to be weak, but the actual value is strong */
  "inputs.reference.strength-mismatch.is-strong-description": "This reference is <em>strong</em>, but according to the current schema it should be <em>weak</em>.",
  /** Explanation of the consequences of leaving the reference as weak instead of strong */
  "inputs.reference.strength-mismatch.is-weak-consquences": "This makes it possible to delete the referenced document without first deleting this reference, leaving this field referencing a nonexisting document.",
  /** Description for alert shown when a reference is supposed to be strong, but the actual value is weak */
  "inputs.reference.strength-mismatch.is-weak-description": "This reference is <em>weak</em>, but according to the current schema it should be <em>strong</em>.",
  /** Label for button that triggers the action that strengthens a reference on strength mismatch */
  "inputs.reference.strength-mismatch.strengthen-button-label": "Convert to strong reference",
  /** Title for alert shown when a reference is supposed to be weak/strong, but the actual value is the opposite of what it is supposed to be */
  "inputs.reference.strength-mismatch.title": "Reference strength mismatch",
  /** Label for button that triggers the action that weakens a reference on strength mismatch */
  "inputs.reference.strength-mismatch.weaken-button-label": "Convert to weak reference",
  /** Action message for generating the slug */
  "inputs.slug.action.generate": "Generate",
  /** Loading message for when the input is actively generating a slug */
  "inputs.slug.action.generating": "Generating",
  /** Error message for when the source to generate a slug from is missing */
  "inputs.slug.error.missing-source": "Source is missing. Check source on type {{schemaType}} in schema",
  /** Convert to <code>`{{targetType}}`</code> */
  "inputs.untyped-value.convert-button.text": "Convert to <code>{{targetType}}</code>",
  /** Encountered an object value without a <code>_type</code> property. */
  "inputs.untyped-value.description": "Encountered an object value without a <code>_type</code> property.",
  /** Either remove the <code>name</code> property of the object declaration, or set <code>_type</code> property on items. */
  "inputs.untyped-value.details.description": "Either remove the <code>name</code> property of the object declaration, or set <code>_type</code> property on items.",
  /** Current value (<code>object</code>): */
  "inputs.untyped-value.details.json-dump-prefix": "Current value (<code>object</code>):",
  /** The following types are valid here according to schema: */
  "inputs.untyped-value.details.multi-type-description": "The following types are valid here according to schema:",
  /** Developer info */
  "inputs.untyped-value.details.title": "Developer info",
  /** Property value missing <code>_type</code> */
  "inputs.untyped-value.title": "Property value missing <code>_type</code>",
  /** Unset value */
  "inputs.untyped-value.unset-item-button.text": "Unset value",
  /** The fallback explanation if no context is provided */
  "insufficient-permissions-message.not-authorized-explanation": "You do not have permission to access this feature.",
  /** The explanation when unable to create any document at all */
  "insufficient-permissions-message.not-authorized-explanation_create-any-document": "You do not have permission to create a document.",
  /** The explanation when unable to create a particular document */
  "insufficient-permissions-message.not-authorized-explanation_create-document": "You do not have permission to create this document.",
  /** The explanation when unable to create a particular type of document */
  "insufficient-permissions-message.not-authorized-explanation_create-document-type": "You do not have permission to create this kind of document.",
  /** The explanation when unable to create a new reference in a document */
  "insufficient-permissions-message.not-authorized-explanation_create-new-reference": "You do not have permission to create a new reference.",
  /** The explanation when unable to delete a particular document */
  "insufficient-permissions-message.not-authorized-explanation_delete-document": "You do not have permission to delete this document.",
  /** The explanation when unable to discard changes in a particular document */
  "insufficient-permissions-message.not-authorized-explanation_discard-changes": "You do not have permission to discard changes in this document.",
  /** The explanation when unable to duplicate a particular document */
  "insufficient-permissions-message.not-authorized-explanation_duplicate-document": "You do not have permission to duplicate this document.",
  /** The explanation when unable to publish a particular document */
  "insufficient-permissions-message.not-authorized-explanation_publish-document": "You do not have permission to publish this document.",
  /** The explanation when unable to unpublish a particular document */
  "insufficient-permissions-message.not-authorized-explanation_unpublish-document": "You do not have permission to unpublish this document.",
  /** Appears after the not-authorized message. Lists the current roles. */
  "insufficient-permissions-message.roles": "Your roles: <Roles/>",
  /** The title for the insufficient permissions message component */
  "insufficient-permissions-message.title": "Insufficient permissions",
  /** Unexpected error: `{{error}}` */
  "member-field-error.unexpected-error": "Unexpected error: {{error}}",
  /**
  * Tooltip message displayed when hovering/activating the "Create new document" action,
  * when there are templates/types available for creation
  */
  "new-document.create-new-document-label": "New document",
  /** Placeholder for the "filter" input within the new document menu */
  "new-document.filter-placeholder": "Filter",
  /** Loading indicator text within the new document menu */
  "new-document.loading": "Loading",
  /** Accessibility label for the list displaying options in the new document menu */
  "new-document.new-document-aria-label": "New document",
  /** Message for when there are no document type options in the new document menu */
  "new-document.no-document-types-found": "No document types found",
  /**
  * Tooltip message displayed when hovering/activating the "Create new document" action,
  * when there are no templates/types to create from
  */
  "new-document.no-document-types-label": "No document types",
  /** Message for when no results are found for a specific search query in the new document menu */
  "new-document.no-results": "No results for <strong>{{searchQuery}}</strong>",
  /** Aria label for the button that opens the "Create new document" popover/dialog */
  "new-document.open-dialog-aria-label": "Create new document",
  /** Title for "Create new document" dialog */
  "new-document.title": "Create new document",
  /** Label for action to manage members of the current studio project */
  "presence.action.manage-members": "Manage members",
  /** Accessibility label for Avatar Stack */
  "presence.aria-label": "Who is here",
  /** Message description for when no one else is currently present */
  "presence.no-one-else-description": "Invite people to the project to see their online status.",
  /** Message title for when no one else is currently present */
  "presence.no-one-else-title": "No one else is here",
  /** Message for when a user is not in a document (displayed in the global presence menu) */
  "presence.not-in-a-document": "Not in a document",
  /** Fallback title shown when a preview does not provide a title */
  "preview.default.title-fallback": "Untitled",
  /** Fallback preview value for types that have "no value" (eg null, undefined) */
  "preview.fallback.no-value": "(no value)",
  /** Alternative text for image being shown while image is being uploaded, in previews */
  "preview.image.file-is-being-uploaded.alt-text": "The image currently being uploaded",
  /* Relative time, just now */
  "relative-time.just-now": "just now",
  /** Accessibility label to open search action when the search would go fullscreen (eg on narrower screens) */
  "search.action-open-aria-label": "Open search",
  /** Action label for adding a search filter */
  "search.action.add-filter": "Add filter",
  /** Action label for clearing search filters */
  "search.action.clear-filters": "Clear filters",
  /** Label for action to clear recent searches */
  "search.action.clear-recent-searches": "Clear recent searches",
  /** Accessibility label for action to clear all currently applied document type filters */
  "search.action.clear-type-filters-aria-label": "Clear checked filters",
  /** Label for action to clear all currently applied document type filters */
  "search.action.clear-type-filters-label": "Clear",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to close the search */
  "search.action.close-search-aria-label": "Close search",
  /** Accessibility label for filtering by document type */
  "search.action.filter-by-document-type-aria-label": "Filter by document type",
  /** Accessibility action label for removing an already applied search filter */
  "search.action.remove-filter-aria-label": "Remove filter",
  /**
  * Text displayed when either no document type(s) have been selected, or we need a fallback,
  * eg "Search for all types".
  */
  "search.action.search-all-types": "Search all documents",
  /**
  * Text displayed when we are able to determine one or more document types that will be used for
  * searching, and can fit within the space assigned by the design.
  */
  "search.action.search-specific-types": "Search for {{types, list}}",
  /**
  * Text displayed when we are able to determine one or more document types that will be used for
  * searching, but cannot list them all within the space assigned by the design, so we need an
  * additional "and X more" suffix. Allows using pluralization suffixes, eg `_one`, `_other` etc.
  */
  "search.action.search-specific-types-truncated": "Search for {{types, list}} +{{count}} more",
  /** Dialog title for action to select an asset of unknown type */
  "search.action.select-asset": "Select asset",
  /** Dialog title for action to select a file asset */
  "search.action.select-asset_file": "Select file",
  /** Dialog title for action to select an image asset */
  "search.action.select-asset_image": "Select image",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to hide filters */
  "search.action.toggle-filters-aria-label_hide": "Hide filters",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to show filters */
  "search.action.toggle-filters-aria-label_show": "Show filters",
  /**
  * A list of provided types (use `list` formatter preferably).
  */
  "search.document-type-list": "{{types, list}}",
  /**
  * In the context of a list of document types - no filtering selection has been done,
  * thus the default is "all types".
  */
  "search.document-type-list-all-types": "All types",
  /**
  * A list of provided types that has been truncated - more types are included but not displayed,
  * thus we need to indicate that there are more. Allows using pluralization suffixes,
  * eg `_one`, `_other` etc.
  */
  "search.document-type-list-truncated": "{{types, list}} +{{count}} more",
  /** Accessibility label for list displaying the available document types */
  "search.document-types-aria-label": "Document types",
  /** Label for when no document types matching the filter are found */
  "search.document-types-no-matches-found": "No matches for {{filter}}",
  /** Description for error when a filter cannot be displayed, describes that you should check the schema */
  "search.error.display-filter-description": "This may indicate invalid options defined in your schema.",
  /** Title for error when a filter cannot be displayed (mainly a developer-oriented error) */
  "search.error.display-filter-title": "An error occurred whilst displaying this filter.",
  /** Description for error when no valid asset source is found, describes that you should check the the current studio config */
  "search.error.no-valid-asset-source-check-config-description": "Please ensure it's enabled in your studio configuration file.",
  /** Description for error when no valid asset source is found, describes that only the default asset is supported */
  "search.error.no-valid-asset-source-only-default-description": "Currently, only the default asset source is supported.",
  /** Title for error when no valid asset sources found */
  "search.error.no-valid-asset-source-title": "No valid asset sources found.",
  /** Helpful description for when search returned an error that we are not able to describe in detail */
  "search.error.unspecified-error-help-description": "Please try again or check your connection",
  /** Title label for when search returned an error that we are not able to describe in detail */
  "search.error.unspecified-error-title": "Something went wrong while searching",
  /**
  * Label for "All fields", a label that appears above the list of available fields when filtering.
  * If one or more document type has been chosen as filter, this label is replaced with a group of
  * fields per selected document type
  */
  "search.filter-all-fields-header": "All fields",
  /** Label for the action of changing from one file to a different file in asset search filter */
  "search.filter-asset-change_file": "Change file",
  /** Label for the action of changing from one image to a different image in asset search filter */
  "search.filter-asset-change_image": "Change image",
  /** Label for the action of clearing the currently selected asset in an image/file filter */
  "search.filter-asset-clear": "Clear",
  /** Label for the action of selecting a file in asset search filter */
  "search.filter-asset-select_file": "Select file",
  /** Label for the action of selecting an image in asset search filter */
  "search.filter-asset-select_image": "Select image",
  /** Label for boolean filter - false */
  "search.filter-boolean-false": "False",
  /** Label for boolean filter - true */
  "search.filter-boolean-true": "True",
  /** Accessibility label for list that lets you filter fields by title, when adding a new filter in search */
  "search.filter-by-title-aria-label": "Filter by title",
  /** Accessibility label for date filter input */
  "search.filter-date-aria-label": "Date",
  /** Accessibility label for selecting end date on the date range search filter */
  "search.filter-date-range-end-date-aria-label": "End date",
  /** Accessibility label for selecting start date on the date range search filter */
  "search.filter-date-range-start-date-aria-label": "Start date",
  /** Accessibility label for selecting the unit (day/month/year) when adding "X days ago" search filter */
  "search.filter-date-unit-aria-label": "Select unit",
  /**
  * Label for "Days"/"Months"/"Years" when selecting it as unit in "X days ago" search filter.
  * Capitalized, as it would be listed in a dropdown.
  */
  "search.filter-date-unit_days": "Days",
  "search.filter-date-unit_months": "Months",
  "search.filter-date-unit_years": "Years",
  /** Accessibility label for the input value (days/months/years) when adding "X days ago" search filter */
  "search.filter-date-value-aria-label": "Unit value",
  /** Label for "field description" shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-description": "Field description",
  /** Label for "field name" shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-name": "Field name",
  /** Label for "Used in document types", a list of the document types a field appears in. Shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-used-in-document-types": "Used in document types",
  /** Label for when no fields/filters are found for the given term */
  "search.filter-no-matches-found": "No matches for {{filter}}",
  /** Placeholder value for maximum numeric value filter */
  "search.filter-number-max-value-placeholder": "Max value",
  /** Placeholder value for minimum numeric value filter */
  "search.filter-number-min-value-placeholder": "Min value",
  /** Placeholder value for the number filter */
  "search.filter-number-value-placeholder": "Value",
  /** Placeholder for the "Filter" input, when narrowing possible fields/filters */
  "search.filter-placeholder": "Filter",
  /** Label for the action of clearing the currently selected document in a reference filter */
  "search.filter-reference-clear": "Clear",
  /**
  * Label for "shared fields", a label that appears above a list of fields that all filtered types
  * have in common, when adding a new filter. For instance, if "book" and "employee" both have a
  * "title" field, this field would be listed under "shared fields".
  * */
  "search.filter-shared-fields-header": "Shared fields",
  /** Placeholder value for the string filter */
  "search.filter-string-value-placeholder": "Value",
  /** Label/placeholder prompting user to select one of the predefined, allowed values for a string field */
  "search.filter-string-value-select-predefined-value": "Select",
  /** Accessibility label for the "Filters" list, that is shown when using "Add filter" in search (singular) */
  "search.filters-aria-label_one": "Filter",
  /** Accessibility label for the "Filters" list, that is shown when using "Add filter" in search (plural) */
  "search.filters-aria-label_other": "Filters",
  /** Label for instructions on how to use the search - displayed when no recent searches are available */
  "search.instructions": "Use <ControlsIcon/> to refine your search",
  /** Helpful description for when no search results are found */
  "search.no-results-help-description": "Try another keyword or adjust your filters",
  /** Title label for when no search results are found */
  "search.no-results-title": "No results found",
  /**
  * Individual search operators.
  *
  * The `name` variant is the form we use when the user is building a query, and selecting from a
  * list of available operators for a field. Keep in mind that since the user knows what the field
  * represents, we do not need to contextualize too much, and that the user may not be a developer
  * eg prefer "quantity is" over "array has length". Additionally, (if applicable in language) use
  * lowercased names.
  *
  * The `description` variant is the form shown once the filter has enough information to apply,
  * and is shown in the list of applied filters. It is passed components that _should_ be used to
  * compose the filter string, and to format them correctly:
  *
  * `<Field/>` - eg "Bird species", "Category", "Date of birth"
  * `<Operator>operator text</Operator>` - eg "has ", "includes", "is"
  * `<Value>{{value}}</Value>` - eg "Hawk", "Sparrow", "Eagle"
  *
  * Where applicable, a `count` is passed, allowing you to pluralize where needed, by using
  * suffixes such as `_zero`, `_one`, `_other` etc.
  *
  * Prefer (reasonable) brevity since many filters may be applied. For instance:
  * `<Field/> has  <Value/>` may be better than
  * `<Field/> has less than or equal to <Value/>`
  **/
  /* Array should have a count the given filter value */
  "search.operator.array-count-equal.description_one": "<Field/> <Operator>has</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-equal.description_other": "<Field/> <Operator>has</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-equal.name": "quantity is",
  /* Array should have a count greater than given filter value */
  "search.operator.array-count-gt.description_one": "<Field/> <Operator>has ></Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-gt.description_other": "<Field/> <Operator>has ></Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-gt.name": "quantity greater than",
  /* Array should have a count greater than or equal to the given filter value */
  "search.operator.array-count-gte.description_one": "<Field/> <Operator>has </Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-gte.description_other": "<Field/> <Operator>has </Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-gte.name": "quantity greater than or equal to",
  /* Array should have a count less than given filter value */
  "search.operator.array-count-lt.description_one": "<Field/> <Operator>has <</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-lt.description_other": "<Field/> <Operator>has <</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-lt.name": "quantity less than",
  /* Array should have a count less than or equal to the given filter value */
  "search.operator.array-count-lte.description_one": "<Field/> <Operator>has </Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-lte.description_other": "<Field/> <Operator>has </Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-lte.name": "quantity less than or equal to",
  /* Array should have a count that is not equal to the given filter value */
  "search.operator.array-count-not-equal.description_one": "<Field/> <Operator>does not have</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-not-equal.description_other": "<Field/> <Operator>does not have</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-not-equal.name": "quantity is not",
  /**
  * Array should have a count within the range of given filter values.
  * Gets passed `{{from}}` and `{{to}}` values.
  **/
  "search.operator.array-count-range.description": "<Field/> <Operator>has between</Operator> <Value>{{from}}  {{to}} items</Value>",
  "search.operator.array-count-range.name": "quantity is between",
  /* Array should include the given value */
  "search.operator.array-list-includes.description": "<Field/> <Operator>includes</Operator> <Value>{{value}}</Value>",
  "search.operator.array-list-includes.name": "includes",
  /* Array should not include the given value */
  "search.operator.array-list-not-includes.description": "<Field/> <Operator>does not include</Operator> <Value>{{value}}</Value>",
  "search.operator.array-list-not-includes.name": "does not include",
  /* Array should include the given reference */
  "search.operator.array-reference-includes.description": "<Field/> <Operator>includes</Operator> <Value>{{value}}</Value>",
  "search.operator.array-reference-includes.name": "includes",
  /* Array should not include the given reference */
  "search.operator.array-reference-not-includes.description": "<Field/> <Operator>does not include</Operator> <Value>{{value}}</Value>",
  "search.operator.array-reference-not-includes.name": "does not include",
  /* Asset (file) should be the selected asset */
  "search.operator.asset-file-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-file-equal.name": "is",
  /* Asset (file) should not be the selected asset */
  "search.operator.asset-file-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-file-not-equal.name": "is not",
  /* Asset (image) should be the selected asset */
  "search.operator.asset-image-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-image-equal.name": "is",
  /* Asset (image) should not be the selected asset */
  "search.operator.asset-image-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-image-not-equal.name": "is not",
  /**
  * Boolean value should be the given filter value (true/false).
  * Context passed is `true` and `false`, allowing for more specific translations:
  * - `search.operator.boolean-equal.description_true`
  * - `search.operator.boolean-equal.description_false`
  */
  "search.operator.boolean-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.boolean-equal.name": "is",
  /* Date should be after (later than) given filter value */
  "search.operator.date-after.description": "<Field/> <Operator>is after</Operator> <Value>{{value}}</Value>",
  "search.operator.date-after.name": "after",
  /* Date should be before (earlier than) given filter value */
  "search.operator.date-before.description": "<Field/> <Operator>is before</Operator> <Value>{{value}}</Value>",
  "search.operator.date-before.name": "before",
  /* Date should be the given filter value */
  "search.operator.date-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.date-equal.name": "is",
  /* Date should be within the given filter value range (eg "within the last X days") */
  "search.operator.date-last.description": "<Field/> <Operator>is in the last</Operator> <Value>{{value}}</Value>",
  "search.operator.date-last.name": "last",
  /* Date should not be the given filter value */
  "search.operator.date-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.date-not-equal.name": "is not",
  /* Date should be within the range of given filter values */
  "search.operator.date-range.description": "<Field/> <Operator>is between</Operator> <Value/>",
  "search.operator.date-range.name": "is between",
  /* Date and time should be after (later than) given filter value */
  "search.operator.date-time-after.description": "<Field/> <Operator>is after</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-after.name": "after",
  /* Date and time should be before (earlier than) given filter value */
  "search.operator.date-time-before.description": "<Field/> <Operator>is before</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-before.name": "before",
  /* Date and time should be the given filter value */
  "search.operator.date-time-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-equal.name": "is",
  /* Date and time should be within the given filter value range (eg "within the last X days") */
  "search.operator.date-time-last.description": "<Field/> <Operator>is in the last</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-last.name": "last",
  /* Date and time should not be the given filter value */
  "search.operator.date-time-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-not-equal.name": "is not",
  /* Date and time should be within the range of given filter values */
  "search.operator.date-time-range.description": "<Field/> <Operator>is between</Operator> <Value/>",
  "search.operator.date-time-range.name": "is between",
  /* Value should be defined */
  "search.operator.defined.description": "<Field/> <Operator>is</Operator> <Value>not empty</Value>",
  "search.operator.defined.name": "not empty",
  /* Value should not be defined */
  "search.operator.not-defined.description": "<Field/> <Operator>is</Operator> <Value>empty</Value>",
  "search.operator.not-defined.name": "empty",
  /* Number should be the given filter value */
  "search.operator.number-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.number-equal.name": "is",
  /* Number should be greater than given filter value */
  "search.operator.number-gt.description": "<Field/> <Operator>></Operator> <Value>{{value}}</Value>",
  "search.operator.number-gt.name": "greater than",
  /* Number should be greater than or the given filter value */
  "search.operator.number-gte.description": "<Field/> <Operator></Operator> <Value>{{value}}</Value>",
  "search.operator.number-gte.name": "greater than or equal to",
  /* Number should be less than given filter value */
  "search.operator.number-lt.description": "<Field/> <Operator><</Operator> <Value>{{value}}</Value>",
  "search.operator.number-lt.name": "less than",
  /* Number should be less than or the given filter value */
  "search.operator.number-lte.description": "<Field/> <Operator></Operator> <Value>{{value}}</Value>",
  "search.operator.number-lte.name": "less than or equal to",
  /* Number should not be the given filter value */
  "search.operator.number-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.number-not-equal.name": "is not",
  /* Number should be within the range of given filter values */
  "search.operator.number-range.description": "<Field/> <Operator>is between</Operator> <Value>{{from}}  {{to}}</Value>",
  "search.operator.number-range.name": "is between",
  /* Portable Text should contain the given filter value */
  "search.operator.portable-text-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-contains.name": "contains",
  /* Portable Text should be the given filter value */
  "search.operator.portable-text-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-equal.name": "is",
  /* Portable Text should not contain the given filter value */
  "search.operator.portable-text-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-not-contains.name": "does not contain",
  /* Portable Text should not be the given filter value */
  "search.operator.portable-text-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-not-equal.name": "is not",
  /* References the given asset (file) */
  "search.operator.reference-asset-file.description": "<Field/> <Operator></Operator> <Value>{{value}}</Value>",
  "search.operator.reference-asset-file.name": "file",
  /* References the given asset (image) */
  "search.operator.reference-asset-image.description": "<Field/> <Operator></Operator> <Value>{{value}}</Value>",
  "search.operator.reference-asset-image.name": "image",
  /* References the given document */
  "search.operator.reference-document.description": "<Field/> <Operator></Operator> <Value>{{value}}</Value>",
  "search.operator.reference-document.name": "document",
  /* Reference should be the given document */
  "search.operator.reference-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-equal.name": "is",
  /* Reference should not be the given document */
  "search.operator.reference-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-not-equal.name": "is not",
  /* Slug contains the given value */
  "search.operator.slug-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-contains.name": "contains",
  /* Slug equals the given filter value */
  "search.operator.slug-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-equal.name": "is",
  /* Slug does not contain the given value */
  "search.operator.slug-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-not-contains.name": "does not contain",
  /* Slug does not equal the given filter value */
  "search.operator.slug-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-not-equal.name": "is not",
  /* String contains the given filter value */
  "search.operator.string-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.string-contains.name": "contains",
  /* String equals the given filter value */
  "search.operator.string-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.string-equal.name": "is",
  /* String equals one of the predefined allowed values */
  "search.operator.string-list-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.string-list-equal.name": "is",
  /* String does not equal one of the predefined allowed values */
  "search.operator.string-list-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.string-list-not-equal.name": "is not",
  /* String does not contain the given filter value */
  "search.operator.string-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.string-not-contains.name": "does not contain",
  /* String does not equal the given filter value */
  "search.operator.string-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.string-not-equal.name": "is not",
  /** Label for the "Best match" search ordering type */
  "search.ordering.best-match-label": "Best match",
  /** Label for the "Created: Oldest first" search ordering type */
  "search.ordering.created-ascending-label": "Created: Oldest first",
  /** Label for the "Created: Newest first" search ordering type */
  "search.ordering.created-descending-label": "Created: Newest first",
  /** Label for the "Updated: Oldest first" search ordering type */
  "search.ordering.updated-ascending-label": "Updated: Oldest first",
  /** Label for the "Updated: Newest first" search ordering type */
  "search.ordering.updated-descending-label": "Updated: Newest first",
  /** Placeholder text for the global search input field */
  "search.placeholder": "Search",
  /** Accessibility label for the recent searches section, shown when no valid search terms has been given */
  "search.recent-searches-aria-label": "Recent searches",
  /** Label/heading shown for the recent searches section */
  "search.recent-searches-label": "Recent searches",
  /** Accessibility label for the search results section, shown when the user has typed valid terms */
  "search.search-results-aria-label": "Search results",
  /** Description for error when the timeline for the given document can't be loaded */
  "timeline.error.load-document-changes-description": "Document history transactions have not been affected.",
  /** Title for error when the timeline for the given document can't be loaded */
  "timeline.error.load-document-changes-title": "An error occurred whilst retrieving document changes.",
  /** Error description for when the document doesn't have history */
  "timeline.error.no-document-history-description": "When changing the content of the document, the document versions will appear in this menu.",
  /** Error title for when the document doesn't have history */
  "timeline.error.no-document-history-title": "No document history",
  /** Error prompt when revision cannot be loaded */
  "timeline.error.unable-to-load-revision": "Unable to load revision",
  /** Label for when the timeline item is the latest in the history */
  "timeline.latest": "Latest",
  /** Label for latest version for timeline menu dropdown */
  "timeline.latest-version": "Latest version",
  /** The aria-label for the list of revisions in the timeline */
  "timeline.list.aria-label": "Document revisions",
  /** Label for loading history */
  "timeline.loading-history": "Loading history",
  /** Label shown in review changes timeline when a document has been created */
  "timeline.operation.created": "Created",
  /** Label shown in review changes timeline when a document was initially created */
  "timeline.operation.created-initial": "Created",
  /** Label shown in review changes timeline when a document was initially created, with a timestamp */
  "timeline.operation.created-initial_timestamp": "Created: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been created, with a timestamp */
  "timeline.operation.created_timestamp": "Created: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been deleted */
  "timeline.operation.deleted": "Deleted",
  /** Label shown in review changes timeline when a document has been deleted, with a timestamp */
  "timeline.operation.deleted_timestamp": "Deleted: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a draft has been discarded */
  "timeline.operation.draft-discarded": "Discarded draft",
  /** Label shown in review changes timeline when a draft has been discarded, with a timestamp */
  "timeline.operation.draft-discarded_timestamp": "Discarded draft: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a draft has been edited */
  "timeline.operation.edited-draft": "Edited",
  /** Label shown in review changes timeline when a draft has been edited, with a timestamp */
  "timeline.operation.edited-draft_timestamp": "Edited: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been edited live */
  "timeline.operation.edited-live": "Live edited",
  /** Label shown in review changes timeline when a document has been edited live, with a timestamp */
  "timeline.operation.edited-live_timestamp": "Live edited: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document was published */
  "timeline.operation.published": "Published",
  /** Label shown in review changes timeline when a document was published, with a timestamp */
  "timeline.operation.published_timestamp": "Published: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document was unpublished */
  "timeline.operation.unpublished": "Unpublished",
  /** Label shown in review changes timeline when a document was unpublished, with a timestamp */
  "timeline.operation.unpublished_timestamp": "Unpublished: {{timestamp, datetime}}",
  /**
  * Label for determining since which version the changes for timeline menu dropdown are showing.
  * Receives the time label as a parameter (`timestamp`).
  */
  "timeline.since": "Since: {{timestamp, datetime}}",
  /** Label for missing change version for timeline menu dropdown are showing */
  "timeline.since-version-missing": "Since: unknown version",
  /** Label for action to invite members to the current sanity project */
  "user-menu.action.invite-members": "Invite members",
  /** Accessibility label for action to invite members to the current sanity project */
  "user-menu.action.invite-members-aria-label": "Invite members",
  /** Label for action to manage the current sanity project */
  "user-menu.action.manage-project": "Manage project",
  /** Accessibility label for the action to manage the current project */
  "user-menu.action.manage-project-aria-label": "Manage project",
  /** Label for action to sign out of the current sanity project */
  "user-menu.action.sign-out": "Sign out",
  /** Title for appearance section for the current studio (dark / light / system scheme) */
  "user-menu.appearance-title": "Appearance",
  /** Label for close menu button for user menu */
  "user-menu.close-menu": "Close menu",
  /** Description for using the "dark theme" in the appearance user menu */
  "user-menu.color-scheme.dark-description": "Use dark appearance",
  /** Title for using the "dark theme" in the appearance user menu */
  "user-menu.color-scheme.dark-title": "Dark",
  /** Description for using the "light theme" in the appearance user menu */
  "user-menu.color-scheme.light-description": "Use light appearance",
  /** Title for using the "light theme" in the appearance user menu */
  "user-menu.color-scheme.light-title": "Light",
  /** Description for using "system apparence" in the appearance user menu */
  "user-menu.color-scheme.system-description": "Use system appearance",
  /** Title for using system apparence in the appearance user menu */
  "user-menu.color-scheme.system-title": "System",
  /** Title for locale section for the current studio */
  "user-menu.locale-title": "Language",
  /** Label for tooltip to show which provider the currently logged in user is using */
  "user-menu.login-provider": "Signed in with {{providerTitle}}",
  /**
  * Label for action to add a workspace (currently a developer-oriented action, as this will
  * lead to the documentation on workspace configuration)
  */
  "workspaces.action.add-workspace": "Add workspace",
  /**
  * Label for action to choose a different workspace, in the case where you are not logged in,
  * have selected a workspace, and are faced with the authentication options for the selected
  * workspace. In other words, label for the action shown when you have reconsidered which
  * workspace to authenticate in.
  */
  "workspaces.action.choose-another-workspace": "Choose another workspace",
  /** Label for heading that indicates that you can choose your workspace */
  "workspaces.choose-your-workspace-label": "Choose your workspace",
  /** Label for the workspace menu */
  "workspaces.select-workspace-aria-label": "Select workspace",
  /** Button label for opening the workspace switcher */
  "workspaces.select-workspace-label": "Select workspace",
  /** Title for Workplaces dropdown menu */
  "workspaces.title": "Workspaces"
});
var studioDefaultLocaleResources = defineLocaleResourceBundle({ locale: "en-US", namespace: studioLocaleNamespace, resources: studioLocaleStrings });
var validationLocaleStrings = defineLocalesResources("validation", {
  /** Array must have exactly "$wantedLength" items, but has more/less */
  "array.exact-length": "Must have exactly {{wantedLength}} items",
  /** Portable Text array must have exactly "$wantedLength" blocks, but has more/less */
  "array.exact-length_blocks": "Must have exactly {{wantedLength}} blocks",
  /** Array item is a duplicate, but array wants only unique items */
  "array.item-duplicate": "Can't be a duplicate",
  /** Array has more than the maximum of "$maxLength" items */
  "array.maximum-length": "Must have at most {{maxLength}} items",
  /** Portable Text array has more than the maximum of "$maxLength" items */
  "array.maximum-length_blocks": "Must have at most {{maxLength}} blocks",
  /** Array has less than the minimum of "$minLength" items */
  "array.minimum-length": "Must have at least {{minLength}} items",
  /** Portable Text array has less than the minimum of "$minLength" blocks */
  "array.minimum-length_blocks": "Must have at least {{minLength}} blocks",
  /** Date is not valid or not in the correct format (ISO-8601) */
  "date.invalid-format": "Must be a valid ISO-8601 formatted date string",
  /** Date is later than the given maximum date "$maxDate" */
  "date.maximum": "Must be at or before {{maxDate}}",
  /** Date is earlier than the given minimum date "$minDate" */
  "date.minimum": "Must be at or after {{minDate}}",
  /** A value of incorrect type is found, eg found `number` instead of `string` */
  "generic.incorrect-type": 'Expected type "{{expectedType}}", got "{{actualType}}"',
  /** Value is not one of the values specifically allowed */
  "generic.not-allowed": "Value did not match any allowed values",
  /** Value "$givenValue" is not one of the values specifically allowed */
  "generic.not-allowed_hint": 'Value "{{hint}}" did not match any allowed values',
  /** A value is expected, but none is provided */
  "generic.required": "Required",
  /** Number is less than the given minimum threshold value "$threshold" */
  "number.greater-than": "Must be greater than {{threshold}}",
  /** Number is greater than the given maximum threshold value "$threshold" */
  "number.less-than": "Must be less than {{threshold}}",
  /** Number is higher than the given maximum value "$maxNumber" */
  "number.maximum": "Must be lower than or equal to {{maxNumber}}",
  /** Number has more precision (decimals) than the allowed "$limit" */
  "number.maximum-precision": "Max precision is {{limit}}",
  /** Number is lower than the given minimum value "$minNumber" */
  "number.minimum": "Must be greater than or equal to {{minNumber}}",
  /** Number is not an integer ("whole number") */
  "number.non-integer": "Must be an integer",
  /** Object is missing a reference to an asset document in its `asset` field */
  "object.asset-required": "Asset is required",
  /** Object is missing a reference to a file asset document in its `asset` field */
  "object.asset-required_file": "File is required",
  /** Object is missing a reference to an image asset document in its `asset` field */
  "object.asset-required_image": "Image is required",
  /** Object is not a reference to a document (eg `{_ref: 'documentId'}`) */
  "object.not-reference": "Must be a reference to a document",
  /** Object references a document which is not published */
  "object.reference-not-published": "Referenced document must be published",
  /** Accessibility label for closing the validation panel */
  "panel.close-button-aria-label": "Close validation",
  /** Message shown when the validation panel is opened but there are no errors/warnings */
  "panel.no-errors-message": "No validation errors",
  /** Title for the actual "Validation" panel/feature */
  "panel.title": "Validation",
  /** Slug is an object, but is missing a `current` string property */
  "slug.missing-current": "Slug must have a value",
  /** Slug is not an object (eg `{current: 'some-slug'}`) */
  "slug.not-object": "Slug must be an object",
  /** Slug is already in use somewhere else, but needs to be unique */
  "slug.not-unique": "Slug is already in use",
  /** String is not a valid email address */
  "string.email": "Must be a valid email address",
  /** String has a different character length than the exact number "$wantedLength" */
  "string.exact-length": "Must be exactly {{wantedLength}} characters long",
  /** String contains characters that are not in lowercase  */
  "string.lowercase": "Must be all lowercase characters",
  /** String is longer than the limit of "$maxLength" characters */
  "string.maximum-length": "Must be at most {{maxLength}} characters long",
  /** String is shorter than the limit of "$minLength" characters */
  "string.minimum-length": "Must be at least {{minLength}} characters long",
  /** String does not match the given regular expression, but should */
  "string.regex-does-not-match": 'Does not match "{{name}}"-pattern',
  /** String matches the given regular expression, but should not */
  "string.regex-match": 'Should not match "{{name}}"-pattern',
  /** String contains characters that are not in uppercase */
  "string.uppercase": "Must be all uppercase characters",
  /** String contains a protocol/scheme that is not allowed, eg (`ftp`, `mailto`) */
  "string.url.disallowed-scheme": "Does not match allowed protocols/schemes",
  /** String contains a URL with a username or password specified before the host */
  "string.url.includes-credentials": "Username/password not allowed",
  /** String is not a valid URL */
  "string.url.invalid": "Not a valid URL",
  /** String is not an absolute URL (eg it is missing a protocol/host) */
  "string.url.not-absolute": "Relative URLs are not allowed",
  /** String is not a relative URL (eg it contains a protocol/host) */
  "string.url.not-relative": "Only relative URLs are allowed"
});
var validationLocaleResources = defineLocaleResourceBundle({ locale: "en-US", namespace: validationLocaleNamespace, resources: validationLocaleStrings });
var usEnglishLocale = defineLocale({ id: "en-US", title: "English (US)", bundles: [studioDefaultLocaleResources, validationLocaleResources] });
var defaultLocale = usEnglishLocale;
var shouldEscape = typeof window === "undefined" || typeof document === "undefined";
var fallbackLocales = [{ id: defaultLocale.id, title: defaultLocale.title }];
var getFallbackLocaleSource = (0, import_memoize.default)(function getFallbackLocaleSource2() {
  const i18n = getFallbackI18nInstance();
  i18n.init();
  return { currentLocale: defaultLocale.id, locales: fallbackLocales, loadNamespaces: i18n.loadNamespaces, t: i18n.t };
});
function getFallbackI18nInstance() {
  var _a4;
  const staticResources = { [defaultLocale.id]: {} };
  const staticBundles = ((_a4 = usEnglishLocale.bundles) == null ? void 0 : _a4.filter(isStaticResourceBundle)) || [];
  const namespaces2 = /* @__PURE__ */ new Set();
  for (const bundle of staticBundles) {
    staticResources[defaultLocale.id][bundle.namespace] = bundle.resources;
    namespaces2.add(bundle.namespace);
  }
  return createInstance({ ns: Array.from(namespaces2), defaultNS: studioLocaleNamespace, initImmediate: true, partialBundledLanguages: true, fallbackLng: defaultLocale.id, lng: defaultLocale.id, supportedLngs: [defaultLocale.id], debug: false, load: "currentOnly", resources: staticResources, interpolation: {
    // If we're in a browser, assume this is running inside of the studio, eg a React app,
    // and that values returned will be escaped by the framework (eg React) automatically.
    escapeValue: shouldEscape
  } });
}
var requestIdleCallbackShim = function requestIdleCallbackShim2(callback, options) {
  const start = Date.now();
  return window.setTimeout(() => {
    callback({ didTimeout: false, timeRemaining() {
      return Math.max(0, Date.now() - start);
    } });
  }, 0);
};
var cancelIdleCallbackShim = function cancelIdleCallbackShim2(handle) {
  return window.clearTimeout(handle);
};
var win = typeof window === "undefined" ? void 0 : window;
var requestIdleCallback$1 = (win == null ? void 0 : win.requestIdleCallback) || requestIdleCallbackShim;
var cancelIdleCallback$1 = (win == null ? void 0 : win.cancelIdleCallback) || cancelIdleCallbackShim;
var memoizedWarnOnArraySlug = (0, import_memoize.default)(warnOnArraySlug);
function getDocumentIds(id4) {
  const isDraft2 = id4.indexOf("drafts.") === 0;
  return { published: isDraft2 ? id4.slice("drafts.".length) : id4, draft: isDraft2 ? id4 : "drafts.".concat(id4) };
}
function serializePath(path2) {
  return path2.reduce((target, part, i) => {
    const isIndex = typeof part === "number";
    const isKey = isKeyedObject(part);
    const separator = i === 0 ? "" : ".";
    const add = isIndex || isKey ? "[]" : "".concat(separator).concat(part);
    return "".concat(target).concat(add);
  }, "");
}
var defaultIsUnique = (slug3, context) => {
  const { getClient, document: document2, path: path2, type } = context;
  const schemaOptions = type == null ? void 0 : type.options;
  if (!document2) {
    throw new Error("`document` was not provided in validation context.");
  }
  if (!path2) {
    throw new Error("`path` was not provided in validation context.");
  }
  const disableArrayWarning = (schemaOptions == null ? void 0 : schemaOptions.disableArrayWarning) || false;
  const { published, draft } = getDocumentIds(document2._id);
  const docType = document2._type;
  const atPath = serializePath(path2.concat("current"));
  if (!disableArrayWarning && atPath.includes("[]")) {
    memoizedWarnOnArraySlug(serializePath(path2));
  }
  const constraints = ["_type == $docType", "!(_id in [$draft, $published])", "".concat(atPath, " == $slug")].join(" && ");
  return getClient({ apiVersion: "2022-09-09" }).fetch("!defined(*[".concat(constraints, "][0]._id)"), { docType, draft, published, slug: slug3 }, { tag: "validation.slug-is-unique" });
};
function warnOnArraySlug(serializedPath) {
  console.warn(["Slug field at path ".concat(serializedPath, " is within an array and cannot be automatically checked for uniqueness"), 'If you need to check for uniqueness, provide your own "isUnique" method', "To disable this message, set `disableArrayWarning: true` on the slug `options` field"].join("\n"));
}
var slugValidator = async (value, context) => {
  var _a4;
  if (!value) {
    return true;
  }
  const { i18n } = context;
  if (typeof value !== "object" || Array.isArray(value)) {
    return i18n.t("validation:slug.not-object");
  }
  if (!isSlug(value) || value.current.trim().length === 0) {
    return i18n.t("validation:slug.missing-current");
  }
  const options = (_a4 = context == null ? void 0 : context.type) == null ? void 0 : _a4.options;
  const isUnique = (options == null ? void 0 : options.isUnique) || defaultIsUnique;
  const slugContext = { ...context, parent: context.parent, type: context.type, defaultIsUnique };
  const wasUnique = await isUnique(value.current, slugContext);
  if (wasUnique) {
    return true;
  }
  return i18n.t("validation:slug.not-unique", { slug: value.current });
};
var ruleConstraintTypes = { array: true, boolean: true, date: true, number: true, object: true, string: true };
var isRuleConstraint = (typeString2) => typeString2 in ruleConstraintTypes;
function getTypeChain$1(type, visited) {
  if (!type)
    return [];
  if (visited.has(type))
    return [];
  visited.add(type);
  const next = type.type ? getTypeChain$1(type.type, visited) : [];
  return [...next, type];
}
function baseRuleReducer(inputRule, type) {
  let baseRule = inputRule;
  if (isRuleConstraint(type.jsonType)) {
    baseRule = baseRule.type(type.jsonType);
  }
  const typeOptionsList = (
    // if type.options is truthy
    (type == null ? void 0 : type.options) && // and type.options is an object (non-null from the previous)
    typeof type.options === "object" && // and if `list` is in options
    "list" in type.options && // then finally access the list
    type.options.list
  );
  if (Array.isArray(typeOptionsList)) {
    baseRule = baseRule.valid(typeOptionsList.map((option) => extractValueFromListOption(option, type)));
  }
  if (type.name === "datetime")
    return baseRule.type("Date");
  if (type.name === "date")
    return baseRule.type("Date");
  if (type.name === "url")
    return baseRule.uri();
  if (type.name === "slug")
    return baseRule.custom(slugValidator);
  if (type.name === "reference")
    return baseRule.reference();
  if (type.name === "email")
    return baseRule.email();
  return baseRule;
}
function hasValueField(typeDef) {
  if (!typeDef)
    return false;
  if (!("fields" in typeDef) && typeDef.type)
    return hasValueField(typeDef.type);
  if (!("fields" in typeDef))
    return false;
  if (!Array.isArray(typeDef.fields))
    return false;
  return typeDef.fields.some((field) => field.name === "value");
}
function extractValueFromListOption(option, typeDef) {
  if (typeDef.jsonType === "object" && hasValueField(typeDef))
    return option;
  return option.value === void 0 ? option : option.value;
}
function normalizeValidationRules(typeDef) {
  if (!typeDef) {
    return [];
  }
  const validation2 = typeDef.validation;
  if (Array.isArray(validation2)) {
    return validation2.flatMap((i) => normalizeValidationRules({ ...typeDef, validation: i }));
  }
  if (validation2 instanceof Rule) {
    return [validation2];
  }
  const baseRule = (
    // using an object + Object.values to de-dupe the type chain by type name
    Object.values(getTypeChain$1(typeDef, /* @__PURE__ */ new Set()).reduce((acc, type) => {
      acc[type.name] = type;
      return acc;
    }, {})).reduce(baseRuleReducer, new Rule(typeDef))
  );
  if (!validation2) {
    return [baseRule];
  }
  return normalizeValidationRules({ ...typeDef, validation: validation2(baseRule) });
}
var isRecord$2 = (maybeRecord) => typeof maybeRecord === "object" && maybeRecord !== null && !Array.isArray(maybeRecord);
var isNonNullable$1 = (value) => value !== null && value !== void 0;
function resolveTypeForArrayItem(item, candidates) {
  if (candidates.length === 1)
    return candidates[0];
  const itemType = isTypedObject(item) && item._type;
  const primitive = item === void 0 || item === null || !itemType && typeString(item).toLowerCase();
  if (primitive && primitive !== "object") {
    return candidates.find((candidate) => candidate.jsonType === primitive);
  }
  return candidates.find((candidate) => {
    var _a4;
    return ((_a4 = candidate.type) == null ? void 0 : _a4.name) === itemType;
  }) || candidates.find((candidate) => candidate.name === itemType) || candidates.find((candidate) => candidate.name === "object" && primitive === "object");
}
var EMPTY_MARKERS = [];
function validateDocumentObservable(getClient, doc, schema, context) {
  const documentType = schema.get(doc._type);
  if (!documentType) {
    console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
    return of(EMPTY_MARKERS);
  }
  const i18n = (context == null ? void 0 : context.i18n) || getFallbackLocaleSource();
  const validationOptions = { getClient, schema, parent: void 0, value: doc, path: [], document: doc, type: documentType, i18n, getDocumentExists: context == null ? void 0 : context.getDocumentExists };
  return from(i18n.loadNamespaces(["validation"])).pipe(switchMap(() => validateItemObservable(validationOptions)), catchError((err) => {
    console.error(err);
    return of([{ type: "validation", level: "error", path: [], item: new ValidationError(err == null ? void 0 : err.message) }]);
  }));
}
function validateItemObservable(_ref59) {
  let { value, type, path: path2 = [], parent, ...restOfContext } = _ref59;
  const rules = normalizeValidationRules(type);
  const selfChecks = rules.map((rule) => defer(() => rule.validate(value, { ...restOfContext, parent, path: path2, type })));
  let nestedChecks = [];
  const selfIsRequired = rules.some((rule) => rule.isRequired());
  const shouldRunNestedObjectValidation = (
    // run nested validation for objects
    (type == null ? void 0 : type.jsonType) === "object" && // if the value is truthy
    (!!value || // or
    // (the value is null or undefined) and the top-level value is required
    (value === null || value === void 0) && selfIsRequired)
  );
  if (shouldRunNestedObjectValidation) {
    const fieldTypes = type.fields.reduce((acc, field) => {
      acc[field.name] = field.type;
      return acc;
    }, {});
    nestedChecks = nestedChecks.concat(rules.map((rule) => rule._fieldRules).filter(isNonNullable$1).flatMap((fieldResults) => Object.entries(fieldResults)).flatMap((_ref60) => {
      let [name, validation2] = _ref60;
      const fieldType = fieldTypes[name];
      return normalizeValidationRules({ ...fieldType, validation: validation2 }).map((subRule) => {
        const nestedValue = isRecord$2(value) ? value[name] : void 0;
        return defer(() => subRule.validate(nestedValue, { ...restOfContext, parent: value, path: path2.concat(name), type: fieldType }));
      });
    }));
    nestedChecks = nestedChecks.concat(type.fields.map((field) => validateItemObservable({ ...restOfContext, parent: value, value: isRecord$2(value) ? value[field.name] : void 0, path: path2.concat(field.name), type: field.type })));
  }
  const shouldRunNestedValidationForArrays = (type == null ? void 0 : type.jsonType) === "array" && Array.isArray(value);
  if (shouldRunNestedValidationForArrays) {
    nestedChecks = nestedChecks.concat(value.map((item, index) => validateItemObservable({ ...restOfContext, parent: value, value: item, path: path2.concat(isKeyedObject(item) ? { _key: item._key } : index), type: resolveTypeForArrayItem(item, type.of) })));
  }
  return defer(() => merge([...selfChecks, ...nestedChecks])).pipe(mergeMap((validateNode) => concat(idle(), validateNode), 40), mergeAll(), toArray(), map(import_flatten5.default), map((results) => {
    if (rules.some((rule) => rule._fieldRules)) {
      return (0, import_uniqBy2.default)(results, (rule) => JSON.stringify(rule));
    }
    return results;
  }));
}
function idle(timeout) {
  return new Observable((observer) => {
    const handle = requestIdleCallback$1(() => {
      observer.complete();
    }, timeout ? { timeout } : void 0);
    return () => cancelIdleCallback$1(handle);
  });
}
function inferFromSchemaType(typeDef) {
  traverse(typeDef, /* @__PURE__ */ new Set());
  return typeDef;
}
function traverse(typeDef, visited) {
  if (visited.has(typeDef)) {
    return;
  }
  visited.add(typeDef);
  typeDef.validation = normalizeValidationRules(typeDef);
  if ("fields" in typeDef) {
    for (const field of typeDef.fields) {
      traverse(field.type, visited);
    }
  }
  if ("of" in typeDef) {
    for (const candidate of typeDef.of) {
      traverse(candidate, visited);
    }
  }
  if (typeDef.annotations) {
    for (const annotation of typeDef.annotations) {
      traverse(annotation, visited);
    }
  }
}
function inferFromSchema(schema) {
  const typeNames = schema.getTypeNames();
  typeNames.forEach((typeName) => {
    const schemaType = schema.get(typeName);
    if (schemaType) {
      inferFromSchemaType(schemaType);
    }
  });
  return schema;
}
var slug2 = { title: "Slug", name: "slug", type: "object", fields: [{ name: "current", title: "Current slug", type: "string" }, {
  // The source field is deprecated/unused, but leaving it included and hidden
  // to prevent rendering "Unknown field" warnings on legacy data
  name: "source",
  title: "Source field",
  type: "string",
  hidden: true
}] };
var geopoint = { title: "Geographical Point", name: "geopoint", type: "object", fields: [{ name: "lat", type: "number", title: "Latitude" }, { name: "lng", type: "number", title: "Longitude" }, { name: "alt", type: "number", title: "Altitude" }] };
var imageCrop = { name: "sanity.imageCrop", title: "Image crop", type: "object", fields: [{ name: "top", type: "number" }, { name: "bottom", type: "number" }, { name: "left", type: "number" }, { name: "right", type: "number" }] };
var imageHotspot = { name: "sanity.imageHotspot", title: "Image hotspot", type: "object", fields: [{ name: "x", type: "number" }, { name: "y", type: "number" }, { name: "height", type: "number" }, { name: "width", type: "number" }] };
var assetSourceData = { name: "sanity.assetSourceData", title: "Asset Source Data", type: "object", fields: [{ name: "name", title: "Source name", description: "A canonical name for the source this asset is originating from", type: "string" }, { name: "id", title: "Asset Source ID", description: "The unique ID for the asset within the originating source so you can programatically find back to it", type: "string" }, { name: "url", title: "Asset information URL", description: "A URL to find more information about this asset in the originating source", type: "string" }] };
var imageAsset = { name: "sanity.imageAsset", title: "Image", type: "document", fieldsets: [{ name: "system", title: "System fields", description: "These fields are managed by the system and not editable" }], fields: [{ name: "originalFilename", type: "string", title: "Original file name", readOnly: true }, { name: "label", type: "string", title: "Label" }, { name: "title", type: "string", title: "Title" }, { name: "description", type: "string", title: "Description" }, { name: "altText", type: "string", title: "Alternative text" }, { name: "sha1hash", type: "string", title: "SHA1 hash", readOnly: true, fieldset: "system" }, { name: "extension", type: "string", readOnly: true, title: "File extension", fieldset: "system" }, { name: "mimeType", type: "string", readOnly: true, title: "Mime type", fieldset: "system" }, { name: "size", type: "number", title: "File size in bytes", readOnly: true, fieldset: "system" }, { name: "assetId", type: "string", title: "Asset ID", readOnly: true, fieldset: "system" }, { name: "uploadId", type: "string", readOnly: true, hidden: true, fieldset: "system" }, { name: "path", type: "string", title: "Path", readOnly: true, fieldset: "system" }, { name: "url", type: "string", title: "Url", readOnly: true, fieldset: "system" }, { name: "metadata", type: "sanity.imageMetadata", title: "Metadata" }, { name: "source", type: "sanity.assetSourceData", title: "Source", readOnly: true, fieldset: "system" }], preview: { select: { id: "_id", title: "originalFilename", mimeType: "mimeType", size: "size" }, prepare(doc) {
  return { title: doc.title || typeof doc.path === "string" && doc.path.split("/").slice(-1)[0], media: { asset: { _ref: doc.id } }, subtitle: "".concat(doc.mimeType, " (").concat((Number(doc.size) / 1024 / 1024).toFixed(2), " MB)") };
} }, orderings: [{ title: "File size", name: "fileSizeDesc", by: [{ field: "size", direction: "desc" }] }] };
var imagePalette = { name: "sanity.imagePalette", title: "Image palette", type: "object", fields: [{ name: "darkMuted", type: "sanity.imagePaletteSwatch", title: "Dark Muted" }, { name: "lightVibrant", type: "sanity.imagePaletteSwatch", title: "Light Vibrant" }, { name: "darkVibrant", type: "sanity.imagePaletteSwatch", title: "Dark Vibrant" }, { name: "vibrant", type: "sanity.imagePaletteSwatch", title: "Vibrant" }, { name: "dominant", type: "sanity.imagePaletteSwatch", title: "Dominant" }, { name: "lightMuted", type: "sanity.imagePaletteSwatch", title: "Light Muted" }, { name: "muted", type: "sanity.imagePaletteSwatch", title: "Muted" }] };
var imagePaletteSwatch = { name: "sanity.imagePaletteSwatch", title: "Image palette swatch", type: "object", fields: [{ name: "background", type: "string", title: "Background", readOnly: true }, { name: "foreground", type: "string", title: "Foreground", readOnly: true }, { name: "population", type: "number", title: "Population", readOnly: true }, { name: "title", type: "string", title: "String", readOnly: true }] };
var imageDimensions = { name: "sanity.imageDimensions", type: "object", title: "Image dimensions", fields: [{ name: "height", type: "number", title: "Height", readOnly: true }, { name: "width", type: "number", title: "Width", readOnly: true }, { name: "aspectRatio", type: "number", title: "Aspect ratio", readOnly: true }] };
var imageMetadata = { name: "sanity.imageMetadata", title: "Image metadata", type: "object", fieldsets: [{ name: "extra", title: "Extra metadata", options: { collapsable: true } }], fields: [{ name: "location", type: "geopoint" }, { name: "dimensions", title: "Dimensions", type: "sanity.imageDimensions", fieldset: "extra" }, { name: "palette", type: "sanity.imagePalette", title: "Palette", fieldset: "extra" }, { name: "lqip", title: "LQIP (Low-Quality Image Placeholder)", type: "string", readOnly: true }, { name: "blurHash", title: "BlurHash", type: "string", readOnly: true }, { name: "hasAlpha", title: "Has alpha channel", type: "boolean", readOnly: true }, { name: "isOpaque", title: "Is opaque", type: "boolean", readOnly: true }] };
var fileAsset = { name: "sanity.fileAsset", title: "File", type: "document", fieldsets: [{ name: "system", title: "System fields", description: "These fields are managed by the system and not editable" }], fields: [{ name: "originalFilename", type: "string", title: "Original file name", readOnly: true }, { name: "label", type: "string", title: "Label" }, { name: "title", type: "string", title: "Title" }, { name: "description", type: "string", title: "Description" }, { name: "altText", type: "string", title: "Alternative text" }, { name: "sha1hash", type: "string", title: "SHA1 hash", readOnly: true, fieldset: "system" }, { name: "extension", type: "string", title: "File extension", readOnly: true, fieldset: "system" }, { name: "mimeType", type: "string", title: "Mime type", readOnly: true, fieldset: "system" }, { name: "size", type: "number", title: "File size in bytes", readOnly: true, fieldset: "system" }, { name: "assetId", type: "string", title: "Asset ID", readOnly: true, fieldset: "system" }, { name: "path", type: "string", title: "Path", readOnly: true, fieldset: "system" }, { name: "url", type: "string", title: "Url", readOnly: true, fieldset: "system" }, { name: "source", type: "sanity.assetSourceData", title: "Source", readOnly: true, fieldset: "system" }], preview: { select: { title: "originalFilename", path: "path", mimeType: "mimeType", size: "size" }, prepare(doc) {
  return { title: doc.title || doc.path.split("/").slice(-1)[0], subtitle: "".concat(doc.mimeType, " (").concat((doc.size / 1024 / 1024).toFixed(2), " MB)") };
} }, orderings: [{ title: "File size", name: "fileSizeDesc", by: [{ field: "size", direction: "desc" }] }] };
var isError$1 = (problem) => problem.severity === "error";
var builtinTypes = [
  assetSourceData,
  slug2,
  geopoint,
  // legacyRichDate,
  imageAsset,
  fileAsset,
  imageCrop,
  imageHotspot,
  imageMetadata,
  imageDimensions,
  imagePalette,
  imagePaletteSwatch
];
function createSchema(schemaDef) {
  const validated = validateSchema(schemaDef.types).getTypes();
  const validation2 = groupProblems(validated);
  const hasErrors = validation2.some((group2) => group2.problems.some(isError$1));
  const compiled = Schema2.compile({ name: schemaDef.name, types: hasErrors ? [] : [...schemaDef.types, ...builtinTypes].filter(Boolean) });
  compiled._validation = validation2;
  return inferFromSchema(compiled);
}
function getSchemaTypeTitle(type) {
  if (typeof type.title === "string") {
    return type.title;
  }
  if (type.type) {
    return getSchemaTypeTitle(type.type);
  }
  return type.name || type.jsonType;
}
function createMultiKeyWeakMap() {
  const rootMap = /* @__PURE__ */ new WeakMap();
  const idCache = /* @__PURE__ */ new WeakMap();
  function randomId() {
    return Array.from({ length: 10 }).map(() => Math.floor(Math.random() * 255).toString(16).padStart(2, "0")).join("");
  }
  function assignId(key2) {
    const cachedId = idCache.get(key2);
    if (cachedId)
      return cachedId;
    const id4 = randomId();
    idCache.set(key2, id4);
    return id4;
  }
  function arrangeKeys(keys) {
    return Array.from(new Set(keys)).map((key2) => [assignId(key2), key2]).sort((_ref61, _ref62) => {
      let [a] = _ref61;
      let [b] = _ref62;
      return a.localeCompare(b, "en");
    }).map((_ref63) => {
      let [, key2] = _ref63;
      return key2;
    });
  }
  function getDeep(keys, map3) {
    if (!keys.length)
      return void 0;
    const [firstKey, ...restOfKeys] = keys;
    const node = map3.get(firstKey);
    if (!node)
      return void 0;
    if (!restOfKeys.length)
      return node.value;
    return getDeep(restOfKeys, node.next);
  }
  function setDeep(keys, map3, value) {
    if (!keys.length)
      return;
    const [firstKey, ...restOfKeys] = keys;
    const node = map3.get(firstKey) || { type: "multi-key-weak-map-node", value: void 0, next: /* @__PURE__ */ new WeakMap() };
    map3.set(firstKey, node);
    if (!restOfKeys.length) {
      node.value = value;
      return;
    }
    setDeep(restOfKeys, node.next, value);
  }
  function get6(keys) {
    return getDeep(arrangeKeys(keys), rootMap);
  }
  function set4(keys, value) {
    setDeep(arrangeKeys(keys), rootMap, value);
  }
  return { get: get6, set: set4 };
}
var ResourceCacheContext = (0, import_react51.createContext)(null);
function ResourceCacheProvider(_ref64) {
  let { children } = _ref64;
  const resourceCache = (0, import_react51.useMemo)(() => {
    const namespaces2 = /* @__PURE__ */ new Map();
    const nullReplacer = {};
    return { get: (_ref65) => {
      let { namespace, dependencies } = _ref65;
      const dependenciesWithoutNull = dependencies.map((dep) => dep === null ? nullReplacer : dep);
      const namespaceMap = namespaces2.get(namespace);
      return namespaceMap == null ? void 0 : namespaceMap.get(dependenciesWithoutNull);
    }, set: (_ref66) => {
      let { namespace, dependencies, value } = _ref66;
      const namespaceMap = namespaces2.get(namespace) || createMultiKeyWeakMap();
      const dependenciesWithoutNull = dependencies.map((dep) => dep === null ? nullReplacer : dep);
      namespaces2.set(namespace, namespaceMap);
      namespaceMap.set(dependenciesWithoutNull, value);
    } };
  }, []);
  return (0, import_jsx_runtime6.jsx)(ResourceCacheContext.Provider, { value: resourceCache, children });
}
function useResourceCache() {
  const cache2 = (0, import_react51.useContext)(ResourceCacheContext);
  if (!cache2)
    throw new Error("Could not find `cache` context");
  return cache2;
}
var CorsOriginError = class extends Error {
  constructor(_ref67) {
    let { projectId: projectId2 } = _ref67;
    super("CorsOriginError");
    this.projectId = projectId2;
  }
};
var supportsLocalStorage = (() => {
  const key2 = "__tmp_supports_local_storage";
  try {
    if (typeof localStorage === "undefined") {
      return false;
    }
    localStorage.setItem(key2, "---");
    localStorage.removeItem(key2);
    return true;
  } catch (err) {
    return false;
  }
})();
var memStore = {};
function setItem(key2, value) {
  if (supportsLocalStorage) {
    localStorage[key2] = value;
  } else {
    memStore[key2] = value;
  }
}
function getItem(key2) {
  return supportsLocalStorage ? localStorage[key2] : memStore[key2];
}
function removeItem2(key2) {
  if (supportsLocalStorage) {
    localStorage.removeItem(key2);
  } else {
    delete memStore[key2];
  }
}
function createBroadcastChannel(namespace) {
  const storageEvents$ = typeof window === "undefined" ? of() : fromEvent(window, "storage");
  const storageKey = "__studio_local_storage_messaging_".concat(namespace);
  const broadcastedMessages$ = new Subject();
  const messages$ = merge(broadcastedMessages$, storageEvents$.pipe(filter((event) => event.key === storageKey), map((event) => event.newValue), filter(isNonNullable$3), map((newValue) => JSON.parse(newValue)))).pipe(
    // this is important to ensure all new subscribers get a message on subscribe
    shareReplay(1)
  );
  function broadcast(message) {
    try {
      setItem(storageKey, JSON.stringify(message));
      removeItem2(storageKey);
      broadcastedMessages$.next(message);
    } catch (err) {
    }
  }
  return { messages: messages$, broadcast };
}
var sidPattern = /sid=([^&]{20,})&?/;
function consumeSessionId() {
  if (typeof window === "undefined" || typeof window.location !== "object") {
    return null;
  }
  const hash3 = window.location.hash;
  const [, sidParam] = hash3.match(sidPattern) || [];
  if (!sidParam) {
    return null;
  }
  const newHash = hash3.replace(sidPattern, "");
  const newUrl = new URL(window.location.href);
  newUrl.hash = newHash.length > 1 ? newHash : "";
  history.replaceState(null, "", newUrl);
  return sidParam;
}
var sessionId = consumeSessionId();
var getSessionId$1 = () => {
  const id4 = sessionId;
  if (id4) {
    sessionId = null;
  }
  return id4;
};
var __freeze$2p = Object.freeze;
var __defProp$2p = Object.defineProperty;
var __template$2p = (cooked, raw) => __freeze$2p(__defProp$2p(cooked, "raw", { value: __freeze$2p(raw || cooked.slice()) }));
var _a$2p;
var _b$14;
var GithubRootSvg = st.svg((_ref68) => {
  let { theme } = _ref68;
  const { fg } = theme.sanity.color.base;
  return nt(_a$2p || (_a$2p = __template$2p(["\n    fill: ", ";\n  "])), fg);
});
var CustomImage = st.img(_b$14 || (_b$14 = __template$2p(["\n  height: 19px;\n  width: 19px;\n  object-fit: contain;\n"])));
var GithubLogo = () => (0, import_jsx_runtime6.jsx)(GithubRootSvg, { width: "1em", height: "1em", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 438.55 438.55", children: (0, import_jsx_runtime6.jsx)("path", { d: "M409.13 114.57a218.32 218.32 0 0 0-79.8-79.8Q278.94 5.36 219.27 5.36T109.21 34.77a218.29 218.29 0 0 0-79.8 79.8Q0 165 0 224.63q0 71.67 41.83 128.91t108.06 79.23q7.71 1.43 11.42-2a11.17 11.17 0 0 0 3.69-8.57q0-.86-.14-15.42t-.14-25.41l-6.57 1.14a83.77 83.77 0 0 1-15.85 1 120.73 120.73 0 0 1-19.84-2 44.34 44.34 0 0 1-19.11-8.51 36.23 36.23 0 0 1-12.56-17.6l-2.86-6.57a71.34 71.34 0 0 0-9-14.56q-6.14-8-12.42-10.85l-2-1.43a21 21 0 0 1-3.71-3.43 15.66 15.66 0 0 1-2.57-4q-.86-2 1.43-3.29C61.2 310.42 64 310 68 310l5.71.85q5.71 1.14 14.13 6.85a46.08 46.08 0 0 1 13.85 14.84q6.57 11.71 15.85 17.85t18.7 6.14a81.19 81.19 0 0 0 16.27-1.42 56.78 56.78 0 0 0 12.85-4.29q2.57-19.14 14-29.41a195.49 195.49 0 0 1-29.36-5.13 116.52 116.52 0 0 1-26.83-11.14 76.86 76.86 0 0 1-23-19.13q-9.14-11.42-15-30t-5.8-42.81q0-34.55 22.56-58.82-10.57-26 2-58.24 8.28-2.57 24.55 3.85t23.84 11q7.57 4.56 12.13 7.71a206.2 206.2 0 0 1 109.64 0l10.85-6.85a153.65 153.65 0 0 1 26.26-12.56q15.13-5.71 23.13-3.14 12.84 32.26 2.28 58.24 22.55 24.27 22.56 58.82 0 24.27-5.85 43t-15.12 30a79.82 79.82 0 0 1-23.13 19 116.74 116.74 0 0 1-26.84 11.14 195.29 195.29 0 0 1-29.23 5.07q14.8 12.84 14.81 40.58v60.2a11.37 11.37 0 0 0 3.57 8.56q3.57 3.42 11.28 2 66.24-22 108.07-79.23t41.83-128.91q-.03-59.62-29.43-110.05z" }) });
var GoogleLogo = () => (0, import_jsx_runtime6.jsxs)("svg", { width: "1em", height: "1em", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 48 48", children: [(0, import_jsx_runtime6.jsx)("path", { d: "M11 24a13 13 0 0 1 .66-4.08l-7.4-5.66a22.18 22.18 0 0 0 0 19.49l7.4-5.67A13 13 0 0 1 11 24z", fill: "#fbbc05" }), (0, import_jsx_runtime6.jsx)("path", { d: "M24 11a12.72 12.72 0 0 1 8.1 2.9l6.4-6.4a22 22 0 0 0-34.24 6.75l7.4 5.66A13 13 0 0 1 24 11z", fill: "#ea4335" }), (0, import_jsx_runtime6.jsx)("path", { d: "M24 37a13 13 0 0 1-12.34-8.92l-7.4 5.66A21.93 21.93 0 0 0 24 46a21 21 0 0 0 14.33-5.48l-7-5.44A13.59 13.59 0 0 1 24 37zm-12.35-8.93l-7.4 5.67 7.4-5.66z", fill: "#34a853" }), (0, import_jsx_runtime6.jsx)("path", { d: "M44.5 20H24v8.5h11.8a9.91 9.91 0 0 1-4.49 6.58l7 5.44C42.37 36.76 45 31.17 45 24a18.25 18.25 0 0 0-.5-4z", fill: "#4285f4" })] });
function CustomLogo(props2) {
  const { provider } = props2;
  return provider.logo ? (0, import_jsx_runtime6.jsx)(CustomImage, { src: provider.logo, alt: "Logo for ".concat(provider.name) }) : void 0;
}
var providerLogos = {
  google: GoogleLogo,
  github: GithubLogo
  // sanity: () => <SanityMonogram data-sanity-icon="" />,
};
async function getProviders(_ref69) {
  let { client, mode, providers: customProviders = [] } = _ref69;
  if (mode === "replace" && Array.isArray(customProviders)) {
    return customProviders;
  }
  const { providers } = await client.request({ uri: "/auth/providers" });
  if (typeof customProviders === "function") {
    return customProviders(providers);
  }
  if (customProviders.length === 0) {
    return providers;
  }
  if (mode === "replace") {
    return customProviders;
  }
  return providers.filter((official) => customProviders.some((provider) => provider.url !== official.url)).concat(customProviders);
}
function createHrefForProvider(_ref70) {
  let { loginMethod = "dual", projectId: projectId2, url, basePath } = _ref70;
  const params = new URLSearchParams();
  params.set("origin", "".concat(window.location.origin).concat(basePath));
  params.set("projectId", projectId2);
  if (loginMethod === "token") {
    params.set("withSid", "true");
  } else {
    params.set("type", loginMethod);
  }
  return "".concat(url, "?").concat(params);
}
function createLoginComponent(_ref71) {
  let { getClient, loginMethod, redirectOnSingle, ...providerOptions } = _ref71;
  const useClient2 = createHookFromObservableFactory(getClient);
  function LoginComponent(_ref72) {
    let { projectId: projectId2, basePath } = _ref72;
    const [providers, setProviders] = (0, import_react51.useState)(null);
    const [error2, setError] = (0, import_react51.useState)(null);
    if (error2)
      throw error2;
    const [client] = useClient2();
    (0, import_react51.useEffect)(() => {
      if (!client)
        return;
      getProviders({ client, ...providerOptions }).then(setProviders).catch(setError);
    }, [client]);
    const redirectUrl = redirectOnSingle && (providers == null ? void 0 : providers.length) === 1 && (providers == null ? void 0 : providers[0]) && createHrefForProvider({ loginMethod, projectId: projectId2, url: providers[0].url, basePath });
    const loading = !providers || redirectUrl;
    (0, import_react51.useEffect)(() => {
      if (redirectUrl) {
        window.location.href = redirectUrl;
      }
    }, [redirectUrl]);
    if (loading) {
      return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", direction: "column", gap: 4, justify: "center", padding: 6, sizing: "border", children: [(0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: "Loading" }), (0, import_jsx_runtime6.jsx)(Spinner, { muted: true })] });
    }
    return (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Heading, { align: "center", size: 1, children: "Choose login provider" }), (0, import_jsx_runtime6.jsx)(Stack, { space: 2, children: providers.map((provider, index) => (0, import_jsx_runtime6.jsx)(Button, { as: "a", icon: providerLogos[provider.name] || (0, import_jsx_runtime6.jsx)(CustomLogo, { provider }), href: createHrefForProvider({ loginMethod, projectId: projectId2, url: provider.url, basePath }), mode: "ghost", text: provider.title }, "".concat(provider.url, "_").concat(index))) })] });
  }
  return LoginComponent;
}
var getStorageKey = (projectId2) => {
  if (!projectId2)
    throw new Error("Invalid project id");
  return "__studio_auth_token_".concat(projectId2);
};
var getToken = (projectId2) => {
  try {
    const item = getItem(getStorageKey(projectId2));
    if (item) {
      const { token } = JSON.parse(item);
      if (token && typeof token === "string") {
        return token;
      }
    }
  } catch (err) {
    console.error(err);
  }
  return null;
};
var clearToken = (projectId2) => {
  try {
    removeItem2(getStorageKey(projectId2));
  } catch (err) {
    console.error(err);
  }
};
var saveToken = (_ref73) => {
  let { token, projectId: projectId2 } = _ref73;
  try {
    setItem(getStorageKey(projectId2), JSON.stringify({ token, time: (/* @__PURE__ */ new Date()).toISOString() }));
  } catch (err) {
    console.error(err);
  }
};
var getCurrentUser = async (client, broadcastToken) => {
  var _a4;
  try {
    const user = await client.request({ uri: "/users/me", withCredentials: true, tag: "users.get-current" });
    return typeof (user == null ? void 0 : user.id) === "string" ? user : null;
  } catch (err) {
    if (err.statusCode === 401) {
      clearToken(client.config().projectId || "");
      broadcastToken(null);
      return null;
    }
    const invalidCorsConfig = await client.request({ uri: "/ping", withCredentials: false, tag: "cors-check" }).then(
      () => true,
      // Request succeeded, so likely the CORS origin is disallowed
      () => false
      // Request failed, so likely a network error of some kind
    );
    if (invalidCorsConfig) {
      throw new CorsOriginError({ projectId: (_a4 = client.config()) == null ? void 0 : _a4.projectId });
    }
    if (err.isNetworkError && !err.message && err.request && err.request.url) {
      const host = new URL(err.request.url).host;
      throw new Error("Unknown network error attempting to reach ".concat(host));
    }
    throw err;
  }
};
function _createAuthStore(_ref74) {
  let { clientFactory: clientFactoryOption, projectId: projectId2, dataset: dataset2, apiHost, loginMethod = "dual", ...providerOptions } = _ref74;
  const { broadcast, messages } = createBroadcastChannel("dual_mode_auth_".concat(projectId2));
  const clientFactory = clientFactoryOption != null ? clientFactoryOption : createClient;
  const token$ = messages.pipe(startWith(loginMethod === "dual" ? getToken(projectId2) : null));
  const hostOptions = {};
  if (apiHost) {
    hostOptions.apiHost = apiHost;
  } else if (typeof __SANITY_STAGING__ !== "undefined" && __SANITY_STAGING__ === true) {
    hostOptions.apiHost = "https://api.sanity.work";
  }
  const state$ = token$.pipe(
    // // see above
    // debounce(() => firstMessage),
    map((token) => clientFactory({ projectId: projectId2, dataset: dataset2, apiVersion: "2021-06-07", useCdn: false, ...token && { token }, withCredentials: true, requestTagPrefix: "sanity.studio", ignoreBrowserTokenWarning: true, allowReconfigure: false, ...hostOptions })),
    switchMap((client) => defer(async () => {
      const currentUser = await getCurrentUser(client, broadcast);
      return { currentUser, client, authenticated: !!currentUser };
    })),
    distinctUntilChanged((prev, next) => (
      // Only notify subscribers if the the currentUser object has changed.
      // Using isEqual is OK since the currentUser object being a small data structure.
      (0, import_isEqual4.default)(prev.currentUser, next.currentUser)
    )),
    shareReplay(1)
  );
  async function handleCallbackUrl() {
    const sessionId2 = getSessionId$1();
    if (!sessionId2) {
      broadcast(loginMethod === "cookie" ? null : getToken(projectId2));
      return;
    }
    const requestClient = clientFactory({ projectId: projectId2, dataset: dataset2, useCdn: true, withCredentials: true, apiVersion: "2021-06-07", requestTagPrefix: "sanity.studio", ...hostOptions });
    let currentUser;
    if (loginMethod === "dual" || loginMethod === "cookie") {
      currentUser = await getCurrentUser(requestClient, broadcast);
    }
    if (currentUser || loginMethod === "cookie") {
      broadcast(null);
      return;
    }
    const token = await tradeSessionForToken(requestClient, sessionId2);
    broadcast(token != null ? token : null);
  }
  async function tradeSessionForToken(client, sessionId2) {
    const { token } = await client.request({ method: "GET", uri: "/auth/fetch", query: { sid: sessionId2 }, tag: "auth.fetch-token" });
    saveToken({ token, projectId: projectId2 });
    return token;
  }
  async function logout() {
    const requestClient = clientFactory({ projectId: projectId2, dataset: dataset2, useCdn: true, withCredentials: true, apiVersion: "2021-06-07", requestTagPrefix: "sanity.studio", ...hostOptions });
    clearToken(projectId2);
    await requestClient.request({ uri: "/auth/logout", method: "POST" });
    broadcast(null);
  }
  const LoginComponent = createLoginComponent({ ...providerOptions, getClient: () => state$.pipe(map((state) => state.client)), loginMethod });
  return { handleCallbackUrl, token: token$, state: state$, LoginComponent, logout };
}
function hash2(value) {
  if (typeof value !== "object" || value === null)
    return "".concat(value);
  return JSON.stringify(Object.fromEntries(Object.entries(value).sort((_ref75, _ref76) => {
    let [a] = _ref75;
    let [b] = _ref76;
    return a.localeCompare(b, "en");
  }).map((_ref77) => {
    let [k, v] = _ref77;
    return [k, hash2(v)];
  })));
}
var createAuthStore = (0, import_memoize.default)(_createAuthStore, hash2);
function isAuthStore(maybeStore) {
  return isRecord$4(maybeStore) && "state" in maybeStore && isRecord$4(maybeStore.state) && "subscribe" in maybeStore.state && typeof maybeStore.state.subscribe === "function";
}
function createMockAuthStore(_ref78) {
  let { client, currentUser = null } = _ref78;
  return { state: of({ authenticated: true, client, currentUser }) };
}
function getProviderTitle(provider) {
  if (provider === "google") {
    return "Google";
  }
  if (provider === "github") {
    return "GitHub";
  }
  if (provider === "sanity") {
    return "Sanity";
  }
  if (provider == null ? void 0 : provider.startsWith("saml-")) {
    return "SAML/SSO";
  }
  return void 0;
}
function catchWithCount(selector) {
  return (input$) => {
    let errors = [];
    const errorOp = catchError((err, caught) => {
      errors.push(err);
      return selector(err, errors.length, caught).pipe(errorOp);
    });
    return input$.pipe(tap(() => {
      errors = [];
    }), errorOp);
  };
}
var onOnline$ = typeof window === "undefined" ? of({}) : fromEvent(window, "online");
var onOffline$ = typeof window === "undefined" ? of({}) : fromEvent(window, "offline");
var expBackoff = (retryCount) => Math.pow(2, retryCount) * 100;
var CONNECTING = { type: "connecting" };
var _callback = observableCallback();
var onRetry$ = _callback[0];
var onRetry = _callback[1];
var createErrorStatus = (_ref79) => {
  let { error: error2, isOffline, attemptNo, retryAt } = _ref79;
  return { type: "error", error: error2, attemptNo, isOffline, retryAt };
};
function createConnectionStatusStore(_ref80) {
  let { bifur } = _ref80;
  const connectionStatus$ = merge(bifur.heartbeats, onOffline$.pipe(mergeMapTo(throwError(new Error("The browser went offline"))))).pipe(map((ts) => ({ type: "connected", lastHeartbeat: ts })), catchWithCount((error2, successiveErrorsCount, caught) => {
    const timeUntilRetry = Math.min(1e3 * 240, expBackoff(successiveErrorsCount));
    const retryAt = new Date((/* @__PURE__ */ new Date()).getTime() + timeUntilRetry);
    const expiry$ = timer(retryAt);
    const isOffline = !navigator.onLine;
    const initialErrorStatus = createErrorStatus({ error: error2, retryAt, isOffline, attemptNo: successiveErrorsCount });
    const triggerRetry$ = NEVER.pipe(takeUntil(isOffline ? onOnline$ : merge(expiry$, onOnline$, onRetry$)));
    return concat(of(initialErrorStatus), triggerRetry$.pipe(take(1)), caught);
  }), startWith(CONNECTING));
  return { connectionStatus$ };
}
function useClient(clientOptions) {
  const source = useSource();
  if (!clientOptions) {
    console.warn('Calling `useClient()` without specifying an API version is deprecated and will stop working in the next dev-preview release - please migrate to use `useClient({apiVersion: "2021-06-07"})`.');
    return source.getClient({ apiVersion: "2021-06-07" });
  }
  return source.getClient(clientOptions);
}
var useUserViaUserStore = createHookFromObservableFactory((_ref81) => {
  let [userStore, userId] = _ref81;
  return from(userStore.getUser(userId).catch((err) => {
    console.error(err);
    return null;
  }));
});
function useUser(userId) {
  const userStore = useUserStore();
  return useUserViaUserStore((0, import_react51.useMemo)(() => [userStore, userId], [userId, userStore]));
}
function useCurrentUser() {
  const { currentUser } = useSource();
  return currentUser;
}
var INITIAL$1 = "connecting";
function useConnectionState(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.documentEvents(publishedDocId, docTypeName).pipe(map((ev) => ev.type), map((eventType) => eventType !== "reconnect"), switchMap((isConnected) => isConnected ? of("connected") : timer(200).pipe(mapTo("reconnecting"))), startWith(INITIAL$1), distinctUntilChanged()), [documentStore.pair, publishedDocId, docTypeName], INITIAL$1);
}
function useDataset() {
  return useSource().dataset;
}
function useDocumentOperation(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.editOperations(publishedDocId, docTypeName), [docTypeName, documentStore.pair, publishedDocId]);
}
function useDocumentOperationEvent(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.operationEvents(publishedDocId, docTypeName), [documentStore.pair, publishedDocId, docTypeName]);
}
function useEditState(publishedDocId, docTypeName) {
  let priority = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  const documentStore = useDocumentStore();
  return useMemoObservable(() => {
    const base = documentStore.pair.editState(publishedDocId, docTypeName).pipe(share());
    if (priority === "low") {
      return merge(base.pipe(take(1)), base.pipe(skip(1), debounce(() => timer(1e3))));
    }
    return documentStore.pair.editState(publishedDocId, docTypeName);
  }, [documentStore.pair, publishedDocId, docTypeName, priority]);
}
var PERIODS = ["days", "hours", "minutes", "seconds", "milliseconds"];
function useFormattedDuration(durationMs, options) {
  const { style = "short", resolution = "seconds" } = options || {};
  const unitDisplay = style;
  const locale = useCurrentLocale();
  const listFormat = useIntlListFormat({ type: "unit", style });
  const isNegative = durationMs < 0;
  const duration = parseMilliseconds(Math.abs(durationMs));
  const formatters = (0, import_react51.useMemo)(() => ({ days: intlCache.numberFormat(locale, { style: "unit", unit: "day", unitDisplay }), hours: intlCache.numberFormat(locale, { style: "unit", unit: "hour", unitDisplay }), minutes: intlCache.numberFormat(locale, { style: "unit", unit: "minute", unitDisplay }), seconds: intlCache.numberFormat(locale, { style: "unit", unit: "second", unitDisplay }), milliseconds: intlCache.numberFormat(locale, { style: "unit", unit: "millisecond", unitDisplay }) }), [locale, unitDisplay]);
  const parts = [];
  for (const period of PERIODS) {
    const value = duration[period];
    if (!value || resolution === "seconds" && period === "milliseconds") {
      continue;
    }
    const prefix = isNegative && parts.length === 0 ? "-" : "";
    parts.push("".concat(prefix).concat(formatters[period].format(value)));
  }
  const formatted = parts.length === 0 ? (
    // If passing duration 0, we still want to show something
    formatters[resolution].format(0)
  ) : (
    // Usually, we want to join the parts with the locales list formatter
    listFormat.format(parts)
  );
  const iso8601 = durationToISO8601(duration, isNegative);
  return { formatted, iso8601 };
}
function parseMilliseconds(milliseconds) {
  return { days: Math.trunc(milliseconds / 864e5), hours: Math.trunc(milliseconds / 36e5) % 24, minutes: Math.trunc(milliseconds / 6e4) % 60, seconds: Math.trunc(milliseconds / 1e3) % 60, milliseconds: Math.trunc(milliseconds) % 1e3 };
}
function durationToISO8601(dur, isNegative) {
  const date = dur.days ? "".concat(dur.days, "D") : "";
  let time2 = "";
  if (dur.hours)
    time2 += "".concat(dur.hours, "H");
  if (dur.minutes)
    time2 += "".concat(dur.minutes, "M");
  if (dur.milliseconds) {
    time2 += "".concat(((dur.seconds * 1e3 + dur.milliseconds) / 1e3).toFixed(3), "S");
  } else if (dur.seconds) {
    time2 += "".concat(dur.seconds, "S");
  }
  if (!date && !time2) {
    return "PT0S";
  }
  const parts = time2 ? [date, time2] : [date];
  const duration = "P".concat(parts.join("T"));
  return isNegative ? "-".concat(duration) : duration;
}
function useProjectId$1() {
  return useSource().projectId;
}
var FIVE_SECONDS = 1e3 * 5;
var TWENTY_SECONDS = 1e3 * 20;
var ONE_MINUTE2 = 1e3 * 60;
var ONE_HOUR = ONE_MINUTE2 * 60;
var NO_YEAR_DATE_ONLY_FORMAT = { month: "short", day: "numeric" };
var DATE_ONLY_FORMAT = { ...NO_YEAR_DATE_ONLY_FORMAT, year: "numeric" };
var FULL_DATE_FORMAT = { ...DATE_ONLY_FORMAT, hour: "numeric", minute: "numeric" };
function useRelativeTime(time2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const resolved = useFormatRelativeTime(time2, options);
  const [, forceUpdate] = (0, import_react51.useReducer)((x) => x + 1, 0);
  (0, import_react51.useEffect)(() => {
    let timerId;
    function tick(interval) {
      timerId = window.setTimeout(() => {
        forceUpdate();
        timerId = window.setTimeout(() => tick(interval), interval);
      }, interval);
    }
    if (resolved.refreshInterval !== null) {
      tick(resolved.refreshInterval);
    }
    return () => {
      if (timerId !== null) {
        clearTimeout(timerId);
      }
    };
  }, [forceUpdate, resolved.refreshInterval]);
  return resolved.timestamp;
}
function useFormatRelativeTime(date) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const { t: t3 } = useTranslation2();
  const currentLocale = useCurrentLocale();
  const { timeZone, minimal } = opts;
  const parsedDate = date instanceof Date ? date : new Date(date);
  const useTemporalPhrase = Boolean(opts.useTemporalPhrase);
  const format4 = (0, import_react51.useCallback)(function formatWithUnit(count2, unit) {
    const isNextOrPrevDay = unit === "day" && Math.abs(count2) === 1;
    if (useTemporalPhrase || isNextOrPrevDay) {
      return intlCache.relativeTimeFormat(currentLocale, { style: minimal ? "short" : "long", numeric: "auto" }).format(count2, unit);
    }
    return intlCache.numberFormat(currentLocale, { style: "unit", unit, unitDisplay: minimal ? "short" : "long" }).format(Math.abs(count2));
  }, [currentLocale, useTemporalPhrase, minimal]);
  if (!parsedDate.getTime()) {
    return { timestamp: "", refreshInterval: null };
  }
  const now3 = opts.relativeTo || Date.now();
  const diffMonths = differenceInMonths(now3, parsedDate);
  const diffYears = differenceInYears(now3, parsedDate);
  if (diffMonths || diffYears) {
    if (opts.minimal && diffYears === 0) {
      return { timestamp: intlCache.dateTimeFormat(currentLocale, { ...NO_YEAR_DATE_ONLY_FORMAT, timeZone }).format(parsedDate), refreshInterval: null };
    }
    if (opts.minimal) {
      return { timestamp: intlCache.dateTimeFormat(currentLocale, { ...DATE_ONLY_FORMAT, timeZone }).format(parsedDate), refreshInterval: null };
    }
    return { timestamp: intlCache.dateTimeFormat(currentLocale, { ...FULL_DATE_FORMAT, timeZone }).format(parsedDate), refreshInterval: null };
  }
  const diffWeeks = differenceInWeeks(parsedDate, now3);
  if (diffWeeks) {
    return { timestamp: format4(diffWeeks, "week"), refreshInterval: ONE_HOUR };
  }
  const diffDays = differenceInDays(parsedDate, now3);
  if (diffDays) {
    return { timestamp: format4(diffDays, "day"), refreshInterval: ONE_HOUR };
  }
  const diffHours = differenceInHours(parsedDate, now3);
  if (diffHours) {
    return { timestamp: format4(diffHours, "hour"), refreshInterval: ONE_MINUTE2 };
  }
  const diffMins = differenceInMinutes(parsedDate, now3);
  if (diffMins) {
    return { timestamp: format4(diffMins, "minute"), refreshInterval: TWENTY_SECONDS };
  }
  const diffSeconds = differenceInSeconds(parsedDate, now3);
  if (Math.abs(diffSeconds) > 10) {
    return { timestamp: format4(diffSeconds, "second"), refreshInterval: FIVE_SECONDS };
  }
  return { timestamp: t3("relative-time.just-now"), refreshInterval: FIVE_SECONDS };
}
function useSchema() {
  return useSource().schema;
}
var SYNCING = { isSyncing: true };
var NOT_SYNCING = { isSyncing: false };
function useSyncState(publishedDocId, documentType) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.consistencyStatus(publishedDocId, documentType).pipe(map((isConsistent) => isConsistent ? NOT_SYNCING : SYNCING)), [documentStore.pair, documentType, publishedDocId], NOT_SYNCING);
}
function useTemplates() {
  return useSource().templates;
}
function useTimeAgo(time2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return useRelativeTime(time2, { minimal: options.minimal, useTemporalPhrase: options.agoSuffix });
}
function useTools() {
  return useSource().tools;
}
function useUnitFormatter() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const currentLocale = useCurrentLocale();
  const defaultOptions5 = { unitDisplay: "long", ...options, style: "unit" };
  return function format4(value, unit) {
    const formatter = intlCache.numberFormat(currentLocale, { ...defaultOptions5, unit });
    return formatter.format(value);
  };
}
var INITIAL = { validation: [], isValidating: false };
function useValidationStatus(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.validation(publishedDocId, docTypeName), [documentStore.pair, publishedDocId, docTypeName], INITIAL);
}
var DEFAULT_STUDIO_CLIENT_OPTIONS = { apiVersion: "2022-09-09" };
var INITIAL_LOADING_STATE$2 = { isLoading: true, enabled: true, features: [] };
function fetchFeatures(_ref82) {
  let { versionedClient } = _ref82;
  return versionedClient.observable.request({ uri: "/features", tag: "features" });
}
var cachedFeatureRequest;
function useFeatureEnabled(featureKey) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  if (!cachedFeatureRequest) {
    cachedFeatureRequest = fetchFeatures({ versionedClient }).pipe(shareReplay());
  }
  const featureInfo = useMemoObservable(() => cachedFeatureRequest.pipe(map(function() {
    let features2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return { isLoading: false, enabled: Boolean(features2 == null ? void 0 : features2.includes(featureKey)), features: features2 };
  }), startWith(INITIAL_LOADING_STATE$2), catchError((err) => {
    console.error(err);
    return of({ isLoading: false, enabled: true, features: [] });
  })), [featureKey], INITIAL_LOADING_STATE$2);
  return featureInfo;
}
var _previewComponents = { default: DefaultPreview, media: MediaPreview, detail: DetailPreview, inline: InlinePreview, block: BlockPreview, blockImage: BlockImagePreview };
function FallbackIcon() {
  return (0, import_jsx_runtime6.jsx)(DocumentIcon, { className: "sanity-studio__preview-fallback-icon" });
}
function SanityDefaultPreview(props2) {
  const { icon, layout: layout2, media: mediaProp, imageUrl, title, ...restProps } = props2;
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const imageBuilder = (0, import_react51.useMemo)(() => (0, import_image_url.default)(client), [client]);
  const renderMedia2 = (0, import_react51.useCallback)((options) => {
    const { dimensions } = options;
    return (0, import_jsx_runtime6.jsx)("img", { alt: isString3(title) ? title : void 0, referrerPolicy: "strict-origin-when-cross-origin", src: imageBuilder.image(mediaProp).width(dimensions.width || 100).height(dimensions.height || 100).fit(dimensions.fit).dpr(dimensions.dpr || 1).url() || "" });
  }, [imageBuilder, mediaProp, title]);
  const renderIcon = (0, import_react51.useCallback)(() => {
    return (0, import_react51.createElement)(icon || FallbackIcon);
  }, [icon]);
  const media = (0, import_react51.useMemo)(() => {
    if (icon === false) {
      return false;
    }
    if ((0, import_react_is2.isValidElementType)(mediaProp)) {
      return mediaProp;
    }
    if ((0, import_react51.isValidElement)(mediaProp)) {
      return mediaProp;
    }
    if (isImageSource(mediaProp)) {
      return renderMedia2;
    }
    if (isString3(imageUrl)) {
      return (0, import_jsx_runtime6.jsx)("img", { src: imageUrl, alt: isString3(title) ? title : void 0, referrerPolicy: "strict-origin-when-cross-origin" });
    }
    return renderIcon;
  }, [icon, imageUrl, mediaProp, renderIcon, renderMedia2, title]);
  const previewProps = (0, import_react51.useMemo)(() => ({
    ...restProps,
    // @todo: fix `TS2769: No overload matches this call.`
    media,
    title
  }), [media, restProps, title]);
  const layoutComponent = _previewComponents[layout2 || "default"];
  return (0, import_react51.createElement)(layoutComponent, previewProps);
}
var resize$ = typeof window === "undefined" ? EMPTY : fromEvent(window, "resize").pipe(shareReplay(1));
var scroll$ = typeof window === "undefined" ? EMPTY : fromEvent(window, "scroll", { passive: true, capture: true }).pipe(shareReplay(1));
var orientationChange$ = typeof window === "undefined" ? EMPTY : fromEvent(window, "orientationchange").pipe(shareReplay(1));
var ROOT_MARGIN_PX = 150;
function isIntersectionObserverSupported() {
  if (typeof window !== "undefined" && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in IntersectionObserverEntry.prototype)) {
      Object.defineProperty(IntersectionObserverEntry.prototype, "isIntersecting", { get() {
        return this.intersectionRatio > 0;
      } });
    }
    return true;
  }
  return false;
}
var intersectionObservableFor = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();
function createIntersectionObserverBased() {
  const intersectionObserverEntriesSubject = new Subject();
  const intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      intersectionObserverEntriesSubject.next(entry);
    });
  }, { threshold: 0, rootMargin: "".concat(ROOT_MARGIN_PX, "px") });
  return function intersectionObservableFor2(element) {
    return new Observable((observer) => {
      intersectionObserver.observe(element);
      observer.next();
      return () => intersectionObserver.unobserve(element);
    }).pipe(mergeMap(() => intersectionObserverEntriesSubject.asObservable()), filter((entry) => entry.target === element), map((ev) => ({ isIntersecting: ev.isIntersecting })));
  };
}
function createLegacyBased() {
  function getViewport() {
    return { left: 0, right: window.innerWidth, top: 0, bottom: window.innerHeight };
  }
  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }
  function inViewport(element) {
    return () => intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
  }
  return function intersectionObservableFor2(element) {
    const isElementInViewport = inViewport(element);
    return merge(of(isElementInViewport()), resize$, scroll$, orientationChange$).pipe(
      // @todo: consider "faking" more of the IntersectionObserverEntry api if possible
      map(isElementInViewport),
      map((isIntersecting) => ({ isIntersecting }))
    );
  };
}
var visibilityChange$ = typeof window === "undefined" ? EMPTY : fromEvent(document, "visibilitychange").pipe(shareReplay(1));
function useVisibility(props2) {
  const { element, hideDelay = 0 } = props2;
  const [visible, setVisible] = (0, import_react51.useState)(false);
  (0, import_react51.useEffect)(() => {
    if (!element) {
      return void 0;
    }
    const isDocumentVisible$ = concat(of(!document.hidden), visibilityChange$.pipe(map((event) => {
      var _a4;
      return event.target instanceof Document ? !((_a4 = event == null ? void 0 : event.target) == null ? void 0 : _a4.hidden) : false;
    }))).pipe(distinctUntilChanged());
    const inViewport$ = intersectionObservableFor(element).pipe(map((event) => event.isIntersecting));
    const visible$ = isDocumentVisible$.pipe(switchMap((isDocumentVisible) => isDocumentVisible ? inViewport$ : of(false)), switchMap((isVisible) => isVisible ? of(true) : of(false).pipe(delay(hideDelay))), distinctUntilChanged());
    const sub2 = visible$.subscribe(setVisible);
    return () => sub2.unsubscribe();
  }, [element, hideDelay]);
  return visible;
}
var INITIAL_STATE$2 = { isLoading: true };
var PENDING_STATE = { isLoading: false };
function useDocumentPreview(props2) {
  const { enabled = true, ordering, schemaType, value: previewValue } = props2 || {};
  const { observeForPreview } = useDocumentPreviewStore();
  return useMemoObservable(() => {
    if (!enabled || !previewValue || !schemaType)
      return of(PENDING_STATE);
    return observeForPreview(previewValue, schemaType, { ordering }).pipe(map((event) => ({ isLoading: false, value: event.snapshot || void 0 })), catchError((error2) => of({ isLoading: false, error: error2 })));
  }, [enabled, observeForPreview, ordering, schemaType, previewValue], INITIAL_STATE$2);
}
function _extractUploadState(value) {
  return _resolveUploadValue(value == null ? void 0 : value._upload);
}
function getStringOrUndefined(value) {
  return isString3(value) ? value : void 0;
}
function _resolveUploadValue(value) {
  var _a4, _b4;
  if (!isRecord$4(value))
    return void 0;
  const progress3 = typeof value.progress === "number" ? value.progress : 0;
  const createdAt = getStringOrUndefined(value.initiated || value.createdAt);
  const updatedAt = getStringOrUndefined(value.updated || value.updatedAt);
  const fileName = getStringOrUndefined((_a4 = value == null ? void 0 : value.file) == null ? void 0 : _a4.name);
  const fileType = getStringOrUndefined((_b4 = value == null ? void 0 : value.file) == null ? void 0 : _b4.type);
  const previewImage = getStringOrUndefined(value.previewImage);
  if (createdAt && updatedAt && fileName && fileType) {
    return { progress: progress3, createdAt, updatedAt, file: { name: fileName, type: fileType }, previewImage };
  }
  return void 0;
}
var _HIDE_DELAY = 1e3 * 2;
function PreviewLoader(props2) {
  const { layout: layout2, value, component, style: styleProp, schemaType, skipVisibilityCheck, ...restProps } = props2;
  const { t: t3 } = useTranslation2();
  const [element, setElement] = (0, import_react51.useState)(null);
  const isVisible = useVisibility({ element: skipVisibilityCheck ? null : element, hideDelay: _HIDE_DELAY });
  const preview = useDocumentPreview({ enabled: skipVisibilityCheck || isVisible, schemaType, value });
  const style = (0, import_react51.useMemo)(() => ({ ...styleProp, minWidth: (styleProp == null ? void 0 : styleProp.minWidth) || 1, minHeight: (styleProp == null ? void 0 : styleProp.minHeight) || 1 }), [styleProp]);
  const uploadState = (0, import_react51.useMemo)(() => _extractUploadState(value), [value]);
  const media = (0, import_react51.useMemo)(() => {
    var _a4, _b4;
    if (uploadState == null ? void 0 : uploadState.previewImage) {
      return (0, import_jsx_runtime6.jsx)("img", { alt: t3("preview.image.file-is-being-uploaded.alt-text"), src: uploadState.previewImage });
    }
    if (!((_a4 = preview == null ? void 0 : preview.value) == null ? void 0 : _a4.media)) {
      return schemaType.icon;
    }
    return (_b4 = preview == null ? void 0 : preview.value) == null ? void 0 : _b4.media;
  }, [preview, schemaType, uploadState, t3]);
  return (0, import_jsx_runtime6.jsx)("div", { ref: setElement, style, children: (0, import_react51.createElement)(component, { ...restProps, ...(preview == null ? void 0 : preview.value) || {}, media, error: preview == null ? void 0 : preview.error, isPlaceholder: preview == null ? void 0 : preview.isLoading, layout: layout2, schemaType }) });
}
var emptyRender = () => (0, import_react51.createElement)(import_react51.Fragment);
function _createMiddlewareComponent(defaultComponent, middlewareComponents) {
  return (outerProps) => {
    let next = (props2) => (0, import_react51.createElement)(defaultComponent, props2);
    for (const middleware of middlewareComponents) {
      const renderDefault = next;
      next = (props2) => (0, import_react51.createElement)(middleware, { ...props2, renderDefault });
    }
    return next({
      ...outerProps,
      // NOTE: it's safe to pass the empty render function, since it'll be overwritten in the next step (above).
      // NOTE: it's important that the default component does not use `renderDefault`, since it will
      // get the `emptyRender` callback will be passed when the middleware stack is empty.
      renderDefault: emptyRender
    });
  };
}
function useMiddlewareComponents(props2) {
  const { options } = useSource().__internal;
  const { defaultComponent, pick: pick5 } = props2;
  return (0, import_react51.useMemo)(() => {
    const flattened = [...flattenConfig(options, [])];
    flattened.reverse();
    const pickedComponents = flattened.map((_ref83) => {
      let { config } = _ref83;
      return pick5(config);
    });
    const result = pickedComponents.filter(Boolean);
    return _createMiddlewareComponent(defaultComponent, result);
  }, [defaultComponent, options, pick5]);
}
function is$1(typeName, type) {
  return type.name === typeName || Boolean(type.type && is$1(typeName, type.type));
}
var isDocumentType = (type) => Boolean(type.type && type.type.name === "document");
var isSanityType = (type) => type.name.startsWith("sanity.");
var getSearchableTypes = (schema) => schema.getTypeNames().map((typeName) => schema.get(typeName)).filter(isNonNullable$3).filter((schemaType) => isDocumentType(schemaType)).filter((type) => !isSanityType(type));
var calculateScore = (searchTerms, value) => {
  const { phrases: uniqueSearchPhrases, words: uniqueSearchWords } = partitionAndSanitizeSearchTerms(searchTerms);
  const [phraseScore, phraseWhy] = calculatePhraseScore(uniqueSearchPhrases, value);
  const [wordScore, wordWhy] = calculateWordScore(uniqueSearchWords, value);
  return [phraseScore + wordScore, [wordWhy, phraseWhy].join(", ")];
};
var stringify4 = (value) => typeof value === "string" ? value : JSON.stringify(value);
function applyWeights(searchSpec, hits) {
  let terms = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const specByType = (0, import_keyBy.default)(searchSpec, (spec) => spec.typeName);
  return hits.map((hit, index) => {
    var _a4;
    const typeSpec = specByType[hit._type];
    const stories = (_a4 = typeSpec.paths || []) == null ? void 0 : _a4.map((pathSpec, idx) => {
      const value = stringify4(hit["w".concat(idx)]);
      if (!value) {
        return { path: pathSpec.path, score: 0, why: "No match" };
      }
      const [score2, why] = calculateScore(terms, value);
      return { path: pathSpec.path, score: score2 * pathSpec.weight, why: "".concat(why, " (*").concat(pathSpec.weight, ")") };
    });
    const totalScore = stories.reduce((acc, rank) => acc + rank.score, 0);
    return { hit, resultIndex: hits.length - index, score: totalScore, stories };
  });
}
function calculatePhraseScore(uniqueSearchPhrases, value) {
  const sanitizedValue = value.toLowerCase().trim();
  let fieldScore = 0;
  let matchCount = 0;
  uniqueSearchPhrases.forEach((term) => {
    if (sanitizedValue.includes(term)) {
      fieldScore += term.length / sanitizedValue.length;
      matchCount += term.length;
    }
  });
  return fieldScore === 1 ? [1, "[Phrase] Exact match"] : [fieldScore / 2, "[Phrase] Matched ".concat(matchCount, " of ").concat(sanitizedValue.length, " characters")];
}
function calculateWordScore(uniqueSearchTerms, value) {
  const uniqueValueTerms = (0, import_uniq4.default)((0, import_compact2.default)((0, import_words.default)((0, import_toLower.default)(value))));
  const matches = (0, import_intersection2.default)(uniqueSearchTerms, uniqueValueTerms);
  const all = (0, import_union.default)(uniqueValueTerms, uniqueSearchTerms);
  const fieldScore = matches.length / all.length;
  return fieldScore === 1 ? [1, "[Word] Exact match"] : [fieldScore / 2, "[Word] Matched ".concat(matches.length, " of ").concat(all.length, " terms: [").concat(matches.join(", "), "]")];
}
function partitionAndSanitizeSearchTerms(searchTerms) {
  const uniqueSearchTerms = (0, import_uniq4.default)(searchTerms.map(import_toLower.default));
  const [searchPhrases, searchWords] = (0, import_partition2.default)(uniqueSearchTerms, (term) => /^".*"$/.test(term));
  return {
    phrases: (0, import_uniq4.default)(searchPhrases).map(import_toLower.default).map(stripWrappingQuotes),
    //
    words: (0, import_uniq4.default)(searchWords.map(import_toLower.default))
  };
}
function stripWrappingQuotes(str) {
  return str.replace(/^"(.*)"$/, "$1");
}
var SPECIAL_CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g;
var STRIP_EDGE_CHARS = /(^[.]+)|([.]+$)/;
function tokenize2(string3) {
  return (string3.match(SPECIAL_CHARS) || []).map((token) => token.replace(STRIP_EDGE_CHARS, ""));
}
var FINDABILITY_MVI = 4;
var DEFAULT_LIMIT = 1e3;
var combinePaths = (0, import_flow.default)([import_flatten5.default, import_union.default, import_compact2.default]);
function createSearchSpecs(types3, optimizeIndexedPaths) {
  let hasIndexedPaths = false;
  const specs = types3.map((type) => ({ typeName: type.name, paths: type.__experimental_search.map((config) => {
    const path2 = config.path.map((p) => {
      if (typeof p === "number") {
        hasIndexedPaths = true;
        if (optimizeIndexedPaths) {
          return [];
        }
      }
      return p;
    });
    return { weight: config.weight, path: joinPath(path2), mapWith: config.mapWith };
  }) }));
  return { specs, hasIndexedPaths };
}
var pathWithMapper = (_ref84) => {
  let { mapWith, path: path2 } = _ref84;
  return mapWith ? "".concat(mapWith, "(").concat(path2, ")") : path2;
};
function createConstraints(terms, specs) {
  const combinedSearchPaths = combinePaths(specs.map((configForType) => (configForType.paths || []).map((opt) => pathWithMapper(opt))));
  const constraints = terms.map((_term, i) => combinedSearchPaths.map((joinedPath) => "".concat(joinedPath, " match $t").concat(i))).filter((constraint) => constraint.length > 0);
  return constraints.map((constraint) => "(".concat(constraint.join(" || "), ")"));
}
function extractTermsFromQuery(query) {
  const quotedQueries = [];
  const unquotedQuery = query.replace(/("[^"]*")/g, (match4) => {
    if ((0, import_words.default)(match4).length > 1) {
      quotedQueries.push(match4);
      return "";
    }
    return match4;
  });
  const quotedTerms = quotedQueries.map((str) => (0, import_trim.default)((0, import_toLower.default)(str)));
  const remainingTerms = (0, import_uniq4.default)((0, import_compact2.default)(tokenize2((0, import_toLower.default)(unquotedQuery))));
  return [...quotedTerms, ...remainingTerms];
}
function toOrderClause(orderBy2) {
  function wrapFieldWithFn(ordering) {
    return ordering.mapWith ? "".concat(ordering.mapWith, "(").concat(ordering.field, ")") : ordering.field;
  }
  return (orderBy2 || []).map((ordering) => [wrapFieldWithFn(ordering), (ordering.direction || "").toLowerCase()].map((str) => str.trim()).filter(Boolean).join(" ")).join(",");
}
function createSearchQuery(searchTerms) {
  let searchOpts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _a4, _b4;
  const { filter: filter3, params, tag } = searchOpts;
  const { specs: exactSearchSpecs, hasIndexedPaths } = createSearchSpecs(searchTerms.types, false);
  const terms = extractTermsFromQuery(searchTerms.query);
  const optimizedSpecs = hasIndexedPaths ? createSearchSpecs(searchTerms.types, true).specs : exactSearchSpecs;
  const filters = ["_type in $__types", searchOpts.includeDrafts === false && "!(_id in path('drafts.**'))", ...createConstraints(terms, optimizedSpecs), filter3 ? "(".concat(filter3, ")") : "", searchTerms.filter ? "(".concat(searchTerms.filter, ")") : ""].filter(Boolean);
  const selections = exactSearchSpecs.map((spec) => {
    const constraint = '_type == "'.concat(spec.typeName, '" => ');
    const selection2 = "{ ".concat(spec.paths.map((cfg, i) => '"w'.concat(i, '": ').concat(pathWithMapper(cfg))), " }");
    return "".concat(constraint).concat(selection2);
  });
  const sortOrder = toOrderClause((searchOpts == null ? void 0 : searchOpts.sort) || [{ field: "_id", direction: "asc" }]);
  const projectionFields = ["_type", "_id"];
  const selection = selections.length > 0 ? "...select(".concat(selections.join(",\n"), ")") : "";
  const finalProjection = projectionFields.join(", ") + (selection ? ", ".concat(selection) : "");
  let query = "*[".concat(filters.join(" && "), "]") + "| order(".concat(sortOrder, ")") + "[$__offset...$__limit]" + // the following would improve search quality for paths-with-numbers, but increases the size of the query by up to 50%
  // `${hasIndexedPaths ? `[${createConstraints(terms, exactSearchSpec).join(' && ')}]` : ''}` +
  "{".concat(finalProjection, "}");
  if (searchOpts == null ? void 0 : searchOpts.__unstable_extendedProjection) {
    const extendedProjection = searchOpts == null ? void 0 : searchOpts.__unstable_extendedProjection;
    const firstProjection = projectionFields.concat(extendedProjection).join(", ");
    query = ["*[".concat(filters.join(" && "), "]{").concat(firstProjection, "}"), "order(".concat(sortOrder, ")[$__offset...$__limit]{").concat(finalProjection, "}")].join("|");
  }
  const groqComments = ["findability-mvi:".concat(FINDABILITY_MVI)].concat((searchOpts == null ? void 0 : searchOpts.comments) || []).map((s) => "// ".concat(s)).join("\n");
  const updatedQuery = groqComments ? "".concat(groqComments, "\n").concat(query) : query;
  const offset2 = (_a4 = searchOpts == null ? void 0 : searchOpts.offset) != null ? _a4 : 0;
  const limit = ((_b4 = searchOpts == null ? void 0 : searchOpts.limit) != null ? _b4 : DEFAULT_LIMIT) + offset2;
  return { query: updatedQuery, params: { ...toGroqParams(terms), __types: exactSearchSpecs.map((spec) => spec.typeName), __limit: limit, __offset: offset2, ...params || {} }, options: { tag }, searchSpec: exactSearchSpecs, terms };
}
var toGroqParams = (terms) => {
  const params = {};
  return terms.reduce((acc, term, i) => {
    acc["t".concat(i)] = "".concat(term, "*");
    return acc;
  }, params);
};
function getSearchTerms(searchParams, types3) {
  if (typeof searchParams === "string") {
    return { query: searchParams, types: types3 };
  }
  return searchParams.types.length ? searchParams : { ...searchParams, types: types3 };
}
function createWeightedSearch(types3, client) {
  let commonOpts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return function search2(searchParams) {
    let searchOpts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const searchTerms = getSearchTerms(searchParams, types3);
    const { query, params, options, searchSpec, terms } = createSearchQuery(searchTerms, { ...commonOpts, ...searchOpts });
    return client.observable.fetch(query, params, options).pipe(
      commonOpts.unique ? map(removeDupes) : tap(),
      // Assign weighting and scores based on current search terms.
      // No scores will be assigned when terms are empty.
      map((hits) => applyWeights(searchSpec, hits, terms)),
      // Optionally skip client-side score sorting.
      // This can be relevant when ordering results by specific fields, especially dates.
      (searchOpts == null ? void 0 : searchOpts.skipSortByScore) ? tap() : map((hits) => (0, import_sortBy.default)(hits, (hit) => -hit.score))
    );
  };
}
var READABLE = { available: true, reason: "READABLE" };
var PERMISSION_DENIED = { available: false, reason: "PERMISSION_DENIED" };
var NOT_FOUND = { available: false, reason: "NOT_FOUND" };
function getReferenceInfo(documentPreviewStore, id4, referenceType) {
  const { publishedId, draftId } = getIdPair(id4);
  const pairAvailability$ = documentPreviewStore.unstable_observeDocumentPairAvailability(id4);
  return pairAvailability$.pipe(switchMap((pairAvailability) => {
    if (!pairAvailability.draft.available && !pairAvailability.published.available) {
      const availability = pairAvailability.draft.reason === "PERMISSION_DENIED" || pairAvailability.published.reason === "PERMISSION_DENIED" ? PERMISSION_DENIED : NOT_FOUND;
      return of({ id: id4, type: void 0, availability, preview: { draft: void 0, published: void 0 } });
    }
    const draftRef = { _type: "reference", _ref: draftId };
    const publishedRef = { _type: "reference", _ref: publishedId };
    const typeName$ = combineLatest([documentPreviewStore.observeDocumentTypeFromId(draftId), documentPreviewStore.observeDocumentTypeFromId(publishedId)]).pipe(
      // assume draft + published are always same type
      map((_ref85) => {
        let [draftTypeName, publishedTypeName] = _ref85;
        return draftTypeName || publishedTypeName;
      })
    );
    return typeName$.pipe(switchMap((typeName) => {
      if (!typeName) {
        return of({ id: id4, type: void 0, availability: { available: true, reason: "READABLE" }, preview: { draft: void 0, published: void 0 } });
      }
      const refSchemaType = referenceType.to.find((memberType) => memberType.name === typeName);
      if (!refSchemaType) {
        return of({ id: id4, type: typeName, availability: { available: true, reason: "READABLE" }, preview: { draft: void 0, published: void 0 } });
      }
      const previewPaths = [...getPreviewPaths(refSchemaType == null ? void 0 : refSchemaType.preview) || [], ["_updatedAt"], ["_createdAt"]];
      const draftPreview$ = documentPreviewStore.observePaths(draftRef, previewPaths).pipe(map((result) => result ? { _id: draftId, ...prepareForPreview(result, refSchemaType) } : void 0), startWith(void 0));
      const publishedPreview$ = documentPreviewStore.observePaths(publishedRef, previewPaths).pipe(map((result) => result ? { _id: publishedId, ...prepareForPreview(result, refSchemaType) } : void 0), startWith(void 0));
      const value$ = combineLatest([draftPreview$, publishedPreview$]).pipe(map((_ref86) => {
        let [draft, published] = _ref86;
        return { draft, published };
      }));
      return value$.pipe(map((value) => {
        const availability = (
          // eslint-disable-next-line no-nested-ternary
          pairAvailability.draft.available || pairAvailability.published.available ? READABLE : pairAvailability.draft.reason === "PERMISSION_DENIED" || pairAvailability.published.reason === "PERMISSION_DENIED" ? PERMISSION_DENIED : NOT_FOUND
        );
        return { type: typeName, id: publishedId, availability, preview: { draft: isRecord$4(value.draft) ? value.draft : void 0, published: isRecord$4(value.published) ? value.published : void 0 } };
      }));
    }));
  }));
}
function getCounterpartIds(collatedHits) {
  return collatedHits.filter((collatedHit) => (
    // we're interested in hits where either draft or published is missing
    !collatedHit.draft || !collatedHit.published
  )).map((collatedHit) => (
    // if we have the draft, return the published id or vice versa
    collatedHit.draft ? collatedHit.id : getDraftId(collatedHit.id)
  ));
}
function getExistingCounterparts(client, ids) {
  return ids.length === 0 ? of([]) : client.observable.fetch("*[_id in $ids]._id", { ids }, { tag: "get-counterpart-ids" });
}
function referenceSearch(client, textTerm, type, options) {
  const searchWeighted = createWeightedSearch(type.to, client, options);
  return searchWeighted(textTerm, { includeDrafts: true }).pipe(
    map((results) => results.map((result) => result.hit)),
    map(collate),
    // pick the 100 best matches
    map((collated) => collated.slice(0, 100)),
    mergeMap((collated) => {
      return getExistingCounterparts(client, getCounterpartIds(collated)).pipe(map((existingCounterpartIds) => {
        return collated.map((entry) => {
          const draftId = getDraftId(entry.id);
          return { id: entry.id, type: entry.type, draft: entry.draft || existingCounterpartIds.includes(draftId) ? { _id: draftId, _type: entry.type } : void 0, published: entry.published || existingCounterpartIds.includes(entry.id) ? { _id: entry.id, _type: entry.type } : void 0 };
        });
      }));
    })
  );
}
function createPatchChannel() {
  const _subscribers = [];
  return { publish(msg2) {
    for (const subscriber of _subscribers) {
      subscriber(msg2);
    }
  }, subscribe(subscriber) {
    _subscribers.push(subscriber);
    return () => {
      const idx = _subscribers.indexOf(subscriber);
      if (idx > -1) {
        _subscribers.splice(idx, 1);
      }
    };
  } };
}
var SANITY_PATCH_TYPE = Symbol.for("sanity.patch");
function setIfMissing2(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "setIfMissing", path: path2, value };
}
function insert2(items, position) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "insert", path: path2, position, items };
}
function set$2(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "set", path: path2, value };
}
function unset2() {
  let path2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "unset", path: path2 };
}
function diffMatchPatch2(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "diffMatchPatch", path: path2, value };
}
function inc() {
  let amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "inc", path: path2, value: amount };
}
function dec() {
  let amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return { patchType: SANITY_PATCH_TYPE, type: "dec", path: path2, value: amount };
}
function prefixPath(patch2, segment) {
  return { ...patch2, path: [segment, ...patch2.path] };
}
var PatchEvent = class _PatchEvent {
  static from(input) {
    if (input instanceof _PatchEvent) {
      return input;
    }
    return new _PatchEvent(Array.isArray(input) ? (0, import_flatten5.default)(input) : [input]);
  }
  constructor(patches) {
    this.patches = patches;
  }
  prepend() {
    for (var _len = arguments.length, patches = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      patches[_key2] = arguments[_key2];
    }
    return _PatchEvent.from([...(0, import_flatten5.default)(patches), ...this.patches]);
  }
  append() {
    for (var _len2 = arguments.length, patches = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      patches[_key3] = arguments[_key3];
    }
    return _PatchEvent.from([...this.patches, ...(0, import_flatten5.default)(patches)]);
  }
  prefixAll(segment) {
    return _PatchEvent.from(this.patches.map((patch2) => prefixPath(patch2, segment)));
  }
};
var __freeze$2o = Object.freeze;
var __defProp$2o = Object.defineProperty;
var __template$2o = (cooked, raw) => __freeze$2o(__defProp$2o(cooked, "raw", { value: __freeze$2o(raw || cooked.slice()) }));
var _a$2o;
var STATUS_TONES$1 = { warning: "caution", error: "critical" };
var SuffixBox = st(Box)(_a$2o || (_a$2o = __template$2o(["\n  border-top: 1px solid var(--card-border-color);\n"])));
function Alert(props2) {
  const { children, status = "warning", suffix, title, ...rest } = props2;
  return (0, import_jsx_runtime6.jsxs)(Card, { radius: 2, tone: STATUS_TONES$1[status], ...rest, "data-ui": "Alert", children: [(0, import_jsx_runtime6.jsxs)(Flex, { padding: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, children: [status === "warning" && (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}), status === "error" && (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {})] }) }), (0, import_jsx_runtime6.jsxs)(Box, { flex: 1, marginLeft: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: title }), children && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children })] })] }), suffix && (0, import_jsx_runtime6.jsx)(SuffixBox, { children: suffix })] });
}
function usePrevious(value, initial) {
  const ref = (0, import_react51.useRef)(initial || null);
  (0, import_react51.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function useDidUpdate(current, didUpdate) {
  let compare = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : import_shallow_equals.default;
  const previous = usePrevious(current);
  (0, import_react51.useEffect)(() => {
    if (!compare(previous, current)) {
      didUpdate(previous, current);
    }
  }, [didUpdate, current, previous, compare]);
}
function useOnClickOutside(refs, handler) {
  (0, import_react51.useEffect)(() => {
    const listener = (event) => {
      const target = event.target;
      if (target instanceof HTMLElement) {
        if (refs.some((ref) => {
          var _a4;
          return (_a4 = ref.current) == null ? void 0 : _a4.contains(target);
        })) {
          return;
        }
        handler(event);
      }
    };
    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);
    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  }, [refs, handler]);
}
var rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reKeySegment3 = /_key\s*==\s*['"](.*)['"]/;
function pathToString2(path2) {
  if (!Array.isArray(path2)) {
    throw new Error("Path is not an array");
  }
  return path2.reduce((target, segment, i) => {
    if (isIndexSegment(segment)) {
      return "".concat(target, "[").concat(segment, "]");
    }
    if (isKeySegment(segment) && segment._key) {
      return "".concat(target, '[_key=="').concat(segment._key, '"]');
    }
    if (isIndexTuple(segment)) {
      const [from2, to] = segment;
      return "".concat(target, "[").concat(from2, ":").concat(to, "]");
    }
    if (typeof segment === "string") {
      const separator = i === 0 ? "" : ".";
      return "".concat(target).concat(separator).concat(segment);
    }
    throw new Error("Unsupported path segment `".concat(JSON.stringify(segment), "`"));
  }, "");
}
function getValueAtPath(rootValue, path2) {
  const segment = path2[0];
  if (!segment) {
    return rootValue;
  }
  const tail = path2.slice(1);
  if (isIndexSegment(segment)) {
    return getValueAtPath(Array.isArray(rootValue) ? rootValue[segment] : void 0, tail);
  }
  if (isKeySegment(segment)) {
    return getValueAtPath(Array.isArray(rootValue) ? rootValue.find((item) => item._key === segment._key) : void 0, tail);
  }
  if (typeof segment === "string") {
    return getValueAtPath(isRecord$4(rootValue) ? rootValue[segment] : void 0, tail);
  }
  throw new Error("Unknown segment type ".concat(JSON.stringify(segment)));
}
function findIndex2(array3, segment) {
  if (typeof segment !== "number" && !isKeySegment(segment)) {
    return -1;
  }
  return typeof segment === "number" ? segment : array3.findIndex((item) => isKeyedObject(item) && item._key === segment._key);
}
function stringToPath(path2) {
  const segments = path2.match(rePropName2);
  if (!segments) {
    throw new Error("Invalid path string");
  }
  return segments.map(normalizePathSegment2);
}
function normalizePathSegment2(segment) {
  if (isIndexSegment(segment)) {
    return normalizeIndexSegment2(segment);
  }
  if (isKeySegment(segment)) {
    return normalizeKeySegment2(segment);
  }
  if (isIndexTuple(segment)) {
    return normalizeIndexTupleSegment2(segment);
  }
  return segment;
}
function normalizeIndexSegment2(segment) {
  return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment2(segment) {
  const segments = segment.match(reKeySegment3);
  if (!segments) {
    throw new Error("Invalid key segment");
  }
  return { _key: segments[1] };
}
function normalizeIndexTupleSegment2(segment) {
  const [from2, to] = segment.split(":").map((seg) => seg === "" ? seg : Number(seg));
  return [from2, to];
}
function pathsAreEqual(pathA, pathB) {
  if (pathA.length !== pathB.length) {
    return false;
  }
  return pathA.every((segmentA, index) => {
    const segmentB = pathB[index];
    if (isKeySegment(segmentA) && isKeySegment(segmentB)) {
      return segmentA._key === segmentB._key;
    }
    if (isIndexSegment(segmentA)) {
      return Number(segmentA) === Number(segmentB);
    }
    if (isIndexTuple(segmentA) && isIndexTuple(segmentB)) {
      return segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1];
    }
    return segmentA === segmentB;
  });
}
function getItemKey$2(arrayItem) {
  return isKeyedObject(arrayItem) ? arrayItem._key : void 0;
}
function getItemKeySegment(arrayItem) {
  const key2 = getItemKey$2(arrayItem);
  return key2 ? { _key: key2 } : void 0;
}
function isEmptyObject$1(item) {
  return typeof item === "object" && item !== null && Object.keys(item).length <= 0;
}
function getAnnotationColor(colorManager, annotation) {
  return colorManager.get((annotation == null ? void 0 : annotation.author) || null);
}
function getAnnotationAtPath(diff4, diffPath) {
  const path2 = Array.isArray(diffPath) ? diffPath : stringToPath(diffPath);
  return getAnnotationAt(diff4, path2);
}
function getDiffAtPath(diff4, diffPath) {
  const path2 = Array.isArray(diffPath) ? diffPath : stringToPath(diffPath);
  return getDiffAt(diff4, path2);
}
function getAnnotationAt(diff4, path2) {
  const diffAt = getDiffAt(diff4, path2);
  if (!diffAt) {
    return void 0;
  }
  if (diffAt.action === "unchanged") {
    return void 0;
  }
  return diffAt.annotation || void 0;
}
function getDiffAt(diff4, path2) {
  let parentPath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  if (path2.length === 0) {
    return diff4;
  }
  const segment = path2[0];
  const tail = path2.slice(1);
  if (isIndexTuple(segment)) {
    throw new Error("Index tuples are not supported in diff paths");
  }
  if (isIndexSegment(segment) || isKeySegment(segment)) {
    const location = isIndexSegment(segment) ? "at index ".concat(segment) : "with key ".concat(segment._key);
    if (diff4.type !== "array") {
      warn("Failed to get item ".concat(location, " at path ").concat(pathToString2(parentPath), " (not an array)"));
      return void 0;
    }
    const itemDiff = diff4.items.find(isIndexSegment(segment) ? (item) => item.toIndex === segment : (item) => itemMatchesKey(item, segment));
    if (!itemDiff) {
      warn("Failed to get item ".concat(location, " at path ").concat(pathToString2(parentPath), " (item missing)"));
      return void 0;
    }
    return getDiffAt(itemDiff.diff, tail, parentPath.concat(segment));
  }
  if (diff4.type !== "object") {
    warn("Failed to get property ".concat(segment, " at path ").concat(pathToString2(parentPath), " (not an object)"));
    return void 0;
  }
  const fieldDiff = diff4.fields[segment];
  if (typeof fieldDiff === "undefined") {
    warn("Failed to get property ".concat(segment, " at path ").concat(pathToString2(parentPath), " (field did not exist)"));
    return void 0;
  }
  return getDiffAt(fieldDiff, tail, parentPath.concat(segment));
}
function warn(msg2) {
}
function itemMatchesKey(item, key2) {
  const itemDiff = item.diff;
  return itemDiff.type !== "object" || !itemDiff.toValue ? false : itemDiff.toValue._key === key2;
}
function visitDiff(diff4, visitor) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  if (!visitor(diff4, path2)) {
    return;
  }
  if (diff4.type === "array") {
    visitArrayDiff(diff4, visitor, path2);
    return;
  }
  if (diff4.type === "object") {
    visitObjectDiff(diff4, visitor, path2);
    return;
  }
  if (diff4.type === "string") {
    visitStringDiff(diff4, visitor, path2);
  }
}
function visitArrayDiff(diff4, visitor, path2) {
  if (diff4.action === "unchanged") {
    return;
  }
  diff4.items.forEach((itemDiff) => {
    var _a4;
    const _key = itemDiff.diff.type === "object" && ((_a4 = itemDiff.diff.toValue) == null ? void 0 : _a4._key);
    const segment = _key ? { _key } : getItemDiffIndex(itemDiff);
    visitDiff(itemDiff.diff, visitor, path2.concat(segment));
  });
}
function visitObjectDiff(diff4, visitor, path2) {
  if (diff4.action === "unchanged") {
    return;
  }
  Object.keys(diff4.fields).forEach((fieldName) => {
    const fieldDiff = diff4.fields[fieldName];
    visitDiff(fieldDiff, visitor, path2.concat(fieldName));
  });
}
function visitStringDiff(diff4, visitor, path2) {
  if (diff4.action === "unchanged") {
    return;
  }
  diff4.segments.forEach((segment) => {
    visitDiff(segment, visitor, path2);
  });
}
function getItemDiffIndex(itemDiff) {
  return typeof itemDiff.toIndex === "undefined" ? itemDiff.fromIndex || 0 : itemDiff.toIndex;
}
function useAnnotationColor(annotation) {
  const userColorManager = useUserColorManager();
  return getAnnotationColor(userColorManager, annotation);
}
function useDiffAnnotationColor(diff4) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const userColorManager = useUserColorManager();
  const annotation = (0, import_react51.useMemo)(() => getAnnotationAtPath(diff4, path2), [diff4, path2]);
  return (0, import_react51.useMemo)(() => getAnnotationColor(userColorManager, annotation), [annotation, userColorManager]);
}
function DiffTooltip(props2) {
  if (!("diff" in props2)) {
    return (0, import_jsx_runtime6.jsx)(DiffTooltipWithAnnotation, { ...props2 });
  }
  const { diff: diff4, path: path2 = [], ...restProps } = props2;
  const annotation = getAnnotationAtPath(diff4, path2);
  return (0, import_jsx_runtime6.jsx)(DiffTooltipWithAnnotation, { ...restProps, annotations: annotation ? [annotation] : [] });
}
function DiffTooltipWithAnnotation(props2) {
  const { annotations, children, description, ...restProps } = props2;
  const { t: t3 } = useTranslation2();
  if (!annotations) {
    return children;
  }
  const content = (0, import_jsx_runtime6.jsxs)(Stack, { padding: 3, space: 2, children: [(0, import_jsx_runtime6.jsx)(Label, { size: 1, style: { textTransform: "uppercase" }, children: description || t3("changes.changed-label") }), (0, import_jsx_runtime6.jsx)(Stack, { space: 2, children: annotations.map((annotation, idx) => (0, import_jsx_runtime6.jsx)(AnnotationItem, { annotation }, idx)) })] });
  return (0, import_jsx_runtime6.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime6.jsx)(Tooltip, { content, portal: true, ...restProps, children }) });
}
function AnnotationItem(_ref87) {
  let { annotation } = _ref87;
  const { author, timestamp } = annotation;
  const [user] = useUser(author);
  const color3 = useAnnotationColor(annotation);
  const timeAgo = useRelativeTime(timestamp, { minimal: true });
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", paddingRight: 3, style: { backgroundColor: color3.background, color: color3.text, borderRadius: "calc(23px / 2)" }, children: [(0, import_jsx_runtime6.jsx)(UserAvatar, { user: author }), (0, import_jsx_runtime6.jsx)(Inline, { paddingLeft: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, style: { color: color3.text }, children: user ? user.displayName : t3("changes.loading-author") }) })] }), (0, import_jsx_runtime6.jsx)(Text3, { as: "time", muted: true, size: 1, dateTime: timestamp, children: timeAgo })] });
}
var __freeze$2n = Object.freeze;
var __defProp$2n = Object.defineProperty;
var __template$2n = (cooked, raw) => __freeze$2n(__defProp$2n(cooked, "raw", { value: __freeze$2n(raw || cooked.slice()) }));
var _a$2n;
var StyledCard$1 = st(Card)(_a$2n || (_a$2n = __template$2n(["\n  --diff-card-radius: ", ";\n  --diff-card-bg-color: ", ";\n\n  max-width: 100%;\n  position: relative;\n  border-radius: var(--diff-card-radius);\n\n  &:not(del) {\n    text-decoration: none;\n  }\n\n  &[data-hover] {\n    &::after {\n      content: '';\n      display: block;\n      position: absolute;\n      left: 0;\n      right: 0;\n      bottom: 0;\n    }\n\n    &:hover {\n      border-bottom-left-radius: 0;\n      border-bottom-right-radius: 0;\n\n      &::after {\n        bottom: -3px;\n        border-top: 1px solid var(---diff-card-bg-color);\n        border-bottom: 2px solid currentColor;\n        border-bottom-left-radius: var(--diff-card-radius);\n        border-bottom-right-radius: var(--diff-card-radius);\n      }\n    }\n\n    [data-from-to-layout]:hover & {\n      border-bottom-left-radius: 0;\n      border-bottom-right-radius: 0;\n\n      &::after {\n        bottom: -3px;\n        border-top: 1px solid var(---diff-card-bg-color);\n        border-bottom: 2px solid currentColor;\n        border-bottom-left-radius: var(--diff-card-radius);\n        border-bottom-right-radius: var(--diff-card-radius);\n      }\n    }\n  }\n"])), (_ref88) => {
  let { theme } = _ref88;
  return rem(theme.sanity.radius[2]);
}, (_ref89) => {
  let { theme } = _ref89;
  return theme.sanity.color.card.enabled.bg;
});
var EMPTY_PATH$1 = [];
var DiffCard = (0, import_react51.forwardRef)(function DiffCard2(props2, ref) {
  const { annotation: annotationProp, as = "div", children, className, diff: diff4, disableHoverEffect, path: path2 = EMPTY_PATH$1, style = {}, tooltip, ...restProps } = props2;
  const annotation = (0, import_react51.useMemo)(() => annotationProp || getAnnotationAtPath(diff4, path2), [annotationProp, diff4, path2]);
  const color3 = useAnnotationColor(annotation);
  const element = (0, import_jsx_runtime6.jsx)(StyledCard$1, { ...restProps, as, className, "data-hover": disableHoverEffect || !annotation ? void 0 : "", ref, radius: 1, style: { ...style, backgroundColor: color3.background, color: color3.text }, children });
  if (tooltip && annotation) {
    return (0, import_jsx_runtime6.jsx)(DiffTooltip, { annotations: [annotation], description: tooltip && typeof tooltip === "object" && tooltip.description, children: element });
  }
  return element;
});
var __freeze$2m = Object.freeze;
var __defProp$2m = Object.defineProperty;
var __template$2m = (cooked, raw) => __freeze$2m(__defProp$2m(cooked, "raw", { value: __freeze$2m(raw || cooked.slice()) }));
var _a$2m;
var _b$13;
var RoundedCard$1 = st.div(_a$2m || (_a$2m = __template$2m(["\n  border-radius: ", ";\n  padding: ", ";\n"])), (_ref90) => {
  let { theme } = _ref90;
  return rem(theme.sanity.radius[2]);
}, (_ref91) => {
  let { theme } = _ref91;
  return rem(theme.sanity.space[1]);
});
var AnnotationText = st(Text3)(_b$13 || (_b$13 = __template$2m(["\n  &:not([hidden]) {\n    color: inherit;\n  }\n"])));
function ChangeTitleSegment(props2) {
  const { change, segment } = props2;
  if (typeof segment === "string") {
    return (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { title: segment, size: 1, weight: "semibold", textOverflow: "ellipsis", children: segment }) });
  }
  const { hasMoved, fromIndex, toIndex, annotation } = segment;
  const created = typeof fromIndex === "undefined";
  const deleted = typeof toIndex === "undefined";
  if (created) {
    return (0, import_jsx_runtime6.jsx)(CreatedTitleSegment, { annotation, change, toIndex });
  }
  if (deleted) {
    return (0, import_jsx_runtime6.jsx)(DeletedTitleSegment, { annotation, fromIndex });
  }
  if (hasMoved && typeof toIndex !== "undefined" && typeof fromIndex !== "undefined") {
    return (0, import_jsx_runtime6.jsx)(MovedTitleSegment, { annotation, fromIndex, toIndex });
  }
  const readableIndex = (toIndex || 0) + 1;
  return (0, import_jsx_runtime6.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, weight: "semibold", children: ["#", readableIndex] }) });
}
function CreatedTitleSegment(props2) {
  const { annotation: annotationProp, change, toIndex = 0 } = props2;
  const { t: t3 } = useTranslation2();
  const readableIndex = toIndex + 1;
  const description = t3("changes.array.item-added-in-position", { position: readableIndex });
  const content = (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: ["#", readableIndex] });
  const diffAnnotation = (change == null ? void 0 : change.diff) ? getAnnotationAtPath(change.diff, []) : void 0;
  const annotation = diffAnnotation || annotationProp;
  if (annotation) {
    return (0, import_jsx_runtime6.jsx)(DiffCard, { annotation, tooltip: { description }, as: RoundedCard$1, children: (0, import_jsx_runtime6.jsx)(AnnotationText, { size: 1, weight: "semibold", forwardedAs: "ins", style: { textDecoration: "none" }, children: content }) });
  }
  return (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: content });
}
function DeletedTitleSegment(props2) {
  const { annotation, fromIndex = 0 } = props2;
  const { t: t3 } = useTranslation2();
  const readableIndex = fromIndex + 1;
  const description = t3("changes.array.item-removed-from-position", { position: readableIndex });
  return (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: annotation || null, as: RoundedCard$1, tooltip: { description }, children: (0, import_jsx_runtime6.jsxs)(AnnotationText, { size: 1, weight: "semibold", forwardedAs: "del", children: ["#", readableIndex] }) });
}
function MovedTitleSegment(props2) {
  const { annotation, fromIndex, toIndex } = props2;
  const { t: t3 } = useTranslation2();
  const indexDiff = toIndex - fromIndex;
  const indexSymbol = indexDiff < 0 ? "" : "";
  const positions = Math.abs(indexDiff);
  const direction = indexDiff < 0 ? "up" : "down";
  const description = t3("changes.array.item-moved", { count: positions, context: direction });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime6.jsxs)(AnnotationText, { size: 1, weight: "semibold", children: ["#", toIndex + 1] }) }), (0, import_jsx_runtime6.jsx)(DiffCard, { annotation, as: RoundedCard$1, tooltip: { description }, children: (0, import_jsx_runtime6.jsxs)(AnnotationText, { size: 1, weight: "semibold", children: [indexSymbol, Math.abs(indexDiff)] }) })] });
}
function ChangeBreadcrumb(props2) {
  const { change, titlePath } = props2;
  return (0, import_jsx_runtime6.jsx)(Breadcrumbs, { maxLength: 4, separator: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(ChevronRightIcon, {}) }), children: titlePath.map((titleSegment, idx) => {
    const showSegment = typeof titleSegment === "string" || !change || change.showIndex;
    if (!showSegment) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(ChangeTitleSegment, { change, segment: titleSegment }, idx);
  }) });
}
function isThenable(value) {
  return isRecord$4(value) && typeof (value == null ? void 0 : value.then) === "function";
}
function useCheckCondition(checkProperty, checkPropertyName, context) {
  const { currentUser, document: document2, parent, value } = context;
  const didWarn2 = (0, import_react51.useRef)(false);
  return (0, import_react51.useMemo)(() => {
    let isTrueIsh = false;
    if (typeof checkProperty === "boolean" || checkProperty === void 0) {
      return checkProperty || false;
    }
    try {
      isTrueIsh = checkProperty({ document: document2, parent, value, currentUser });
    } catch (err) {
      console.error("An error occurred while running the callback from `".concat(checkPropertyName, "`: ").concat(err.message));
      return false;
    }
    if (isThenable(isTrueIsh) && !didWarn2.current) {
      console.warn("The `".concat(checkPropertyName, "` option is either a promise or a promise returning function. Async callbacks for `").concat(checkPropertyName, "` option is not currently supported."));
      return false;
    }
    if (typeof isTrueIsh === "undefined") {
      console.warn("The `".concat(checkPropertyName, "` option is or returned `undefined`. `").concat(checkPropertyName, "` should return a boolean."));
    }
    return isTrueIsh;
  }, [checkProperty, document2, parent, value, currentUser, checkPropertyName]);
}
var useConditionalProperty = (props2) => {
  const { checkProperty = false, checkPropertyKey, document: document2, parent, value: valueProp } = props2;
  const value = useUnique2(valueProp);
  const currentUser = useCurrentUser();
  const isPropertyTruthy = useCheckCondition(checkProperty, checkPropertyKey, { currentUser, document: document2, parent, value });
  return isPropertyTruthy;
};
var DiffContext = (0, import_react51.createContext)({ path: [] });
function getPrintableType(value) {
  const nativeType = typeof value;
  if (nativeType === "object") {
    if (value === null)
      return "null";
    if (Array.isArray(value))
      return "array";
    if (value instanceof Object && value.constructor.name !== "Object") {
      return value.constructor.name;
    }
  }
  return nativeType;
}
function getValueError(value, schemaType) {
  const { jsonType } = schemaType;
  const valueType = Array.isArray(value) ? "array" : typeof value;
  if (value === null || valueType === "undefined") {
    return void 0;
  }
  if (valueType !== jsonType) {
    return { messageKey: "changes.error.incorrect-type-message", value, expectedType: jsonType, actualType: getPrintableType(value) };
  }
  if (isObjectType(schemaType) && isObjectValue(value)) {
    for (const field of schemaType.fields) {
      const fieldError = getValueError(value[field.name], field.type);
      if (fieldError) {
        return fieldError;
      }
    }
  }
  return void 0;
}
function isObjectType(schemaType) {
  return schemaType.jsonType === "object";
}
function isObjectValue(value) {
  return value !== null && !Array.isArray(value) && typeof value === "object";
}
function resolveTypeName$1(value) {
  return isTypedObject(value) ? value._type : resolveJSType$1(value);
}
function getArrayDiffItemType(diff4, schemaType) {
  if (diff4.action === "added") {
    return { toType: resolveArrayMemberType(schemaType, diff4.toValue) };
  }
  if (diff4.action === "changed") {
    return { fromType: resolveArrayMemberType(schemaType, diff4.fromValue), toType: resolveArrayMemberType(schemaType, diff4.toValue) };
  }
  if (diff4.action === "removed") {
    return { fromType: resolveArrayMemberType(schemaType, diff4.fromValue) };
  }
  return { toType: resolveArrayMemberType(schemaType, diff4.toValue) };
}
function resolveArrayMemberType(schemaType, value) {
  const typeName = resolveTypeName$1(value);
  const declared = schemaType.of.find((candidate) => candidate.name === typeName);
  if (declared) {
    return declared;
  }
  return schemaType.of.length === 1 ? schemaType.of[0] : void 0;
}
function resolveJSType$1(val) {
  if (Array.isArray(val)) {
    return "array";
  }
  if (val === null) {
    return "null";
  }
  return typeof val;
}
var ANNOTATION_SYMBOLS = [
  // [startTag, endTag]
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""]
];
var CHILD_SYMBOL = "";
var DECORATOR_SYMBOLS = [
  // [startTag, endTag]
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""],
  ["", ""]
];
var EMPTY_BLOCK_SYMBOL = "";
var INLINE_SYMBOLS = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
var TRAILING_SPACE_SYMBOL = "";
var SEGMENT_START_SYMBOL = "";
function hasPTMemberType(schemaType) {
  return schemaType.of.some(isPTSchemaType);
}
var startMarkSymbols = DECORATOR_SYMBOLS.map((set4) => set4[0]).concat(ANNOTATION_SYMBOLS.map((set4) => set4[0]));
var endMarkSymbols = DECORATOR_SYMBOLS.map((set4) => set4[1]).concat(ANNOTATION_SYMBOLS.map((set4) => set4[1]));
var allSymbols = startMarkSymbols.concat(endMarkSymbols).concat(INLINE_SYMBOLS).concat(CHILD_SYMBOL).concat(SEGMENT_START_SYMBOL);
var symbolRegex = new RegExp("".concat(allSymbols.join("|")), "g");
var segmentRegex = new RegExp("".concat(allSymbols.join("|"), "|\n"), "g");
function isPTSchemaType(schemaType) {
  return schemaType.jsonType === "object" && schemaType.name === "block";
}
function isHeader(node) {
  return isPortableTextTextBlock(node) && !!node.style && ["h1", "h2", "h3", "h4", "h5", "h6"].includes(node.style);
}
function findChildDiff(diff4, child) {
  const childrenDiff = diff4.fields.children;
  return childrenDiff.items.filter((item) => item.diff.isChanged && (item.diff.toValue === child || item.diff.fromValue === child)).map((item) => item.diff).map((childDiff) => childDiff)[0];
}
function getChildSchemaType(fields, child) {
  const childrenField = fields.find((f) => f.name === "children");
  const cSchemaType = childrenField && childrenField.type && childrenField.type.jsonType === "array" && childrenField.type.of.find((type) => type.name === child._type) || void 0;
  return cSchemaType;
}
function getDecorators(spanSchemaType) {
  if (spanSchemaType.decorators) {
    return (0, import_orderBy.default)(spanSchemaType.decorators, ["value"], ["asc"]);
  }
  return [];
}
function isDecorator(name, schemaType) {
  return getDecorators(schemaType).some((dec2) => dec2.value === name);
}
function blockToSymbolizedText(diff4, block, decoratorMap, annotationMap, inlineMap) {
  if (!block) {
    return "";
  }
  return block.children.map((child) => {
    var _a4;
    let returned = isPortableTextSpan(child) ? (_a4 = child.text) == null ? void 0 : _a4.replace(symbolRegex, "") : "";
    if (isPortableTextSpan(child)) {
      const spanDiff = findSpanDiffFromChild(diff4, child);
      const textDiff = spanDiff == null ? void 0 : spanDiff.fields.text;
      if (textDiff && textDiff.toValue === child.text && textDiff.type === "string" && textDiff.action !== "unchanged") {
        returned = textDiff.segments.filter((seg) => seg.action !== "removed").map((seg) => seg.text.replace(symbolRegex, "")).join(SEGMENT_START_SYMBOL);
      }
      if (child.marks) {
        child.marks.forEach((mark) => {
          const _isDecorator = !!decoratorMap[mark];
          if (_isDecorator) {
            returned = "".concat(decoratorMap[mark][0]).concat(returned).concat(decoratorMap[mark][1]);
          } else if (annotationMap[mark]) {
            returned = "".concat(annotationMap[mark][0]).concat(returned).concat(annotationMap[mark][1]);
          }
        });
      }
    } else {
      returned = inlineMap[child._key];
    }
    return "".concat(CHILD_SYMBOL).concat(returned);
  }).join("");
}
function createPortableTextDiff(diff4, schemaType) {
  const displayValue = diff4.action === "removed" ? diff4.fromValue : diff4.toValue;
  const _diff = { ...diff4, origin: diff4, displayValue };
  if (displayValue) {
    const annotationMap = {};
    const decoratorMap = {};
    const inlineMap = {};
    const spanSchemaType = getChildSchemaType(schemaType.fields, { _key: "bogus", _type: "span" });
    if (spanSchemaType) {
      getDecorators(spanSchemaType).forEach((dec2, index) => {
        decoratorMap[dec2.value] = DECORATOR_SYMBOLS[index];
      });
    }
    const allMarkDefs = getAllMarkDefs(_diff.origin);
    allMarkDefs.forEach((markDef, index) => {
      annotationMap[markDef._key] = ANNOTATION_SYMBOLS[index];
    });
    const inlines = getInlineObjects(_diff.origin);
    inlines.forEach((inline, index) => {
      inlineMap[inline._key] = INLINE_SYMBOLS[index];
    });
    const fromText = blockToSymbolizedText(_diff.origin, _diff.fromValue, decoratorMap, annotationMap, inlineMap);
    const toText = blockToSymbolizedText(_diff.origin, _diff.toValue, decoratorMap, annotationMap, inlineMap);
    const toPseudoValue = { ...displayValue, children: [{ _type: "span", _key: "pseudoSpanKey", text: toText, marks: [] }] };
    const fromPseudoValue = { displayValue, children: [{ _type: "span", _key: "pseudoSpanKey", text: fromText, marks: [] }] };
    const pseudoDiff = { origin: diff4, action: "changed", type: "object", displayValue: toPseudoValue, fromValue: fromPseudoValue, toValue: toPseudoValue, isChanged: true, fields: { children: { action: "changed", type: "array", isChanged: true, items: [{ diff: { action: "changed", type: "object", isChanged: true, fields: { text: { type: "string", action: "changed", isChanged: true, fromValue: fromText, toValue: toText, segments: buildSegments2(fromText, toText).map((seg) => ({ ...seg, ..._diff.action !== "unchanged" && _diff.annotation ? { annotation: _diff.annotation } : {} })) } }, fromValue: fromPseudoValue.children[0], toValue: toPseudoValue.children[0] }, annotation: null, fromIndex: 0, toIndex: 0, hasMoved: false }], fromValue: fromPseudoValue.children, toValue: toPseudoValue.children } } };
    return pseudoDiff;
  }
  throw new Error("Can not display this diff");
}
function buildSegments2(fromInput, toInput) {
  const segments = [];
  const dmpDiffs = cleanupEfficiency2(diff2(fromInput, toInput));
  let fromIdx = 0;
  let toIdx = 0;
  for (const [op, text] of dmpDiffs) {
    switch (op) {
      case DIFF_EQUAL2:
        segments.push({ type: "stringSegment", action: "unchanged", text });
        fromIdx += text.length;
        toIdx += text.length;
        break;
      case DIFF_DELETE2:
        segments.push({ type: "stringSegment", action: "removed", text: fromInput.substring(fromIdx, fromIdx + text.length), annotation: null });
        fromIdx += text.length;
        break;
      case DIFF_INSERT2:
        segments.push({ type: "stringSegment", action: "added", text: toInput.substring(toIdx, toIdx + text.length), annotation: null });
        toIdx += text.length;
        break;
    }
  }
  return (0, import_flatten5.default)(segments.map((seg) => {
    const newSegments = [];
    if (seg.text.length > 1) {
      const markMatches = [...seg.text.matchAll(segmentRegex)];
      let lastIndex = -1;
      markMatches.forEach((match4) => {
        const index = match4.index || 0;
        if (index > lastIndex) {
          newSegments.push({ ...seg, text: seg.text.substring(lastIndex + 1, index) });
          newSegments.push({ ...seg, text: match4[0] });
        }
        if (match4 === markMatches[markMatches.length - 1]) {
          newSegments.push({ ...seg, text: seg.text.substring(index + 1) });
        }
        lastIndex = index;
      });
      if (markMatches.length === 0) {
        newSegments.push(seg);
      }
    } else {
      newSegments.push(seg);
    }
    return newSegments;
  }));
}
function getInlineObjects(diff4) {
  const allChildren = [...diff4.toValue ? diff4.toValue.children.filter((cld) => cld._type !== "span") : []];
  const previousChildren = diff4.fromValue ? diff4.fromValue.children.filter((cld) => cld._type !== "span") : [];
  previousChildren.forEach((oCld) => {
    if (!allChildren.some((cld) => oCld._key === cld._key)) {
      allChildren.push(oCld);
    }
  });
  return (0, import_orderBy.default)(allChildren, ["_key"], ["asc"]);
}
function findSpanDiffFromChild(diff4, child) {
  const candidate = diff4.fields.children && diff4.fields.children.action !== "unchanged" && diff4.fields.children.type === "array" && diff4.fields.children.items.find((item) => item.diff && item.diff.type === "object" && (item.diff.action === "removed" ? item.diff.fromValue && item.diff.fromValue._key === child._key : (item.diff.toValue && item.diff.toValue._key) === child._key));
  if (candidate) {
    return candidate.diff;
  }
  return void 0;
}
function findAnnotationDiff(diff4, markDefKey) {
  var _a4;
  return diff4.fields.markDefs && diff4.fields.markDefs.isChanged && diff4.fields.markDefs.type === "array" && ((_a4 = diff4.fields.markDefs.items.find((item) => item.diff && item.diff.type === "object" && (item.diff.toValue && item.diff.toValue._key && item.diff.toValue._key === markDefKey || item.diff.fromValue && item.diff.fromValue._key && item.diff.fromValue._key === markDefKey))) == null ? void 0 : _a4.diff) || void 0;
}
function isEmptyObject(object2) {
  return object2 && (0, import_isEqual4.default)(Object.keys(object2), ["_key", "_type"]) || false;
}
function escapeRegExp2(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function getAllMarkDefs(diff4) {
  const allDefs = [...diff4.toValue && diff4.toValue.markDefs ? diff4.toValue.markDefs : []];
  const oldDefs = diff4.fromValue && diff4.fromValue.markDefs ? diff4.fromValue.markDefs : [];
  oldDefs.forEach((oDef) => {
    if (!allDefs.some((def) => oDef._key === def._key)) {
      allDefs.push(oDef);
    }
  });
  return (0, import_orderBy.default)(allDefs, ["_key"], ["asc"]);
}
var diffResolvers = [];
function Checkbox3(_ref92) {
  let { checked, color: color3 } = _ref92;
  return (0, import_jsx_runtime6.jsxs)("svg", { width: "17", height: "17", viewBox: "0 0 17 17", xmlns: "http://www.w3.org/2000/svg", fill: color3 == null ? void 0 : color3.background, children: [(0, import_jsx_runtime6.jsx)("rect", { x: "0", y: "0", width: "17", height: "17", rx: "2.5" }), typeof checked === "undefined" && (0, import_jsx_runtime6.jsx)("path", { d: "M4.07996 8.5H12.92", stroke: color3 == null ? void 0 : color3.text, strokeWidth: "2" }), checked && (0, import_jsx_runtime6.jsx)("path", { d: "M3.5 8L7 11.5L13.5 5", stroke: color3 == null ? void 0 : color3.text, strokeWidth: "2" })] });
}
function Switch3(_ref93) {
  let { checked, color: color3 } = _ref93;
  return (0, import_jsx_runtime6.jsxs)("svg", { width: "38", height: "22", viewBox: "0 0 38 22", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime6.jsx)("rect", { width: "38", height: "22", rx: "11", fill: checked ? color3 == null ? void 0 : color3.border : color3 == null ? void 0 : color3.background }), typeof checked === "undefined" && (0, import_jsx_runtime6.jsx)("rect", { x: "11", y: "3", width: "16", height: "16", rx: "8", fill: "white" }), checked && (0, import_jsx_runtime6.jsx)("rect", { x: "18", y: "3", width: "16", height: "16", rx: "8", fill: "white" }), typeof checked === "boolean" && !checked && (0, import_jsx_runtime6.jsx)("rect", { x: "4", y: "3", width: "16", height: "16", rx: "8", fill: "white" })] });
}
var BooleanFieldDiff = (_ref94) => {
  let { diff: diff4, schemaType } = _ref94;
  const { fromValue, toValue } = diff4;
  const { title, options } = schemaType;
  const Preview2 = (options == null ? void 0 : options.layout) === "checkbox" ? Checkbox3 : Switch3;
  const userColor = useDiffAnnotationColor(diff4, []);
  const showToValue = toValue !== void 0 && toValue !== null;
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(DiffTooltip, { diff: diff4, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Preview2, { checked: fromValue, color: userColor }), showToValue && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Box, { marginX: 2, children: (0, import_jsx_runtime6.jsx)(FromToArrow, {}) }), (0, import_jsx_runtime6.jsx)(Preview2, { checked: toValue, color: userColor })] })] }) }), showToValue && title && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: title }) })] });
};
var __freeze$2l = Object.freeze;
var __defProp$2l = Object.defineProperty;
var __template$2l = (cooked, raw) => __freeze$2l(__defProp$2l(cooked, "raw", { value: __freeze$2l(raw || cooked.slice()) }));
var _a$2l;
var DEFAULT_DATE_FORMAT$2 = "YYYY-MM-DD";
var DEFAULT_TIME_FORMAT$1 = "HH:mm";
var DatetimeWrapper = st.div(_a$2l || (_a$2l = __template$2l(["\n  display: inline-block;\n  word-wrap: break-word;\n"])));
var DatetimePreview = function DatetimePreview2(_ref95) {
  let { value, schemaType } = _ref95;
  return (0, import_jsx_runtime6.jsx)(Box, { as: DatetimeWrapper, paddingX: 2, paddingY: 1, children: formatDateTime(value, schemaType) });
};
function formatDateTime(value, schemaType) {
  const { options, name } = schemaType;
  const dateFormat = (options == null ? void 0 : options.dateFormat) || DEFAULT_DATE_FORMAT$2;
  const timeFormat = (options == null ? void 0 : options.timeFormat) || DEFAULT_TIME_FORMAT$1;
  return format3(new Date(value), name === "date" ? dateFormat : "".concat(dateFormat, " ").concat(timeFormat));
}
var DatetimeFieldDiff = (_ref96) => {
  let { diff: diff4, schemaType } = _ref96;
  return (0, import_jsx_runtime6.jsx)(DiffFromTo, { align: "center", diff: diff4, layout: "grid", previewComponent: DatetimePreview, schemaType });
};
var DocumentChangeContext = (0, import_react51.createContext)(null);
function useDocumentChange() {
  const documentChange = (0, import_react51.useContext)(DocumentChangeContext);
  if (!documentChange) {
    throw new Error("DocumentChange: missing context value");
  }
  return documentChange;
}
function useRefValue(refId) {
  const [value, setValue] = (0, import_react51.useState)(void 0);
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  (0, import_react51.useEffect)(() => {
    if (!refId) {
      return void 0;
    }
    const subscription = client.observable.getDocument(refId).subscribe(setValue);
    return () => {
      subscription.unsubscribe();
    };
  }, [client, refId]);
  return refId ? value : void 0;
}
function getSizeDiff(prev, next) {
  if (!prev || !next) {
    return 0;
  }
  const increase = next - prev;
  const pct = Math.round(increase / prev * 100);
  return pct;
}
function getHumanFriendlyBytes(bytes, format4) {
  if (bytes < 1e3) {
    return format4(bytes, "byte");
  }
  if (bytes < 1e3 * 1e3) {
    return format4(bytes / 1e3, "kilobyte");
  }
  if (bytes < 1e3 * 1e3 * 1e3) {
    return format4(bytes / (1e3 * 1e3), "megabyte");
  }
  if (bytes < 1e3 * 1e3 * 1e3 * 1e3) {
    return format4(bytes / (1e3 * 1e3 * 1e3), "gigabyte");
  }
  return format4(bytes / (1e3 * 1e3 * 1e3 * 1e3), "terabyte");
}
var __freeze$2k = Object.freeze;
var __defProp$2k = Object.defineProperty;
var __template$2k = (cooked, raw) => __freeze$2k(__defProp$2k(cooked, "raw", { value: __freeze$2k(raw || cooked.slice()) }));
var _a$2k;
var SizeDiff = st.div(_a$2k || (_a$2k = __template$2k(["\n  ", "\n  &:not([hidden]) {\n    display: inline-block;\n  }\n\n  [data-number='positive'] {\n    color: var(--size-diff-positive);\n  }\n\n  [data-number='negative'] {\n    color: var(--size-diff-negative);\n  }\n"])), (_ref97) => {
  let { theme } = _ref97;
  return "\n    --size-diff-positive: ".concat(theme.sanity.color.solid.positive.enabled.bg, ";\n    --size-diff-negative: ").concat(theme.sanity.color.solid.critical.enabled.bg, ";\n  ");
});
var FileFieldDiff = (_ref98) => {
  let { diff: diff4, schemaType } = _ref98;
  const { fromValue, toValue, fields } = diff4;
  const fromAsset = fromValue == null ? void 0 : fromValue.asset;
  const toAsset = toValue == null ? void 0 : toValue.asset;
  const { t: t3 } = useTranslation2();
  const prev = useRefValue(fromAsset == null ? void 0 : fromAsset._ref);
  const next = useRefValue(toAsset == null ? void 0 : toAsset._ref);
  const formatUnit = useUnitFormatter({ unitDisplay: "short", maximumFractionDigits: 2 });
  const changedFields = Object.entries(fields).filter((_ref99) => {
    let [name, field] = _ref99;
    return field.isChanged && name !== "_type";
  }).map((_ref100) => {
    let [name] = _ref100;
    return name;
  });
  const didAssetChange = changedFields.includes("asset");
  const nestedFields = schemaType.fields.filter((field) => field.name !== "asset" && changedFields.includes(field.name)).map((field) => field.name);
  const pctDiff = getSizeDiff(prev == null ? void 0 : prev.size, next == null ? void 0 : next.size);
  const prevSize = (prev == null ? void 0 : prev.size) && getHumanFriendlyBytes(prev.size, formatUnit);
  const nextSize = (next == null ? void 0 : next.size) && getHumanFriendlyBytes(next.size, formatUnit);
  const cardStyles2 = (0, import_react51.useMemo)(() => ({ display: "block", flex: 1 }), []);
  const from2 = prev && (0, import_jsx_runtime6.jsx)(DiffCard, { as: "del", diff: diff4, path: "asset._ref", style: cardStyles2, children: (0, import_jsx_runtime6.jsx)(MetaInfo, { title: prev.originalFilename || t3("changes.file.meta-info-fallback-title"), icon: DocumentIcon, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 0, style: { color: "inherit" }, children: prevSize }) }) });
  const to = next && (0, import_jsx_runtime6.jsx)(DiffCard, { as: "ins", diff: diff4, path: "asset._ref", style: cardStyles2, children: (0, import_jsx_runtime6.jsx)(MetaInfo, { title: next.originalFilename || t3("changes.file.meta-info-fallback-title"), icon: DocumentIcon, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 0, style: { color: "inherit" }, children: nextSize }), pctDiff !== 0 && (0, import_jsx_runtime6.jsx)(Card, { radius: 2, padding: 1, as: SizeDiff, marginLeft: 2, children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 0, "data-number": pctDiff > 0 ? "positive" : "negative", children: [pctDiff > 0 ? "+" : "-", pctDiff, "%"] }) })] }) }) });
  const FileAssetChange = (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [from2 && !to && (0, import_jsx_runtime6.jsx)(DiffTooltip, { diff: diff4, path: "asset._ref", description: t3("changes.removed-label"), children: from2 }), from2 && to && (0, import_jsx_runtime6.jsx)(DiffTooltip, { diff: diff4, path: "asset._ref", children: (0, import_jsx_runtime6.jsx)(FromTo, { from: from2, layout: "grid", to }) }), !from2 && to && (0, import_jsx_runtime6.jsx)(DiffTooltip, { diff: diff4, path: "asset._ref", description: t3("changes.added-label"), children: to })] });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [didAssetChange && FileAssetChange, nestedFields.length > 0 && (0, import_jsx_runtime6.jsx)(Box, { marginTop: didAssetChange ? 4 : 3, children: (0, import_jsx_runtime6.jsx)(ChangeList, { diff: diff4, schemaType, fields: nestedFields }) })] });
};
function hexToRgba(hex2, opacity) {
  const rgba3 = (/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex2) || []).slice(1).map((num) => parseInt(num, 16)).concat(opacity);
  return "rgba(".concat(rgba3.join(", "), ")");
}
function simpleHash(str) {
  let hash3 = 0;
  if (str.length == 0) {
    return hash3.toString();
  }
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash3 = (hash3 << 5) - hash3 + char;
    hash3 &= hash3;
  }
  return hash3.toString();
}
function getDeviceDpr() {
  const base = Math.ceil(window.devicePixelRatio || 1);
  return Math.min(3, Math.max(1, base));
}
function HotspotCropSVG(props2) {
  const { crop, diff: diff4, hash: hash3, hotspot, width = 100, height = 100, ...restProps } = props2;
  const { t: t3 } = useTranslation2();
  const cropColor = useDiffAnnotationColor(diff4, "crop");
  const hotspotColor = useDiffAnnotationColor(diff4, "hotspot");
  return (0, import_jsx_runtime6.jsxs)("svg", { ...restProps, fill: "none", width, height, viewBox: "0 0 ".concat(width, " ").concat(height), children: [(0, import_jsx_runtime6.jsx)("defs", { children: crop && hotspot && (0, import_jsx_runtime6.jsxs)("mask", { id: "mask-hotspot-".concat(hash3), children: [(0, import_jsx_runtime6.jsx)("rect", { x: 0, y: 0, width, height, fill: "#fff" }), (0, import_jsx_runtime6.jsx)(HotspotSVG, { hotspot, fill: "#000", offset: 1, width, height, stroke: "#000", strokeWidth: 3 })] }) }), crop && (0, import_jsx_runtime6.jsx)(DiffTooltip, { diff: diff4, path: "crop", description: t3("changes.image.crop-changed"), children: (0, import_jsx_runtime6.jsx)("g", { children: (0, import_jsx_runtime6.jsx)(CropSVG, { crop, fill: hexToRgba(cropColor.border, 0.25), mask: hotspot ? "url(#mask-hotspot-".concat(hash3, ")") : void 0, stroke: cropColor.border, strokeWidth: 1, width, height }) }) }), hotspot && (0, import_jsx_runtime6.jsx)(DiffTooltip, { diff: diff4, path: "hotspot", description: t3("changes.image.crop-changed"), children: (0, import_jsx_runtime6.jsx)("g", { children: (0, import_jsx_runtime6.jsx)(HotspotSVG, { hotspot, fill: hexToRgba(hotspotColor.border, 0.25), stroke: hotspotColor.border, strokeWidth: 1, width, height }) }) })] });
}
function CropSVG(_ref101) {
  let { crop, width, height, ...restProps } = _ref101;
  const rectProps = { x: crop.left * width, y: crop.top * height, width: (1 - crop.right - crop.left) * width, height: (1 - crop.bottom - crop.top) * height };
  return (0, import_jsx_runtime6.jsx)("rect", { ...restProps, ...rectProps, style: { vectorEffect: "non-scaling-stroke" } });
}
function HotspotSVG(_ref102) {
  let { hotspot, offset: offset2 = 0, width, height, ...restProps } = _ref102;
  const ellipseProps = { cx: hotspot.x * width, cy: hotspot.y * height, rx: hotspot.width / 2 * width + offset2, ry: hotspot.height / 2 * height + offset2 };
  return (0, import_jsx_runtime6.jsx)("ellipse", { ...restProps, ...ellipseProps, style: { vectorEffect: "non-scaling-stroke" } });
}
var __freeze$2j = Object.freeze;
var __defProp$2j = Object.defineProperty;
var __template$2j = (cooked, raw) => __freeze$2j(__defProp$2j(cooked, "raw", { value: __freeze$2j(raw || cooked.slice()) }));
var _a$2j;
var _b$12;
var _c$B;
var ASSET_FIELDS = ["originalFilename"];
var NoImagePreview = () => {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Card, { flex: 1, tone: "transparent", padding: 4, radius: 2, height: "stretch", children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "center", height: "fill", children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: t3("changes.image.no-image-placeholder") }) }) });
};
var ImageWrapper = st.div(_a$2j || (_a$2j = __template$2j(["\n  height: 100%;\n  max-height: 190px;\n  position: relative;\n\n  /* Ideally the checkerboard component currently in the form builder should be made available and used here */\n  background-color: ", ";\n  background-image: linear-gradient(45deg, ", " 25%, transparent 25%),\n    linear-gradient(-45deg, ", " 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, ", " 75%),\n    linear-gradient(-45deg, transparent 75%, ", " 75%);\n  background-size: 16px 16px;\n  background-position:\n    0 0,\n    0 8px,\n    8px -8px,\n    -8px 0;\n\n  &::after {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    box-shadow: inset 0 0 0 1px var(--card-border-color);\n    pointer-events: none;\n  }\n\n  &[data-changed] {\n    opacity: 0.45;\n  }\n"])), hues.gray[100].hex, hues.gray[50].hex, hues.gray[50].hex, hues.gray[50].hex, hues.gray[50].hex);
var Image$3 = st.img(_b$12 || (_b$12 = __template$2j(["\n  display: block;\n  flex: 1;\n  min-height: 0;\n  object-fit: contain;\n  width: 100%;\n  height: 100%;\n\n  &[data-action='removed'] {\n    opacity: 0.45;\n  }\n"])));
var HotspotDiff = st.div(_c$B || (_c$B = __template$2j(["\n  svg {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n"])));
function ImagePreview$2(props2) {
  var _a22, _b22, _c22, _d4;
  const { id: id4, action, diff: diff4, hotspot, crop, is: is2 } = props2;
  const { t: t3 } = useTranslation2();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [imageError, setImageError] = import_react51.default.useState();
  const { value: asset } = useDocumentValues(id4, ASSET_FIELDS);
  const dimensions = getImageDimensions(id4);
  const imageBuilder = (0, import_react51.useMemo)(() => (0, import_image_url.default)(client), [client]);
  const assetIsDeleted = asset === null;
  const title = asset && asset.originalFilename;
  const imageSource = imageBuilder.image(id4).height(190).dpr(getDeviceDpr()).fit("max");
  const assetChanged = ((_b22 = (_a22 = diff4.fromValue) == null ? void 0 : _a22.asset) == null ? void 0 : _b22._ref) !== ((_d4 = (_c22 = diff4.toValue) == null ? void 0 : _c22.asset) == null ? void 0 : _d4._ref);
  let printAction;
  if (action && action !== "changed") {
    printAction = t3(action === "added" ? "changes.added-label" : "changes.removed-label");
  }
  const metaAction = action === "changed" ? void 0 : action;
  return (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", height: "fill", flex: 1, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, padding: 2, paddingBottom: 0, children: (0, import_jsx_runtime6.jsxs)(Flex, { as: ImageWrapper, direction: "column", "data-changed": is2 === "from" && assetChanged ? "" : void 0, "data-error": imageError ? "" : void 0, children: [!assetIsDeleted && !imageError && (0, import_jsx_runtime6.jsx)(Image$3, { src: imageSource.toString() || "", alt: title, "data-action": metaAction, onError: setImageError, width: dimensions.width, height: dimensions.height }), (assetIsDeleted || imageError) && (0, import_jsx_runtime6.jsx)(Box, { paddingY: 5, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, align: "center", children: t3(assetIsDeleted ? "changes.image.deleted" : "changes.image.error-loading-image") }) }), (0, import_jsx_runtime6.jsx)(HotspotDiff, { children: (0, import_jsx_runtime6.jsx)(HotspotCropSVG, { crop: crop && !isDefaultCrop(crop) ? crop : void 0, diff: diff4, hash: simpleHash("".concat(imageSource.toString() || "", "-").concat(is2)), hotspot: hotspot && !isDefaultHotspot(hotspot) ? hotspot : void 0, width: dimensions.width, height: dimensions.height }) })] }) }), (0, import_jsx_runtime6.jsx)(MetaInfo, { title: title || t3("changes.image.meta-info-fallback-title"), icon: ImageIcon, markRemoved: assetChanged && is2 === "from", children: printAction ? (0, import_jsx_runtime6.jsx)("div", { children: printAction }) : (0, import_jsx_runtime6.jsxs)("div", { children: [dimensions.width, "  ", dimensions.height] }) })] });
}
var IMAGE_META_FIELDS = ["crop", "hotspot"];
var BASE_IMAGE_FIELDS = ["asset", ...IMAGE_META_FIELDS];
var CARD_STYLES = { flex: 1 };
var ImageFieldDiff = (_ref103) => {
  let { diff: diff4, schemaType } = _ref103;
  var _a4, _b4;
  const { t: t3 } = useTranslation2();
  const { fromValue, toValue, fields, isChanged } = diff4;
  const fromRef = (_a4 = fromValue == null ? void 0 : fromValue.asset) == null ? void 0 : _a4._ref;
  const toRef = (_b4 = toValue == null ? void 0 : toValue.asset) == null ? void 0 : _b4._ref;
  const assetAnnotation = getAnnotationAtPath(diff4, ["asset", "_ref"]);
  const changedFields = Object.keys(fields).filter((name) => fields[name].isChanged && name !== "_type");
  const nestedFields = schemaType.fields.filter((field) => !BASE_IMAGE_FIELDS.includes(field.name) && changedFields.includes(field.name)).map((field) => field.name);
  let assetAction = "changed";
  if (!fromRef && toRef) {
    assetAction = "added";
  } else if (!toRef && fromRef) {
    assetAction = "removed";
  }
  const didAssetChange = changedFields.includes("asset");
  const didCropChange = changedFields.includes("crop");
  const didHotspotChange = changedFields.includes("hotspot");
  const didMetaChange = didCropChange || didHotspotChange;
  const showImageDiff = didAssetChange || didMetaChange;
  const showMetaChange = didMetaChange && !didAssetChange;
  const from2 = fromValue && fromRef ? (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: (0, import_jsx_runtime6.jsx)(ImagePreview$2, { is: "from", id: fromRef, diff: diff4, action: assetAction, hotspot: showMetaChange && didHotspotChange ? fromValue.hotspot : void 0, crop: showMetaChange && didCropChange ? fromValue.crop : void 0 }) }) : (0, import_jsx_runtime6.jsx)(NoImagePreview, {});
  const to = toValue && toRef ? (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: (0, import_jsx_runtime6.jsx)(ImagePreview$2, { is: "to", id: toRef, diff: diff4, hotspot: showMetaChange && didHotspotChange ? toValue.hotspot : void 0, crop: showMetaChange && didCropChange ? toValue.crop : void 0 }) }) : (0, import_jsx_runtime6.jsx)(NoImagePreview, {});
  if (!from2 && !to) {
    return (0, import_jsx_runtime6.jsx)(Card, { padding: 4, radius: 2, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, align: "center", children: t3("changes.image.no-asset-set") }) });
  }
  if (!isChanged) {
    return toRef ? (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: (0, import_jsx_runtime6.jsx)(ImagePreview$2, { id: toRef, is: "to", diff: diff4 }) }) : null;
  }
  const imageDiff = (0, import_jsx_runtime6.jsx)(FromTo, { align: "center", from: from2, layout: "grid", to });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [showImageDiff && (didAssetChange ? (0, import_jsx_runtime6.jsx)(DiffTooltip, { annotations: assetAnnotation ? [assetAnnotation] : [], description: getChangeDescription(assetAction, t3), children: imageDiff }) : imageDiff), nestedFields.length > 0 && (0, import_jsx_runtime6.jsx)(Box, { marginTop: showImageDiff ? 4 : 3, children: (0, import_jsx_runtime6.jsx)(ChangeList, { diff: diff4, schemaType, fields: nestedFields }) })] });
};
function getChangeDescription(action, t3) {
  switch (action) {
    case "changed":
      return t3("changes.changed-label");
    case "added":
      return t3("changes.added-label");
    case "removed":
      return t3("changes.removed-label");
    default:
      return "Unknown change";
  }
}
var __freeze$2i = Object.freeze;
var __defProp$2i = Object.defineProperty;
var __template$2i = (cooked, raw) => __freeze$2i(__defProp$2i(cooked, "raw", { value: __freeze$2i(raw || cooked.slice()) }));
var _a$2i;
var NumberWrapper = st.div(_a$2i || (_a$2i = __template$2i(["\n  display: inline-block;\n  word-break: break-all;\n"])));
var NumberPreview = (props2) => {
  const { value } = props2;
  return (0, import_jsx_runtime6.jsx)(Box, { as: NumberWrapper, paddingX: 2, paddingY: 1, children: value });
};
var NumberFieldDiff = (_ref104) => {
  let { diff: diff4, schemaType } = _ref104;
  return (0, import_jsx_runtime6.jsx)(DiffFromTo, { diff: diff4, schemaType, previewComponent: NumberPreview, layout: "inline" });
};
var __freeze$2h = Object.freeze;
var __defProp$2h = Object.defineProperty;
var __template$2h = (cooked, raw) => __freeze$2h(__defProp$2h(cooked, "raw", { value: __freeze$2h(raw || cooked.slice()) }));
var _a$2h;
var Quote = st.blockquote(_a$2h || (_a$2h = __template$2h(["\n  margin: 0;\n"])));
function Blockquote(_ref105) {
  let { children } = _ref105;
  return (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Quote, { children }) });
}
var __freeze$2g = Object.freeze;
var __defProp$2g = Object.defineProperty;
var __template$2g = (cooked, raw) => __freeze$2g(__defProp$2g(cooked, "raw", { value: __freeze$2g(raw || cooked.slice()) }));
var _a$2g;
var headingSizes = { h1: 2, h2: 1, h3: 0, h4: 0, h5: 0, h6: 0 };
var StyledHeading = st(Heading)(_a$2g || (_a$2g = __template$2g(["\n  &:not([hidden]) {\n    display: inline;\n    text-transform: none;\n    margin: 0;\n\n    &::before,\n    &::after {\n      content: unset;\n    }\n  }\n"])));
function Header$1(_ref106) {
  let { style, children } = _ref106;
  return (0, import_jsx_runtime6.jsx)(StyledHeading, { size: headingSizes[style], children });
}
var __freeze$2f = Object.freeze;
var __defProp$2f = Object.defineProperty;
var __template$2f = (cooked, raw) => __freeze$2f(__defProp$2f(cooked, "raw", { value: __freeze$2f(raw || cooked.slice()) }));
var _a$2f;
var StyledParagraph = st.div(_a$2f || (_a$2f = __template$2f(["\n  text-transform: none;\n  white-space: wrap;\n  overflow-wrap: break-word;\n  margin: 0;\n"])));
function Paragraph(_ref107) {
  let { children } = _ref107;
  return (0, import_jsx_runtime6.jsx)(StyledParagraph, { children });
}
var EMPTY_PATH3 = [];
function Block(props2) {
  var _a4, _b4, _c4;
  const { diff: diff4, block, children } = props2;
  const color3 = useDiffAnnotationColor(diff4, EMPTY_PATH3);
  const { path: fullPath } = (0, import_react51.useContext)(DiffContext);
  const { onSetFocus } = (0, import_react51.useContext)(ConnectorContext);
  const { t: t3 } = useTranslation2();
  const isRemoved = diff4.action === "removed";
  let returned = children;
  const handleClick = (0, import_react51.useCallback)((event) => {
    event.stopPropagation();
    if (!isRemoved) {
      onSetFocus(fullPath);
    }
  }, [fullPath, isRemoved, onSetFocus]);
  if (block.style === "blockquote") {
    returned = (0, import_jsx_runtime6.jsx)(Blockquote, { children: returned });
  } else if (block.style && isHeader(block)) {
    returned = (0, import_jsx_runtime6.jsx)(Header$1, { style: block.style, children: returned });
  } else {
    returned = (0, import_jsx_runtime6.jsx)(Paragraph, { children: returned });
  }
  let fromStyle;
  if (diff4.origin.action === "changed" && diff4.origin.fields.style && diff4.origin.fields.style.action === "changed" && diff4.origin.fields.style.annotation) {
    fromStyle = (_b4 = (_a4 = diff4 == null ? void 0 : diff4.origin) == null ? void 0 : _a4.fromValue) == null ? void 0 : _b4.style;
    const style = color3 ? { background: color3.background, color: color3.text } : {};
    returned = (0, import_jsx_runtime6.jsx)(Card, { padding: 3, border: true, radius: 2, style: { borderStyle: "dotted" }, "diff-block-action": diff4.action, "data-block-note": "changed_from_style_".concat(fromStyle || "undefined"), children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(DiffTooltip, { annotations: [(_c4 = diff4.origin.fields.style) == null ? void 0 : _c4.annotation], diff: diff4.origin.fields.style, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 0, children: t3("changes.portable-text.block-style-changed", { fromStyle, toStyle: block.style }) }) }), (0, import_jsx_runtime6.jsx)(Box, { style, children: returned })] }) });
  }
  return (0, import_jsx_runtime6.jsx)("div", { onClick: handleClick, "data-diff-block-action": diff4.action, "data-block-note": "changed_from_style_".concat(fromStyle || "undefined"), children: returned });
}
var __freeze$2e = Object.freeze;
var __defProp$2e = Object.defineProperty;
var __template$2e = (cooked, raw) => __freeze$2e(__defProp$2e(cooked, "raw", { value: __freeze$2e(raw || cooked.slice()) }));
var _a$2e;
var _b$11;
var _c$A;
var _d$m;
var InlineBox = st(Box)(_a$2e || (_a$2e = __template$2e(["\n  &:not([hidden]) {\n    display: inline;\n    align-items: center;\n\n    &[data-changed] {\n      cursor: pointer;\n    }\n  }\n"])));
var InlineText = st(Text3)(_b$11 || (_b$11 = __template$2e(["\n  &:not([hidden]) {\n    display: inline;\n    color: inherit;\n  }\n"])));
var PreviewContainer$1 = st(Box)(_c$A || (_c$A = __template$2e(["\n  &:not([hidden]) {\n    display: inline-flex;\n    align-items: center;\n\n    ", ' [data-ui="Text"] {\n      opacity: 0.5;\n    }\n  }\n'])), InlineBox);
var PopoverContainer = st(Box)(_d$m || (_d$m = __template$2e(["\n  min-width: 160px;\n  max-height: 40vh;\n  overflow-y: auto;\n"])));
var __freeze$2d = Object.freeze;
var __defProp$2d = Object.defineProperty;
var __template$2d = (cooked, raw) => __freeze$2d(__defProp$2d(cooked, "raw", { value: __freeze$2d(raw || cooked.slice()) }));
var _a$2d;
var AnnotationWrapper = st.div(_a$2d || (_a$2d = __template$2d(["\n  text-decoration: none;\n  display: inline;\n  position: relative;\n  border: 0;\n  padding: 0;\n  border-bottom: 2px dotted currentColor;\n  box-shadow: inset 0 0 0 1px var(--card-border-color);\n  white-space: nowrap;\n  align-items: center;\n  background-color: color(var(--card-fg-color) a(10%));\n\n  &[data-changed] {\n    cursor: pointer;\n  }\n\n  &[data-removed] {\n    text-decoration: line-through;\n  }\n\n  &:hover ", " {\n    opacity: 1;\n  }\n"])), PreviewContainer$1);
function Annotation$1(_ref108) {
  let { children, diff: diff4, object: object2, schemaType, path: path2, ...restProps } = _ref108;
  const { t: t3 } = useTranslation2();
  if (!schemaType) {
    return (0, import_jsx_runtime6.jsx)(AnnotationWrapper, { ...restProps, children: t3("changes.portable-text.unknown-annotation-schema-type") });
  }
  if (diff4 && diff4.action !== "unchanged") {
    return (0, import_jsx_runtime6.jsx)(AnnnotationWithDiff, { ...restProps, diff: diff4, object: object2, schemaType, path: path2, children });
  }
  return (0, import_jsx_runtime6.jsx)(AnnotationWrapper, { children });
}
function AnnnotationWithDiff(_ref109) {
  let { diff: diff4, children, object: object2, schemaType, path: path2, ...restProps } = _ref109;
  const { onSetFocus } = (0, import_react51.useContext)(ConnectorContext);
  const { path: fullPath } = (0, import_react51.useContext)(DiffContext);
  const [popoverElement, setPopoverElement] = (0, import_react51.useState)(null);
  const { t: t3 } = useTranslation2();
  const color3 = useDiffAnnotationColor(diff4, []);
  const style = (0, import_react51.useMemo)(() => color3 ? { background: color3.background, color: color3.text } : {}, [color3]);
  const isRemoved = diff4.action === "removed";
  const [open, setOpen] = (0, import_react51.useState)(false);
  const emptyObject = object2 && isEmptyObject(object2);
  const markDefPath = (0, import_react51.useMemo)(() => [path2[0]].concat(["markDefs", { _key: object2._key }]), [object2._key, path2]);
  const prefix = (0, import_react51.useMemo)(() => fullPath.slice(0, fullPath.findIndex((seg) => isKeySegment(seg) && seg._key === object2._key)), [fullPath, object2._key]);
  const annotationPath = (0, import_react51.useMemo)(() => prefix.concat(path2), [path2, prefix]);
  const myPath = (0, import_react51.useMemo)(() => prefix.concat(markDefPath), [markDefPath, prefix]);
  const myValue = "field-".concat(toString(myPath));
  const values2 = useReportedValues$1();
  const isEditing = (0, import_react51.useMemo)(() => values2.filter((_ref110) => {
    let [p] = _ref110;
    return p.startsWith(myValue);
  }).length > 0, [myValue, values2]);
  (0, import_react51.useEffect)(() => {
    if (!open && isEditing) {
      setOpen(true);
      onSetFocus(myPath);
    }
  }, [isEditing, myPath, onSetFocus, open]);
  const handleOpenPopup = (0, import_react51.useCallback)((event) => {
    event.stopPropagation();
    setOpen(true);
    if (!isRemoved) {
      event.preventDefault();
      onSetFocus(annotationPath);
      setTimeout(() => onSetFocus(myPath), 10);
    }
  }, [annotationPath, isRemoved, myPath, onSetFocus]);
  const handleClickOutside = (0, import_react51.useCallback)(() => {
    if (!isEditing) {
      setOpen(false);
    }
  }, [isEditing]);
  useClickOutside(handleClickOutside, [popoverElement]);
  const annotation = diff4.action !== "unchanged" && diff4.annotation || null;
  const annotations = (0, import_react51.useMemo)(() => annotation ? [annotation] : [], [annotation]);
  const popoverContent = (0, import_jsx_runtime6.jsx)(DiffContext.Provider, { value: { path: myPath }, children: (0, import_jsx_runtime6.jsx)(PopoverContainer, { padding: 3, children: (0, import_jsx_runtime6.jsxs)("div", { children: [emptyObject && (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("changes.portable-text.empty-object-annotation", { annotationType: schemaType.title || schemaType.name }) }), !emptyObject && (0, import_jsx_runtime6.jsx)(ChangeList, { diff: diff4, schemaType })] }) }) });
  return (0, import_jsx_runtime6.jsx)(AnnotationWrapper, { ...restProps, onClick: handleOpenPopup, style, "data-changed": "", "data-removed": diff4.action === "removed" ? "" : void 0, children: (0, import_jsx_runtime6.jsx)(Popover, { content: popoverContent, open, ref: setPopoverElement, portal: true, children: (0, import_jsx_runtime6.jsx)(PreviewContainer$1, { paddingLeft: 1, children: (0, import_jsx_runtime6.jsx)(DiffTooltip, { annotations, description: t3("changes.portable-text.annotation", { context: diff4.action }), children: (0, import_jsx_runtime6.jsxs)(InlineBox, { style: { display: "inline-flex" }, children: [(0, import_jsx_runtime6.jsx)("span", { children }), (0, import_jsx_runtime6.jsx)(Flex, { align: "center", paddingX: 1, children: (0, import_jsx_runtime6.jsx)(InlineText, { size: 0, children: (0, import_jsx_runtime6.jsx)(ChevronDownIcon, {}) }) })] }) }) }) }) });
}
var __freeze$2c = Object.freeze;
var __defProp$2c = Object.defineProperty;
var __template$2c = (cooked, raw) => __freeze$2c(__defProp$2c(cooked, "raw", { value: __freeze$2c(raw || cooked.slice()) }));
var _a$2c;
var DecoratorWrapper = st.span(_a$2c || (_a$2c = __template$2c(["\n  display: inline;\n  ", "\n"])), (_ref111) => {
  let { theme, decoration } = _ref111;
  switch (decoration) {
    case "strong":
      return "font-weight: bold;";
    case "em":
      return "font-style: italic;";
    case "underline":
      return "text-decoration: underline;";
    case "overline":
      return "text-decoration: overline;";
    case "strike-through":
      return "text-decoration: line-through;";
    case "code":
      return "\n          font-family: ".concat(theme.sanity.fonts.code.family, ";\n          background: ").concat(theme.sanity.color.muted.default.enabled.bg, ";\n        ");
    default:
      return "";
  }
});
function Decorator$1(_ref112) {
  let { mark, children } = _ref112;
  return (0, import_jsx_runtime6.jsx)(DecoratorWrapper, { decoration: mark, children });
}
var __freeze$2b = Object.freeze;
var __defProp$2b = Object.defineProperty;
var __template$2b = (cooked, raw) => __freeze$2b(__defProp$2b(cooked, "raw", { value: __freeze$2b(raw || cooked.slice()) }));
var _a$2b;
var InlineObjectWrapper = st(Card)(_a$2b || (_a$2b = __template$2b(["\n  &:not([hidden]) {\n    display: inline;\n    cursor: pointer;\n    white-space: nowrap;\n    align-items: center;\n\n    &[data-removed] {\n      text-decoration: line-through;\n    }\n\n    ", " {\n      display: inline-flex;\n    }\n  }\n"])), InlineBox);
function InlineObject$1(_ref113) {
  let { diff: diff4, object: object2, schemaType, ...restProps } = _ref113;
  const { t: t3 } = useTranslation2();
  if (!schemaType) {
    return (0, import_jsx_runtime6.jsx)(InlineObjectWrapper, { ...restProps, border: true, radius: 1, children: t3("changes.portable-text.unknown-inline-object-schema-type", { schemaType: object2._type }) });
  }
  if (diff4) {
    return (0, import_jsx_runtime6.jsx)(InlineObjectWithDiff, { ...restProps, diff: diff4, object: object2, schemaType });
  }
  return (0, import_jsx_runtime6.jsx)(InlineObjectWrapper, { children: (0, import_jsx_runtime6.jsx)(Preview, { schemaType, value: object2, layout: "inline" }) });
}
function InlineObjectWithDiff(_ref114) {
  let { diff: diff4, object: object2, path: path2, schemaType, ...restProps } = _ref114;
  const { path: fullPath } = (0, import_react51.useContext)(DiffContext);
  const { onSetFocus } = (0, import_react51.useContext)(ConnectorContext);
  const { t: t3 } = useTranslation2();
  const color3 = useDiffAnnotationColor(diff4, []);
  const style = (0, import_react51.useMemo)(() => color3 ? { background: color3.background, color: color3.text } : {}, [color3]);
  const [open, setOpen] = (0, import_react51.useState)(false);
  const emptyObject = object2 && isEmptyObject(object2);
  const isRemoved = diff4.action === "removed";
  const prefix = fullPath.slice(0, fullPath.findIndex((seg) => isKeySegment(seg) && seg._key === object2._key));
  const myPath = prefix.concat(path2);
  const myValue = "field-".concat(toString(myPath));
  const values2 = useReportedValues$1();
  const isEditing = values2.filter((_ref115) => {
    let [p] = _ref115;
    return p.startsWith(myValue);
  }).length > 0;
  const focusPath = fullPath.slice(0, -1).concat(path2).concat([FOCUS_TERMINATOR]);
  (0, import_react51.useEffect)(() => {
    if (isEditing) {
      setOpen(true);
      onSetFocus(focusPath);
    }
  }, [focusPath, isEditing, onSetFocus]);
  const handleOpenPopup = (0, import_react51.useCallback)((event) => {
    event.stopPropagation();
    setOpen(true);
    if (!isRemoved) {
      onSetFocus(focusPath);
      return;
    }
    event.preventDefault();
  }, [focusPath, isRemoved, onSetFocus]);
  const handleClose = (0, import_react51.useCallback)(() => {
    setOpen(false);
  }, []);
  const popoverContent = (0, import_jsx_runtime6.jsx)(DiffContext.Provider, { value: { path: myPath }, children: (0, import_jsx_runtime6.jsx)(PopoverContent, { diff: diff4, emptyObject, onClose: handleClose, schemaType }) });
  const annotation = diff4.action !== "unchanged" && diff4.annotation || null;
  const annotations = annotation ? [annotation] : [];
  return (0, import_jsx_runtime6.jsx)(InlineObjectWrapper, { ...restProps, onClick: handleOpenPopup, style, "data-removed": diff4.action === "removed" ? "" : void 0, border: true, radius: 2, children: (0, import_jsx_runtime6.jsx)(Popover, { content: popoverContent, open, portal: true, children: (0, import_jsx_runtime6.jsx)(PreviewContainer$1, { children: (0, import_jsx_runtime6.jsx)(DiffTooltip, { annotations, description: t3("changes.portable-text.inline-object", { context: diff4.action }), children: (0, import_jsx_runtime6.jsxs)(InlineBox, { children: [(0, import_jsx_runtime6.jsx)(Preview, { schemaType, value: object2, layout: "inline" }), (0, import_jsx_runtime6.jsx)(Flex, { align: "center", paddingX: 1, children: (0, import_jsx_runtime6.jsx)(InlineText, { size: 0, children: (0, import_jsx_runtime6.jsx)(ChevronDownIcon, {}) }) })] }) }) }) }) });
}
function PopoverContent(_ref116) {
  let { diff: diff4, emptyObject, onClose, schemaType } = _ref116;
  const { t: t3 } = useTranslation2();
  const [popoverElement, setPopoverElement] = (0, import_react51.useState)(null);
  useClickOutside(onClose, [popoverElement]);
  return (0, import_jsx_runtime6.jsxs)(PopoverContainer, { ref: setPopoverElement, padding: 3, children: [emptyObject && (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("changes.portable-text.empty-inline-object", { inlineObjectType: schemaType.title || schemaType.name }) }), !emptyObject && (0, import_jsx_runtime6.jsx)(ChangeList, { diff: diff4, schemaType })] });
}
function Text4(_ref117) {
  let { diff: diff4, childDiff, children, path: path2, segment, ...restProps } = _ref117;
  const diffWithFallback = diff4 || childDiff;
  const hasChanged = diffWithFallback && diffWithFallback.action !== "unchanged" && segment.action !== "unchanged";
  if (hasChanged) {
    return (0, import_jsx_runtime6.jsx)(TextWithDiff, { ...restProps, childDiff, diff: diff4, segment, path: path2, children });
  }
  return (0, import_jsx_runtime6.jsx)(InlineBox, { children });
}
function TextWithDiff(_ref118) {
  let { diff: diff4, childDiff, children, path: path2, segment, ...restProps } = _ref118;
  const { onSetFocus } = (0, import_react51.useContext)(ConnectorContext);
  const { path: fullPath } = (0, import_react51.useContext)(DiffContext);
  const spanSegment = (0, import_react51.useMemo)(() => path2.slice(-2, 1)[0], [path2]);
  const { t: t3 } = useTranslation2();
  const isRemoved = diff4 && diff4.action === "removed";
  const prefix = fullPath.slice(0, fullPath.findIndex((seg) => isKeySegment(seg) && isKeySegment(spanSegment) && seg._key === spanSegment._key));
  const focusPath = prefix.concat(path2);
  const handleClick = (0, import_react51.useCallback)((event) => {
    event.stopPropagation();
    if (!isRemoved) {
      event.preventDefault();
      onSetFocus(focusPath);
    }
  }, [focusPath, isRemoved, onSetFocus]);
  const realSeg = diff4 && diff4.segments.find((rSeg) => rSeg.text === segment.text);
  const diffWithFallback = realSeg || diff4 || childDiff;
  const annotation = diffWithFallback && diffWithFallback.action !== "unchanged" && diffWithFallback.annotation || null;
  const diffCard = annotation && segment.action !== "unchanged" ? (0, import_jsx_runtime6.jsx)(DiffCard, { annotation, as: segment.action === "removed" ? "del" : "ins", tooltip: { description: t3("changes.portable-text.text", { context: segment.action }) }, children }) : null;
  return (0, import_jsx_runtime6.jsx)(InlineBox, { ...restProps, onClick: handleClick, "data-changed": "", children: (0, import_jsx_runtime6.jsx)("span", { children: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: diffCard || children }) }) });
}
var decoratorSymbolsStart = DECORATOR_SYMBOLS.map((set4) => set4[0]);
var decoratorSymbolsEnd = DECORATOR_SYMBOLS.map((set4) => set4[1]);
var annotationSymbolsStart = ANNOTATION_SYMBOLS.map((set4) => set4[0]);
var annotationSymbolsEnd = ANNOTATION_SYMBOLS.map((set4) => set4[1]);
var allSymbolsStart = decoratorSymbolsStart.concat(annotationSymbolsStart);
var allSymbolsEnd = decoratorSymbolsEnd.concat(annotationSymbolsEnd);
var allDecoratorSymbols = decoratorSymbolsStart.concat(decoratorSymbolsEnd);
var markRegex = new RegExp("".concat(allDecoratorSymbols.concat(allSymbolsEnd).join("|")), "g");
function PortableText(props2) {
  const { diff: diff4, schemaType } = props2;
  const block = diff4.origin.toValue || diff4.origin.fromValue;
  const { t: t3 } = useTranslation2();
  const inlineObjects = (0, import_react51.useMemo)(() => diff4.origin.toValue ? getInlineObjects(diff4.origin) : [], [diff4.origin]);
  const renderChild = (0, import_react51.useCallback)((ptDiffChild) => {
    const spanSchemaType = getChildSchemaType(schemaType.fields, ptDiffChild);
    let decoratorTypes = [];
    if (spanSchemaType) {
      decoratorTypes = getDecorators(spanSchemaType);
      const childrenDiff = diff4.fields.children;
      const segments = childrenDiff.items[0].diff && childrenDiff.items[0].diff.type === "object" && childrenDiff.items[0].diff.fields.text.type === "string" && childrenDiff.items[0].diff.fields.text.segments || [];
      const returnedChildren = [];
      const annotationSegments = {};
      if (isEmptyTextChange(block, diff4) && (diff4.origin.action === "added" || diff4.origin.action === "removed")) {
        const textDiff = findChildDiff(diff4.origin, block.children[0]) || diff4.origin;
        if (textDiff && textDiff.action !== "unchanged") {
          return (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: textDiff.annotation, as: textDiff.action === "removed" ? "del" : "ins", tooltip: { description: t3("changes.portable-text.empty-text", { context: textDiff.action }) }, children: (0, import_jsx_runtime6.jsx)("span", { children: EMPTY_BLOCK_SYMBOL }) }, "empty-block-".concat(block._key));
        }
      }
      let childToIndex = -1;
      let segIndex = -1;
      const activeAnnotations = [];
      let endedAnnotation;
      const allMarkDefs = getAllMarkDefs(diff4.origin);
      segments.forEach((seg) => {
        var _a4, _b4, _c4;
        segIndex++;
        const isInline = INLINE_SYMBOLS.includes(seg.text);
        const isMarkStart = allSymbolsStart.includes(seg.text);
        const isMarkEnd = allSymbolsEnd.includes(seg.text);
        const isChildStart = seg.text === CHILD_SYMBOL;
        const isRemoved = seg.action === "removed";
        if (isChildStart) {
          if (!isRemoved) {
            childToIndex++;
          }
        } else if (isMarkStart || isMarkEnd) {
          if (isMarkStart && annotationSymbolsStart.includes(seg.text)) {
            const object2 = allMarkDefs[annotationSymbolsStart.indexOf(seg.text)];
            if (object2) {
              activeAnnotations.push({ mark: object2._key, symbols: [seg.text, annotationSymbolsEnd[annotationSymbolsStart.indexOf(seg.text)]], object: object2 });
            }
          }
          if (isMarkEnd && annotationSymbolsEnd.includes(seg.text)) {
            endedAnnotation = activeAnnotations.pop();
          }
        } else if (isInline) {
          const indexOfSymbol = INLINE_SYMBOLS.findIndex((sym) => sym === seg.text);
          const key2 = (_a4 = inlineObjects[indexOfSymbol]) == null ? void 0 : _a4._key;
          const originChild = inlineObjects[indexOfSymbol];
          if (key2) {
            const objectSchemaType = getChildSchemaType(schemaType.fields, originChild);
            const objectDiff = findChildDiff(diff4.origin, originChild);
            returnedChildren.push((0, import_jsx_runtime6.jsx)(InlineObject$1, { object: originChild, path: [{ _key: block._key }, "children", { _key: originChild._key }], diff: objectDiff, schemaType: objectSchemaType }, "inline-object-".concat(originChild._key)));
          }
        } else if (seg.text) {
          const getChildFromFromValue = () => {
            var _a22;
            return (_a22 = diff4.origin.fromValue) == null ? void 0 : _a22.children.find((cld) => cld.text && cld.text.match(escapeRegExp2(seg.text)));
          };
          const child = block.children[childToIndex] || getChildFromFromValue();
          const childDiff = child && findSpanDiffFromChild(diff4.origin, child);
          if (!child) {
            throw new Error("Could not find child");
          }
          const textDiff = ((_b4 = childDiff == null ? void 0 : childDiff.fields) == null ? void 0 : _b4.text) ? (_c4 = childDiff == null ? void 0 : childDiff.fields) == null ? void 0 : _c4.text : void 0;
          const text = (0, import_jsx_runtime6.jsx)(Text4, { diff: textDiff, path: [{ _key: block._key }, "children", { _key: child._key }], childDiff, segment: seg, children: renderTextSegment({ diff: diff4, child, decoratorTypes, seg, segIndex, spanSchemaType, t: t3 }) }, "text-".concat(child._key, "-").concat(segIndex));
          if (activeAnnotations.length > 0) {
            activeAnnotations.forEach((active) => {
              annotationSegments[active.mark] = annotationSegments[active.mark] || [];
              annotationSegments[active.mark].push(text);
            });
          }
          if (endedAnnotation) {
            const key2 = "annotation-".concat(endedAnnotation.object._key);
            const lastChild = returnedChildren[returnedChildren.length - 1];
            if (lastChild && lastChild.key !== key2) {
              const annotationDiff = findAnnotationDiff(diff4.origin, endedAnnotation.mark);
              const objectSchemaType = endedAnnotation && spanSchemaType.annotations && spanSchemaType.annotations.find((type) => endedAnnotation && endedAnnotation.object && type.name === endedAnnotation.object._type);
              returnedChildren.push((0, import_jsx_runtime6.jsx)(Annotation$1, { object: endedAnnotation.object, diff: annotationDiff, path: [{ _key: block._key }, "children", { _key: child._key }], schemaType: objectSchemaType, children: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: annotationSegments[endedAnnotation.mark] }) }, key2));
            }
            endedAnnotation = void 0;
          }
          if (activeAnnotations.length === 0) {
            returnedChildren.push(text);
          }
        }
      });
      return import_react51.default.createElement("div", { key: block._key }, ...returnedChildren);
    }
    throw new Error("'span' schemaType not found");
  }, [block, diff4, inlineObjects, schemaType, t3]);
  return (0, import_jsx_runtime6.jsx)(Block, { block: diff4.displayValue, diff: diff4, children: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (diff4.displayValue.children || []).map((child) => renderChild(child)) }) });
}
function renderTextSegment(_ref119) {
  let { diff: diff4, child, decoratorTypes, seg, segIndex, spanSchemaType, t: t3 } = _ref119;
  if (seg.text === "\n") {
    return (0, import_jsx_runtime6.jsx)("br", {});
  }
  let children = (0, import_jsx_runtime6.jsx)("span", { children: seg.text.replace(/ /g, TRAILING_SPACE_SYMBOL) }, "text-".concat(segIndex));
  const spanDiff = child && findSpanDiffFromChild(diff4.origin, child);
  const activeMarks = isPortableTextSpan(child) ? child.marks || [] : [];
  if (spanDiff) {
    children = renderDecorators({ activeMarks, decoratorTypes, diff: diff4, children, seg, segIndex, spanDiff, spanSchemaType, t: t3 });
  }
  if (activeMarks && activeMarks.length > 0) {
    activeMarks.forEach((mark) => {
      if (isDecorator(mark, spanSchemaType)) {
        children = // eslint-disable-next-line react/no-array-index-key
        (0, import_jsx_runtime6.jsx)(Decorator$1, { mark, children }, "decorator-".concat(mark, "-").concat(child._key, "-").concat(segIndex));
      }
    });
  }
  return children;
}
function renderDecorators(_ref120) {
  let { activeMarks, decoratorTypes, diff: diff4, children, seg, segIndex, spanDiff, spanSchemaType, t: t3 } = _ref120;
  var _a4;
  let returned = (0, import_jsx_runtime6.jsx)("span", { children }, "text-segment-".concat(segIndex));
  const fromPtDiffText = diff4.origin.fromValue && diff4.fromValue && diff4.fromValue.children[0].text || "";
  const indirectMarksAnnotation = spanDiff && spanDiff.action !== "unchanged" && spanDiff.annotation || void 0;
  const marksDiff = (_a4 = spanDiff == null ? void 0 : spanDiff.fields) == null ? void 0 : _a4.marks;
  const marksAnnotation = marksDiff && marksDiff.action !== "unchanged" && marksDiff.annotation || indirectMarksAnnotation;
  let marksChanged = [];
  const ptDiffChildren = fromPtDiffText.split(CHILD_SYMBOL).filter((text) => !!text).join("");
  const ptDiffMatchString = ptDiffChildren;
  const controlString = ptDiffMatchString.substring(0, ptDiffMatchString.indexOf(seg.text) + seg.text.length);
  const toTest = controlString.substring(0, controlString.indexOf(seg.text));
  const marks = [];
  const matches = [...toTest.matchAll(markRegex)];
  matches.forEach((match4) => {
    var _a22;
    const sym = match4[0];
    const set4 = DECORATOR_SYMBOLS.concat(ANNOTATION_SYMBOLS).find((aSet) => aSet.indexOf(sym) > -1);
    if (set4) {
      const isMarkStart = sym === set4[0];
      const mark = ((_a22 = decoratorTypes[isMarkStart ? decoratorSymbolsStart.indexOf(sym) : decoratorSymbolsEnd.indexOf(sym)]) == null ? void 0 : _a22.value) || sym;
      const notClosed = toTest.lastIndexOf(sym) > toTest.lastIndexOf(set4[1]);
      if (notClosed) {
        marks.push(mark);
      }
    }
  });
  marksChanged = (0, import_xor.default)(activeMarks, (0, import_uniq4.default)(marks));
  if (marksAnnotation && marksChanged.length > 0 && marksChanged.some((m2) => isDecorator(m2, spanSchemaType))) {
    returned = (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: marksAnnotation, as: "ins", tooltip: { description: t3("changes.portable-text.changed-formatting") }, children: returned }, "diffcard-annotation-".concat(segIndex, "-").concat(marksChanged.join("-")));
  }
  return returned;
}
function isEmptyTextChange(block, diff4) {
  return block.children.length === 1 && block.children[0]._type === "span" && typeof block.children[0].text === "string" && block.children[0].text === "" && diff4.origin.action !== "unchanged";
}
var PTDiff = (props2) => {
  const { diff: diff4, schemaType } = props2;
  const ptDiff = (0, import_react51.useMemo)(() => createPortableTextDiff(diff4, schemaType), [diff4, schemaType]);
  return (0, import_jsx_runtime6.jsx)("div", { "data-diff-action": diff4.action, children: (0, import_jsx_runtime6.jsx)(PortableText, { diff: ptDiff, schemaType }) });
};
var __freeze$2a = Object.freeze;
var __defProp$2a = Object.defineProperty;
var __template$2a = (cooked, raw) => __freeze$2a(__defProp$2a(cooked, "raw", { value: __freeze$2a(raw || cooked.slice()) }));
var _a$2a;
var ReferenceWrapper = st.div(_a$2a || (_a$2a = __template$2a(["\n  word-wrap: break-word;\n"])));
var ReferencePreview$1 = (_ref121) => {
  let { value, schemaType } = _ref121;
  return (0, import_jsx_runtime6.jsx)(Box, { as: ReferenceWrapper, padding: 2, children: (0, import_jsx_runtime6.jsx)(Preview, { schemaType, value, layout: "default" }) });
};
var ReferenceFieldDiff = (_ref122) => {
  let { diff: diff4, schemaType } = _ref122;
  return (0, import_jsx_runtime6.jsx)(DiffFromTo, { align: "center", diff: diff4, layout: "grid", path: "_ref", previewComponent: ReferencePreview$1, schemaType });
};
var __freeze$29 = Object.freeze;
var __defProp$29 = Object.defineProperty;
var __template$29 = (cooked, raw) => __freeze$29(__defProp$29(cooked, "raw", { value: __freeze$29(raw || cooked.slice()) }));
var _a$29;
var StringWrapper$1 = st.div(_a$29 || (_a$29 = __template$29(["\n  display: inline-block;\n  word-break: break-all;\n  white-space: pre-wrap;\n"])));
var StringPreview = (props2) => {
  const { value } = props2;
  return (0, import_jsx_runtime6.jsx)(Box, { as: StringWrapper$1, paddingX: 2, paddingY: 1, children: value });
};
var __freeze$28 = Object.freeze;
var __defProp$28 = Object.defineProperty;
var __template$28 = (cooked, raw) => __freeze$28(__defProp$28(cooked, "raw", { value: __freeze$28(raw || cooked.slice()) }));
var _a$28;
var StringWrapper2 = st.div(_a$28 || (_a$28 = __template$28(["\n  white-space: pre-wrap;\n  word-wrap: break-word;\n"])));
var StringFieldDiff = (_ref123) => {
  let { diff: diff4, schemaType } = _ref123;
  const { options } = schemaType;
  if (options == null ? void 0 : options.list) {
    return (0, import_jsx_runtime6.jsx)(DiffFromTo, { diff: diff4, previewComponent: StringPreview, schemaType });
  }
  return (0, import_jsx_runtime6.jsx)(StringWrapper2, { children: (0, import_jsx_runtime6.jsx)(DiffString, { diff: diff4 }) });
};
var defaultComponents = { block: PTDiff, boolean: { component: BooleanFieldDiff, showHeader: false }, date: DatetimeFieldDiff, datetime: DatetimeFieldDiff, file: FileFieldDiff, image: ImageFieldDiff, number: NumberFieldDiff, reference: ReferenceFieldDiff, string: StringFieldDiff };
function resolveDiffComponent(type, parentSchemaType) {
  var _a4;
  let itType = type;
  while (itType) {
    const resolved = ((_a4 = itType == null ? void 0 : itType.components) == null ? void 0 : _a4.diff) || tryResolve(itType, parentSchemaType) || defaultComponents[itType.name];
    if (resolved) {
      return resolved;
    }
    itType = itType.type;
  }
  const isDateType = ["date", "datetime"].includes(type.name);
  const defaultComponentKey = isDateType ? type.name : type.jsonType;
  return defaultComponents[defaultComponentKey];
}
function tryResolve(schemaType, parentSchemaType) {
  const resolvers = diffResolvers;
  let resolved;
  for (const resolver of resolvers) {
    if (typeof resolver !== "function") {
      console.error("Diff component resolver is not a function: ", resolver);
      continue;
    }
    resolved = resolver({ schemaType, parentSchemaType });
    if (resolved) {
      return resolved;
    }
  }
  return void 0;
}
function noop$2() {
}
function isFieldChange(change) {
  return change.type === "field";
}
function isGroupChange(change) {
  return change.type === "group";
}
function isAddedItemDiff(item) {
  return item.diff.action === "added";
}
function isRemovedItemDiff(item) {
  return item.diff.action === "removed";
}
function isUnchangedDiff(diff4) {
  return diff4.action === "unchanged";
}
function buildChangeList(schemaType, diff4) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  let titlePath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  let context = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const diffComponent = resolveDiffComponent(schemaType, context.parentSchema);
  if (!diffComponent) {
    if (schemaType.jsonType === "object" && diff4.type === "object") {
      return buildObjectChangeList(schemaType, diff4, path2, titlePath, context);
    }
    if (schemaType.jsonType === "array" && diff4.type === "array") {
      return buildArrayChangeList(schemaType, diff4, path2, titlePath);
    }
  }
  return getFieldChange(schemaType, diff4, path2, titlePath, context);
}
function buildObjectChangeList(schemaType, diff4) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  let titlePath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  let diffContext = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const changes = [];
  const childContext = { ...diffContext, parentSchema: schemaType };
  const fieldSets = schemaType.fieldsets || schemaType.fields.map((field) => ({ single: true, field }));
  for (const fieldSet of fieldSets) {
    if (fieldSet.single) {
      changes.push(...buildFieldChange(fieldSet.field, diff4, path2, titlePath, childContext));
    } else {
      changes.push(...buildFieldsetChangeList(fieldSet, diff4, path2, titlePath, childContext));
    }
  }
  if (changes.length < 2) {
    return changes;
  }
  return [{ type: "group", key: pathToString2(path2) || "root", path: path2, titlePath, changes: reduceTitlePaths(changes, titlePath.length), schemaType }];
}
function buildFieldChange(field, diff4, path2, titlePath) {
  let diffContext = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const { fieldFilter, ...context } = diffContext;
  const fieldDiff = diff4.fields[field.name];
  if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name)) {
    return [];
  }
  const fieldPath = path2.concat([field.name]);
  const fieldTitlePath = titlePath.concat([field.type.title || field.name]);
  return buildChangeList(field.type, fieldDiff, fieldPath, fieldTitlePath, context);
}
function buildFieldsetChangeList(fieldSet, diff4, path2, titlePath) {
  let diffContext = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const { fields, name, title, readOnly, hidden } = fieldSet;
  const { fieldFilter, ...context } = diffContext;
  const fieldSetHidden = hidden;
  const fieldsetReadOnly = readOnly;
  const fieldSetTitlePath = titlePath.concat([title || name]);
  const changes = [];
  for (const field of fields) {
    const fieldDiff = diff4.fields[field.name];
    if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name)) {
      continue;
    }
    const fieldPath = path2.concat([field.name]);
    const fieldTitlePath = fieldSetTitlePath.concat([field.type.title || field.name]);
    changes.push(...buildChangeList({ readOnly: fieldsetReadOnly, hidden: fieldSetHidden, ...field.type }, fieldDiff, fieldPath, fieldTitlePath, context));
  }
  if (changes.length < 2) {
    return changes;
  }
  return [{ type: "group", key: pathToString2(path2) || "root", fieldsetName: name, path: path2, titlePath: fieldSetTitlePath, changes: reduceTitlePaths(changes, fieldSetTitlePath.length), readOnly: fieldsetReadOnly, hidden: fieldSetHidden }];
}
function buildArrayChangeList(schemaType, diff4) {
  let path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  let titlePath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  const changedOrMoved = diff4.items.filter((item) => item.hasMoved && item.fromIndex !== item.toIndex || item.diff.action !== "unchanged");
  if (changedOrMoved.length === 0) {
    return [];
  }
  const isPortableText2 = hasPTMemberType(schemaType);
  const list = [];
  const changes = changedOrMoved.reduce((acc, itemDiff) => {
    const memberTypes = getArrayDiffItemType(itemDiff.diff, schemaType);
    const memberType = memberTypes.toType || memberTypes.fromType;
    if (!memberType) {
      console.warn("Could not determine schema type for item at %s", pathToString2(path2));
      return acc;
    }
    const segment = getItemKeySegment(itemDiff.diff.fromValue) || getItemKeySegment(itemDiff.diff.toValue) || diff4.items.indexOf(itemDiff);
    const itemPath = path2.concat(segment);
    const itemContext = { itemDiff, parentDiff: diff4, parentSchema: schemaType };
    const itemTitlePath = titlePath.concat({ hasMoved: itemDiff.hasMoved, toIndex: itemDiff.toIndex, fromIndex: itemDiff.fromIndex, annotation: itemDiff.diff.action === "unchanged" ? itemDiff.annotation : itemDiff.diff.annotation });
    const attachItemDiff = (change) => {
      if (change.type === "field" && pathsAreEqual(itemPath, change.path)) {
        change.itemDiff = itemDiff;
      }
      return change;
    };
    const children = buildChangeList(memberType, itemDiff.diff, itemPath, itemTitlePath, itemContext).map(attachItemDiff);
    if (isPortableText2) {
      children.filter(isFieldChange).forEach((field, index, siblings) => {
        field.showHeader = siblings.length === 1;
        field.showIndex = itemDiff.fromIndex !== itemDiff.toIndex && itemDiff.hasMoved;
      });
    }
    if (children.length === 0) {
      acc.push(...getFieldChange(memberType, itemDiff.diff, itemPath, itemTitlePath, itemContext));
    } else {
      acc.push(...children);
    }
    return acc;
  }, list);
  if (changes.length > 1) {
    return [{ type: "group", key: pathToString2(path2) || "root", path: path2, titlePath, changes: reduceTitlePaths(changes, titlePath.length), schemaType }];
  }
  return changes;
}
function getFieldChange(schemaType, diff4, path2, titlePath) {
  let { itemDiff, parentDiff, parentSchema } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const { fromValue, toValue, type } = diff4;
  if (type === "array" && isEmpty2(fromValue) && isEmpty2(toValue)) {
    return [];
  }
  let error2;
  if (typeof fromValue !== "undefined") {
    error2 = getValueError(fromValue, schemaType);
  }
  if (!error2 && typeof toValue !== "undefined") {
    error2 = getValueError(toValue, schemaType);
  }
  let showHeader = true;
  let component;
  const diffComponent = resolveDiffComponent(schemaType, parentSchema);
  if (diffComponent && typeof diffComponent === "function") {
    component = diffComponent;
  } else if (diffComponent) {
    component = diffComponent.component;
    showHeader = typeof diffComponent.showHeader === "undefined" ? showHeader : diffComponent.showHeader;
  }
  return [{ type: "field", diff: diff4, path: path2, error: error2, itemDiff, parentDiff, titlePath, schemaType, showHeader, showIndex: true, key: pathToString2(path2) || "root", diffComponent: error2 ? void 0 : component, parentSchema }];
}
function reduceTitlePaths(changes) {
  let byLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return changes.map((change) => {
    change.titlePath = change.titlePath.slice(byLength);
    return change;
  });
}
function isEmpty2(item) {
  return Array.isArray(item) && item.length === 0 || item === null || typeof item === "undefined";
}
var isAddedAction = (change) => {
  return change.type === "field" && change.diff.action === "added";
};
var flattenChangeNode = (changeNode) => {
  if (changeNode.type !== "group") {
    return [changeNode];
  }
  const newSubChanges = [];
  changeNode.changes.forEach((cChange) => {
    newSubChanges.push(...flattenChangeNode(cChange));
  });
  return newSubChanges;
};
var isSubpathOf = (subPath, parentPath) => {
  if (parentPath.length >= subPath.length) {
    return false;
  }
  for (let i = 0; i < parentPath.length; i++) {
    if (parentPath[i] !== subPath[i]) {
      return false;
    }
  }
  return true;
};
var pathSegmentOfCorrectType = (item, child) => {
  const nextItem = item[child];
  const key2 = getItemKey$2(nextItem);
  if (key2) {
    return { _key: key2 };
  }
  const isArray2 = Array.isArray(item);
  if (isArray2) {
    return parseInt(child, 10);
  }
  return child;
};
var diffOptions = { diffMatchPatch: { enabled: false, lengthThresholdAbsolute: 30, lengthThresholdRelative: 1.2 } };
function undoChange(change, rootDiff, documentOperations) {
  if (!rootDiff) {
    return;
  }
  const patches = [];
  if (change.type === "group") {
    const allChanges = flattenChangeNode(change);
    const unsetChanges = allChanges.filter(isAddedAction);
    allChanges.filter((child) => !isAddedAction(child)).forEach((child) => undoChange(child, rootDiff, documentOperations));
    patches.push(...buildUnsetPatches(rootDiff, unsetChanges.map((unsetChange) => unsetChange.path).reverse()));
  } else if (change.diff.action === "added") {
    patches.push(...buildUnsetPatches(rootDiff, [change.path]));
  } else if (change.type === "field" && change.itemDiff && change.parentDiff && change.parentDiff.type === "array" && change.itemDiff.hasMoved) {
    patches.push(...buildMovePatches(change.itemDiff, change.parentDiff, change.path));
  } else {
    patches.push(...buildUndoPatches(change.diff, rootDiff, change.path));
  }
  documentOperations.patch.execute(patches);
}
function buildUnsetPatch(rootDiff, path2, concurrentUnsetPaths) {
  const previousValue = rootDiff.toValue;
  return furthestEmptyAncestor(previousValue, path2, concurrentUnsetPaths);
}
function buildUnsetPatches(rootDiff, paths) {
  const patches = [];
  for (let i = 0; i < paths.length; i++) {
    const unsetByEarlierPatch = patches.some((patch2) => isSubpathOf(paths[i], patch2));
    if (unsetByEarlierPatch) {
      continue;
    }
    patches.push(buildUnsetPatch(rootDiff, paths[i], paths));
  }
  return [{ unset: [...new Set(patches.map(pathToString2))] }];
}
function furthestEmptyAncestor(previousValue, currentPath) {
  let ignorePaths = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  let initialPath = arguments.length > 3 ? arguments[3] : void 0;
  if (currentPath.length <= 0) {
    if (!initialPath) {
      throw new Error("Root has no ancestor");
    }
    return initialPath;
  }
  const ancestorPath = currentPath.slice(0, -1);
  const ancestorValue = getValueAtPath(previousValue, ancestorPath);
  const updatedIgnorePaths = [
    ancestorPath,
    /*
    * We can filter out all the subpaths from under this ancestor
    * because since we ignore it higher up in the tree it doesn't
    * matter anymore what the values of subpaths are.
    */
    ...ignorePaths.filter((path2) => !isSubpathOf(path2, ancestorPath))
  ];
  return isStub(ancestorValue, ancestorPath, ignorePaths) ? furthestEmptyAncestor(previousValue, ancestorPath, updatedIgnorePaths, initialPath) : currentPath;
}
function buildMovePatches(itemDiff, parentDiff, path2) {
  const basePath = path2.slice(0, -1);
  const { parentValue, fromIndex, fromValue } = getFromItem(parentDiff, itemDiff);
  let insertLocation;
  if (fromIndex === 0) {
    insertLocation = { before: pathToString2([...basePath, 0]) };
  } else {
    const prevIndex = fromIndex - 1;
    const prevItemKey = getItemKeySegment(parentValue[prevIndex]);
    const prevSegment = prevItemKey || prevIndex;
    insertLocation = { after: pathToString2([...basePath, prevSegment]) };
  }
  return [{ unset: [pathToString2(path2)] }, { insert: { ...insertLocation, items: [fromValue] } }];
}
function buildUndoPatches(diff4, rootDiff, path2) {
  const patches = diffItem(diff4.toValue, diff4.fromValue, diffOptions, path2);
  const inserts = patches.filter((patch2) => patch2.op === "insert").map((_ref124) => {
    let { after, items } = _ref124;
    return { insert: { after: pathToString2(after), items } };
  });
  const unsets = patches.filter((patch2) => patch2.op === "unset").reduce((acc, patch2) => acc.concat(pathToString2(patch2.path)), []);
  const stubbedPaths = /* @__PURE__ */ new Set();
  const stubs = [];
  let hasSets = false;
  const sets2 = patches.filter((patch2) => patch2.op === "set").reduce((acc, patch2) => {
    hasSets = true;
    stubs.push(...getParentStubs(patch2.path, rootDiff, stubbedPaths));
    acc[pathToString2(patch2.path)] = patch2.value;
    return acc;
  }, {});
  return [...stubs, ...inserts, ...unsets.length > 0 ? [{ unset: unsets }] : [], ...hasSets ? [{ set: sets2 }] : []];
}
function getParentStubs(path2, rootDiff, stubbed) {
  const value = rootDiff.fromValue;
  const nextValue = rootDiff.toValue;
  const stubs = [];
  for (let i = 1; i <= path2.length; i++) {
    const subPath = path2.slice(0, i);
    const pathStr = pathToString2(subPath);
    if (stubbed.has(pathStr)) {
      continue;
    }
    const nextSegment = path2[i];
    const nextIsArrayElement = isKeySegment(nextSegment) || isIndexSegment(nextSegment);
    const itemValue = getValueAtPath(value, subPath);
    const stub = getStubValue(itemValue);
    if (nextIsArrayElement && Array.isArray(itemValue) && !getValueAtPath(nextValue, path2.slice(0, i + 1))) {
      const indexAtPrev = findIndex2(itemValue, nextSegment);
      const prevItem = itemValue[indexAtPrev - 1];
      const nextItem = getValueAtPath(value, subPath.concat(nextSegment));
      const prevSeg = isKeyedObject(prevItem) ? { _key: prevItem._key } : indexAtPrev - 1;
      const after = pathToString2(subPath.concat(indexAtPrev < 1 ? 0 : prevSeg));
      stubs.push({ setIfMissing: { [pathStr]: [] } });
      stubs.push({ insert: { after, items: [getStubValue(nextItem)] } });
      i++;
      continue;
    }
    if (typeof stub === "undefined") {
      continue;
    }
    stubbed.add(pathStr);
    stubs.push({ setIfMissing: { [pathStr]: stub } });
  }
  return stubs;
}
function onlyContainsStubs(item, path2, ignorePaths) {
  if (!isRecord$4(item) || !Array.isArray(item)) {
    return false;
  }
  for (const child in item) {
    if (!Object.prototype.hasOwnProperty.call(item, child)) {
      continue;
    }
    if (child === "_type" || child === "_key") {
      continue;
    }
    const nextPath = [...path2, pathSegmentOfCorrectType(item, child)];
    if (!isStub(item[child], nextPath, ignorePaths)) {
      return false;
    }
  }
  return true;
}
function isStub(item, path2, ignorePaths) {
  const isIgnoredPath = ignorePaths == null ? void 0 : ignorePaths.some((ignorePath) => pathToString2(ignorePath) === pathToString2(path2));
  const isEmptyArray2 = Array.isArray(item) && item.length <= 0;
  return isIgnoredPath || item === void 0 || item === null || isEmptyArray2 || isEmptyObject$1(item) || onlyContainsStubs(item, path2, ignorePaths);
}
function getStubValue(item) {
  if (Array.isArray(item)) {
    return [];
  }
  if (typeof item !== "object" || item === null) {
    return void 0;
  }
  const props2 = {};
  if (isKeyedObject(item)) {
    props2._key = item._key;
  }
  if (isTypedObject(item)) {
    props2._type = item._type;
  }
  return props2;
}
function getFromItem(parentDiff, itemDiff) {
  if (parentDiff.fromValue && typeof itemDiff.fromIndex === "number") {
    const fromValue = parentDiff.fromValue[itemDiff.fromIndex];
    return { parentValue: parentDiff.fromValue, fromIndex: itemDiff.fromIndex, fromValue };
  }
  throw new Error("Failed to find item at index ".concat(itemDiff.fromIndex));
}
var isDev = true;
var isProd = !isDev;
var DiffErrorBoundary = class extends import_react51.default.Component {
  constructor() {
    super(...arguments);
    this.state = {};
  }
  static getDerivedStateFromError(error2) {
    return { error: error2 };
  }
  // eslint-disable-next-line class-methods-use-this
  componentDidCatch(error2) {
    console.error("Error rendering diff component: ");
    console.error(error2);
  }
  render() {
    const { t: t3 } = this.props;
    const { error: error2 } = this.state;
    if (!error2) {
      return this.props.children;
    }
    return (0, import_jsx_runtime6.jsx)(Card, { padding: 3, radius: 2, tone: "critical", children: (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {}) }), (0, import_jsx_runtime6.jsxs)(Box, { paddingLeft: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "h3", size: 1, weight: "medium", children: t3("changes.error-boundary.title") }), isDev && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", size: 1, children: t3("changes.error-boundary.developer-info") }) })] })] }) });
  }
};
var arrowComponents = { down: ArrowDownIcon, right: ArrowRightIcon };
function FromToArrow(props2) {
  const { direction = "right", ...restProps } = props2;
  const arrowComponent = arrowComponents[direction];
  return (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, ...restProps, children: (0, import_react51.createElement)(arrowComponent) });
}
var __freeze$27 = Object.freeze;
var __defProp$27 = Object.defineProperty;
var __template$27 = (cooked, raw) => __freeze$27(__defProp$27(cooked, "raw", { value: __freeze$27(raw || cooked.slice()) }));
var _a$27;
var _b$10;
var CodeWrapper$1 = st.pre(_a$27 || (_a$27 = __template$27(["\n  overflow-x: auto;\n  position: relative;\n"])));
var Meta = st.div(_b$10 || (_b$10 = __template$27(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
function DiffInspectWrapper(props2) {
  const { children, as, change, ...restProps } = props2;
  const isHovering = (0, import_react51.useRef)(false);
  const [isInspecting, setIsInspecting] = (0, import_react51.useState)(false);
  const toggleInspect = (0, import_react51.useCallback)(() => setIsInspecting((state) => !state), [setIsInspecting]);
  const handleMouseEnter = (0, import_react51.useCallback)(() => isHovering.current = true, []);
  const handleMouseLeave = (0, import_react51.useCallback)(() => isHovering.current = false, [isHovering]);
  (0, import_react51.useEffect)(() => {
    function onKeyDown(evt) {
      const { metaKey, key: key2 } = evt;
      if (metaKey && key2 === "i" && isHovering.current) {
        toggleInspect();
      }
    }
    window.addEventListener("keydown", onKeyDown, false);
    return () => window.removeEventListener("keydown", onKeyDown, false);
  }, [toggleInspect]);
  return (0, import_jsx_runtime6.jsx)(Box, { as, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...restProps, children: isInspecting ? (0, import_jsx_runtime6.jsx)(DiffInspector, { change }) : children });
}
var MetaLabel = (_ref125) => {
  let { title } = _ref125;
  return (0, import_jsx_runtime6.jsx)(Box, { padding: 3, display: "inline-block", as: Meta, children: (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: title }) });
};
function DiffInspector(_ref126) {
  let { change } = _ref126;
  var _a22, _b22, _c4;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsxs)(Card, { padding: 3, tone: "transparent", as: CodeWrapper$1, radius: 1, children: [(0, import_jsx_runtime6.jsx)(MetaLabel, { title: t3("changes.inspector.meta-label") }), (0, import_jsx_runtime6.jsx)(Code, { language: "json", size: 1, children: printMeta({ path: pathToString2(change.path), fromIndex: (_a22 = change.itemDiff) == null ? void 0 : _a22.fromIndex, toIndex: (_b22 = change.itemDiff) == null ? void 0 : _b22.toIndex, hasMoved: (_c4 = change.itemDiff) == null ? void 0 : _c4.hasMoved, action: change.diff.action, isChanged: change.diff.isChanged }) })] }), (0, import_jsx_runtime6.jsxs)(Card, { as: CodeWrapper$1, tone: "critical", padding: 3, radius: 1, children: [(0, import_jsx_runtime6.jsx)(MetaLabel, { title: t3("changes.inspector.from-label") }), (0, import_jsx_runtime6.jsx)(Code, { language: "json", size: 1, children: jsonify(change.diff.fromValue) })] }), (0, import_jsx_runtime6.jsx)(Card, { children: (0, import_jsx_runtime6.jsx)(FromToArrow, { direction: "down", align: "center" }) }), (0, import_jsx_runtime6.jsxs)(Card, { as: CodeWrapper$1, tone: "positive", padding: 3, radius: 1, children: [(0, import_jsx_runtime6.jsx)(MetaLabel, { title: t3("changes.inspector.to-label") }), (0, import_jsx_runtime6.jsx)(Code, { language: "json", size: 1, children: jsonify(change.diff.toValue) })] })] });
}
function jsonify(value) {
  if (typeof value === "undefined") {
    return "undefined";
  }
  return JSON.stringify(value, null, 2);
}
function printMeta(keys) {
  const lines = [];
  Object.entries(keys).forEach((_ref127) => {
    let [key2, value] = _ref127;
    if (typeof value !== "undefined" && value !== null) {
      lines.push("".concat(key2, ": ").concat(value));
    }
  });
  return lines.join("\n");
}
function useChangeVerb(diff4) {
  const { t: t3 } = useTranslation2();
  const hadPrevValue = hasValue(diff4.fromValue);
  const hasNextValue = hasValue(diff4.toValue);
  if (!hadPrevValue && hasNextValue) {
    return t3("changes.added-label");
  }
  if (!hasNextValue && hadPrevValue) {
    return t3("changes.removed-label");
  }
  return t3("changes.changed-label");
}
function hasValue(value) {
  return value !== null && typeof value !== "undefined" && value !== "";
}
var INLINE_COLUMN_STYLES = { flexShrink: 0 };
var BLOCK_COLUMN_STYLES = { alignItems: "stretch" };
var FLEX_ALIGN = { top: "flex-start", center: "center", bottom: "flex-end", default: "flex-start" };
var FromTo = (0, import_react51.forwardRef)(function FromTo2(props2, ref) {
  const { align: align2 = "top", layout: layout2 = "inline", from: from2, to, style, ...restProps } = props2;
  const theme = useTheme();
  const Layout2 = layout2 === "inline" ? Flex : Grid;
  const layoutStyles = (0, import_react51.useMemo)(() => ({ ...style, ...layout2 === "inline" ? { maxWidth: "100%", display: "inline-flex" } : { gridTemplateColumns: "minmax(0, 1fr) ".concat(rem(theme.sanity.space[5]), " minmax(0, 1fr)") } }), [layout2, style, theme]);
  const columnStyles = layout2 === "inline" ? INLINE_COLUMN_STYLES : BLOCK_COLUMN_STYLES;
  return (0, import_jsx_runtime6.jsxs)(Layout2, { ...restProps, ref, style: layoutStyles, "data-from-to-layout": true, children: [from2 && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Flex, { align: FLEX_ALIGN[align2], style: columnStyles, children: from2 }), (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "center", padding: 2, children: (0, import_jsx_runtime6.jsx)(FromToArrow, {}) })] }), (0, import_jsx_runtime6.jsx)(Flex, { align: FLEX_ALIGN[align2], style: columnStyles, children: to })] });
});
var cardStyles = { flex: 1, minWidth: 0, display: "block", whiteSpace: "break-spaces" };
function DiffFromTo(props2) {
  const { align: align2, cardClassName, diff: diff4, layout: layout2, path: path2, previewComponent, schemaType } = props2;
  const { action } = diff4;
  const changeVerb = useChangeVerb(diff4);
  if (action === "unchanged") {
    return (0, import_jsx_runtime6.jsx)(DiffCard, { className: cardClassName, style: cardStyles, children: (0, import_react51.createElement)(previewComponent, { schemaType, value: diff4.toValue }) });
  }
  const from2 = diff4.fromValue !== void 0 && diff4.fromValue !== null && (0, import_jsx_runtime6.jsx)(DiffCard, { as: "del", className: cardClassName, diff: diff4, path: path2, style: cardStyles, children: (0, import_react51.createElement)(previewComponent, { schemaType, value: diff4.fromValue }) });
  const to = diff4.toValue !== void 0 && diff4.toValue !== null && (0, import_jsx_runtime6.jsx)(DiffCard, { as: "ins", className: cardClassName, diff: diff4, path: path2, style: cardStyles, children: (0, import_react51.createElement)(previewComponent, { schemaType, value: diff4.toValue }) });
  if (from2 && !to) {
    return (0, import_jsx_runtime6.jsx)(DiffTooltip, { description: changeVerb, diff: diff4, path: path2, children: from2 });
  }
  if (!from2 && to) {
    return (0, import_jsx_runtime6.jsx)(DiffTooltip, { description: changeVerb, diff: diff4, path: path2, children: to });
  }
  return (0, import_jsx_runtime6.jsx)(DiffTooltip, { description: changeVerb, diff: diff4, path: path2, children: (0, import_jsx_runtime6.jsx)(FromTo, { align: align2, from: from2, layout: layout2, to }) });
}
var FallbackPreview = (_ref128) => {
  let { value, schemaType } = _ref128;
  return (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Preview, { schemaType, value, layout: "default" }) });
};
var FallbackDiff = (props2) => {
  const { diff: diff4, schemaType } = props2;
  return (0, import_jsx_runtime6.jsx)(DiffFromTo, { diff: diff4, schemaType, previewComponent: FallbackPreview, layout: "grid" });
};
var __freeze$26 = Object.freeze;
var __defProp$26 = Object.defineProperty;
var __template$26 = (cooked, raw) => __freeze$26(__defProp$26(cooked, "raw", { value: __freeze$26(raw || cooked.slice()) }));
var _a$26;
var Root$o2 = st(Button)(_a$26 || (_a$26 = __template$26(["\n  [data-ui='Text'] {\n    font-weight: normal;\n  }\n\n  div[data-ui='Box'] {\n    display: none;\n  }\n\n  &:not([data-disabled='true']):hover,\n  &:not([data-disabled='true']):focus {\n    --card-fg-color: ", ";\n    --card-bg-color: transparent;\n    --card-border-color: transparent;\n\n    div[data-ui='Box'] {\n      display: block;\n    }\n  }\n"])), (_ref129) => {
  let { theme } = _ref129;
  return theme.sanity.color.solid.critical.enabled.bg;
});
var RevertChangesButton = (0, import_react51.forwardRef)(function RevertChangesButton2(props2, ref) {
  const { selected, changeCount, ...restProps } = props2;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Root$o2, { icon: RevertIcon, selected, text: t3("changes.action.revert-changes-confirm-change", { count: changeCount }), mode: "bleed", padding: 1, fontSize: 1, space: 2, ref, ...restProps });
});
function ValueError(_ref130) {
  let { error: error2 } = _ref130;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Card, { tone: "critical", padding: 3, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "flex-start", children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, paddingLeft: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, as: "p", children: t3(error2.messageKey, { expectedType: error2.expectedType, actualType: error2.actualType }) }) })] }) });
}
var __freeze$25 = Object.freeze;
var __defProp$25 = Object.defineProperty;
var __template$25 = (cooked, raw) => __freeze$25(__defProp$25(cooked, "raw", { value: __freeze$25(raw || cooked.slice()) }));
var _a$25;
var _b$$;
var _c$z;
var FieldChangeContainer = st.div(_a$25 || (_a$25 = __template$25(["\n  --field-change-error: ", ";\n  &[data-revert-all-changes-hover] [data-revert-all-hover]::before {\n    border-left: 2px solid var(--field-change-error);\n  }\n"])), (_ref131) => {
  let { theme } = _ref131;
  return theme.sanity.color.solid.critical.enabled.bg;
});
var DiffBorder = st.div(_b$$ || (_b$$ = __template$25(["\n  --field-change-error: ", ";\n  --diff-inspect-padding-xsmall: ", ";\n  --diff-inspect-padding-small: ", ";\n\n  position: relative;\n  padding: var(--diff-inspect-padding-xsmall) 0 var(--diff-inspect-padding-xsmall)\n    var(--diff-inspect-padding-small);\n\n  &::before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    border-left: 1px solid var(--card-border-color);\n  }\n\n  &[data-error]:hover::before,\n  &[data-revert-field-hover]:hover::before {\n    border-left: 2px solid var(--field-change-error);\n  }\n"])), (_ref132) => {
  let { theme } = _ref132;
  return theme.sanity.color.solid.critical.enabled.bg;
}, (_ref133) => {
  let { theme } = _ref133;
  return rem(theme.sanity.space[1]);
}, (_ref134) => {
  let { theme } = _ref134;
  return rem(theme.sanity.space[2]);
});
var PopoverWrapper$2 = st(Popover)(_c$z || (_c$z = __template$25(["\n  /* hides the popover when the target of it has left the visible part of the window.\n   without it, the popover will be on top of the headers (document title & changes)\n   and footers (changed notifications, publish button etc)*/\n  &[data-popper-reference-hidden='true'] {\n    display: none;\n  }\n"])));
function FieldChange(props2) {
  var _a4;
  const { change, hidden, readOnly } = props2;
  const DiffComponent = change.diffComponent || FallbackDiff;
  const { documentId, schemaType, rootDiff, isComparingCurrent, FieldWrapper: FieldWrapper2 = import_react51.default.Fragment } = useDocumentChange();
  const ops = useDocumentOperation(documentId, schemaType.name);
  const [confirmRevertOpen, setConfirmRevertOpen] = (0, import_react51.useState)(false);
  const [revertHovered, setRevertHovered] = (0, import_react51.useState)(false);
  const [revertButtonElement, setRevertButtonElement] = (0, import_react51.useState)(null);
  const { t: t3 } = useTranslation2();
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id: documentId, type: schemaType.name, permission: "update" });
  const handleRevertChanges = (0, import_react51.useCallback)(() => {
    undoChange(change, rootDiff, ops);
  }, [change, rootDiff, ops]);
  const handleRevertChangesConfirm = (0, import_react51.useCallback)(() => {
    setConfirmRevertOpen(true);
  }, []);
  const closeRevertChangesConfirmDialog = import_react51.default.useCallback(() => {
    setConfirmRevertOpen(false);
  }, []);
  const handleRevertButtonMouseEnter = (0, import_react51.useCallback)(() => {
    setRevertHovered(true);
  }, []);
  const handleRevertButtonMouseLeave = (0, import_react51.useCallback)(() => {
    setRevertHovered(false);
  }, []);
  const handleClickOutside = (0, import_react51.useCallback)(() => setConfirmRevertOpen(false), []);
  useClickOutside(handleClickOutside, [revertButtonElement]);
  const isArray2 = ((_a4 = change.parentSchema) == null ? void 0 : _a4.jsonType) === "array";
  const fieldPath = isArray2 ? change.path.slice(0, -1) : change.path;
  const content = (0, import_react51.useMemo)(() => hidden ? null : (0, import_jsx_runtime6.jsxs)(Stack, { space: 1, as: FieldChangeContainer, children: [change.showHeader && (0, import_jsx_runtime6.jsx)(ChangeBreadcrumb, { change, titlePath: change.titlePath }), (0, import_jsx_runtime6.jsx)(FieldWrapper2, { path: fieldPath, hasHover: revertHovered, children: (0, import_jsx_runtime6.jsxs)(DiffInspectWrapper, { change, as: DiffBorder, "data-revert-field-hover": revertHovered ? "" : void 0, "data-error": change.error ? "" : void 0, "data-revert-all-hover": true, children: [change.error ? (0, import_jsx_runtime6.jsx)(ValueError, { error: change.error }) : (0, import_jsx_runtime6.jsx)(DiffErrorBoundary, { t: t3, children: (0, import_jsx_runtime6.jsx)(DiffContext.Provider, { value: { path: change.path }, children: (0, import_jsx_runtime6.jsx)(DiffComponent, { diff: change.diff, schemaType: change.schemaType }) }) }), isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && (0, import_jsx_runtime6.jsx)(PopoverWrapper$2, { content: (0, import_jsx_runtime6.jsxs)(Box, { padding: 3, sizing: "border", children: [t3("changes.action.revert-changes-description", { count: 1 }), (0, import_jsx_runtime6.jsxs)(Grid, { columns: 2, gap: 2, marginTop: 2, children: [(0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", onClick: closeRevertChangesConfirmDialog, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", children: t3("changes.action.revert-all-cancel") }) }), (0, import_jsx_runtime6.jsx)(Button, { tone: "critical", onClick: handleRevertChanges, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", children: t3("changes.action.revert-changes-confirm-change", { count: 1 }) }) })] })] }), open: confirmRevertOpen, portal: true, placement: "left", ref: setRevertButtonElement, children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(RevertChangesButton, { changeCount: 1, onClick: handleRevertChangesConfirm, onMouseEnter: handleRevertButtonMouseEnter, onMouseLeave: handleRevertButtonMouseLeave, selected: confirmRevertOpen, disabled: readOnly, "data-testid": "single-change-revert-button-".concat(change == null ? void 0 : change.key) }) }) })] }) })] }), [change, closeRevertChangesConfirmDialog, confirmRevertOpen, DiffComponent, fieldPath, FieldWrapper2, handleRevertButtonMouseEnter, handleRevertButtonMouseLeave, handleRevertChanges, handleRevertChangesConfirm, hidden, isComparingCurrent, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, readOnly, revertHovered, t3]);
  return content;
}
function useHover() {
  const ref = (0, import_react51.useRef)(null);
  const [value, setValue] = (0, import_react51.useState)(false);
  (0, import_react51.useEffect)(() => {
    const node = ref.current;
    if (!node) {
      return () => void 0;
    }
    const handleMouseOver = () => setValue(true);
    const handleMouseOut = () => setValue(false);
    node.addEventListener("mouseover", handleMouseOver);
    node.addEventListener("mouseout", handleMouseOut);
    return () => {
      node.removeEventListener("mouseover", handleMouseOver);
      node.removeEventListener("mouseout", handleMouseOut);
    };
  }, []);
  return [ref, value];
}
var __freeze$24 = Object.freeze;
var __defProp$24 = Object.defineProperty;
var __template$24 = (cooked, raw) => __freeze$24(__defProp$24(cooked, "raw", { value: __freeze$24(raw || cooked.slice()) }));
var _a$24;
var _b$_;
var _c$y;
var ChangeListWrapper$1 = st.div(_a$24 || (_a$24 = __template$24(["\n  display: grid;\n  grid-template-columns: minmax(0, 1fr);\n"])));
var GroupChangeContainer = st.div(_b$_ || (_b$_ = __template$24(["\n  --field-change-error: ", ";\n  --diff-inspect-padding-xsmall: ", ";\n  --diff-inspect-padding-small: ", ";\n\n  position: relative;\n  padding: var(--diff-inspect-padding-xsmall) var(--diff-inspect-padding-small);\n\n  &::before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    border-left: 1px solid var(--card-border-color);\n  }\n\n  &[data-error]:hover::before,\n  &[data-revert-group-hover]:hover::before,\n  &[data-revert-all-groups-hover]::before {\n    border-left: 2px solid var(--field-change-error);\n  }\n"])), (_ref135) => {
  let { theme } = _ref135;
  return theme.sanity.color.solid.critical.enabled.bg;
}, (_ref136) => {
  let { theme } = _ref136;
  return rem(theme.sanity.space[1]);
}, (_ref137) => {
  let { theme } = _ref137;
  return rem(theme.sanity.space[2]);
});
var PopoverWrapper$1 = st(Popover)(_c$y || (_c$y = __template$24(["\n  /* hides the popover when the target of it has left the visible part of the window.\n   without it, the popover will be on top of the headers (document title & changes)\n   and footers (changed notifications, publish button etc)*/\n  &[data-popper-reference-hidden='true'] {\n    display: none;\n  }\n"])));
function GroupChange(props2) {
  const { change: group2, readOnly, hidden, ...restProps } = props2;
  const { titlePath, changes, path: groupPath } = group2;
  const { path: diffPath } = (0, import_react51.useContext)(DiffContext);
  const { documentId, schemaType, FieldWrapper: FieldWrapper2, rootDiff, isComparingCurrent } = useDocumentChange();
  const { t: t3 } = useTranslation2();
  const isPortableText2 = changes.every((change) => isFieldChange(change) && isPTSchemaType(change.schemaType));
  const isNestedInDiff = pathsAreEqual(diffPath, groupPath);
  const [revertButtonRef, isRevertButtonHovered] = useHover();
  const docOperations = useDocumentOperation(documentId, schemaType.name);
  const [confirmRevertOpen, setConfirmRevertOpen] = (0, import_react51.useState)(false);
  const [revertPopoverElement, setRevertPopoverElement] = (0, import_react51.useState)(null);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id: documentId, type: schemaType.name, permission: "update" });
  const handleRevertChanges = (0, import_react51.useCallback)(() => undoChange(group2, rootDiff, docOperations), [group2, rootDiff, docOperations]);
  const handleRevertChangesConfirm = (0, import_react51.useCallback)(() => {
    setConfirmRevertOpen(true);
  }, []);
  const closeRevertChangesConfirmDialog = (0, import_react51.useCallback)(() => {
    setConfirmRevertOpen(false);
  }, []);
  useClickOutside(() => setConfirmRevertOpen(false), [revertPopoverElement]);
  const content = (0, import_react51.useMemo)(() => hidden ? null : (0, import_jsx_runtime6.jsxs)(Stack, { space: 1, as: GroupChangeContainer, "data-revert-group-hover": isRevertButtonHovered ? "" : void 0, "data-portable-text": isPortableText2 ? "" : void 0, children: [(0, import_jsx_runtime6.jsx)(Stack, { as: ChangeListWrapper$1, space: 5, children: changes.map((change) => (0, import_jsx_runtime6.jsx)(ChangeResolver, { change, readOnly, hidden }, change.key)) }), isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && (0, import_jsx_runtime6.jsx)(PopoverWrapper$1, { content: (0, import_jsx_runtime6.jsxs)(Box, { children: [t3("changes.action.revert-changes-description", { count: changes.length }), (0, import_jsx_runtime6.jsxs)(Grid, { columns: 2, gap: 2, marginTop: 2, children: [(0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", onClick: closeRevertChangesConfirmDialog, children: (0, import_jsx_runtime6.jsxs)(Text3, { align: "center", children: [" ", t3("changes.action.revert-all-cancel")] }) }), (0, import_jsx_runtime6.jsx)(Button, { tone: "critical", onClick: handleRevertChanges, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", children: t3("changes.action.revert-changes-confirm-change", { count: 1 }) }) })] })] }), portal: true, padding: 4, placement: "left", open: confirmRevertOpen, ref: setRevertPopoverElement, children: (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(RevertChangesButton, { changeCount: changes.length, onClick: handleRevertChangesConfirm, ref: revertButtonRef, selected: confirmRevertOpen, disabled: readOnly, "data-testid": "group-change-revert-button-".concat(group2.fieldsetName) }) }) })] }), [changes, closeRevertChangesConfirmDialog, confirmRevertOpen, group2.fieldsetName, handleRevertChanges, handleRevertChangesConfirm, hidden, isComparingCurrent, isPermissionsLoading, isPortableText2, isRevertButtonHovered, permissions == null ? void 0 : permissions.granted, readOnly, revertButtonRef, t3]);
  return hidden ? null : (0, import_jsx_runtime6.jsxs)(Stack, { space: 1, ...restProps, children: [(0, import_jsx_runtime6.jsx)(ChangeBreadcrumb, { titlePath }), isNestedInDiff || !FieldWrapper2 ? content : (0, import_jsx_runtime6.jsx)(FieldWrapper2, { hasHover: isRevertButtonHovered, path: group2.path, children: content })] });
}
function ChangeResolver(props2) {
  var _a4, _b4;
  const { change, hidden, readOnly } = props2;
  const { value } = useDocumentChange();
  const isHidden2 = useConditionalProperty({
    // @todo: is parent missing here?
    document: value,
    checkProperty: hidden || ((_a4 = change.schemaType) == null ? void 0 : _a4.hidden),
    checkPropertyKey: "hidden",
    value: change.type === "field" ? change.diff.toValue : void 0
  });
  const isReadOnly = useConditionalProperty({
    // @todo: is parent missing here?
    document: value,
    checkProperty: readOnly || ((_b4 = change.schemaType) == null ? void 0 : _b4.readOnly),
    checkPropertyKey: "readOnly",
    value: change.type === "field" ? change.diff.toValue : void 0
  });
  if (isHidden2)
    return null;
  if (change.type === "field") {
    return (0, import_jsx_runtime6.jsx)(FieldChange, { change, readOnly: isReadOnly });
  }
  if (change.type === "group") {
    return (0, import_jsx_runtime6.jsx)(GroupChange, { change, "data-testid": "group-change-".concat(change.fieldsetName), readOnly: isReadOnly });
  }
  return (
    // eslint-disable-next-line i18next/no-literal-string
    (0, import_jsx_runtime6.jsxs)(Text3, { children: ["Unknown change type: ", (0, import_jsx_runtime6.jsx)("code", { children: change.type || "undefined" })] })
  );
}
function NoChanges() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", as: "h3", children: t3("changes.no-changes-title") }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", size: 1, muted: true, children: t3("changes.no-changes-description") })] });
}
var __freeze$23 = Object.freeze;
var __defProp$23 = Object.defineProperty;
var __template$23 = (cooked, raw) => __freeze$23(__defProp$23(cooked, "raw", { value: __freeze$23(raw || cooked.slice()) }));
var _a$23;
var _b$Z;
var ChangeListWrapper = st.div(_a$23 || (_a$23 = __template$23(["\n  display: grid;\n  grid-template-columns: minmax(0, 1fr);\n"])));
var PopoverWrapper = st(Popover)(_b$Z || (_b$Z = __template$23(["\n  /* hides the popover when the target of it has left the visible part of the window.\n   without it, the popover will be on top of the headers (document title & changes)\n   and footers (changed notifications, publish button etc)*/\n  &[data-popper-reference-hidden='true'] {\n    display: none;\n  }\n"])));
function ChangeList(_ref138) {
  let { diff: diff4, fields, schemaType } = _ref138;
  const { documentId, isComparingCurrent, value } = useDocumentChange();
  const docOperations = useDocumentOperation(documentId, schemaType.name);
  const { path: path2 } = (0, import_react51.useContext)(DiffContext);
  const isRoot2 = path2.length === 0;
  const [confirmRevertAllOpen, setConfirmRevertAllOpen] = (0, import_react51.useState)(false);
  const [confirmRevertAllHover, setConfirmRevertAllHover] = (0, import_react51.useState)(false);
  const { t: t3 } = useTranslation2();
  const isReadOnly = useConditionalProperty({ document: value, value: void 0, checkProperty: schemaType.readOnly, checkPropertyKey: "readOnly" });
  if (schemaType.jsonType !== "object") {
    throw new Error("Only object schema types are allowed in ChangeList");
  }
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id: documentId, type: schemaType.name, permission: "update" });
  const allChanges = (0, import_react51.useMemo)(() => buildObjectChangeList(schemaType, diff4, path2, [], { fieldFilter: fields }), [schemaType, fields, path2, diff4]);
  const changes = (0, import_react51.useMemo)(() => fields && fields.length === 0 ? [] : maybeFlatten(allChanges), [allChanges, fields]);
  const rootChange = allChanges[0];
  const revertAllChanges = (0, import_react51.useCallback)(() => {
    undoChange(rootChange, diff4, docOperations);
    setConfirmRevertAllOpen(false);
  }, [rootChange, diff4, docOperations]);
  const handleRevertAllChangesClick = (0, import_react51.useCallback)(() => {
    setConfirmRevertAllOpen(true);
  }, []);
  const handleRevertAllChangesMouseEnter = (0, import_react51.useCallback)(() => {
    setConfirmRevertAllHover(true);
  }, []);
  const handleRevertAllChangesMouseLeave = (0, import_react51.useCallback)(() => {
    setConfirmRevertAllHover(false);
  }, []);
  const closeRevertAllChangesConfirmDialog = (0, import_react51.useCallback)(() => {
    setConfirmRevertAllOpen(false);
  }, []);
  const [revertAllContainerElement, setRevertAllContainerElement] = (0, import_react51.useState)(null);
  const handleClickOutside = (0, import_react51.useCallback)(() => setConfirmRevertAllOpen(false), []);
  useClickOutside(handleClickOutside, [revertAllContainerElement]);
  if (changes.length === 0) {
    return isRoot2 ? (0, import_jsx_runtime6.jsx)(NoChanges, {}) : null;
  }
  const showFooter = isRoot2 && changes.length > 1;
  return (0, import_jsx_runtime6.jsx)(Card, { children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 5, children: [(0, import_jsx_runtime6.jsx)(Stack, { as: ChangeListWrapper, space: 5, children: changes.map((change) => (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(ChangeResolver, { change, "data-revert-all-changes-hover": confirmRevertAllHover ? "" : void 0, readOnly: isReadOnly || (change == null ? void 0 : change.readOnly), hidden: change == null ? void 0 : change.hidden }, change.key) }, change.key)) }), showFooter && isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && (0, import_jsx_runtime6.jsx)(PopoverWrapper, { content: (0, import_jsx_runtime6.jsxs)(Box, { children: [t3("changes.action.revert-all-description", { count: changes.length }), (0, import_jsx_runtime6.jsxs)(Grid, { columns: 2, gap: 2, marginTop: 2, children: [(0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", text: t3("changes.action.revert-all-cancel"), onClick: closeRevertAllChangesConfirmDialog }), (0, import_jsx_runtime6.jsx)(Button, { tone: "critical", text: t3("changes.action.revert-all-confirm"), onClick: revertAllChanges })] })] }), open: confirmRevertAllOpen, padding: 4, placement: "left", portal: true, ref: setRevertAllContainerElement, children: (0, import_jsx_runtime6.jsx)(Stack, { children: (0, import_jsx_runtime6.jsx)(Button, { tone: "critical", mode: "ghost", text: t3("changes.action.revert-all-confirm"), icon: RevertIcon, onClick: handleRevertAllChangesClick, onMouseEnter: handleRevertAllChangesMouseEnter, onMouseLeave: handleRevertAllChangesMouseLeave, disabled: isReadOnly }) }) })] }) });
}
function maybeFlatten(changes) {
  return changes.length === 1 && changes[0].type === "group" && changes[0].path.length === 0 ? changes[0].changes : changes;
}
var __freeze$22 = Object.freeze;
var __defProp$222 = Object.defineProperty;
var __template$22 = (cooked, raw) => __freeze$22(__defProp$222(cooked, "raw", { value: __freeze$22(raw || cooked.slice()) }));
var _a$22;
var _b$Y;
var RoundedCard = st.span(_a$22 || (_a$22 = __template$22(["\n  border-radius: ", ";\n"])), (_ref139) => {
  let { theme } = _ref139;
  return rem(theme.sanity.radius[1]);
});
var ChangeSegment = st(Text3)(_b$Y || (_b$Y = __template$22(["\n  &:not([hidden]) {\n    display: inline;\n    line-height: calc(1.25em + 2px);\n  }\n\n  &:hover {\n    background-color: none !important;\n    background-image: linear-gradient(\n      to bottom,\n      var(--card-bg-color) 0,\n      var(--card-bg-color) 33.333%,\n      currentColor 33.333%,\n      currentColor 100%\n    );\n    background-size: 1px 3px;\n    background-repeat: repeat-x;\n    background-position-y: bottom;\n    padding-bottom: 3px;\n    box-shadow: 0 0 0 1px var(--card-bg-color);\n    z-index: 1;\n  }\n"])));
function DiffStringSegment(props2) {
  const { segment } = props2;
  const { text } = segment;
  const { t: t3 } = useTranslation2();
  if (segment.action === "added") {
    return (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: segment.annotation, disableHoverEffect: true, tooltip: { description: t3("changes.added-label") }, as: RoundedCard, children: (0, import_jsx_runtime6.jsx)(ChangeSegment, { as: "ins", style: { textDecoration: "none" }, children: text }) });
  }
  if (segment.action === "removed") {
    return (0, import_jsx_runtime6.jsx)(DiffCard, { annotation: segment.annotation, as: RoundedCard, disableHoverEffect: true, tooltip: { description: t3("changes.removed-label") }, children: (0, import_jsx_runtime6.jsx)(ChangeSegment, { as: "del", children: text }) });
  }
  return (0, import_jsx_runtime6.jsx)(Card, { as: "span", radius: 2, style: { display: "inline" }, children: text });
}
function DiffString(props2) {
  const { diff: diff4 } = props2;
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (diff4.segments || []).map((segment, segmentIndex) => (0, import_jsx_runtime6.jsx)(DiffStringSegment, { segment }, segmentIndex)) });
}
var __freeze$21 = Object.freeze;
var __defProp$21 = Object.defineProperty;
var __template$21 = (cooked, raw) => __freeze$21(__defProp$21(cooked, "raw", { value: __freeze$21(raw || cooked.slice()) }));
var _a$21;
var MetaText = st(Text3)(_a$21 || (_a$21 = __template$21(["\n  color: inherit;\n"])));
function MetaInfo(props2) {
  const { title, action, icon, children, markRemoved } = props2;
  return (0, import_jsx_runtime6.jsxs)(Flex, { padding: 2, align: "center", children: [icon && (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(MetaText, { size: 4, forwardedAs: markRemoved ? "del" : "div", children: (0, import_react51.createElement)(icon) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, paddingLeft: 2, children: [(0, import_jsx_runtime6.jsx)(MetaText, { size: 1, weight: "semibold", forwardedAs: markRemoved ? "del" : "h3", textOverflow: "ellipsis", children: title }), action && (0, import_jsx_runtime6.jsx)("div", { children: action }), (0, import_jsx_runtime6.jsx)(MetaText, { size: 0, textOverflow: "ellipsis", children })] })] });
}
function isEqual$1(item, otherItem) {
  if (item === otherItem) {
    return true;
  }
  if (typeof item !== typeof otherItem) {
    return false;
  }
  if (typeof item !== "object" && !Array.isArray(item)) {
    return item === otherItem;
  }
  if (isKeyedObject(item) && isKeyedObject(otherItem) && item._key === otherItem._key) {
    return true;
  }
  if (Array.isArray(item) && Array.isArray(otherItem)) {
    if (item.length !== otherItem.length) {
      return false;
    }
    return item.every((child, i) => isEqual$1(child, otherItem[i]));
  }
  if (item === null || otherItem === null) {
    return item === otherItem;
  }
  const obj = item;
  const otherObj = otherItem;
  const keys = Object.keys(obj);
  const otherKeys = Object.keys(otherObj);
  if (keys.length !== otherKeys.length) {
    return false;
  }
  return keys.every((keyName) => isEqual$1(obj[keyName], otherObj[keyName]));
}
var ArrayOfOptionsFieldDiff = (_ref140) => {
  let { diff: diff4, schemaType } = _ref140;
  var _a4;
  const options = (_a4 = schemaType.options) == null ? void 0 : _a4.list;
  const colorManager = useUserColorManager();
  const { t: t3 } = useTranslation2();
  if (!Array.isArray(options)) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)("div", { children: diff4.items.map((item) => normalizeItems$1(item, diff4, schemaType)).filter((item) => item !== null).sort(sortItems).map((item, index) => {
    const { annotation, isPresent, value, memberType, title } = item;
    const color3 = getAnnotationColor(colorManager, annotation);
    const action = isPresent ? t3("changes.added-label") : t3("changes.removed-label");
    return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(DiffTooltip, { annotations: annotation ? [annotation] : [], description: action, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Checkbox3, { checked: !isPresent, color: color3 }), (0, import_jsx_runtime6.jsx)(Box, { margin: 2, children: (0, import_jsx_runtime6.jsx)(FromToArrow, {}) }), (0, import_jsx_runtime6.jsx)(Checkbox3, { checked: isPresent, color: color3 })] }) }), (0, import_jsx_runtime6.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime6.jsx)(ItemPreview, { value: title || value, memberType }) })] }, getItemKey$1(diff4, index));
  }) });
};
function normalizeItems$1(item, parentDiff, schemaType) {
  if (item.diff.action === "unchanged") {
    return null;
  }
  const { fromValue, toValue } = parentDiff;
  const value = getValue$1(item.diff);
  const wasPresent = isInArray(value, fromValue);
  const isPresent = isInArray(value, toValue);
  if (wasPresent === isPresent) {
    return null;
  }
  return { title: getItemTitle(value, schemaType), memberType: resolveMemberType(getValue$1(item.diff), schemaType), itemIndex: getOptionIndex(value, schemaType), annotation: item.annotation, isPresent, value };
}
function sortItems(itemA, itemB) {
  return itemA.itemIndex - itemB.itemIndex;
}
function ItemPreview(_ref141) {
  let { value, memberType } = _ref141;
  return (0, import_jsx_runtime6.jsx)(Box, { marginX: 2, marginY: 1, children: typeof value === "string" || typeof value === "number" ? value : (0, import_jsx_runtime6.jsx)(Preview, { schemaType: memberType, value, layout: "default" }) });
}
function isInArray(value, parent) {
  const array3 = parent || [];
  return typeof value === "object" && value !== null ? array3.some((item) => isEqual$1(item, value)) : array3.includes(value);
}
function getItemKey$1(diff4, index) {
  const value = diff4.toValue || diff4.fromValue;
  return isKeyedObject(value) ? value._key : index;
}
function getValue$1(diff4) {
  return typeof diff4.toValue === "undefined" ? diff4.fromValue : diff4.toValue;
}
function resolveMemberType(item, schemaType) {
  const itemTypeName = resolveTypeName2(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
}
function resolveTypeName2(value) {
  const jsType = resolveJSType2(value);
  if (jsType !== "object") {
    return jsType;
  }
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
function resolveJSType2(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
}
function isNamedOption(item) {
  return typeof item === "object" && item !== null && "title" in item;
}
function getOptionIndex(item, schemaType) {
  var _a4;
  const list = ((_a4 = schemaType.options) == null ? void 0 : _a4.list) || [];
  return list.findIndex((opt) => isEqual$1(isNamedOption(opt) ? opt.value : opt, item));
}
function getItemTitle(item, schemaType) {
  var _a4;
  const list = ((_a4 = schemaType.options) == null ? void 0 : _a4.list) || [];
  const index = getOptionIndex(item, schemaType);
  return index === -1 ? void 0 : list[index].title || void 0;
}
var UrlFieldDiff = (_ref142) => {
  let { diff: diff4, schemaType } = _ref142;
  return (0, import_jsx_runtime6.jsx)(DiffFromTo, { diff: diff4, schemaType, previewComponent: StringPreview });
};
var __freeze$20 = Object.freeze;
var __defProp$20 = Object.defineProperty;
var __template$20 = (cooked, raw) => __freeze$20(__defProp$20(cooked, "raw", { value: __freeze$20(raw || cooked.slice()) }));
var _a$20;
var SlugWrapper = st.div(_a$20 || (_a$20 = __template$20(["\n  display: inline-block;\n  word-break: break-all;\n  white-space: pre-wrap;\n"])));
var SlugPreview = (props2) => {
  const { value } = props2;
  return (0, import_jsx_runtime6.jsx)(Box, { as: SlugWrapper, paddingX: 2, paddingY: 1, children: value.current });
};
var SlugFieldDiff = (_ref143) => {
  let { diff: diff4, schemaType } = _ref143;
  return (0, import_jsx_runtime6.jsx)(DiffFromTo, { layout: "inline", diff: diff4, schemaType, previewComponent: SlugPreview });
};
var diffResolver = (_ref144) => {
  let { schemaType } = _ref144;
  var _a4;
  if (["datetime", "date"].includes(schemaType.name)) {
    return DatetimeFieldDiff;
  }
  if (schemaType.name === "url") {
    return UrlFieldDiff;
  }
  if (schemaType.name === "slug") {
    return SlugFieldDiff;
  }
  if (schemaType.jsonType === "array" && Array.isArray((_a4 = schemaType.options) == null ? void 0 : _a4.list)) {
    return ArrayOfOptionsFieldDiff;
  }
  return void 0;
};
var FormValueContext = (0, import_react51.createContext)(null);
function FormValueProvider(props2) {
  const value = (0, import_react51.useMemo)(() => ({ value: props2.value }), [props2.value]);
  return (0, import_jsx_runtime6.jsx)(FormValueContext.Provider, { value, children: props2.children });
}
function useFormValue(path2) {
  const uniquePath = pathFor(path2);
  const ctx = (0, import_react51.useContext)(FormValueContext);
  if (!ctx) {
    throw new Error("useFormValue must be used within a FormValueProvider");
  }
  return getValueAtPath(ctx == null ? void 0 : ctx.value, uniquePath);
}
var GetFormValueContext = (0, import_react51.createContext)(null);
function GetFormValueProvider(props2) {
  const valueRef = (0, import_react51.useRef)(props2.value);
  valueRef.current = props2.value;
  const getValue3 = (0, import_react51.useCallback)((path2) => getValueAtPath(valueRef.current, path2), [valueRef]);
  return (0, import_jsx_runtime6.jsx)(GetFormValueContext.Provider, { value: getValue3, children: props2.children });
}
function useGetFormValue() {
  const ctx = (0, import_react51.useContext)(GetFormValueContext);
  if (!ctx) {
    throw new Error("useFormValue must be used within a FormValueProvider");
  }
  return ctx;
}
var FormBuilderContext = (0, import_react51.createContext)(null);
var POPOVER_PROPS$3 = { constrainSize: true, portal: true, fallbackPlacements: ["top", "bottom"] };
function ArrayOfObjectsFunctions(props2) {
  const { schemaType, readOnly, children, onValueCreate, onItemAppend } = props2;
  const menuButtonId = (0, import_react51.useId)();
  const { t: t3 } = useTranslation2();
  const insertItem = (0, import_react51.useCallback)((itemType) => {
    const item = onValueCreate(itemType);
    onItemAppend(item);
  }, [onValueCreate, onItemAppend]);
  const handleAddBtnClick = import_react51.default.useCallback(() => {
    insertItem(schemaType.of[0]);
  }, [schemaType, insertItem]);
  const addItemI18nKey = schemaType.of.length > 1 ? "inputs.array.action.add-item-select-type" : "inputs.array.action.add-item";
  if (readOnly) {
    return (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("inputs.array.read-only-label") }) }), children: (0, import_jsx_runtime6.jsx)(Grid, { children: (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "ghost", disabled: true, text: t3(addItemI18nKey) }) }) });
  }
  return (0, import_jsx_runtime6.jsxs)(Grid, { gap: 1, style: { gridTemplateColumns: "repeat(auto-fit, minmax(100px, 1fr))" }, children: [schemaType.of.length === 1 ? (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "ghost", onClick: handleAddBtnClick, text: t3(addItemI18nKey) }) : (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "ghost", text: t3(addItemI18nKey) }), id: menuButtonId || "", menu: (0, import_jsx_runtime6.jsx)(Menu, { children: schemaType.of.map((memberDef, i) => {
    var _a4, _b4;
    const referenceIcon = isReferenceSchemaType(memberDef) && (memberDef.to || []).length === 1 && memberDef.to[0].icon;
    const icon = memberDef.icon || ((_a4 = memberDef.type) == null ? void 0 : _a4.icon) || referenceIcon;
    return (0, import_jsx_runtime6.jsx)(MenuItem, { text: memberDef.title || ((_b4 = memberDef.type) == null ? void 0 : _b4.name), onClick: () => insertItem(memberDef), icon }, i);
  }) }), popover: POPOVER_PROPS$3 }), children] });
}
function useFormBuilder() {
  const formBuilder = (0, import_react51.useContext)(FormBuilderContext);
  if (!formBuilder) {
    throw new Error("FormBuilder: missing context value");
  }
  return formBuilder;
}
var __freeze$1$ = Object.freeze;
var __defProp$1$ = Object.defineProperty;
var __template$1$ = (cooked, raw) => __freeze$1$(__defProp$1$(cooked, "raw", { value: __freeze$1$(raw || cooked.slice()) }));
var _a$1$;
var getIcon = (level) => {
  if (level === "error") {
    return (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {});
  }
  if (level === "warning") {
    return (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {});
  }
  return (0, import_jsx_runtime6.jsx)(InfoOutlineIcon, {});
};
var IconText = st(Text3)((_ref145) => {
  let { theme } = _ref145;
  return nt(_a$1$ || (_a$1$ = __template$1$(["\n    &[data-info] {\n      color: ", ";\n    }\n\n    &[data-warning] {\n      color: ", ";\n    }\n\n    &[data-error] {\n      color: ", ";\n    }\n  "])), theme.sanity.color.muted.primary.enabled.fg, theme.sanity.color.muted.caution.enabled.fg, theme.sanity.color.muted.critical.enabled.fg);
});
function DefaultMarkers(props2) {
  const { markers, validation: validation2, renderCustomMarkers } = props2;
  const { CustomMarkers } = useFormBuilder().__internal.components;
  if (markers.length === 0 && validation2.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 1, children: [validation2.length > 0 && validation2.map((_ref146, index) => {
    let { message, level } = _ref146;
    return (
      // eslint-disable-next-line react/no-array-index-key
      (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { marginRight: 2, marginBottom: index + 1 === validation2.length ? 0 : 2, children: (0, import_jsx_runtime6.jsx)(IconText, { size: 1, "data-error": level === "error" ? "" : void 0, "data-warning": level === "warning" ? "" : void 0, "data-info": level === "info" ? "" : void 0, children: getIcon(level) }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: message || "Error" }) })] }, "validationItem-".concat(index))
    );
  }), markers.length > 0 && (0, import_jsx_runtime6.jsxs)(Box, { marginTop: validation2.length > 0 ? 3 : 0, children: [renderCustomMarkers && renderCustomMarkers(markers), !renderCustomMarkers && (0, import_jsx_runtime6.jsx)(CustomMarkers, { markers })] })] });
}
function DefaultCustomMarkers() {
  return (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, children: ["This is a example custom marker, please implement ", (0, import_jsx_runtime6.jsx)("code", { children: "renderCustomMarkers" }), " function."] });
}
var FormCallbacksContext = import_react51.default.createContext(null);
var FormCallbacksProvider = (0, import_react51.memo)(function FormCallbacksProvider2(props2) {
  const ref = (0, import_react51.useRef)(props2);
  ref.current = props2;
  const transformPatches = (0, import_react51.useCallback)((patches) => {
    var _a4, _b4, _c4;
    return (_c4 = (_b4 = (_a4 = ref.current) == null ? void 0 : _a4.transformPatches) == null ? void 0 : _b4.call(_a4, patches)) != null ? _c4 : [];
  }, [ref]);
  const onChange = (0, import_react51.useCallback)((patchEvent) => {
    ref.current.onChange(patchEvent);
  }, []);
  const onPathFocus = (0, import_react51.useCallback)((path2) => {
    ref.current.onPathFocus(path2);
  }, []);
  const onPathBlur = (0, import_react51.useCallback)((path2) => {
    ref.current.onPathBlur(path2);
  }, []);
  const onPathOpen = (0, import_react51.useCallback)((path2) => {
    ref.current.onPathOpen(path2);
  }, []);
  const onSetPathCollapsed = (0, import_react51.useCallback)((path2, collapsed) => {
    ref.current.onSetPathCollapsed(path2, collapsed);
  }, []);
  const onSetFieldSetCollapsed = (0, import_react51.useCallback)((path2, collapsed) => {
    ref.current.onSetFieldSetCollapsed(path2, collapsed);
  }, []);
  const onFieldGroupSelect = (0, import_react51.useCallback)((path2, fieldGroupName) => {
    ref.current.onFieldGroupSelect(path2, fieldGroupName);
  }, []);
  const contextValue = (0, import_react51.useMemo)(() => ({ transformPatches, onChange, onPathFocus, onPathBlur, onPathOpen, onSetPathCollapsed, onSetFieldSetCollapsed, onFieldGroupSelect }), [onChange, onFieldGroupSelect, onPathBlur, onPathFocus, onPathOpen, onSetFieldSetCollapsed, onSetPathCollapsed, transformPatches]);
  return (0, import_jsx_runtime6.jsx)(FormCallbacksContext.Provider, { value: contextValue, children: props2.children });
});
function useFormCallbacks() {
  const ctx = (0, import_react51.useContext)(FormCallbacksContext);
  if (!ctx) {
    throw new Error("Form context not provided");
  }
  return ctx;
}
function immutableReconcile(previous, next) {
  return _immutableReconcile(previous, next, /* @__PURE__ */ new WeakSet());
}
function _immutableReconcile(previous, next, parents) {
  if (previous === next)
    return previous;
  if (parents.has(next)) {
    return next;
  }
  if (previous == null || next == null)
    return next;
  const prevType = typeof previous;
  const nextType = typeof next;
  if (prevType !== nextType)
    return next;
  if (Array.isArray(next)) {
    parents.add(next);
    let allEqual = previous.length === next.length;
    const result = [];
    for (let index = 0; index < next.length; index++) {
      const nextItem = _immutableReconcile(previous[index], next[index], parents);
      if (nextItem !== previous[index]) {
        allEqual = false;
      }
      result[index] = nextItem;
    }
    parents.delete(next);
    return allEqual ? previous : result;
  }
  if (typeof next === "object") {
    parents.add(next);
    const nextKeys = Object.keys(next);
    let allEqual = Object.keys(previous).length === nextKeys.length;
    const result = {};
    for (const key2 of nextKeys) {
      const nextValue = _immutableReconcile(previous[key2], next[key2], parents);
      if (nextValue !== previous[key2]) {
        allEqual = false;
      }
      result[key2] = nextValue;
    }
    parents.delete(next);
    return allEqual ? previous : result;
  }
  return next;
}
var PresenceContext2 = (0, import_react51.createContext)([]);
function PresenceProvider(props2) {
  return (0, import_jsx_runtime6.jsx)(PresenceContext2.Provider, { value: props2.presence, children: props2.children });
}
function useFormFieldPresence() {
  const ctx = (0, import_react51.useContext)(PresenceContext2);
  if (!ctx) {
    throw new Error("Form context not provided");
  }
  return ctx;
}
function useChildPresence(path2, inclusive) {
  const presence = useFormFieldPresence();
  const prev = (0, import_react51.useRef)(presence);
  const next = immutableReconcile(prev.current, presence.filter((item) => startsWith(path2, item.path) && (inclusive || !isEqual(path2, item.path))));
  prev.current = next;
  return next;
}
var ValidationContext = (0, import_react51.createContext)([]);
function ValidationProvider(props2) {
  return (0, import_jsx_runtime6.jsx)(ValidationContext.Provider, { value: props2.validation, children: props2.children });
}
function useValidationMarkers() {
  const ctx = (0, import_react51.useContext)(ValidationContext);
  if (!ctx) {
    throw new Error("Form context not provided");
  }
  return ctx;
}
function useChildValidation(path2) {
  let inclusive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const validation2 = useValidationMarkers();
  return (0, import_react51.useMemo)(() => validation2.filter((item) => startsWith(path2, item.path) && (inclusive || !isEqual(path2, item.path))).map((marker) => ({ message: marker.item.message, level: marker.level, path: marker.path })), [inclusive, path2, validation2]);
}
function FieldActionMenuItem(props2) {
  const { action } = props2;
  const handleClick = (0, import_react51.useCallback)(() => {
    action.onAction();
  }, [action]);
  const disabledTooltipContent = typeof action.disabled === "object" && (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: action.disabled.reason });
  return (0, import_jsx_runtime6.jsx)(TooltipOfDisabled, { content: disabledTooltipContent, placement: "left", children: (0, import_jsx_runtime6.jsx)(MenuItem, { disabled: Boolean(action.disabled), fontSize: 1, icon: action.icon, iconRight: action.iconRight || (action.selected ? CheckmarkIcon : void 0), onClick: handleClick, padding: 3, pressed: action.selected, space: 3, text: action.title, tone: action.tone }) });
}
var POPOVER_PROPS$2 = { placement: "right", fallbackPlacements: ["top", "bottom"] };
function FieldActionMenuGroup(props2) {
  const { group: group2 } = props2;
  if (group2.expanded) {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 2, paddingBottom: 1, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 0, children: group2.title }) }), group2.children.map((item, idx) => {
      var _a4;
      return (0, import_jsx_runtime6.jsx)(FieldActionMenuNode, { action: item, isFirst: idx === 0, prevIsGroup: ((_a4 = group2.children[idx - 1]) == null ? void 0 : _a4.type) === "group" }, idx);
    })] });
  }
  return (0, import_jsx_runtime6.jsx)(MenuGroup, { fontSize: 1, icon: group2.icon, padding: 3, popover: POPOVER_PROPS$2, space: 3, text: group2.title, tone: group2.tone, children: group2.children.map((item, idx) => {
    var _a4;
    return (0, import_jsx_runtime6.jsx)(FieldActionMenuNode, { action: item, isFirst: idx === 0, prevIsGroup: ((_a4 = group2.children[idx - 1]) == null ? void 0 : _a4.type) === "group" }, idx);
  }) });
}
function FieldActionMenuNode(props2) {
  const { action, isFirst, prevIsGroup } = props2;
  if (action.type === "divider") {
    return (0, import_jsx_runtime6.jsx)(MenuDivider, {});
  }
  if (action.type === "group") {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [!isFirst && (0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(FieldActionMenuGroup, { group: action })] });
  }
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [prevIsGroup && (0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(FieldActionMenuItem, { action })] });
}
var STATUS_BUTTON_TOOLTIP_PROPS = { placement: "top" };
function renderAsButton(node) {
  return "renderAsButton" in node && node.renderAsButton;
}
var FieldActionMenu = (0, import_react51.memo)(function FieldActionMenu2(props2) {
  const { nodes, onMenuOpenChange } = props2;
  const [open, setOpen] = (0, import_react51.useState)(false);
  const handleOpen = (0, import_react51.useCallback)(() => {
    onMenuOpenChange(true);
    setOpen(true);
  }, [onMenuOpenChange]);
  const handleClose = (0, import_react51.useCallback)(() => {
    onMenuOpenChange(false);
    setOpen(false);
  }, [onMenuOpenChange]);
  const buttonNodes = (0, import_react51.useMemo)(() => nodes.filter(renderAsButton), [nodes]);
  const menuNodesProp = (0, import_react51.useMemo)(() => nodes.filter((node) => !renderAsButton(node)), [nodes]);
  const menuNodes = (0, import_react51.useMemo)(() => {
    const len = menuNodesProp.length;
    if (len === 0 || len > 1)
      return menuNodesProp;
    const node = menuNodesProp[0];
    if (node.type === "group") {
      return [{ ...node, expanded: true }];
    }
    return menuNodesProp;
  }, [menuNodesProp]);
  const rootNodes = (0, import_react51.useMemo)(() => [...menuNodes.length ? [{ type: "group", children: menuNodes, icon: EllipsisVerticalIcon, title: "Field actions" }] : [], ...buttonNodes], [buttonNodes, menuNodes]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: rootNodes.map((node, idx) => (0, import_jsx_runtime6.jsx)(RootFieldActionMenuNode, { node, onOpen: handleOpen, onClose: handleClose, open }, idx)) });
});
var RootFieldActionMenuNode = (0, import_react51.memo)(function RootFieldActionMenuNode2(props2) {
  const { node, onOpen, onClose, open } = props2;
  if (node.type === "divider") {
    return (0, import_jsx_runtime6.jsx)(Card, { borderLeft: true, flex: "none" });
  }
  if (node.type === "action") {
    return (0, import_jsx_runtime6.jsx)(StatusButton, { fontSize: 1, icon: node.icon, label: open ? void 0 : node.title, mode: "bleed", onClick: node.onAction, padding: 2, tooltip: STATUS_BUTTON_TOOLTIP_PROPS });
  }
  return (0, import_jsx_runtime6.jsx)(RootFieldActionMenuGroup, { node, onOpen, onClose, open });
});
var ROOT_MENU_BUTTON_POPOVER_PROPS = { constrainSize: true, placement: "right", portal: true, fallbackPlacements: ["top", "bottom"] };
function RootFieldActionMenuGroup(props2) {
  const { node, onOpen, onClose, open } = props2;
  return (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(StatusButton, { fontSize: 1, icon: node.icon, label: open ? void 0 : node.title, mode: "bleed", padding: 2, tooltip: STATUS_BUTTON_TOOLTIP_PROPS }), id: (0, import_react51.useId)(), menu: (0, import_jsx_runtime6.jsx)(Menu, { children: node.children.map((action, idx) => {
    var _a4;
    return (0, import_jsx_runtime6.jsx)(FieldActionMenuNode, { action, isFirst: idx === 0, prevIsGroup: ((_a4 = node.children[idx - 1]) == null ? void 0 : _a4.type) === "group" }, idx);
  }) }), onOpen, onClose, popover: ROOT_MENU_BUTTON_POPOVER_PROPS });
}
function filterActions(actions) {
  return actions.filter(Boolean).filter((node) => {
    if ("hidden" in node)
      return node.hidden !== true;
    return true;
  }).map((node) => {
    if (node.type === "group") {
      return { ...node, children: filterActions(node.children) };
    }
    return node;
  });
}
var FieldActionsResolver = (0, import_react51.memo)(function FieldActions(props2) {
  const { actions, documentId, documentType, onActions, path: path2, schemaType } = props2;
  const len = actions.length;
  const lenRef = (0, import_react51.useRef)(len);
  const [fieldActions, setFieldActions] = (0, import_react51.useState)(() => Array.from(new Array(len)));
  const fieldActionsRef = (0, import_react51.useRef)(fieldActions);
  const setFieldAction = (0, import_react51.useCallback)((index, node) => {
    setFieldActions((prev) => {
      const next = [...prev];
      next[index] = node;
      return next;
    });
  }, []);
  (0, import_react51.useEffect)(() => {
    if (fieldActionsRef.current !== fieldActions) {
      fieldActionsRef.current = fieldActions;
      onActions(filterActions(fieldActions));
    }
  }, [fieldActions, onActions]);
  (0, import_react51.useEffect)(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++) {
        newFieldActions[i] = fieldActionsRef.current[i];
      }
      lenRef.current = len;
      setFieldActions(newFieldActions);
      fieldActionsRef.current = newFieldActions;
    }
  }, [len]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: actions.map((a, aIdx) => (0, import_jsx_runtime6.jsx)(FieldAction, { action: a, index: aIdx, documentId, documentType, path: path2, schemaType, setFieldAction }, aIdx)) });
});
var FieldAction = (0, import_react51.memo)(function FieldAction2(props2) {
  const { action, documentId, documentType, index, path: path2, schemaType, setFieldAction } = props2;
  const node = useUnique2(action.useAction({ documentId, documentType, path: path2, schemaType }));
  (0, import_react51.useEffect)(() => {
    setFieldAction(index, node);
  }, [index, node, setFieldAction]);
  return null;
});
var HoveredFieldContext = (0, import_react51.createContext)({ hoveredStack: [], onMouseEnter: () => void 0, onMouseLeave: () => void 0 });
function useHoveredField() {
  return (0, import_react51.useContext)(HoveredFieldContext);
}
var FieldActionsContext = (0, import_react51.createContext)({ actions: [], focused: false, hovered: false, onMouseEnter: () => void 0, onMouseLeave: () => void 0 });
function FieldActionsProvider(props2) {
  const { actions, children, path: path2, focused } = props2;
  const { onMouseEnter: onFieldMouseEnter, onMouseLeave: onFieldMouseLeave } = useHoveredField();
  const hoveredPath = useHoveredField().hoveredStack[0];
  const hovered = supportsTouch || (hoveredPath ? pathToString2(path2) === hoveredPath : false);
  const handleMouseEnter = (0, import_react51.useCallback)(() => {
    onFieldMouseEnter(path2);
  }, [onFieldMouseEnter, path2]);
  const handleMouseLeave = (0, import_react51.useCallback)(() => {
    onFieldMouseLeave(path2);
  }, [onFieldMouseLeave, path2]);
  const context = (0, import_react51.useMemo)(() => ({ actions, focused, hovered, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave }), [actions, focused, handleMouseEnter, handleMouseLeave, hovered]);
  return (0, import_jsx_runtime6.jsx)(FieldActionsContext.Provider, { value: context, children });
}
function useFieldActions() {
  return (0, import_react51.useContext)(FieldActionsContext);
}
function HoveredFieldProvider(props2) {
  const { children } = props2;
  const [hoveredStack, setHoveredStack] = (0, import_react51.useState)([]);
  const handleMouseEnter = (0, import_react51.useCallback)((path2) => {
    const pathString = pathToString2(path2);
    setHoveredStack((prev) => {
      if (prev.includes(pathString)) {
        return prev;
      }
      return [pathString, ...prev];
    });
  }, []);
  const handleMouseLeave = (0, import_react51.useCallback)((path2) => {
    const pathString = pathToString2(path2);
    setHoveredStack((prev) => {
      if (prev.includes(pathString)) {
        return prev.filter((item) => item !== pathString);
      }
      return prev;
    });
  }, []);
  const context = (0, import_react51.useMemo)(() => ({ hoveredStack, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave }), [handleMouseEnter, handleMouseLeave, hoveredStack]);
  return (0, import_jsx_runtime6.jsx)(HoveredFieldContext.Provider, { value: context, children });
}
var DocumentIdContext = (0, import_react51.createContext)(null);
function DocumentIdProvider(props2) {
  const value = (0, import_react51.useMemo)(() => ({ id: props2.id }), [props2.id]);
  return (0, import_jsx_runtime6.jsx)(DocumentIdContext.Provider, { value, children: props2.children });
}
function useGivenDocumentId() {
  const ctx = (0, import_react51.useContext)(DocumentIdContext);
  if (!ctx) {
    throw new Error("useDocumentId must be used within a DocumentIdProvider");
  }
  return ctx.id;
}
function usePublishedId() {
  return getPublishedId(useGivenDocumentId());
}
var missingPatchChannel = { publish: () => void 0, subscribe: () => {
  console.warn("No patch channel provided to form-builder. If you need input based patch updates, please provide one");
  return () => void 0;
} };
function FormBuilderProvider(props2) {
  const { __internal_fieldActions: fieldActions = EMPTY_ARRAY$b, __internal_patchChannel: patchChannel = missingPatchChannel, autoFocus, changesOpen, children, collapsedFieldSets, collapsedPaths, file: file2, filterField, focusPath, focused, groups, id: id4, image: image2, onChange, onFieldGroupSelect, onPathBlur, onPathFocus, onPathOpen, onSetFieldSetCollapsed, onSetPathCollapsed, presence, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, unstable, validation: validation2 } = props2;
  const __internal = (0, import_react51.useMemo)(() => ({
    patchChannel,
    // eslint-disable-line camelcase
    components: { ArrayFunctions: ArrayOfObjectsFunctions, CustomMarkers: (unstable == null ? void 0 : unstable.CustomMarkers) || DefaultCustomMarkers, Markers: (unstable == null ? void 0 : unstable.Markers) || DefaultMarkers },
    field: { actions: fieldActions },
    file: { assetSources: file2.assetSources, directUploads: (file2 == null ? void 0 : file2.directUploads) !== false },
    filterField: filterField || (() => true),
    image: { assetSources: image2.assetSources, directUploads: (image2 == null ? void 0 : image2.directUploads) !== false },
    onChange
  }), [fieldActions, file2.assetSources, file2 == null ? void 0 : file2.directUploads, filterField, image2.assetSources, image2 == null ? void 0 : image2.directUploads, onChange, patchChannel, unstable == null ? void 0 : unstable.CustomMarkers, unstable == null ? void 0 : unstable.Markers]);
  const formBuilder = (0, import_react51.useMemo)(() => ({ __internal, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id: id4, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType }), [__internal, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id4, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType]);
  return (0, import_jsx_runtime6.jsx)(FormBuilderContext.Provider, { value: formBuilder, children: (0, import_jsx_runtime6.jsx)(FormCallbacksProvider, { onChange, onFieldGroupSelect, onPathBlur, onPathFocus, onPathOpen, onSetPathCollapsed, onSetFieldSetCollapsed, children: (0, import_jsx_runtime6.jsx)(DocumentIdProvider, { id: id4, children: (0, import_jsx_runtime6.jsx)(PresenceProvider, { presence, children: (0, import_jsx_runtime6.jsx)(ValidationProvider, { validation: validation2, children: (0, import_jsx_runtime6.jsx)(HoveredFieldProvider, { children }) }) }) }) }) });
}
function FormProvider(props2) {
  const { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, autoFocus, changesOpen, children, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id: id4, onChange, onPathBlur, onPathFocus, onPathOpen, onFieldGroupSelect, onSetPathCollapsed, onSetFieldSetCollapsed, presence, readOnly, schemaType, validation: validation2 } = props2;
  const { file: file2, image: image2 } = useSource().form;
  const Input3 = useInputComponent();
  const Field = useFieldComponent();
  const Preview2 = usePreviewComponent();
  const Item3 = useItemComponent();
  const Block2 = useBlockComponent();
  const InlineBlock = useInlineBlockComponent();
  const Annotation2 = useAnnotationComponent();
  const renderInput = (0, import_react51.useCallback)((inputProps) => (0, import_jsx_runtime6.jsx)(Input3, { ...inputProps }), [Input3]);
  const renderField = (0, import_react51.useCallback)((fieldProps) => (0, import_jsx_runtime6.jsx)(Field, { ...fieldProps }), [Field]);
  const renderItem = (0, import_react51.useCallback)((itemProps) => (0, import_jsx_runtime6.jsx)(Item3, { ...itemProps }), [Item3]);
  const renderPreview = (0, import_react51.useCallback)((previewProps) => (0, import_jsx_runtime6.jsx)(PreviewLoader, { component: Preview2, ...previewProps }), [Preview2]);
  const renderBlock = (0, import_react51.useCallback)((blockProps) => (0, import_jsx_runtime6.jsx)(Block2, { ...blockProps }), [Block2]);
  const renderInlineBlock = (0, import_react51.useCallback)((blockProps) => (0, import_jsx_runtime6.jsx)(InlineBlock, { ...blockProps }), [InlineBlock]);
  const renderAnnotation = (0, import_react51.useCallback)((annotationProps) => (0, import_jsx_runtime6.jsx)(Annotation2, { ...annotationProps }), [Annotation2]);
  return (0, import_jsx_runtime6.jsx)(FormBuilderProvider, { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, file: file2, focusPath, focused, groups, id: id4, image: image2, onChange, onPathBlur, onPathFocus, onPathOpen, onFieldGroupSelect, onSetPathCollapsed, onSetFieldSetCollapsed, presence, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, validation: validation2, children });
}
var DocumentFieldActionsContext = (0, import_react51.createContext)(null);
function DocumentFieldActionsProvider(props2) {
  const value = (0, import_react51.useMemo)(() => ({ actions: props2.actions || EMPTY_ARRAY$b }), [props2.actions]);
  return (0, import_jsx_runtime6.jsx)(DocumentFieldActionsContext.Provider, { value, children: props2.children });
}
function useDocumentFieldActions() {
  const context = import_react51.default.useContext(DocumentFieldActionsContext);
  if (!context) {
    throw new Error("useDocumentFieldActions must be used within a DocumentFieldActionsProvider");
  }
  return context.actions;
}
function FormBuilder(props2) {
  const { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id: id4, members, onChange, onPathBlur, onPathFocus, onPathOpen, onFieldGroupSelect, onSetFieldSetCollapsed, onSetPathCollapsed, presence, readOnly, schemaType, validation: validation2, value } = props2;
  const handleCollapseField = (0, import_react51.useCallback)((fieldName) => onSetPathCollapsed([fieldName], true), [onSetPathCollapsed]);
  const handleExpandField = (0, import_react51.useCallback)((fieldName) => onSetPathCollapsed([fieldName], false), [onSetPathCollapsed]);
  const handleBlur = (0, import_react51.useCallback)(() => onPathBlur(EMPTY_ARRAY$b), [onPathBlur]);
  const handleFocus = (0, import_react51.useCallback)(() => onPathFocus(EMPTY_ARRAY$b), [onPathFocus]);
  const handleChange = (0, import_react51.useCallback)((patch2) => onChange(PatchEvent.from(patch2)), [onChange]);
  const focusRef = (0, import_react51.useRef)(null);
  const handleSelectFieldGroup = (0, import_react51.useCallback)((groupName) => onFieldGroupSelect(EMPTY_ARRAY$b, groupName), [onFieldGroupSelect]);
  const handleOpenField = (0, import_react51.useCallback)((fieldName) => onPathOpen([fieldName]), [onPathOpen]);
  const handleCloseField = (0, import_react51.useCallback)(() => onPathOpen([]), [onPathOpen]);
  const handleCollapseFieldSet = (0, import_react51.useCallback)((fieldSetName) => onSetFieldSetCollapsed([fieldSetName], true), [onSetFieldSetCollapsed]);
  const handleExpandFieldSet = (0, import_react51.useCallback)((fieldSetName) => onSetFieldSetCollapsed([fieldSetName], false), [onSetFieldSetCollapsed]);
  const Input3 = useInputComponent();
  const Field = useFieldComponent();
  const Preview2 = usePreviewComponent();
  const Item3 = useItemComponent();
  const Block2 = useBlockComponent();
  const InlineBlock = useInlineBlockComponent();
  const Annotation2 = useAnnotationComponent();
  const renderInput = (0, import_react51.useCallback)((inputProps) => (0, import_jsx_runtime6.jsx)(Input3, { ...inputProps }), [Input3]);
  const renderField = (0, import_react51.useCallback)((fieldProps) => (0, import_jsx_runtime6.jsx)(Field, { ...fieldProps }), [Field]);
  const renderItem = (0, import_react51.useCallback)((itemProps) => (0, import_jsx_runtime6.jsx)(Item3, { ...itemProps }), [Item3]);
  const renderPreview = (0, import_react51.useCallback)((previewProps) => (0, import_jsx_runtime6.jsx)(PreviewLoader, { component: Preview2, ...previewProps }), [Preview2]);
  const renderBlock = (0, import_react51.useCallback)((blockProps) => (0, import_jsx_runtime6.jsx)(Block2, { ...blockProps }), [Block2]);
  const renderInlineBlock = (0, import_react51.useCallback)((blockProps) => (0, import_jsx_runtime6.jsx)(InlineBlock, { ...blockProps }), [InlineBlock]);
  const renderAnnotation = (0, import_react51.useCallback)((annotationProps) => (0, import_jsx_runtime6.jsx)(Annotation2, { ...annotationProps }), [Annotation2]);
  const rootInputProps = { focusPath, elementProps: {
    ref: focusRef,
    id: id4,
    onBlur: handleBlur,
    onFocus: handleFocus,
    "aria-describedby": void 0
    // Root input should not have any aria-describedby
  }, changed: members.some((m2) => m2.kind === "field" && m2.field.changed), focused, groups, id: id4, level: 0, members, onChange: handleChange, onFieldClose: handleCloseField, onFieldCollapse: handleCollapseField, onFieldSetCollapse: handleCollapseFieldSet, onFieldExpand: handleExpandField, onFieldSetExpand: handleExpandFieldSet, onPathFocus, onFieldOpen: handleOpenField, onFieldGroupSelect: handleSelectFieldGroup, path: EMPTY_ARRAY$b, presence: EMPTY_ARRAY$b, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, validation: EMPTY_ARRAY$b, value };
  return (0, import_jsx_runtime6.jsx)(FormProvider, { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id: id4, onChange, onPathBlur, onPathFocus, onPathOpen, onFieldGroupSelect, onSetPathCollapsed, onSetFieldSetCollapsed, presence, validation: validation2, readOnly, schemaType, children: (0, import_jsx_runtime6.jsx)(GetFormValueProvider, { value, children: (0, import_jsx_runtime6.jsx)(FormValueProvider, { value, children: (0, import_jsx_runtime6.jsx)(DocumentFieldActionsProvider, { actions: fieldActions, children: renderInput(rootInputProps) }) }) }) });
}
var Context = (0, import_react51.createContext)({});
function useReferenceInputOptions() {
  return (0, import_react51.useContext)(Context);
}
function ReferenceInputOptionsProvider(props2) {
  const { children, activePath, EditReferenceLinkComponent, onEditReference, initialValueTemplateItems } = props2;
  const contextValue = (0, import_react51.useMemo)(() => ({ activePath, EditReferenceLinkComponent, onEditReference, initialValueTemplateItems }), [activePath, EditReferenceLinkComponent, onEditReference, initialValueTemplateItems]);
  return (0, import_jsx_runtime6.jsx)(Context.Provider, { value: contextValue, children });
}
var ReviewChangesContext = (0, import_react51.createContext)(null);
function useReviewChanges() {
  const reviewChanges = (0, import_react51.useContext)(ReviewChangesContext);
  if (!reviewChanges) {
    throw new Error("Review changes: missing context value");
  }
  return reviewChanges;
}
function useScrollIntoViewOnFocusWithin(elementRef, hasFocusWithin) {
  return useDidUpdate(hasFocusWithin, (0, import_react51.useCallback)((hadFocus, hasFocus) => {
    if (elementRef.current && !hadFocus && hasFocus) {
      e(elementRef.current, { scrollMode: "always" });
    }
  }, [elementRef]));
}
function whatwgRNG3() {
  let length2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  const rnds8 = new Uint8Array(length2);
  getRandomValues(rnds8);
  return rnds8;
}
var getByteHexTable2 = (() => {
  let table;
  return () => {
    if (table) {
      return table;
    }
    table = [];
    for (let i = 0; i < 256; ++i) {
      table[i] = (i + 256).toString(16).substring(1);
    }
    return table;
  };
})();
function randomKey3(length2) {
  const table = getByteHexTable2();
  return whatwgRNG3(length2).reduce((str, n) => str + table[n], "").slice(0, length2);
}
var __freeze$1_ = Object.freeze;
var __defProp$1_ = Object.defineProperty;
var __template$1_ = (cooked, raw) => __freeze$1_(__defProp$1_(cooked, "raw", { value: __freeze$1_(raw || cooked.slice()) }));
var _a$1_;
var _b$X;
var PRESENCE_MENU_POPOVER_PROPS = { portal: true };
var AvatarStackCard$1 = st(Card)((_ref147) => {
  let { theme, $selected } = _ref147;
  var _a22;
  const { color: color3 } = theme.sanity;
  return nt(_a$1_ || (_a$1_ = __template$1_(["\n    --card-bg-color: inherit;\n    --card-fg-color: inherit;\n    --card-hairline-hard-color: ", ";\n  "])), $selected ? (_a22 = color3.selectable) == null ? void 0 : _a22.default.pressed.border : void 0);
});
var TooltipContentBox$2 = st(Box)(_b$X || (_b$X = __template$1_(["\n  max-width: 150px;\n"])));
var getTooltipText = (presence) => {
  if (presence.length === 1) {
    return "".concat(presence[0].user.displayName, " is editing this document");
  }
  if (presence.length > 1) {
    return "".concat(presence.length, " people are editing this document right now");
  }
  return void 0;
};
function DocumentPreviewPresence(props2) {
  const { presence } = props2;
  const { color: color3 } = Je().sanity;
  const invertedScheme = color3.dark ? "light" : "dark";
  const { selected } = usePreviewCard();
  const uniqueUsers = (0, import_react51.useMemo)(() => Array.from(new Set(presence.map((a) => a.user.id))).map((id4) => {
    return presence.find((a) => a.user.id === id4);
  }).filter(isNonNullable$3), [presence]);
  const tooltipContent = (0, import_react51.useMemo)(() => {
    return (0, import_jsx_runtime6.jsx)(TooltipContentBox$2, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", size: 1, children: getTooltipText(uniqueUsers) }) });
  }, [uniqueUsers]);
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content: tooltipContent, ...PRESENCE_MENU_POPOVER_PROPS, children: (0, import_jsx_runtime6.jsx)(AvatarStackCard$1, { scheme: selected ? invertedScheme : void 0, $selected: selected, children: (0, import_jsx_runtime6.jsx)(AvatarStack, { maxLength: 2, "aria-label": getTooltipText(uniqueUsers), children: uniqueUsers.map((item) => (0, import_jsx_runtime6.jsx)(UserAvatar, { user: item.user }, item.user.id)) }) }) });
}
var symbols2 = /[^\p{Alpha}\p{White_Space}]/gu;
var whitespace = new RegExp("\\p{White_Space}+", "u");
var LEGACY_TO_UI_AVATAR_SIZES = { small: 0, medium: 1, large: 2 };
function nameToInitials(fullName) {
  const namesArray = fullName.replace(symbols2, "").split(whitespace);
  if (namesArray.length === 1) {
    return "".concat(namesArray[0].charAt(0)).toUpperCase();
  }
  return "".concat(namesArray[0].charAt(0)).concat(namesArray[namesArray.length - 1].charAt(0));
}
function UserAvatar(props2) {
  const { user, ...restProps } = props2;
  if (isRecord$4(user)) {
    if (restProps.withTooltip) {
      return (0, import_jsx_runtime6.jsx)(TooltipUserAvatar, { ...restProps, user });
    }
    return (0, import_jsx_runtime6.jsx)(StaticUserAvatar, { ...restProps, user });
  }
  return (0, import_jsx_runtime6.jsx)(UserAvatarLoader, { ...props2, user });
}
function TooltipUserAvatar(props2) {
  const { user: { displayName } } = props2;
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: displayName }) }), placement: "top", portal: true, children: (0, import_jsx_runtime6.jsx)("div", { style: { display: "inline-block" }, children: (0, import_jsx_runtime6.jsx)(StaticUserAvatar, { ...props2 }) }) });
}
var StaticUserAvatar = (0, import_react51.forwardRef)(function StaticUserAvatar2(props2, ref) {
  const { user, animateArrowFrom, position, size: size2, status, tone, ...restProps } = props2;
  const [imageLoadError, setImageLoadError] = (0, import_react51.useState)(null);
  const userColor = useUserColor(user.id);
  const imageUrl = imageLoadError ? void 0 : user == null ? void 0 : user.imageUrl;
  return (0, import_jsx_runtime6.jsx)(Avatar, { animateArrowFrom, arrowPosition: position, color: userColor.name, "data-legacy-tone": tone, initials: (user == null ? void 0 : user.displayName) && nameToInitials(user.displayName), src: imageUrl, onImageLoadError: setImageLoadError, ref, size: typeof size2 === "string" ? LEGACY_TO_UI_AVATAR_SIZES[size2] : size2, status, title: user == null ? void 0 : user.displayName, ...restProps });
});
function UserAvatarLoader(_ref148) {
  let { user, ...loadedProps } = _ref148;
  const [value] = useUser(user);
  if (!value) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(UserAvatar, { ...loadedProps, user: value });
}
var MAX_AVATARS_DOCK = 3;
var DEFAULT_MAX_AVATARS_FIELDS = 3;
var AVATAR_DISTANCE = -4;
var AVATAR_SIZE$1 = 23;
var AVATAR_ARROW_HEIGHT = 4;
var INTERSECTION_THRESHOLDS = [0, 0.25, 0.75, 1];
var INTERSECTION_ELEMENT_PADDING = 23;
var SNAP_TO_DOCK_DISTANCE_TOP = 8;
var SNAP_TO_DOCK_DISTANCE_BOTTOM = 8;
var SLIDE_RIGHT_THRESHOLD_TOP = 20;
var SLIDE_RIGHT_THRESHOLD_BOTTOM = 20;
var DEBUG = false;
var splitRight = (array3, max2) => {
  const indexFromMax = array3.length > max2 ? max2 - 1 : max2;
  const idx = Math.max(0, array3.length - indexFromMax);
  return [array3.slice(0, idx), array3.slice(idx)];
};
function calcAvatarStackWidth(len) {
  return -AVATAR_DISTANCE + (AVATAR_SIZE$1 + AVATAR_DISTANCE) * len;
}
var __freeze$1Z = Object.freeze;
var __defProp$1Z = Object.defineProperty;
var __template$1Z = (cooked, raw) => __freeze$1Z(__defProp$1Z(cooked, "raw", { value: __freeze$1Z(raw || cooked.slice()) }));
var _a$1Z;
var _b$W;
var FlexWrapper$1 = st(Flex)(_a$1Z || (_a$1Z = __template$1Z(["\n  & > div:first-child {\n    flex: 1;\n    min-width: 0;\n  }\n"])));
var InnerBox = st(Flex)(_b$W || (_b$W = __template$1Z(["\n  height: 23px;\n  min-width: 23px;\n  vertical-align: top;\n"])));
var FormFieldPresenceContext = import_react51.default.createContext([]);
function PresenceTooltip(props2) {
  const { children, items } = props2;
  const content = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(Stack, { padding: 1, sizing: "border", children: items.map((item) => (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, padding: 1, children: [(0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(UserAvatar, { user: item.user, status: "online" }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: item.user.displayName })] }, item.user.id)) }), [items]);
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content, placement: "top", portal: "documentScrollElement", children });
}
var { Tracker, useReporter, useReportedValues } = createTrackerScope();
var FieldPresenceInner = (0, import_react51.memo)(function FieldPresenceInner2(_ref149) {
  let { presence, position = "inside", animateArrowFrom = "inside", maxAvatars = DEFAULT_MAX_AVATARS_FIELDS, stack = true } = _ref149;
  const uniquePresence = (0, import_uniqBy2.default)(presence || [], (item) => item.user.id);
  const sorted = (0, import_sortBy.default)(uniquePresence, (_presence) => _presence.lastActiveAt);
  const [hidden, visible] = stack ? splitRight(sorted, maxAvatars) : [[], sorted];
  const avatars = [...visible.reverse().map((_visible) => ({ key: _visible.user.id, element: (0, import_jsx_runtime6.jsx)(UserAvatar, { animateArrowFrom, position, status: "online", user: _visible.user }) })), hidden.length >= 2 ? { key: "counter", element: (0, import_jsx_runtime6.jsx)(AvatarCounter, { count: hidden.length }) } : null].filter(Boolean);
  return (0, import_jsx_runtime6.jsxs)(FlexWrapper$1, { children: [(0, import_jsx_runtime6.jsx)("div", {}), (0, import_jsx_runtime6.jsx)(InnerBox, { direction: "row-reverse", children: avatars.map((av, i) => av && (0, import_jsx_runtime6.jsx)("div", { style: { position: "absolute", transform: "translate3d(".concat(-i * (AVATAR_SIZE$1 + AVATAR_DISTANCE), "px, 0px, 0px)"), transitionProperty: "transform", transitionDuration: "200ms", transitionTimingFunction: "cubic-bezier(0.85, 0, 0.15, 1)", zIndex: 100 - i }, children: av.element }, av.key)) })] });
});
function FieldPresenceWithOverlay(props2) {
  const contextPresence = (0, import_react51.useContext)(FormFieldPresenceContext);
  const { presence = contextPresence, maxAvatars = DEFAULT_MAX_AVATARS_FIELDS } = props2;
  const ref = (0, import_react51.useRef)(null);
  useReporter((0, import_react51.useId)(), () => ({ presence, element: ref.current, maxAvatars }));
  const uniquePresence = (0, import_react51.useMemo)(() => (0, import_uniqBy2.default)(presence || [], (item) => item.user.id), [presence]);
  return (0, import_jsx_runtime6.jsx)(PresenceTooltip, { items: uniquePresence, children: (0, import_jsx_runtime6.jsx)(FlexWrapper$1, { ref, style: { minHeight: AVATAR_SIZE$1, minWidth: AVATAR_SIZE$1 } }) });
}
function FieldPresenceWithoutOverlay(props2) {
  const contextPresence = (0, import_react51.useContext)(FormFieldPresenceContext);
  const { presence = contextPresence, maxAvatars = DEFAULT_MAX_AVATARS_FIELDS } = props2;
  if (!presence.length) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(FieldPresenceInner, { presence, maxAvatars });
}
var FieldPresence = FieldPresenceWithOverlay;
var EMPTY_ARRAY$7 = [];
function trimChildPath2(path2, childPath) {
  return startsWith(path2, childPath) ? trimLeft(path2, childPath) : EMPTY_ARRAY$7;
}
function PresenceScope(props2) {
  const { readOnly, path: path2, children } = props2;
  const contextPresence = import_react51.default.useContext(FormFieldPresenceContext);
  const childPresence = (0, import_react51.useMemo)(() => {
    return readOnly ? EMPTY_ARRAY$7 : (contextPresence || EMPTY_ARRAY$7).filter((presence) => {
      return startsWith(path2, presence.path);
    }).map((presence) => ({ ...presence, path: trimChildPath2(path2, presence.path) }));
  }, [contextPresence, path2, readOnly]);
  return (0, import_jsx_runtime6.jsx)(FormFieldPresenceContext.Provider, { value: childPresence, children });
}
var createIntersectionObserver = (options) => {
  const entries$ = new Subject();
  const intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      entries$.next(entry);
    });
  }, options);
  return { observe: (element) => {
    return new Observable((subscriber) => {
      const subscription = entries$.pipe(filter((entry) => entry.target === element)).subscribe(subscriber);
      intersectionObserver.observe(element);
      return () => {
        subscription.unsubscribe();
        intersectionObserver.unobserve(element);
      };
    });
  } };
};
var WithIntersection = (props2) => {
  const { onIntersection, io, id: id4, ...rest } = props2;
  const element = import_react51.default.useRef(null);
  import_react51.default.useEffect(() => {
    const el = element.current;
    if (!el)
      return void 0;
    const subscription = io.observe(el).pipe(tap((entry) => onIntersection(id4, entry))).subscribe();
    return () => subscription.unsubscribe();
  }, [io, id4, onIntersection]);
  return (0, import_jsx_runtime6.jsx)("div", { ref: element, ...rest });
};
var __freeze$1Y = Object.freeze;
var __defProp$1Y = Object.defineProperty;
var __template$1Y = (cooked, raw) => __freeze$1Y(__defProp$1Y(cooked, "raw", { value: __freeze$1Y(raw || cooked.slice()) }));
var _a$1Y;
var _b$V;
var _c$x;
var _d$l;
var _e$a;
var _f$8;
var _g$6;
var RootWrapper = st.div(_a$1Y || (_a$1Y = __template$1Y(["\n  position: relative;\n"])));
var OverlayWrapper = st.div(_b$V || (_b$V = __template$1Y(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n  z-index: 13;\n"])));
var RegionWrapper = nt(_c$x || (_c$x = __template$1Y(["\n  overflow: hidden;\n  overflow: clip;\n  pointer-events: none;\n  position: absolute;\n"])));
var TopRegionWrapper = st(WithIntersection)((_ref150) => {
  let { $debug, margins } = _ref150;
  return nt(_d$l || (_d$l = __template$1Y(["\n    ", "\n\n    z-index: 100;\n    position: sticky;\n    height: 1px;\n    top: ", ";\n    background-color: ", ";\n  "])), RegionWrapper, margins ? "".concat(margins[0] - 1, "px") : void 0, $debug ? "red" : "none");
});
var MiddleRegionWrapper = st(WithIntersection)((_ref151) => {
  let { $debug } = _ref151;
  return nt(_f$8 || (_f$8 = __template$1Y(["\n    ", "\n\n    visibility: none;\n\n    ", "\n  "])), RegionWrapper, $debug && nt(_e$a || (_e$a = __template$1Y(["\n      background: rgba(255, 0, 0, 0.25);\n      outline: 1px solid #00b;\n      visibility: visible;\n    "]))));
});
var BottomRegionWrapper = st(WithIntersection)((_ref152) => {
  let { $debug } = _ref152;
  return nt(_g$6 || (_g$6 = __template$1Y(["\n    ", "\n\n    position: sticky;\n    bottom: -1px;\n    height: 1px;\n    background-color: ", ";\n  "])), RegionWrapper, $debug ? "blue" : "transparent");
});
var toPx = (num) => "".concat(num, "px");
var negate = (num) => 0 - num;
var RegionsWithIntersections = (0, import_react51.forwardRef)(function RegionsWithIntersections2(props2, ref) {
  const { regions, render: render2, children, margins: marginsProp } = props2;
  const overlayRef = (0, import_react51.useRef)(null);
  const margins = (0, import_react51.useMemo)(() => marginsProp, [JSON.stringify(marginsProp)]);
  const io = (0, import_react51.useMemo)(() => createIntersectionObserver({ rootMargin: margins.map(negate).map(toPx).join(" "), threshold: INTERSECTION_THRESHOLDS }), [margins]);
  const [intersections, setIntersections] = (0, import_react51.useState)({});
  const onIntersection = (0, import_react51.useCallback)((id4, entry) => {
    setIntersections((current) => ({ ...current, [id4]: entry }));
  }, []);
  const top = intersections["::top"];
  const bottom2 = intersections["::bottom"];
  const regionsWithIntersectionDetails = (0, import_react51.useMemo)(() => top && bottom2 ? regions.filter((region) => {
    var _a4;
    return ((_a4 = region.presence) == null ? void 0 : _a4.length) > 0;
  }).map((region) => {
    const intersection3 = intersections[region.id];
    if (!intersection3) {
      return null;
    }
    const { bottom: boundsBottom, top: boundsTop } = intersection3.boundingClientRect;
    const aboveTop = intersection3.boundingClientRect.top < top.boundingClientRect.bottom;
    const belowBottom = intersection3.boundingClientRect.top < bottom2.boundingClientRect.top;
    const distanceTop = intersection3.isIntersecting ? boundsTop - (intersection3.intersectionRect.top - INTERSECTION_ELEMENT_PADDING) : aboveTop ? -top.boundingClientRect.bottom : bottom2.boundingClientRect.top;
    const distanceBottom = intersection3.isIntersecting ? -(boundsBottom - (intersection3.intersectionRect.bottom + INTERSECTION_ELEMENT_PADDING)) : belowBottom ? bottom2.boundingClientRect.top : -top.boundingClientRect.bottom;
    const position = (
      // eslint-disable-next-line no-nested-ternary
      distanceTop <= SNAP_TO_DOCK_DISTANCE_TOP ? "top" : distanceBottom <= SNAP_TO_DOCK_DISTANCE_BOTTOM ? "bottom" : "inside"
    );
    return { distanceTop, distanceBottom, region, position };
  }).filter(Boolean) : [], [bottom2, intersections, regions, top]);
  return (0, import_jsx_runtime6.jsxs)(RootWrapper, { ref, children: [(0, import_jsx_runtime6.jsx)(TopRegionWrapper, { $debug: DEBUG, io, id: "::top", onIntersection, margins }), (0, import_jsx_runtime6.jsx)("div", { children }), (0, import_jsx_runtime6.jsx)(OverlayWrapper, { ref: overlayRef, children: overlayRef.current && render2(regionsWithIntersectionDetails, overlayRef.current.offsetWidth) }), regions.map((region) => {
    const forceWidth = region.rect.width === 0;
    return (0, import_jsx_runtime6.jsx)(MiddleRegionWrapper, { $debug: DEBUG, io, onIntersection, id: region.id, style: { width: forceWidth ? 1 : region.rect.width, left: region.rect.left - (forceWidth ? 1 : 0), top: region.rect.top - INTERSECTION_ELEMENT_PADDING, height: region.rect.height + INTERSECTION_ELEMENT_PADDING * 2 } }, region.id);
  }), (0, import_jsx_runtime6.jsx)(BottomRegionWrapper, { $debug: DEBUG, id: "::bottom", io, onIntersection })] });
});
var ITEM_TRANSITION = { transitionProperty: "transform", transitionDuration: "200ms", transitionTimingFunction: "cubic-bezier(0.85, 0, 0.15, 1)" };
var bottom = (rect) => rect.top + rect.height;
function withSpacerHeight(regionsWithIntersectionDetails) {
  return regionsWithIntersectionDetails.map((withIntersection, idx, _regionsWithIntersectionDetails) => {
    var _a4;
    const prevRect = (_a4 = _regionsWithIntersectionDetails[idx - 1]) == null ? void 0 : _a4.region.rect;
    const prevBottom = prevRect ? bottom(prevRect) : 0;
    return { ...withIntersection, spacerHeight: withIntersection.region.rect.top - prevBottom };
  });
}
var orderByTop = (regionsWithIntersectionDetails) => (0, import_orderBy.default)(regionsWithIntersectionDetails, (withIntersection) => withIntersection.region.rect.top);
var plus2 = (a, b) => a + b;
var sum = (array3) => array3.reduce(plus2, 0);
function group(regionsWithIntersectionDetails) {
  const regionsWithSpacerHeight = withSpacerHeight(orderByTop(regionsWithIntersectionDetails));
  const grouped = { top: [], inside: [], bottom: [], ...(0, import_groupBy.default)(regionsWithSpacerHeight, (_withSpacerHeight) => _withSpacerHeight.position) };
  return { top: orderByTop(grouped.top).map((withIntersection, i, grp) => ({ ...withIntersection, indent: grp.slice(i + 1).reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0) })), inside: orderByTop(grouped.inside).map((withIntersection) => ({ ...withIntersection, indent: 0 })), bottom: orderByTop(grouped.bottom).map((withIntersection, i, grp) => ({ ...withIntersection, indent: grp.slice(0, i).reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0) })) };
}
var Spacer = (_ref153) => {
  let { height, ...rest } = _ref153;
  return (0, import_jsx_runtime6.jsx)("div", { style: { height: Math.max(0, height), ...rest == null ? void 0 : rest.style } });
};
var DEFAULT_MARGINS$1 = [0, 0, 0, 0];
var getOffsetsTo = (source, target) => {
  let el = source;
  let top = -el.scrollTop;
  let left = 0;
  while (el && el !== target) {
    top += el.offsetTop - el.scrollTop;
    left += el.offsetLeft;
    el = el.offsetParent instanceof HTMLElement ? el.offsetParent : null;
  }
  return { top, left };
};
function getRelativeRect(element, parent) {
  return { ...getOffsetsTo(element, parent), width: element.offsetWidth, height: element.offsetHeight };
}
function regionsWithComputedRects(regions, parent) {
  return regions.map((_ref154) => {
    let [id4, region] = _ref154;
    return { ...region, id: id4, rect: getRelativeRect(region.element, parent) };
  });
}
function StickyOverlay(props2) {
  const { children, margins = DEFAULT_MARGINS$1 } = props2;
  const reportedValues = useReportedValues();
  const ref = import_react51.default.useRef(null);
  const regions = import_react51.default.useMemo(() => ref.current ? regionsWithComputedRects(reportedValues, ref.current) : EMPTY_ARRAY$6, [reportedValues]);
  const renderCallback = import_react51.default.useCallback((regionsWithIntersectionDetails, containerWidth) => {
    const grouped = group(regionsWithIntersectionDetails.filter((item) => item.region.presence.length > 0));
    const topSpacing = sum(grouped.top.map((n) => n.region.rect.height + n.spacerHeight));
    const bottomSpacing = sum([...grouped.inside, ...grouped.bottom].map((n) => n.region.rect.height + n.spacerHeight));
    const counts = grouped.inside.reduce((_counts, withIntersection) => {
      const { distanceTop, distanceBottom } = withIntersection;
      const nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP;
      const nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM;
      return { nearTop: _counts.nearTop + (nearTop ? withIntersection.region.presence.length : 0), nearBottom: _counts.nearBottom + (nearBottom ? withIntersection.region.presence.length : 0) };
    }, { nearTop: 0, nearBottom: 0 });
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(PresenceDock, { closeCount: counts.nearTop, margins, position: "top", regionsWithIntersectionDetails: grouped.top }), (0, import_jsx_runtime6.jsx)(Spacer, { height: topSpacing }), (0, import_jsx_runtime6.jsx)(PresenceInside, { containerWidth, regionsWithIntersectionDetails: grouped.inside }), (0, import_jsx_runtime6.jsx)(Spacer, { height: bottomSpacing }), (0, import_jsx_runtime6.jsx)(PresenceDock, { closeCount: counts.nearBottom, margins, position: "bottom", regionsWithIntersectionDetails: grouped.bottom })] });
  }, [margins]);
  return (0, import_jsx_runtime6.jsx)(RegionsWithIntersections, { ref, margins, regions, render: renderCallback, children });
}
var EMPTY_ARRAY$6 = [];
var PresenceDock = (0, import_react51.memo)(function PresenceDock2(props2) {
  const { closeCount, margins, position, regionsWithIntersectionDetails } = props2;
  const dir2 = position === "top" ? 1 : -1;
  const allPresenceItems = (0, import_react51.useMemo)(() => {
    if (!regionsWithIntersectionDetails.length) {
      return EMPTY_ARRAY$6;
    }
    return (0, import_flatten5.default)((0, import_sortBy.default)(regionsWithIntersectionDetails, (r2) => r2.region.rect.top * dir2).map((withIntersection) => withIntersection.region.presence || EMPTY_ARRAY$6));
  }, [dir2, regionsWithIntersectionDetails]);
  const [topMargin, rightMargin, bottomMargin, leftMargin] = margins;
  const leftOffset = (leftMargin || 0) + (allPresenceItems.length > 0 ? -closeCount * (AVATAR_SIZE$1 + AVATAR_DISTANCE) : 0) - rightMargin;
  const margin = position === "top" ? topMargin : bottomMargin;
  const style = (0, import_react51.useMemo)(() => ({ zIndex: 2, position: "sticky", display: "flex", flexDirection: "column", alignItems: "flex-end", ...ITEM_TRANSITION, transform: "translate3d(".concat(leftOffset, "px, 0px, 0px)"), top: AVATAR_ARROW_HEIGHT + 1 + margin, bottom: AVATAR_ARROW_HEIGHT + 1 + margin }), [leftOffset, margin]);
  return (0, import_jsx_runtime6.jsx)("div", { "data-dock": position, style, children: (0, import_jsx_runtime6.jsx)(FieldPresenceInner, { position, maxAvatars: MAX_AVATARS_DOCK, presence: allPresenceItems }) }, "sticky-".concat(position));
});
function PresenceInside(props2) {
  const { regionsWithIntersectionDetails, containerWidth } = props2;
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: regionsWithIntersectionDetails.map((withIntersection) => {
    const originalLeft = withIntersection.region.rect.left;
    const { distanceTop, distanceBottom } = withIntersection;
    const nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP;
    const nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM;
    const diffRight = containerWidth - originalLeft - withIntersection.region.rect.width;
    const { presence, maxAvatars } = withIntersection.region;
    return (0, import_jsx_runtime6.jsx)(import_react51.default.Fragment, { children: (0, import_jsx_runtime6.jsx)("div", { style: { zIndex: 2, position: "absolute", ...ITEM_TRANSITION, left: originalLeft, transform: "translate3d(".concat(nearTop || nearBottom ? diffRight : 0, "px, 0px, 0px)"), height: withIntersection.region.rect.height, top: withIntersection.region.rect.top }, children: (0, import_jsx_runtime6.jsx)(DebugValue, { value: () => "".concat(distanceTop, " | ").concat(distanceBottom, ""), children: (0, import_jsx_runtime6.jsx)(FieldPresenceInner, { stack: !nearTop && !nearBottom, position: nearTop ? "top" : nearBottom ? "bottom" : "inside", maxAvatars, presence }) }) }) }, withIntersection.region.id);
  }) });
}
var PassThrough = (props2) => props2.children;
var DebugValue = PassThrough;
var DEFAULT_MARGINS = [0, 0, 0, 0];
function OverlayEnabled(_ref155) {
  let { children, margins } = _ref155;
  return (0, import_jsx_runtime6.jsx)(Tracker, { children: (0, import_jsx_runtime6.jsx)(StickyOverlay, { margins: margins || DEFAULT_MARGINS, children }) });
}
function OverlayDisabled(props2) {
  return props2.children;
}
var PresenceOverlay = OverlayEnabled;
var __freeze$1X = Object.freeze;
var __defProp$1X = Object.defineProperty;
var __template$1X = (cooked, raw) => __freeze$1X(__defProp$1X(cooked, "raw", { value: __freeze$1X(raw || cooked.slice()) }));
var _a$1X;
var _b$U;
var _c$w;
var _d$k;
var _e$9;
var _f$7;
var TOOLTIP_GROUP_DELAY = { open: 500 };
var Root$n2 = st(Flex)(_a$1X || (_a$1X = __template$1X(["\n  /* Prevent buttons from taking up extra vertical space */\n  line-height: 1;\n  /* For floating actions menu */\n  position: relative;\n"])));
var PresenceBox = st(Box)((_ref156) => {
  let { theme, $right } = _ref156;
  const { space } = theme.sanity;
  return nt(_b$U || (_b$U = __template$1X(["\n    position: absolute;\n    bottom: 0;\n    right: ", "px;\n  "])), $right + space[1]);
});
var ContentBox = st(Box)((_ref157) => {
  let { theme, $presenceMaxWidth } = _ref157;
  const { space } = theme.sanity;
  return nt(_c$w || (_c$w = __template$1X(["\n    max-width: calc(100% - ", "px);\n    min-width: 75%;\n  "])), $presenceMaxWidth + space[1]);
});
var SlotBox = st(Box)((_ref158) => {
  let { theme, $right, $fieldActionsVisible } = _ref158;
  const { space } = theme.sanity;
  const right = $fieldActionsVisible ? $right + space[1] : $right;
  return nt(_d$k || (_d$k = __template$1X(["\n    position: absolute;\n    bottom: 0;\n    right: ", "px;\n  "])), right);
});
var FieldActionsFloatingCard = st(Card)((_ref159) => {
  let { theme } = _ref159;
  const space = theme.sanity.space[1] / 2;
  return nt(_e$9 || (_e$9 = __template$1X(["\n    align-items: center;\n    bottom: 0;\n    gap: ", "px;\n    padding: ", "px;\n    position: absolute;\n    right: 0;\n\n    @media (hover: hover) {\n      // If hover is supported, we hide the floating card by default\n      // and only show it when it has focus within or when the field is hovered or focused.\n      opacity: 0;\n      pointer-events: none;\n      width: 0;\n\n      [data-ui='FieldActionsFlex'] {\n        opacity: 0;\n        width: 0;\n      }\n\n      &[data-actions-visible='false']:not(:focus-within) {\n        // Remove the shadow when the field actions are not visible\n        box-shadow: none;\n\n        // Since the field actions always will be present in the DOM (to make them focusable) \n        // they will always affect the width of the floating card, even when they are not visible.\n        // Therefore, we remove the background of the floating card when the field actions are not visible.\n        background: transparent;\n      }\n\n      // Remove the shadow when the field has comments but no actions\n      &[data-has-comments='true']:not([data-has-actions='true']) {\n        box-shadow: none;\n      }\n\n      // Show the floating card when it has focus within (ie when field actions are focused).\n      &:focus-within {\n        opacity: 1;\n        pointer-events: auto;\n        width: max-content;\n\n        [data-ui='FieldActionsFlex'] {\n          opacity: 1;\n          pointer-events: auto;\n          width: max-content;\n        }\n      }\n    }\n\n    &[data-visible='true'] {\n      opacity: 1;\n      pointer-events: auto;\n      width: max-content;\n    }\n\n    &[data-actions-visible='true'] {\n      [data-ui='FieldActionsFlex'] {\n        opacity: 1;\n        pointer-events: auto;\n        width: max-content;\n      }\n    }\n  "])), space, space);
});
var FieldActionsFlex = st(Flex)(_f$7 || (_f$7 = __template$1X(["\n  gap: inherit;\n"])));
var MAX_AVATARS$1 = 4;
function FormFieldBaseHeader(props2) {
  const { __internal_comments: comments, __internal_slot: slot, actions, content, fieldFocused, fieldHovered, presence } = props2;
  const [menuOpen, setMenuOpen] = (0, import_react51.useState)(false);
  const [floatingCardElement, setFloatingCardElement] = (0, import_react51.useState)(null);
  const [floatingCardWidth, setFloatingCardWidth] = (0, import_react51.useState)(0);
  const [slotElement, setSlotElement] = (0, import_react51.useState)(null);
  const [slotWidth, setSlotWidth] = (0, import_react51.useState)(0);
  const { hasComments = false, button: commentButton = null, isAddingComment = false } = comments || {};
  const hasActions = actions && actions.length > 0;
  const showFieldActions = fieldFocused || fieldHovered || menuOpen || isAddingComment;
  const hasCommentsButtonOrActions = (comments == null ? void 0 : comments.button) || hasActions;
  const shouldShowFloatingCard = showFieldActions || hasComments;
  const handleSetFloatingCardElementWidth = (0, import_react51.useCallback)(() => {
    if (floatingCardElement) {
      const { width } = floatingCardElement.getBoundingClientRect();
      setFloatingCardWidth(width || 0);
    }
  }, [floatingCardElement]);
  const handleFocusCapture = (0, import_react51.useCallback)(handleSetFloatingCardElementWidth, [handleSetFloatingCardElementWidth]);
  const handleBlurCapture = (0, import_react51.useCallback)(handleSetFloatingCardElementWidth, [handleSetFloatingCardElementWidth]);
  (0, import_react51.useEffect)(() => {
    handleSetFloatingCardElementWidth();
  }, [handleSetFloatingCardElementWidth, showFieldActions]);
  (0, import_react51.useEffect)(() => {
    if (slotElement) {
      const { width } = slotElement.getBoundingClientRect();
      setSlotWidth(width || 0);
    }
  }, [slotElement]);
  const slotEl = (0, import_react51.useMemo)(() => {
    if (!slot)
      return null;
    return (0, import_jsx_runtime6.jsx)(SlotBox, { $fieldActionsVisible: Boolean(showFieldActions), $right: floatingCardWidth, ref: setSlotElement, children: slot });
  }, [floatingCardWidth, showFieldActions, slot]);
  return (0, import_jsx_runtime6.jsxs)(Root$n2, { align: "flex-end", children: [(0, import_jsx_runtime6.jsx)(ContentBox, { flex: 1, paddingY: 2, $presenceMaxWidth: calcAvatarStackWidth(MAX_AVATARS$1), children: content }), presence && presence.length > 0 && (0, import_jsx_runtime6.jsx)(PresenceBox, { flex: "none", paddingBottom: 1, $right: floatingCardWidth + slotWidth, children: (0, import_jsx_runtime6.jsx)(FieldPresence, { maxAvatars: MAX_AVATARS$1, presence }) }), slotEl, (hasCommentsButtonOrActions || hasComments) && (0, import_jsx_runtime6.jsx)(TooltipDelayGroupProvider, { delay: TOOLTIP_GROUP_DELAY, children: (0, import_jsx_runtime6.jsxs)(FieldActionsFloatingCard, { "data-actions-visible": showFieldActions ? "true" : "false", "data-has-actions": hasActions ? "true" : "false", "data-has-comments": hasComments ? "true" : "false", "data-visible": shouldShowFloatingCard ? "true" : "false", display: "flex", onBlurCapture: handleBlurCapture, onFocusCapture: handleFocusCapture, radius: 2, ref: setFloatingCardElement, shadow: 2, sizing: "border", children: [hasActions && (0, import_jsx_runtime6.jsx)(FieldActionsFlex, { align: "center", "data-ui": "FieldActionsFlex", children: (0, import_jsx_runtime6.jsx)(FieldActionMenu, { nodes: actions, onMenuOpenChange: setMenuOpen }) }), commentButton] }) })] });
}
function createDescriptionId(id4, description) {
  if (!description || !id4)
    return void 0;
  return "desc_".concat(id4);
}
var __freeze$1W = Object.freeze;
var __defProp$1W = Object.defineProperty;
var __template$1W = (cooked, raw) => __freeze$1W(__defProp$1W(cooked, "raw", { value: __freeze$1W(raw || cooked.slice()) }));
var _a$1W;
var EMPTY_ARRAY$5 = [];
var VALIDATION_STYLES = { error: { color: hues.red[500].hex }, warning: { color: hues.yellow[500].hex }, info: { color: hues.blue[500].hex } };
var VALIDATION_ICONS = { error: ValidationErrorIcon, warning: ValidationWarningIcon, info: ValidationInfoIcon };
var StyledStack = st(Stack)(_a$1W || (_a$1W = __template$1W(["\n  max-width: 200px;\n"])));
function FormFieldValidationStatus(props2) {
  const { validation: validation2 = EMPTY_ARRAY$5, __unstable_showSummary: showSummary, fontSize: fontSize2, placement = "top" } = props2;
  const hasErrors = validation2.some((v) => v.level === "error");
  const hasWarnings = validation2.some((v) => v.level === "warning");
  const hasInfo = validation2.some((v) => v.level === "info");
  const StatusIcon = (() => {
    if (hasErrors)
      return VALIDATION_ICONS.error;
    if (hasWarnings)
      return VALIDATION_ICONS.warning;
    if (hasInfo)
      return VALIDATION_ICONS.info;
    return void 0;
  })();
  const statusStyle = (() => {
    if (hasErrors)
      return VALIDATION_STYLES.error;
    if (hasWarnings)
      return VALIDATION_STYLES.warning;
    if (hasInfo)
      return VALIDATION_STYLES.info;
    return void 0;
  })();
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsxs)(StyledStack, { padding: 3, space: 3, children: [showSummary && (0, import_jsx_runtime6.jsx)(FormFieldValidationSummary, { validation: validation2 }), !showSummary && (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: validation2.map((item, itemIndex) => (
    // eslint-disable-next-line react/no-array-index-key
    (0, import_jsx_runtime6.jsx)(FormFieldValidationStatusItem, { validation: item }, itemIndex)
  )) })] }), portal: true, placement, fallbackPlacements: ["bottom", "right", "left"], children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: fontSize2, weight: "semibold", style: statusStyle, children: StatusIcon && (0, import_jsx_runtime6.jsx)(StatusIcon, {}) }) }) });
}
function FormFieldValidationStatusItem(props2) {
  const { validation: validation2 } = props2;
  const StatusIcon = (() => {
    if (validation2.level === "error")
      return VALIDATION_ICONS.error;
    if (validation2.level === "warning")
      return VALIDATION_ICONS.warning;
    if (validation2.level === "info")
      return VALIDATION_ICONS.info;
    return void 0;
  })();
  const statusStyle = (() => {
    if (validation2.level === "error")
      return VALIDATION_STYLES.error;
    if (validation2.level === "warning")
      return VALIDATION_STYLES.warning;
    if (validation2.level === "info")
      return VALIDATION_STYLES.info;
    return void 0;
  })();
  return (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { marginRight: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, style: statusStyle, children: StatusIcon && (0, import_jsx_runtime6.jsx)(StatusIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: validation2.message }) })] });
}
function FormFieldValidationSummary(_ref160) {
  let { validation: validation2 } = _ref160;
  const { t: t3 } = useTranslation2();
  const listFormatter = useIntlListFormat();
  const errorCount = validation2.reduce((count2, item) => item.level === "error" ? count2 + 1 : count2, 0);
  const warningCount = validation2.reduce((count2, item) => item.level === "warning" ? count2 + 1 : count2, 0);
  const hasErrors = errorCount > 0;
  const hasWarnings = warningCount > 0;
  if (!hasErrors && !hasWarnings) {
    return null;
  }
  const errorText = hasErrors && t3("form.validation.summary.errors-count", { count: errorCount });
  const warningText = hasWarnings && t3("form.validation.summary.warnings-count", { count: warningCount });
  return errorText && warningText ? (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: listFormatter.format([errorText, warningText]) }) : (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: errorText || warningText });
}
function ValidationErrorIcon() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, { "data-testid": "input-validation-icon-error", "aria-label": t3("form.validation.has-error-aria-label"), "aria-hidden": true, role: "presentation" });
}
function ValidationWarningIcon() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, { "data-testid": "input-validation-icon-warning", "aria-label": t3("form.validation.has-warning-aria-label"), "aria-hidden": true, role: "presentation" });
}
function ValidationInfoIcon() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(InfoOutlineIcon, { "data-testid": "input-validation-icon-info", "aria-label": t3("form.validation.has-info-aria-label"), "aria-hidden": true, role: "presentation" });
}
var EMPTY_ARRAY$4 = [];
var FormFieldHeaderText = (0, import_react51.memo)(function FormFieldHeaderText2(props2) {
  const { description, inputId, title, validation: validation2 = EMPTY_ARRAY$4 } = props2;
  const { t: t3 } = useTranslation2();
  const hasValidations = validation2.length > 0;
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "label", htmlFor: inputId, weight: "semibold", size: 1, children: title || (0, import_jsx_runtime6.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t3("form.field.untitled-field-label") }) }), hasValidations && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(FormFieldValidationStatus, { fontSize: 1, validation: validation2 }) })] }), description && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, id: createDescriptionId(inputId, description), children: description })] });
});
var EMPTY_ARRAY$3 = [];
var FormField = (0, import_react51.memo)(function FormField2(props2) {
  const { __unstable_headerActions: actions = EMPTY_ARRAY$3, __unstable_presence: presence = EMPTY_ARRAY$3, __internal_slot: slot = null, __internal_comments: comments, children, description, inputId, level, title, validation: validation2, ...restProps } = props2;
  const { focused, hovered, onMouseEnter, onMouseLeave } = useFieldActions();
  return (0, import_jsx_runtime6.jsxs)(Stack, { ...restProps, "data-level": level, onMouseEnter, onMouseLeave, space: 1, children: [title && (0, import_jsx_runtime6.jsx)(FormFieldBaseHeader, { __internal_comments: comments, __internal_slot: slot, actions, fieldFocused: Boolean(focused), fieldHovered: hovered, presence, content: (0, import_jsx_runtime6.jsx)(FormFieldHeaderText, { description, inputId, title, validation: validation2 }) }), (0, import_jsx_runtime6.jsx)("div", { children })] });
});
var __freeze$1V = Object.freeze;
var __defProp$1V = Object.defineProperty;
var __template$1V = (cooked, raw) => __freeze$1V(__defProp$1V(cooked, "raw", { value: __freeze$1V(raw || cooked.slice()) }));
var _a$1V;
var _b$T;
var _c$v;
var Root$m2 = st.legend(_a$1V || (_a$1V = __template$1V(["\n  /* See: https://thatemil.com/blog/2015/01/03/reset-your-fieldset/ */\n  padding: 0;\n  display: table;\n"])));
var ToggleButton = st(Flex).attrs({ forwardedAs: "button" })((props2) => {
  const { theme } = props2;
  const { focusRing, radius } = theme.sanity;
  const { base } = theme.sanity.color;
  return nt(_b$T || (_b$T = __template$1V(["\n    appearance: none;\n    border: 0;\n    background: none;\n    color: inherit;\n    -webkit-font-smoothing: inherit;\n    font: inherit;\n    outline: none;\n    border-radius: ", ";\n    position: relative;\n\n    &:not([hidden]) {\n      display: flex;\n    }\n\n    &:focus {\n      box-shadow: ", ";\n    }\n\n    &:focus:not(:focus-visible) {\n      box-shadow: none;\n    }\n\n    /* Added to increase the hit area of the collapsible fieldset */\n    &::after {\n      content: '';\n      position: absolute;\n      top: -10px;\n      right: -10px;\n      bottom: -10px;\n      left: -10px;\n    }\n  "])), rem(radius[1]), focusRingStyle$2({ base, focusRing }));
});
var ToggleIconBox = st(Box)(_c$v || (_c$v = __template$1V(["\n  width: 9px;\n  height: 9px;\n  margin-right: 3px;\n\n  & svg {\n    transition: transform 100ms;\n  }\n"])));
var FormFieldSetLegend = (0, import_react51.memo)(function FormFieldSetLegend2(props2) {
  const { collapsed, collapsible, onClick, title } = props2;
  const { t: t3 } = useTranslation2();
  const text = (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", size: 1, children: title || (0, import_jsx_runtime6.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t3("form.field.untitled-fieldset-label") }) });
  if (!collapsible) {
    return (0, import_jsx_runtime6.jsx)(Root$m2, { children: text });
  }
  return (0, import_jsx_runtime6.jsx)(Root$m2, { children: (0, import_jsx_runtime6.jsxs)(ToggleButton, { type: "button", onClick, children: [(0, import_jsx_runtime6.jsx)(ToggleIconBox, { children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(ToggleArrowRightIcon, { style: { transform: "rotate(".concat(collapsed ? "0" : "90deg", ") translate3d(0, 0, 0)") } }) }) }), text] }) });
});
var __freeze$1U = Object.freeze;
var __defProp$1U = Object.defineProperty;
var __template$1U = (cooked, raw) => __freeze$1U(__defProp$1U(cooked, "raw", { value: __freeze$1U(raw || cooked.slice()) }));
var _a$1U;
var _b$S;
function getChildren(children) {
  return typeof children === "function" ? children() : children;
}
var Root$l2 = st(Box).attrs({ forwardedAs: "fieldset" })(_a$1U || (_a$1U = __template$1U(["\n  border: none;\n\n  /* See: https://thatemil.com/blog/2015/01/03/reset-your-fieldset/ */\n  body:not(:-moz-handler-blocked) & {\n    display: table-cell;\n  }\n"])));
var Content$1 = st(Box)((props2) => {
  const { $borderLeft, theme } = props2;
  const { focusRing, radius } = theme.sanity;
  const { base } = theme.sanity.color;
  return nt(_b$S || (_b$S = __template$1U(["\n    outline: none;\n    border-left: ", ";\n    border-radius: ", ";\n\n    &:focus {\n      box-shadow: ", ";\n    }\n\n    &:focus:not(:focus-visible) {\n      box-shadow: none;\n    }\n  "])), $borderLeft ? "1px solid var(--card-border-color)" : void 0, rem(radius[1]), focusRingStyle$2({ base, focusRing: { ...focusRing, offset: 2 } }));
});
var EMPTY_ARRAY$2 = [];
var FormFieldSet = (0, import_react51.forwardRef)(function FormFieldSet2(props2, ref) {
  const { __internal_comments: comments, __internal_slot: slot = null, __unstable_headerActions: actions = EMPTY_ARRAY$2, __unstable_presence: presence = EMPTY_ARRAY$2, children, collapsed, collapsible, columns, description, level = 0, onCollapse, onExpand, onFocus, tabIndex, title, validation: validation2 = EMPTY_ARRAY$2, inputId, ...restProps } = props2;
  const { focused, hovered, onMouseEnter, onMouseLeave } = useFieldActions();
  const hasValidationMarkers = validation2.length > 0;
  const forwardedRef = useForwardedRef(ref);
  const handleFocus = (0, import_react51.useCallback)((event) => {
    const element = forwardedRef.current;
    if (element === event.target) {
      if (onFocus)
        onFocus(event);
    }
  }, [forwardedRef, onFocus]);
  const handleToggle = (0, import_react51.useCallback)(() => collapsed ? onExpand == null ? void 0 : onExpand() : onCollapse == null ? void 0 : onCollapse(), [collapsed, onCollapse, onExpand]);
  const content = (0, import_react51.useMemo)(() => {
    if (collapsed) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(Grid, { columns, gapX: 4, gapY: 5, children: getChildren(children) });
  }, [children, collapsed, columns]);
  return (0, import_jsx_runtime6.jsxs)(Root$l2, { "data-level": level, ...restProps, onMouseEnter, onMouseLeave, children: [(0, import_jsx_runtime6.jsx)(FormFieldBaseHeader, { __internal_comments: comments, __internal_slot: slot, actions, fieldFocused: Boolean(focused), fieldHovered: hovered, presence, content: (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(FormFieldSetLegend, { collapsed: Boolean(collapsed), collapsible, onClick: collapsible ? handleToggle : void 0, title }), hasValidationMarkers && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(FormFieldValidationStatus, { fontSize: 1, validation: validation2 }) })] }), description && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, id: createDescriptionId(inputId, description), children: description })] }) }), (0, import_jsx_runtime6.jsx)(Content$1, { $borderLeft: level > 0, hidden: collapsed, marginTop: 1, paddingLeft: level === 0 ? 0 : 3, onFocus: typeof tabIndex === "number" && tabIndex > -1 ? handleFocus : void 0, ref: forwardedRef, tabIndex, children: !collapsed && content })] });
});
var __freeze$1T = Object.freeze;
var __defProp$1T = Object.defineProperty;
var __template$1T = (cooked, raw) => __freeze$1T(__defProp$1T(cooked, "raw", { value: __freeze$1T(raw || cooked.slice()) }));
var _a$1T;
var Root$k2 = st.div(_a$1T || (_a$1T = __template$1T(["\n  display: flex;\n  justify-content: flex-end;\n  box-sizing: border-box;\n  min-height: var(--avatar-height);\n  width: 77px;\n  margin-left: var(--small-padding);\n\n  &[data-max-avatars='1'] {\n    max-width: 23px;\n  }\n\n  &[data-position='top'] {\n    align-self: flex-start;\n  }\n\n  &[data-position='bottom'] {\n    align-self: flex-end;\n  }\n"])));
function FormFieldStatus(_ref161) {
  let { children, maxAvatars, position = "bottom" } = _ref161;
  return (0, import_jsx_runtime6.jsx)(Root$k2, { "data-max-avatars": maxAvatars, "data-position": position, children });
}
var __freeze$1S = Object.freeze;
var __defProp$1S = Object.defineProperty;
var __template$1S = (cooked, raw) => __freeze$1S(__defProp$1S(cooked, "raw", { value: __freeze$1S(raw || cooked.slice()) }));
var _a$1S;
var DragHandleButton = st(Button)(_a$1S || (_a$1S = __template$1S(["\n  cursor: ", ";\n"])), (props2) => props2.grid ? "move" : "ns-resize");
var SortableItemIdContext = import_react51.default.createContext(null);
var DragHandle = function DragHandle2(props2) {
  const id4 = (0, import_react51.useContext)(SortableItemIdContext);
  const { listeners, attributes } = useSortable({ id: id4 });
  return (0, import_jsx_runtime6.jsx)(DragHandleButton, { icon: DragHandleIcon, mode: "bleed", "data-ui": "DragHandleButton", ...attributes, ...props2, ...listeners });
};
function restrictToBoundingRect(transform2, rect, boundingRect, margins) {
  const value = { ...transform2 };
  const marginY = margins.y || 0;
  const marginX = margins.x || 0;
  if (rect.top + value.y <= boundingRect.top + marginY) {
    value.y = boundingRect.top - rect.top + marginY;
  } else if (rect.bottom + value.y >= boundingRect.top + boundingRect.height - marginY) {
    value.y = boundingRect.top + boundingRect.height - rect.bottom - marginY;
  }
  if (rect.left + value.x <= boundingRect.left - marginX) {
    value.x = boundingRect.left - rect.left + marginX;
  } else if (rect.right + value.x >= boundingRect.left + boundingRect.width + marginX) {
    value.x = boundingRect.left + boundingRect.width - rect.right + marginX;
  }
  return value;
}
var restrictToParentElementWithMargins = (margins) => (_ref162) => {
  let { containerNodeRect, draggingNodeRect, transform: transform2 } = _ref162;
  if (!draggingNodeRect || !containerNodeRect) {
    return transform2;
  }
  return restrictToBoundingRect(transform2, draggingNodeRect, containerNodeRect, margins);
};
var __freeze$1R = Object.freeze;
var __defProp$1R = Object.defineProperty;
var __template$1R = (cooked, raw) => __freeze$1R(__defProp$1R(cooked, "raw", { value: __freeze$1R(raw || cooked.slice()) }));
var _a$1R;
var _b$R;
var MOVING_ITEM_CLASS_NAME = "moving";
var ListItem$1 = st(Box)(_b$R || (_b$R = __template$1R(["\n  ", "\n"])), (props2) => props2.$moving && nt(_a$1R || (_a$1R = __template$1R(["\n      z-index: 10000;\n      /* prevents hover-effects etc on the dragged element  */\n      pointer-events: none;\n    "]))));
var AUTO_SCROLL_OPTIONS = { threshold: { x: 0, y: 0.02 } };
var SENSOR_OPTIONS = { coordinateGetter: sortableKeyboardCoordinates };
var TRANSITION = { duration: 200, easing: "ease" };
function restrictToAxis(axis) {
  return axis === "x" ? restrictToHorizontalAxis : restrictToVerticalAxis;
}
function sortingStrategy(axis) {
  return axis === "x" ? horizontalListSortingStrategy : verticalListSortingStrategy;
}
var SortableList = (0, import_react51.memo)(function SortableList2(props2) {
  const { items, axis, onItemMove, onItemMoveStart, onItemMoveEnd, children, ...rest } = props2;
  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, SENSOR_OPTIONS));
  const handleDragEnd = (0, import_react51.useCallback)((event) => {
    var _a22, _b22, _c4, _d4;
    const { active, over } = event;
    if (active.id !== (over == null ? void 0 : over.id)) {
      onItemMove == null ? void 0 : onItemMove({ fromIndex: (_b22 = (_a22 = active.data.current) == null ? void 0 : _a22.sortable) == null ? void 0 : _b22.index, toIndex: (_d4 = (_c4 = over == null ? void 0 : over.data.current) == null ? void 0 : _c4.sortable) == null ? void 0 : _d4.index });
    }
    onItemMoveEnd == null ? void 0 : onItemMoveEnd();
  }, [onItemMove, onItemMoveEnd]);
  const modifiers = (0, import_react51.useMemo)(() => [restrictToParentElementWithMargins({ y: 4 }), ...axis ? [restrictToAxis(axis)] : []], [axis]);
  return (0, import_jsx_runtime6.jsx)(DndContext, { sensors, autoScroll: AUTO_SCROLL_OPTIONS, modifiers, collisionDetection: closestCenter, onDragEnd: handleDragEnd, onDragStart: onItemMoveStart, children: (0, import_jsx_runtime6.jsx)(SortableContext, { items, strategy: axis ? sortingStrategy(axis) : void 0, children: (0, import_jsx_runtime6.jsx)(Grid, { ...rest, children }) }) });
});
var SortableListItem = (0, import_react51.forwardRef)(function SortableListItem2(props2, ref) {
  const { id: id4, children, disableTransition } = props2;
  const { setNodeRef, transform: transform2, transition, active } = useSortable({ id: id4, transition: disableTransition ? null : TRANSITION });
  const isActive = id4 === (active == null ? void 0 : active.id);
  const style = (0, import_react51.useMemo)(() => ({ transform: CSS.Translate.toString(transform2), transition, pointerEvents: active ? "none" : void 0 }), [transform2, transition, active]);
  const setRef = (0, import_react51.useCallback)((node) => {
    setNodeRef(node);
    if (typeof ref === "function") {
      ref(node);
    } else if (ref) {
      ref.current = node;
    }
  }, [ref, setNodeRef]);
  return (0, import_jsx_runtime6.jsx)(ListItem$1, { ref: setRef, style, $moving: isActive, className: isActive ? MOVING_ITEM_CLASS_NAME : "", "data-index": props2["data-index"], children });
});
function List(props2) {
  const { onItemMove, onItemMoveEnd, onItemMoveStart, sortable, ...rest } = props2;
  const handleSortEnd = (0, import_react51.useCallback)((event) => {
    onItemMove == null ? void 0 : onItemMove(event);
  }, [onItemMove]);
  return sortable ? (0, import_jsx_runtime6.jsx)(SortableList, { onItemMove: handleSortEnd, onItemMoveStart, onItemMoveEnd, ...rest }) : (0, import_jsx_runtime6.jsx)(Grid, { ...rest });
}
var Item2 = (0, import_react51.forwardRef)(function Item22(props2, ref) {
  const { sortable, ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(SortableItemIdContext.Provider, { value: props2.id, children: sortable ? (0, import_jsx_runtime6.jsx)(SortableListItem, { ref, ...rest }) : (0, import_jsx_runtime6.jsx)(ListItem$1, { ref, ...rest }) });
});
var __freeze$1Q = Object.freeze;
var __defProp$1Q = Object.defineProperty;
var __template$1Q = (cooked, raw) => __freeze$1Q(__defProp$1Q(cooked, "raw", { value: __freeze$1Q(raw || cooked.slice()) }));
var _a$1Q;
var Root$j2 = st(Card)(_a$1Q || (_a$1Q = __template$1Q(["\n  position: relative;\n  border: 1px solid transparent;\n  transition: border-color 250ms;\n\n  .", " & {\n    border-color: var(--card-shadow-umbra-color);\n    box-shadow:\n      0 0 0 0,\n      0 8px 17px 2px var(--card-shadow-umbra-color),\n      0 3px 14px 2px var(--card-shadow-penumbra-color),\n      0 5px 5px -3px var(--card-shadow-ambient-color);\n  }\n\n  &:hover {\n    border-color: var(--card-shadow-umbra-color);\n  }\n\n  &[aria-selected='true'] {\n    border-color: var(--card-focus-ring-color);\n  }\n"])), MOVING_ITEM_CLASS_NAME);
function RowLayout(props2) {
  const { validation: validation2, selected, tone, presence, focused, children, dragHandle, menu, footer } = props2;
  const elementRef = (0, import_react51.useRef)(null);
  useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    if (!hadFocus && hasFocus) {
      (_a22 = elementRef.current) == null ? void 0 : _a22.focus();
    }
  });
  return (0, import_jsx_runtime6.jsx)(Root$j2, { ref: elementRef, selected, "aria-selected": selected, radius: 2, padding: 1, tone, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 1, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [dragHandle && (0, import_jsx_runtime6.jsx)(Box, { marginRight: 1, paddingY: 1, children: (0, import_jsx_runtime6.jsx)(DragHandle, { paddingX: 1, paddingY: 3 }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children }), (presence || validation2 || menu) && (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", marginLeft: 1, children: [presence && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: presence }), validation2 && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: validation2 }), menu] })] }), footer] }) });
}
function createProtoValue(type) {
  if (isObjectSchemaType(type)) {
    return type.name === "object" ? {} : { _type: type.name };
  }
  if (isArraySchemaType(type)) {
    return [];
  }
  if (type.jsonType === "string") {
    return "";
  }
  if (type.jsonType === "number") {
    return 0;
  }
  if (type.jsonType === "boolean") {
    return false;
  }
  return void 0;
}
function createProtoArrayValue(type) {
  if (!isObjectSchemaType(type)) {
    throw new Error('Invalid item type: "'.concat(type.type, '". Default array input can only contain objects (for now)'));
  }
  return { ...createProtoValue(type), _key: randomKey(12) };
}
var MENU_POPOVER_PROPS$a = { portal: true, tone: "default", placement: "left", constrainSize: true };
var InsertMenu$1 = (0, import_react51.memo)(function InsertMenu2(props2) {
  const { types: types3, onInsert } = props2;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(InsertMenuGroup, { pos: "before", types: types3, onInsert, text: t3("inputs.array.action.add-before"), icon: InsertAboveIcon }), (0, import_jsx_runtime6.jsx)(InsertMenuGroup, { pos: "after", types: types3, onInsert, text: t3("inputs.array.action.add-after"), icon: InsertBelowIcon })] });
});
function InsertMenuGroup(props2) {
  const { types: types3, onInsert, pos, text, icon } = props2;
  if ((types3 == null ? void 0 : types3.length) === 1) {
    return (0, import_jsx_runtime6.jsx)(MenuItem, { text, icon, onClick: () => onInsert(pos, types3[0]) }, pos);
  }
  return (0, import_jsx_runtime6.jsx)(MenuGroup, { text, popover: MENU_POPOVER_PROPS$a, children: types3 == null ? void 0 : types3.map((insertableType) => (0, import_jsx_runtime6.jsx)(MenuItem, { icon: insertableType.icon, text: insertableType.title, onClick: () => onInsert(pos, insertableType) }, insertableType.name)) }, pos);
}
var noop$1 = () => void 0;
var INITIAL_LOADING_STATE$1 = { isLoading: true, result: void 0, error: void 0, retry: noop$1 };
var EMPTY_STATE$12 = { isLoading: false, result: void 0, error: void 0, retry: noop$1 };
function useReferenceInfo$1(id4, getReferenceInfo2) {
  const msgSubject = (0, import_react51.useMemo)(() => new Subject(), []);
  const msg$ = (0, import_react51.useMemo)(() => msgSubject.asObservable(), [msgSubject]);
  const retry2 = (0, import_react51.useCallback)(() => {
    msgSubject.next({ type: "retry" });
  }, [msgSubject]);
  const referenceInfo = useMemoObservable(() => concat(of(null), msg$).pipe(map(() => id4), concatMap((refId) => refId ? getReferenceInfo2(refId).pipe(map((result) => {
    return { isLoading: false, result, error: void 0, retry: retry2 };
  }), startWith(INITIAL_LOADING_STATE$1), catchError((err) => {
    console.error(err);
    return of({ isLoading: false, result: void 0, error: err, retry: retry2 });
  })) : of(EMPTY_STATE$12))), [getReferenceInfo2, id4, msg$, retry2], INITIAL_LOADING_STATE$1);
  const previousId = usePrevious(id4, id4);
  if (id4 && previousId !== id4) {
    return INITIAL_LOADING_STATE$1;
  }
  return referenceInfo;
}
function RelativeTime(_ref163) {
  let { time: time2, ...options } = _ref163;
  const timestamp = time2 instanceof Date ? time2 : new Date(time2);
  const timeAgo = useRelativeTime(timestamp, options);
  return (0, import_jsx_runtime6.jsx)("time", { dateTime: timestamp.toISOString(), title: timeAgo, children: timeAgo });
}
function ReferencePreview(props2) {
  var _a4, _b4, _c4, _d4;
  const { id: id4, layout: layout2, preview, refType, renderPreview, showTypeLabel } = props2;
  const { t: t3 } = useTranslation2();
  const theme = useRootTheme();
  const documentPresence = useDocumentPresence(id4);
  const previewId = ((_a4 = preview.draft) == null ? void 0 : _a4._id) || ((_b4 = preview.published) == null ? void 0 : _b4._id) || // note: during publish of the referenced document we might have both a missing draft and a missing published version
  // this happens because the preview system tries to optimistically re-fetch as soon as it sees a mutation, but
  // when publishing, the draft is deleted, and therefore both the draft and the published may be missing for a brief
  // moment before the published version appears. In this case, it's safe to fallback to the given id, which is always
  // the published id
  id4;
  const previewStub = (0, import_react51.useMemo)(() => ({ _id: previewId, _type: refType.name }), [previewId, refType.name]);
  const previewProps = (0, import_react51.useMemo)(() => ({ layout: layout2, schemaType: refType, value: previewStub }), [layout2, previewStub, refType]);
  const publishedAt = (_c4 = preview.published) == null ? void 0 : _c4._updatedAt;
  const draftEditedAt = (_d4 = preview.draft) == null ? void 0 : _d4._updatedAt;
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: renderPreview(previewProps) }), (0, import_jsx_runtime6.jsx)(Box, { paddingLeft: 3, children: (0, import_jsx_runtime6.jsxs)(Inline, { space: 3, children: [showTypeLabel && (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: refType.title }), documentPresence && documentPresence.length > 0 && (0, import_jsx_runtime6.jsx)(DocumentPreviewPresence, { presence: documentPresence }), (0, import_jsx_runtime6.jsxs)(Inline, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: publishedAt ? (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.preview.published-at-time", components: { RelativeTime: () => (0, import_jsx_runtime6.jsx)(RelativeTime, { time: publishedAt, useTemporalPhrase: true }) } }) : (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.reference.preview.not-published") }) }) }), children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: theme.tone === "default" ? "positive" : "default", size: 1, dimmed: !preview.published, muted: !preview.published, children: (0, import_jsx_runtime6.jsx)(PublishIcon, { "aria-label": preview.published ? t3("inputs.reference.preview.is-published-aria-label") : t3("inputs.reference.preview.is-not-published-aria-label") }) }) }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: draftEditedAt ? (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.preview.edited-at-time", components: { RelativeTime: () => (0, import_jsx_runtime6.jsx)(RelativeTime, { time: draftEditedAt, useTemporalPhrase: true }) } }) : (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.reference.preview.no-unpublished-edits") }) }) }), children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: theme.tone === "default" ? "caution" : "default", size: 1, dimmed: !preview.draft, muted: !preview.draft, children: (0, import_jsx_runtime6.jsx)(EditIcon, { "aria-label": preview.draft ? t3("inputs.reference.preview.has-unpublished-changes-aria-label") : t3("inputs.reference.preview.has-no-unpublished-changes-aria-label") }) }) }) })] })] }) })] });
}
function PreviewReferenceValue$1(props2) {
  var _a4, _b4, _c4, _d4, _e3, _f3;
  const { referenceInfo, renderPreview, type, value, showTypeLabel } = props2;
  const { t: t3 } = useTranslation2();
  if (referenceInfo.isLoading || referenceInfo.error) {
    return (0, import_jsx_runtime6.jsx)(SanityDefaultPreview, { isPlaceholder: true });
  }
  if (((_a4 = referenceInfo.result) == null ? void 0 : _a4.availability.reason) === "NOT_FOUND" && value._strengthenOnPublish) {
    const refType2 = type.to.find((toType) => {
      var _a22;
      return toType.name === ((_a22 = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _a22.type);
    });
    if (!refType2) {
      return (0, import_jsx_runtime6.jsx)(InvalidType, { documentId: value._ref, actualType: (_b4 = value._strengthenOnPublish) == null ? void 0 : _b4.type, declaredTypes: type.to.map((toType) => toType.name) });
    }
    const stub = ((_c4 = value._strengthenOnPublish) == null ? void 0 : _c4.type) ? { _id: value._ref, _type: (_d4 = value._strengthenOnPublish) == null ? void 0 : _d4.type } : value;
    return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: renderPreview({ layout: "default", schemaType: refType2, value: stub, skipVisibilityCheck: true }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Inline, { space: 4, children: showTypeLabel && (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: refType2.title }) }) })] });
  }
  const availability = referenceInfo.result.availability;
  const notFound = availability.reason === "NOT_FOUND";
  const insufficientPermissions = availability.reason === "PERMISSION_DENIED";
  if (insufficientPermissions || notFound) {
    return (0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, paddingY: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: t3("inputs.reference.error.document-unavailable-title") }) }) }) }), insufficientPermissions || notFound ? (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: notFound ? (0, import_jsx_runtime6.jsx)(UnavailableMessage$1, { title: t3("inputs.reference.error.nonexistent-document-title"), icon: HelpCircleIcon, children: (0, import_jsx_runtime6.jsx)(Translate, { i18nKey: "inputs.reference.error.nonexistent-document-description", t: t3, values: { documentId: value._ref } }) }) : (0, import_jsx_runtime6.jsx)(UnavailableMessage$1, { title: t3("inputs.reference.error.missing-read-permissions-title"), icon: AccessDeniedIcon, children: t3("inputs.reference.error.missing-read-permissions-description") }), children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "default", children: (0, import_jsx_runtime6.jsx)(HelpCircleIcon, {}) }) }) }) : null] });
  }
  const refTypeName = (_e3 = referenceInfo.result) == null ? void 0 : _e3.type;
  const refType = type.to.find((toType) => toType.name === refTypeName);
  if (!refType) {
    return (0, import_jsx_runtime6.jsx)(InvalidType, { documentId: value._ref, actualType: refTypeName || "<unknown>", declaredTypes: type.to.map((toType) => toType.name) });
  }
  return (0, import_jsx_runtime6.jsx)(ReferencePreview, { id: value._ref, layout: "default", preview: (_f3 = referenceInfo.result) == null ? void 0 : _f3.preview, refType, renderPreview, showTypeLabel });
}
function UnavailableMessage$1(props2) {
  const Icon3 = props2.icon;
  return (0, import_jsx_runtime6.jsxs)(Flex, { padding: 3, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Icon3, {}) }) }), (0, import_jsx_runtime6.jsxs)(Box, { flex: 1, marginLeft: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: props2.title }), (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: props2.children }) })] })] });
}
function InvalidType(_ref164) {
  let { declaredTypes, documentId, actualType } = _ref164;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "flex-start", children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, paddingY: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: t3("inputs.reference.error.invalid-type-title") }) }) }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(Stack, { space: 3, padding: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.error.invalid-type-description", values: { documentId, actualType }, components: { AllowedTypes: () => (0, import_jsx_runtime6.jsx)(HumanizedList, { values: declaredTypes }) } }) }) }), children: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "default", children: (0, import_jsx_runtime6.jsx)(HelpCircleIcon, {}) }) }) }) })] });
}
function HumanizedList(props2) {
  const listFormat = useIntlListFormat({ type: "disjunction" });
  const parts = listFormat.formatToParts(props2.values);
  return (0, import_jsx_runtime6.jsx)(import_react51.Fragment, { children: parts.map((segment) => segment.type === "element" ? (0, import_jsx_runtime6.jsx)("code", { children: segment.value }, segment.value) : segment.value) });
}
var __freeze$1P = Object.freeze;
var __defProp$1P = Object.defineProperty;
var __template$1P = (cooked, raw) => __freeze$1P(__defProp$1P(cooked, "raw", { value: __freeze$1P(raw || cooked.slice()) }));
var _a$1P;
var StyledCard = st(Card)(_a$1P || (_a$1P = __template$1P(["\n  /* this is a hack to avoid layout jumps while previews are loading\n     there's probably better ways of solving this */\n  min-height: 35px;\n  position: relative;\n\n  /* TextWithTone uses its own logic to set color, and we therefore need */\n  /* to override this logic in order to set the correct color in different states */\n  &[data-selected],\n  &[data-pressed],\n  &:active {\n    [data-ui='TextWithTone'] {\n      color: inherit;\n    }\n  }\n"])));
var ReferenceLinkCard = (0, import_react51.forwardRef)(function ReferenceLinkCard2(props2, ref) {
  const { as, documentId, documentType, ...cardProps } = props2;
  const linkProps = documentId && documentType && {
    // this will make @sanity/ui style it as a link
    "data-as": "a",
    // this determines the actual tag inserted into the DOM (either a React.HTML element or a component)
    forwardedAs: as,
    documentId,
    documentType
  };
  return (0, import_jsx_runtime6.jsx)(StyledCard, { ...cardProps, ...linkProps, ref });
});
var ReferenceItemRefContext = (0, import_react51.createContext)(null);
function useReferenceItemRef() {
  const ref = (0, import_react51.useContext)(ReferenceItemRefContext);
  if (!ref) {
    return { menuRef: { current: null }, containerRef: { current: null } };
  }
  return ref;
}
function ReferenceItemRefProvider(props2) {
  const { menuRef, containerRef } = props2;
  return (0, import_jsx_runtime6.jsx)(ReferenceItemRefContext.Provider, { value: { menuRef, containerRef }, children: props2.children });
}
var __freeze$1O = Object.freeze;
var __defProp$1O = Object.defineProperty;
var __template$1O = (cooked, raw) => __freeze$1O(__defProp$1O(cooked, "raw", { value: __freeze$1O(raw || cooked.slice()) }));
var _a$1O;
var _b$Q;
var _c$u;
var _d$j;
var HeaderButton = st.button(_a$1O || (_a$1O = __template$1O(["\n  display: block;\n  -webkit-font-smoothing: inherit;\n  appearance: none;\n  font: inherit;\n  background: none;\n  width: 100%;\n  text-align: left;\n  border: 0;\n  margin: 0;\n  padding: 0;\n  outline: none;\n"])));
var ToggleArrow = st(ToggleArrowRightIcon)(_b$Q || (_b$Q = __template$1O(["\n  transform: ", ";\n"])), (props2) => props2.open ? "rotate(90deg)" : "");
var Header = st(Flex)(_c$u || (_c$u = __template$1O(["\n  cursor: default;\n"])));
var IconBox$1 = st(Box)(_d$j || (_d$j = __template$1O(["\n  & > div > svg {\n    transform: rotate(0);\n    transition: transform 100ms;\n  }\n\n  &[data-open] > div > svg {\n    transform: rotate(90deg);\n  }\n"])));
function Details(props2) {
  const { children, open: openProp, icon, title = "Details", ...restProps } = props2;
  const [open, setOpen] = (0, import_react51.useState)(openProp || false);
  const handleToggle = (0, import_react51.useCallback)(() => setOpen((v) => !v), []);
  (0, import_react51.useEffect)(() => setOpen(openProp || false), [openProp]);
  return (0, import_jsx_runtime6.jsxs)(Box, { ...restProps, children: [(0, import_jsx_runtime6.jsx)(HeaderButton, { type: "button", onClick: handleToggle, children: (0, import_jsx_runtime6.jsx)(Header, { align: "center", children: (0, import_jsx_runtime6.jsxs)(Inline, { children: [(0, import_jsx_runtime6.jsx)(IconBox$1, { "data-open": open ? "" : void 0, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(ToggleArrow, { open }) }) }), icon && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: icon }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "medium", children: title }) })] }) }) }), (0, import_jsx_runtime6.jsx)(Box, { hidden: !open, marginTop: 3, children })] });
}
var STATUS_TONES = { warning: "caution", error: "critical", info: "positive" };
var STATUS_ICONS = { warning: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}), error: (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {}), info: (0, import_jsx_runtime6.jsx)(InfoOutlineIcon, {}) };
function AlertStrip(props2) {
  const { children, status = "warning", title, ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(Card, { radius: 2, tone: STATUS_TONES[status], ...rest, "data-ui": "Alert", children: (0, import_jsx_runtime6.jsx)(Flex, { padding: 1, children: children && (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Details, { icon: STATUS_ICONS[status], title, children: (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 3, marginTop: 3, children }) }) }) }) });
}
function ReferenceFinalizeAlertStrip(_ref165) {
  let { schemaType, handleRemoveStrengthenOnPublish } = _ref165;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(AlertStrip, { padding: 1, title: t3(schemaType.weak ? "inputs.reference.incomplete-reference.finalize-action-title" : "inputs.reference.incomplete-reference.strengthen-action-title"), status: "info", "data-testid": "alert-reference-published", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: schemaType.weak ? "inputs.reference.incomplete-reference.finalize-action-description" : "inputs.reference.incomplete-reference.strengthen-action-description" }) }), (0, import_jsx_runtime6.jsx)(Button, { onClick: handleRemoveStrengthenOnPublish, text: t3("inputs.reference.incomplete-reference.strengthen-button-label"), tone: "positive" })] }) });
}
function ReferenceStrengthMismatchAlertStrip(_ref166) {
  let { actualStrength, handleFixStrengthMismatch } = _ref166;
  const shouldBe = actualStrength === "weak" ? "strong" : "weak";
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(AlertStrip, { padding: 1, title: t3("inputs.reference.strength-mismatch.title"), status: "warning", "data-testid": "alert-reference-strength-mismatch", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: actualStrength === "weak" ? "inputs.reference.strength-mismatch.is-weak-description" : "inputs.reference.strength-mismatch.is-strong-description" }) }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3(shouldBe === "weak" ? "inputs.reference.strength-mismatch.is-strong-consquences" : "inputs.reference.strength-mismatch.is-weak-consquences") }), (0, import_jsx_runtime6.jsx)(Button, { onClick: handleFixStrengthMismatch, text: t3(shouldBe === "weak" ? "inputs.reference.strength-mismatch.weaken-button-label" : "inputs.reference.strength-mismatch.strengthen-button-label"), tone: "caution" })] }) });
}
function ReferenceMetadataLoadErrorAlertStrip(_ref167) {
  let { errorMessage, onHandleRetry } = _ref167;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(AlertStrip, { padding: 1, title: t3("inputs.reference.metadata-error.title"), status: "warning", "data-testid": "alert-reference-info-failed", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: errorMessage }), (0, import_jsx_runtime6.jsx)(Button, { onClick: onHandleRetry, text: t3("inputs.reference.metadata-error.retry-button-label"), tone: "primary" })] }) });
}
function getTone$3(_ref168) {
  let { readOnly, hasErrors, hasWarnings } = _ref168;
  if (readOnly) {
    return "transparent";
  }
  if (hasErrors) {
    return "critical";
  }
  return hasWarnings ? "caution" : "default";
}
var MENU_POPOVER_PROPS$9 = { portal: true, tone: "default" };
var INITIAL_VALUE_CARD_STYLE$2 = { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", opacity: 0.6 };
function ReferenceItem(props2) {
  var _a4, _b4, _c4, _d4, _e3, _f3, _g3;
  const { schemaType, parentSchemaType, path: path2, readOnly, onRemove, value, open, onInsert, presence, validation: validation2, inputId, changed, focused, children, inputProps: { onChange, focusPath, onPathFocus, renderPreview, elementProps } } = props2;
  const sortable = !readOnly && ((_a4 = parentSchemaType.options) == null ? void 0 : _a4.sortable) !== false;
  const insertableTypes = parentSchemaType.of;
  const elementRef = (0, import_react51.useRef)(null);
  const menuRef = (0, import_react51.useRef)(null);
  const containerRef = (0, import_react51.useRef)(null);
  const { EditReferenceLink, getReferenceInfo: getReferenceInfo2, selectedState, isCurrentDocumentLiveEdit } = useReferenceInput({ path: path2, schemaType, value });
  useScrollIntoViewOnFocusWithin(elementRef, open);
  useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    if (!hadFocus && hasFocus && elementRef.current) {
      (_a22 = elementRef.current) == null ? void 0 : _a22.focus();
    }
  });
  const hasErrors = props2.validation.some((v) => v.level === "error");
  const hasWarnings = props2.validation.some((v) => v.level === "warning");
  const resolvingInitialValue = value._resolvingInitialValue;
  const handleDuplicate = (0, import_react51.useCallback)(() => {
    onInsert({ items: [{ ...value, _key: randomKey3() }], position: "after" });
  }, [onInsert, value]);
  const handleInsert = (0, import_react51.useCallback)((pos, insertType) => {
    onInsert({ items: [{ ...createProtoArrayValue(insertType), _key: randomKey3() }], position: pos });
  }, [onInsert]);
  const loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2);
  const hasRef = value._ref;
  const refTypeName = ((_b4 = loadableReferenceInfo.result) == null ? void 0 : _b4.type) || ((_c4 = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _c4.type);
  const publishedReferenceExists = hasRef && ((_f3 = (_e3 = (_d4 = loadableReferenceInfo.result) == null ? void 0 : _d4.preview) == null ? void 0 : _e3.published) == null ? void 0 : _f3._id);
  const handleRemoveStrengthenOnPublish = (0, import_react51.useCallback)(() => {
    onChange([schemaType.weak === true ? set$2(true, ["_weak"]) : unset2(["_weak"]), unset2(["_strengthenOnPublish"])]);
  }, [onChange, schemaType.weak]);
  const refType = refTypeName ? schemaType.to.find((toType) => toType.name === refTypeName) : void 0;
  const pressed = selectedState === "pressed";
  const selected = selectedState === "selected";
  const tone = getTone$3({ readOnly, hasErrors, hasWarnings });
  const isEditing = !hasRef || focusPath[0] === "_ref";
  const { t: t3 } = useTranslation2();
  const OpenLink = (0, import_react51.useMemo)(() => (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (0, import_react51.forwardRef)(function OpenLink2(restProps, _ref) {
      return (0, import_jsx_runtime6.jsx)(IntentLink, { ...restProps, intent: "edit", params: { id: value == null ? void 0 : value._ref, type: refType == null ? void 0 : refType.name }, target: "_blank", rel: "noopener noreferrer", ref: _ref });
    })
  ), [refType == null ? void 0 : refType.name, value == null ? void 0 : value._ref]);
  const handleReplace = (0, import_react51.useCallback)(() => {
    if (hasRef && isEditing) {
      onPathFocus([]);
    } else {
      onPathFocus(["_ref"]);
    }
  }, [hasRef, isEditing, onPathFocus]);
  const menu = (0, import_react51.useMemo)(() => readOnly ? null : (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { paddingY: 3, paddingX: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(inputId, "-menuButton"), menu: (0, import_jsx_runtime6.jsxs)(Menu, { ref: menuRef, children: [!readOnly && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.reference.action.remove"), tone: "critical", icon: TrashIcon, onClick: onRemove }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3(hasRef && isEditing ? "inputs.reference.action.replace-cancel" : "inputs.reference.action.replace"), icon: hasRef && isEditing ? CloseIcon : SyncIcon, onClick: handleReplace }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.reference.action.duplicate"), icon: CopyIcon, onClick: handleDuplicate }), (0, import_jsx_runtime6.jsx)(InsertMenu$1, { onInsert: handleInsert, types: insertableTypes })] }), !readOnly && !isEditing && hasRef && (0, import_jsx_runtime6.jsx)(MenuDivider, {}), !isEditing && hasRef && (0, import_jsx_runtime6.jsx)(MenuItem, { as: OpenLink, "data-as": "a", text: t3("inputs.reference.action.open-in-new-tab"), icon: LaunchIcon })] }), popover: MENU_POPOVER_PROPS$9 }) }), [handleDuplicate, handleInsert, handleReplace, hasRef, inputId, insertableTypes, isEditing, onRemove, OpenLink, readOnly, t3]);
  const handleFixStrengthMismatch = (0, import_react51.useCallback)(() => {
    onChange(schemaType.weak === true ? set$2(true, ["_weak"]) : unset2(["_weak"]));
  }, [onChange, schemaType]);
  const actualStrength = (value == null ? void 0 : value._weak) ? "weak" : "strong";
  const weakShouldBe = schemaType.weak === true ? "weak" : "strong";
  const weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && (value == null ? void 0 : value._strengthenOnPublish);
  const showWeakRefMismatch = !loadableReferenceInfo.isLoading && ((_g3 = loadableReferenceInfo.result) == null ? void 0 : _g3.availability.available) && hasRef && actualStrength !== weakShouldBe && !weakWarningOverride;
  const issues = (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [isCurrentDocumentLiveEdit && publishedReferenceExists && value._strengthenOnPublish && (0, import_jsx_runtime6.jsx)(ReferenceFinalizeAlertStrip, { schemaType, handleRemoveStrengthenOnPublish }), showWeakRefMismatch && (0, import_jsx_runtime6.jsx)(ReferenceStrengthMismatchAlertStrip, { actualStrength, handleFixStrengthMismatch }), loadableReferenceInfo.error && (0, import_jsx_runtime6.jsx)(ReferenceMetadataLoadErrorAlertStrip, { errorMessage: loadableReferenceInfo.error.message, onHandleRetry: loadableReferenceInfo.retry })] });
  const item = (0, import_jsx_runtime6.jsx)(ReferenceItemRefProvider, { menuRef, containerRef, children: (0, import_jsx_runtime6.jsx)(RowLayout, { dragHandle: sortable, presence: !isEditing && presence.length > 0 && (0, import_jsx_runtime6.jsx)(FieldPresence, { presence, maxAvatars: 1 }), validation: !isEditing && validation2.length > 0 && (0, import_jsx_runtime6.jsx)(FormFieldValidationStatus, { validation: validation2 }), menu, footer: isEditing ? void 0 : issues, tone: isEditing ? void 0 : tone, focused, children: isEditing ? (0, import_jsx_runtime6.jsx)(Box, { padding: 1, ref: containerRef, children: (0, import_jsx_runtime6.jsx)(FormFieldSet, { title: schemaType.title, description: schemaType.description, __unstable_presence: presence, validation: validation2, inputId, children }) }) : (0, import_jsx_runtime6.jsxs)(ReferenceLinkCard, { as: EditReferenceLink, tone: "inherit", radius: 2, documentId: value == null ? void 0 : value._ref, documentType: refType == null ? void 0 : refType.name, disabled: resolvingInitialValue, paddingX: 2, paddingY: 1, __unstable_focusRing: true, selected, pressed, "data-selected": selected ? true : void 0, "data-pressed": pressed ? true : void 0, ...elementProps, children: [(0, import_jsx_runtime6.jsx)(PreviewReferenceValue$1, { value, referenceInfo: loadableReferenceInfo, renderPreview, type: schemaType }), resolvingInitialValue && (0, import_jsx_runtime6.jsx)(Card, { style: INITIAL_VALUE_CARD_STYLE$2, tone: "transparent", radius: 2, as: Flex, justify: "center", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "center", padding: 3, children: [(0, import_jsx_runtime6.jsx)(Box, { marginX: 3, children: (0, import_jsx_runtime6.jsx)(Spinner, { muted: true }) }), (0, import_jsx_runtime6.jsx)(Text3, { children: t3("inputs.reference.resolving-initial-value") })] }) })] }) }) });
  return (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: Boolean(focused), children: (0, import_jsx_runtime6.jsx)(Box, { paddingX: 1, children: item }) });
}
function isObjectInputProps$1(inputProps) {
  return isObjectSchemaType(inputProps.schemaType);
}
function isArrayInputProps(inputProps) {
  return isArraySchemaType(inputProps.schemaType);
}
function hasKey$1(item) {
  return item._key !== void 0;
}
function ensureKey(item) {
  return hasKey$1(item) ? item : { ...item, _key: randomKey3(12) };
}
var DEFAULT_CONCURRENCY = 4;
function remove(array3, item) {
  const index = array3.indexOf(item);
  if (index > -1) {
    array3.splice(index, 1);
  }
  return array3;
}
function withMaxConcurrency(func) {
  let concurrency = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CONCURRENCY;
  const throttler = createThrottler(concurrency);
  return function() {
    return from(throttler(func(...arguments)));
  };
}
function createThrottler() {
  let concurrency = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_CONCURRENCY;
  const currentSubscriptions = [];
  const pendingObservables = [];
  const ready$ = new Subject();
  return request;
  function request(observable2) {
    return new Observable((observer) => {
      if (currentSubscriptions.length >= concurrency) {
        return scheduleAndWait(observable2).pipe(mergeMap(request)).subscribe(observer);
      }
      const subscription = observable2.subscribe(observer);
      currentSubscriptions.push(subscription);
      return () => {
        remove(currentSubscriptions, subscription);
        remove(pendingObservables, observable2);
        subscription.unsubscribe();
        check();
      };
    });
  }
  function scheduleAndWait(observable2) {
    pendingObservables.push(observable2);
    return ready$.asObservable().pipe(first((obs) => obs === observable2));
  }
  function check() {
    while (pendingObservables.length > 0 && currentSubscriptions.length < concurrency) {
      ready$.next(pendingObservables.shift());
    }
  }
}
var MAX_CONCURRENT_UPLOADS = 4;
function uploadSanityAsset(client, assetType, file2) {
  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const extract = options.metadata;
  const preserveFilename = options.storeOriginalFilename;
  const { label, title, description, creditLine, source } = options;
  return hashFile(file2).pipe(catchError(() => (
    // ignore if hashing fails for some reason
    of(null)
  )), mergeMap((hash3) => (
    // note: the sanity api will still dedupe unique files, but this saves us from uploading the asset file entirely
    hash3 ? fetchExisting(client, "sanity.".concat(assetType, "Asset"), hash3) : of(null)
  )), mergeMap((existing) => {
    if (existing) {
      return of({
        // complete with the existing asset document
        type: "complete",
        id: existing._id,
        asset: existing
      });
    }
    return client.observable.assets.upload(assetType, file2, { tag: "asset.upload", extract, preserveFilename, label, title, description, creditLine, source }).pipe(map((event) => event.type === "response" ? {
      // rewrite to a 'complete' event
      type: "complete",
      id: event.body.document._id,
      asset: event.body.document
    } : event));
  }));
}
var uploadAsset = withMaxConcurrency(uploadSanityAsset, MAX_CONCURRENT_UPLOADS);
var uploadImageAsset = (client, file2, options) => uploadAsset(client, "image", file2, options);
var uploadFileAsset = (client, file2, options) => uploadAsset(client, "file", file2, options);
function observeAssetDoc(documentPreviewStore, id4) {
  return documentPreviewStore.observePaths({ _type: "reference", _ref: id4 }, ["originalFilename", "url", "metadata", "label", "title", "description", "creditLine", "source", "size"]);
}
function observeImageAsset(documentPreviewStore, id4) {
  return observeAssetDoc(documentPreviewStore, id4);
}
function observeFileAsset(documentPreviewStore, id4) {
  return observeAssetDoc(documentPreviewStore, id4);
}
function fetchExisting(client, type, hash3) {
  return client.observable.fetch("*[_type == $documentType && sha1hash == $hash][0]", { documentType: type, hash: hash3 }, { tag: "asset.find-duplicate" });
}
function readFile(file2) {
  return new Observable((subscriber) => {
    const reader = new FileReader();
    reader.onload = () => {
      subscriber.next(reader.result);
      subscriber.complete();
    };
    reader.onerror = (err) => {
      subscriber.error(err);
    };
    reader.readAsArrayBuffer(file2);
    return () => {
      reader.abort();
    };
  });
}
function hashFile(file2) {
  if (!window.crypto || !window.crypto.subtle || !window.FileReader) {
    return of(null);
  }
  return readFile(file2).pipe(mergeMap((arrayBuffer) => crypto.subtle.digest("SHA-1", arrayBuffer)), map(hexFromBuffer));
}
function hexFromBuffer(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x) => "00".concat(x.toString(16)).slice(-2)).join("");
}
function readFileAsArrayBuffer(file2, length2) {
  return new Observable((observer) => {
    const reader = new window.FileReader();
    reader.onerror = (err) => observer.error(err);
    reader.onload = () => {
      observer.next(reader.result);
      observer.complete();
    };
    reader.readAsArrayBuffer(length2 === void 0 ? file2 : file2.slice(0, length2));
    return () => reader.abort();
  });
}
var SKIP_EXIF_ERROR_RE = /(invalid image format)|(No exif data)/i;
var EXIF_BUFFER_LENGTH = 128e3;
function readExif(file2) {
  return from(readFileAsArrayBuffer(file2, EXIF_BUFFER_LENGTH)).pipe(map((buf) => (0, import_exif_component.default)(buf)), catchError((error2) => {
    if (!SKIP_EXIF_ERROR_RE.test(error2.message)) {
      console.warn("Exif read failed, continuing anyway: ".concat(error2.message));
    }
    return of({});
  }));
}
function rotated(n) {
  return [5, 6, 7, 8].indexOf(n) > -1;
}
function rotate$12(ctx, options) {
  const x = options.x;
  const y = options.y;
  const radians = (options.degrees || 0) * (Math.PI / 180);
  ctx == null ? void 0 : ctx.translate(x, y);
  ctx == null ? void 0 : ctx.rotate(radians);
  ctx == null ? void 0 : ctx.translate(-x, -y);
}
function flip2(canvas, x, y) {
  const ctx = canvas.getContext("2d");
  ctx == null ? void 0 : ctx.translate(x ? canvas.width : 0, y ? canvas.height : 0);
  ctx == null ? void 0 : ctx.scale(x ? -1 : 1, y ? -1 : 1);
}
var ORIENTATION_OPS = [{ op: "none", degrees: 0 }, { op: "flip-x", degrees: 0 }, { op: "none", degrees: 180 }, { op: "flip-y", degrees: 0 }, { op: "flip-x", degrees: 90 }, { op: "none", degrees: 90 }, { op: "flip-x", degrees: -90 }, { op: "none", degrees: -90 }];
var ORIENTATIONS = ["top-left", "top-right", "bottom-right", "bottom-left", "left-top", "right-top", "right-bottom", "left-bottom"];
var DEFAULT_ORIENTATION = "top-left";
var THUMB_SIZE = 120;
function _orient(img, orientationNumber) {
  const orientation = ORIENTATION_OPS[orientationNumber - 1];
  const ratio = img.height / img.width;
  img.width = THUMB_SIZE / ratio;
  img.height = img.width * ratio;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (rotated(orientationNumber)) {
    canvas.height = img.width;
    canvas.width = img.height;
  } else {
    canvas.width = img.width;
    canvas.height = img.height;
  }
  if (orientation.op === "flip-x") {
    flip2(canvas, true, false);
  }
  if (orientation.op === "flip-y") {
    flip2(canvas, false, true);
  }
  if (orientation.degrees) {
    rotate$12(ctx, { degrees: orientation.degrees, x: canvas.width / 2, y: canvas.height / 2 });
    if (rotated(orientationNumber)) {
      const d = canvas.width - canvas.height;
      ctx == null ? void 0 : ctx.translate(d / 2, -d / 2);
    }
  }
  ctx == null ? void 0 : ctx.drawImage(img, 0, 0, img.width, img.height);
  return canvas;
}
function orient(image2, orientationId) {
  return new Observable((observer) => {
    const orientation = ORIENTATIONS.indexOf(orientationId) + 1;
    const canvas = _orient(image2, orientation);
    observer.next(canvas.toDataURL("image/jpeg", 0.1));
    observer.complete();
  });
}
function loadImage$1(url) {
  return new Observable((observer) => {
    const image2 = new window.Image();
    image2.onerror = () => {
      observer.error(new Error('Could not load image from url "'.concat(url, '". Image may be of an unsupported format')));
    };
    image2.onload = () => {
      observer.next(image2);
      observer.complete();
    };
    image2.src = url;
    return () => {
    };
  });
}
function rotateImage(file2, orientation) {
  return loadImage$1(window.URL.createObjectURL(file2)).pipe(mergeMap((image2) => orient(image2, orientation)));
}
var UPLOAD_STATUS_KEY = "_upload";
var UNSET_UPLOAD_PATCH = unset2([UPLOAD_STATUS_KEY]);
function createUploadEvent() {
  let patches = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return { type: "uploadProgress", patches };
}
var CLEANUP_EVENT = createUploadEvent([UNSET_UPLOAD_PATCH]);
function createInitialUploadEvent(file2) {
  const now3 = (/* @__PURE__ */ new Date()).toISOString();
  const value = { progress: 2, createdAt: now3, updatedAt: now3, file: { name: file2.name, type: file2.type } };
  return createUploadEvent([set$2(value, [UPLOAD_STATUS_KEY])]);
}
function uploadImage(client, file2, options) {
  const upload$ = uploadImageAsset(client, file2, options).pipe(filter((event) => event.stage !== "download"), map((event) => ({ ...event, progress: 2 + event.percent / 100 * 98 })), map((event) => {
    if (event.type === "complete") {
      return createUploadEvent([set$2({ _type: "reference", _ref: event.asset._id }, ["asset"]), set$2(100, [UPLOAD_STATUS_KEY, "progress"]), set$2((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updatedAt"])]);
    }
    return createUploadEvent([set$2(event.percent, [UPLOAD_STATUS_KEY, "progress"]), set$2((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updatedAt"])]);
  }));
  const setPreviewUrl$ = readExif(file2).pipe(mergeMap((exifData) => rotateImage(file2, exifData.orientation || DEFAULT_ORIENTATION)), catchError((error2) => {
    console.warn('Image preprocessing failed for "%s" with the error: %s', file2.name, error2.message);
    return of(null);
  }), filter(Boolean), map((imageUrl) => createUploadEvent([set$2(imageUrl, [UPLOAD_STATUS_KEY, "previewImage"])])));
  return concat(of(createInitialUploadEvent(file2)), merge(upload$, setPreviewUrl$), of(CLEANUP_EVENT));
}
function uploadFile(client, file2, options) {
  const upload$ = uploadFileAsset(client, file2, options).pipe(map((event) => {
    if (event.type === "complete") {
      return createUploadEvent([set$2({ _type: "reference", _ref: event.asset._id }, ["asset"]), set$2(100, [UPLOAD_STATUS_KEY, "progress"]), set$2((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updated"])]);
    }
    return createUploadEvent([set$2(event.percent, [UPLOAD_STATUS_KEY, "progress"]), set$2((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updated"])]);
  }));
  return concat(of(createInitialUploadEvent(file2)), upload$, of(CLEANUP_EVENT));
}
var UPLOAD_IMAGE = { type: "image", accepts: "image/*", upload: (client, file2, type, options) => uploadImage(client, file2, options) };
var UPLOAD_FILE = { type: "file", accepts: "", upload: (client, file2, type, options) => uploadFile(client, file2, options) };
var UPLOAD_TEXT = {
  type: "string",
  accepts: "text/*",
  upload: (client, file2, type, options) => uploadFile(client, file2, options).pipe(map((content) => ({ type: "uploadProgress", patches: [set$2(content)] })))
  // Todo: promote this to a "first-class" form-builder abstraction
  // and make it possible to register custom uploaders
};
var uploaders = [UPLOAD_IMAGE, UPLOAD_TEXT, UPLOAD_FILE].map((uploader, i) => ({ ...uploader, priority: i }));
function accepts(file2, acceptedFiles) {
  if (!file2 || !acceptedFiles) {
    return true;
  }
  const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
  const fileName = file2.name || "";
  const mimeType = (file2.type || "").toLowerCase();
  const baseMimeType = mimeType.replace(/\/.*$/, "");
  return acceptedFilesArray.some((type) => {
    const validType = type.trim().toLowerCase();
    if (validType.charAt(0) === ".") {
      return fileName.toLowerCase().endsWith(validType);
    }
    if (validType.endsWith("/*")) {
      return baseMimeType === validType.replace(/\/.*$/, "");
    }
    return mimeType === validType;
  });
}
function resolveUploader(type, file2) {
  return uploaders.find((uploader) => {
    var _a4;
    return is$1(uploader.type, type) && accepts(file2, uploader.accepts) && accepts(file2, ((_a4 = type.options) == null ? void 0 : _a4.accept) || "");
  }) || null;
}
var IGNORE_KEYS = ["_key", "_type", "_weak"];
function isEmptyItem(value) {
  return Object.keys(value).every((key2) => IGNORE_KEYS.includes(key2));
}
var getMemberTypeOfItem$2 = (schemaType, item) => {
  const itemTypeName = resolveTypeName(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
};
function assign(values2, path2) {
  return Object.entries(values2).map((_ref169) => {
    let [key2, value] = _ref169;
    return set$2(value, [...path2, key2]);
  });
}
function resolveInitialArrayValues(items, schemaType, resolver) {
  return from(items).pipe(mergeMap((item) => {
    const itemPathSegment = { _key: item._key };
    return of(getMemberTypeOfItem$2(schemaType, item)).pipe(mergeMap((memberType) => memberType ? of(memberType) : EMPTY), mergeMap((memberType) => {
      if (!isEmptyItem(item) || !resolver) {
        return EMPTY;
      }
      return concat(of({ type: "patch", patches: [set$2(true, [itemPathSegment, "_resolvingInitialValue"])] }), defer(() => resolver(memberType, item)).pipe(filter(isNonNullable$3), map((initial) => ({ type: "patch", patches: assign(initial, [itemPathSegment]) })), catchError((error2) => of({ type: "error", error: error2, item, schemaType: memberType }))), of({ type: "patch", patches: [unset2([itemPathSegment, "_resolvingInitialValue"])] }));
    }));
  }));
}
var BEFORE2 = "before";
var AFTER2 = "after";
function arrayInsert(array3, position, index) {
  if (position !== BEFORE2 && position !== AFTER2) {
    throw new Error('Invalid position "'.concat(position, '", must be either ').concat(BEFORE2, " or ").concat(AFTER2));
  }
  for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key4 = 3; _key4 < _len3; _key4++) {
    args[_key4 - 3] = arguments[_key4];
  }
  const items = flatten5(...args);
  if (array3.length === 0) {
    return items;
  }
  const len = array3.length;
  const idx = Math.abs((len + index) % len) % len;
  const normalizedIdx = position === "after" ? idx + 1 : idx;
  const copy2 = array3.slice();
  copy2.splice(normalizedIdx, 0, ...flatten5(items));
  return copy2;
}
function flatten5() {
  for (var _len4 = arguments.length, values2 = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
    values2[_key5] = arguments[_key5];
  }
  return values2.reduce((prev, item) => prev.concat(item), []);
}
var hasOwn3 = (obj, property) => Object.prototype.hasOwnProperty.call(obj, property);
function move$1(arr, from2, to) {
  const nextValue = arr.slice();
  const val = nextValue[from2];
  nextValue.splice(from2, 1);
  nextValue.splice(to, 0, val);
  return nextValue;
}
function findTargetIndex2(array3, pathSegment) {
  if (typeof pathSegment === "number") {
    return pathSegment;
  }
  const index = (0, import_findIndex2.default)(array3, pathSegment);
  return index === -1 ? false : index;
}
function _arrayApply(value, patch2) {
  const nextValue = value.slice();
  if (patch2.path.length === 0) {
    if (patch2.type === "setIfMissing") {
      if (!Array.isArray(patch2.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return value === void 0 ? patch2.value : value;
    } else if (patch2.type === "set") {
      if (!Array.isArray(patch2.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return patch2.value;
    } else if (patch2.type === "unset") {
      return void 0;
    } else if (patch2.type === "move") {
      if (!patch2.value || !hasOwn3(patch2.value, "from") || !hasOwn3(patch2.value, "to")) {
        throw new Error(`Invalid value of 'move' patch. Expected a value with "from" and "to" indexes, instead got: `.concat(JSON.stringify(patch2.value)));
      }
      return move$1(nextValue, patch2.value.from, patch2.value.to);
    }
    throw new Error("Invalid array operation: ".concat(patch2.type));
  }
  const [head, ...tail] = patch2.path;
  const index = findTargetIndex2(value, head);
  if (index === false) {
    return nextValue;
  }
  if (tail.length === 0) {
    if (patch2.type === "insert") {
      const { position, items } = patch2;
      return arrayInsert(value, position, index, items);
    } else if (patch2.type === "unset") {
      if (typeof index !== "number") {
        throw new Error('Expected array index to be a number, instead got "'.concat(index, '"'));
      }
      nextValue.splice(index, 1);
      return nextValue;
    }
  }
  nextValue[index] = applyPatch4(nextValue[index], { ...patch2, path: tail });
  return nextValue;
}
function _objectApply(value, patch2) {
  const nextValue = (0, import_clone2.default)(value);
  if (patch2.path.length === 0) {
    if (patch2.type === "set") {
      if (!(0, import_isObject2.default)(patch2.value)) {
        throw new Error("Cannot set value of an object to a non-object");
      }
      return patch2.value;
    } else if (patch2.type === "unset") {
      return void 0;
    } else if (patch2.type === "setIfMissing") {
      return value === void 0 ? patch2.value : value;
    }
    throw new Error("Invalid object operation: ".concat(patch2.type));
  }
  const [head, ...tail] = patch2.path;
  if (typeof head !== "string") {
    throw new Error("Expected field name to be a string, instad got: ".concat(head));
  }
  if (tail.length === 0 && patch2.type === "unset") {
    return (0, import_omit4.default)(nextValue, head);
  }
  nextValue[head] = applyPatch4(nextValue[head], { ...patch2, path: tail });
  return nextValue;
}
var OPERATIONS$12 = { replace(currentValue, nextValue) {
  return nextValue;
}, set(currentValue, nextValue) {
  return nextValue;
}, setIfMissing(currentValue, nextValue) {
  return currentValue === void 0 ? nextValue : currentValue;
}, unset(currentValue, nextValue) {
  return void 0;
}, inc(currentValue, nextValue) {
  return currentValue + nextValue;
}, dec(currentValue, nextValue) {
  return currentValue - nextValue;
} };
var SUPPORTED_PATCH_TYPES$12 = Object.keys(OPERATIONS$12);
function _primitiveApply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES$12.includes(patch2.type)) {
    throw new Error('Received patch of unsupported type "'.concat(patch2.type, '" for primitives. This is most likely a bug.'));
  }
  if (patch2.path.length > 0) {
    throw new Error('Cannot apply deep operations on primitive values. Received patch with type "'.concat(patch2.type, '" and path "').concat(patch2.path.map((path2) => JSON.stringify(path2)).join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
  }
  return OPERATIONS$12[patch2.type](value, patch2.value);
}
var OPERATIONS2 = { replace(currentValue, nextValue) {
  return nextValue;
}, set(currentValue, nextValue) {
  return nextValue;
}, setIfMissing(currentValue, nextValue) {
  return currentValue === void 0 ? nextValue : currentValue;
}, unset(currentValue, nextValue) {
  return void 0;
}, diffMatchPatch(currentValue, dmpPatch) {
  const [result] = apply2(parse4(dmpPatch), currentValue, { allowExceedingIndices: true });
  return result;
} };
var SUPPORTED_PATCH_TYPES2 = Object.keys(OPERATIONS2);
function _stringApply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES2.includes(patch2.type)) {
    throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch2.type), '" for string. This is most likely a bug.'));
  }
  if (patch2.path.length > 0) {
    throw new Error('Cannot apply deep operations on string values. Received patch with type "'.concat(patch2.type, '" and path "').concat(patch2.path.join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
  }
  return OPERATIONS2[patch2.type](value, patch2.value);
}
function applyAll2(value, patches) {
  return patches.reduce(applyPatch4, value);
}
function _applyPatch(value, patch2) {
  if (Array.isArray(value)) {
    return _arrayApply(value, patch2);
  }
  if ((0, import_isString2.default)(value)) {
    return _stringApply(value, patch2);
  }
  if ((0, import_isObject2.default)(value)) {
    return _objectApply(value, patch2);
  }
  return _primitiveApply(value, patch2);
}
function applyPatch4(value, patch2) {
  const res = _applyPatch(value, patch2);
  return res;
}
function ArrayOfObjectsField(props2) {
  const { onPathBlur, onPathFocus, onChange, onSetPathCollapsed, onSetFieldSetCollapsed, onPathOpen, onFieldGroupSelect } = useFormCallbacks();
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  const fieldActions = useDocumentFieldActions();
  const focusRef = (0, import_react51.useRef)();
  const uploadSubscriptions = (0, import_react51.useRef)({});
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a4;
    if (!hadFocus && hasFocus) {
      (_a4 = focusRef.current) == null ? void 0 : _a4.focus();
    }
  });
  const handleFocus = (0, import_react51.useCallback)((event) => {
    if (event.currentTarget === event.target && event.currentTarget === focusRef.current) {
      onPathFocus(member.field.path);
    }
  }, [member.field.path, onPathFocus]);
  const handleBlur = (0, import_react51.useCallback)((event) => {
    if (event.currentTarget === event.target && event.currentTarget === focusRef.current) {
      onPathBlur(member.field.path);
    }
  }, [member.field.path, onPathBlur]);
  const valueRef = (0, import_react51.useRef)(member.field.value);
  (0, import_react51.useEffect)(() => {
    valueRef.current = member.field.value;
  }, [member.field.value]);
  const handleChange = (0, import_react51.useCallback)((event) => {
    const patches = PatchEvent.from(event).patches;
    const isRemovingLastItem = patches.some((patch2) => patch2.type === "unset" && patch2.path.length === 1);
    if (isRemovingLastItem) {
      valueRef.current = applyAll2(valueRef.current || [], patches);
      if (Array.isArray(valueRef.current) && !valueRef.current.length) {
        onChange(PatchEvent.from(unset2([member.name])));
        return;
      }
    }
    onChange(PatchEvent.from(event).prepend(setIfMissing2([])).prefixAll(member.name));
  }, [onChange, member.name, valueRef]);
  const resolveInitialValue2 = useResolveInitialValueForType();
  const toast = useToast();
  const handleCollapse = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.field.path, true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpand = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.field.path, false);
  }, [onSetPathCollapsed, member.field.path]);
  const handleCollapseItem = (0, import_react51.useCallback)((itemKey) => {
    onSetPathCollapsed(member.field.path.concat({ _key: itemKey }), true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpandItem = (0, import_react51.useCallback)((itemKey) => {
    onSetPathCollapsed(member.field.path.concat({ _key: itemKey }), false);
  }, [onSetPathCollapsed, member.field.path]);
  const handleOpenItem = (0, import_react51.useCallback)((path2) => {
    onPathOpen(path2);
    onSetPathCollapsed(path2, false);
  }, [onPathOpen, onSetPathCollapsed]);
  const handleCloseItem = (0, import_react51.useCallback)(() => {
    onPathOpen(member.field.path);
    onSetPathCollapsed(member.field.path, true);
  }, [onPathOpen, member.field.path, onSetPathCollapsed]);
  const handleInsert = (0, import_react51.useCallback)((event) => {
    if (event.items.length === 0) {
      throw new Error("Insert event should include at least one item");
    }
    const itemsWithKeys = event.items.map((item) => ensureKey(item));
    handleChange(PatchEvent.from([insert2(itemsWithKeys, event.position, [event.referenceItem])]));
    const focusItemKey = itemsWithKeys[0]._key;
    const itemPath = [...member.field.path, { _key: focusItemKey }];
    onPathFocus(itemPath);
    const shouldOpen = event.open !== false;
    if (event.skipInitialValue) {
      if (shouldOpen) {
        handleOpenItem(itemPath);
      }
    } else {
      resolveInitialArrayValues(itemsWithKeys, member.field.schemaType, resolveInitialValue2).pipe(tap((result) => {
        if (result.type === "patch") {
          handleChange(result.patches);
        } else {
          toast.push({ title: "Could not resolve initial value", description: "Unable to resolve initial value for type: ".concat(result.schemaType.title, ": ").concat(result.error.message, "."), status: "error" });
        }
      })).subscribe({ complete: () => {
        if (shouldOpen) {
          handleOpenItem(itemPath);
        }
      } });
    }
  }, [handleChange, handleOpenItem, member.field.path, member.field.schemaType, onPathFocus, resolveInitialValue2, toast]);
  const handleMoveItem = (0, import_react51.useCallback)((event) => {
    const value = member.field.value;
    const item = value == null ? void 0 : value[event.fromIndex];
    const refItem = value == null ? void 0 : value[event.toIndex];
    if (event.fromIndex === event.toIndex) {
      return;
    }
    if (!(item == null ? void 0 : item._key) || !(refItem == null ? void 0 : refItem._key)) {
      console.error("Neither the item you are moving nor the item you are moving to have a key. Cannot continue.");
      return;
    }
    handleChange([unset2([{ _key: item._key }]), insert2([item], event.fromIndex > event.toIndex ? "before" : "after", [{ _key: refItem._key }])]);
  }, [handleChange, member.field.value]);
  const handlePrependItem = (0, import_react51.useCallback)((item) => {
    handleChange([setIfMissing2([]), insert2([ensureKey(item)], "before", [0])]);
  }, [handleChange]);
  const handleAppendItem = (0, import_react51.useCallback)((item) => {
    handleChange([setIfMissing2([]), insert2([ensureKey(item)], "after", [-1])]);
  }, [handleChange]);
  const handleRemoveItem = (0, import_react51.useCallback)((itemKey) => {
    if (uploadSubscriptions.current[itemKey]) {
      uploadSubscriptions.current[itemKey].unsubscribe();
      delete uploadSubscriptions.current[itemKey];
    }
    handleChange([unset2([{ _key: itemKey }])]);
  }, [handleChange]);
  const handleFocusChildPath = (0, import_react51.useCallback)((path2) => {
    onPathFocus(member.field.path.concat(path2));
  }, [member.field.path, onPathFocus]);
  const elementProps = (0, import_react51.useMemo)(() => ({ onBlur: handleBlur, onFocus: handleFocus, id: member.field.id, ref: focusRef, "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description) }), [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]);
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const formBuilder = useFormBuilder();
  const supportsImageUploads = formBuilder.__internal.image.directUploads;
  const supportsFileUploads = formBuilder.__internal.file.directUploads;
  const resolveUploader$1 = (0, import_react51.useCallback)((type, file2) => {
    if (is$1("image", type) && !supportsImageUploads) {
      return null;
    }
    if (is$1("file", type) && !supportsFileUploads) {
      return null;
    }
    return resolveUploader(type, file2);
  }, [supportsFileUploads, supportsImageUploads]);
  const handleUpload = (0, import_react51.useCallback)((_ref170) => {
    let { file: file2, schemaType, uploader } = _ref170;
    const item = createProtoArrayValue(schemaType);
    const key2 = item._key;
    handleInsert({ items: [item], position: "after", referenceItem: -1, open: false });
    const events$ = uploader.upload(client, file2, schemaType).pipe(map((uploadProgressEvent) => PatchEvent.from(uploadProgressEvent.patches || []).prefixAll({ _key: key2 })), tap((event) => handleChange(event.patches)));
    uploadSubscriptions.current = { ...uploadSubscriptions.current, [key2]: events$.subscribe() };
  }, [client, handleChange, handleInsert]);
  const inputProps = (0, import_react51.useMemo)(() => {
    return { level: member.field.level, members: member.field.members, value: member.field.value, readOnly: member.field.readOnly, schemaType: member.field.schemaType, changed: member.field.changed, id: member.field.id, onItemExpand: handleExpandItem, onItemCollapse: handleCollapseItem, onItemClose: handleCloseItem, onItemOpen: handleOpenItem, focusPath: member.field.focusPath, focused: member.field.focused, path: member.field.path, onChange: handleChange, onInsert: handleInsert, onItemMove: handleMoveItem, onItemRemove: handleRemoveItem, onItemAppend: handleAppendItem, onItemPrepend: handlePrependItem, onPathFocus: handleFocusChildPath, resolveInitialValue: resolveInitialValue2, onUpload: handleUpload, resolveUploader: resolveUploader$1, validation: member.field.validation, presence: member.field.presence, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderField, renderItem, renderPreview, elementProps };
  }, [member.field.level, member.field.members, member.field.value, member.field.readOnly, member.field.schemaType, member.field.changed, member.field.id, member.field.focusPath, member.field.focused, member.field.path, member.field.validation, member.field.presence, handleExpandItem, handleCollapseItem, handleCloseItem, handleOpenItem, handleChange, handleInsert, handleMoveItem, handleRemoveItem, handleAppendItem, handlePrependItem, handleFocusChildPath, resolveInitialValue2, handleUpload, resolveUploader$1, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderField, renderItem, renderPreview, elementProps]);
  const renderedInput = (0, import_react51.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const fieldProps = (0, import_react51.useMemo)(() => {
    return { actions: fieldActions, name: member.name, index: member.index, level: member.field.level, value: member.field.value, title: member.field.schemaType.title, description: member.field.schemaType.description, collapsible: member.collapsible, collapsed: member.collapsed, changed: member.field.changed, onCollapse: handleCollapse, onExpand: handleExpand, schemaType: member.field.schemaType, inputId: member.field.id, path: member.field.path, presence: member.field.presence, validation: member.field.validation, children: renderedInput, inputProps };
  }, [fieldActions, member.name, member.index, member.field.level, member.field.value, member.field.schemaType, member.field.changed, member.field.id, member.field.path, member.field.presence, member.field.validation, member.collapsible, member.collapsed, handleCollapse, handleExpand, renderedInput, inputProps]);
  return (0, import_jsx_runtime6.jsx)(FormCallbacksProvider, { onFieldGroupSelect, onChange: handleChange, onSetFieldSetCollapsed, onSetPathCollapsed, onPathOpen, onPathBlur, onPathFocus, children: (0, import_react51.useMemo)(() => renderField(fieldProps), [fieldProps, renderField]) });
}
function resolveNativeNumberInputValue(schemaType, value, localValue) {
  if (isNumberSchemaType(schemaType) && typeof localValue === "string" && Number(localValue) === value) {
    return localValue;
  }
  return String(value != null ? value : "");
}
function PrimitiveField$1(props2) {
  const { member, renderInput, renderField } = props2;
  const fieldActions = useDocumentFieldActions();
  const focusRef = (0, import_react51.useRef)();
  const [localValue, setLocalValue] = (0, import_react51.useState)();
  const { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
  (0, import_react51.useEffect)(() => {
    var _a4;
    if (member.field.focused) {
      (_a4 = focusRef.current) == null ? void 0 : _a4.focus();
    }
  }, [member.field.focused]);
  const handleBlur = (0, import_react51.useCallback)(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]);
  const handleFocus = (0, import_react51.useCallback)(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]);
  const handleChange = (0, import_react51.useCallback)((event) => {
    onChange(PatchEvent.from(event).prefixAll(member.name));
  }, [onChange, member.name]);
  const handleNativeChange = (0, import_react51.useCallback)((event) => {
    let inputValue = event.currentTarget.value;
    if (isNumberSchemaType(member.field.schemaType)) {
      inputValue = event.currentTarget.valueAsNumber;
      if (inputValue > Number.MAX_SAFE_INTEGER || inputValue < Number.MIN_SAFE_INTEGER) {
        return;
      }
    } else if (isBooleanSchemaType(member.field.schemaType)) {
      inputValue = event.currentTarget.checked;
    }
    const hasEmptyValue = inputValue === "" || typeof inputValue === "number" && isNaN(inputValue);
    if (isNumberSchemaType(member.field.schemaType)) {
      setLocalValue(hasEmptyValue ? void 0 : event.currentTarget.value);
    }
    onChange(PatchEvent.from(hasEmptyValue ? unset2() : set$2(inputValue)).prefixAll(member.name));
  }, [member.name, member.field.schemaType, onChange]);
  const validationError = (0, import_react51.useMemo)(() => member.field.validation.filter((item) => item.level === "error").map((item) => item.message).join("\n"), [member.field.validation]) || void 0;
  const elementProps = (0, import_react51.useMemo)(() => ({ onBlur: handleBlur, onFocus: handleFocus, id: member.field.id, ref: focusRef, onChange: handleNativeChange, value: resolveNativeNumberInputValue(member.field.schemaType, member.field.value, localValue), readOnly: Boolean(member.field.readOnly), placeholder: member.field.schemaType.placeholder, "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description) }), [handleBlur, handleFocus, handleNativeChange, member.field.id, member.field.readOnly, member.field.schemaType, member.field.value, localValue]);
  const inputProps = (0, import_react51.useMemo)(() => {
    return { value: member.field.value, readOnly: member.field.readOnly, schemaType: member.field.schemaType, changed: member.field.changed, id: member.field.id, path: member.field.path, focused: member.field.focused, level: member.field.level, onChange: handleChange, validation: member.field.validation, presence: member.field.presence, validationError, elementProps };
  }, [member.field.value, member.field.readOnly, member.field.schemaType, member.field.changed, member.field.id, member.field.path, member.field.focused, member.field.level, member.field.validation, member.field.presence, handleChange, validationError, elementProps]);
  const renderedInput = (0, import_react51.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const fieldProps = (0, import_react51.useMemo)(() => {
    return { actions: fieldActions, changed: member.field.changed, children: renderedInput, description: member.field.schemaType.description, index: member.index, inputId: member.field.id, inputProps, level: member.field.level, name: member.name, path: member.field.path, presence: member.field.presence, schemaType: member.field.schemaType, title: member.field.schemaType.title, validation: member.field.validation, value: member.field.value };
  }, [fieldActions, member.field.level, member.field.value, member.field.schemaType, member.field.id, member.field.path, member.field.validation, member.field.presence, member.field.changed, member.name, member.index, renderedInput, inputProps]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: renderField(fieldProps) });
}
var ObjectField = function ObjectField2(props2) {
  const { onPathBlur, onPathFocus, onChange, onPathOpen, onSetPathCollapsed, onSetFieldSetCollapsed, onFieldGroupSelect } = useFormCallbacks();
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  const fieldActions = useDocumentFieldActions();
  const focusRef = (0, import_react51.useRef)();
  const pendingValue = (0, import_react51.useRef)(member.field.value);
  (0, import_react51.useEffect)(() => {
    pendingValue.current = member.field.value;
  }, [member.field.value]);
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a4;
    if (!hadFocus && hasFocus) {
      (_a4 = focusRef.current) == null ? void 0 : _a4.focus();
    }
  });
  const handleBlur = (0, import_react51.useCallback)(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]);
  const handleFocus = (0, import_react51.useCallback)(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]);
  const handleFocusChildPath = (0, import_react51.useCallback)((path2) => {
    onPathFocus(member.field.path.concat(path2));
  }, [member.field.path, onPathFocus]);
  const handleChange = (0, import_react51.useCallback)((event) => {
    const isRoot2 = member.field.path.length === 0;
    if (!isRoot2) {
      const patches = PatchEvent.from(event).patches;
      pendingValue.current = applyAll2(pendingValue.current || {}, patches);
      if (pendingValue.current && isShallowEmptyObject(pendingValue.current)) {
        onChange(PatchEvent.from(unset2([member.name])));
        return;
      }
    }
    onChange(PatchEvent.from(event).prepend(setIfMissing2(createProtoValue(member.field.schemaType))).prefixAll(member.name));
  }, [onChange, member, pendingValue]);
  const handleCollapse = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.field.path, true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpand = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.field.path, false);
  }, [onSetPathCollapsed, member.field.path]);
  const handleCollapseField = (0, import_react51.useCallback)((fieldName) => {
    onSetPathCollapsed(member.field.path.concat(fieldName), true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpandField = (0, import_react51.useCallback)((fieldName) => {
    onSetPathCollapsed(member.field.path.concat(fieldName), false);
  }, [onSetPathCollapsed, member.field.path]);
  const handleOpenField = (0, import_react51.useCallback)((fieldName) => {
    onPathOpen(member.field.path.concat(fieldName));
  }, [onPathOpen, member.field.path]);
  const handleCloseField = (0, import_react51.useCallback)(() => {
    onPathOpen(member.field.path);
  }, [onPathOpen, member.field.path]);
  const handleExpandFieldSet = (0, import_react51.useCallback)((fieldsetName) => {
    onSetFieldSetCollapsed(member.field.path.concat(fieldsetName), false);
  }, [onSetFieldSetCollapsed, member.field.path]);
  const handleCollapseFieldSet = (0, import_react51.useCallback)((fieldsetName) => {
    onSetFieldSetCollapsed(member.field.path.concat(fieldsetName), true);
  }, [onSetFieldSetCollapsed, member.field.path]);
  const handleOpen = (0, import_react51.useCallback)(() => {
    onPathOpen(member.field.path);
  }, [onPathOpen, member.field.path]);
  const handleClose = (0, import_react51.useCallback)(() => {
    onPathOpen(member.field.path.slice(0, -1));
  }, [onPathOpen, member.field.path]);
  const handleSelectFieldGroup = (0, import_react51.useCallback)((groupName) => {
    onFieldGroupSelect(member.field.path, groupName);
  }, [onFieldGroupSelect, member.field.path]);
  const elementProps = (0, import_react51.useMemo)(() => ({ onBlur: handleBlur, onFocus: handleFocus, id: member.field.id, ref: focusRef, "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description) }), [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]);
  const inputProps = (0, import_react51.useMemo)(() => {
    return { elementProps, level: member.field.level, members: member.field.members, value: member.field.value, readOnly: member.field.readOnly, validation: member.field.validation, presence: member.field.presence, schemaType: member.field.schemaType, changed: member.field.changed, id: member.field.id, onFieldGroupSelect: handleSelectFieldGroup, onFieldOpen: handleOpenField, onFieldClose: handleCloseField, onFieldCollapse: handleCollapseField, onFieldExpand: handleExpandField, onFieldSetExpand: handleExpandFieldSet, onFieldSetCollapse: handleCollapseFieldSet, onPathFocus: handleFocusChildPath, path: member.field.path, focusPath: member.field.focusPath, focused: member.field.focused, groups: member.field.groups, onChange: handleChange, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview };
  }, [elementProps, member.field.level, member.field.members, member.field.value, member.field.readOnly, member.field.validation, member.field.presence, member.field.schemaType, member.field.changed, member.field.id, member.field.path, member.field.focusPath, member.field.focused, member.field.groups, handleSelectFieldGroup, handleOpenField, handleCloseField, handleCollapseField, handleExpandField, handleExpandFieldSet, handleCollapseFieldSet, handleFocusChildPath, handleChange, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  const renderedInput = (0, import_react51.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const fieldProps = (0, import_react51.useMemo)(() => {
    return { actions: fieldActions, name: member.name, index: member.index, level: member.field.level, value: member.field.value, validation: member.field.validation, presence: member.field.presence, title: member.field.schemaType.title, description: member.field.schemaType.description, collapsible: member.collapsible, collapsed: member.collapsed, onCollapse: handleCollapse, onExpand: handleExpand, open: member.open, changed: member.field.changed, onOpen: handleOpen, onClose: handleClose, schemaType: member.field.schemaType, inputId: member.field.id, path: member.field.path, children: renderedInput, inputProps };
  }, [fieldActions, member.name, member.index, member.field.level, member.field.value, member.field.validation, member.field.presence, member.field.schemaType, member.field.changed, member.field.id, member.field.path, member.collapsible, member.collapsed, member.open, handleCollapse, handleExpand, handleOpen, handleClose, renderedInput, inputProps]);
  return (0, import_jsx_runtime6.jsx)(FormCallbacksProvider, { onFieldGroupSelect, onChange: handleChange, onSetFieldSetCollapsed, onPathOpen, onSetPathCollapsed, onPathBlur, onPathFocus, children: (0, import_react51.useMemo)(() => renderField(fieldProps), [fieldProps, renderField]) });
};
function readAsText(file2, encoding) {
  return new Observable((observer) => {
    const reader = new FileReader();
    reader.onerror = (error2) => observer.error(error2);
    reader.onload = () => {
      observer.next(reader.result);
      observer.complete();
    };
    reader.readAsText(file2, encoding);
    return () => {
      reader.abort();
    };
  });
}
function move2(arr, from2, to) {
  const copy2 = arr.slice();
  const val = copy2[from2];
  copy2.splice(from2, 1);
  copy2.splice(to, 0, val);
  return copy2;
}
function insertAfter(index, arr, items) {
  const copy2 = arr.slice();
  copy2.splice(index + 1, 0, ...items);
  return copy2;
}
function isStringNumeric(input) {
  return /^\d+$/.test(input);
}
function convertToSchemaType(line, candidates) {
  let acceptsBooleans = false;
  let acceptsNumbers = false;
  let acceptsStrings = false;
  candidates.forEach((candidate) => {
    if (isBooleanSchemaType(candidate)) {
      acceptsBooleans = true;
    }
    if (isStringSchemaType(candidate)) {
      acceptsStrings = true;
    }
    if (isNumberSchemaType(candidate)) {
      acceptsNumbers = true;
    }
  });
  if (acceptsBooleans && (line === "true" || line === "false"))
    return line === "true";
  if (acceptsNumbers && isStringNumeric(line))
    return Number(line);
  return acceptsStrings ? line : void 0;
}
function createPlainTextUploader(itemTypes) {
  return { priority: 0, accepts: "text/*", type: "string", upload(client, file2) {
    return readAsText(file2, "utf-8").pipe(map((textContent) => textContent == null ? void 0 : textContent.split(/[\n\r]/).map((value) => convertToSchemaType(value, itemTypes)).filter((v) => v !== void 0)), filter((v) => Array.isArray(v)), map((lines) => ({ type: "uploadProgress", patches: [insert2(lines, "after", [-1])] })));
  } };
}
function ArrayOfPrimitivesField(props2) {
  const { onPathBlur, onPathFocus, onChange, onPathOpen, onSetPathCollapsed, onSetFieldSetCollapsed, onFieldGroupSelect } = useFormCallbacks();
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  const fieldActions = useDocumentFieldActions();
  const focusRef = (0, import_react51.useRef)();
  const uploadSubscriptions = (0, import_react51.useRef)();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a4;
    if (!hadFocus && hasFocus) {
      (_a4 = focusRef.current) == null ? void 0 : _a4.focus();
    }
  });
  const handleFocus = (0, import_react51.useCallback)((event) => {
    if (event.currentTarget === event.target && event.currentTarget === focusRef.current) {
      onPathFocus(member.field.path);
    }
  }, [member.field.path, onPathFocus]);
  const handleBlur = (0, import_react51.useCallback)((event) => {
    if (event.currentTarget === event.target && event.currentTarget === focusRef.current) {
      onPathBlur(member.field.path);
    }
  }, [member.field.path, onPathBlur]);
  const handleChange = (0, import_react51.useCallback)((event) => {
    const patches = PatchEvent.from(event).patches;
    const isRemovingLastItem = patches.some((patch2) => patch2.type === "unset" && patch2.path.length === 1);
    if (isRemovingLastItem) {
      const result = applyAll2(member.field.value || [], patches);
      if (Array.isArray(result) && !result.length) {
        onChange(PatchEvent.from(unset2([member.name])));
        return;
      }
    }
    onChange(PatchEvent.from(event).prepend(setIfMissing2([])).prefixAll(member.name));
  }, [onChange, member.name, member.field.value]);
  const handleSetCollapsed = (0, import_react51.useCallback)((collapsed) => {
    onSetPathCollapsed(member.field.path, collapsed);
  }, [onSetPathCollapsed, member.field.path]);
  const handleCollapse = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.field.path, true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpand = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.field.path, false);
  }, [onSetPathCollapsed, member.field.path]);
  const setValue = (0, import_react51.useCallback)((nextValue) => {
    handleChange(nextValue.length === 0 ? unset2() : set$2(nextValue));
  }, [handleChange]);
  const handleMoveItem = (0, import_react51.useCallback)((event) => {
    const { value = [] } = member.field;
    if (event.fromIndex === event.toIndex) {
      return;
    }
    setValue(move2(value, event.fromIndex, event.toIndex));
  }, [member.field, setValue]);
  const handleAppend = (0, import_react51.useCallback)((itemValue) => {
    const { value = [] } = member.field;
    setValue(value.concat(itemValue));
  }, [member.field, setValue]);
  const handlePrepend = (0, import_react51.useCallback)((itemValue) => {
    const { value = [] } = member.field;
    setValue([itemValue].concat(value || []));
  }, [member.field, setValue]);
  const handleInsert = (0, import_react51.useCallback)((event) => {
    const { value = [] } = member.field;
    const insertIndex = event.referenceIndex + (event.position === "before" ? -1 : 0);
    setValue(insertAfter(insertIndex, value, event.items));
  }, [member.field, setValue]);
  const handleRemoveItem = (0, import_react51.useCallback)((index) => {
    handleChange(unset2([index]));
  }, [handleChange]);
  const handleFocusIndex = (0, import_react51.useCallback)((index) => {
    onPathFocus(member.field.path.concat([index]));
  }, [member.field.path, onPathFocus]);
  const elementProps = (0, import_react51.useMemo)(() => ({ onBlur: handleBlur, onFocus: handleFocus, id: member.field.id, ref: focusRef, "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description) }), [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]);
  const plainTextUploader = (0, import_react51.useMemo)(() => createPlainTextUploader(member.field.schemaType.of), [member.field.schemaType.of]);
  const resolveUploader2 = (0, import_react51.useCallback)((schemaType, file2) => accepts(file2, "text/*") ? plainTextUploader : null, [plainTextUploader]);
  const handleUpload = (0, import_react51.useCallback)((_ref171) => {
    let { file: file2, schemaType, uploader } = _ref171;
    const events$ = uploader.upload(client, file2, schemaType).pipe(map((uploadProgressEvent) => PatchEvent.from(uploadProgressEvent.patches || [])), tap((event) => handleChange(event.patches)));
    if (uploadSubscriptions.current) {
      uploadSubscriptions.current.unsubscribe();
    }
    uploadSubscriptions.current = events$.subscribe();
  }, [client, handleChange]);
  const inputProps = (0, import_react51.useMemo)(() => {
    return { level: member.field.level, members: member.field.members, value: member.field.value, readOnly: member.field.readOnly, onSetCollapsed: handleSetCollapsed, schemaType: member.field.schemaType, changed: member.field.changed, id: member.field.id, elementProps, path: member.field.path, focusPath: member.field.focusPath, focused: member.field.focused, onChange: handleChange, onInsert: handleInsert, onMoveItem: handleMoveItem, onItemRemove: handleRemoveItem, onItemAppend: handleAppend, onItemPrepend: handlePrepend, validation: member.field.validation, presence: member.field.presence, resolveUploader: resolveUploader2, onUpload: handleUpload, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderItem, onIndexFocus: handleFocusIndex, renderPreview };
  }, [member.field.level, member.field.members, member.field.value, member.field.readOnly, member.field.schemaType, member.field.changed, member.field.id, member.field.path, member.field.focusPath, member.field.focused, member.field.validation, member.field.presence, handleSetCollapsed, elementProps, handleChange, handleInsert, handleMoveItem, handleRemoveItem, handleAppend, handlePrepend, resolveUploader2, handleUpload, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderItem, handleFocusIndex, renderPreview]);
  const renderedInput = (0, import_react51.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const fieldProps = (0, import_react51.useMemo)(() => {
    return { actions: fieldActions, name: member.name, index: member.index, level: member.field.level, value: member.field.value, title: member.field.schemaType.title, description: member.field.schemaType.description, collapsible: member.collapsible, collapsed: member.collapsed, onExpand: handleExpand, changed: member.field.changed, onCollapse: handleCollapse, schemaType: member.field.schemaType, inputId: member.field.id, path: member.field.path, presence: member.field.presence, validation: member.field.validation, children: renderedInput, inputProps };
  }, [fieldActions, member.name, member.index, member.field.level, member.field.value, member.field.schemaType, member.field.changed, member.field.id, member.field.path, member.field.presence, member.field.validation, member.collapsible, member.collapsed, handleExpand, handleCollapse, renderedInput, inputProps]);
  return (0, import_jsx_runtime6.jsx)(FormCallbacksProvider, { onFieldGroupSelect, onChange: handleChange, onPathOpen, onSetFieldSetCollapsed, onSetPathCollapsed, onPathBlur, onPathFocus, children: (0, import_react51.useMemo)(() => renderField(fieldProps), [fieldProps, renderField]) });
}
function isMemberObject(member) {
  return isObjectSchemaType(member.field.schemaType);
}
function isMemberArrayOfPrimitives(member) {
  return isArraySchemaType(member.field.schemaType) && member.field.schemaType.of.every((ofType) => isPrimitiveSchemaType(ofType));
}
function isMemberArrayOfObjects(member) {
  return isArraySchemaType(member.field.schemaType) && member.field.schemaType.of.every((ofType) => isObjectSchemaType(ofType));
}
var MemberField = (0, import_react51.memo)(function MemberField2(props2) {
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  if (isMemberObject(member)) {
    return (0, import_jsx_runtime6.jsx)(ObjectField, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview });
  }
  if (isMemberArrayOfPrimitives(member)) {
    return (0, import_jsx_runtime6.jsx)(ArrayOfPrimitivesField, { member, renderAnnotation, renderBlock, renderField, renderInput, renderInlineBlock, renderItem, renderPreview });
  }
  if (isMemberArrayOfObjects(member)) {
    return (0, import_jsx_runtime6.jsx)(ArrayOfObjectsField, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview });
  }
  return (0, import_jsx_runtime6.jsx)(PrimitiveField$1, { member, renderField, renderInput });
});
var TRUTHY_STRINGS = ["yes", "true", "1"];
var FALSEY_STRINGS = ["false", "no", "false", "0", "null"];
var BOOL_STRINGS = TRUTHY_STRINGS.concat(FALSEY_STRINGS);
var TRUE = () => true;
var has = (prop) => (val) => val && val[prop];
var is = (typeName) => (val) => (val && val._type) === typeName;
function toLocalDate(input) {
  const newDate = new Date(input.getTime() + input.getTimezoneOffset() * 60 * 1e3);
  const offset2 = input.getTimezoneOffset() / 60;
  const hours = input.getHours();
  newDate.setHours(hours - offset2);
  return newDate;
}
function getTZName() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch (e2) {
  }
  return null;
}
var converters = { string: { number: { test: Number, convert: Number }, boolean: { test: (value) => BOOL_STRINGS.includes(value.toLowerCase()), convert: (value) => TRUTHY_STRINGS.includes(value.toLowerCase()) || !FALSEY_STRINGS.includes(value.toLowerCase()) }, richDate: { test: (value) => isValid(value), convert: (value) => {
  return { _type: "richDate", local: toLocalDate(new Date(value)).toJSON(), utc: new Date(value).toJSON(), timezone: getTZName(), offset: (/* @__PURE__ */ new Date()).getTimezoneOffset() };
} } }, date: { richDate: { test: is("date"), convert: (value) => Object.assign({}, value, { _type: "richDate" }) } }, richDate: { datetime: { test: has("utc"), convert: (value) => value.utc } }, number: { string: { test: TRUE, convert: String }, boolean: { test: TRUE, convert: Number } }, boolean: { string: { test: TRUE, convert: (value) => value ? "Yes" : "No" }, number: { test: TRUE, convert: Number } } };
function SetMissingTypeButton(_ref172) {
  let { value, targetType, onChange } = _ref172;
  const itemValue = (0, import_react51.useMemo)(() => ({ ...value, _type: targetType }), [targetType, value]);
  const handleClick = (0, import_react51.useCallback)(() => onChange(PatchEvent.from(setIfMissing2(targetType, ["_type"])), itemValue), [itemValue, onChange, targetType]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Button, { onClick: handleClick, text: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.untyped-value.convert-button.text", values: { targetType } }) }) });
}
function UnsetItemButton(_ref173) {
  let { value, onChange, validTypes } = _ref173;
  const itemValue = (0, import_react51.useMemo)(() => ({ ...value, _type: validTypes[0] }), [validTypes, value]);
  const handleClick = (0, import_react51.useCallback)(() => onChange(PatchEvent.from(unset2()), itemValue), [itemValue, onChange]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Button, { onClick: handleClick, tone: "critical", text: t3("inputs.untyped-value.unset-item-button.text") });
}
function UntypedValueInput(_ref174) {
  let { validTypes, value, onChange } = _ref174;
  const schema = useSchema();
  const isSingleValidType = validTypes.length === 1;
  const isHoistedType = schema.has(validTypes[0]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Alert, { status: "warning", title: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.untyped-value.title" }) }), children: (0, import_jsx_runtime6.jsx)(Details, { open: isDev, title: t3("inputs.untyped-value.details.title"), children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.untyped-value.description" }) }), isSingleValidType && !isHoistedType && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.untyped-value.details.description" }) }), !isSingleValidType && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("inputs.untyped-value.details.multi-type-description") }), !isSingleValidType && (0, import_jsx_runtime6.jsx)(Stack, { as: "ul", space: 2, children: validTypes.map((validType) => (0, import_jsx_runtime6.jsx)(Text3, { as: "li", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)("code", { children: validType }) }, validType)) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "h4", weight: "semibold", size: 1, children: t3("inputs.untyped-value.details.json-dump-prefix") }), (0, import_jsx_runtime6.jsx)(Card, { border: true, overflow: "auto", padding: 2, radius: 2, tone: "inherit", children: (0, import_jsx_runtime6.jsx)(Code, { language: "json", children: JSON.stringify(value, null, 2) }) })] }), (0, import_jsx_runtime6.jsxs)(Grid, { columns: [1, 2, 2], gap: 1, children: [isSingleValidType && (0, import_jsx_runtime6.jsx)(SetMissingTypeButton, { onChange, targetType: validTypes[0], value }), (0, import_jsx_runtime6.jsx)(UnsetItemButton, { onChange, validTypes, value })] })] }) }) });
}
function getConverters(value, actualType, validTypes) {
  if (!(actualType in converters)) {
    return [];
  }
  return Object.keys(converters[actualType]).filter((targetType) => validTypes.includes(targetType)).map((targetType) => ({ from: actualType, to: targetType, ...converters[actualType][targetType] })).filter((converter) => converter.test(value));
}
var InvalidValueInput = (0, import_react51.forwardRef)((props2, ref) => {
  const { value, actualType, validTypes, onChange } = props2;
  (0, import_react51.useImperativeHandle)(ref, () => ({
    // @todo
    focus: () => void 0
  }));
  const handleClearClick = (0, import_react51.useCallback)(() => {
    onChange(PatchEvent.from(unset2()));
  }, [onChange]);
  const handleConvertTo = (0, import_react51.useCallback)((converted) => {
    onChange(PatchEvent.from(set$2(converted)));
  }, [onChange]);
  const converters2 = (0, import_react51.useMemo)(() => getConverters(value, actualType, validTypes), [value, actualType, validTypes]);
  const { t: t3 } = useTranslation2();
  if ((0, import_isPlainObject5.default)(value) && !("_type" in value)) {
    return (0, import_jsx_runtime6.jsx)(UntypedValueInput, { value, validTypes, onChange });
  }
  const suffix = (0, import_jsx_runtime6.jsx)(Stack, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Button, { onClick: handleClearClick, tone: "critical", text: t3("inputs.invalid-value.reset-button.text") }) });
  return (0, import_jsx_runtime6.jsxs)(Alert, { status: "error", suffix, title: t3("inputs.invalid-value.title"), children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("inputs.invalid-value.description") }), (0, import_jsx_runtime6.jsx)(Details, { marginTop: 4, open: isDev, title: t3("inputs.invalid-value.details.title"), children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [validTypes.length === 1 && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.invalid-value.details.description", values: { validType: validTypes[0] } }) }), validTypes.length === 1 && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("inputs.invalid-value.details.possible-reason") }), validTypes.length !== 1 && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("inputs.invalid-value.details.multi-type-description") }), validTypes.length !== 1 && (0, import_jsx_runtime6.jsx)(Stack, { as: "ul", space: 2, children: validTypes.map((validType) => (0, import_jsx_runtime6.jsx)(Text3, { as: "li", children: (0, import_jsx_runtime6.jsx)("code", { children: validType }) }, validType)) }), (0, import_jsx_runtime6.jsxs)(Stack, { marginTop: 2, space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.invalid-value.current-type", values: { actualType } }) }), (0, import_jsx_runtime6.jsx)(Card, { border: true, padding: 2, radius: 2, tone: "inherit", children: (0, import_jsx_runtime6.jsx)(Code, { language: "json", size: 1, children: JSON.stringify(value, null, 2) }) })] }), converters2.length > 0 && (0, import_jsx_runtime6.jsx)(Stack, { space: 1, children: converters2.map((converter) => (0, import_jsx_runtime6.jsx)(ConvertButton, { converter, onConvert: handleConvertTo, value }, "".concat(converter.from, "-").concat(converter.to))) })] }) })] });
});
InvalidValueInput.displayName = "InvalidValueInput";
function ConvertButton(_ref175) {
  let { converter, onConvert, value } = _ref175;
  const handleClick = (0, import_react51.useCallback)(() => onConvert(converter.convert(value)), [converter, onConvert, value]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Button, { onClick: handleClick, text: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.invalid-value.convert-button.text", values: { targetType: converter.to } }) }) });
}
function MissingKeysAlert(props2) {
  const { error: error2, onChange } = props2;
  const handleFixMissingKeys = (0, import_react51.useCallback)(() => {
    onChange(PatchEvent.from((error2.value || []).map((val, i) => setIfMissing2(randomKey(), [i, "_key"]))));
  }, [error2.value, onChange]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(FormField, { title: error2.schemaType.title, description: error2.schemaType.description, children: (0, import_jsx_runtime6.jsxs)(Alert, { status: "warning", suffix: (0, import_jsx_runtime6.jsx)(Stack, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Button, { onClick: handleFixMissingKeys, text: t3("form.error.missing-keys-alert.add-button.text"), tone: "caution" }) }), title: t3("form.error.missing-keys-alert.title"), children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("form.error.missing-keys-alert.summary") }), (0, import_jsx_runtime6.jsx)(Details, { marginTop: 4, open: isDev, title: t3("form.error.missing-keys-alert.details.title"), children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "form.error.missing-keys-alert.details.description" }) }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "form.error.missing-keys-alert.details.additional-description" }) })] }) })] }) });
}
function DuplicateKeysAlert(props2) {
  const { error: error2, onChange } = props2;
  const handleFixDuplicateKeys = (0, import_react51.useCallback)(() => {
    onChange(PatchEvent.from((error2.duplicates || []).map((_ref176) => {
      let [index, key2] = _ref176;
      return set$2("".concat(key2, "_deduped_").concat(index), [index, "_key"]);
    })));
  }, [error2.duplicates, onChange]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(FormField, { title: error2.schemaType.title, description: error2.schemaType.description, children: (0, import_jsx_runtime6.jsxs)(Alert, { status: "warning", suffix: (0, import_jsx_runtime6.jsx)(Stack, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Button, { onClick: handleFixDuplicateKeys, text: t3("form.error.duplicate-keys-alert.generate-button.text"), tone: "caution" }) }), title: t3("form.error.duplicate-keys-alert.title"), children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("form.error.duplicate-keys-alert.summary") }), (0, import_jsx_runtime6.jsx)(Details, { marginTop: 4, open: isDev, title: t3("form.error.duplicate-keys-alert.details.title"), children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "form.error.duplicate-keys-alert.details.description" }) }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "form.error.duplicate-keys-alert.details.additional-description" }) })] }) })] }) });
}
function MixedArrayAlert(props2) {
  const { error: error2, onChange } = props2;
  const handleRemoveNonObjectValues = () => {
    const nonObjectIndices = (error2.value || []).flatMap((item, index) => (0, import_isPlainObject5.default)(item) ? [] : [index]).reverse();
    const patches = nonObjectIndices.map((index) => unset2([index]));
    onChange(PatchEvent.from(patches));
  };
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(FormField, { title: error2.schemaType.title, description: error2.schemaType.description, children: (0, import_jsx_runtime6.jsxs)(Alert, { status: "error", suffix: (0, import_jsx_runtime6.jsx)(Stack, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Button, { onClick: handleRemoveNonObjectValues, text: t3("form.error.mixed-array-alert.remove-button.text"), tone: "critical" }) }), title: t3("form.error.mixed-array-alert.title"), children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("form.error.mixed-array-alert.summary") }), (0, import_jsx_runtime6.jsx)(Details, { marginTop: 4, open: isDev, title: t3("form.error.mixed-array-alert.details.title"), children: (0, import_jsx_runtime6.jsx)(Stack, { space: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("form.error.mixed-array-alert.details.description") }) }) })] }) });
}
function MemberFieldError(props2) {
  const { member } = props2;
  const { onChange } = useFormCallbacks();
  const handleChange = (0, import_react51.useCallback)((event) => {
    onChange(PatchEvent.from(event).prefixAll(member.fieldName));
  }, [onChange, member.fieldName]);
  const { t: t3 } = useTranslation2();
  if (member.error.type === "INCOMPATIBLE_TYPE") {
    return (0, import_jsx_runtime6.jsx)(InvalidValueInput, { value: member.error.value, onChange: handleChange, actualType: member.error.resolvedValueType, validTypes: [member.error.expectedSchemaType.name] });
  }
  if (member.error.type === "MISSING_KEYS") {
    return (0, import_jsx_runtime6.jsx)(MissingKeysAlert, { error: member.error, onChange: handleChange });
  }
  if (member.error.type === "DUPLICATE_KEYS") {
    return (0, import_jsx_runtime6.jsx)(DuplicateKeysAlert, { error: member.error, onChange: handleChange });
  }
  if (member.error.type === "MIXED_ARRAY") {
    return (0, import_jsx_runtime6.jsx)(MixedArrayAlert, { onChange: handleChange, error: member.error });
  }
  return (0, import_jsx_runtime6.jsx)(Box, { children: t3("member-field-error.unexpected-error", { error: props2.member.error.type }) });
}
var MemberFieldSet = (0, import_react51.memo)(function MemberFieldSet2(props2) {
  var _a4;
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  const { onSetFieldSetCollapsed } = useFormCallbacks();
  const handleCollapse = (0, import_react51.useCallback)(() => {
    onSetFieldSetCollapsed(member.fieldSet.path, true);
  }, [member.fieldSet.path, onSetFieldSetCollapsed]);
  const handleExpand = (0, import_react51.useCallback)(() => {
    onSetFieldSetCollapsed(member.fieldSet.path, false);
  }, [member.fieldSet.path, onSetFieldSetCollapsed]);
  return (0, import_jsx_runtime6.jsx)(FormFieldSet, { title: member.fieldSet.title || (0, import_capitalize2.default)(member.fieldSet.name), description: member.fieldSet.description, level: member.fieldSet.level, collapsible: member.fieldSet.collapsible, collapsed: member.fieldSet.collapsed, onCollapse: handleCollapse, onExpand: handleExpand, columns: (_a4 = member == null ? void 0 : member.fieldSet) == null ? void 0 : _a4.columns, "data-testid": "fieldset-".concat(member.fieldSet.name), inputId: member.fieldSet.name, children: member.fieldSet.members.map((fieldsetMember) => {
    if (fieldsetMember.kind === "error") {
      return (0, import_jsx_runtime6.jsx)(MemberFieldError, { member: fieldsetMember }, member.key);
    }
    return (0, import_jsx_runtime6.jsx)(MemberField, { member: fieldsetMember, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }, fieldsetMember.key);
  }) });
});
function ArrayOfObjectsItem(props2) {
  const focusRef = (0, import_react51.useRef)();
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  const { t: t3 } = useTranslation2();
  const { onPathBlur, onPathFocus, onChange, onPathOpen, onSetPathCollapsed, onSetFieldSetCollapsed, onFieldGroupSelect } = useFormCallbacks();
  const resolveInitialValue2 = useResolveInitialValueForType();
  useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
    var _a4;
    if (!hadFocus && hasFocus) {
      (_a4 = focusRef.current) == null ? void 0 : _a4.focus();
    }
  });
  const onRemove = (0, import_react51.useCallback)(() => {
    onChange(PatchEvent.from([unset2([{ _key: member.key }])]));
  }, [member.key, onChange]);
  const handleOpenItem = (0, import_react51.useCallback)((path2) => {
    onPathOpen(path2);
    onSetPathCollapsed(path2, false);
  }, [onPathOpen, onSetPathCollapsed]);
  const toast = useToast();
  const handleInsert = (0, import_react51.useCallback)((event) => {
    if (event.items.length === 0) {
      throw new Error("Insert event should include at least one item");
    }
    const itemsWithKeys = event.items.map((item) => ensureKey(item));
    onChange(PatchEvent.from([insert2(itemsWithKeys, event.position, [{ _key: member.key }])]));
    const focusItemKey = itemsWithKeys[0]._key;
    const parentPath = member.item.path.slice(0, -1);
    const itemPath = [...parentPath, { _key: focusItemKey }];
    onPathFocus(itemPath);
    const shouldOpen = event.open !== false;
    if (event.skipInitialValue) {
      if (shouldOpen) {
        handleOpenItem(itemPath);
      }
    } else {
      resolveInitialArrayValues(itemsWithKeys, member.parentSchemaType, resolveInitialValue2).pipe(tap((result) => {
        if (result.type === "patch") {
          onChange(PatchEvent.from(result.patches));
        } else {
          toast.push({ title: t3("inputs.array.error.cannot-resolve-initial-value-title"), description: t3("inputs.array.error.cannot-resolve-initial-value-description", { schemaTypeTitle: result.schemaType.title, errorMessage: result.error.message }), status: "error" });
        }
      })).subscribe({ complete: () => {
        if (shouldOpen) {
          handleOpenItem(itemPath);
        }
      } });
    }
  }, [handleOpenItem, member.item.path, member.key, member.parentSchemaType, onChange, onPathFocus, resolveInitialValue2, toast, t3]);
  const handleBlur = (0, import_react51.useCallback)(() => {
    onPathBlur(member.item.path);
  }, [member.item.path, onPathBlur]);
  const handleFocus = (0, import_react51.useCallback)(() => {
    onPathFocus(member.item.path);
  }, [member.item.path, onPathFocus]);
  const handleFocusChildPath = (0, import_react51.useCallback)((path2) => {
    onPathFocus(member.item.path.concat(path2));
  }, [member.item.path, onPathFocus]);
  const handleChange = (0, import_react51.useCallback)((event) => {
    onChange(PatchEvent.from(event).prepend(setIfMissing2(createProtoValue(member.item.schemaType))).prefixAll({ _key: member.key }));
  }, [onChange, member.item.schemaType, member.key]);
  const handleCollapse = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.item.path, true);
  }, [onSetPathCollapsed, member.item.path]);
  const handleExpand = (0, import_react51.useCallback)(() => {
    onSetPathCollapsed(member.item.path, false);
  }, [onSetPathCollapsed, member.item.path]);
  const handleCollapseField = (0, import_react51.useCallback)((fieldName) => {
    onSetPathCollapsed(member.item.path.concat(fieldName), true);
  }, [onSetPathCollapsed, member.item.path]);
  const handleExpandField = (0, import_react51.useCallback)((fieldName) => {
    onSetPathCollapsed(member.item.path.concat(fieldName), false);
  }, [onSetPathCollapsed, member.item.path]);
  const handleCloseField = (0, import_react51.useCallback)(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]);
  const handleOpenField = (0, import_react51.useCallback)((fieldName) => {
    onPathOpen(member.item.path.concat(fieldName));
  }, [onPathOpen, member.item.path]);
  const handleExpandFieldSet = (0, import_react51.useCallback)((fieldsetName) => {
    onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), false);
  }, [onSetFieldSetCollapsed, member.item.path]);
  const handleCollapseFieldSet = (0, import_react51.useCallback)((fieldsetName) => {
    onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), true);
  }, [onSetFieldSetCollapsed, member.item.path]);
  const handleOpen = (0, import_react51.useCallback)(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]);
  const isEmptyValue = !member.item.value || isEmptyItem(member.item.value);
  const handleClose = (0, import_react51.useCallback)(() => {
    if (isEmptyValue) {
      onRemove();
    }
    const parentPath = member.item.path.slice(0, -1);
    onPathOpen(parentPath);
    onPathFocus(parentPath);
  }, [isEmptyValue, onPathOpen, member.item.path, onPathFocus, onRemove]);
  const handleSelectFieldGroup = (0, import_react51.useCallback)((groupName) => {
    onFieldGroupSelect(member.item.path, groupName);
  }, [onFieldGroupSelect, member.item.path]);
  const elementProps = (0, import_react51.useMemo)(() => ({ onBlur: handleBlur, onFocus: handleFocus, id: member.item.id, ref: focusRef, "aria-describedby": createDescriptionId(member.item.id, member.item.schemaType.description) }), [handleBlur, handleFocus, member.item.id, member.item.schemaType.description]);
  const inputProps = (0, import_react51.useMemo)(() => {
    return { changed: member.item.changed, focusPath: member.item.focusPath, focused: member.item.focused, groups: member.item.groups, id: member.item.id, level: member.item.level, members: member.item.members, onChange: handleChange, onFieldClose: handleCloseField, onFieldCollapse: handleCollapseField, onFieldSetCollapse: handleCollapseFieldSet, onFieldExpand: handleExpandField, onFieldSetExpand: handleExpandFieldSet, onFieldGroupSelect: handleSelectFieldGroup, onPathFocus: handleFocusChildPath, onFieldOpen: handleOpenField, path: member.item.path, presence: member.item.presence, readOnly: member.item.readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType: member.item.schemaType, validation: member.item.validation, value: member.item.value, elementProps };
  }, [elementProps, handleChange, handleCloseField, handleCollapseField, handleCollapseFieldSet, handleExpandField, handleExpandFieldSet, handleFocusChildPath, handleOpenField, handleSelectFieldGroup, member.item.changed, member.item.focusPath, member.item.focused, member.item.groups, member.item.id, member.item.level, member.item.members, member.item.path, member.item.presence, member.item.readOnly, member.item.schemaType, member.item.validation, member.item.value, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  const renderedInput = (0, import_react51.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const itemProps = (0, import_react51.useMemo)(() => {
    return { key: member.key, index: member.index, level: member.item.level, value: member.item.value, title: member.item.schemaType.title, description: member.item.schemaType.description, collapsible: member.collapsible, collapsed: member.collapsed, schemaType: member.item.schemaType, parentSchemaType: member.parentSchemaType, onInsert: handleInsert, onRemove, presence: member.item.presence, validation: member.item.validation, open: member.open, onOpen: handleOpen, onClose: handleClose, onExpand: handleExpand, onCollapse: handleCollapse, readOnly: member.item.readOnly, focused: member.item.focused, onFocus: handleFocus, onBlur: handleBlur, inputId: member.item.id, path: member.item.path, children: renderedInput, changed: member.item.changed, inputProps };
  }, [member.key, member.index, member.item.level, member.item.value, member.item.schemaType, member.parentSchemaType, member.item.presence, member.item.validation, member.item.readOnly, member.item.focused, member.item.id, member.item.path, member.item.changed, member.collapsible, member.collapsed, member.open, handleInsert, onRemove, handleOpen, handleClose, handleExpand, handleCollapse, handleFocus, handleBlur, renderedInput, inputProps]);
  return (0, import_jsx_runtime6.jsx)(FormCallbacksProvider, { onFieldGroupSelect, onChange: handleChange, onPathOpen, onSetFieldSetCollapsed, onSetPathCollapsed, onPathBlur, onPathFocus, children: (0, import_react51.useMemo)(() => renderItem(itemProps), [itemProps, renderItem]) });
}
function getEmptyValue(type) {
  switch (type.jsonType) {
    case "string": {
      return "";
    }
    case "number": {
      return -0;
    }
    case "boolean": {
      return false;
    }
    default:
      throw new Error('Unable to create value from type "'.concat(type.jsonType, '"'));
  }
}
function ArrayOfPrimitivesItem(props2) {
  const focusRef = (0, import_react51.useRef)();
  const { member, renderItem, renderInput } = props2;
  const [localValue, setLocalValue] = (0, import_react51.useState)();
  const { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
  useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
    var _a4;
    if (!hadFocus && hasFocus) {
      (_a4 = focusRef.current) == null ? void 0 : _a4.focus();
    }
  });
  const handleBlur = (0, import_react51.useCallback)((event) => {
    onPathBlur(member.item.path);
  }, [member.item.path, onPathBlur]);
  const handleFocus = (0, import_react51.useCallback)((event) => {
    onPathFocus(member.item.path);
  }, [member.item.path, onPathFocus]);
  const handleChange = (0, import_react51.useCallback)((event) => {
    onChange(PatchEvent.from(event).prefixAll(member.index));
  }, [onChange, member.index]);
  const handleNativeChange = (0, import_react51.useCallback)((event) => {
    let inputValue = event.currentTarget.value;
    if (isNumberSchemaType(member.item.schemaType)) {
      inputValue = event.currentTarget.valueAsNumber;
      if (inputValue > Number.MAX_SAFE_INTEGER || inputValue < Number.MIN_SAFE_INTEGER) {
        return;
      }
    } else if (isBooleanSchemaType(member.item.schemaType)) {
      inputValue = event.currentTarget.checked;
    }
    const hasEmptyValue = inputValue === "" || typeof inputValue === "number" && isNaN(inputValue);
    if (isNumberSchemaType(member.item.schemaType)) {
      setLocalValue(hasEmptyValue ? void 0 : event.currentTarget.value);
    }
    handleChange(set$2(hasEmptyValue ? (
      // Map direct unset patches to empty value instead in order to not *remove* elements as the user clears out the value
      // note: this creates the rather curious case where the input renders 0 when you try to clear it.
      getEmptyValue(member.item.schemaType)
    ) : inputValue));
  }, [handleChange, member.item.schemaType]);
  const elementProps = (0, import_react51.useMemo)(() => ({ onBlur: handleBlur, onFocus: handleFocus, id: member.item.id, ref: focusRef, onChange: handleNativeChange, value: resolveNativeInputValue(member.item.schemaType, member.item.value, localValue), readOnly: Boolean(member.item.readOnly), placeholder: member.item.schemaType.placeholder, "aria-describedby": createDescriptionId(member.item.id, member.item.schemaType.description) }), [handleBlur, handleFocus, handleNativeChange, member.item.id, member.item.readOnly, member.item.schemaType, member.item.value, localValue]);
  const inputProps = (0, import_react51.useMemo)(() => {
    return { changed: member.item.changed, level: member.item.level, value: member.item.value, readOnly: member.item.readOnly, schemaType: member.item.schemaType, id: member.item.id, path: member.item.path, focused: member.item.focused, onChange: handleChange, validation: member.item.validation, presence: member.item.presence, elementProps };
  }, [member.item.changed, member.item.level, member.item.value, member.item.readOnly, member.item.schemaType, member.item.id, member.item.path, member.item.focused, member.item.validation, member.item.presence, handleChange, elementProps]);
  const renderedInput = (0, import_react51.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const onRemove = (0, import_react51.useCallback)(() => {
    onChange(PatchEvent.from([unset2([member.index])]));
  }, [member.index, onChange]);
  const onInsert = (0, import_react51.useCallback)((event) => {
    onChange(PatchEvent.from([insert2(event.items, event.position, [member.index])]));
  }, [member.index, onChange]);
  const itemProps = (0, import_react51.useMemo)(() => {
    return { key: member.key, index: member.index, level: member.item.level, value: member.item.value, title: member.item.schemaType.title, description: member.item.schemaType.description, schemaType: member.item.schemaType, parentSchemaType: member.parentSchemaType, onInsert, onRemove, presence: member.item.presence, validation: member.item.validation, readOnly: member.item.readOnly, focused: member.item.focused, onFocus: handleFocus, onBlur: handleBlur, inputId: member.item.id, path: member.item.path, children: renderedInput };
  }, [member.key, member.index, member.item.level, member.item.value, member.item.schemaType, member.item.presence, member.item.validation, member.item.readOnly, member.item.focused, member.item.id, member.item.path, member.parentSchemaType, onInsert, onRemove, handleFocus, handleBlur, renderedInput]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (0, import_react51.useMemo)(() => renderItem(itemProps), [itemProps, renderItem]) });
}
function resolveNativeInputValue(schemaType, value, localValue) {
  if (Object.is(value, -0)) {
    return "";
  }
  return resolveNativeNumberInputValue(schemaType, value, localValue);
}
var __freeze$1N = Object.freeze;
var __defProp$1N = Object.defineProperty;
var __template$1N = (cooked, raw) => __freeze$1N(__defProp$1N(cooked, "raw", { value: __freeze$1N(raw || cooked.slice()) }));
var _a$1N;
var PopoverCard$2 = st(Card)(_a$1N || (_a$1N = __template$1N(["\n  max-width: ", "px;\n"])), (_ref177) => {
  let { theme } = _ref177;
  return theme.sanity.container[1];
});
function IncompatibleItemType$2(props2) {
  const { value, onFocus, vertical, ...rest } = props2;
  const [showDetails, setShowDetails] = import_react51.default.useState(false);
  const [popoverRef, setPopoverRef] = import_react51.default.useState(null);
  const { t: t3 } = useTranslation2();
  useClickOutside(() => setShowDetails(false), [popoverRef]);
  const handleKeyDown = import_react51.default.useCallback((e2) => {
    if (e2.key === "Escape" || e2.key === "Tab") {
      setShowDetails(false);
    }
  }, []);
  const handleShowDetails = (0, import_react51.useCallback)(() => {
    setShowDetails((v) => !v);
  }, []);
  const typeName = resolveTypeName(value);
  return (0, import_jsx_runtime6.jsx)(Popover, { open: showDetails, ref: setPopoverRef, onKeyDown: handleKeyDown, portal: true, constrainSize: true, tone: "default", content: (0, import_jsx_runtime6.jsx)(PopoverCard$2, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.type-is-incompatible-prompt", values: { typeName } }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.array.error.type-is-incompatible-title") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.current-schema-not-declare-description", values: { typeName } }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, children: [(0, import_jsx_runtime6.jsx)(BulbOutlineIcon, {}), " ", t3("inputs.array.error.can-delete-but-no-edit-description")] }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.array.error.json-representation-description") }), (0, import_jsx_runtime6.jsx)(Card, { padding: 2, overflow: "auto", border: true, children: (0, import_jsx_runtime6.jsx)(Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })] })] }) }), children: (0, import_jsx_runtime6.jsx)(Card, { as: "button", type: "button", radius: 2, tone: "inherit", paddingX: 2, paddingY: 3, flex: 1, onFocus, onClick: handleShowDetails, onKeyDown: handleKeyDown, __unstable_focusRing: true, ...rest, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { marginRight: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(UnknownIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, textOverflow: "ellipsis", children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.type-is-incompatible-prompt", values: { typeName } }) }) })] }) }) });
}
function MemberItemError(props2) {
  const { member } = props2;
  const { t: t3 } = useTranslation2();
  if (member.error.type === "INVALID_ITEM_TYPE") {
    return (0, import_jsx_runtime6.jsx)(IncompatibleItemType$2, { value: member.error.value });
  }
  return (0, import_jsx_runtime6.jsx)("div", { children: t3("inputs.array.error.unexpected-error", { error: member.error.type }) });
}
function ArrayOfObjectsInputMember(props2) {
  const { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = props2;
  if (member.kind === "item") {
    return (0, import_jsx_runtime6.jsx)(ArrayOfObjectsItem, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }, member.key);
  }
  if (member.kind === "error") {
    return (0, import_jsx_runtime6.jsx)(MemberItemError, { member }, member.key);
  }
  console.warn(new Error("Unhandled member kind ".concat(member.kind)));
  return null;
}
function ArrayOfObjectsInputMembers(props2) {
  const { members, ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: members.map((member) => (0, import_jsx_runtime6.jsx)(ArrayOfObjectsInputMember, { member, ...rest }, member.key)) });
}
var ObjectInputMember = (0, import_react51.memo)(function ObjectInputMember2(props2) {
  const { member, renderAnnotation, renderBlock, renderInput, renderInlineBlock, renderField, renderItem, renderPreview } = props2;
  if (member.kind === "field") {
    return (0, import_jsx_runtime6.jsx)(MemberField, { member, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderField, renderItem, renderPreview }, member.key);
  }
  if (member.kind === "error") {
    return (0, import_jsx_runtime6.jsx)(MemberFieldError, { member }, member.key);
  }
  if (member.kind === "fieldSet") {
    return (0, import_jsx_runtime6.jsx)(MemberFieldSet, { member, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderField, renderItem, renderPreview }, member.key);
  }
  console.warn(new Error("Unhandled member kind ".concat(member.kind)));
  return null;
});
function ObjectInputMembers(props2) {
  const { members, renderAnnotation, renderBlock, renderInput, renderInlineBlock, renderField, renderItem, renderPreview } = props2;
  const renderMembers = (0, import_react51.useMemo)(() => members.map((member) => (0, import_jsx_runtime6.jsx)(ObjectInputMember, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }, member.key)), [members, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: renderMembers });
}
var ObjectMembers = ObjectInputMembers;
var pass = (_ref178) => {
  let { children } = _ref178;
  return children;
};
function hasAbsolutePath(a) {
  return "absolutePath" in a;
}
var FormInput = (0, import_react51.memo)(function FormInput2(props2) {
  const absolutePath = (0, import_react51.useMemo)(() => {
    return hasAbsolutePath(props2) ? props2.absolutePath : props2.path.concat(props2.relativePath);
  }, [props2]);
  const nullRender = (0, import_react51.useCallback)(() => (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: "Missing destination render function" }), []);
  return (0, import_jsx_runtime6.jsx)(FormInputInner, { ...props2, absolutePath, destinationRenderAnnotation: props2.renderAnnotation || nullRender, destinationRenderBlock: props2.renderBlock || nullRender, destinationRenderField: props2.renderField, destinationRenderInlineBlock: props2.renderInlineBlock || nullRender, destinationRenderInput: props2.renderInput, destinationRenderItem: props2.renderItem, destinationRenderPreview: props2.renderPreview });
});
var FormInputInner = (0, import_react51.memo)(function FormInputInner2(props2) {
  const { absolutePath, destinationRenderAnnotation, destinationRenderBlock, destinationRenderField, destinationRenderInlineBlock, destinationRenderInput, destinationRenderItem, destinationRenderPreview } = props2;
  const { t: t3 } = useTranslation2();
  const renderInput = (0, import_react51.useCallback)((inputProps) => {
    const isDestinationReached = isEqual(inputProps.path, absolutePath) || startsWith(absolutePath, inputProps.path);
    if (isDestinationReached) {
      return destinationRenderInput(inputProps);
    }
    if (!isObjectInputProps$1(inputProps) && !isArrayInputProps(inputProps)) {
      throw new Error("Expected either object input props or array input props for: ".concat(JSON.stringify(inputProps.path)));
    }
    return (0, import_jsx_runtime6.jsx)(FormInputInner2, { ...inputProps, absolutePath, destinationRenderAnnotation, destinationRenderBlock, destinationRenderInput, destinationRenderItem, destinationRenderField, destinationRenderInlineBlock, destinationRenderPreview });
  }, [absolutePath, destinationRenderAnnotation, destinationRenderBlock, destinationRenderField, destinationRenderInlineBlock, destinationRenderInput, destinationRenderItem, destinationRenderPreview]);
  const renderField = (0, import_react51.useCallback)((fieldProps) => {
    const shouldRenderField = startsWith(absolutePath, fieldProps.path) && (props2.includeField || !isEqual(absolutePath, fieldProps.path));
    return shouldRenderField ? destinationRenderField(fieldProps) : pass(fieldProps);
  }, [absolutePath, destinationRenderField, props2.includeField]);
  const renderItem = (0, import_react51.useCallback)((itemProps) => {
    const shouldRenderField = startsWith(absolutePath, itemProps.path) && (props2.includeItem || !isEqual(absolutePath, itemProps.path));
    return shouldRenderField ? destinationRenderItem(itemProps) : pass(itemProps);
  }, [absolutePath, destinationRenderItem, props2.includeItem]);
  const renderBlock = (0, import_react51.useCallback)((blockProps) => {
    const shouldRenderBlock = startsWith(absolutePath, blockProps.path) && (props2.includeItem || !isEqual(absolutePath, blockProps.path));
    return shouldRenderBlock ? destinationRenderBlock(blockProps) : pass(blockProps);
  }, [absolutePath, destinationRenderBlock, props2.includeItem]);
  const renderInlineBlock = (0, import_react51.useCallback)((blockProps) => {
    const shouldRenderInlineBlock = startsWith(absolutePath, blockProps.path) && (props2.includeItem || !isEqual(absolutePath, blockProps.path));
    return shouldRenderInlineBlock ? destinationRenderInlineBlock(blockProps) : pass(blockProps);
  }, [absolutePath, destinationRenderInlineBlock, props2.includeItem]);
  const renderAnnotation = (0, import_react51.useCallback)((annotationProps) => {
    const shouldRenderAnnotation = startsWith(absolutePath, annotationProps.path) && (props2.includeItem || !isEqual(absolutePath, annotationProps.path));
    return shouldRenderAnnotation ? destinationRenderAnnotation(annotationProps) : pass(annotationProps);
  }, [absolutePath, destinationRenderAnnotation, props2.includeItem]);
  if (isArrayInputProps(props2)) {
    const childPath = trimLeft(props2.path, absolutePath);
    const itemMember = props2.members.find((member) => member.kind == "item" && isKeySegment(childPath[0]) && member.key === childPath[0]._key);
    if (!itemMember) {
      const path2 = pathToString2(props2.path);
      const relativePath = trimLeft(props2.path, absolutePath);
      if (isKeySegment(relativePath[0])) {
        const key2 = relativePath[0]._key;
        return (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "form.error.no-array-item-at-key", values: { key: key2, path: path2 } }) });
      }
      const index = isIndexSegment(relativePath[0]) ? relativePath[0] : relativePath[0][0];
      return (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "form.error.no-array-item-at-index", values: { index, path: path2 } }) });
    }
    if (itemMember.kind === "error") {
      return (0, import_jsx_runtime6.jsx)(MemberItemError, { member: itemMember });
    }
    return (0, import_jsx_runtime6.jsx)(ArrayOfObjectsItem, { member: itemMember, renderAnnotation, renderBlock, renderInput, renderField, renderInlineBlock, renderItem, renderPreview: destinationRenderPreview });
  }
  if (isObjectInputProps$1(props2)) {
    const childPath = trimLeft(props2.path, absolutePath);
    const fieldMember = props2.members.find((member) => member.kind == "field" && childPath[0] === member.name);
    if (!fieldMember) {
      const fieldName = typeof childPath[0] === "string" ? childPath[0] : JSON.stringify(childPath[0]);
      return (0, import_jsx_runtime6.jsx)("div", { children: t3("form.error.field-not-found", { fieldName }) });
    }
    return (0, import_jsx_runtime6.jsx)(MemberField, { member: fieldMember, renderAnnotation, renderBlock, renderInput, renderInlineBlock, renderField, renderItem, renderPreview: destinationRenderPreview });
  }
  throw new Error("FormInput can only be used with arrays or objects");
});
var VirtualizerScrollInstanceContext = (0, import_react51.createContext)(null);
function useVirtualizerScrollInstance() {
  const ref = (0, import_react51.useContext)(VirtualizerScrollInstanceContext);
  if (!ref) {
    throw new Error("VirtualizerScrollInstance: missing context value");
  }
  return ref;
}
function VirtualizerScrollInstanceProvider(props2) {
  const { scrollElement, containerElement } = props2;
  return (0, import_jsx_runtime6.jsx)(VirtualizerScrollInstanceContext.Provider, { value: { scrollElement, containerElement }, children: props2.children });
}
var PRESENCE_MARGINS = [0, 0, 1, 0];
function onDragEnter(event) {
  return event.stopPropagation();
}
function EditPortal(props2) {
  const { children, header, id: id4, legacy_referenceElement: referenceElement, onClose, type, width, autofocus } = props2;
  const [documentScrollElement, setDocumentScrollElement] = (0, import_react51.useState)(null);
  const containerElement = (0, import_react51.useRef)(null);
  const contents = (0, import_jsx_runtime6.jsx)(PresenceOverlay, { margins: PRESENCE_MARGINS, children: (0, import_jsx_runtime6.jsx)(Box, { ref: containerElement, padding: 4, children }) });
  if (type === "dialog") {
    return (0, import_jsx_runtime6.jsx)(VirtualizerScrollInstanceProvider, { scrollElement: documentScrollElement, containerElement, children: (0, import_jsx_runtime6.jsx)(Dialog, { header, id: id4 || "", onClickOutside: onClose, onClose, onDragEnter, width, contentRef: setDocumentScrollElement, __unstable_autoFocus: autofocus, children: contents }) });
  }
  return (0, import_jsx_runtime6.jsx)(PopoverDialog, { header, onClose, referenceElement, width, containerRef: setDocumentScrollElement, children: (0, import_jsx_runtime6.jsx)(VirtualizerScrollInstanceProvider, { scrollElement: documentScrollElement, containerElement, children: contents }) });
}
function getTone$2(_ref179) {
  let { readOnly, hasErrors, hasWarnings } = _ref179;
  if (readOnly) {
    return "transparent";
  }
  if (hasErrors) {
    return "critical";
  }
  return hasWarnings ? "caution" : "default";
}
var MENU_POPOVER_PROPS$8 = { portal: true, tone: "default" };
var INITIAL_VALUE_CARD_STYLE$1 = { position: "absolute", top: 0, left: 0, bottom: 0, right: 0, opacity: 0.6 };
var BUTTON_CARD_STYLE = { position: "relative" };
function PreviewItem(props2) {
  var _a4, _b4, _c4, _d4, _e3, _f3;
  const { schemaType, parentSchemaType, path: path2, readOnly, onRemove, value, open, onInsert, onFocus, onOpen, onClose, changed, focused, children, inputProps: { renderPreview } } = props2;
  const { t: t3 } = useTranslation2();
  const sortable = !readOnly && ((_a4 = parentSchemaType.options) == null ? void 0 : _a4.sortable) !== false;
  const insertableTypes = parentSchemaType.of;
  const previewCardRef = (0, import_react51.useRef)(null);
  useScrollIntoViewOnFocusWithin(previewCardRef, open);
  useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    if (!hadFocus && hasFocus && previewCardRef.current) {
      (_a22 = previewCardRef.current) == null ? void 0 : _a22.focus();
    }
  });
  const resolvingInitialValue = value._resolvingInitialValue;
  const handleDuplicate = (0, import_react51.useCallback)(() => {
    onInsert({ items: [{ ...value, _key: randomKey3() }], position: "after" });
  }, [onInsert, value]);
  const handleInsert = (0, import_react51.useCallback)((pos, insertType) => {
    onInsert({ items: [createProtoArrayValue(insertType)], position: pos });
  }, [onInsert]);
  const childPresence = useChildPresence(path2, true);
  const presence = (0, import_react51.useMemo)(() => {
    return childPresence.length === 0 ? null : (0, import_jsx_runtime6.jsx)(FieldPresence, { presence: childPresence, maxAvatars: 1 });
  }, [childPresence]);
  const childValidation = useChildValidation(path2, true);
  const validation2 = (0, import_react51.useMemo)(() => {
    return childValidation.length === 0 ? null : (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, paddingX: 1, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(FormFieldValidationStatus, { validation: childValidation, __unstable_showSummary: true }) });
  }, [childValidation]);
  const hasErrors = childValidation.some((v) => v.level === "error");
  const hasWarnings = childValidation.some((v) => v.level === "warning");
  const menu = (0, import_react51.useMemo)(() => readOnly ? null : (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(props2.inputId, "-menuButton"), menu: (0, import_jsx_runtime6.jsxs)(Menu, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.remove"), tone: "critical", icon: TrashIcon, onClick: onRemove }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.duplicate"), icon: CopyIcon, onClick: handleDuplicate }), (0, import_jsx_runtime6.jsx)(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })] }), popover: MENU_POPOVER_PROPS$8 }), [handleDuplicate, handleInsert, onRemove, insertableTypes, props2.inputId, readOnly, t3]);
  const tone = getTone$2({ readOnly, hasErrors, hasWarnings });
  const item = (0, import_jsx_runtime6.jsx)(RowLayout, { menu, presence, validation: validation2, tone, focused, dragHandle: sortable, selected: open, children: (0, import_jsx_runtime6.jsxs)(Card, { as: "button", type: "button", tone: "inherit", radius: 2, disabled: resolvingInitialValue, padding: 1, onClick: onOpen, ref: previewCardRef, onFocus, __unstable_focusRing: true, style: BUTTON_CARD_STYLE, children: [renderPreview({
    schemaType: props2.schemaType,
    value: props2.value,
    layout: "default",
    // Don't do visibility check for virtualized items as the calculation will be incorrect causing it to scroll
    skipVisibilityCheck: true
  }), resolvingInitialValue && (0, import_jsx_runtime6.jsx)(Card, { style: INITIAL_VALUE_CARD_STYLE$1, tone: "transparent", radius: 2, as: Flex, justify: "center", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "center", padding: 3, children: [(0, import_jsx_runtime6.jsx)(Box, { marginX: 3, children: (0, import_jsx_runtime6.jsx)(Spinner, { muted: true }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: t3("inputs.array.resolving-initial-value") })] }) })] }) });
  const itemTypeTitle = getSchemaTypeTitle(schemaType);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: Boolean(focused), children: (0, import_jsx_runtime6.jsx)(Box, { paddingX: 1, children: item }) }), open && (0, import_jsx_runtime6.jsx)(EditPortal, { header: readOnly ? t3("inputs.array.action.view", { itemTypeTitle }) : t3("inputs.array.action.edit", { itemTypeTitle }), type: ((_c4 = (_b4 = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _b4.modal) == null ? void 0 : _c4.type) || "dialog", width: (_f3 = (_e3 = (_d4 = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _d4.modal) == null ? void 0 : _e3.width) != null ? _f3 : 1, id: value._key, onClose, autofocus: focused, legacy_referenceElement: previewCardRef.current, children })] });
}
function defaultResolveItemComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.item)
    return schemaType.components.item;
  if (isReferenceSchemaType(schemaType)) {
    return ReferenceItem;
  }
  return PreviewItem;
}
function getTone$1(_ref180) {
  let { readOnly, hasErrors, hasWarnings } = _ref180;
  if (readOnly) {
    return "transparent";
  }
  if (hasErrors) {
    return "critical";
  }
  return hasWarnings ? "caution" : "default";
}
var MENU_POPOVER_PROPS$7 = { portal: true, tone: "default" };
function ReferenceField(props2) {
  var _a4, _b4, _c4, _d4, _e3, _f3;
  const elementRef = (0, import_react51.useRef)(null);
  const { schemaType, path: path2, open, inputId, children, inputProps } = props2;
  const { readOnly, focused, renderPreview, onChange } = props2.inputProps;
  const [fieldActionsNodes, setFieldActionNodes] = (0, import_react51.useState)([]);
  const documentId = usePublishedId();
  const handleClear = (0, import_react51.useCallback)(() => inputProps.onChange(unset2()), [inputProps]);
  const value = props2.value;
  const { EditReferenceLink, getReferenceInfo: getReferenceInfo2, selectedState, isCurrentDocumentLiveEdit } = useReferenceInput({ path: path2, schemaType, value });
  useScrollIntoViewOnFocusWithin(elementRef, open);
  useDidUpdate(focused, (hadFocus, hasFocus) => {
    if (!hadFocus && hasFocus && elementRef.current) {
      elementRef.current.focus();
    }
  });
  const hasErrors = props2.validation.some((v) => v.level === "error");
  const hasWarnings = props2.validation.some((v) => v.level === "warning");
  const loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2);
  const refTypeName = ((_a4 = loadableReferenceInfo.result) == null ? void 0 : _a4.type) || ((_b4 = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _b4.type);
  const refType = refTypeName ? schemaType.to.find((toType) => toType.name === refTypeName) : void 0;
  const pressed = selectedState === "pressed";
  const selected = selectedState === "selected";
  const hasRef = value == null ? void 0 : value._ref;
  const publishedReferenceExists = hasRef && ((_e3 = (_d4 = (_c4 = loadableReferenceInfo.result) == null ? void 0 : _c4.preview) == null ? void 0 : _d4.published) == null ? void 0 : _e3._id);
  const handleRemoveStrengthenOnPublish = (0, import_react51.useCallback)(() => {
    onChange([schemaType.weak === true ? set$2(true, ["_weak"]) : unset2(["_weak"]), unset2(["_strengthenOnPublish"])]);
  }, [onChange, schemaType.weak]);
  const handleFixStrengthMismatch = (0, import_react51.useCallback)(() => {
    onChange(schemaType.weak === true ? set$2(true, ["_weak"]) : unset2(["_weak"]));
  }, [onChange, schemaType]);
  const handleReplace = (0, import_react51.useCallback)(() => {
    inputProps.onPathFocus(["_ref"]);
  }, [inputProps]);
  const actualStrength = (value == null ? void 0 : value._weak) ? "weak" : "strong";
  const weakShouldBe = schemaType.weak === true ? "weak" : "strong";
  const weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && (value == null ? void 0 : value._strengthenOnPublish);
  const showWeakRefMismatch = !loadableReferenceInfo.isLoading && ((_f3 = loadableReferenceInfo.result) == null ? void 0 : _f3.availability.available) && hasRef && actualStrength !== weakShouldBe && !weakWarningOverride;
  const tone = getTone$1({ readOnly, hasErrors, hasWarnings });
  const isEditing = !(value == null ? void 0 : value._ref) || inputProps.focusPath[0] === "_ref";
  const { t: t3 } = useTranslation2();
  const footer = (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [isCurrentDocumentLiveEdit && publishedReferenceExists && value._strengthenOnPublish && (0, import_jsx_runtime6.jsx)(ReferenceFinalizeAlertStrip, { schemaType, handleRemoveStrengthenOnPublish }), showWeakRefMismatch && (0, import_jsx_runtime6.jsx)(ReferenceStrengthMismatchAlertStrip, { actualStrength, handleFixStrengthMismatch }), loadableReferenceInfo.error && (0, import_jsx_runtime6.jsx)(ReferenceMetadataLoadErrorAlertStrip, { errorMessage: loadableReferenceInfo.error.message, onHandleRetry: loadableReferenceInfo.retry })] });
  const OpenLink = (0, import_react51.useMemo)(() => (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (0, import_react51.forwardRef)(function OpenLink2(restProps, _ref) {
      return (0, import_jsx_runtime6.jsx)(IntentLink, { ...restProps, intent: "edit", params: { id: value == null ? void 0 : value._ref, type: refType == null ? void 0 : refType.name }, target: "_blank", rel: "noopener noreferrer", ref: _ref });
    })
  ), [refType == null ? void 0 : refType.name, value == null ? void 0 : value._ref]);
  const menu = (0, import_react51.useMemo)(() => readOnly ? null : (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { paddingY: 3, paddingX: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(inputId, "-menuButton"), menu: (0, import_jsx_runtime6.jsxs)(Menu, { children: [!readOnly && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.reference.action.clear"), tone: "critical", icon: TrashIcon, onClick: handleClear }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.reference.action.replace"), icon: SyncIcon, onClick: handleReplace })] }), !readOnly && (value == null ? void 0 : value._ref) && (0, import_jsx_runtime6.jsx)(MenuDivider, {}), (value == null ? void 0 : value._ref) && (0, import_jsx_runtime6.jsx)(MenuItem, { as: OpenLink, "data-as": "a", text: t3("inputs.reference.action.open-in-new-tab"), icon: LaunchIcon })] }), popover: MENU_POPOVER_PROPS$7 }) }), [handleClear, handleReplace, inputId, OpenLink, readOnly, t3, value == null ? void 0 : value._ref]);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [documentId && props2.actions && props2.actions.length > 0 && (0, import_jsx_runtime6.jsx)(FieldActionsResolver, { actions: props2.actions, documentId, documentType: schemaType.name, onActions: setFieldActionNodes, path: path2, schemaType }), (0, import_jsx_runtime6.jsx)(FieldActionsProvider, { actions: fieldActionsNodes, focused: Boolean(props2.inputProps.focused), path: path2, children: (0, import_jsx_runtime6.jsx)(FormField, { __internal_comments: props2.__internal_comments, __internal_slot: props2.__internal_slot, __unstable_headerActions: fieldActionsNodes, __unstable_presence: props2.presence, description: props2.description, level: props2.level, title: props2.title, validation: props2.validation, children: isEditing ? (0, import_jsx_runtime6.jsx)(Box, { children }) : (0, import_jsx_runtime6.jsx)(Card, { shadow: 1, radius: 1, padding: 1, tone, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 1, children: [(0, import_jsx_runtime6.jsxs)(Flex, { gap: 1, align: "center", children: [(0, import_jsx_runtime6.jsx)(ReferenceLinkCard, { __unstable_focusRing: true, as: EditReferenceLink, "data-pressed": pressed ? true : void 0, "data-selected": selected ? true : void 0, documentId: value == null ? void 0 : value._ref, documentType: refType == null ? void 0 : refType.name, flex: 1, paddingX: 2, paddingY: 1, pressed, radius: 2, ref: elementRef, selected, tone: "inherit", children: (0, import_jsx_runtime6.jsx)(PreviewReferenceValue$1, { value, referenceInfo: loadableReferenceInfo, renderPreview, type: schemaType }) }), (0, import_jsx_runtime6.jsx)(Box, { children: menu })] }), footer] }) }) }) })] });
}
function getOption(type, optionName) {
  return (0, import_get3.default)(type.options, optionName);
}
var PSEUDO_OBJECTS = ["array", "file", "image", "reference", "slug"];
var HIDDEN_FIELDS = ["asset", "crop", "hotspot", "_ref", "_weak"];
var NO_LEVEL_LAYOUTS = ["tags"];
var NO_LEVEL_TYPES = ["slug"];
function getTypeChain(type, visited) {
  if (!type)
    return [];
  if (visited.has(type))
    return [];
  visited.add(type);
  const next = type.type ? getTypeChain(type.type, visited) : [];
  return [type, ...next];
}
function getFieldLevel(schemaType, currentLevel) {
  return isArraySchemaType(schemaType) ? getArrayFieldLevel(schemaType, currentLevel) : getObjectFieldLevel(schemaType, currentLevel);
}
function getObjectFieldLevel(schemaType, currentLevel) {
  var _a4, _b4, _c4;
  const { type, options } = schemaType;
  const typeIfRelevant = asType(type, PSEUDO_OBJECTS);
  const fields = (schemaType == null ? void 0 : schemaType.jsonType) === "object" ? schemaType.fields : void 0;
  const typeName = (typeIfRelevant == null ? void 0 : typeIfRelevant.name) || "";
  if (NO_LEVEL_TYPES.includes(typeName)) {
    return 0;
  }
  const isPseudoObject = PSEUDO_OBJECTS.includes(typeName);
  const hasVisibleFields = ((_a4 = fields == null ? void 0 : fields.filter((f) => !HIDDEN_FIELDS.includes(f.name)).length) != null ? _a4 : 0) > 0;
  const hasListOptions2 = ((_c4 = (_b4 = options == null ? void 0 : options.list) == null ? void 0 : _b4.length) != null ? _c4 : 0) > 0;
  if (hasVisibleFields || hasListOptions2 || !isPseudoObject) {
    return currentLevel;
  }
  return 0;
}
function getArrayFieldLevel(schemaType, currentLevel) {
  var _a4;
  const { options } = schemaType;
  const hasListOptions2 = ((_a4 = (options == null ? void 0 : options.list) || []) == null ? void 0 : _a4.length) > 0;
  const isNoLevelLayout = NO_LEVEL_LAYOUTS.includes((options == null ? void 0 : options.layout) || "");
  if (hasListOptions2 && !isNoLevelLayout) {
    return currentLevel;
  }
  return 0;
}
function asType(schemaType, asOneOfTypes) {
  if ((schemaType == null ? void 0 : schemaType.name) && asOneOfTypes.includes(schemaType == null ? void 0 : schemaType.name)) {
    return schemaType;
  }
  if (!schemaType) {
    return void 0;
  }
  return asType(schemaType.type, asOneOfTypes);
}
var EMPTY_ARRAY$1 = [];
function BooleanField(field) {
  return (0, import_jsx_runtime6.jsx)(ChangeIndicator, { hasFocus: Boolean(field.inputProps.focused), isChanged: field.inputProps.changed, path: field.path, children: field.children });
}
function PrimitiveField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = (0, import_react51.useState)(EMPTY_ARRAY$1);
  const documentId = usePublishedId();
  const focused = Boolean(field.inputProps.focused);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [documentId && field.actions && field.actions.length > 0 && (0, import_jsx_runtime6.jsx)(FieldActionsResolver, { actions: field.actions, documentId, documentType: field.schemaType.name, onActions: setFieldActionNodes, path: field.path, schemaType: field.schemaType }), (0, import_jsx_runtime6.jsx)(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: (0, import_jsx_runtime6.jsx)(FormField, { __internal_slot: field.__internal_slot, __internal_comments: field.__internal_comments, __unstable_headerActions: fieldActionsNodes, __unstable_presence: field.presence, "data-testid": "field-".concat(field.inputId), description: field.description, inputId: field.inputId, level: field.level, title: field.title, validation: field.validation, children: (0, import_jsx_runtime6.jsx)(ChangeIndicator, { hasFocus: focused, isChanged: field.inputProps.changed, path: field.path, children: field.children }) }) })] });
}
function ObjectOrArrayField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = (0, import_react51.useState)(EMPTY_ARRAY$1);
  const documentId = usePublishedId();
  const focused = Boolean(field.inputProps.focused);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [documentId && field.actions && field.actions.length > 0 && (0, import_jsx_runtime6.jsx)(FieldActionsResolver, { actions: field.actions, documentId, documentType: field.schemaType.name, onActions: setFieldActionNodes, path: field.path, schemaType: field.schemaType }), (0, import_jsx_runtime6.jsx)(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: (0, import_jsx_runtime6.jsx)(FormFieldSet, { __internal_comments: field.__internal_comments, __internal_slot: field.__internal_slot, __unstable_headerActions: fieldActionsNodes, __unstable_presence: field.presence, collapsed: field.collapsed, collapsible: field.collapsible, "data-testid": "field-".concat(field.inputId), description: field.description, level: field.level, onCollapse: field.onCollapse, onExpand: field.onExpand, title: field.title, validation: field.validation, inputId: field.inputId, children: field.children }) })] });
}
function ImageOrFileField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = (0, import_react51.useState)(EMPTY_ARRAY$1);
  const documentId = usePublishedId();
  const focused = Boolean(field.inputProps.focused);
  const hotspotField = field.inputProps.members.find((member) => member.kind === "field" && member.name === "hotspot");
  const presence = (hotspotField == null ? void 0 : hotspotField.open) ? field.presence : field.presence.concat((hotspotField == null ? void 0 : hotspotField.field.presence) || EMPTY_ARRAY$1);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [documentId && field.actions && field.actions.length > 0 && (0, import_jsx_runtime6.jsx)(FieldActionsResolver, { actions: field.actions, documentId, documentType: field.schemaType.name, onActions: setFieldActionNodes, path: field.path, schemaType: field.schemaType }), (0, import_jsx_runtime6.jsx)(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: (0, import_jsx_runtime6.jsx)(FormFieldSet, { __internal_comments: field.__internal_comments, __internal_slot: field.__internal_slot, __unstable_headerActions: fieldActionsNodes, __unstable_presence: presence, collapsed: field.collapsed, collapsible: field.collapsible, description: field.description, level: field.level, onCollapse: field.onCollapse, onExpand: field.onExpand, title: field.title, validation: field.validation, inputId: field.inputId, children: field.children }) })] });
}
function defaultResolveFieldComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.field)
    return schemaType.components.field;
  if (isBooleanSchemaType(schemaType)) {
    return BooleanField;
  }
  const typeChain = getTypeChain(schemaType, /* @__PURE__ */ new Set());
  if (typeChain.some((t3) => t3.name === "image" || t3.name === "file")) {
    return ImageOrFileField;
  }
  if (typeChain.some((t3) => isCrossDatasetReferenceSchemaType(t3))) {
    return PrimitiveField;
  }
  if (typeChain.some((t3) => t3.name === "slug")) {
    return PrimitiveField;
  }
  if (typeChain.some((t3) => isReferenceSchemaType(t3))) {
    return ReferenceField;
  }
  if (schemaType.jsonType !== "object" && schemaType.jsonType !== "array") {
    return PrimitiveField;
  }
  return ObjectOrArrayField;
}
function createInsertCallback(options) {
  const { allowedDecorators, block, onChange } = options;
  let toInsert;
  return (givenBlock) => {
    toInsert = Array.isArray(givenBlock) ? givenBlock : [givenBlock];
    toInsert = toInsert.map((blk) => normalizeBlock(blk, { allowedDecorators }));
    const patches = [insert2(toInsert, "after", [{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
function createSetCallback(options) {
  const { allowedDecorators, block, onChange } = options;
  return (givenBlock) => {
    const patches = [set$2(normalizeBlock(givenBlock, { allowedDecorators }), [{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
function createUnsetCallback(options) {
  const { block, onChange } = options;
  return () => {
    const patches = [unset2([{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
var __freeze$1M = Object.freeze;
var __defProp$1M = Object.defineProperty;
var __template$1M = (cooked, raw) => __freeze$1M(__defProp$1M(cooked, "raw", { value: __freeze$1M(raw || cooked.slice()) }));
var _a$1M;
var Root$i2 = st.div(_a$1M || (_a$1M = __template$1M(["\n  display: flex;\n  pointer-events: all;\n"])));
function BlockActions(props2) {
  const editor2 = usePortableTextEditor();
  const { block, onChange, renderBlockActions } = props2;
  const decoratorValues = (0, import_react51.useMemo)(() => editor2.schemaTypes.decorators.map((d) => d.value), [editor2]);
  const blockActions = (0, import_react51.useMemo)(() => {
    if (renderBlockActions) {
      const blockActionProps = { block, value: PortableTextEditor.getValue(editor2), set: createSetCallback({ allowedDecorators: decoratorValues, block, onChange }), unset: createUnsetCallback({ block, onChange }), insert: createInsertCallback({ allowedDecorators: decoratorValues, block, onChange }) };
      return renderBlockActions(blockActionProps);
    }
    return void 0;
  }, [renderBlockActions, block, editor2, onChange, decoratorValues]);
  if (!blockActions)
    return null;
  return (0, import_jsx_runtime6.jsx)(Root$i2, { contentEditable: false, children: blockActions });
}
var __freeze$1L = Object.freeze;
var __defProp$1L = Object.defineProperty;
var __template$1L = (cooked, raw) => __freeze$1L(__defProp$1L(cooked, "raw", { value: __freeze$1L(raw || cooked.slice()) }));
var _a$1L;
var ReviewChangesHighlightBlock = st.div((_ref181) => {
  let { theme } = _ref181;
  const { radius, space, color: color3 } = theme.sanity;
  const bg = rgba2(color3.spot.yellow, 0.2);
  return nt(_a$1L || (_a$1L = __template$1L(["\n    position: absolute;\n    border-radius: ", "px;\n    top: -", "px;\n    bottom: -", "px;\n    left: ", "px;\n    right: 0;\n    background-color: ", ";\n  "])), radius[3], space[2], space[1] + space[1], space[4] + space[1], bg);
});
var __freeze$1K = Object.freeze;
var __defProp$1K = Object.defineProperty;
var __template$1K = (cooked, raw) => __freeze$1K(__defProp$1K(cooked, "raw", { value: __freeze$1K(raw || cooked.slice()) }));
var _a$1K;
var StyledChangeIndicatorWithProvidedFullPath = st(ChangeIndicator)(() => {
  return nt(_a$1K || (_a$1K = __template$1K(["\n    width: 1px;\n    height: 100%;\n\n    & > div {\n      height: 100%;\n    }\n  "])));
});
function isBlockType(type) {
  if (type.type) {
    return isBlockType(type.type);
  }
  return type.name === "block";
}
function isArrayOfObjectsFieldMember(member) {
  return member.kind === "field" && member.field.schemaType.jsonType === "array";
}
var NONEXISTENT_PATH = ["@@_NONEXISTENT_PATH_@@"];
function useMemberValidation(member) {
  const prev = (0, import_react51.useRef)(null);
  const memberValidation = (member == null ? void 0 : member.validation) && member.validation.length > 0 ? member.validation : EMPTY_ARRAY$b;
  const childValidation = useChildValidation((member == null ? void 0 : member.path) || NONEXISTENT_PATH);
  const validation2 = (0, import_react51.useMemo)(() => (member == null ? void 0 : member.schemaType) && isBlockType(member == null ? void 0 : member.schemaType) ? memberValidation : memberValidation.concat(childValidation), [childValidation, member, memberValidation]);
  const [hasError, hasWarning, hasInfo] = (0, import_react51.useMemo)(() => [validation2.filter((v) => v.level === "error").length > 0, validation2.filter((v) => v.level === "warning").length > 0, validation2.filter((v) => v.level === "info").length > 0], [validation2]);
  const reconciled = immutableReconcile(prev.current, validation2);
  prev.current = reconciled;
  return (0, import_react51.useMemo)(() => {
    return { validation: reconciled, hasError, hasWarning, hasInfo };
  }, [reconciled, hasError, hasWarning, hasInfo]);
}
var PortableTextMarkersContext = (0, import_react51.createContext)([]);
function PortableTextMarkersProvider(props2) {
  return (0, import_jsx_runtime6.jsx)(PortableTextMarkersContext.Provider, { value: props2.markers, children: props2.children });
}
function usePortableTextMarkers(path2) {
  const ctx = (0, import_react51.useContext)(PortableTextMarkersContext);
  if (!ctx) {
    throw new Error("Form context not provided");
  }
  const markers = (0, import_react51.useMemo)(() => ctx.filter((m2) => isEqual(m2.path, path2)), [ctx, path2]);
  return markers;
}
var PortableTextMemberItemsContext = (0, import_react51.createContext)([]);
function PortableTextMemberItemsProvider(props2) {
  return (0, import_jsx_runtime6.jsx)(PortableTextMemberItemsContext.Provider, { value: props2.memberItems, children: props2.children });
}
function usePortableTextMemberItem(key2) {
  const ctx = (0, import_react51.useContext)(PortableTextMemberItemsContext);
  if (!ctx) {
    throw new Error("Form context not provided");
  }
  return ctx.find((m2) => m2.key === key2);
}
function usePortableTextMemberItems() {
  const ctx = (0, import_react51.useContext)(PortableTextMemberItemsContext);
  if (!ctx) {
    throw new Error("Form context not provided");
  }
  return ctx;
}
function usePortableTextMemberItemsFromProps(props2) {
  const portableTextMemberItemsRef = (0, import_react51.useRef)([]);
  reconcilePortableTextMembers({ props: props2, ref: portableTextMemberItemsRef });
  return portableTextMemberItemsRef.current;
}
var reconcilePortableTextMembers = (_ref182) => {
  let { props: props2, ref } = _ref182;
  var _a4;
  const result = [];
  const { members, path: path2, schemaType, renderAnnotation, renderField, renderBlock, renderInput, renderItem, renderInlineBlock, renderPreview } = props2;
  for (const member of members) {
    if (member.kind === "item") {
      const isObjectBlock = !isBlockType(member.item.schemaType);
      if (isObjectBlock) {
        result.push({ kind: "objectBlock", member, node: member.item });
      } else {
        if (member.item.validation.length > 0 || member.item.changed || ((_a4 = member.item.presence) == null ? void 0 : _a4.length)) {
          result.push({ kind: "textBlock", member, node: member.item });
        }
        const childrenField = member.item.members.find((f) => f.kind === "field" && f.name === "children");
        if (childrenField && childrenField.kind === "field" && isMemberArrayOfObjects(childrenField)) {
          for (const child of childrenField.field.members) {
            if (child.kind === "item" && child.item.schemaType.name !== "span") {
              result.push({ kind: "inlineObject", member: child, node: child.item });
            }
          }
        }
        const markDefArrayMember = member.item.members.filter(isArrayOfObjectsFieldMember).find((f) => f.name === "markDefs");
        if (markDefArrayMember) {
          for (const child of markDefArrayMember.field.members) {
            if (child.kind === "item" && child.item.schemaType.jsonType === "object") {
              result.push({ kind: "annotation", member: child, node: child.item });
            }
          }
        }
      }
    }
  }
  const items = result.map((item) => {
    const key2 = pathToString2(item.node.path);
    const existingItem = ref.current.find((refItem) => refItem.key === key2);
    const isObject4 = item.kind !== "textBlock";
    let input = null;
    if (isObject4 && item.member !== (existingItem == null ? void 0 : existingItem.member) || item.node !== (existingItem == null ? void 0 : existingItem.node)) {
      const inputProps = { absolutePath: pathFor(item.node.path), includeField: false, members, path: pathFor(path2), renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType };
      input = (0, import_jsx_runtime6.jsx)(FormInput, { ...inputProps });
    }
    if (existingItem) {
      existingItem.member = item.member;
      existingItem.node = item.node;
      existingItem.input = input || existingItem.input;
      return existingItem;
    }
    return { kind: item.kind, key: key2, member: item.member, node: item.node, elementRef: (0, import_react51.createRef)(), input };
  });
  ref.current = items;
  return items;
};
function debugRender(style) {
  return void 0;
}
var __freeze$1J = Object.freeze;
var __defProp$1J = Object.defineProperty;
var __template$1J = (cooked, raw) => __freeze$1J(__defProp$1J(cooked, "raw", { value: __freeze$1J(raw || cooked.slice()) }));
var _a$1J;
var _b$P;
var _c$t;
var _d$i;
var _e$8;
var _f$6;
var _g$5;
var _h$3;
var _i$1;
var Root$h2 = st(Card)((props2) => {
  var _a22;
  const { color: color3, radius, space } = props2.theme.sanity;
  const overlay = nt(_a$1J || (_a$1J = __template$1J(["\n    pointer-events: none;\n    content: '';\n    position: absolute;\n    top: -", "px;\n    bottom: -", "px;\n    left: -", "px;\n    right: -", "px;\n    border-radius: ", "px;\n    mix-blend-mode: ", ";\n  "])), space[1], space[1], space[1], space[1], radius[2], color3.dark ? "screen" : "multiply");
  return nt(_b$P || (_b$P = __template$1J(["\n    box-shadow: 0 0 0 1px var(--card-border-color);\n    border-radius: ", "px;\n    pointer-events: all;\n    position: relative;\n\n    &[data-focused] {\n      box-shadow: 0 0 0 1px ", ";\n    }\n\n    &:not([data-focused]):not([data-selected]) {\n      @media (hover: hover) {\n        &:hover {\n          --card-border-color: ", ";\n        }\n      }\n    }\n\n    &[data-markers] {\n      &:after {\n        ", "\n        background-color: ", ";\n      }\n    }\n\n    &[data-warning] {\n      &:after {\n        ", "\n        background-color: ", ";\n      }\n\n      @media (hover: hover) {\n        &:hover {\n          --card-border-color: ", ";\n        }\n      }\n    }\n\n    &[data-invalid] {\n      &:after {\n        ", "\n        background-color: ", ";\n      }\n\n      @media (hover: hover) {\n        &:hover {\n          --card-border-color: ", ";\n        }\n      }\n    }\n  "])), radius[1], (_a22 = color3.selectable) == null ? void 0 : _a22.primary.selected.border, color3.input.default.hovered.border, overlay, color3.dark ? hues.purple[950].hex : hues.purple[50].hex, overlay, color3.muted.caution.hovered.bg, color3.muted.caution.hovered.border, overlay, color3.input.invalid.enabled.bg, color3.input.invalid.hovered.border);
});
var PreviewContainer = st(Box)(_c$t || (_c$t = __template$1J(["\n  display: block;\n  width: 100%;\n  user-select: none;\n  pointer-events: all;\n"])));
var ChangeIndicatorWrapper$1 = st.div((_ref183) => {
  let { theme, $hasChanges } = _ref183;
  const { space } = theme.sanity;
  return nt(_e$8 || (_e$8 = __template$1J(["\n      position: absolute;\n      width: ", "px;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      padding-left: ", "px;\n      user-select: none;\n\n      ", "\n\n      [data-dragged] & {\n        visibility: hidden;\n      }\n    "])), space[2], space[1], !$hasChanges && nt(_d$i || (_d$i = __template$1J(["\n        display: none;\n      "]))));
});
var InnerFlex = st(Flex)(_f$6 || (_f$6 = __template$1J(["\n  position: relative;\n\n  [data-dragged] > & {\n    opacity: 0.5;\n  }\n"])));
var BlockActionsOuter$1 = st(Box)(_g$5 || (_g$5 = __template$1J(["\n  width: 25px;\n  position: relative;\n\n  [data-dragged] & {\n    visibility: hidden;\n  }\n"])));
var BlockActionsInner$1 = st(Flex)(_h$3 || (_h$3 = __template$1J(["\n  position: absolute;\n  right: 0;\n  [data-dragged] & {\n    visibility: hidden;\n  }\n"])));
var TooltipBox$3 = st(Box)(_i$1 || (_i$1 = __template$1J(["\n  max-width: 250px;\n"])));
var POPOVER_PROPS$1 = { constrainSize: true, placement: "bottom", portal: "default", tone: "default" };
function BlockObjectActionsMenu(props2) {
  const { children, focused, isOpen, onOpen, onRemove, readOnly, value } = props2;
  const { t: t3 } = useTranslation2();
  const menuButtonId = (0, import_react51.useId)();
  const menuButton = (0, import_react51.useRef)(null);
  const isTabbing = (0, import_react51.useRef)(false);
  const referenceLink = (0, import_react51.useMemo)(() => isReference(value) ? (0, import_react51.forwardRef)(function ReferenceLink(linkProps, ref) {
    return (0, import_jsx_runtime6.jsx)(IntentLink, { ...linkProps, intent: "edit", params: { id: value._ref }, ref });
  }) : void 0, [value]);
  (0, import_react51.useEffect)(() => {
    if (isOpen) {
      isTabbing.current = false;
    }
  }, [isOpen]);
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (!focused) {
      return;
    }
    if (event.key === "Tab") {
      if (menuButton.current && !isTabbing.current && !isOpen) {
        event.preventDefault();
        event.stopPropagation();
        menuButton.current.focus();
        isTabbing.current = true;
      }
    }
  }, [focused, isOpen]));
  const handleDelete = (0, import_react51.useCallback)((event) => {
    event.preventDefault();
    event.stopPropagation();
    onRemove();
  }, [onRemove]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("inputs.portable-text.block.open-menu-aria-label"), fontSize: 1, iconRight: EllipsisVerticalIcon, mode: "bleed", paddingX: 2, tabIndex: focused ? 0 : 1 }), ref: menuButton, id: menuButtonId, menu: (0, import_jsx_runtime6.jsx)(Menu, { children: (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: ["_ref" in value && value._ref && (0, import_jsx_runtime6.jsx)(MenuItem, { as: referenceLink, "data-as": "a", icon: LinkIcon, text: t3("inputs.portable-text.block.open-reference") }), readOnly && (0, import_jsx_runtime6.jsx)(MenuItem, { icon: EyeOpenIcon, onClick: onOpen, text: t3("inputs.portable-text.block.view") }), !readOnly && (0, import_jsx_runtime6.jsx)(MenuItem, { icon: EditIcon, onClick: onOpen, text: t3("inputs.portable-text.block.edit") }), !readOnly && (0, import_jsx_runtime6.jsx)(MenuItem, { icon: TrashIcon, onClick: handleDelete, text: t3("inputs.portable-text.block.remove"), tone: "critical" })] }) }), popover: POPOVER_PROPS$1 }) })] });
}
var parseResponsiveWidth = (value) => {
  if (Array.isArray(value)) {
    return value.flatMap(parseResponsiveWidth);
  }
  if (typeof value === "number") {
    return [value];
  }
  return value === "auto" ? ["auto"] : [];
};
var parseModalType = (value) => {
  return value === "dialog" || value === "popover" ? value : void 0;
};
function _getModalOption(schemaType) {
  var _a4;
  const raw = (_a4 = schemaType.options) == null ? void 0 : _a4.modal;
  return typeof raw === "object" && raw !== null ? { type: parseModalType(raw.type), width: parseResponsiveWidth(raw.width) } : void 0;
}
function DefaultEditDialog(props2) {
  const { onClose, children, title, width = 1, autoFocus } = props2;
  const dialogId = (0, import_react51.useId)();
  const [contentElement, setContentElement] = (0, import_react51.useState)(null);
  const containerElement = (0, import_react51.useRef)(null);
  return (0, import_jsx_runtime6.jsx)(Dialog, { header: title, id: dialogId, onClickOutside: onClose, onClose, portal: "default", width, contentRef: setContentElement, "data-testid": "default-edit-object-dialog", __unstable_autoFocus: autoFocus, children: (0, import_jsx_runtime6.jsx)(PresenceOverlay, { margins: [0, 0, 1, 0], children: (0, import_jsx_runtime6.jsx)(VirtualizerScrollInstanceProvider, { scrollElement: contentElement, containerElement, children: (0, import_jsx_runtime6.jsx)(Box, { padding: 4, ref: containerElement, children }) }) }) });
}
var __freeze$1I = Object.freeze;
var __defProp$1I = Object.defineProperty;
var __template$1I = (cooked, raw) => __freeze$1I(__defProp$1I(cooked, "raw", { value: __freeze$1I(raw || cooked.slice()) }));
var _a$1I;
var _b$O;
var _c$s;
var RootPopover = st(Popover)(_a$1I || (_a$1I = __template$1I(["\n  &[data-popper-reference-hidden='true'] {\n    visibility: hidden;\n    pointer-events: none;\n  }\n\n  & > div {\n    overflow: hidden;\n    overflow: clip;\n  }\n"])));
var ContentScrollerBox = st(Box)(_b$O || (_b$O = __template$1I(["\n  /* Prevent overflow caused by change indicator */\n  overflow-x: hidden;\n  overflow-y: auto;\n"])));
var ContentHeaderBox = st(Box)(_c$s || (_c$s = __template$1I(["\n  box-shadow: 0 1px 0 var(--card-shadow-outline-color);\n  position: relative;\n  z-index: 10;\n  min-height: auto;\n"])));
var POPOVER_FALLBACK_PLACEMENTS$2 = ["top", "bottom"];
function PopoverEditDialog(props2) {
  const { floatingBoundary, referenceBoundary, referenceElement, width = 0 } = props2;
  const [open, setOpen] = (0, import_react51.useState)(false);
  (0, import_react51.useEffect)(() => {
    setOpen(true);
  }, []);
  return (0, import_jsx_runtime6.jsx)(RootPopover, { content: (0, import_jsx_runtime6.jsx)(Content, { ...props2 }), constrainSize: true, "data-ui": "PopoverEditDialog", fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2, floatingBoundary, open, overflow: "auto", placement: "bottom", portal: "default", preventOverflow: true, referenceBoundary, referenceElement, width });
}
function Content(props2) {
  const { onClose, referenceBoundary, referenceElement, title, autoFocus } = props2;
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (event.key === "Escape") {
      onClose();
    }
  }, [onClose]));
  useClickOutside(onClose, referenceElement ? [referenceElement] : [], referenceBoundary);
  const [contentElement, setContentElement] = (0, import_react51.useState)(null);
  const containerElement = (0, import_react51.useRef)(null);
  return (0, import_jsx_runtime6.jsx)(VirtualizerScrollInstanceProvider, { scrollElement: contentElement, containerElement, children: (0, import_jsx_runtime6.jsxs)(Flex, { ref: containerElement, direction: "column", height: "fill", children: [(0, import_jsx_runtime6.jsx)(ContentHeaderBox, { flex: "none", padding: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: title }) }), (0, import_jsx_runtime6.jsx)(Button, { autoFocus: Boolean(autoFocus), icon: CloseIcon, mode: "bleed", onClick: onClose, padding: 2 })] }) }), (0, import_jsx_runtime6.jsx)(ContentScrollerBox, { flex: 1, children: (0, import_jsx_runtime6.jsx)(PresenceOverlay, { margins: [0, 0, 1, 0], children: (0, import_jsx_runtime6.jsx)(Box, { padding: 3, ref: setContentElement, children: props2.children }) }) })] }) });
}
function ObjectEditModal(props2) {
  const { autoFocus, defaultType, floatingBoundary, onClose, referenceBoundary, referenceElement, schemaType } = props2;
  const { t: t3 } = useTranslation2();
  const schemaModalOption = (0, import_react51.useMemo)(() => _getModalOption(schemaType), [schemaType]);
  const modalType = (schemaModalOption == null ? void 0 : schemaModalOption.type) || defaultType;
  const schemaTypeTitle = schemaType.i18nTitleKey ? t3(schemaType.i18nTitleKey) : schemaType.title || schemaType.name;
  const modalTitle = t3("inputs.portable-text.annotation-editor.title", { schemaType: schemaTypeTitle });
  const handleClose = (0, import_react51.useCallback)(() => {
    onClose();
  }, [onClose]);
  const modalWidth = schemaModalOption == null ? void 0 : schemaModalOption.width;
  if (modalType === "popover") {
    return (0, import_jsx_runtime6.jsx)(PopoverEditDialog, { autoFocus, floatingBoundary, onClose: handleClose, referenceBoundary, referenceElement, title: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: modalTitle }), width: modalWidth, children: props2.children });
  }
  return (0, import_jsx_runtime6.jsx)(DefaultEditDialog, { onClose: handleClose, title: modalTitle, width: modalWidth, autoFocus, children: props2.children });
}
function BlockObject(props2) {
  var _a4;
  const { floatingBoundary, focused, isFullscreen, onItemClose, onItemOpen, onPathFocus, path: path2, readOnly, referenceBoundary, relativePath, renderAnnotation, renderBlock, renderBlockActions, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, value } = props2;
  const { onChange } = useFormCallbacks();
  const { Markers } = useFormBuilder().__internal.components;
  const [reviewChangesHovered, setReviewChangesHovered] = (0, import_react51.useState)(false);
  const markers = usePortableTextMarkers(path2);
  const editor2 = usePortableTextEditor();
  const memberItem = usePortableTextMemberItem(pathToString2(path2));
  const isDeleting = (0, import_react51.useRef)(false);
  const selfSelection = (0, import_react51.useMemo)(() => ({ anchor: { path: relativePath, offset: 0 }, focus: { path: relativePath, offset: 0 } }), [relativePath]);
  const handleMouseOver = (0, import_react51.useCallback)(() => setReviewChangesHovered(true), []);
  const handleMouseOut = (0, import_react51.useCallback)(() => setReviewChangesHovered(false), []);
  const onOpen = (0, import_react51.useCallback)(() => {
    if (memberItem) {
      PortableTextEditor.blur(editor2);
      onItemOpen(memberItem.node.path);
    }
  }, [editor2, memberItem, onItemOpen]);
  const onClose = (0, import_react51.useCallback)(() => {
    onItemClose();
    PortableTextEditor.select(editor2, selfSelection);
    PortableTextEditor.focus(editor2);
  }, [onItemClose, editor2, selfSelection]);
  const onRemove = (0, import_react51.useCallback)(() => {
    if (isDeleting.current) {
      return;
    }
    try {
      PortableTextEditor.delete(editor2, selfSelection, { mode: "blocks" });
    } catch (err) {
      console.error(err);
    } finally {
      isDeleting.current = true;
    }
  }, [editor2, selfSelection]);
  (0, import_react51.useEffect)(() => () => {
    if (isDeleting.current) {
      PortableTextEditor.focus(editor2);
    }
  }, [editor2]);
  const innerPaddingProps = (0, import_react51.useMemo)(() => {
    if (isFullscreen && !renderBlockActions) {
      return { paddingX: 5 };
    }
    if (isFullscreen && renderBlockActions) {
      return { paddingLeft: 5, paddingRight: 2 };
    }
    if (renderBlockActions) {
      return { paddingLeft: 3, paddingRight: 2 };
    }
    return { paddingX: 3 };
  }, [isFullscreen, renderBlockActions]);
  const { validation: validation2, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem == null ? void 0 : memberItem.node);
  const parentSchemaType = editor2.schemaTypes.portableText;
  const hasMarkers = Boolean(markers.length > 0);
  const presence = useChildPresence(path2, true);
  const rootPresence = (0, import_react51.useMemo)(() => presence.filter((p) => isEqual(p.path, path2)), [path2, presence]);
  const tooltipEnabled = hasError || hasWarning || hasInfo || hasMarkers;
  const toolTipContent = (0, import_react51.useMemo)(() => tooltipEnabled && (0, import_jsx_runtime6.jsx)(TooltipBox$3, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Markers, { markers, validation: validation2, renderCustomMarkers }) }) || null, [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]);
  const isOpen = Boolean(memberItem == null ? void 0 : memberItem.member.open);
  const input = memberItem == null ? void 0 : memberItem.input;
  const nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b;
  const referenceElement = (_a4 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a4.current;
  const componentProps = (0, import_react51.useMemo)(() => ({ __unstable_floatingBoundary: floatingBoundary, __unstable_referenceBoundary: referenceBoundary, __unstable_referenceElement: referenceElement || null, children: input, focused, markers, onClose, onOpen, onPathFocus, onRemove, open: isOpen, parentSchemaType, path: nodePath, presence: rootPresence, readOnly: Boolean(readOnly), renderAnnotation, renderBlock, renderDefault: DefaultBlockObjectComponent, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, validation: validation2, value }), [floatingBoundary, referenceElement, input, focused, markers, onClose, onOpen, onPathFocus, onRemove, isOpen, parentSchemaType, nodePath, rootPresence, readOnly, referenceBoundary, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, validation2, value]);
  return (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(Box, { ref: memberItem == null ? void 0 : memberItem.elementRef, contentEditable: false, children: (0, import_jsx_runtime6.jsx)(Flex, { paddingBottom: 1, marginY: 3, style: debugRender(), children: (0, import_jsx_runtime6.jsxs)(InnerFlex, { flex: 1, children: [(0, import_jsx_runtime6.jsx)(Tooltip, { placement: "top", portal: "editor", disabled: !tooltipEnabled, content: toolTipContent, children: (0, import_jsx_runtime6.jsx)(PreviewContainer, { ...innerPaddingProps, children: renderBlock && renderBlock(componentProps) }) }), (0, import_jsx_runtime6.jsx)(BlockActionsOuter$1, { marginRight: 1, children: (0, import_jsx_runtime6.jsx)(BlockActionsInner$1, { children: renderBlockActions && value && focused && !readOnly && (0, import_jsx_runtime6.jsx)(BlockActions, { block: value, onChange, renderBlockActions }) }) }), isFullscreen && memberItem && (0, import_jsx_runtime6.jsx)(ChangeIndicatorWrapper$1, { $hasChanges: memberItem.member.item.changed, onMouseOut: handleMouseOut, onMouseOver: handleMouseOver, children: (0, import_jsx_runtime6.jsx)(StyledChangeIndicatorWithProvidedFullPath, { hasFocus: focused, isChanged: memberItem.member.item.changed, path: memberItem.member.item.path, withHoverEffect: false }) }), reviewChangesHovered && (0, import_jsx_runtime6.jsx)(ReviewChangesHighlightBlock, {})] }) }) }), [componentProps, focused, handleMouseOut, handleMouseOver, innerPaddingProps, isFullscreen, memberItem, onChange, readOnly, renderBlock, renderBlockActions, reviewChangesHovered, toolTipContent, tooltipEnabled, value]);
}
var DefaultBlockObjectComponent = (props2) => {
  const { __unstable_floatingBoundary, __unstable_referenceBoundary, __unstable_referenceElement, children, focused, markers, onClose, onOpen, onRemove, open, readOnly, renderPreview, schemaType, selected, value, validation: validation2 } = props2;
  const isImagePreview = isImage(value);
  const hasError = validation2.filter((v) => v.level === "error").length > 0;
  const hasWarning = validation2.filter((v) => v.level === "warning").length > 0;
  const hasMarkers = Boolean(markers.length > 0);
  const tone = selected || focused ? "primary" : "default";
  const handleDoubleClickToOpen = (0, import_react51.useCallback)((e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    onOpen();
  }, [onOpen]);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Root$h2, { "data-focused": focused ? "" : void 0, "data-image-preview": isImagePreview ? "" : void 0, "data-invalid": hasError ? "" : void 0, "data-markers": hasMarkers ? "" : void 0, "data-read-only": readOnly ? "" : void 0, "data-selected": selected ? "" : void 0, "data-testid": "pte-block-object", "data-warning": hasWarning ? "" : void 0, flex: 1, onDoubleClick: handleDoubleClickToOpen, padding: isImagePreview ? 0 : 1, tone, children: renderPreview({ actions: (0, import_jsx_runtime6.jsx)(BlockObjectActionsMenu, { isOpen: open, focused, onOpen, onRemove, readOnly, value }), layout: isImagePreview ? "blockImage" : "block", schemaType, skipVisibilityCheck: true, value }) }), open && (0, import_jsx_runtime6.jsx)(ObjectEditModal, { floatingBoundary: __unstable_floatingBoundary, defaultType: "dialog", onClose, autoFocus: focused, schemaType, referenceBoundary: __unstable_referenceBoundary, referenceElement: __unstable_referenceElement, children })] });
};
var TEXT_LEVELS = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var TEXT_BULLET_MARKERS = ["", "", ""];
var TEXT_NUMBER_FORMATS = ["number", "lower-alpha", "lower-roman"];
var TEXT_DECORATOR_TAGS = { em: "em", "strike-through": "s", underline: "u", strong: "strong", code: "code" };
var TEXT_STYLE_PADDING = { h1: { paddingTop: 5, paddingBottom: 4 }, h2: { paddingTop: 4, paddingBottom: 4 }, h3: { paddingTop: 4, paddingBottom: 3 }, h4: { paddingTop: 4, paddingBottom: 3 }, h5: { paddingTop: 4, paddingBottom: 3 }, h6: { paddingTop: 4, paddingBottom: 2 }, normal: { paddingTop: 2, paddingBottom: 3 }, blockquote: { paddingTop: 2, paddingBottom: 3 } };
function createListName(level) {
  return "list-level-".concat(level);
}
var __freeze$1H = Object.freeze;
var __defProp$1H = Object.defineProperty;
var __template$1H = (cooked, raw) => __freeze$1H(__defProp$1H(cooked, "raw", { value: __freeze$1H(raw || cooked.slice()) }));
var _a$1H;
var _b$N;
var _c$r;
var _d$h;
var _e$7;
var _f$5;
var _g$4;
var _h$2;
var _i;
var _j;
function textBlockStyle(props2) {
  var _a22;
  const { $level, theme } = props2;
  const { color: color3, fonts: fonts2, radius, space } = theme.sanity;
  const numberMarker = TEXT_NUMBER_FORMATS[($level - 1) % TEXT_NUMBER_FORMATS.length];
  const bulletMarker = TEXT_BULLET_MARKERS[($level - 1) % TEXT_BULLET_MARKERS.length];
  return nt(_a$1H || (_a$1H = __template$1H(["\n    --marker-bg-color: transparent;\n\n    mix-blend-mode: ", ";\n    position: relative;\n\n    & > [data-ui='TextBlock_inner'] {\n      position: relative;\n      flex: 1;\n    }\n\n    & > div:before {\n      content: '';\n      position: absolute;\n      top: -", "px;\n      bottom: -", "px;\n      left: -", "px;\n      right: -", "px;\n      border-radius: ", "px;\n      background-color: var(--marker-bg-color);\n      // This is to make sure the marker is always behind the text\n      z-index: -1;\n    }\n\n    &[data-markers] {\n      --marker-bg-color: ", ";\n    }\n\n    &[data-warning] {\n      --card-border-color: ", ";\n      --marker-bg-color: ", ";\n    }\n\n    &[data-error] {\n      --card-border-color: ", ";\n      --marker-bg-color: ", ";\n    }\n\n    & [data-list-prefix] {\n      position: absolute;\n      margin-left: -4.5rem;\n      width: 3.75rem;\n      text-align: right;\n      box-sizing: border-box;\n    }\n\n    &[data-list-item='number'] [data-list-prefix] {\n      font-variant-numeric: tabular-nums;\n\n      & > span:before {\n        content: counter(", ") '.';\n        content: counter(", ", ", ") '.';\n      }\n    }\n\n    &[data-list-item='bullet'] [data-list-prefix] {\n      & > span {\n        position: relative;\n        top: -0.1875em;\n\n        &:before {\n          content: '", "';\n          font-size: 0.46666em;\n        }\n      }\n    }\n\n    & [data-text] {\n      overflow-wrap: anywhere;\n      text-transform: none;\n      white-space: pre-wrap;\n      font-family: ", ";\n      flex: 1;\n\n      *::selection {\n        background-color: ", ";\n      }\n    }\n  "])), color3.dark ? "screen" : "multiply", space[1], space[1], space[1], space[1], radius[2], color3.dark ? hues.purple[950].hex : hues.purple[50].hex, color3.muted.caution.enabled.border, color3.muted.caution.hovered.bg, color3.muted.critical.enabled.border, color3.muted.critical.hovered.bg, createListName($level), createListName($level), numberMarker, bulletMarker, fonts2.text.family, (_a22 = color3.selectable) == null ? void 0 : _a22.primary.pressed.bg);
}
var TextRoot = st.div(textBlockStyle);
var TextBlockFlexWrapper = st(Box)(_b$N || (_b$N = __template$1H(["\n  position: relative;\n  display: flex;\n"])));
var ListPrefixWrapper = st.div(_c$r || (_c$r = __template$1H(["\n  user-select: none;\n  white-space: nowrap;\n"])));
var BlockExtrasContainer = st(Box)(_d$h || (_d$h = __template$1H(["\n  user-select: none;\n"])));
var BlockActionsOuter = st(Box)(_e$7 || (_e$7 = __template$1H(["\n  line-height: 0;\n  width: 25px;\n  position: relative;\n"])));
var BlockActionsInner = st(Flex)((_ref184) => {
  let { theme } = _ref184;
  const { fonts: fonts2, space } = theme.sanity;
  const textSize1 = fonts2.text.sizes[1];
  const textSize2 = fonts2.text.sizes[2];
  const capHeight1 = textSize1.lineHeight - textSize1.ascenderHeight - textSize1.descenderHeight;
  const capHeight2 = textSize2.lineHeight - textSize2.ascenderHeight - textSize2.descenderHeight;
  const buttonHeight = capHeight1 + space[2] + space[2];
  const negativeTop = 0 - (buttonHeight - capHeight2) / 2;
  return nt(_f$5 || (_f$5 = __template$1H(["\n    user-select: none;\n    position: absolute;\n    right: 0;\n    top: ", "px;\n  "])), negativeTop);
});
var TooltipBox$2 = st(Box)(_g$4 || (_g$4 = __template$1H(["\n  max-width: 250px;\n"])));
var TextFlex = st(Flex)(_h$2 || (_h$2 = __template$1H(["\n  position: relative;\n  padding-left: ", "px;\n"])), (_ref185) => {
  let { $level } = _ref185;
  return $level ? $level * 32 : 0;
});
var ChangeIndicatorWrapper = st.div((_ref186) => {
  let { theme, $hasChanges } = _ref186;
  const { space } = theme.sanity;
  return nt(_j || (_j = __template$1H(["\n      position: absolute;\n      width: ", "px;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      padding-left: ", "px;\n      user-select: none;\n\n      ", "\n    "])), space[2], space[1], !$hasChanges && nt(_i || (_i = __template$1H(["\n        display: none;\n      "]))));
});
var __freeze$1G = Object.freeze;
var __defProp$1G = Object.defineProperty;
var __template$1G = (cooked, raw) => __freeze$1G(__defProp$1G(cooked, "raw", { value: __freeze$1G(raw || cooked.slice()) }));
var _a$1G;
var _b$M;
var TextContainer = st.div(_a$1G || (_a$1G = __template$1G(["\n  display: block;\n"])));
var Normal = (_ref187) => {
  let { children, ...rest } = _ref187;
  return (0, import_jsx_runtime6.jsx)(Text3, { "data-testid": "text-style--normal", ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var Heading1 = (_ref188) => {
  let { children, ...rest } = _ref188;
  return (0, import_jsx_runtime6.jsx)(Heading, { as: "h1", "data-testid": "text-style--h1", size: 5, ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var Heading22 = (_ref189) => {
  let { children, ...rest } = _ref189;
  return (0, import_jsx_runtime6.jsx)(Heading, { as: "h2", "data-testid": "text-style--h2", size: 4, ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var Heading3 = (_ref190) => {
  let { children, ...rest } = _ref190;
  return (0, import_jsx_runtime6.jsx)(Heading, { as: "h3", "data-testid": "text-style--h3", size: 3, ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var Heading4 = (_ref191) => {
  let { children, ...rest } = _ref191;
  return (0, import_jsx_runtime6.jsx)(Heading, { as: "h4", "data-testid": "text-style--h4", size: 2, ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var Heading5 = (_ref192) => {
  let { children, ...rest } = _ref192;
  return (0, import_jsx_runtime6.jsx)(Heading, { as: "h5", "data-testid": "text-style--h5", size: 1, ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var Heading6 = (_ref193) => {
  let { children, ...rest } = _ref193;
  return (0, import_jsx_runtime6.jsx)(Heading, { as: "h6", "data-testid": "text-style--h6", size: 0, ...rest, children: (0, import_jsx_runtime6.jsx)(TextContainer, { children }) });
};
var BlockQuoteRoot = st.blockquote(_b$M || (_b$M = __template$1G(["\n  position: relative;\n  display: block;\n  margin: 0;\n  padding-left: ", "px;\n\n  &::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: -4px;\n    bottom: -4px;\n    width: 3px;\n    background: var(--card-border-color);\n  }\n"])), (_ref194) => {
  let { theme } = _ref194;
  return theme.sanity.space[3];
});
var BlockQuote = (_ref195) => {
  let { children, ...rest } = _ref195;
  return (0, import_jsx_runtime6.jsx)(BlockQuoteRoot, { "data-testid": "text-style--blockquote", ...rest, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", children }) });
};
var TEXT_STYLES = { normal: Normal, h1: Heading1, h2: Heading22, h3: Heading3, h4: Heading4, h5: Heading5, h6: Heading6, blockquote: BlockQuote };
function TextBlock(props2) {
  const { children, floatingBoundary, focused, isFullscreen, onItemClose, onItemOpen, onPathFocus, path: path2, readOnly, referenceBoundary, renderBlock, renderAnnotation, renderBlockActions, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, spellCheck, value } = props2;
  const { Markers } = useFormBuilder().__internal.components;
  const [reviewChangesHovered, setReviewChangesHovered] = (0, import_react51.useState)(false);
  const markers = usePortableTextMarkers(path2);
  const memberItem = usePortableTextMemberItem(pathToString2(path2));
  const editor2 = usePortableTextEditor();
  const { onChange } = useFormCallbacks();
  const presence = useChildPresence(path2, true);
  const textPresence = (0, import_react51.useMemo)(() => {
    return presence.filter((p) => isEqual(p.path, path2) || p.path.slice(-3)[1] === "children" && p.path.length - path2.length === 2);
  }, [path2, presence]);
  const handleChangeIndicatorMouseEnter = (0, import_react51.useCallback)(() => setReviewChangesHovered(true), []);
  const handleChangeIndicatorMouseLeave = (0, import_react51.useCallback)(() => setReviewChangesHovered(false), []);
  const { validation: validation2, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem == null ? void 0 : memberItem.node);
  const hasMarkers = Boolean(renderCustomMarkers) && markers.length > 0;
  const tooltipEnabled = hasError || hasWarning || hasMarkers || hasInfo;
  const onOpen = (0, import_react51.useCallback)(() => {
    if (memberItem) {
      onItemOpen(memberItem.node.path);
    }
  }, [onItemOpen, memberItem]);
  const onRemove = (0, import_react51.useCallback)(() => {
    const point = { path: path2.slice(-1), offset: 0 };
    const sel = { focus: point, anchor: point };
    PortableTextEditor.delete(editor2, sel, { mode: "blocks" });
    PortableTextEditor.focus(editor2);
  }, [path2, editor2]);
  const text = (0, import_react51.useMemo)(() => {
    return (0, import_jsx_runtime6.jsxs)(TextFlex, { align: "flex-start", $level: value == null ? void 0 : value.level, children: [value.listItem && (0, import_jsx_runtime6.jsx)(ListPrefixWrapper, { contentEditable: false, children: (0, import_jsx_runtime6.jsx)(Text3, { "data-list-prefix": "", children: (0, import_jsx_runtime6.jsx)(TextContainer, {}) }) }), (0, import_jsx_runtime6.jsx)("div", { "data-text": "", style: debugRender(), children })] });
  }, [value.listItem, value.level, children]);
  const innerPaddingProps = (0, import_react51.useMemo)(() => {
    if (isFullscreen && !renderBlockActions) {
      return { paddingX: 5 };
    }
    if (isFullscreen && renderBlockActions) {
      return { paddingLeft: 5, paddingRight: 2 };
    }
    if (renderBlockActions) {
      return { paddingLeft: 3, paddingRight: 2 };
    }
    return { paddingX: 3 };
  }, [isFullscreen, renderBlockActions]);
  const outerPaddingProps = (0, import_react51.useMemo)(() => {
    if (value.listItem) {
      return { paddingY: 2 };
    }
    return TEXT_STYLE_PADDING[value.style || "normal"] || { paddingY: 2 };
  }, [value]);
  const isOpen = Boolean(memberItem == null ? void 0 : memberItem.member.open);
  const parentSchemaType = editor2.schemaTypes.portableText;
  const componentProps = (0, import_react51.useMemo)(() => {
    var _a4;
    return { __unstable_floatingBoundary: floatingBoundary, __unstable_referenceBoundary: referenceBoundary, __unstable_referenceElement: ((_a4 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a4.current) || null, children: text, focused, markers, onClose: onItemClose, onOpen, onPathFocus, onRemove, open: isOpen, parentSchemaType, path: (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b, presence: textPresence, readOnly: Boolean(readOnly), renderAnnotation, renderBlock, renderDefault: DefaultComponent$1, renderField, renderInput, renderInlineBlock, renderItem, renderPreview, schemaType, selected, validation: validation2, value };
  }, [floatingBoundary, focused, isOpen, markers, memberItem == null ? void 0 : memberItem.elementRef, memberItem == null ? void 0 : memberItem.node.path, onItemClose, onOpen, onPathFocus, onRemove, parentSchemaType, readOnly, referenceBoundary, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, text, textPresence, validation2, value]);
  const toolTipContent = (0, import_react51.useMemo)(() => tooltipEnabled && (0, import_jsx_runtime6.jsx)(TooltipBox$2, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Markers, { markers, renderCustomMarkers, validation: validation2 }) }) || null, [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]);
  return (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(Box, { "data-testid": "text-block", ...outerPaddingProps, style: debugRender(), ref: memberItem == null ? void 0 : memberItem.elementRef, children: (0, import_jsx_runtime6.jsx)(TextBlockFlexWrapper, { "data-testid": "text-block__wrapper", children: (0, import_jsx_runtime6.jsxs)(Flex, { flex: 1, ...innerPaddingProps, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Tooltip, { content: toolTipContent, disabled: !tooltipEnabled, placement: "top", portal: "editor", children: (0, import_jsx_runtime6.jsx)(TextRoot, { $level: value.level || 1, "data-error": hasError ? "" : void 0, "data-list-item": value.listItem, "data-markers": hasMarkers ? "" : void 0, "data-read-only": readOnly, "data-testid": "text-block__text", "data-warning": hasWarning ? "" : void 0, spellCheck, children: renderBlock && renderBlock(componentProps) }) }) }), (0, import_jsx_runtime6.jsxs)(BlockExtrasContainer, { contentEditable: false, children: [(0, import_jsx_runtime6.jsx)(BlockActionsOuter, { marginRight: 1, children: (0, import_jsx_runtime6.jsx)(BlockActionsInner, { children: renderBlockActions && focused && !readOnly && (0, import_jsx_runtime6.jsx)(BlockActions, { onChange, block: value, renderBlockActions }) }) }), isFullscreen && memberItem && (0, import_jsx_runtime6.jsx)(ChangeIndicatorWrapper, { $hasChanges: memberItem.member.item.changed, onMouseEnter: handleChangeIndicatorMouseEnter, onMouseLeave: handleChangeIndicatorMouseLeave, children: (0, import_jsx_runtime6.jsx)(StyledChangeIndicatorWithProvidedFullPath, { hasFocus: focused, isChanged: memberItem.member.item.changed, path: memberItem.member.item.path, withHoverEffect: false }) })] }), reviewChangesHovered && (0, import_jsx_runtime6.jsx)(ReviewChangesHighlightBlock, {})] }) }) }), [componentProps, focused, handleChangeIndicatorMouseEnter, handleChangeIndicatorMouseLeave, hasError, hasMarkers, hasWarning, innerPaddingProps, isFullscreen, memberItem, onChange, outerPaddingProps, readOnly, renderBlock, renderBlockActions, reviewChangesHovered, spellCheck, toolTipContent, tooltipEnabled, value]);
}
var DefaultComponent$1 = (props2) => {
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: props2.children });
};
var __freeze$1F = Object.freeze;
var __defProp$1F = Object.defineProperty;
var __template$1F = (cooked, raw) => __freeze$1F(__defProp$1F(cooked, "raw", { value: __freeze$1F(raw || cooked.slice()) }));
var _a$1F;
var ToolbarPopover$1 = st(Popover)(_a$1F || (_a$1F = __template$1F(["\n  &[data-popper-reference-hidden='true'] {\n    display: none !important;\n  }\n"])));
var POPOVER_FALLBACK_PLACEMENTS$1 = ["top", "bottom"];
function InlineObjectToolbarPopover(props2) {
  const { floatingBoundary, onClosePopover, onEdit, onDelete, referenceBoundary, referenceElement, title, open } = props2;
  const { sanity: sanity2 } = useTheme();
  const { t: t3 } = useTranslation2();
  const editButtonRef = (0, import_react51.useRef)(null);
  const deleteButtonRef = (0, import_react51.useRef)(null);
  const popoverScheme = sanity2.color.dark ? "light" : "dark";
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClosePopover();
    }
  }, [onClosePopover]));
  const handleDelete = (0, import_react51.useCallback)((event) => {
    var _a22;
    if ((_a22 = deleteButtonRef.current) == null ? void 0 : _a22.disabled) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    try {
      onDelete(event);
    } catch (err) {
      console.error(err);
    } finally {
      if (deleteButtonRef.current) {
        deleteButtonRef.current.disabled = true;
      }
    }
  }, [onDelete]);
  const popoverContent = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime6.jsxs)(Inline, { space: 1, children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", size: 1, children: title }) }), (0, import_jsx_runtime6.jsx)(Button, { icon: EditIcon, mode: "bleed", onClick: onEdit, padding: 2, ref: editButtonRef, alt: t3("inputs.portable-text.inline-object.edit") }), (0, import_jsx_runtime6.jsx)(Button, { ref: deleteButtonRef, icon: TrashIcon, mode: "bleed", padding: 2, onClick: handleDelete, tone: "critical", alt: t3("inputs.portable-text.inline-object.remove") })] }) }), [handleDelete, onEdit, title, t3]);
  return (0, import_jsx_runtime6.jsx)(ToolbarPopover$1, { constrainSize: true, content: popoverContent, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1, floatingBoundary, open, placement: "top", portal: true, referenceBoundary, referenceElement, scheme: popoverScheme });
}
var __freeze$1E = Object.freeze;
var __defProp$1E = Object.defineProperty;
var __template$1E = (cooked, raw) => __freeze$1E(__defProp$1E(cooked, "raw", { value: __freeze$1E(raw || cooked.slice()) }));
var _a$1E;
var _b$L;
var _c$q;
var Root$g2 = st(Card)(rootStyle2);
var PreviewSpan = st.span(_a$1E || (_a$1E = __template$1E(["\n  display: block;\n  max-width: calc(5em + 80px);\n  position: relative;\n"])));
var TooltipBox$1 = st(Box)(_b$L || (_b$L = __template$1E(["\n  max-width: 250px;\n"])));
function rootStyle2(_ref196) {
  let { theme } = _ref196;
  var _a22, _b22, _c22;
  const { color: color3, radius } = theme.sanity;
  return nt(_c$q || (_c$q = __template$1E(["\n    line-height: 0;\n    border-radius: ", "px;\n    padding: 2px;\n    box-shadow: inset 0 0 0 1px var(--card-border-color);\n    height: calc(1em - 1px);\n    margin-top: 0.0625em;\n    cursor: default;\n\n    &:not([hidden]) {\n      display: inline-flex;\n      align-items: center;\n      vertical-align: top;\n    }\n\n    &[data-ready-only] {\n      cursor: default;\n    }\n\n    &[data-focused] {\n      box-shadow: inset 0 0 0 1px ", ";\n      color: ", ";\n    }\n\n    &[data-selected] {\n      background-color: ", ";\n    }\n\n    &:not([data-focused]):not([data-selected]) {\n      @media (hover: hover) {\n        &:hover {\n          --card-border-color: ", ";\n        }\n      }\n    }\n\n    &[data-markers] {\n      --card-bg-color: ", ";\n    }\n\n    &[data-warning] {\n      --card-bg-color: ", ";\n\n      @media (hover: hover) {\n        &:hover {\n          --card-border-color: ", ";\n        }\n      }\n    }\n\n    &[data-invalid] {\n      --card-bg-color: ", ";\n      --card-border-color: ", ";\n\n      @media (hover: hover) {\n        &:hover {\n          --card-border-color: ", ";\n        }\n      }\n    }\n  "])), radius[2], (_a22 = color3.selectable) == null ? void 0 : _a22.primary.selected.border, (_b22 = color3.selectable) == null ? void 0 : _b22.primary.pressed.fg, (_c22 = color3.selectable) == null ? void 0 : _c22.primary.pressed.bg, color3.input.default.hovered.border, color3.dark ? hues.purple[950].hex : hues.purple[50].hex, color3.muted.caution.hovered.bg, color3.muted.caution.hovered.border, color3.input.invalid.enabled.bg, color3.input.invalid.enabled.border, color3.input.invalid.hovered.border);
}
var InlineObject = (props2) => {
  var _a4;
  const { floatingBoundary, focused, onItemClose, onItemOpen, onPathFocus, path: path2, readOnly, referenceBoundary, relativePath, renderAnnotation, renderBlock, renderCustomMarkers, renderField, renderItem, renderInlineBlock, renderInput, renderPreview, schemaType, selected, value } = props2;
  const { Markers } = useFormBuilder().__internal.components;
  const editor2 = usePortableTextEditor();
  const markers = usePortableTextMarkers(path2);
  const memberItem = usePortableTextMemberItem(pathToString2(path2));
  const { validation: validation2, hasError, hasInfo, hasWarning } = useMemberValidation(memberItem == null ? void 0 : memberItem.node);
  const parentSchemaType = editor2.schemaTypes.block;
  const hasMarkers = markers.length > 0;
  const selfSelection = (0, import_react51.useMemo)(() => ({ anchor: { path: relativePath, offset: 0 }, focus: { path: relativePath, offset: 0 } }), [relativePath]);
  const onRemove = (0, import_react51.useCallback)(() => {
    PortableTextEditor.delete(editor2, selfSelection, { mode: "children" });
    PortableTextEditor.focus(editor2);
  }, [selfSelection, editor2]);
  const onOpen = (0, import_react51.useCallback)(() => {
    if (memberItem) {
      PortableTextEditor.blur(editor2);
      onItemOpen(memberItem.node.path);
    }
  }, [editor2, onItemOpen, memberItem]);
  const onClose = (0, import_react51.useCallback)(() => {
    onItemClose();
    PortableTextEditor.select(editor2, selfSelection);
    PortableTextEditor.focus(editor2);
  }, [onItemClose, editor2, selfSelection]);
  const isOpen = Boolean(memberItem == null ? void 0 : memberItem.member.open);
  const input = memberItem == null ? void 0 : memberItem.input;
  const nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b;
  const referenceElement = (_a4 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a4.current;
  const presence = useChildPresence(path2, true);
  const rootPresence = (0, import_react51.useMemo)(() => presence.filter((p) => isEqual(p.path, path2)), [path2, presence]);
  const componentProps = (0, import_react51.useMemo)(() => ({ __unstable_floatingBoundary: floatingBoundary, __unstable_referenceBoundary: referenceBoundary, __unstable_referenceElement: referenceElement, children: input, focused, onClose, onOpen, onPathFocus, onRemove, open: isOpen, markers, member: memberItem == null ? void 0 : memberItem.member, parentSchemaType, path: nodePath, presence: rootPresence, readOnly: Boolean(readOnly), renderAnnotation, renderBlock, renderDefault: DefaultInlineObjectComponent, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, value, validation: validation2 }), [floatingBoundary, focused, input, isOpen, markers, memberItem == null ? void 0 : memberItem.member, nodePath, onClose, onOpen, onPathFocus, onRemove, parentSchemaType, readOnly, referenceBoundary, referenceElement, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, rootPresence, schemaType, selected, validation2, value]);
  const tooltipEnabled = hasError || hasWarning || hasInfo || hasMarkers;
  const toolTipContent = (0, import_react51.useMemo)(() => tooltipEnabled && (0, import_jsx_runtime6.jsx)(TooltipBox$1, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Markers, { markers, validation: validation2, renderCustomMarkers }) }) || null, [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]);
  return (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)("span", { ref: memberItem == null ? void 0 : memberItem.elementRef, contentEditable: false, children: (0, import_jsx_runtime6.jsx)(Tooltip, { placement: "bottom", portal: "editor", disabled: !tooltipEnabled, content: toolTipContent, children: renderInlineBlock && (0, import_jsx_runtime6.jsx)("span", { style: { position: "relative" }, children: renderInlineBlock(componentProps) }) }) }), [componentProps, memberItem == null ? void 0 : memberItem.elementRef, renderInlineBlock, toolTipContent, tooltipEnabled]);
};
var DefaultInlineObjectComponent = (props2) => {
  const { __unstable_floatingBoundary: floatingBoundary, __unstable_referenceBoundary: referenceBoundary, __unstable_referenceElement: referenceElement, children, focused, markers, onClose, onOpen, onRemove, open, readOnly, renderPreview, schemaType, selected, validation: validation2, value } = props2;
  const hasMarkers = markers.length > 0;
  const [popoverOpen, setPopoverOpen] = (0, import_react51.useState)(false);
  const popoverTitle = (schemaType == null ? void 0 : schemaType.title) || schemaType.name;
  const hasError = validation2.filter((v) => v.level === "error").length > 0;
  const hasWarning = validation2.filter((v) => v.level === "warning").length > 0;
  const openItem = (0, import_react51.useCallback)(() => {
    setPopoverOpen(false);
    onOpen();
  }, [onOpen]);
  (0, import_react51.useEffect)(() => {
    if (open) {
      setPopoverOpen(false);
    } else if (focused) {
      setPopoverOpen(true);
    } else {
      setPopoverOpen(false);
    }
  }, [focused, open]);
  const tone = (0, import_react51.useMemo)(() => {
    if (hasError) {
      return "critical";
    }
    if (hasWarning) {
      return "caution";
    }
    if (selected || focused) {
      return "primary";
    }
    return void 0;
  }, [focused, hasError, hasWarning, selected]);
  const onClosePopover = (0, import_react51.useCallback)(() => {
    setPopoverOpen(false);
  }, []);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Root$g2, { "data-focused": focused || void 0, "data-invalid": hasError || void 0, "data-markers": hasMarkers || void 0, "data-read-only": readOnly || void 0, "data-selected": selected || void 0, "data-warning": hasWarning || void 0, forwardedAs: "span", onClick: readOnly ? openItem : void 0, onDoubleClick: openItem, tone, children: (0, import_jsx_runtime6.jsx)(PreviewSpan, { children: renderPreview({ layout: "inline", schemaType, skipVisibilityCheck: true, value, fallbackTitle: "Click to edit" }) }) }), referenceElement && (0, import_jsx_runtime6.jsx)(InlineObjectToolbarPopover, { floatingBoundary, onClosePopover, onDelete: onRemove, onEdit: openItem, open: popoverOpen, referenceBoundary, referenceElement, title: popoverTitle }), open && (0, import_jsx_runtime6.jsx)(ObjectEditModal, { defaultType: "popover", onClose, autoFocus: focused, floatingBoundary, referenceBoundary, referenceElement, schemaType, children })] });
};
var __freeze$1D = Object.freeze;
var __defProp$1D = Object.defineProperty;
var __template$1D = (cooked, raw) => __freeze$1D(__defProp$1D(cooked, "raw", { value: __freeze$1D(raw || cooked.slice()) }));
var _a$1D;
var ToolbarPopover = st(Popover)(_a$1D || (_a$1D = __template$1D(["\n  &[data-popper-reference-hidden='true'] {\n    display: none !important;\n  }\n"])));
var POPOVER_FALLBACK_PLACEMENTS = ["top", "bottom"];
function AnnotationToolbarPopover(props2) {
  const { annotationOpen, floatingBoundary, onOpen, onRemove, referenceBoundary, referenceElement, selected, title } = props2;
  const [popoverOpen, setPopoverOpen] = (0, import_react51.useState)(false);
  const [cursorRect, setCursorRect] = (0, import_react51.useState)(null);
  const rangeRef = (0, import_react51.useRef)(null);
  const { sanity: sanity2 } = useTheme();
  const { t: t3 } = useTranslation2();
  const popoverRef = (0, import_react51.useRef)(null);
  const popoverScheme = sanity2.color.dark ? "light" : "dark";
  const cursorElement = (0, import_react51.useMemo)(() => {
    if (!cursorRect) {
      return null;
    }
    return { getBoundingClientRect: () => {
      return cursorRect;
    } };
  }, [cursorRect]);
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (!popoverOpen) {
      return;
    }
    if (event.key === "Escape") {
      setPopoverOpen(false);
    }
  }, [popoverOpen]));
  const handleSelectionChange = (0, import_react51.useCallback)(() => {
    if (annotationOpen) {
      setPopoverOpen(false);
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0)
      return;
    const range2 = sel.getRangeAt(0);
    const isWithinRoot = referenceElement == null ? void 0 : referenceElement.contains(range2.commonAncestorContainer);
    if (!isWithinRoot) {
      setPopoverOpen(false);
      setCursorRect(null);
      return;
    }
    const rect = range2 == null ? void 0 : range2.getBoundingClientRect();
    if (rect) {
      setPopoverOpen(true);
      setCursorRect(rect);
    }
  }, [annotationOpen, referenceElement]);
  (0, import_react51.useEffect)(() => {
    document.addEventListener("selectionchange", handleSelectionChange, { passive: true });
    return () => {
      document.removeEventListener("selectionchange", handleSelectionChange);
    };
  }, [handleSelectionChange]);
  const handleEditButtonClicked = (0, import_react51.useCallback)(() => {
    setPopoverOpen(false);
    onOpen();
  }, [onOpen]);
  (0, import_react51.useEffect)(() => {
    if (!annotationOpen && selected) {
      setPopoverOpen(true);
    }
    if (annotationOpen) {
      setPopoverOpen(false);
    }
  }, [annotationOpen, selected]);
  const handleRemoveButtonClicked = (0, import_react51.useCallback)(() => {
    setPopoverOpen(false);
    onRemove();
  }, [onRemove]);
  const handleScroll = (0, import_react51.useCallback)(() => {
    if (rangeRef.current) {
      setCursorRect(rangeRef.current.getBoundingClientRect());
    }
  }, []);
  (0, import_react51.useEffect)(() => {
    if (!popoverOpen) {
      return void 0;
    }
    referenceBoundary == null ? void 0 : referenceBoundary.addEventListener("scroll", handleScroll);
    return () => {
      referenceBoundary == null ? void 0 : referenceBoundary.removeEventListener("scroll", handleScroll);
    };
  }, [popoverOpen, referenceBoundary, handleScroll]);
  if (!popoverOpen) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(ToolbarPopover, { open: popoverOpen, floatingBoundary, constrainSize: true, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 1, "data-testid": "annotation-toolbar-popover", children: (0, import_jsx_runtime6.jsxs)(Inline, { space: 1, children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", size: 1, children: title }) }), (0, import_jsx_runtime6.jsx)(Button, { icon: EditIcon, mode: "bleed", onClick: handleEditButtonClicked, padding: 2, alt: t3("inputs.portable-text.action.edit-annotation"), tabIndex: 0 }), (0, import_jsx_runtime6.jsx)(Button, { icon: TrashIcon, mode: "bleed", padding: 2, onClick: handleRemoveButtonClicked, tone: "critical", alt: t3("inputs.portable-text.action.remove-annotation"), tabIndex: 0 })] }) }), fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, placement: "top", portal: true, preventOverflow: true, ref: popoverRef, referenceBoundary, referenceElement: cursorElement, scheme: popoverScheme });
}
var __freeze$1C = Object.freeze;
var __defProp$1C = Object.defineProperty;
var __template$1C = (cooked, raw) => __freeze$1C(__defProp$1C(cooked, "raw", { value: __freeze$1C(raw || cooked.slice()) }));
var _a$1C;
var _b$K;
var Root$f2 = st.span((props2) => {
  var _a22, _b22, _c4, _d4;
  const { $toneKey = "default", theme } = props2;
  return nt(_a$1C || (_a$1C = __template$1C(["\n      text-decoration: none;\n      display: inline;\n      background-color: ", ";\n      border-bottom: 1px dashed ", ";\n      color: ", ";\n\n      &[data-link] {\n        border-bottom: 1px solid ", ";\n      }\n\n      &[data-custom-markers] {\n        background-color: ", ";\n      }\n\n      &[data-warning] {\n        background-color: ", ";\n      }\n\n      &[data-error] {\n        background-color: ", ";\n      }\n    "])), (_a22 = theme.sanity.color.selectable) == null ? void 0 : _a22[$toneKey].enabled.bg, (_b22 = theme.sanity.color.selectable) == null ? void 0 : _b22[$toneKey].enabled.fg, (_c4 = theme.sanity.color.selectable) == null ? void 0 : _c4[$toneKey].enabled.fg, (_d4 = theme.sanity.color.selectable) == null ? void 0 : _d4[$toneKey].enabled.fg, theme.sanity.color.dark ? hues.purple[950].hex : hues.purple[50].hex, theme.sanity.color.muted.caution.hovered.bg, theme.sanity.color.muted.critical.hovered.bg);
});
var TooltipBox = st(Box).attrs({ forwardedAs: "span" })(_b$K || (_b$K = __template$1C(["\n  max-width: 250px;\n"])));
function Annotation(props2) {
  var _a4;
  const { children, editorNodeFocused, floatingBoundary, focused, onItemClose, onItemOpen, onPathFocus, path: path2, readOnly, referenceBoundary, renderAnnotation, renderBlock, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType, selected, value } = props2;
  const { Markers = DefaultMarkers } = useFormBuilder().__internal.components;
  const editor2 = usePortableTextEditor();
  const markDefPath = (0, import_react51.useMemo)(() => path2.slice(0, path2.length - 2).concat(["markDefs", { _key: value._key }]), [path2, value._key]);
  const [spanElement, setSpanElement] = (0, import_react51.useState)(null);
  const spanPath = (0, import_react51.useMemo)(() => path2.slice(path2.length - 3, path2.length), [path2]);
  const memberItem = usePortableTextMemberItem(pathToString2(markDefPath));
  const { validation: validation2 } = useMemberValidation(memberItem == null ? void 0 : memberItem.node);
  const markers = usePortableTextMarkers(path2);
  const text = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)("span", { "data-annotation": "", children }), [children]);
  const onOpen = (0, import_react51.useCallback)(() => {
    if (memberItem) {
      PortableTextEditor.blur(editor2);
      onPathFocus(memberItem.node.focusPath);
      onItemOpen(memberItem.node.path);
    }
  }, [editor2, memberItem, onItemOpen, onPathFocus]);
  const onClose = (0, import_react51.useCallback)(() => {
    onItemClose();
    const sel = PortableTextEditor.getSelection(editor2);
    const focusOffset = (sel == null ? void 0 : sel.focus.path) && isEqual(sel.focus.path, spanPath) && sel.focus.offset;
    const anchorOffset = (sel == null ? void 0 : sel.anchor.path) && isEqual(sel.anchor.path, spanPath) && sel.anchor.offset;
    PortableTextEditor.select(editor2, { anchor: { path: spanPath, offset: anchorOffset || 0 }, focus: { path: spanPath, offset: focusOffset || 0 } });
    PortableTextEditor.focus(editor2);
  }, [editor2, spanPath, onItemClose]);
  const onRemove = (0, import_react51.useCallback)(() => {
    PortableTextEditor.removeAnnotation(editor2, schemaType);
    PortableTextEditor.focus(editor2);
  }, [editor2, schemaType]);
  const markersToolTip = (0, import_react51.useMemo)(() => validation2.length > 0 || markers.length > 0 ? (0, import_jsx_runtime6.jsx)(Tooltip, { placement: "bottom", portal: "default", content: (0, import_jsx_runtime6.jsx)(TooltipBox, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Markers, { markers, renderCustomMarkers, validation: validation2 }) }), children: text }) : void 0, [Markers, markers, renderCustomMarkers, text, validation2]);
  const presence = useChildPresence(path2, true);
  const rootPresence = (0, import_react51.useMemo)(() => presence.filter((p) => isEqual(p.path, path2)), [path2, presence]);
  const isOpen = Boolean(memberItem == null ? void 0 : memberItem.member.open);
  const input = memberItem == null ? void 0 : memberItem.input;
  const nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$b;
  const referenceElement = spanElement;
  const componentProps = (0, import_react51.useMemo)(() => ({
    __unstable_floatingBoundary: floatingBoundary,
    __unstable_referenceBoundary: referenceBoundary,
    __unstable_referenceElement: referenceElement,
    __unstable_textElementFocus: editorNodeFocused,
    // Is there focus on the related text element for this object?
    children: input,
    focused,
    markers,
    onClose,
    onOpen,
    onPathFocus,
    onRemove,
    open: isOpen,
    parentSchemaType: editor2.schemaTypes.block,
    path: nodePath,
    presence: rootPresence,
    readOnly: Boolean(readOnly),
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderPreview,
    renderItem,
    renderDefault: DefaultAnnotationComponent,
    schemaType,
    selected,
    textElement: markersToolTip || text,
    validation: validation2,
    value
  }), [editor2.schemaTypes.block, editorNodeFocused, floatingBoundary, focused, input, isOpen, markers, markersToolTip, nodePath, onClose, onOpen, onPathFocus, onRemove, readOnly, referenceBoundary, referenceElement, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, rootPresence, schemaType, selected, text, validation2, value]);
  const CustomComponent = (_a4 = schemaType.components) == null ? void 0 : _a4.annotation;
  const setRef = (0, import_react51.useCallback)((elm) => {
    if (memberItem == null ? void 0 : memberItem.elementRef) {
      memberItem.elementRef.current = elm;
    }
    setSpanElement(elm);
  }, [memberItem]);
  return (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)("span", { ref: setRef, style: debugRender(), children: CustomComponent ? (0, import_jsx_runtime6.jsx)(CustomComponent, { ...componentProps }) : (0, import_jsx_runtime6.jsx)(DefaultAnnotationComponent, { ...componentProps }) }), [CustomComponent, componentProps, setRef]);
}
var DefaultAnnotationComponent = (props2) => {
  const { __unstable_floatingBoundary: floatingBoundary, __unstable_referenceBoundary: referenceBoundary, __unstable_referenceElement: referenceElement, children, focused, markers, onClose, onOpen, onRemove, open, readOnly, selected, schemaType, textElement, validation: validation2 } = props2;
  const isLink = schemaType.name === "link";
  const hasError = validation2.some((v) => v.level === "error");
  const hasWarning = validation2.some((v) => v.level === "warning");
  const hasMarkers = markers.length > 0;
  const { t: t3 } = useTranslation2();
  const toneKey = (0, import_react51.useMemo)(() => {
    if (hasError) {
      return "critical";
    }
    if (hasWarning) {
      return "caution";
    }
    if (isLink) {
      return "primary";
    }
    return "default";
  }, [isLink, hasError, hasWarning]);
  return (0, import_jsx_runtime6.jsxs)(Root$f2, { $toneKey: toneKey, "data-link": isLink ? "" : void 0, "data-error": hasError ? "" : void 0, "data-warning": hasWarning ? "" : void 0, "data-markers": hasMarkers || void 0, onClick: readOnly ? onOpen : void 0, children: [textElement, (0, import_jsx_runtime6.jsx)(AnnotationToolbarPopover, { annotationOpen: open, floatingBoundary, onOpen, onRemove, referenceBoundary, referenceElement, selected, title: schemaType.i18nTitleKey ? t3(schemaType.i18nTitleKey) : schemaType.title || schemaType.name }), open && (0, import_jsx_runtime6.jsx)(ObjectEditModal, { defaultType: "popover", floatingBoundary, onClose, autoFocus: focused, referenceBoundary, referenceElement, schemaType, children })] });
};
function defaultResolveBlockComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.block)
    return schemaType.components.block;
  if (isBlockType(schemaType)) {
    return DefaultComponent$1;
  }
  return DefaultBlockObjectComponent;
}
function defaultResolveInlineBlockComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.inlineBlock)
    return schemaType.components.inlineBlock;
  return DefaultInlineObjectComponent;
}
function defaultResolveAnnotationComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.annotation)
    return schemaType.components.annotation;
  return DefaultAnnotationComponent;
}
var defaultRenderAnnotation = (props2) => {
  return (0, import_react51.createElement)(defaultResolveAnnotationComponent(props2.schemaType), props2);
};
var defaultRenderBlock = (props2) => {
  return (0, import_react51.createElement)(defaultResolveBlockComponent(props2.schemaType), props2);
};
var defaultRenderInlineBlock = (props2) => {
  return (0, import_react51.createElement)(defaultResolveInlineBlockComponent(props2.schemaType), props2);
};
var defaultRenderField = (props2) => {
  return (0, import_react51.createElement)(defaultResolveFieldComponent(props2.schemaType), props2);
};
var defaultRenderInput = (props2) => {
  return (0, import_react51.createElement)(defaultResolveInputComponent(props2.schemaType), props2);
};
var defaultRenderItem = (props2) => {
  return (0, import_react51.createElement)(defaultResolveItemComponent(props2.schemaType), props2);
};
var defaultRenderPreview = (props2) => {
  return (0, import_react51.createElement)(Preview, props2);
};
function WithReferencedAsset(props2) {
  const { reference: reference2, children, observeAsset, waitPlaceholder } = props2;
  const documentId = reference2 == null ? void 0 : reference2._ref;
  const asset = useMemoObservable(() => observeAsset(documentId), [documentId, observeAsset]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: documentId && asset ? children(asset) : waitPlaceholder });
}
function extractPastedFiles(dataTransfer) {
  if (dataTransfer.files && dataTransfer.files.length > 0) {
    return Promise.resolve(Array.from(dataTransfer.files || []));
  }
  return normalizeItems(Array.from(dataTransfer.items || [])).then(import_flatten5.default);
}
function extractDroppedFiles(dataTransfer) {
  const files = Array.from(dataTransfer.files || []);
  const items = Array.from(dataTransfer.items || []);
  if (files && files.length > 0) {
    return Promise.resolve(files);
  }
  return normalizeItems(items).then(import_flatten5.default);
}
function toArray2(v) {
  return v === null ? [] : [v];
}
function normalizeItems(items) {
  return Promise.all(items.map((item) => {
    if (item.kind === "file" && item.webkitGetAsEntry) {
      let entry;
      try {
        entry = item.webkitGetAsEntry();
      } catch (err) {
        return toArray2(item.getAsFile());
      }
      if (!entry) {
        return [];
      }
      return entry.isDirectory ? walk(entry) : toArray2(item.getAsFile());
    }
    if (item.kind === "file") {
      const file2 = item.getAsFile();
      return Promise.resolve(file2 ? [file2] : []);
    }
    if (item.kind === "string") {
      console.warn('DataTransfer with kind="string" is currently not supported');
      return Promise.resolve([]);
    }
    console.warn("Unknown DataTransferItem.kind: %s", item.kind);
    return Promise.resolve([]);
  }));
}
function walk(entry) {
  if (entry.isFile) {
    return new Promise((resolve, reject) => entry.file(resolve, reject)).then((file2) => [file2]);
  }
  if (entry.isDirectory) {
    const dir2 = entry.createReader();
    return new Promise((resolve, reject) => dir2.readEntries(resolve, reject)).then((entries) => entries.filter((entr) => !entr.name.startsWith("."))).then((entries) => Promise.all(entries.map(walk)).then(import_flatten5.default));
  }
  return Promise.resolve([]);
}
function imageUrlToBlob(imageUrl) {
  let format4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "image/jpeg";
  let quality = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (imageUrl.match(/^webkit-fake-url:\/\//)) {
    return Promise.reject(new Error("Cannot read image contents from webkit fake url"));
  }
  return new Promise((resolve, reject) => {
    const loader = new Image();
    loader.crossOrigin = "anonymous";
    loader.referrerPolicy = "strict-origin-when-cross-origin";
    loader.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = loader.width;
      canvas.height = loader.height;
      const ctx = canvas.getContext("2d");
      ctx == null ? void 0 : ctx.drawImage(loader, 0, 0, canvas.width, canvas.height);
      try {
        canvas.toBlob(resolve, format4, quality);
      } catch (error2) {
        reject(error2);
      }
    };
    loader.src = imageUrl;
  });
}
var PASTE_INPUT_STYLE = { opacity: 0, position: "absolute" };
function fileTarget(Component3) {
  return import_react51.default.forwardRef(function FileTarget2(props2, ref) {
    const { onFiles, onFilesOver, onFilesOut, disabled, ...rest } = props2;
    const [showPasteInput, setShowPasteInput] = import_react51.default.useState(false);
    const pasteInput = import_react51.default.useRef(null);
    const forwardedRef = useForwardedRef(ref);
    const enteredElements = import_react51.default.useRef([]);
    const emitFiles = (0, import_react51.useCallback)((files) => {
      onFiles == null ? void 0 : onFiles(files);
    }, [onFiles]);
    const handleKeyDown = (0, import_react51.useCallback)((event) => {
      if (event.target === forwardedRef.current && (event.ctrlKey || event.metaKey) && event.key === "v") {
        setShowPasteInput(true);
      }
    }, [forwardedRef]);
    const handlePaste = (0, import_react51.useCallback)((event) => {
      extractPastedFiles(event.clipboardData).then((files) => {
        if (!pasteInput.current) {
          return [];
        }
        return files.length > 0 ? files : (
          // Invoke Safari hack if we didn't get any files
          convertImagesToFilesAndClearContentEditable(pasteInput.current, "image/jpeg")
        );
      }).then((files) => {
        var _a4;
        emitFiles(files);
        setShowPasteInput(false);
        (_a4 = forwardedRef.current) == null ? void 0 : _a4.focus();
      });
    }, [emitFiles, forwardedRef]);
    const handleDrop = (0, import_react51.useCallback)((event) => {
      enteredElements.current = [];
      event.preventDefault();
      event.stopPropagation();
      const dataTransfer = event.nativeEvent.dataTransfer;
      if (onFiles && dataTransfer) {
        extractDroppedFiles(dataTransfer).then((files) => {
          if (files) {
            emitFiles(files);
          }
        });
      }
      onFilesOut == null ? void 0 : onFilesOut();
    }, [emitFiles, onFiles, onFilesOut]);
    const handleDragOver = (0, import_react51.useCallback)((event) => {
      if (onFiles) {
        event.preventDefault();
        event.stopPropagation();
      }
    }, [onFiles]);
    const handleDragEnter = (0, import_react51.useCallback)((event) => {
      event.stopPropagation();
      if (onFilesOver && forwardedRef.current === event.currentTarget) {
        enteredElements.current = [...new Set(enteredElements.current), event.currentTarget];
        const fileTypes = Array.from(event.dataTransfer.items).map((item) => ({ type: item.type, kind: item.kind }));
        onFilesOver(fileTypes);
      }
    }, [onFilesOver, forwardedRef]);
    const handleDragLeave = (0, import_react51.useCallback)((event) => {
      event.stopPropagation();
      const idx = enteredElements.current.indexOf(event.currentTarget);
      if (idx > -1) {
        enteredElements.current.splice(idx, 1);
      }
      if (enteredElements.current.length === 0) {
        onFilesOut == null ? void 0 : onFilesOut();
      }
    }, [onFilesOut]);
    const prevShowPasteInput = import_react51.default.useRef(false);
    import_react51.default.useEffect(() => {
      var _a4;
      if (!prevShowPasteInput.current && showPasteInput && pasteInput.current) {
        pasteInput.current.focus();
        select(pasteInput.current);
      } else if (prevShowPasteInput.current && !showPasteInput) {
        (_a4 = pasteInput.current) == null ? void 0 : _a4.focus();
      }
      prevShowPasteInput.current = showPasteInput;
    }, [showPasteInput]);
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Component3, { ...rest, ref: forwardedRef, onKeyDown: disabled ? void 0 : handleKeyDown, onDragOver: disabled ? void 0 : handleDragOver, onDragEnter: disabled ? void 0 : handleDragEnter, onDragLeave: disabled ? void 0 : handleDragLeave, onDrop: disabled ? void 0 : handleDrop }), !disabled && showPasteInput && (0, import_jsx_runtime6.jsx)("div", { contentEditable: true, onPaste: handlePaste, ref: pasteInput, style: PASTE_INPUT_STYLE })] });
  });
}
function convertImagesToFilesAndClearContentEditable(element) {
  let targetFormat = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "image/jpeg";
  if (!element.isContentEditable) {
    return Promise.reject(new Error('Expected element to be contentEditable="true". Instead found a non contenteditable '.concat(element.tagName)));
  }
  return new Promise((resolve) => setTimeout(resolve, 10)).then(() => Array.from(element.querySelectorAll("img"))).then((imageElements) => {
    element.innerHTML = "";
    return imageElements;
  }).then((images) => Promise.all(images.map((img) => imageUrlToBlob(img.src)))).then((imageBlobs) => imageBlobs.map((blob) => new File([blob], "pasted-image.jpg", { type: targetFormat })));
}
function select(el) {
  const range2 = document.createRange();
  range2.selectNodeContents(el);
  const sel = window.getSelection();
  sel == null ? void 0 : sel.removeAllRanges();
  sel == null ? void 0 : sel.addRange(range2);
}
function focusRingBorderStyle$1(border2) {
  return "inset 0 0 0 ".concat(border2.width, "px ").concat(border2.color);
}
function focusRingStyle$1(opts) {
  const { base, border: border2, focusRing } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border2 && focusRingBorderStyle$1(border2), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
var __freeze$1B = Object.freeze;
var __defProp$1B = Object.defineProperty;
var __template$1B = (cooked, raw) => __freeze$1B(__defProp$1B(cooked, "raw", { value: __freeze$1B(raw || cooked.slice()) }));
var _a$1B;
function withFocusRing(component) {
  return st(component)((props2) => {
    const border2 = { width: props2.$border ? 1 : 0, color: "var(--card-border-color)" };
    return nt(_a$1B || (_a$1B = __template$1B(["\n        --card-focus-box-shadow: ", ";\n\n        border-radius: ", ";\n        outline: none;\n        box-shadow: var(--card-focus-box-shadow);\n\n        &:focus {\n          --card-focus-box-shadow: ", ";\n        }\n      "])), focusRingBorderStyle$1(border2), rem(props2.theme.sanity.radius[1]), focusRingStyle$1({ base: props2.theme.sanity.color.base, border: border2, focusRing: props2.theme.sanity.focusRing }));
  });
}
var FileTarget = withFocusRing(fileTarget(Card));
var STALE_UPLOAD_MS = 1e3 * 60 * 2;
var __freeze$1A = Object.freeze;
var __defProp$1A = Object.defineProperty;
var __template$1A = (cooked, raw) => __freeze$1A(__defProp$1A(cooked, "raw", { value: __freeze$1A(raw || cooked.slice()) }));
var _a$1A;
var _b$J;
var _c$p;
var _d$g;
var CardWrapper = st(Card)(_a$1A || (_a$1A = __template$1A(["\n  min-height: 82px;\n  box-sizing: border-box;\n"])));
var FlexWrapper = st(Flex)(_b$J || (_b$J = __template$1A(["\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var LeftSection = st(Stack)(_c$p || (_c$p = __template$1A(["\n  position: relative;\n  width: 60%;\n"])));
var CodeWrapper = st(Code)(_d$g || (_d$g = __template$1A(["\n  position: relative;\n  width: 100%;\n\n  code {\n    overflow: hidden;\n    overflow: clip;\n    text-overflow: ellipsis;\n    position: relative;\n    max-width: 200px;\n  }\n"])));
var elapsedMs = (date) => (/* @__PURE__ */ new Date()).getTime() - new Date(date).getTime();
function UploadProgress(_ref197) {
  let { uploadState, onCancel, onStale, height } = _ref197;
  const filename = uploadState.file.name;
  (0, import_react51.useEffect)(() => {
    if (elapsedMs(uploadState.updatedAt) > STALE_UPLOAD_MS) {
      onStale == null ? void 0 : onStale();
    }
  }, [uploadState.updatedAt, onStale]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(CardWrapper, { tone: "primary", padding: 4, border: true, style: { height: "".concat(height, "px") }, children: (0, import_jsx_runtime6.jsxs)(FlexWrapper, { align: "center", justify: "space-between", height: "fill", direction: "row", gap: 2, children: [(0, import_jsx_runtime6.jsxs)(LeftSection, { children: [(0, import_jsx_runtime6.jsx)(Flex, { justify: "center", gap: [3, 3, 2, 2], direction: ["column", "column", "row"], children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Inline, { space: 2, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "input.files.common.upload-progress", components: { FileName: () => (0, import_jsx_runtime6.jsx)(CodeWrapper, { size: 1, children: filename ? filename : "" }) } }) }) }) }), (0, import_jsx_runtime6.jsx)(Card, { marginTop: 3, radius: 5, shadow: 1, children: (0, import_jsx_runtime6.jsx)(LinearProgress, { value: uploadState.progress }) })] }), onCancel ? (0, import_jsx_runtime6.jsx)(Button, { fontSize: 2, text: t3("input.files.common.cancel-upload"), mode: "ghost", tone: "critical", onClick: onCancel }) : null] }) });
}
function urlToFile(url, filename) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      const reader = new FileReader();
      reader.onloadend = () => {
        var _a4;
        const string3 = (_a4 = reader.result) == null ? void 0 : _a4.toString();
        const ext = string3 == null ? void 0 : string3.substring("data:image/".length, string3.indexOf(";base64"));
        if (!ext && !filename) {
          reject(new Error("Could not find mime type for image"));
          return;
        }
        resolve(dataURLtoFile(reader.result, filename || "".concat(v4_default(), ".").concat(ext)));
      };
      reader.readAsDataURL(xhr.response);
    };
    xhr.onerror = (error2) => {
      reject(error2);
    };
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.send();
  });
}
function base64ToFile(base64Data, filename) {
  return new Promise((resolve, reject) => {
    const string3 = base64Data.toString();
    const ext = string3.substring("data:image/".length, string3.indexOf(";base64"));
    if (!ext && !filename) {
      reject(new Error("Could not find mime type for image"));
      return;
    }
    resolve(dataURLtoFile(base64Data, filename || "".concat(v4_default(), ".").concat(ext)));
  });
}
function dataURLtoFile(dataurl, filename) {
  var _a4;
  const arr = dataurl.split(",");
  const mime = (_a4 = arr[0].match(/:(.*?);/)) == null ? void 0 : _a4[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], filename, { type: mime });
}
function handleSelectAssetFromSource(_ref198) {
  let { assetFromSource, onChange, type, resolveUploader: resolveUploader2, uploadWith, isImage: isImage2 } = _ref198;
  if (!assetFromSource) {
    throw new Error("No asset given");
  }
  if (!Array.isArray(assetFromSource) || assetFromSource.length === 0) {
    throw new Error("Returned value must be an array with at least one item (asset)");
  }
  const firstAsset = assetFromSource[0];
  const assetProps = firstAsset.assetDocumentProps;
  const originalFilename = assetProps == null ? void 0 : assetProps.originalFilename;
  const label = assetProps == null ? void 0 : assetProps.label;
  const title = assetProps == null ? void 0 : assetProps.title;
  const description = assetProps == null ? void 0 : assetProps.description;
  const creditLine = assetProps == null ? void 0 : assetProps.creditLine;
  const source = assetProps == null ? void 0 : assetProps.source;
  const imagePatches = isImage2 ? [unset2(["hotspot"]), unset2(["crop"])] : [];
  switch (firstAsset.kind) {
    case "assetDocumentId":
      onChange([setIfMissing2({ _type: type.name }), ...imagePatches, set$2({ _type: "reference", _ref: firstAsset.value }, ["asset"])]);
      break;
    case "file": {
      const uploader = resolveUploader2(type, firstAsset.value);
      if (uploader) {
        uploadWith(uploader, firstAsset.value, { label, title, description, creditLine, source });
      }
      break;
    }
    case "base64":
      base64ToFile(firstAsset.value, originalFilename).then((file2) => {
        const uploader = resolveUploader2(type, file2);
        if (uploader) {
          uploadWith(uploader, file2, { label, title, description, creditLine, source });
        }
      });
      break;
    case "url":
      urlToFile(firstAsset.value, originalFilename).then((file2) => {
        const uploader = resolveUploader2(type, file2);
        if (uploader) {
          uploadWith(uploader, file2, { label, title, description, creditLine, source });
        }
      });
      break;
    default: {
      throw new Error("Invalid value returned from asset source plugin");
    }
  }
}
var __freeze$1z = Object.freeze;
var __defProp$1z = Object.defineProperty;
var __template$1z = (cooked, raw) => __freeze$1z(__defProp$1z(cooked, "raw", { value: __freeze$1z(raw || cooked.slice()) }));
var _a$1z;
var FileMenuItem = st(MenuItem)(_a$1z || (_a$1z = __template$1z(["\n  position: relative;\n\n  & input {\n    overflow: hidden;\n    overflow: clip;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    min-width: 0;\n    display: block;\n    appearance: none;\n    padding: 0;\n    margin: 0;\n    border: 0;\n    opacity: 0;\n  }\n"])));
var FileInputMenuItem = import_react51.default.forwardRef(function FileInputMenuItem2(props2, forwardedRef) {
  const { icon, id: idProp, accept, capture, fontSize: fontSize2, multiple, onSelect, padding = 3, space = 3, textAlign, text, disabled, ...rest } = props2;
  const id4 = "".concat(idProp || "", "-").concat((0, import_react51.useId)());
  const handleChange = import_react51.default.useCallback((event) => {
    if (onSelect && event.target.files) {
      onSelect(Array.from(event.target.files));
    }
  }, [onSelect]);
  const content = (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "flex-start", padding, children: [icon && (0, import_jsx_runtime6.jsx)(Box, { marginRight: text ? space : void 0, children: (0, import_jsx_runtime6.jsxs)(Text3, { size: fontSize2, children: [(0, import_react51.isValidElement)(icon) && icon, (0, import_react_is2.isValidElementType)(icon) && (0, import_react51.createElement)(icon)] }) }), text && (0, import_jsx_runtime6.jsx)(Text3, { align: textAlign, size: fontSize2, textOverflow: "ellipsis", children: text })] });
  return (0, import_jsx_runtime6.jsxs)(FileMenuItem, { ...rest, htmlFor: id4, padding: 0, fontSize: 2, disabled, ref: forwardedRef, children: [content, (0, import_jsx_runtime6.jsx)("input", { "data-testid": "file-menuitem-input", accept, capture, id: id4, multiple, onChange: handleChange, type: "file", value: "", disabled })] });
});
function ActionsMenu(props2) {
  const { onUpload, onReset, readOnly, accept, directUploads, browse, downloadUrl, copyUrl } = props2;
  const { push: pushToast } = useToast();
  const { t: t3 } = useTranslation2();
  const handleCopyURL = (0, import_react51.useCallback)(() => {
    navigator.clipboard.writeText(copyUrl || "");
    pushToast({ closable: true, status: "success", title: t3("inputs.files.common.actions-menu.notification.url-copied") });
  }, [copyUrl, pushToast, t3]);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("inputs.files.common.actions-menu.replace.label") }) }), (0, import_jsx_runtime6.jsx)(FileInputMenuItem, { icon: UploadIcon, mode: "bleed", onSelect: onUpload, accept, text: t3("inputs.files.common.actions-menu.upload.label"), "data-testid": "file-input-upload-button", disabled: readOnly || !directUploads, fontSize: 2 }), browse, (downloadUrl || copyUrl) && (0, import_jsx_runtime6.jsx)(MenuDivider, {}), downloadUrl && (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", icon: DownloadIcon, text: t3("inputs.files.common.actions-menu.download.label"), href: downloadUrl }), copyUrl && (0, import_jsx_runtime6.jsx)(MenuItem, { icon: CopyIcon, text: t3("inputs.files.common.actions-menu.copy-url.label"), onClick: handleCopyURL }), (0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(MenuItem, { tone: "critical", icon: ResetIcon, text: t3("inputs.files.common.actions-menu.clear-field.label"), onClick: onReset, disabled: readOnly, "data-testid": "file-input-clear" })] });
}
var __freeze$1y = Object.freeze;
var __defProp$1y = Object.defineProperty;
var __template$1y = (cooked, raw) => __freeze$1y(__defProp$1y(cooked, "raw", { value: __freeze$1y(raw || cooked.slice()) }));
var _a$1y;
var RootFlex$4 = st(Flex)(_a$1y || (_a$1y = __template$1y(["\n  pointer-events: none;\n"])));
function PlaceholderText(props2) {
  const { hoveringFiles, type, readOnly, acceptedFiles, rejectedFilesCount, directUploads } = props2;
  const isFileType = type === "file";
  const { t: t3 } = useTranslation2();
  const messageIcon = (0, import_react51.useMemo)(() => {
    if (readOnly) {
      return (0, import_jsx_runtime6.jsx)(ReadOnlyIcon, {});
    }
    if (hoveringFiles && rejectedFilesCount > 0 || !directUploads) {
      return (0, import_jsx_runtime6.jsx)(AccessDeniedIcon, {});
    }
    return isFileType ? (0, import_jsx_runtime6.jsx)(BinaryDocumentIcon, {}) : (0, import_jsx_runtime6.jsx)(ImageIcon, {});
  }, [directUploads, hoveringFiles, isFileType, readOnly, rejectedFilesCount]);
  const messageText = (0, import_react51.useMemo)(() => {
    if (!directUploads) {
      return t3("inputs.files.common.placeholder.upload-not-supported");
    }
    if (readOnly) {
      return t3("inputs.files.common.placeholder.read-only");
    }
    if (hoveringFiles && directUploads && !readOnly) {
      if (acceptedFiles.length > 0) {
        return t3("inputs.files.common.placeholder.drop-to-upload", { context: type });
      }
      if (rejectedFilesCount > 0) {
        return t3("inputs.files.common.placeholder.cannot-upload-some-files", { count: rejectedFilesCount });
      }
    }
    return t3("inputs.files.common.placeholder.drag-or-paste-to-upload", { context: type });
  }, [acceptedFiles.length, directUploads, hoveringFiles, readOnly, rejectedFilesCount, t3, type]);
  return (0, import_jsx_runtime6.jsxs)(RootFlex$4, { align: "center", gap: 2, justify: "center", children: [(0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: messageIcon }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: messageText })] });
}
var __freeze$1x = Object.freeze;
var __defProp$1x = Object.defineProperty;
var __template$1x = (cooked, raw) => __freeze$1x(__defProp$1x(cooked, "raw", { value: __freeze$1x(raw || cooked.slice()) }));
var _a$1x;
var FileButton = st(Button).attrs({ forwardedAs: "label" })((_ref199) => {
  let { theme } = _ref199;
  const { focusRing } = theme.sanity;
  const base = theme.sanity.color.base;
  const border2 = { width: 1, color: "var(--card-border-color)" };
  return nt(_a$1x || (_a$1x = __template$1x(["\n      &:not([data-disabled='true']) {\n        &:focus-within {\n          box-shadow: ", ";\n        }\n      }\n\n      & input {\n        overflow: hidden;\n        overflow: clip;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        position: absolute;\n        min-width: 0;\n        display: block;\n        appearance: none;\n        padding: 0;\n        margin: 0;\n        border: 0;\n        opacity: 0;\n      }\n    "])), focusRingStyle$1({ base, border: border2, focusRing }));
});
var FileInputButton = import_react51.default.forwardRef(function FileInputButton2(props2, forwardedRef) {
  const { icon, id: idProp, accept, capture, fontSize: fontSize2, multiple, onSelect, padding = 3, space = 3, textAlign, text, disabled, ...rest } = props2;
  const id4 = "".concat(idProp || "", "-").concat((0, import_react51.useId)());
  const theme = useTheme();
  const handleChange = import_react51.default.useCallback((event) => {
    if (onSelect && event.target.files) {
      onSelect(Array.from(event.target.files));
    }
  }, [onSelect]);
  const content = (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "center", padding, children: [icon && (0, import_jsx_runtime6.jsx)(Box, { marginRight: text ? space : void 0, children: (0, import_jsx_runtime6.jsxs)(Text3, { size: fontSize2, children: [(0, import_react51.isValidElement)(icon) && icon, (0, import_react_is2.isValidElementType)(icon) && (0, import_react51.createElement)(icon)] }) }), text && (0, import_jsx_runtime6.jsx)(Text3, { align: textAlign, size: fontSize2, textOverflow: "ellipsis", weight: theme.sanity.button.textWeight, children: text })] });
  return (0, import_jsx_runtime6.jsxs)(FileButton, { ...rest, htmlFor: id4, padding: 0, fontSize: 2, disabled, children: [content, (0, import_jsx_runtime6.jsx)("input", { "data-testid": "file-button-input", accept, capture, id: id4, multiple, onChange: handleChange, ref: forwardedRef, type: "file", value: "", disabled })] });
});
function UploadPlaceholderComponent(props2) {
  const { accept, acceptedFiles, browse, directUploads, hoveringFiles, onUpload, readOnly, rejectedFilesCount, type } = props2;
  const [rootElement, setRootElement] = (0, import_react51.useState)(null);
  const rect = useElementSize(rootElement);
  const collapsed = (rect == null ? void 0 : rect.border) && rect.border.width < 440;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: collapsed ? void 0 : "center", direction: collapsed ? "column" : "row", gap: 4, justify: "space-between", paddingY: collapsed ? 1 : void 0, ref: setRootElement, children: [(0, import_jsx_runtime6.jsx)(Flex, { flex: 1, justify: "center", children: (0, import_jsx_runtime6.jsx)(PlaceholderText, { acceptedFiles, directUploads, hoveringFiles, readOnly, rejectedFilesCount, type }) }), (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, justify: "center", wrap: "wrap", children: [(0, import_jsx_runtime6.jsx)(FileInputButton, { accept, "data-testid": "file-input-upload-button", disabled: readOnly || !directUploads, icon: UploadIcon, mode: "ghost", onSelect: onUpload, text: t3("input.files.common.upload-placeholder.file-input-button.text") }), browse] })] });
}
var UploadPlaceholder = import_react51.default.memo(UploadPlaceholderComponent);
var __freeze$1w = Object.freeze;
var __defProp$1w = Object.defineProperty;
var __template$1w = (cooked, raw) => __freeze$1w(__defProp$1w(cooked, "raw", { value: __freeze$1w(raw || cooked.slice()) }));
var _a$1w;
var ButtonWrapper$3 = st(Button)(_a$1w || (_a$1w = __template$1w(["\n  width: 100%;\n"])));
function UploadWarning(_ref200) {
  let { onClearStale } = _ref200;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Card, { tone: "caution", padding: 4, border: true, radius: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { gap: 4, marginBottom: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.files.common.stale-upload-warning.title") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("inputs.files.common.stale-upload-warning.description", { staleThresholdMinutes: Math.ceil(STALE_UPLOAD_MS / 1e3 / 60) }) })] })] }), (0, import_jsx_runtime6.jsx)(ButtonWrapper$3, { icon: ResetIcon, text: t3("inputs.files.common.stale-upload-warning.clear"), onClick: onClearStale, mode: "ghost" })] });
}
var __freeze$1v = Object.freeze;
var __defProp$1v = Object.defineProperty;
var __template$1v = (cooked, raw) => __freeze$1v(__defProp$1v(cooked, "raw", { value: __freeze$1v(raw || cooked.slice()) }));
var _a$1v;
var _b$I;
var CardOverlay = st(Card)(_a$1v || (_a$1v = __template$1v(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n"])));
var FlexContainer$1 = st(Flex)(_b$I || (_b$I = __template$1v(["\n  height: 100%;\n"])));
function formatBytes(bytes) {
  let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return "".concat(parseFloat((bytes / Math.pow(k, i)).toFixed(dm)), " ").concat(sizes[i]);
}
function FileActionsMenu(props2) {
  const { originalFilename, size: size2, children, muted, disabled, onClick, isMenuOpen, onMenuOpen, setMenuButtonElement } = props2;
  const [menuElement, setMenuElement] = (0, import_react51.useState)(null);
  const [buttonElement, setButtonElement] = (0, import_react51.useState)(null);
  const handleClick = (0, import_react51.useCallback)(() => onMenuOpen(true), [onMenuOpen]);
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (isMenuOpen && (event.key === "Escape" || event.key === "Tab")) {
      onMenuOpen(false);
      buttonElement == null ? void 0 : buttonElement.focus();
    }
  }, [isMenuOpen, onMenuOpen, buttonElement]));
  useClickOutside((0, import_react51.useCallback)((event) => {
    if (!(buttonElement == null ? void 0 : buttonElement.contains(event.target))) {
      onMenuOpen(false);
    }
  }, [buttonElement, onMenuOpen]), [menuElement]);
  const setOptionsButtonRef = (0, import_react51.useCallback)((el) => {
    setMenuButtonElement(el);
    setButtonElement(el);
  }, [setMenuButtonElement]);
  (0, import_react51.useEffect)(() => {
    if (isMenuOpen) {
      menuElement == null ? void 0 : menuElement.focus();
    }
  }, [isMenuOpen, menuElement]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Flex, { wrap: "nowrap", justify: "space-between", align: "center", children: [(0, import_jsx_runtime6.jsx)(Card, { as: muted || disabled ? void 0 : "button", radius: 2, padding: 2, tone: "inherit", onClick, flex: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { wrap: "nowrap", align: "center", children: [(0, import_jsx_runtime6.jsx)(Card, { padding: 3, tone: "transparent", shadow: 1, radius: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { muted, children: (0, import_jsx_runtime6.jsx)(BinaryDocumentIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, marginLeft: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 2, textOverflow: "ellipsis", muted, "data-testid": "file-name", children: originalFilename }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, "data-testid": "file-size", children: formatBytes(size2) })] })] }) }), (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Flex, { justify: "center", children: (0, import_jsx_runtime6.jsx)(Popover, { content: (0, import_jsx_runtime6.jsx)(Menu, { ref: setMenuElement, children }), id: "file-actions-menu", portal: true, open: isMenuOpen, constrainSize: true, children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("inputs.file.actions-menu.file-options.aria-label"), "data-testid": "options-menu-button", icon: EllipsisVerticalIcon, mode: "bleed", onClick: handleClick, ref: setOptionsButtonRef }) }) }) })] });
}
function FileSkeleton$1() {
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "flex-start", padding: 2, children: [(0, import_jsx_runtime6.jsx)(Skeleton, { padding: 3, radius: 1, animated: true }), (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, marginLeft: 3, children: [(0, import_jsx_runtime6.jsx)(LabelSkeleton, { style: { width: "100%" }, radius: 1, animated: true }), (0, import_jsx_runtime6.jsx)(LabelSkeleton, { style: { width: "100%" }, radius: 1, animated: true })] })] });
}
var __freeze$1u = Object.freeze;
var __defProp$1u = Object.defineProperty;
var __template$1u = (cooked, raw) => __freeze$1u(__defProp$1u(cooked, "raw", { value: __freeze$1u(raw || cooked.slice()) }));
var _a$1u;
var ButtonWrapper$2 = st(Button)(_a$1u || (_a$1u = __template$1u(["\n  width: 100%;\n"])));
function InvalidFileWarning(_ref201) {
  let { onClearValue } = _ref201;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Card, { tone: "caution", padding: 4, border: true, radius: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { gap: 4, marginBottom: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.file.invalid-file-warning.title") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("inputs.file.invalid-file-warning.description") })] })] }), (0, import_jsx_runtime6.jsx)(ButtonWrapper$2, { icon: ResetIcon, text: t3("inputs.file.invalid-file-warning.reset-button.text"), onClick: onClearValue, mode: "ghost" })] });
}
function passThrough$1(_ref202) {
  let { children } = _ref202;
  return children;
}
var ASSET_FIELD_PATH$1 = ["asset"];
var BaseFileInput = class extends import_react51.default.PureComponent {
  constructor(props2) {
    var _this;
    super(props2);
    _this = this;
    this.uploadSubscription = null;
    this.browseButtonElement = null;
    this.state = { isUploading: false, selectedAssetSource: null, hoveringFiles: [], isStale: false, isMenuOpen: false };
    this.toast = null;
    this.handleRemoveButtonClick = () => {
      const { path: path2, value } = this.props;
      const parentPathSegment = path2.slice(-1)[0];
      const isArrayElement = typeof parentPathSegment !== "string";
      const allKeys = Object.keys(value || {});
      const remainingKeys = allKeys.filter((key2) => !["_type", "_key", "_upload", "asset"].includes(key2));
      const isEmpty3 = remainingKeys.length === 0;
      const removeKeys = ["asset"].concat(allKeys.filter((key2) => ["_upload"].includes(key2))).map((key2) => unset2([key2]));
      this.props.onChange(PatchEvent.from(isEmpty3 && !isArrayElement ? unset2() : removeKeys));
    };
    this.handleCancelUpload = () => {
      this.cancelUpload();
    };
    this.handleClearUploadState = () => {
      this.setState({ isStale: false });
      this.clearUploadStatus();
    };
    this.handleStaleUpload = () => {
      this.setState({ isStale: true });
    };
    this.handleClearField = () => {
      this.props.onChange(unset2(["asset"]));
    };
    this.handleSelectFiles = (files) => {
      const { directUploads, readOnly } = this.props;
      const { hoveringFiles } = this.state;
      if (directUploads && !readOnly) {
        this.uploadFirstAccepted(files);
      } else if (hoveringFiles.length > 0) {
        this.handleFilesOut();
      }
    };
    this.handleSelectFileFromAssetSource = (source) => {
      this.setState({ selectedAssetSource: source });
    };
    this.handleAssetSourceClosed = () => {
      var _a4;
      this.setState({ selectedAssetSource: null });
      (_a4 = this.browseButtonElement) == null ? void 0 : _a4.focus();
    };
    this.setBrowseButtonElement = (el) => {
      this.browseButtonElement = el;
    };
    this.uploadWith = function(uploader, file2) {
      let assetDocumentProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const { schemaType, onChange, client, t: t3 } = _this.props;
      const { source } = assetDocumentProps;
      const options = { metadata: (0, import_get3.default)(schemaType, "options.metadata"), storeOriginalFilename: (0, import_get3.default)(schemaType, "options.storeOriginalFilename"), source };
      _this.cancelUpload();
      _this.setState({ isUploading: true });
      onChange(PatchEvent.from([setIfMissing2({ _type: schemaType.name })]));
      _this.uploadSubscription = uploader.upload(client, file2, schemaType, options).subscribe({ next: (uploadEvent) => {
        if (uploadEvent.patches) {
          onChange(PatchEvent.from(uploadEvent.patches));
        }
      }, error: (err) => {
        var _a4;
        console.error(err);
        (_a4 = _this.toast) == null ? void 0 : _a4.push({ status: "error", description: t3("inputs.file.upload-failed.description"), title: t3("inputs.file.upload-failed.title") });
        _this.clearUploadStatus();
      }, complete: () => {
        _this.setState({ isUploading: false });
      } });
    };
    this.handleSelectAssetFromSource = (assetFromSource) => {
      const { onChange, schemaType, resolveUploader: resolveUploader2 } = this.props;
      handleSelectAssetFromSource({ assetFromSource, onChange, type: schemaType, resolveUploader: resolveUploader2, uploadWith: this.uploadWith });
      this.setState({ selectedAssetSource: null });
    };
    this.handleFileTargetFocus = (event) => {
      var _a4;
      if (event.currentTarget === event.target && event.currentTarget === ((_a4 = this.props.elementProps.ref) == null ? void 0 : _a4.current)) {
        this.props.elementProps.onFocus(event);
      }
    };
    this.handleFilesOver = (fileInfo) => {
      this.setState({ hoveringFiles: fileInfo });
    };
    this.handleFilesOut = () => {
      this.setState({ hoveringFiles: [] });
    };
    this.handleUpload = (_ref203) => {
      let { file: file2, uploader } = _ref203;
      this.uploadWith(uploader, file2);
    };
    this.setToast = (toast) => {
      this.toast = toast;
    };
    this._assetFieldPath = props2.path.concat(ASSET_FIELD_PATH$1);
  }
  clearUploadStatus() {
    var _a4;
    if ((_a4 = this.props.value) == null ? void 0 : _a4._upload) {
      this.props.onChange(PatchEvent.from([unset2(["_upload"])]));
    }
  }
  cancelUpload() {
    if (this.uploadSubscription) {
      this.uploadSubscription.unsubscribe();
      this.clearUploadStatus();
    }
  }
  uploadFirstAccepted(files) {
    const { schemaType } = this.props;
    const match4 = files.map((file2) => {
      var _a4, _b4;
      return { file: file2, uploader: (_b4 = (_a4 = this.props).resolveUploader) == null ? void 0 : _b4.call(_a4, schemaType, file2) };
    }).find((result) => result.uploader);
    if (match4) {
      this.uploadWith(match4.uploader, match4.file);
    }
    this.setState({ isMenuOpen: false });
  }
  renderUploadState(uploadState) {
    const { isUploading } = this.state;
    return (0, import_jsx_runtime6.jsx)(UploadProgress, { uploadState, onCancel: isUploading ? this.handleCancelUpload : void 0, onStale: this.handleStaleUpload });
  }
  renderAssetSource() {
    const { selectedAssetSource } = this.state;
    const { value, schemaType, observeAsset, t: t3 } = this.props;
    if (!selectedAssetSource) {
      return null;
    }
    const accept = (0, import_get3.default)(schemaType, "options.accept", "");
    const Component3 = selectedAssetSource.component;
    if (value && value.asset) {
      return (0, import_jsx_runtime6.jsx)(WithReferencedAsset, { observeAsset, reference: value.asset, waitPlaceholder: (0, import_jsx_runtime6.jsx)(FileSkeleton$1, {}), children: (fileAsset2) => (0, import_jsx_runtime6.jsx)(Component3, { selectedAssets: [fileAsset2], selectionType: "single", assetType: "file", accept, dialogHeaderTitle: t3("inputs.file.dialog.title"), onClose: this.handleAssetSourceClosed, onSelect: this.handleSelectAssetFromSource }) });
    }
    return (0, import_jsx_runtime6.jsx)(Component3, { selectedAssets: [], selectionType: "single", assetType: "file", accept, dialogHeaderTitle: t3("inputs.file.dialog.title"), onClose: this.handleAssetSourceClosed, onSelect: this.handleSelectAssetFromSource });
  }
  renderAsset() {
    const { value, changed, readOnly, elementProps } = this.props;
    const { hoveringFiles, isStale } = this.state;
    const hasValueOrUpload = Boolean((value == null ? void 0 : value._upload) || (value == null ? void 0 : value.asset));
    if (value && typeof value.asset !== "undefined" && !(value == null ? void 0 : value._upload) && !isFileSource(value)) {
      return () => (0, import_jsx_runtime6.jsx)(InvalidFileWarning, { onClearValue: this.handleClearField });
    }
    return (inputProps) => (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [isStale && (0, import_jsx_runtime6.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime6.jsx)(UploadWarning, { onClearStale: this.handleClearUploadState }) }), (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: this._assetFieldPath, hasFocus: !!inputProps.focused, isChanged: changed, children: (value == null ? void 0 : value._upload) ? this.renderUploadState(value._upload) : (0, import_jsx_runtime6.jsx)(FileTarget, { ...elementProps, onFocus: this.handleFileTargetFocus, tabIndex: 0, disabled: Boolean(readOnly), onFiles: this.handleSelectFiles, onFilesOver: this.handleFilesOver, onFilesOut: this.handleFilesOut, tone: this.getFileTone(), $border: hasValueOrUpload || hoveringFiles.length > 0, style: { padding: 1 }, sizing: "border", radius: 2, children: (0, import_jsx_runtime6.jsxs)("div", { style: { position: "relative" }, children: [!(value == null ? void 0 : value.asset) && this.renderUploadPlaceholder(), (value == null ? void 0 : value.asset) && hoveringFiles.length > 0 ? this.renderAssetMenu(this.getFileTone()) : null, !(value == null ? void 0 : value._upload) && (value == null ? void 0 : value.asset) && this.renderPreview()] }) }) })] });
  }
  renderPreview() {
    const { value, readOnly, assetSources, schemaType, directUploads, observeAsset, t: t3 } = this.props;
    const { isMenuOpen } = this.state;
    const asset = value == null ? void 0 : value.asset;
    if (!asset) {
      return null;
    }
    const accept = (0, import_get3.default)(schemaType, "options.accept", "");
    let browseMenuItem = assetSources && (assetSources == null ? void 0 : assetSources.length) === 0 ? null : (0, import_jsx_runtime6.jsx)(MenuItem, { icon: SearchIcon, text: t3("inputs.file.browse-button.text"), onClick: () => {
      this.setState({ isMenuOpen: false });
      this.handleSelectFileFromAssetSource(assetSources[0]);
    }, disabled: readOnly, "data-testid": "file-input-browse-button" });
    if (assetSources.length > 1) {
      browseMenuItem = assetSources.map((assetSource) => {
        return (0, import_jsx_runtime6.jsx)(MenuItem, { text: (assetSource.i18nKey ? t3(assetSource.i18nKey) : assetSource.title) || (0, import_startCase2.default)(assetSource.name), onClick: () => {
          this.setState({ isMenuOpen: false });
          this.handleSelectFileFromAssetSource(assetSource);
        }, icon: assetSource.icon || ImageIcon, disabled: readOnly, "data-testid": "file-input-browse-button-".concat(assetSource.name) }, assetSource.name);
      });
    }
    return (0, import_jsx_runtime6.jsx)(WithReferencedAsset, { reference: asset, observeAsset, waitPlaceholder: (0, import_jsx_runtime6.jsx)(FileSkeleton$1, {}), children: (_ref204) => {
      let { originalFilename, extension, url, size: size2 } = _ref204;
      const filename = originalFilename || "download.".concat(extension);
      let copyUrl;
      let downloadUrl;
      if (isFileSource(value)) {
        downloadUrl = "".concat(url, "?dl");
        copyUrl = url;
      }
      return (0, import_jsx_runtime6.jsx)(FileActionsMenu, { size: size2, originalFilename: filename, muted: !readOnly, onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }), isMenuOpen, setMenuButtonElement: this.setBrowseButtonElement, children: (0, import_jsx_runtime6.jsx)(ActionsMenu, { onUpload: this.handleSelectFiles, browse: browseMenuItem, onReset: this.handleRemoveButtonClick, downloadUrl, copyUrl, readOnly, accept, directUploads }) });
    } });
  }
  renderAssetMenu(tone) {
    const { schemaType, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props;
    const { hoveringFiles } = this.state;
    const acceptedFiles = hoveringFiles.filter((file2) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file2));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return (0, import_jsx_runtime6.jsx)(CardOverlay, { tone, children: (0, import_jsx_runtime6.jsx)(FlexContainer$1, { align: "center", justify: "center", gap: 2, flex: 1, children: (0, import_jsx_runtime6.jsx)(PlaceholderText, { readOnly, hoveringFiles, acceptedFiles, rejectedFilesCount, directUploads, type: "file" }) }) });
  }
  renderBrowser() {
    const { assetSources, readOnly, directUploads, id: id4, t: t3 } = this.props;
    if (assetSources.length === 0)
      return null;
    if (assetSources.length > 1 && !readOnly && directUploads) {
      return (0, import_jsx_runtime6.jsx)(MenuButton, { id: "".concat(id4, "_assetFileButton"), ref: this.setBrowseButtonElement, button: (0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", text: t3("inputs.file.multi-browse-button.text"), "data-testid": "file-input-multi-browse-button", icon: SearchIcon }), "data-testid": "input-select-button", menu: (0, import_jsx_runtime6.jsx)(Menu, { children: assetSources.map((assetSource) => {
        return (0, import_jsx_runtime6.jsx)(MenuItem, { text: assetSource.title, onClick: () => {
          this.setState({ isMenuOpen: false });
          this.handleSelectFileFromAssetSource(assetSource);
        }, icon: assetSource.icon || ImageIcon, disabled: readOnly, "data-testid": "file-input-browse-button-".concat(assetSource.name) }, assetSource.name);
      }) }) });
    }
    return (0, import_jsx_runtime6.jsx)(Button, { fontSize: 2, text: t3("inputs.file.browse-button.text"), icon: SearchIcon, mode: "ghost", onClick: () => {
      this.setState({ isMenuOpen: false });
      this.handleSelectFileFromAssetSource(assetSources[0]);
    }, "data-testid": "file-input-browse-button", disabled: readOnly, ref: this.setBrowseButtonElement });
  }
  renderUploadPlaceholder() {
    const { readOnly, schemaType, directUploads, resolveUploader: resolveUploader2 } = this.props;
    const { hoveringFiles } = this.state;
    const acceptedFiles = hoveringFiles.filter((file2) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file2));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    const accept = (0, import_get3.default)(schemaType, "options.accept", "");
    return (0, import_jsx_runtime6.jsx)("div", { style: { padding: 1 }, children: (0, import_jsx_runtime6.jsx)(Card, { tone: readOnly ? "transparent" : "inherit", border: true, padding: 3, style: hoveringFiles.length === 0 ? { borderStyle: "dashed" } : { borderStyle: "dashed", borderColor: "transparent" }, children: (0, import_jsx_runtime6.jsx)(UploadPlaceholder, { browse: this.renderBrowser(), onUpload: this.handleSelectFiles, readOnly, hoveringFiles, acceptedFiles, rejectedFilesCount, type: "file", accept, directUploads }) }) });
  }
  getFileTone() {
    const { directUploads, schemaType, value, readOnly, resolveUploader: resolveUploader2 } = this.props;
    const { hoveringFiles } = this.state;
    const acceptedFiles = hoveringFiles.filter((file2) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file2));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    if (hoveringFiles.length > 0) {
      if (rejectedFilesCount > 0 || !directUploads) {
        return "critical";
      }
    }
    if (!(value == null ? void 0 : value._upload) && !readOnly && hoveringFiles.length > 0) {
      return "primary";
    }
    return (value == null ? void 0 : value._upload) && (value == null ? void 0 : value.asset) && readOnly ? "transparent" : "default";
  }
  render() {
    const { members, renderAnnotation, renderBlock, renderInlineBlock, renderItem, renderInput, renderField, renderPreview, t: t3 } = this.props;
    const { selectedAssetSource } = this.state;
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(ImperativeToast, { ref: this.setToast }), members.map((member) => {
      if (member.kind === "field" && (member.name === "crop" || member.name === "hotspot")) {
        return null;
      }
      if (member.kind === "field") {
        return (0, import_jsx_runtime6.jsx)(MemberField, { member, renderAnnotation, renderInlineBlock, renderBlock, renderInput: member.name === "asset" ? this.renderAsset() : renderInput, renderField: member.name === "asset" ? passThrough$1 : renderField, renderItem, renderPreview }, member.key);
      }
      if (member.kind === "fieldSet") {
        return (0, import_jsx_runtime6.jsx)(MemberFieldSet, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }, member.key);
      }
      if (member.kind === "error") {
        return (0, import_jsx_runtime6.jsx)(MemberFieldError, { member }, member.key);
      }
      return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.file.error.unknown-member-kind", { kind: member.kind }) });
    }), selectedAssetSource && this.renderAssetSource()] });
  }
};
function StudioFileInput(props2) {
  var _a4;
  const sourcesFromSchema = (_a4 = props2.schemaType.options) == null ? void 0 : _a4.sources;
  const documentPreviewStore = useDocumentPreviewStore();
  const { file: fileConfig } = useFormBuilder().__internal;
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const { t: t3 } = useTranslation2();
  const resolveUploader$1 = (0, import_react51.useCallback)((type, file2) => {
    if (!fileConfig.directUploads) {
      return null;
    }
    return resolveUploader(type, file2);
  }, [fileConfig.directUploads]);
  const assetSources = (0, import_react51.useMemo)(() => sourcesFromSchema || fileConfig.assetSources, [fileConfig, sourcesFromSchema]);
  const observeAsset = (0, import_react51.useCallback)((id4) => observeFileAsset(documentPreviewStore, id4), [documentPreviewStore]);
  return (0, import_jsx_runtime6.jsx)(BaseFileInput, { ...props2, t: t3, client, assetSources, directUploads: fileConfig.directUploads, observeAsset, resolveUploader: resolveUploader$1 });
}
var __freeze$1t = Object.freeze;
var __defProp$1t = Object.defineProperty;
var __template$1t = (cooked, raw) => __freeze$1t(__defProp$1t(cooked, "raw", { value: __freeze$1t(raw || cooked.slice()) }));
var _a$1t;
var RatioBox$1 = st(Box)(_a$1t || (_a$1t = __template$1t(["\n  position: relative;\n  padding-bottom: calc(", " * 100%);\n\n  & > div {\n    position: absolute;\n    top: ", "px;\n    left: ", "px;\n    right: ", "px;\n    bottom: ", "px;\n  }\n"])), (_ref205) => {
  let { ratio = 3 / 2 } = _ref205;
  return 1 / ratio;
}, (_ref206) => {
  let { padding = 0 } = _ref206;
  return padding;
}, (_ref207) => {
  let { padding = 0 } = _ref207;
  return padding;
}, (_ref208) => {
  let { padding = 0 } = _ref208;
  return padding;
}, (_ref209) => {
  let { padding = 0 } = _ref209;
  return padding;
});
function ImageLoader(props2) {
  const { src, children } = props2;
  const [isLoading, setIsLoading] = (0, import_react51.useState)(true);
  const [image2, setImage] = (0, import_react51.useState)(null);
  const [error2, setError] = (0, import_react51.useState)(null);
  (0, import_react51.useEffect)(() => {
    setImage(null);
    setError(null);
    setIsLoading(true);
    const image22 = new Image();
    image22.onload = () => {
      setImage(image22);
      setError(null);
      setIsLoading(false);
    };
    image22.onerror = () => {
      setError(new Error("Could not load image from ".concat(JSON.stringify(src))));
      setIsLoading(false);
    };
    image22.referrerPolicy = "strict-origin-when-cross-origin";
    image22.src = src;
  }, [src]);
  return children({ image: image2, error: error2, isLoading });
}
var testProperties = ["", "webkit", "moz", "ms", "o"].map((prefix) => "".concat(prefix, "backingStoreRatio"));
var foundProperty = -1;
function getBackingStoreRatio(context) {
  if (foundProperty === -1) {
    foundProperty = testProperties.find((testProperty) => testProperty in context);
  }
  return foundProperty && context[foundProperty];
}
function isPointInEllipse(point, ellipse) {
  const center = { x: ellipse.center.x, y: ellipse.center.y };
  const xradius = ellipse.width / 2;
  const yradius = ellipse.height / 2;
  if (xradius <= 0 || yradius <= 0) {
    return false;
  }
  const normalized = { x: point.x - center.x, y: point.y - center.y };
  return Math.pow(normalized.x, 2) / Math.pow(xradius, 2) + Math.pow(normalized.y, 2) / Math.pow(yradius, 2) <= 1;
}
function isPointInCircle(_ref210, circle) {
  let { x, y } = _ref210;
  return Math.pow(x - circle.x, 2) + Math.pow(y - circle.y, 2) < Math.pow(circle.radius, 2);
}
function isPointInRect(point, rect) {
  return point.x >= rect.left && point.x <= rect.left + rect.width && point.y >= rect.top && point.y <= rect.top + rect.height;
}
function getPointAtCircumference(radians, ellipse) {
  return { x: ellipse.center.x - ellipse.width / 2 * Math.cos(radians), y: ellipse.center.y - ellipse.height / 2 * Math.sin(radians) };
}
var Point = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
};
var HLine = class {
  constructor(y, left, right) {
    this.y = y;
    this._left = left;
    this._right = right;
  }
  get right() {
    return new Point(this._right, this.y);
  }
  get left() {
    return new Point(this._left, this.y);
  }
  get length() {
    return this._right - this._left;
  }
};
var Corners = class {
  constructor(rect) {
    this.rect = rect;
  }
  get top() {
    return new HLine(this.rect.top, this.rect.left, this.rect.right);
  }
  get bottom() {
    return new HLine(this.rect.bottom, this.rect.left, this.rect.right);
  }
};
var Rect = class _Rect {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static fromEdges(_ref211) {
    let { left, right, top, bottom: bottom2 } = _ref211;
    return new _Rect(left, top, 1 - left - right, 1 - top - bottom2);
  }
  constructor() {
    let left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let width = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  setTopLeft(left, top) {
    return new _Rect(left, top, this.width || 0, this.height || 0);
  }
  setSize(width, height) {
    return new _Rect(this.left || 0, this.top || 0, width, height);
  }
  setCenter(x, y) {
    const width = this.width || 0;
    const height = this.height || 0;
    return new _Rect(x - width / 2, y - height / 2, width || 0, height || 0);
  }
  get center() {
    return new Point(this.left + this.width / 2, this.top + this.height / 2);
  }
  get corners() {
    return new Corners(this);
  }
  get right() {
    return this.left + this.width;
  }
  get bottom() {
    return this.top + this.height;
  }
  multiply(rect) {
    return new _Rect((this.left || 0) + this.width * rect.left, (this.top || 0) + this.height * rect.top, this.width * rect.width, this.height * rect.height);
  }
  grow(delta2) {
    return new _Rect(this.left - delta2, this.top - delta2, this.width + delta2 * 2, this.height + delta2 * 2);
  }
  shrink(delta2) {
    return this.grow(-delta2);
  }
  cropRelative(crop) {
    const top = this.top + crop.top * this.height;
    const left = this.left + crop.left * this.width;
    const height = this.height * crop.height;
    const width = this.width * crop.width;
    return new _Rect(left, top, width, height);
  }
  clamp(bounds) {
    let { left, top, width, height } = this;
    if (bounds.width < width) {
      width = bounds.width;
      left = bounds.left;
    }
    if (bounds.height < height) {
      height = bounds.height;
      top = bounds.top;
    }
    if (left + width > bounds.left + bounds.width) {
      left = bounds.right - width;
    }
    if (top + height > bounds.top + bounds.height) {
      top = bounds.bottom - height;
    }
    return new _Rect(Math.max(left, bounds.left), Math.max(top, bounds.top), width, height);
  }
};
var debug$22 = (0, import_debug5.default)("sanity-imagetool");
function makeDragAware(Component3) {
  return class DragAware extends import_react51.default.PureComponent {
    constructor() {
      super(...arguments);
      this.domNode = null;
      this.currentPos = null;
      this.isDragging = false;
      this.handleDragStart = (event) => {
        const { onDragStart, readOnly } = this.props;
        if (readOnly || !this.domNode) {
          return;
        }
        if (this.isDragging) {
          debug$22("Start cancelled, already a drag in progress");
          return;
        }
        this.isDragging = true;
        const nextPos = getPos(event);
        debug$22("Drag started %o", nextPos);
        onDragStart(getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect()));
        this.currentPos = nextPos;
      };
      this.handleDrag = (event) => {
        if (!this.isDragging || this.props.readOnly || !this.currentPos) {
          return;
        }
        const { onDrag } = this.props;
        const nextPos = getPos(event);
        const diff4 = diffPos(nextPos, this.currentPos);
        onDrag(diff4);
        debug$22("moving by %o", diff4);
        this.currentPos = nextPos;
      };
      this.handleDragEnd = (event) => {
        const { onDragEnd, readOnly } = this.props;
        if (!this.isDragging || readOnly || !this.domNode) {
          return;
        }
        const nextPos = getPos(event);
        onDragEnd(getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect()));
        this.isDragging = false;
        this.currentPos = null;
        debug$22("Done moving %o", nextPos);
      };
      this.handleDragCancel = () => {
        if (!this.isDragging || this.props.readOnly || !this.currentPos || !this.domNode) {
          return;
        }
        const { onDragEnd } = this.props;
        this.isDragging = false;
        onDragEnd(getPositionRelativeToRect(this.currentPos.x, this.currentPos.y, this.domNode.getBoundingClientRect()));
        this.currentPos = null;
      };
      this.setDomNode = (node) => {
        this.domNode = node;
      };
    }
    componentDidMount() {
      document.body.addEventListener("pointermove", this.handleDrag);
      document.body.addEventListener("pointerup", this.handleDragEnd);
      document.body.addEventListener("pointerleave", this.handleDragCancel);
      document.body.addEventListener("pointercancel", this.handleDragCancel);
    }
    componentWillUnmount() {
      document.body.removeEventListener("pointermove", this.handleDrag);
      document.body.removeEventListener("pointerup", this.handleDragEnd);
      document.body.removeEventListener("pointerleave", this.handleDragCancel);
      document.body.removeEventListener("pointercancel", this.handleDragCancel);
    }
    render() {
      const { readOnly, onDragStart, onDragEnd, onDrag, ...rest } = this.props;
      return (0, import_jsx_runtime6.jsx)(Component3, { ref: this.setDomNode, onPointerDown: readOnly ? void 0 : this.handleDragStart, onPointerMove: readOnly ? void 0 : this.handleDrag, ...rest });
    }
  };
}
function getPositionRelativeToRect(x, y, rect) {
  return { x: x - rect.left, y: y - rect.top };
}
function getPos(event) {
  return { x: event.clientX, y: event.clientY };
}
function diffPos(pos, otherPos) {
  return { x: pos.x - otherPos.x, y: pos.y - otherPos.y };
}
var __freeze$1s = Object.freeze;
var __defProp$1s = Object.defineProperty;
var __template$1s = (cooked, raw) => __freeze$1s(__defProp$1s(cooked, "raw", { value: __freeze$1s(raw || cooked.slice()) }));
var _a$1s;
var _b$H;
var DragAwareCanvas = makeDragAware("canvas");
var RootContainer = st.div(_a$1s || (_a$1s = __template$1s(["\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n"])));
var CanvasContainer = st(DragAwareCanvas)(_b$H || (_b$H = __template$1s(["\n  display: block;\n  position: relative;\n  max-width: calc(100% - 0.5em); /* to prevent overlap with change bar */\n  max-height: calc(100% + 1em);\n  user-select: none;\n  // Enable only multi-finger panning and zooming within this element.\n  // This prevents single finger panning when manipulating drag handles,\n  // which can cause unwanted scrolling in the underlying document body.\n  touch-action: pinch-zoom;\n"])));
var OPEN_HAND = "data:image/png;base64,AAACAAEAICACAAcABQAwAQAAFgAAACgAAAAgAAAAQAAAAAEAAQAAAAAAAAEAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAfwAAAP+AAAH/gAAB/8AAA//AAAd/wAAGf+AAAH9gAADbYAAA2yAAAZsAAAGbAAAAGAAAAAAAAA//////////////////////////////////////////////////////////////////////////////////////gH///4B///8Af//+AD///AA///wAH//4AB//8AAf//AAD//5AA///gAP//4AD//8AF///AB///5A////5///8=";
var CLOSE_HAND = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAABdSURBVEjH7ZA7DsAwCEMN6v2vTCdESpLKQRl5gxfzMQDNRQyWlEK83QAIRh3cH/QbIhQwMDl8gORl7A16WD/xxAdq6N6SgycKUblf41+wbFBT44RiCi11NU3TLHgBxRUUD4ITqnIAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDEtMjFUMDA6MTM6NDMrMDE6MDC74T7AAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEyLTA0LTAyVDA0OjEzOjM3KzAyOjAwQJ35wQAAAABJRU5ErkJggg==";
var DEFAULT_HOTSPOT = { x: 0.5, y: 0.5, height: 1, width: 1 };
var DEFAULT_CROP = { top: 0, left: 0, right: 0, bottom: 0 };
var MARGIN_PX = 8;
var CROP_HANDLE_SIZE = 12;
var HOTSPOT_HANDLE_SIZE = 10;
function normalizeRect(rect) {
  const flippedY = rect.top > rect.bottom;
  const flippedX = rect.left > rect.right;
  return { top: flippedY ? rect.bottom : rect.top, bottom: flippedY ? rect.top : rect.bottom, left: flippedX ? rect.right : rect.left, right: flippedX ? rect.left : rect.right };
}
function checkCropBoundaries(value, delta2) {
  if (!value || !value.crop || value.crop.top + delta2.top < 0 || value.crop.left + delta2.left < 0 || value.crop.right + delta2.right < 0 || value.crop.bottom + delta2.bottom < 0) {
    return false;
  }
  return true;
}
function limitToBoundaries(value, delta2) {
  const { top, right, bottom: bottom2, left } = value.crop || DEFAULT_CROP;
  const newValue = { hotspot: value.hotspot, crop: { top: top + (delta2.top || 0) > 0 ? top : 0, right: right + (delta2.right || 0) > 0 ? right : 0, bottom: bottom2 + (delta2.bottom || 0) > 0 ? bottom2 : 0, left: left + (delta2.left || 0) > 0 ? left : 0 } };
  const newDelta = { top: top + (delta2.top || 0) > 0 ? delta2.top || 0 : 0, right: right + (delta2.right || 0) > 0 ? delta2.right || 0 : 0, bottom: bottom2 + (delta2.bottom || 0) > 0 ? delta2.bottom || 0 : 0, left: left + (delta2.left || 0) > 0 ? delta2.left || 0 : 0 };
  return { value: newValue, delta: newDelta };
}
function getCropCursorForHandle(handle) {
  switch (handle) {
    case "left":
    case "right":
      return "col-resize";
    case "top":
    case "bottom":
      return "row-resize";
    case "topRight":
    case "bottomLeft":
      return "nesw-resize";
    case "topLeft":
    case "bottomRight":
      return "nwse-resize";
    default:
      return null;
  }
}
var getDevicePixelRatio$1 = (0, import_memoize.default)(() => {
  const devicePixelRatio2 = window.devicePixelRatio || 1;
  const ctx = document.createElement("canvas").getContext("2d");
  const backingStoreRatio = ctx && getBackingStoreRatio(ctx) || 1;
  return devicePixelRatio2 / backingStoreRatio;
});
var cropHandleKeys = ["left", "right", "top", "topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"];
var ToolCanvas = class extends import_react51.default.PureComponent {
  constructor() {
    super(...arguments);
    this.state = { cropping: false, cropMoving: false, moving: false, resizing: false, pointerPosition: null };
    this.handleDragStart = (_ref212) => {
      let { x, y } = _ref212;
      const pointerPosition = { x: x * this.getScale(), y: y * this.getScale() };
      const inHotspot = isPointInEllipse(pointerPosition, this.getHotspotRect());
      const inDragHandle = isPointInCircle(pointerPosition, this.getDragHandleCoords());
      const activeCropHandle = this.getActiveCropHandleFor(pointerPosition);
      const inCropRect = isPointInRect(pointerPosition, this.getCropRect());
      if (activeCropHandle) {
        this.setState({ cropping: activeCropHandle });
      } else if (inDragHandle) {
        this.setState({ resizing: true });
      } else if (inHotspot) {
        this.setState({ moving: true });
      } else if (inCropRect) {
        this.setState({ cropMoving: true });
      }
    };
    this.handleDrag = (pos) => {
      if (this.state.cropping) {
        this.emitCrop(this.state.cropping, pos);
      } else if (this.state.cropMoving) {
        this.emitCropMove(pos);
      } else if (this.state.moving) {
        this.emitMove(pos);
      } else if (this.state.resizing) {
        this.emitResize(pos);
      }
    };
    this.handleDragEnd = () => {
      const { onChange, onChangeEnd } = this.props;
      this.setState({ moving: false, resizing: false, cropping: false, cropMoving: false });
      const { hotspot, crop: rawCrop } = this.getClampedValue();
      const crop = normalizeRect(rawCrop);
      const finalValue = { crop: { top: crop.top, bottom: 1 - crop.bottom, left: crop.left, right: 1 - crop.right }, hotspot: { x: hotspot.center.x, y: hotspot.center.y, height: Math.abs(hotspot.height), width: Math.abs(hotspot.width) } };
      onChange(finalValue);
      if (onChangeEnd) {
        onChangeEnd(finalValue);
      }
    };
    this.handlePointerOut = () => {
      this.setState({ pointerPosition: null });
    };
    this.handlePointerMove = (event) => {
      const clientRect = event.currentTarget.getBoundingClientRect();
      this.setState({ pointerPosition: { x: (event.clientX - clientRect.left) * this.getScale(), y: (event.clientY - clientRect.top) * this.getScale() } });
    };
    this.setCanvas = (node) => {
      this.canvas = node;
    };
  }
  getHotspotRect() {
    const { value, image: image2 } = this.props;
    const hotspot = value.hotspot || DEFAULT_HOTSPOT;
    const hotspotRect = new Rect().setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y);
    return new Rect().setSize(image2.width, image2.height).shrink(MARGIN_PX * this.getScale()).multiply(hotspotRect);
  }
  getCropRect() {
    const { value, image: image2 } = this.props;
    return new Rect().setSize(image2.width, image2.height).shrink(MARGIN_PX * this.getScale()).cropRelative(Rect.fromEdges(value.crop || DEFAULT_CROP).clamp(new Rect(0, 0, 1, 1)));
  }
  getCropHandles() {
    const inner = this.getCropRect();
    const handleSize = CROP_HANDLE_SIZE * this.getScale();
    const halfCropHandleSize = handleSize / 2;
    const cropHandle = new Rect(0, 0, handleSize, handleSize);
    return { left: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.center.y - halfCropHandleSize), right: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.center.y - halfCropHandleSize), top: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.top - halfCropHandleSize), topLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.top - halfCropHandleSize), topRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.top - halfCropHandleSize), bottom: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.bottom - halfCropHandleSize), bottomLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.bottom - halfCropHandleSize), bottomRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.bottom - halfCropHandleSize) };
  }
  getActiveCropHandleFor(_ref213) {
    let { x, y } = _ref213;
    const cropHandles = this.getCropHandles();
    for (const position of cropHandleKeys) {
      if (isPointInRect({ x, y }, cropHandles[position])) {
        return position;
      }
    }
    return false;
  }
  emitMove(pos) {
    const { image: image2, value, onChange } = this.props;
    const scale2 = this.getScale();
    const delta2 = { x: pos.x * scale2 / image2.width, y: pos.y * scale2 / image2.height };
    onChange(applyHotspotMoveBy(value, delta2));
  }
  emitCropMove(pos) {
    const { image: image2, onChange, value } = this.props;
    const scale2 = this.getScale();
    const left = pos.x * scale2 / image2.width;
    const right = -pos.x * scale2 / image2.width;
    const top = pos.y * scale2 / image2.height;
    const bottom2 = -pos.y * scale2 / image2.height;
    const delta2 = { left, right, top, bottom: bottom2 };
    if (checkCropBoundaries(value, delta2)) {
      onChange(applyCropMoveBy(value, delta2));
    }
  }
  emitCrop(side, pos) {
    const { image: image2, onChange, value } = this.props;
    const scale2 = this.getScale();
    let left = 0;
    let right = 0;
    let top = 0;
    let bottom2 = 0;
    if (side == "left" || side === "topLeft" || side === "bottomLeft") {
      left = pos.x * scale2 / image2.width;
    } else if (side == "right" || side === "topRight" || side === "bottomRight") {
      right = -pos.x * scale2 / image2.width;
    }
    if (side == "top" || side === "topLeft" || side === "topRight") {
      top = pos.y * scale2 / image2.height;
    } else if (side == "bottom" || side === "bottomLeft" || side === "bottomRight") {
      bottom2 = -pos.y * scale2 / image2.height;
    }
    const delta2 = { left, right, top, bottom: bottom2 };
    const newValue = limitToBoundaries(value, delta2).value;
    const newDelta = limitToBoundaries(value, delta2).delta;
    onChange(applyCropMoveBy(newValue, newDelta));
  }
  emitResize(pos) {
    const { image: image2, onChange, value } = this.props;
    const scale2 = this.getScale();
    const delta2 = { x: pos.x * scale2 * 2 / image2.width, y: pos.y * scale2 * 2 / image2.height };
    onChange(applyHotspotResizeBy(value, { height: delta2.y, width: delta2.x }));
  }
  getClampedValue() {
    const value = this.props.value;
    const crop = Rect.fromEdges(value.crop || DEFAULT_CROP).clamp(new Rect(0, 0, 1, 1));
    const hotspot = value.hotspot || DEFAULT_HOTSPOT;
    const hotspotRect = new Rect(0, 0, 1, 1).setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y).clamp(crop);
    return { crop, hotspot: hotspotRect };
  }
  paintHotspot(context, opacity) {
    const { image: image2, readOnly } = this.props;
    const imageRect = new Rect().setSize(image2.width, image2.height);
    const { hotspot, crop } = this.getClampedValue();
    const scale2 = this.getScale();
    const margin = MARGIN_PX * scale2;
    context.save();
    drawBackdrop();
    drawEllipse();
    context.clip();
    drawHole();
    context.restore();
    if (!readOnly) {
      drawDragHandle(Math.PI * 1.25);
    }
    function drawEllipse() {
      context.save();
      const dest = imageRect.shrink(margin).multiply(hotspot);
      const scaleY = dest.height / dest.width;
      context.scale(1, scaleY);
      context.beginPath();
      context.globalAlpha = opacity;
      context.arc(dest.center.x, dest.center.y / scaleY, Math.abs(dest.width / 2), 0, 2 * Math.PI, false);
      context.strokeStyle = "white";
      context.lineWidth = 1.5 * scale2;
      context.stroke();
      context.closePath();
      context.restore();
    }
    function drawImage(srcLeft, srcTop, srcWidth, srcHeight, destLeft, destTop, destWidth, destHeight) {
      context.save();
      context.drawImage(image2, srcLeft, srcTop, srcWidth, srcHeight, destLeft, destTop, destWidth, destHeight);
      context.restore();
    }
    function drawHole() {
      const src = imageRect.multiply(hotspot);
      const dest = imageRect.shrink(margin).multiply(hotspot);
      drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
    }
    function drawBackdrop() {
      const src = imageRect.cropRelative(crop);
      const dest = imageRect.shrink(margin).cropRelative(crop);
      context.save();
      drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
      context.globalAlpha = 0.5;
      context.fillStyle = "black";
      context.fillRect(dest.left, dest.top, dest.width, dest.height);
      context.restore();
    }
    function drawDragHandle(radians) {
      context.save();
      const radius = HOTSPOT_HANDLE_SIZE * scale2;
      const dest = imageRect.shrink(margin).multiply(hotspot);
      const point = getPointAtCircumference(radians, dest);
      context.beginPath();
      context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
      context.fillStyle = "rgb(255,255,255)";
      context.fill();
      context.closePath();
      context.restore();
      context.beginPath();
      context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
      context.strokeStyle = "rgb(0, 0, 0)";
      context.lineWidth = 0.5 * scale2;
      context.stroke();
      context.closePath();
    }
  }
  getActualSize() {
    var _a4;
    const node = (_a4 = this.canvas) == null ? void 0 : _a4.domNode;
    return node ? { height: node.clientHeight, width: node.clientWidth } : { height: 0, width: 0 };
  }
  getDragHandleCoords() {
    const bbox = this.getHotspotRect();
    const point = getPointAtCircumference(Math.PI * 1.25, bbox);
    return { x: point.x, y: point.y, radius: 8 * this.getScale() };
  }
  debug(context) {
    context.save();
    const { image: image2 } = this.props;
    const bbox = this.getHotspotRect();
    const scale2 = this.getScale();
    const margin = MARGIN_PX * scale2;
    if (context.setLineDash) {
      context.setLineDash([2 * scale2, 2 * scale2]);
    }
    context.lineWidth = 0.5 * scale2;
    context.strokeStyle = "rgba(200, 200, 200, 0.5)";
    vline(bbox.center.x);
    hline(bbox.center.y);
    context.strokeStyle = "rgba(150, 150, 150, 0.5)";
    hline(bbox.top);
    hline(bbox.bottom);
    vline(bbox.left);
    vline(bbox.right);
    context.restore();
    function vline(x) {
      line(x, margin, x, image2.height - margin);
    }
    function hline(y) {
      line(margin, y, image2.width - margin, y);
    }
    function line(x1, y1, x2, y2) {
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      context.stroke();
      context.closePath();
    }
  }
  paintBackground(context) {
    const { image: image2 } = this.props;
    const inner = new Rect().setSize(image2.width, image2.height).shrink(MARGIN_PX * this.getScale());
    context.save();
    context.fillStyle = "white";
    context.clearRect(0, 0, image2.width, image2.height);
    context.globalAlpha = 0.3;
    context.drawImage(image2, inner.left, inner.top, inner.width, inner.height);
    context.restore();
  }
  paint(context) {
    const { readOnly } = this.props;
    context.save();
    const pxratio = getDevicePixelRatio$1();
    context.scale(pxratio, pxratio);
    const opacity = !readOnly && this.state.pointerPosition ? 0.8 : 0.2;
    this.paintBackground(context);
    this.paintHotspot(context, opacity);
    this.debug(context);
    this.paintCropBorder(context);
    if (!readOnly) {
      this.highlightCropHandles(context, opacity);
    }
    context.restore();
  }
  paintPointerPosition(context) {
    if (!this.state.pointerPosition) {
      return;
    }
    const { x, y } = this.state.pointerPosition;
    context.beginPath();
    context.arc(x, y, 14 * this.getScale(), 0, 2 * Math.PI, false);
    context.fillStyle = "lightblue";
    context.fill();
    context.restore();
  }
  paintCropBorder(context) {
    const cropRect = this.getCropRect();
    context.save();
    context.beginPath();
    context.fillStyle = "rgba(66, 66, 66, 0.9)";
    context.lineWidth = 1;
    context.rect(cropRect.left, cropRect.top, cropRect.width, cropRect.height);
    context.stroke();
    context.closePath();
    context.restore();
  }
  highlightCropHandles(context, opacity) {
    context.save();
    const cropHandles = this.getCropHandles();
    cropHandleKeys.forEach((handle) => {
      context.fillStyle = this.state.cropping === handle ? "rgba(202, 54, 53, ".concat(opacity, ")") : "rgba(230, 230, 230, ".concat(opacity + 0.4, ")");
      const { left, top, height, width } = cropHandles[handle];
      context.fillRect(left, top, width, height);
      context.beginPath();
      context.fillStyle = "rgba(66, 66, 66, ".concat(opacity, ")");
      context.rect(left, top, width, height);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  getScale() {
    const actualSize = this.getActualSize();
    return this.props.image.width / actualSize.width;
  }
  getCursor() {
    const { pointerPosition } = this.state;
    const { readOnly } = this.props;
    if (!pointerPosition || readOnly) {
      return "auto";
    }
    const activeCropArea = this.state.cropping || this.getActiveCropHandleFor(pointerPosition);
    if (activeCropArea) {
      return getCropCursorForHandle(activeCropArea) || "auto";
    }
    const pointerOverDragHandle = isPointInCircle(pointerPosition, this.getDragHandleCoords());
    if (this.state.resizing || pointerOverDragHandle) {
      return "move";
    }
    if (this.state.moving || this.state.cropMoving) {
      return "url(".concat(CLOSE_HAND, "), move");
    }
    const pointerOverHotspot = isPointInEllipse(pointerPosition, this.getHotspotRect());
    const pointerOverCropRect = isPointInRect(pointerPosition, this.getCropRect());
    if (pointerOverHotspot || pointerOverCropRect) {
      return "url(".concat(OPEN_HAND, "), move");
    }
    return "auto";
  }
  componentDidMount() {
    this.draw();
  }
  componentDidUpdate() {
    this.draw();
  }
  draw() {
    if (!this.canvas) {
      return;
    }
    const domNode = this.canvas.domNode;
    const context = domNode.getContext("2d");
    if (!context) {
      return;
    }
    this.paint(context);
    const currentCursor = domNode.style.cursor;
    const newCursor = this.getCursor();
    if (currentCursor !== newCursor) {
      domNode.style.cursor = newCursor;
    }
  }
  render() {
    const { image: image2, readOnly } = this.props;
    const ratio = getDevicePixelRatio$1();
    return (0, import_jsx_runtime6.jsx)(RootContainer, { children: (0, import_jsx_runtime6.jsx)(CanvasContainer, { readOnly, ref: this.setCanvas, onDrag: this.handleDrag, onDragStart: this.handleDragStart, onDragEnd: this.handleDragEnd, onPointerMove: this.handlePointerMove, onPointerOut: this.handlePointerOut, height: image2.height * ratio, width: image2.width * ratio }) });
  }
};
function applyHotspotMoveBy(value, delta2) {
  const currentHotspot = value && value.hotspot || DEFAULT_HOTSPOT;
  return { ...value, hotspot: { ...currentHotspot, x: currentHotspot.x + delta2.x, y: currentHotspot.y + delta2.y } };
}
function applyHotspotResizeBy(value, delta2) {
  const currentHotspot = value && value.hotspot || DEFAULT_HOTSPOT;
  return { ...value, hotspot: { ...currentHotspot, height: currentHotspot.height + delta2.height, width: currentHotspot.width + delta2.width } };
}
function applyCropMoveBy(value, delta2) {
  const currentCrop = value && value.crop || DEFAULT_CROP;
  return { ...value, crop: { left: currentCrop.left + (delta2.left || 0), right: currentCrop.right + (delta2.right || 0), top: currentCrop.top + (delta2.top || 0), bottom: currentCrop.bottom + (delta2.bottom || 0) } };
}
function Resize(props2) {
  const { image: image2, maxHeight, maxWidth, children } = props2;
  const [canvas] = (0, import_react51.useState)(() => {
    const canvasElement = document.createElement("canvas");
    canvasElement.style.display = "none";
    return canvasElement;
  });
  (0, import_react51.useEffect)(() => {
    document.body.appendChild(canvas);
    return () => {
      document.body.removeChild(canvas);
    };
  }, [canvas]);
  const resize2 = (0, import_react51.useCallback)((image22, maxHeight2, maxWidth2) => {
    const ratio = image22.width / image22.height;
    const width = Math.min(image22.width, maxWidth2);
    const height = Math.min(image22.height, maxHeight2);
    const landscape = image22.width > image22.height;
    const targetWidth = landscape ? width : height * ratio;
    const targetHeight = landscape ? width / ratio : height;
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      ctx.drawImage(image22, 0, 0, image22.width, image22.height, 0, 0, targetWidth, targetHeight);
    }
    return canvas;
  }, [canvas]);
  return children(resize2(image2, maxHeight, maxWidth));
}
function ImageTool(props2) {
  return (0, import_jsx_runtime6.jsx)(ImageLoader, { src: props2.src, children: (_ref214) => {
    let { isLoading, image: image2, error: error2 } = _ref214;
    if (isLoading) {
      return (0, import_jsx_runtime6.jsx)("div", { children: "Loading..." });
    }
    if (error2) {
      return (0, import_jsx_runtime6.jsx)("div", { children: error2.message });
    }
    if (image2) {
      return (0, import_jsx_runtime6.jsx)(Resize, { image: image2, maxHeight: ImageTool.maxHeight, maxWidth: ImageTool.maxWidth, children: (canvas) => (0, import_jsx_runtime6.jsx)(ToolCanvas, { image: canvas, ...props2 }) });
    }
    return null;
  } });
}
ImageTool.maxHeight = 500;
ImageTool.maxWidth = 1e3;
function calculateStyles() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const imageAspect = readAspectRatio(options.image) || 1;
  const hotspot = options.hotspot || DEFAULT_HOTSPOT;
  const crop = options.crop || DEFAULT_CROP;
  const containerAspect = readAspectRatio(options.container) || imageAspect * readCropAspect(crop);
  const align2 = options.align || { x: "center", y: "center" };
  const result = calculateHotSpotCrop(imageAspect, { hotspot, crop }, { aspect: containerAspect, align: align2 });
  const containerHeight = styleFormat(round2(100 / containerAspect));
  return { debug: { result }, container: {
    //outline: '1px solid cyan',
    overflow: "hidden",
    position: "relative",
    width: "100%",
    height: containerHeight
  }, padding: { marginTop: containerHeight }, crop: { position: "absolute", overflow: "hidden", height: toStylePercentage(result.crop.height), width: toStylePercentage(result.crop.width), top: toStylePercentage(result.crop.top), left: toStylePercentage(result.crop.left) }, image: { position: "absolute", height: toStylePercentage(result.image.height), width: toStylePercentage(result.image.width), top: toStylePercentage(result.image.top), left: toStylePercentage(result.image.left) } };
}
function readAspectRatio(opts) {
  if (!opts) {
    return null;
  }
  if ("aspectRatio" in opts) {
    return opts.aspectRatio;
  }
  if ("height" in opts || "width" in opts) {
    if (typeof opts.height !== "number" && typeof opts.width !== "number") {
      throw new Error("Height and width must be numbers, got ".concat(JSON.stringify(opts)));
    }
    return opts.width / opts.height;
  }
  return null;
}
function round2(num) {
  let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  const multiplier = Math.pow(10, decimals);
  return Math.round(num * multiplier) / multiplier;
}
function calculateHotSpotCrop(sourceAspect, descriptor, spec) {
  const crop = descriptor.crop;
  const viewportAspect = spec.aspect;
  const alignment = spec.align;
  const netWidth = 1 - crop.left - crop.right;
  const netHeight = 1 - crop.top - crop.bottom;
  const outImg = { top: -crop.top / netHeight, left: -crop.left / netWidth, width: 1 / netWidth, height: 1 / netHeight };
  const cropRationalAspect = netWidth / netHeight;
  const cropAspect = cropRationalAspect * sourceAspect;
  const hotspot = { x: (descriptor.hotspot.x - crop.left) / netWidth, y: (descriptor.hotspot.y - crop.top) / netHeight, height: descriptor.hotspot.height / netHeight, width: descriptor.hotspot.width / netWidth };
  const maxHotspotXScale = 1 / hotspot.width;
  const maxHotspotYScale = 1 / hotspot.height * cropAspect / viewportAspect;
  const maxScale = Math.min(maxHotspotXScale, maxHotspotYScale);
  let minFullBleedScale;
  const cropIsTaller = cropAspect <= viewportAspect;
  if (cropIsTaller) {
    minFullBleedScale = 1;
  } else {
    minFullBleedScale = cropAspect / viewportAspect;
  }
  let method;
  let outCrop;
  if (minFullBleedScale > maxScale) {
    method = "letterbox";
    let letterboxScale;
    const diff4 = minFullBleedScale - maxScale;
    if (cropIsTaller) {
      letterboxScale = 1 - diff4;
    } else {
      letterboxScale = maxScale;
    }
    outCrop = {
      width: letterboxScale,
      height: letterboxScale / cropAspect * viewportAspect,
      // Gets overwritten further down
      left: 0,
      top: 0
    };
    const hotspotLeft = hotspot.x * outCrop.width - hotspot.width * outCrop.width / 2;
    switch (alignment.x) {
      case "left":
        outCrop.left = cropIsTaller ? 0 : -hotspotLeft;
        break;
      case "right":
        outCrop.left = cropIsTaller ? 1 - outCrop.width : hotspotLeft;
        break;
      case "center":
        outCrop.left = cropIsTaller ? (1 - outCrop.width) / 2 : -hotspotLeft;
        break;
      default:
        throw new Error("Invalid x alignment: '".concat(alignment.x, "'. Must be either 'left', 'right' or 'center'"));
    }
    const hotspotTop = hotspot.y * outCrop.height - hotspot.height * outCrop.height / 2;
    switch (alignment.y) {
      case "top":
        outCrop.top = cropIsTaller ? -hotspotTop : 0;
        break;
      case "bottom":
        outCrop.top = hotspotTop;
        break;
      case "center":
        outCrop.top = cropIsTaller ? -hotspotTop : (1 - outCrop.height) / 2;
        break;
      default:
        throw new Error("Invalid y alignment: '".concat(alignment.y, "'. Must be either 'top', 'bottom' or 'center'"));
    }
  } else if (cropIsTaller) {
    method = "full_width";
    let top = -hotspot.y / cropAspect * viewportAspect + 0.5;
    const height = minFullBleedScale / cropAspect * viewportAspect;
    if (top > 0) {
      top = 0;
    } else if (-top > height - 1) {
      top = -(height - 1);
    }
    outCrop = {
      width: minFullBleedScale,
      height,
      left: 0,
      // Place the Y center of the hotspot near the center of the viewport
      top
    };
  } else {
    method = "full_height";
    const width = minFullBleedScale;
    let left = 0.5 - hotspot.x * minFullBleedScale;
    if (left > 0) {
      left = 0;
    } else if (-left > width - 1) {
      left = -(width - 1);
    }
    outCrop = {
      width,
      height: minFullBleedScale / cropAspect * viewportAspect,
      top: 0,
      // Place the X center of the hotspot at the center of the viewport
      left
    };
  }
  return { method, crop: outCrop, image: outImg };
}
function readCropAspect(crop) {
  const height = 1 - crop.top - crop.bottom;
  const width = 1 - crop.left - crop.right;
  return width / height;
}
function styleFormat(num) {
  return num === 0 ? 0 : "".concat(num, "%");
}
function toStylePercentage(num) {
  return styleFormat(round2(num * 100));
}
var __freeze$1r = Object.freeze;
var __defProp$1r = Object.defineProperty;
var __template$1r = (cooked, raw) => __freeze$1r(__defProp$1r(cooked, "raw", { value: __freeze$1r(raw || cooked.slice()) }));
var _a$1r;
var HotspotImageContainer = st.div(_a$1r || (_a$1r = __template$1r(["\n  position: relative;\n  width: 100%;\n"])));
var debug$13 = (0, import_debug5.default)("sanity-imagetool");
function getCropAspect(crop, srcAspect) {
  const origHeight = 1 / srcAspect;
  const origWidth = srcAspect * origHeight;
  const cropWidth = origWidth - (crop.left + crop.right) * origWidth;
  const cropHeight = origHeight - (crop.top + crop.bottom) * origHeight;
  return cropWidth / cropHeight;
}
var HotspotImage = (0, import_react51.memo)(function HotspotImage2(props2) {
  const { alignX = "center", alignY = "center", alt, aspectRatio: aspectRatio2 = "none", className = "", crop = DEFAULT_CROP, hotspot = DEFAULT_HOTSPOT, onError, onLoad, src, srcAspectRatio, srcSet, style } = props2;
  const [containerAspect, setContainerAspect] = (0, import_react51.useState)(null);
  const containerElementRef = (0, import_react51.useRef)(null);
  const imageElementRef = (0, import_react51.useRef)(null);
  const updateContainerAspect = (0, import_react51.useCallback)(() => {
    if (!containerElementRef.current)
      return;
    if (aspectRatio2 === "auto") {
      const parentNode = containerElementRef.current.parentNode;
      (0, import_react51.startTransition)(() => setContainerAspect(parentNode.offsetWidth / parentNode.offsetHeight));
    } else {
      setContainerAspect(null);
    }
  }, [aspectRatio2]);
  (0, import_react51.useEffect)(() => {
    const imageElement = imageElementRef.current;
    const alreadyLoaded = imageElement && imageElement.src && imageElement.complete && imageElement.naturalWidth !== void 0;
    if (alreadyLoaded) {
      debug$13("Image '%s' already loaded, refreshing (from cache) to trigger onLoad / onError", src);
      imageElement.src = imageElement.src;
    }
    updateContainerAspect();
    window.addEventListener("resize", updateContainerAspect);
    return () => {
      window.removeEventListener("resize", updateContainerAspect);
    };
  }, [src, updateContainerAspect]);
  const targetAspect = (0, import_react51.useMemo)(() => {
    if (aspectRatio2 === "none") {
      return crop ? getCropAspect(crop, srcAspectRatio) : srcAspectRatio;
    }
    if (aspectRatio2 === "auto") {
      return containerAspect;
    }
    return aspectRatio2 || null;
  }, [aspectRatio2, containerAspect, crop, srcAspectRatio]);
  const targetStyles = (0, import_react51.useMemo)(() => calculateStyles({ container: { aspectRatio: targetAspect || srcAspectRatio }, image: { aspectRatio: srcAspectRatio }, hotspot, crop, align: { x: alignX, y: alignY } }), [alignX, alignY, crop, hotspot, srcAspectRatio, targetAspect]);
  return (0, import_jsx_runtime6.jsx)(HotspotImageContainer, { className: "".concat(className), style, ref: containerElementRef, children: (0, import_jsx_runtime6.jsxs)("div", { style: targetStyles.container, children: [(0, import_jsx_runtime6.jsx)("div", { style: targetStyles.padding }), (0, import_jsx_runtime6.jsx)("div", { style: targetStyles.crop, children: (0, import_jsx_runtime6.jsx)("img", { ref: imageElementRef, src, alt, srcSet, onLoad, onError, style: targetStyles.image }) })] }) });
});
var PROBABLY_THE_TINIEST_GIF_EVER = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
function isBlob(src) {
  return src.startsWith("blob:");
}
function loadImage(src) {
  return new Observable((subscriber) => {
    const image2 = document.createElement("img");
    let completed = false;
    const onload = () => {
      completed = true;
      subscriber.next(image2);
      subscriber.complete();
    };
    const onerror = () => {
      completed = true;
      subscriber.error(new Error("Could not load image from ".concat(isBlob(src) ? "blob" : src)));
    };
    image2.onload = onload;
    image2.onerror = onerror;
    image2.src = src;
    return () => {
      image2.onload = null;
      image2.onerror = null;
      if (!completed) {
        image2.src = PROBABLY_THE_TINIEST_GIF_EVER;
      }
    };
  });
}
var INITIAL_STATE$1 = { isLoading: true };
function useLoadImage(url) {
  const [state, setState] = (0, import_react51.useState)(INITIAL_STATE$1);
  (0, import_react51.useEffect)(() => {
    setState(INITIAL_STATE$1);
    const subscription = loadImage(url).subscribe({ error: (err) => {
      setState({ isLoading: false, error: err });
    }, next: (image2) => {
      setState({ image: image2, isLoading: false });
    } });
    return () => {
      subscription.unsubscribe();
    };
  }, [url]);
  return state;
}
var __freeze$1q = Object.freeze;
var __defProp$1q = Object.defineProperty;
var __template$1q = (cooked, raw) => __freeze$1q(__defProp$1q(cooked, "raw", { value: __freeze$1q(raw || cooked.slice()) }));
var _a$1q;
var HOTSPOT_PATH = ["hotspot"];
var PREVIEW_ASPECT_RATIOS = [["3:4", 3 / 4], ["Square", 1 / 1], ["16:9", 16 / 9], ["Panorama", 4 / 1]];
var DEFAULT_VALUE2 = { crop: DEFAULT_CROP, hotspot: DEFAULT_HOTSPOT };
var Placeholder$1 = st.div(_a$1q || (_a$1q = __template$1q(["\n  min-height: 6em;\n"])));
function LoadStatus(props2) {
  return (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "center", padding: 4, style: { overflowWrap: "break-word" }, children: props2.children });
}
function ImageToolInput(props2) {
  const { imageUrl, value, changed, level, path: path2, focusPath = EMPTY_ARRAY$b, presence, onChange, schemaType, onPathFocus, readOnly, elementProps } = props2;
  const [localValue, setLocalValue] = (0, import_react51.useState)(value || DEFAULT_VALUE2);
  const { image: image2, isLoading: isImageLoading, error: imageLoadError } = useLoadImage(imageUrl);
  const handleFocus = (0, import_react51.useCallback)(() => {
    onPathFocus(HOTSPOT_PATH);
  }, [onPathFocus]);
  (0, import_react51.useEffect)(() => {
    setLocalValue(value || DEFAULT_VALUE2);
  }, [value]);
  const hasFocus = focusPath[0] === "hotspot";
  useDidUpdate(hasFocus, (hadFocus) => {
    var _a22;
    if (!hadFocus && hasFocus) {
      (_a22 = elementProps.ref.current) == null ? void 0 : _a22.focus();
    }
  });
  const handleChangeEnd = (0, import_react51.useCallback)((finalValue) => {
    if (readOnly) {
      return;
    }
    const cropField = schemaType.fields.find((field) => field.name === "crop" && field.type.name !== "object");
    const hotspotField = schemaType.fields.find((field) => field.type.name !== "object" && field.name === "hotspot");
    const crop = cropField ? { _type: cropField.type.name, ...finalValue.crop || DEFAULT_CROP } : finalValue.crop;
    const hotspot = hotspotField ? { _type: hotspotField.type.name, ...finalValue.hotspot || DEFAULT_HOTSPOT } : finalValue.hotspot;
    onChange([set$2(crop, ["crop"]), set$2(hotspot, ["hotspot"])]);
  }, [onChange, readOnly, schemaType.fields]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(FormField, { title: t3("inputs.imagetool.title"), level, description: t3("inputs.imagetool.description"), __unstable_presence: presence, children: (0, import_jsx_runtime6.jsxs)("div", { children: [(0, import_jsx_runtime6.jsx)(Card, { __unstable_checkered: true, __unstable_focusRing: true, tabIndex: 0, ref: elementProps.ref, onFocus: handleFocus, children: (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2.concat(HOTSPOT_PATH), hasFocus: focusPath[0] === "hotspot", isChanged: changed, children: (0, import_jsx_runtime6.jsxs)(RatioBox$1, { ratio: 3 / 2, children: [(isImageLoading || imageLoadError) && (0, import_jsx_runtime6.jsx)(LoadStatus, { children: imageLoadError ? (0, import_jsx_runtime6.jsx)(Card, { padding: 4, radius: 2, tone: "critical", border: true, children: (0, import_jsx_runtime6.jsx)(Text3, { children: t3("inputs.imagetool.load-error", { errorMessage: imageLoadError.message }) }) }) : (0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: t3("inputs.imagetool.loading") }) }), !isImageLoading && image2 && (0, import_jsx_runtime6.jsx)(Box, { margin: 1, children: (0, import_jsx_runtime6.jsx)(ImageTool, { value: localValue, src: image2.src, readOnly: Boolean(readOnly), onChangeEnd: handleChangeEnd, onChange: setLocalValue }) })] }) }) }), (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime6.jsx)(Grid, { columns: PREVIEW_ASPECT_RATIOS.length, gap: 1, children: PREVIEW_ASPECT_RATIOS.map((_ref215) => {
    let [title, ratio] = _ref215;
    return (0, import_jsx_runtime6.jsxs)("div", { children: [(0, import_jsx_runtime6.jsx)(Heading, { as: "h4", size: 0, children: title }), (0, import_jsx_runtime6.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime6.jsx)(RatioBox$1, { ratio, children: (0, import_jsx_runtime6.jsx)(Card, { __unstable_checkered: true, children: !isImageLoading && image2 ? (0, import_jsx_runtime6.jsx)(HotspotImage, { aspectRatio: ratio, src: image2.src, srcAspectRatio: image2.width / image2.height, hotspot: localValue.hotspot || DEFAULT_HOTSPOT, crop: localValue.crop || DEFAULT_CROP }) : (0, import_jsx_runtime6.jsx)(Placeholder$1, {}) }) }) })] }, ratio);
  }) }) })] }) });
}
var __freeze$1p = Object.freeze;
var __defProp$1p = Object.defineProperty;
var __template$1p = (cooked, raw) => __freeze$1p(__defProp$1p(cooked, "raw", { value: __freeze$1p(raw || cooked.slice()) }));
var _a$1p;
var MenuActionsWrapper = st(Inline)(_a$1p || (_a$1p = __template$1p(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
function ImageActionsMenu(props2) {
  const { onEdit, children, showEdit, setHotspotButtonElement, setMenuButtonElement, onMenuOpen, isMenuOpen } = props2;
  const [menuElement, setMenuElement] = (0, import_react51.useState)(null);
  const [buttonElement, setButtonElement] = (0, import_react51.useState)(null);
  const handleClick = (0, import_react51.useCallback)(() => onMenuOpen(!isMenuOpen), [onMenuOpen, isMenuOpen]);
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (isMenuOpen && (event.key === "Escape" || event.key === "Tab")) {
      onMenuOpen(false);
      buttonElement == null ? void 0 : buttonElement.focus();
    }
  }, [isMenuOpen, onMenuOpen, buttonElement]));
  useClickOutside((0, import_react51.useCallback)((event) => {
    if (!(buttonElement == null ? void 0 : buttonElement.contains(event.target))) {
      onMenuOpen(false);
    }
  }, [buttonElement, onMenuOpen]), [menuElement]);
  const setOptionsButtonRef = (0, import_react51.useCallback)((el) => {
    setMenuButtonElement(el);
    setButtonElement(el);
  }, [setMenuButtonElement]);
  (0, import_react51.useEffect)(() => {
    if (isMenuOpen) {
      menuElement == null ? void 0 : menuElement.focus();
    }
  }, [isMenuOpen, menuElement]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(MenuActionsWrapper, { "data-buttons": true, space: 1, padding: 2, children: [showEdit && (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("inputs.image.actions-menu.crop-image-tooltip") }), padding: 2, children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("inputs.image.actions-menu.edit-details.aria-label"), "data-testid": "options-menu-edit-details", icon: CropIcon, mode: "ghost", onClick: onEdit, ref: setHotspotButtonElement }) }), (0, import_jsx_runtime6.jsx)(Popover, { id: "image-actions-menu", content: (0, import_jsx_runtime6.jsx)(Menu, { ref: setMenuElement, children }), portal: true, open: isMenuOpen, constrainSize: true, children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("inputs.image.actions-menu.options.aria-label"), "data-testid": "options-menu-button", icon: EllipsisVerticalIcon, mode: "ghost", onClick: handleClick, ref: setOptionsButtonRef }) })] });
}
var __freeze$1o = Object.freeze;
var __defProp$1o = Object.defineProperty;
var __template$1o = (cooked, raw) => __freeze$1o(__defProp$1o(cooked, "raw", { value: __freeze$1o(raw || cooked.slice()) }));
var _a$1o;
var _b$G;
var _c$o;
var _d$f;
var MAX_DEFAULT_HEIGHT = 30;
var RatioBox = st(Card)(_a$1o || (_a$1o = __template$1o(["\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n  overflow: clip;\n  min-height: 3.75rem;\n  max-height: 20rem;\n\n  & > div[data-container] {\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex !important;\n    align-items: center;\n    justify-content: center;\n  }\n\n  & img {\n    max-width: 100%;\n    max-height: 100%;\n  }\n"])));
var SpinnerWrapper = st(Spinner)(_b$G || (_b$G = __template$1o(["\n  position: absolute;\n"])));
var Overlay$2 = st(Flex)((_ref216) => {
  let { $drag, $tone } = _ref216;
  const textColor = studioTheme.color.light[$tone].card.enabled.fg;
  const backgroundColor = rgba2(studioTheme.color.light[$tone].card.enabled.bg, 0.8);
  return nt(_c$o || (_c$o = __template$1o(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    backdrop-filter: ", ";\n    color: ", ";\n    background-color: ", ";\n  "])), $drag ? "blur(10px)" : "", $tone ? textColor : "", $drag ? backgroundColor : "transparent");
});
var FlexOverlay = st(Flex)(_d$f || (_d$f = __template$1o(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n"])));
var getImageSize = (src) => {
  const imageUrlParams = new URLSearchParams(src.split("?")[1]);
  const rect = imageUrlParams.get("rect");
  if (rect) {
    return [rect.split(",")[2], rect.split(",")[3]].map(Number);
  }
  return src.split("-")[1].split(".")[0].split("x").map(Number);
};
function ImagePreview$1(props2) {
  const { drag: drag2, readOnly, isRejected, src, ...rest } = props2;
  const [isLoaded, setLoaded] = (0, import_react51.useState)(false);
  const [rootElement, setRootElement] = (0, import_react51.useState)(null);
  const rootRect = useElementRect(rootElement);
  const rootWidth = (rootRect == null ? void 0 : rootRect.width) || 0;
  const acceptTone = isRejected || readOnly ? "critical" : "primary";
  const tone = drag2 ? acceptTone : "default";
  const maxHeightToPx = MAX_DEFAULT_HEIGHT * document.documentElement.clientHeight / 100;
  const [imageWidth, imageHeight] = getImageSize(src);
  const imageRatio = imageWidth / imageHeight;
  const renderedImageHeight = imageWidth > rootWidth ? rootWidth / imageRatio : imageHeight;
  const rootHeight = renderedImageHeight < maxHeightToPx ? null : "".concat(MAX_DEFAULT_HEIGHT, "vh");
  (0, import_react51.useEffect)(() => {
    setLoaded(false);
  }, [src]);
  const onLoadChange = (0, import_react51.useCallback)(() => {
    setLoaded(true);
  }, []);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(RatioBox, { ...rest, ref: setRootElement, style: { height: rootHeight }, tone: "transparent", children: [(0, import_jsx_runtime6.jsxs)(Card, { "data-container": true, tone: "inherit", children: [!isLoaded && (0, import_jsx_runtime6.jsx)(OverlayComponent, { cardTone: "transparent", drag: true, content: (0, import_jsx_runtime6.jsx)(SpinnerWrapper, {}) }), (0, import_jsx_runtime6.jsx)("img", { src, "data-testid": "hotspot-image-input", alt: props2.alt, onLoad: onLoadChange, referrerPolicy: "strict-origin-when-cross-origin" })] }), drag2 && (0, import_jsx_runtime6.jsx)(OverlayComponent, { cardTone: tone, drag: drag2, content: (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Box, { marginBottom: 3, children: (0, import_jsx_runtime6.jsx)(Heading, { children: (0, import_jsx_runtime6.jsx)(HoverIcon, { isRejected, readOnly }) }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3(getHoverTextTranslationKey({ isRejected, readOnly })) })] }) })] });
}
function HoverIcon(_ref217) {
  let { isRejected, readOnly } = _ref217;
  if (isRejected) {
    return (0, import_jsx_runtime6.jsx)(AccessDeniedIcon, {});
  }
  if (readOnly) {
    return (0, import_jsx_runtime6.jsx)(ReadOnlyIcon, {});
  }
  return (0, import_jsx_runtime6.jsx)(ImageIcon, {});
}
function getHoverTextTranslationKey(_ref218) {
  let { isRejected, readOnly } = _ref218;
  if (isRejected) {
    return "inputs.image.drag-overlay.this-field-is-read-only";
  }
  return readOnly ? "inputs.image.drag-overlay.cannot-upload-here" : "inputs.image.drag-overlay.drop-to-upload-image";
}
function OverlayComponent(_ref219) {
  let { cardTone, drag: drag2, content } = _ref219;
  return (0, import_jsx_runtime6.jsx)(Overlay$2, { justify: "flex-end", padding: 3, $drag: drag2, $tone: cardTone, children: (0, import_jsx_runtime6.jsx)(FlexOverlay, { direction: "column", align: "center", justify: "center", children: content }) });
}
var __freeze$1n = Object.freeze;
var __defProp$1n = Object.defineProperty;
var __template$1n = (cooked, raw) => __freeze$1n(__defProp$1n(cooked, "raw", { value: __freeze$1n(raw || cooked.slice()) }));
var _a$1n;
var ButtonWrapper$1 = st(Button)(_a$1n || (_a$1n = __template$1n(["\n  width: 100%;\n"])));
function InvalidImageWarning(_ref220) {
  let { onClearValue } = _ref220;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Card, { tone: "caution", padding: 4, border: true, radius: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { gap: 4, marginBottom: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.image.invalid-image-warning.title") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("inputs.image.invalid-image-warning.description") })] })] }), (0, import_jsx_runtime6.jsx)(ButtonWrapper$1, { icon: ResetIcon, text: t3("inputs.image.invalid-image-warning.reset-button.text"), onClick: onClearValue, mode: "ghost" })] });
}
var getDevicePixelRatio2 = () => {
  if (typeof window === "undefined" || !window.devicePixelRatio) {
    return 1;
  }
  return Math.round(Math.max(1, window.devicePixelRatio));
};
function passThrough(_ref221) {
  let { children } = _ref221;
  return children;
}
var ASSET_FIELD_PATH = ["asset"];
var ASSET_IMAGE_MENU_POPOVER = { portal: true };
var BaseImageInput = class extends import_react51.default.PureComponent {
  constructor(props2) {
    var _this2;
    super(props2);
    _this2 = this;
    this._previewElement = null;
    this.uploadSubscription = null;
    this.state = { isUploading: false, selectedAssetSource: null, hoveringFiles: [], isStale: false, hotspotButtonElement: null, menuButtonElement: null, isMenuOpen: false };
    this.toast = null;
    this.setPreviewElement = (el) => {
      this._previewElement = el;
    };
    this.setHotspotButtonElement = (el) => {
      this.setState({ hotspotButtonElement: el });
    };
    this.setMenuButtonElement = (el) => {
      this.setState({ menuButtonElement: el });
    };
    this.getUploadOptions = (file2) => {
      const { schemaType, resolveUploader: resolveUploader2 } = this.props;
      const uploader = resolveUploader2 && resolveUploader2(schemaType, file2);
      return uploader ? [{ type: schemaType, uploader }] : [];
    };
    this.uploadWith = function(uploader, file2) {
      let assetDocumentProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const { schemaType, onChange, client, t: t22 } = _this2.props;
      const { label, title, description, creditLine, source } = assetDocumentProps;
      const options = { metadata: (0, import_get3.default)(schemaType, "options.metadata"), storeOriginalFilename: (0, import_get3.default)(schemaType, "options.storeOriginalFilename"), label, title, description, creditLine, source };
      _this2.cancelUpload();
      _this2.setState({ isUploading: true });
      onChange(setIfMissing2({ _type: schemaType.name }));
      _this2.uploadSubscription = uploader.upload(client, file2, schemaType, options).subscribe({ next: (uploadEvent) => {
        if (uploadEvent.patches) {
          onChange(uploadEvent.patches);
        }
      }, error: (err) => {
        var _a4;
        console.error(err);
        (_a4 = _this2.toast) == null ? void 0 : _a4.push({ status: "error", description: t22("inputs.image.upload-error.description"), title: t22("inputs.image.upload-error.title") });
        _this2.clearUploadStatus();
      }, complete: () => {
        onChange([unset2(["hotspot"]), unset2(["crop"])]);
        _this2.setState({ isUploading: false });
      } });
    };
    this.handleRemoveButtonClick = () => {
      const { value } = this.props;
      const allKeys = Object.keys(value || {});
      const remainingKeys = allKeys.filter((key2) => !["_type", "_key", "_upload", "asset", "crop", "hotspot"].includes(key2));
      const isEmpty3 = remainingKeys.length === 0;
      const removeKeys = ["asset"].concat(allKeys.filter((key2) => ["crop", "hotspot", "_upload"].includes(key2))).map((key2) => unset2([key2]));
      this.props.onChange(isEmpty3 && !this.valueIsArrayElement() ? unset2() : removeKeys);
    };
    this.handleFieldChange = (event) => {
      const { onChange, schemaType } = this.props;
      if (!this.valueIsArrayElement() && this.eventIsUnsettingLastFilledField(event)) {
        onChange(unset2());
        return;
      }
      onChange(event.prepend(setIfMissing2({ _type: schemaType.name })).patches);
    };
    this.eventIsUnsettingLastFilledField = (event) => {
      const patch2 = event.patches[0];
      if (event.patches.length !== 1 || patch2.type !== "unset") {
        return false;
      }
      const allKeys = Object.keys(this.props.value || {});
      const remainingKeys = allKeys.filter((key2) => !["_type", "_key", "crop", "hotspot"].includes(key2));
      const isEmpty3 = event.patches[0].path.length === 1 && remainingKeys.length === 1 && remainingKeys[0] === event.patches[0].path[0];
      return isEmpty3;
    };
    this.valueIsArrayElement = () => {
      const { path: path2 } = this.props;
      const parentPathSegment = path2.slice(-1)[0];
      return typeof parentPathSegment !== "string";
    };
    this.handleOpenDialog = () => {
      this.props.onPathFocus(["hotspot"]);
    };
    this.handleCloseDialog = () => {
      var _a4;
      this.props.onPathFocus([]);
      (_a4 = this.state.hotspotButtonElement) == null ? void 0 : _a4.focus();
    };
    this.handleSelectAssetFromSource = (assetFromSource) => {
      const { onChange, schemaType, resolveUploader: resolveUploader2 } = this.props;
      handleSelectAssetFromSource({ assetFromSource, onChange, type: schemaType, resolveUploader: resolveUploader2, uploadWith: this.uploadWith, isImage: true });
      this.setState({ selectedAssetSource: null });
    };
    this.handleFileTargetFocus = (event) => {
      var _a4;
      if (event.currentTarget === event.target && event.currentTarget === ((_a4 = this.props.elementProps.ref) == null ? void 0 : _a4.current)) {
        this.props.elementProps.onFocus(event);
      }
    };
    this.handleFilesOver = (hoveringFiles) => {
      this.setState({ hoveringFiles: hoveringFiles.filter((file2) => file2.kind !== "string") });
    };
    this.handleFilesOut = () => {
      this.setState({ hoveringFiles: [] });
    };
    this.handleCancelUpload = () => {
      this.cancelUpload();
    };
    this.handleClearUploadState = () => {
      this.setState({ isStale: false });
      this.clearUploadStatus();
    };
    this.handleStaleUpload = () => {
      this.setState({ isStale: true });
    };
    this.handleClearField = () => {
      this.props.onChange([unset2(["asset"]), unset2(["crop"]), unset2(["hotspot"])]);
    };
    this.handleSelectFiles = (files) => {
      const { directUploads, readOnly } = this.props;
      const { hoveringFiles } = this.state;
      if (directUploads && !readOnly) {
        this.uploadFirstAccepted(files);
      } else if (hoveringFiles.length > 0) {
        this.handleFilesOut();
      }
    };
    this.handleSelectImageFromAssetSource = (source) => {
      this.setState({ selectedAssetSource: source });
    };
    this.handleAssetSourceClosed = () => {
      var _a4;
      this.setState({ selectedAssetSource: null });
      (_a4 = this.state.menuButtonElement) == null ? void 0 : _a4.focus();
    };
    this.renderHotspotInput = (hotspotInputProps) => {
      const { value, changed, id: id4, imageUrlBuilder: imageUrlBuilder2, t: t22 } = this.props;
      const withImageTool = this.isImageToolEnabled() && value && value.asset;
      return (0, import_jsx_runtime6.jsx)(Dialog, { __unstable_autoFocus: false, header: t22("inputs.image.hotspot-dialog.title"), id: "".concat(id4, "_dialog"), onClickOutside: this.handleCloseDialog, onClose: this.handleCloseDialog, width: 1, children: (0, import_jsx_runtime6.jsx)(PresenceOverlay, { children: (0, import_jsx_runtime6.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime6.jsx)(Stack, { space: 5, children: withImageTool && (value == null ? void 0 : value.asset) && (0, import_jsx_runtime6.jsx)(ImageToolInput, { ...this.props, imageUrl: imageUrlBuilder2.image(value.asset).url(), value, presence: hotspotInputProps.presence, changed }) }) }) }) });
    };
    this.renderPreview = () => {
      const { value, schemaType, readOnly, directUploads, imageUrlBuilder: imageUrlBuilder2, t: t22, resolveUploader: resolveUploader2 } = this.props;
      if (!value || !isImageSource(value)) {
        return null;
      }
      const { hoveringFiles } = this.state;
      const acceptedFiles = hoveringFiles.filter((file2) => resolveUploader2(schemaType, file2));
      const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
      const imageUrl = imageUrlBuilder2.width(2e3).fit("max").image(value).dpr(getDevicePixelRatio2()).auto("format").url();
      return (0, import_jsx_runtime6.jsx)(ImagePreview$1, { drag: !(value == null ? void 0 : value._upload) && hoveringFiles.length > 0, isRejected: rejectedFilesCount > 0 || !directUploads, readOnly, src: imageUrl, alt: t22("inputs.image.preview-uploaded-image") });
    };
    this.setToast = (toast) => {
      this.toast = toast;
    };
    this._assetPath = props2.path.concat(ASSET_FIELD_PATH);
  }
  isImageToolEnabled() {
    return (0, import_get3.default)(this.props.schemaType, "options.hotspot") === true;
  }
  clearUploadStatus() {
    var _a4;
    if ((_a4 = this.props.value) == null ? void 0 : _a4._upload) {
      this.props.onChange(unset2(["_upload"]));
    }
  }
  cancelUpload() {
    if (this.uploadSubscription) {
      this.uploadSubscription.unsubscribe();
      this.clearUploadStatus();
    }
  }
  uploadFirstAccepted(files) {
    const { schemaType, resolveUploader: resolveUploader2 } = this.props;
    const match4 = files.map((file2) => ({ file: file2, uploader: resolveUploader2(schemaType, file2) })).find((result) => result.uploader);
    if (match4) {
      this.uploadWith(match4.uploader, match4.file);
    }
    this.setState({ isMenuOpen: false });
  }
  renderAssetMenu() {
    const { value, assetSources, schemaType, readOnly, directUploads, imageUrlBuilder: imageUrlBuilder2, observeAsset, t: t22 } = this.props;
    const asset = value == null ? void 0 : value.asset;
    if (!asset) {
      return null;
    }
    const accept = (0, import_get3.default)(schemaType, "options.accept", "image/*");
    const showAdvancedEditButton = value && asset && this.isImageToolEnabled();
    let browseMenuItem = assetSources && assetSources.length === 0 ? null : (0, import_jsx_runtime6.jsx)(MenuItem, { icon: SearchIcon, text: t22("inputs.image.browse-menu.text"), onClick: () => {
      this.setState({ isMenuOpen: false });
      this.handleSelectImageFromAssetSource(assetSources[0]);
    }, disabled: readOnly, "data-testid": "file-input-browse-button" });
    if (assetSources && assetSources.length > 1) {
      browseMenuItem = assetSources.map((assetSource) => {
        return (0, import_jsx_runtime6.jsx)(MenuItem, { text: (assetSource.i18nKey ? t22(assetSource.i18nKey) : assetSource.title) || (0, import_startCase2.default)(assetSource.name), onClick: () => {
          this.setState({ isMenuOpen: false });
          this.handleSelectImageFromAssetSource(assetSource);
        }, icon: assetSource.icon || ImageIcon, "data-testid": "file-input-browse-button-".concat(assetSource.name), disabled: readOnly }, assetSource.name);
      });
    }
    return (0, import_jsx_runtime6.jsx)(WithReferencedAsset, { observeAsset, reference: asset, children: (_ref222) => {
      let { _id, originalFilename, extension } = _ref222;
      let copyUrl;
      let downloadUrl;
      if (isImageSource(value)) {
        const filename = originalFilename || "download.".concat(extension);
        downloadUrl = imageUrlBuilder2.image(_id).forceDownload(filename).url();
        copyUrl = imageUrlBuilder2.image(_id).url();
      }
      return (0, import_jsx_runtime6.jsx)(ImageActionsMenu, { isMenuOpen: this.state.isMenuOpen, onEdit: this.handleOpenDialog, onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }), setHotspotButtonElement: this.setHotspotButtonElement, setMenuButtonElement: this.setMenuButtonElement, showEdit: showAdvancedEditButton, children: (0, import_jsx_runtime6.jsx)(ActionsMenu, { onUpload: this.handleSelectFiles, browse: browseMenuItem, onReset: this.handleRemoveButtonClick, downloadUrl, copyUrl, readOnly, directUploads, accept }) });
    } });
  }
  renderBrowser() {
    const { assetSources, readOnly, directUploads, id: id4, t: t22 } = this.props;
    if (assetSources && assetSources.length === 0)
      return null;
    if (assetSources && assetSources.length > 1 && !readOnly && directUploads) {
      return (0, import_jsx_runtime6.jsx)(MenuButton, { id: "".concat(id4, "_assetImageButton"), ref: this.setMenuButtonElement, button: (0, import_jsx_runtime6.jsx)(Button, { "data-testid": "file-input-multi-browse-button", icon: SearchIcon, iconRight: ChevronDownIcon, mode: "ghost", text: t22("inputs.image.browse-menu.text") }), menu: (0, import_jsx_runtime6.jsx)(Menu, { children: assetSources.map((assetSource) => {
        return (0, import_jsx_runtime6.jsx)(MenuItem, { text: (assetSource.i18nKey ? t22(assetSource.i18nKey) : assetSource.title) || (0, import_startCase2.default)(assetSource.name), onClick: () => {
          this.setState({ isMenuOpen: false });
          this.handleSelectImageFromAssetSource(assetSource);
        }, icon: assetSource.icon || ImageIcon, disabled: readOnly, "data-testid": "file-input-browse-button-".concat(assetSource.name) }, assetSource.name);
      }) }), popover: ASSET_IMAGE_MENU_POPOVER });
    }
    return (0, import_jsx_runtime6.jsx)(Button, { fontSize: 2, text: t22("inputs.image.browse-menu.text"), icon: SearchIcon, mode: "ghost", onClick: () => {
      this.setState({ isMenuOpen: false });
      this.handleSelectImageFromAssetSource(assetSources[0]);
    }, "data-testid": "file-input-browse-button", disabled: readOnly });
  }
  renderUploadPlaceholder() {
    const { schemaType, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props;
    const { hoveringFiles } = this.state;
    const acceptedFiles = hoveringFiles.filter((file2) => resolveUploader2(schemaType, file2));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    const accept = (0, import_get3.default)(schemaType, "options.accept", "image/*");
    return (0, import_jsx_runtime6.jsx)("div", { style: { padding: 1 }, children: (0, import_jsx_runtime6.jsx)(Card, { tone: readOnly ? "transparent" : "inherit", border: true, padding: 3, style: hoveringFiles.length === 0 ? { borderStyle: "dashed" } : { borderStyle: "dashed", borderColor: "transparent" }, children: (0, import_jsx_runtime6.jsx)(UploadPlaceholder, { browse: this.renderBrowser(), onUpload: this.handleSelectFiles, readOnly, hoveringFiles, acceptedFiles, rejectedFilesCount, type: "image", accept, directUploads }) }) });
  }
  renderUploadState(uploadState) {
    var _a4;
    const { isUploading } = this.state;
    const height = (_a4 = this._previewElement) == null ? void 0 : _a4.offsetHeight;
    return (0, import_jsx_runtime6.jsx)(UploadProgress, { uploadState, onCancel: isUploading ? this.handleCancelUpload : void 0, onStale: this.handleStaleUpload, height });
  }
  renderAssetSource() {
    const { selectedAssetSource } = this.state;
    const { value, schemaType, observeAsset } = this.props;
    const accept = (0, import_get3.default)(schemaType, "options.accept", "image/*");
    if (!selectedAssetSource) {
      return null;
    }
    const Component3 = selectedAssetSource.component;
    if (value && value.asset) {
      return (0, import_jsx_runtime6.jsx)(WithReferencedAsset, { observeAsset, reference: value.asset, children: (imageAsset2) => (0, import_jsx_runtime6.jsx)(Component3, { selectedAssets: [imageAsset2], assetType: "image", accept, selectionType: "single", onClose: this.handleAssetSourceClosed, onSelect: this.handleSelectAssetFromSource }) });
    }
    return (0, import_jsx_runtime6.jsx)(Component3, { selectedAssets: [], selectionType: "single", assetType: "image", accept, onClose: this.handleAssetSourceClosed, onSelect: this.handleSelectAssetFromSource });
  }
  getFileTone() {
    const { schemaType, value, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props;
    const { hoveringFiles } = this.state;
    const acceptedFiles = hoveringFiles.filter((file2) => resolveUploader2(schemaType, file2));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    if (hoveringFiles.length > 0) {
      if (rejectedFilesCount > 0 || !directUploads) {
        return "critical";
      }
    }
    if (!(value == null ? void 0 : value._upload) && !readOnly && hoveringFiles.length > 0) {
      return "primary";
    }
    if (readOnly) {
      return "transparent";
    }
    return (value == null ? void 0 : value._upload) && (value == null ? void 0 : value.asset) ? "transparent" : "default";
  }
  renderAsset() {
    const { value, readOnly, elementProps } = this.props;
    const { hoveringFiles, isStale } = this.state;
    const hasValueOrUpload = Boolean((value == null ? void 0 : value._upload) || (value == null ? void 0 : value.asset));
    if (value && typeof value.asset !== "undefined" && !(value == null ? void 0 : value._upload) && !isImageSource(value)) {
      return () => (0, import_jsx_runtime6.jsx)(InvalidImageWarning, { onClearValue: this.handleClearField });
    }
    return (inputProps) => (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [isStale && (0, import_jsx_runtime6.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime6.jsx)(UploadWarning, { onClearStale: this.handleClearUploadState }) }), (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: inputProps.path.concat(ASSET_FIELD_PATH), hasFocus: !!inputProps.focused, isChanged: inputProps.changed, children: (value == null ? void 0 : value._upload) ? this.renderUploadState(value._upload) : (0, import_jsx_runtime6.jsxs)(FileTarget, { ...elementProps, onFocus: this.handleFileTargetFocus, tabIndex: 0, disabled: Boolean(readOnly), onFiles: this.handleSelectFiles, onFilesOver: this.handleFilesOver, onFilesOut: this.handleFilesOut, tone: this.getFileTone(), $border: hasValueOrUpload || hoveringFiles.length > 0, style: { padding: 1 }, sizing: "border", radius: 2, children: [!(value == null ? void 0 : value.asset) && this.renderUploadPlaceholder(), !(value == null ? void 0 : value._upload) && (value == null ? void 0 : value.asset) && (0, import_jsx_runtime6.jsxs)("div", { style: { position: "relative" }, ref: this.setPreviewElement, children: [this.renderPreview(), this.renderAssetMenu()] })] }) })] });
  }
  render() {
    const { focusPath, members, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview } = this.props;
    const { selectedAssetSource } = this.state;
    const hotspotField = members.find((member) => member.kind === "field" && member.name === "hotspot");
    return (
      // The Stack space should match the space in ObjectInput
      (0, import_jsx_runtime6.jsxs)(Stack, { space: 5, "data-testid": "image-input", children: [(0, import_jsx_runtime6.jsx)(ImperativeToast, { ref: this.setToast }), members.map((member) => {
        if (member.kind === "field" && (member.name === "crop" || member.name === "hotspot")) {
          return null;
        }
        if (member.kind === "field") {
          return (0, import_jsx_runtime6.jsx)(MemberField, { member, renderAnnotation, renderBlock, renderInlineBlock, renderInput: member.name === "asset" ? this.renderAsset() : renderInput, renderField: member.name === "asset" ? passThrough : renderField, renderItem, renderPreview }, member.key);
        }
        if (member.kind === "fieldSet") {
          return (0, import_jsx_runtime6.jsx)(MemberFieldSet, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }, member.key);
        }
        if (member.kind === "error") {
          return (0, import_jsx_runtime6.jsx)(MemberFieldError, { member }, member.key);
        }
        return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t("inputs.image.error.unknown-member-kind", { kind: member.kind }) });
      }), hotspotField && focusPath[0] === "hotspot" && (0, import_jsx_runtime6.jsx)(FormInput, { ...this.props, absolutePath: hotspotField.field.path, renderInput: this.renderHotspotInput }), selectedAssetSource && this.renderAssetSource()] })
    );
  }
};
function StudioImageInput(props2) {
  var _a4;
  const sourcesFromSchema = (_a4 = props2.schemaType.options) == null ? void 0 : _a4.sources;
  const { image: image2 } = useFormBuilder().__internal;
  const documentPreviewStore = useDocumentPreviewStore();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const supportsImageUploads = image2.directUploads;
  const resolveUploader$1 = (0, import_react51.useCallback)((type, file2) => {
    if (!supportsImageUploads) {
      return null;
    }
    return resolveUploader(type, file2);
  }, [supportsImageUploads]);
  const assetSources = import_react51.default.useMemo(() => sourcesFromSchema || image2.assetSources, [image2, sourcesFromSchema]);
  const builder = import_react51.default.useMemo(() => (0, import_image_url.default)(client), [client]);
  const observeAsset = (0, import_react51.useCallback)((id4) => observeImageAsset(documentPreviewStore, id4), [documentPreviewStore]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(BaseImageInput, { ...props2, t: t3, client, assetSources, directUploads: supportsImageUploads, imageUrlBuilder: builder, observeAsset, resolveUploader: resolveUploader$1 });
}
var noop4 = () => {
};
var INITIAL_LOADING_STATE = { isLoading: true, result: void 0, error: void 0, retry: noop4 };
var EMPTY_STATE2 = { isLoading: false, result: void 0, error: void 0, retry: noop4 };
function useReferenceInfo(doc, getReferenceInfo2) {
  const [retryAttempt, setRetryAttempt] = (0, import_react51.useState)(0);
  const retry2 = (0, import_react51.useCallback)(() => {
    setRetryAttempt((current) => current + 1);
  }, []);
  const docInfo = (0, import_react51.useMemo)(() => ({ _id: doc._id, _type: doc._type }), [doc._id, doc._type]);
  const referenceInfo = useMemoObservable(() => docInfo._id ? getReferenceInfo2(docInfo).pipe(map((result) => ({ isLoading: false, result, error: void 0, retry: retry2, retryAttempt })), startWith(INITIAL_LOADING_STATE), catchError((err) => {
    console.error(err);
    return of({ isLoading: false, result: void 0, error: err, retry: retry2, retryAttempt });
  })) : of(EMPTY_STATE2), [docInfo, getReferenceInfo2, retry2, retryAttempt], INITIAL_LOADING_STATE);
  const previousId = usePrevious(doc._id, doc._id);
  if (previousId !== doc._id) {
    return INITIAL_LOADING_STATE;
  }
  return referenceInfo;
}
var __freeze$1m = Object.freeze;
var __defProp$1m = Object.defineProperty;
var __template$1m = (cooked, raw) => __freeze$1m(__defProp$1m(cooked, "raw", { value: __freeze$1m(raw || cooked.slice()) }));
var _a$1m;
var _b$F;
var StyledPreviewFlex = st(Flex)(_a$1m || (_a$1m = __template$1m(["\n  /* this is a hack to avoid layout jumps while previews are loading\n  or the message is not tall enough to fill the card\n  there's probably better ways of solving this */\n  min-height: 36px;\n"])));
var TooltipContent = st(Flex)(_b$F || (_b$F = __template$1m(["\n  /* This limits the width of the tooltip content */\n  max-width: 250px;\n"])));
function UnavailableMessage(props2) {
  return (0, import_jsx_runtime6.jsx)(TooltipContent, { padding: 3, children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", size: 1, children: props2.children }) }) }) });
}
function CrossDatasetReferencePreview(props2) {
  var _a4, _b4, _c4;
  const { refType, showStudioUrlIcon, hasStudioUrl, showTypeLabel, availability, preview, id: id4, dataset: dataset2, projectId: projectId2 } = props2;
  const notFound = (availability == null ? void 0 : availability.reason) === "NOT_FOUND";
  const insufficientPermissions = (availability == null ? void 0 : availability.reason) === "PERMISSION_DENIED";
  const previewMedia = (_a4 = preview.published) == null ? void 0 : _a4.media;
  const { t: t3 } = useTranslation2();
  const media = (0, import_react51.useMemo)(() => {
    if (previewMedia) {
      const isValidImageAsset = typeof (previewMedia == null ? void 0 : previewMedia.asset) !== "undefined" && isImageSource(previewMedia);
      const isValidElement4 = import_react51.default.isValidElement(previewMedia);
      if (!isValidImageAsset && !isValidElement4) {
        return null;
      }
      return function MediaPreview2(_ref223) {
        let { dimensions } = _ref223;
        return isValidElement4 ? previewMedia : (0, import_jsx_runtime6.jsx)("img", { src: (0, import_image_url.default)({ dataset: dataset2, projectId: projectId2 }).image(previewMedia).withOptions(dimensions).url(), alt: t3("inputs.reference.image-preview-alt-text"), referrerPolicy: "strict-origin-when-cross-origin" });
      };
    }
    return (refType == null ? void 0 : refType.icon) ? (0, import_react51.createElement)(refType.icon) : null;
  }, [previewMedia, dataset2, projectId2, refType == null ? void 0 : refType.icon, t3]);
  return (0, import_jsx_runtime6.jsxs)(StyledPreviewFlex, { align: "center", justify: "center", flex: 1, "data-testid": "preview", children: [(availability == null ? void 0 : availability.available) ? (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(DefaultPreview, { title: (_b4 = preview.published) == null ? void 0 : _b4.title, subtitle: (_c4 = preview.published) == null ? void 0 : _c4.subtitle, media: media || false }) }) : (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, paddingY: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: t3("inputs.reference.error.document-unavailable-title") }) }) }) }), (0, import_jsx_runtime6.jsx)(Box, { paddingLeft: 3, children: (0, import_jsx_runtime6.jsxs)(Inline, { space: 4, children: [refType && showTypeLabel && (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: refType.title || refType.type }), (insufficientPermissions || notFound) && (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(UnavailableMessage, { children: t3(notFound ? "inputs.reference.referenced-document-does-not-exist" : "inputs.reference.referenced-document-insufficient-permissions", { documentId: id4 }) }), children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "default", children: insufficientPermissions ? (0, import_jsx_runtime6.jsx)(AccessDeniedIcon, {}) : (0, import_jsx_runtime6.jsx)(HelpCircleIcon, {}) }) }) }), !(notFound || insufficientPermissions) && showStudioUrlIcon && (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(TooltipContent, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3(hasStudioUrl ? "inputs.reference.document-opens-in-new-tab" : "input.reference.document-cannot-be-opened.failed-to-resolve-url") }) }), children: (0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "default", muted: !hasStudioUrl, children: (0, import_jsx_runtime6.jsx)(LaunchIcon, {}) }) }) })] }) })] });
}
function useProjectId() {
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return client.config().projectId;
}
function OptionPreview$1(props2) {
  var _a4;
  const { isLoading, result: referenceInfo, error: error2 } = useReferenceInfo(props2.document, props2.getReferenceInfo);
  const { t: t3 } = useTranslation2();
  const projectId2 = useProjectId();
  if (isLoading) {
    return (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, padding: 1, children: [(0, import_jsx_runtime6.jsx)(TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: true }), (0, import_jsx_runtime6.jsx)(TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: true })] });
  }
  if (error2) {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 1, children: (0, import_jsx_runtime6.jsx)(Alert, { title: t3("inputs.reference.error.failed-to-load-document-title"), children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: error2.message }) }) });
  }
  if (!referenceInfo) {
    return null;
  }
  if (((_a4 = referenceInfo.availability) == null ? void 0 : _a4.reason) === "PERMISSION_DENIED") {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 1, children: t3("inputs.reference.error.missing-read-permissions-description") });
  }
  const refType = props2.referenceType.to.find((toEntry) => toEntry.type === referenceInfo.type);
  if (!refType) {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 1, children: t3("inputs.reference.error.invalid-search-result-type-title", { returnedType: referenceInfo.type }) });
  }
  return referenceInfo && refType && (0, import_jsx_runtime6.jsx)(CrossDatasetReferencePreview, { id: referenceInfo.id, availability: referenceInfo.availability, preview: referenceInfo.preview, refType, dataset: props2.referenceType.dataset, projectId: projectId2, showTypeLabel: props2.referenceType.to.length > 1 });
}
function PreviewReferenceValue(props2) {
  var _a4, _b4;
  const { value, type, showStudioUrlIcon, hasStudioUrl, referenceInfo } = props2;
  const { t: t3 } = useTranslation2();
  const projectId2 = useProjectId();
  if (referenceInfo.isLoading || referenceInfo.error) {
    return (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, padding: 1, children: [(0, import_jsx_runtime6.jsx)(TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !referenceInfo.error }), (0, import_jsx_runtime6.jsx)(TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !referenceInfo.error })] });
  }
  const showTypeLabel = type.to.length > 1;
  const refTypeName = (_a4 = referenceInfo.result) == null ? void 0 : _a4.type;
  const refType = type.to.find((toType) => toType.type === refTypeName);
  if (((_b4 = referenceInfo.result.availability) == null ? void 0 : _b4.available) && !refType) {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.cross-dataset.invalid-type", values: { typeName: refTypeName || "unknown" }, components: { JsonValue: () => (0, import_jsx_runtime6.jsx)("pre", { children: JSON.stringify(value, null, 2) }) } }) }) });
  }
  return (0, import_jsx_runtime6.jsx)(CrossDatasetReferencePreview, { availability: referenceInfo.result.availability, hasStudioUrl, showStudioUrlIcon, preview: referenceInfo.result.preview, refType, projectId: projectId2, dataset: type.dataset, id: value._ref, showTypeLabel });
}
var __freeze$1l = Object.freeze;
var __defProp$1l = Object.defineProperty;
var __template$1l = (cooked, raw) => __freeze$1l(__defProp$1l(cooked, "raw", { value: __freeze$1l(raw || cooked.slice()) }));
var _a$1l;
var _b$E;
var StyledPopover$2 = st(Popover)(_a$1l || (_a$1l = __template$1l(["\n  & > div {\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n  }\n"])));
var StyledText$3 = st(Text3)(_b$E || (_b$E = __template$1l(["\n  word-break: break-word;\n"])));
var FALLBACK_PLACEMENTS$2 = ["top-start", "bottom-start"];
var ReferenceAutocomplete$2 = (0, import_react51.forwardRef)(function ReferenceAutocomplete2(props2, ref) {
  const { searchString, loading, portalRef, referenceElement, ...restProps } = props2;
  const { t: t3 } = useTranslation2();
  const hasResults = props2.options && props2.options.length > 0;
  const renderPopover = (0, import_react51.useCallback)((_ref224, contentRef) => {
    let { content, hidden, inputElement, onMouseEnter, onMouseLeave } = _ref224;
    return (0, import_jsx_runtime6.jsx)(StyledPopover$2, { "data-testid": "autocomplete-popover", placement: "bottom-start", fallbackPlacements: FALLBACK_PLACEMENTS$2, arrow: false, constrainSize: true, onMouseEnter, onMouseLeave, content: (0, import_jsx_runtime6.jsx)("div", { ref: contentRef, children: hasResults ? content : (0, import_jsx_runtime6.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", height: "fill", justify: "center", children: (0, import_jsx_runtime6.jsx)(StyledText$3, { align: "center", muted: true, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.no-results-for-query", values: { searchTerm: searchString || "" } }) }) }) }) }), open: !loading && !hidden, ref: portalRef, portal: true, referenceElement: referenceElement || inputElement, matchReferenceWidth: true });
  }, [hasResults, t3, searchString, loading, portalRef, referenceElement]);
  return (0, import_jsx_runtime6.jsx)(Autocomplete, { ...restProps, ref, renderPopover });
});
var __freeze$1k = Object.freeze;
var __defProp$1k = Object.defineProperty;
var __template$1k = (cooked, raw) => __freeze$1k(__defProp$1k(cooked, "raw", { value: __freeze$1k(raw || cooked.slice()) }));
var _a$1k;
var ButtonWrapper = st(Button)(_a$1k || (_a$1k = __template$1k(["\n  width: 100%;\n"])));
function DisabledFeatureWarning(_ref225) {
  let { value, onClearValue } = _ref225;
  const hasRef = (0, import_react51.useMemo)(() => Boolean(value == null ? void 0 : value._ref), [value == null ? void 0 : value._ref]);
  const { t: t3 } = useTranslation2();
  const description = (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.cross-dataset.feature-disabled-description", components: { DocumentationLink: (_ref226) => {
    let { children } = _ref226;
    return (0, import_jsx_runtime6.jsx)("a", { href: "https://www.sanity.io/docs/cross-dataset-references", target: "_blank", rel: "noreferrer", children });
  } } });
  return (0, import_jsx_runtime6.jsxs)(Card, { tone: "caution", padding: 4, border: true, radius: 2, "data-testid": "alert-cross-dataset-reference-feature-disabled", children: [(0, import_jsx_runtime6.jsxs)(Flex, { gap: 4, marginBottom: hasRef ? 4 : void 0, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "h2", size: 1, weight: "semibold", children: t3("inputs.reference.cross-dataset.feature-unavailable-title") }), hasRef && (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", size: 1, children: description }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", size: 1, children: t3("inputs.reference.cross-dataset.feature-disabled-actions") })] }), !hasRef && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", size: 1, children: description })] })] }), onClearValue && hasRef && (0, import_jsx_runtime6.jsx)(ButtonWrapper, { icon: ResetIcon, text: t3("inputs.reference.action.clear"), onClick: onClearValue, mode: "ghost" })] });
}
var INITIAL_SEARCH_STATE$2 = { hits: [], isLoading: false };
var NO_FILTER$2 = () => true;
var REF_PATH = ["_ref"];
var CROSS_DATASET_FEATUREKEY = "crossDatasetReferences";
function CrossDatasetReferenceInput(props2) {
  var _a4, _b4;
  const { changed, focused, focusPath, getReferenceInfo: getReferenceInfo2, onChange, onPathFocus, onSearch, path: path2, readOnly, schemaType, validation: validation2, value, elementProps } = props2;
  const { t: t3 } = useTranslation2();
  const projectId2 = useProjectId();
  const [searchState, setSearchState] = (0, import_react51.useState)(INITIAL_SEARCH_STATE$2);
  const handleChange = (0, import_react51.useCallback)((id4) => {
    if (!id4) {
      onChange(unset2());
      onPathFocus([]);
      return;
    }
    const hit = searchState.hits.find((h) => h.id === id4);
    if (!hit) {
      throw new Error("Selected an item that wasnt part of the result set");
    }
    onChange(set$2({
      _type: schemaType.name,
      _ref: getPublishedId(id4),
      _projectId: projectId2,
      _dataset: schemaType.dataset,
      _weak: schemaType.weak,
      // persist _key between mutations if the value is in an array
      _key: value == null ? void 0 : value._key
    }));
    onPathFocus([]);
  }, [value == null ? void 0 : value._key, searchState.hits, schemaType.name, schemaType.dataset, schemaType.weak, projectId2, onChange, onPathFocus]);
  const handleClear = (0, import_react51.useCallback)(() => {
    onChange(unset2());
  }, [onChange]);
  const handleAutocompleteKeyDown = (0, import_react51.useCallback)((event) => {
    if (event.key === "Escape") {
      onPathFocus == null ? void 0 : onPathFocus([]);
    }
  }, [onPathFocus]);
  const getReferenceInfoMemo = (0, import_react51.useCallback)((doc) => getReferenceInfo2(doc, schemaType), [getReferenceInfo2, schemaType]);
  const refDoc = (0, import_react51.useMemo)(() => ({ _id: value == null ? void 0 : value._ref }), [value == null ? void 0 : value._ref]);
  const loadableReferenceInfo = useReferenceInfo(refDoc, getReferenceInfoMemo);
  const featureInfo = useFeatureEnabled(CROSS_DATASET_FEATUREKEY);
  const autocompletePopoverReferenceElementRef = (0, import_react51.useRef)(null);
  const hasFocusAtRef = focusPath.length === 1 && focusPath[0] === "_ref";
  const focusElementRef = elementProps.ref;
  useDidUpdate({ hasFocusAt: hasFocusAtRef, ref: value == null ? void 0 : value._ref }, (prev, current) => {
    var _a22;
    const refUpdated = (prev == null ? void 0 : prev.ref) !== current.ref;
    const focusAtUpdated = (prev == null ? void 0 : prev.hasFocusAt) !== current.hasFocusAt;
    if ((focusAtUpdated || refUpdated) && current.hasFocusAt) {
      (_a22 = focusElementRef.current) == null ? void 0 : _a22.focus();
    }
  });
  const actualStrength = (value == null ? void 0 : value._weak) ? "weak" : "strong";
  const weakShouldBe = schemaType.weak === true ? "weak" : "strong";
  const hasRef = Boolean(value == null ? void 0 : value._ref);
  const handleFixStrengthMismatch = (0, import_react51.useCallback)(() => {
    onChange(schemaType.weak === true ? set$2(true, ["_weak"]) : unset2(["_weak"]));
  }, [onChange, schemaType]);
  const { push } = useToast();
  const errors = (0, import_react51.useMemo)(() => validation2.filter((item) => item.level === "error"), [validation2]);
  const handleFocus = (0, import_react51.useCallback)((event) => {
    if (event.currentTarget === elementProps.ref.current) {
      onPathFocus == null ? void 0 : onPathFocus([FOCUS_TERMINATOR]);
    }
  }, [elementProps.ref, onPathFocus]);
  const handleAutocompleteFocus = (0, import_react51.useCallback)((event) => {
    if (event.currentTarget === elementProps.ref.current) {
      onPathFocus == null ? void 0 : onPathFocus(REF_PATH);
    }
  }, [elementProps.ref, onPathFocus]);
  const handleReplace = (0, import_react51.useCallback)(() => {
    onPathFocus == null ? void 0 : onPathFocus(REF_PATH);
  }, [onPathFocus]);
  const inputId = (0, import_react51.useId)();
  const handleQueryChange = useObservableCallback((inputValue$) => {
    return inputValue$.pipe(filter(isNonNullable$3), distinctUntilChanged(), switchMap((searchString) => concat(of({ isLoading: true }), onSearch(searchString).pipe(map((hits) => ({ hits, searchString, isLoading: false })), catchError((error2) => {
      push({ title: "Reference search failed", description: error2.message, status: "error", id: "reference-search-fail-".concat(inputId) });
      console.error(error2);
      return of({ hits: [] });
    })))), scan((prevState, nextState) => ({ ...prevState, ...nextState }), INITIAL_SEARCH_STATE$2), tap(setSearchState));
  }, [inputId, onSearch, push]);
  const handleAutocompleteOpenButtonClick = (0, import_react51.useCallback)(() => {
    handleQueryChange("");
  }, [handleQueryChange]);
  const showWeakRefMismatch = !loadableReferenceInfo.isLoading && hasRef && actualStrength !== weakShouldBe;
  const studioUrl = (value == null ? void 0 : value._ref) && ((_b4 = schemaType.studioUrl) == null ? void 0 : _b4.call(schemaType, { id: value == null ? void 0 : value._ref, type: (_a4 = loadableReferenceInfo == null ? void 0 : loadableReferenceInfo.result) == null ? void 0 : _a4.type })) || null;
  const renderOption = (0, import_react51.useCallback)((option) => {
    return (0, import_jsx_runtime6.jsx)(PreviewCard$1, { as: "button", type: "button", radius: 2, children: (0, import_jsx_runtime6.jsx)(Box, { paddingX: 3, paddingY: 1, children: (0, import_jsx_runtime6.jsx)(OptionPreview$1, { referenceType: schemaType, document: option.hit.published, getReferenceInfo: getReferenceInfoMemo }) }) });
  }, [schemaType, getReferenceInfoMemo]);
  const isEditing = hasFocusAtRef || !(value == null ? void 0 : value._ref);
  const clickOutsideBoundaryRef = (0, import_react51.useRef)(null);
  const autocompletePortalRef = (0, import_react51.useRef)(null);
  const createButtonMenuPortalRef = (0, import_react51.useRef)(null);
  useOnClickOutside([clickOutsideBoundaryRef, autocompletePortalRef, createButtonMenuPortalRef], () => {
    if (hasFocusAtRef) {
      onPathFocus([]);
    }
  });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [!featureInfo.isLoading && !featureInfo.enabled && (0, import_jsx_runtime6.jsx)(DisabledFeatureWarning, { value, onClearValue: handleClear }), (featureInfo.isLoading || featureInfo.enabled) && (0, import_jsx_runtime6.jsx)(Stack, { space: 1, children: isEditing ? (0, import_jsx_runtime6.jsx)(Stack, { space: 2, ref: clickOutsideBoundaryRef, children: (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: !!focused, children: (0, import_jsx_runtime6.jsx)("div", { ref: autocompletePopoverReferenceElementRef, children: (0, import_jsx_runtime6.jsx)(ReferenceAutocomplete$2, { ...elementProps, "data-testid": "autocomplete", loading: searchState.isLoading, referenceElement: autocompletePopoverReferenceElementRef.current, portalRef: autocompletePortalRef, id: inputId || "", options: searchState.hits.map((hit) => ({ value: hit.id, hit })), onFocus: handleAutocompleteFocus, radius: 1, placeholder: t3("inputs.reference.search-placeholder"), onKeyDown: handleAutocompleteKeyDown, readOnly, disabled: loadableReferenceInfo.isLoading, onQueryChange: handleQueryChange, searchString: searchState.searchString, onChange: handleChange, filterOption: NO_FILTER$2, renderOption, openButton: { onClick: handleAutocompleteOpenButtonClick } }) }) }) }) : (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: !!focused, children: (0, import_jsx_runtime6.jsxs)(Card, { padding: 0, border: true, flex: 1, radius: 1, tone: readOnly ? "transparent" : loadableReferenceInfo.error || errors.length > 0 ? "critical" : "default", children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", padding: 1, children: [studioUrl ? (0, import_jsx_runtime6.jsx)(PreviewCard$1, { as: "a", target: "_blank", rel: "noopener noreferrer", href: studioUrl, "data-as": "a", flex: 1, padding: 1, paddingRight: 3, radius: 2, tone: "inherit", __unstable_focusRing: true, tabIndex: 0, onFocus: handleFocus, ref: elementProps.ref, children: (0, import_jsx_runtime6.jsx)(PreviewReferenceValue, { value, referenceInfo: loadableReferenceInfo, showStudioUrlIcon: true, hasStudioUrl: !!studioUrl, type: schemaType }) }) : (0, import_jsx_runtime6.jsx)(PreviewCard$1, { flex: 1, padding: 1, paddingRight: 3, radius: 2, tone: "inherit", __unstable_focusRing: true, tabIndex: 0, onFocus: handleFocus, ref: elementProps.ref, children: (0, import_jsx_runtime6.jsx)(PreviewReferenceValue, { value, referenceInfo: loadableReferenceInfo, showStudioUrlIcon: true, type: schemaType }) }), (0, import_jsx_runtime6.jsx)(Inline, { paddingX: 1, children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon, "data-testid": "menu-button" }), id: "".concat(inputId, "-menuButton"), menu: (0, import_jsx_runtime6.jsx)(Menu, { children: !readOnly && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.reference.action.clear"), tone: "critical", icon: ResetIcon, "data-testid": "menu-item-clear", onClick: handleClear }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.reference.action.replace"), icon: SyncIcon, "data-testid": "menu-item-replace", onClick: handleReplace })] }) }), placement: "right", popover: { portal: true, tone: "default" } }) })] }), showWeakRefMismatch && (0, import_jsx_runtime6.jsx)(ReferenceStrengthMismatchAlertStrip, { actualStrength, handleFixStrengthMismatch }), loadableReferenceInfo.error && (0, import_jsx_runtime6.jsx)(ReferenceMetadataLoadErrorAlertStrip, { errorMessage: loadableReferenceInfo.error.message, onHandleRetry: loadableReferenceInfo.retry })] }) }) })] });
}
function search(client, textTerm, type, options) {
  const searchWeighted = createWeightedSearch(type.to.map((crossDatasetType) => ({
    name: crossDatasetType.type,
    // eslint-disable-next-line camelcase
    __experimental_search: crossDatasetType.__experimental_search
  })), client, options);
  return searchWeighted(textTerm, { includeDrafts: false }).pipe(
    // pick the 100 best matches
    map((results) => results.map((result) => result.hit)),
    map(collate),
    map((collated) => collated.map((entry) => ({ id: entry.id, type: entry.type, published: entry.published })))
  );
}
var REQUEST_TAG_BASE = "cross-dataset-refs";
var AVAILABILITY_READABLE$1 = { available: true, reason: "READABLE" };
var AVAILABILITY_PERMISSION_DENIED$1 = { available: false, reason: "PERMISSION_DENIED" };
var AVAILABILITY_NOT_FOUND$1 = { available: false, reason: "NOT_FOUND" };
function createGetReferenceInfo(context) {
  const { client, documentPreviewStore } = context;
  const { dataset: dataset2, projectId: projectId2 } = client.config();
  const apiConfig = dataset2 && projectId2 ? { dataset: dataset2, projectId: projectId2 } : void 0;
  return function getReferenceInfo2(doc, referenceType) {
    return (doc._type ? of(doc) : documentPreviewStore.observeDocumentTypeFromId(doc._id, apiConfig).pipe(map((docType) => ({ _id: doc._id, _type: docType })))).pipe(switchMap((resolvedDoc) => {
      if (!resolvedDoc._type) {
        return fetchDocumentAvailability(client, doc._id).pipe(map((availability) => ({ id: doc._id, type: void 0, availability, preview: { published: void 0 } })));
      }
      const refSchemaType = referenceType.to.find((candidate) => candidate.type === resolvedDoc._type);
      const previewPaths = [...getPreviewPaths(refSchemaType == null ? void 0 : refSchemaType.preview) || [], ["_updatedAt"], ["_createdAt"]];
      const publishedPreview$ = documentPreviewStore.observePaths(doc, previewPaths, apiConfig).pipe(map((result) => result ? prepareForPreview(result, refSchemaType) : result));
      return combineLatest([publishedPreview$]).pipe(map((_ref227) => {
        let [publishedPreview] = _ref227;
        return { type: resolvedDoc._type, id: doc._id, availability: AVAILABILITY_READABLE$1, preview: { published: isRecord$4(publishedPreview) ? publishedPreview : void 0 } };
      }));
    }));
  };
}
function fetchDocumentAvailability(client, id4) {
  const requestOptions2 = { uri: client.getDataUrl("doc", id4), json: true, query: { excludeContent: "true" }, tag: "".concat(REQUEST_TAG_BASE, ".availability") };
  return client.observable.request(requestOptions2).pipe(map((response) => {
    const omitted = (0, import_keyBy.default)(response.omitted || [], (entry) => entry.id);
    const omittedEntry = omitted[id4];
    if (!omittedEntry) {
      return AVAILABILITY_READABLE$1;
    }
    if (omittedEntry.reason === "existence") {
      return AVAILABILITY_NOT_FOUND$1;
    }
    if (omittedEntry.reason === "permission") {
      return AVAILABILITY_PERMISSION_DENIED$1;
    }
    return null;
  }));
}
async function resolveUserDefinedFilter$2(options, document2, valuePath, getClient) {
  if (!options) {
    return {};
  }
  if (typeof options.filter === "function") {
    const parentPath = valuePath.slice(0, -1);
    const parent = get(document2, parentPath);
    const resolvedFilter = await options.filter({ document: document2, parentPath, parent, getClient });
    return resolvedFilter;
  }
  return { filter: options.filter, params: "filterParams" in options ? options.filterParams : void 0 };
}
function useValueRef$2(value) {
  const ref = (0, import_react51.useRef)(value);
  ref.current = value;
  return ref;
}
function StudioCrossDatasetReferenceInput(props2) {
  const { path: path2, schemaType } = props2;
  const source = useSource();
  const client = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const documentPreviewStore = useDocumentPreviewStore();
  const getClient = source.getClient;
  const crossDatasetClient = (0, import_react51.useMemo)(() => {
    return client.withConfig({ dataset: schemaType.dataset, apiVersion: "2022-03-07", ignoreBrowserTokenWarning: true }).clone();
  }, [client, schemaType.dataset]);
  const documentValue = useFormValue([]);
  const documentRef = useValueRef$2(documentValue);
  const handleSearch = (0, import_react51.useCallback)((searchString) => from(resolveUserDefinedFilter$2(schemaType.options, documentRef.current, path2, getClient)).pipe(mergeMap((_ref228) => {
    let { filter: filter3, params } = _ref228;
    return search(crossDatasetClient, searchString, schemaType, { ...schemaType.options, filter: filter3, params, tag: "search.cross-dataset-reference" });
  }), catchError((err) => {
    var _a4;
    const isQueryError = err.details && err.details.type === "queryParseError";
    if (((_a4 = schemaType.options) == null ? void 0 : _a4.filter) && isQueryError) {
      err.message = 'Invalid reference filter, please check the custom "filter" option';
    }
    return throwError(err);
  })), [crossDatasetClient, documentRef, path2, schemaType, getClient]);
  const getReferenceInfo2 = (0, import_react51.useMemo)(() => createGetReferenceInfo({ client: crossDatasetClient, documentPreviewStore }), [crossDatasetClient, documentPreviewStore]);
  return (0, import_jsx_runtime6.jsx)(CrossDatasetReferenceInput, { ...props2, getReferenceInfo: getReferenceInfo2, onSearch: handleSearch });
}
function useValueRef$1(value) {
  const ref = (0, import_react51.useRef)(value);
  ref.current = value;
  return ref;
}
async function resolveUserDefinedFilter$1(options, document2, valuePath, getClient) {
  if (!options) {
    return {};
  }
  if (typeof options.filter === "function") {
    const parentPath = valuePath.slice(0, -1);
    const parent = get(document2, parentPath);
    return options.filter({ document: document2, parentPath, parent, getClient });
  }
  return { filter: options.filter, params: "filterParams" in options ? options.filterParams : void 0 };
}
function useReferenceInput(options) {
  var _a4, _b4, _c4, _d4;
  const { path: path2, schemaType } = options;
  const source = useSource();
  const client = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const schema = useSchema();
  const documentPreviewStore = useDocumentPreviewStore();
  const searchClient = (0, import_react51.useMemo)(() => client.withConfig({ apiVersion: "2021-03-25" }), [client]);
  const { EditReferenceLinkComponent, onEditReference, activePath, initialValueTemplateItems } = useReferenceInputOptions();
  const documentValue = useFormValue([]);
  const documentRef = useValueRef$1(documentValue);
  const documentTypeName = (_a4 = documentRef.current) == null ? void 0 : _a4._type;
  const isCurrentDocumentLiveEdit = (0, import_react51.useMemo)(() => {
    var _a22;
    return (_a22 = schema.get(documentTypeName)) == null ? void 0 : _a22.liveEdit;
  }, [documentTypeName, schema]);
  const disableNew = ((_b4 = schemaType.options) == null ? void 0 : _b4.disableNew) === true;
  const getClient = source.getClient;
  const handleSearch = (0, import_react51.useCallback)((searchString) => from(resolveUserDefinedFilter$1(schemaType.options, documentRef.current, path2, getClient)).pipe(mergeMap((_ref229) => {
    let { filter: filter3, params } = _ref229;
    return referenceSearch(searchClient, searchString, schemaType, { ...schemaType.options, filter: filter3, params, tag: "search.reference" });
  }), catchError((err) => {
    var _a22;
    const isQueryError = err.details && err.details.type === "queryParseError";
    if (((_a22 = schemaType.options) == null ? void 0 : _a22.filter) && isQueryError) {
      err.message = 'Invalid reference filter, please check the custom "filter" option';
    }
    return throwError(err);
  })), [documentRef, path2, searchClient, schemaType, getClient]);
  const template = (_d4 = (_c4 = options.value) == null ? void 0 : _c4._strengthenOnPublish) == null ? void 0 : _d4.template;
  const EditReferenceLink = (0, import_react51.useMemo)(() => (0, import_react51.forwardRef)(function EditReferenceLink_(_props, forwardedRef) {
    return EditReferenceLinkComponent ? (0, import_jsx_runtime6.jsx)(EditReferenceLinkComponent, { ..._props, ref: forwardedRef, parentRefPath: path2, template }) : null;
  }), [EditReferenceLinkComponent, path2, template]);
  const handleEditReference = (0, import_react51.useCallback)((event) => {
    onEditReference == null ? void 0 : onEditReference({ parentRefPath: path2, id: event.id, type: event.type, template: event.template });
  }, [onEditReference, path2]);
  const selectedState = startsWith(path2, (activePath == null ? void 0 : activePath.path) || []) ? activePath == null ? void 0 : activePath.state : "none";
  const createOptions = (0, import_react51.useMemo)(() => {
    if (disableNew) {
      return [];
    }
    return (initialValueTemplateItems || []).filter((i) => schemaType.to.some((refType) => {
      var _a22;
      return refType.name === ((_a22 = i.template) == null ? void 0 : _a22.schemaType);
    })).map((item) => {
      var _a22;
      return ((_a22 = item.template) == null ? void 0 : _a22.schemaType) ? { id: item.id, title: item.title || "".concat(item.template.schemaType, " from template ").concat(item.template.id), type: item.template.schemaType, icon: item.icon, template: { id: item.template.id, params: item.parameters }, permission: { granted: item.granted, reason: item.reason } } : void 0;
    }).filter(isNonNullable$3);
  }, [disableNew, initialValueTemplateItems, schemaType.to]);
  const getReferenceInfo$1 = (0, import_react51.useCallback)((id4) => getReferenceInfo(documentPreviewStore, id4, schemaType), [documentPreviewStore, schemaType]);
  return { selectedState, handleSearch, isCurrentDocumentLiveEdit, handleEditReference, EditReferenceLink, createOptions, getReferenceInfo: getReferenceInfo$1 };
}
function OptionPreview(props2) {
  const { getReferenceInfo: getReferenceInfo2, id: documentId, renderPreview } = props2;
  const { isLoading, result: referenceInfo, error: error2 } = useReferenceInfo$1(documentId, getReferenceInfo2);
  const { t: t3 } = useTranslation2();
  if (isLoading) {
    return (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, padding: 1, children: [(0, import_jsx_runtime6.jsx)(TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: true }), (0, import_jsx_runtime6.jsx)(TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: true })] });
  }
  if (error2) {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 1, children: (0, import_jsx_runtime6.jsx)(Alert, { title: t3("inputs.reference.error.failed-to-load-document-title"), children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: error2.message }) }) });
  }
  if (!referenceInfo) {
    return null;
  }
  if (referenceInfo.availability.reason === "PERMISSION_DENIED") {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 1, children: t3("inputs.reference.error.missing-read-permissions-description") });
  }
  const refType = props2.type.to.find((toType) => toType.name === referenceInfo.type);
  if (!refType) {
    return (0, import_jsx_runtime6.jsx)(Stack, { space: 2, padding: 1, children: t3("inputs.reference.error.invalid-search-result-type-title", { returnedType: referenceInfo.type }) });
  }
  return referenceInfo && refType && (0, import_jsx_runtime6.jsx)(ReferencePreview, { id: referenceInfo.id, layout: "default", preview: referenceInfo.preview, refType, renderPreview, showTypeLabel: props2.type.to.length > 1 });
}
var INLINE_BLOCK_STYLE = { display: "inline-flex" };
var FULL_WIDTH = { width: "100%" };
var POPOVER_PROPS = { portal: true, tone: "default", constrainSize: true, fallbackPlacements: ["bottom", "left", "top"], placement: "right", preventOverflow: true };
function CreateButton(props2) {
  const { createOptions, onCreate, id: id4, menuRef, ...rest } = props2;
  const currentUser = useCurrentUser();
  const { t: t3 } = useTranslation2();
  const canCreateAny = createOptions.some((option) => option.permission.granted);
  if (!canCreateAny) {
    return (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(InsufficientPermissionsMessage, { currentUser, context: "create-new-reference" }) }), children: (0, import_jsx_runtime6.jsx)("div", { style: INLINE_BLOCK_STYLE, children: (0, import_jsx_runtime6.jsx)(Button, { text: t3("inputs.reference.create-new-document"), mode: "ghost", disabled: true, icon: AddIcon, style: FULL_WIDTH }) }) });
  }
  return createOptions.length > 1 ? (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { ...rest, disabled: props2.readOnly, text: t3("inputs.reference.action-create-new-document-select"), mode: "ghost", icon: AddIcon }), id: id4, menu: (0, import_jsx_runtime6.jsx)(Menu, { ref: menuRef, children: createOptions.map((createOption) => (0, import_jsx_runtime6.jsx)(Tooltip, { disabled: createOption.permission.granted, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(InsufficientPermissionsMessage, { currentUser, context: "create-document-type" }) }), portal: true, children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(MenuItem, { disabled: !createOption.permission.granted, icon: createOption.icon, text: createOption.title, onClick: () => onCreate(createOption) }) }) }, createOption.id)) }), popover: POPOVER_PROPS }) : (0, import_jsx_runtime6.jsx)(Button, { ...rest, text: t3("inputs.reference.action-create-new-document-select"), mode: "ghost", disabled: !createOptions[0].permission.granted || props2.readOnly, onClick: () => onCreate(createOptions[0]), icon: AddIcon });
}
var __freeze$1j = Object.freeze;
var __defProp$1j = Object.defineProperty;
var __template$1j = (cooked, raw) => __freeze$1j(__defProp$1j(cooked, "raw", { value: __freeze$1j(raw || cooked.slice()) }));
var _a$1j;
var _b$D;
var StyledPopover$1 = st(Popover)(_a$1j || (_a$1j = __template$1j(["\n  & > div {\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n  }\n"])));
var StyledText$2 = st(Text3)(_b$D || (_b$D = __template$1j(["\n  word-break: break-word;\n"])));
var FALLBACK_PLACEMENTS$1 = ["top-start", "bottom-start"];
var ReferenceAutocomplete$1 = (0, import_react51.forwardRef)(function ReferenceAutocomplete22(props2, ref) {
  const { searchString, loading, portalRef, referenceElement, ...restProps } = props2;
  const { t: t3 } = useTranslation2();
  const hasResults = props2.options && props2.options.length > 0;
  const renderPopover = (0, import_react51.useCallback)((_ref230, contentRef) => {
    let { content, hidden, inputElement, onMouseEnter, onMouseLeave } = _ref230;
    return (0, import_jsx_runtime6.jsx)(StyledPopover$1, { placement: "bottom-start", fallbackPlacements: FALLBACK_PLACEMENTS$1, arrow: false, constrainSize: true, onMouseEnter, onMouseLeave, content: (0, import_jsx_runtime6.jsx)("div", { ref: contentRef, children: hasResults ? content : (0, import_jsx_runtime6.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", height: "fill", justify: "center", children: (0, import_jsx_runtime6.jsx)(StyledText$2, { align: "center", muted: true, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.reference.no-results-for-query", values: { searchTerm: searchString || "" } }) }) }) }) }), open: !loading && !hidden, ref: portalRef, portal: true, referenceElement: referenceElement || inputElement, matchReferenceWidth: true });
  }, [hasResults, t3, searchString, loading, portalRef, referenceElement]);
  return (0, import_jsx_runtime6.jsx)(Autocomplete, { ...restProps, loading, ref, renderPopover });
});
var __freeze$1i = Object.freeze;
var __defProp$1i = Object.defineProperty;
var __template$1i = (cooked, raw) => __freeze$1i(__defProp$1i(cooked, "raw", { value: __freeze$1i(raw || cooked.slice()) }));
var _a$1i;
var _b$C;
var NARROW_LAYOUT = nt(_a$1i || (_a$1i = __template$1i(["\n  grid-template-columns: minmax(0px, 1fr);\n"])));
var WIDE_LAYOUT = nt(_b$C || (_b$C = __template$1i(["\n  grid-template-columns: 1fr min-content;\n"])));
var Root$e2 = st(Grid)((props2) => props2.$narrow ? NARROW_LAYOUT : WIDE_LAYOUT);
var AutocompleteContainer = (0, import_react51.forwardRef)(function AutocompleteContainer2(props2, forwardedRef) {
  const [rootElement, setRootElement] = (0, import_react51.useState)(null);
  const handleNewRef = (0, import_react51.useCallback)((element) => {
    setForwardedRef(forwardedRef, element);
    setRootElement(element);
  }, [forwardedRef]);
  const inputWrapperRect = useElementRect(rootElement);
  return (0, import_jsx_runtime6.jsx)(Root$e2, { ref: handleNewRef, gap: 1, $narrow: ((inputWrapperRect == null ? void 0 : inputWrapperRect.width) || 0) < 480, children: props2.children });
});
function setForwardedRef(ref, instance2) {
  if (typeof ref === "function") {
    ref(instance2);
  } else if (ref) {
    ref.current = instance2;
  }
}
var __freeze$1h = Object.freeze;
var __defProp$1h = Object.defineProperty;
var __template$1h = (cooked, raw) => __freeze$1h(__defProp$1h(cooked, "raw", { value: __freeze$1h(raw || cooked.slice()) }));
var _a$1h;
var StyledPreviewCard = st(PreviewCard$1)(_a$1h || (_a$1h = __template$1h(["\n  /* this is a hack to avoid layout jumps while previews are loading\n  there's probably better ways of solving this */\n  min-height: 36px;\n"])));
var INITIAL_SEARCH_STATE$1 = { hits: [], isLoading: false };
var NO_FILTER$1 = () => true;
function nonNullable$1(v) {
  return v !== null;
}
function ReferenceInput(props2) {
  var _a22, _b4, _c4, _d4, _e3, _f3;
  const { createOptions, onChange, onEditReference, onSearch, schemaType, readOnly, id: id4, onPathFocus, value, renderPreview, path: path2, elementProps, focusPath } = props2;
  const { getReferenceInfo: getReferenceInfo2 } = useReferenceInput({ path: path2, schemaType, value });
  const [searchState, setSearchState] = (0, import_react51.useState)(INITIAL_SEARCH_STATE$1);
  const handleCreateNew = (0, import_react51.useCallback)((option) => {
    const newDocumentId = v4_default();
    const patches = [setIfMissing2({}), set$2(schemaType.name, ["_type"]), set$2(newDocumentId, ["_ref"]), set$2(true, ["_weak"]), set$2({ type: option.type, weak: schemaType.weak, template: option.template }, ["_strengthenOnPublish"])].filter(isNonNullable$3);
    onChange(patches);
    onEditReference({ id: newDocumentId, type: option.type, template: option.template });
    onPathFocus([]);
  }, [onChange, onEditReference, onPathFocus, schemaType]);
  const handleChange = (0, import_react51.useCallback)((nextId) => {
    if (!nextId) {
      onChange(unset2());
      onPathFocus([]);
      return;
    }
    const hit = searchState.hits.find((h) => h.id === nextId);
    if (!hit) {
      throw new Error("Selected an item that wasnt part of the result set");
    }
    const patches = [setIfMissing2({}), set$2(schemaType.name, ["_type"]), set$2(getPublishedId(nextId), ["_ref"]), hit.published && !schemaType.weak ? unset2(["_weak"]) : set$2(true, ["_weak"]), hit.published ? unset2(["_strengthenOnPublish"]) : set$2({ type: hit == null ? void 0 : hit.type, weak: schemaType.weak }, ["_strengthenOnPublish"])].filter(isNonNullable$3);
    onChange(patches);
    onPathFocus([]);
  }, [onChange, onPathFocus, schemaType.name, schemaType.weak, searchState.hits]);
  const handleClear = (0, import_react51.useCallback)(() => {
    onChange(unset2());
  }, [onChange]);
  const handleCancelEdit = (0, import_react51.useCallback)(() => {
    if (!(value == null ? void 0 : value._ref)) {
      handleClear();
    }
  }, [handleClear, value == null ? void 0 : value._ref]);
  const handleAutocompleteKeyDown = (0, import_react51.useCallback)((event) => {
    if (event.key === "Escape") {
      onPathFocus([]);
    }
  }, [onPathFocus]);
  const loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2);
  const autocompletePopoverReferenceElementRef = (0, import_react51.useRef)(null);
  const { push } = useToast();
  const { t: t3 } = useTranslation2();
  const handleQueryChange = useObservableCallback((inputValue$) => {
    return inputValue$.pipe(filter(nonNullable$1), switchMap((searchString) => concat(of({ isLoading: true }), onSearch(searchString).pipe(map((hits2) => ({ hits: hits2, searchString, isLoading: false })), catchError((error2) => {
      push({ title: t3("inputs.reference.error.search-failed-title"), description: error2.message, status: "error", id: "reference-search-fail-".concat(id4) });
      console.error(error2);
      return of({ hits: [] });
    })))), scan((prevState, nextState) => ({ ...prevState, ...nextState }), INITIAL_SEARCH_STATE$1), tap(setSearchState));
  }, [id4, onSearch, push, t3]);
  const handleAutocompleteOpenButtonClick = (0, import_react51.useCallback)(() => {
    handleQueryChange("");
  }, [handleQueryChange]);
  const handleCreateButtonKeyDown = (0, import_react51.useCallback)((e2) => {
    if (e2.key === "Escape") {
      onPathFocus([]);
    }
  }, [onPathFocus]);
  const renderOption = (0, import_react51.useCallback)((option) => {
    var _a32, _b22;
    const documentId = ((_a32 = option.hit.draft) == null ? void 0 : _a32._id) || ((_b22 = option.hit.published) == null ? void 0 : _b22._id) || option.value;
    return (0, import_jsx_runtime6.jsx)(StyledPreviewCard, { forwardedAs: "button", type: "button", radius: 2, tone: "inherit", children: (0, import_jsx_runtime6.jsx)(Box, { paddingX: 3, paddingY: 1, children: (0, import_jsx_runtime6.jsx)(OptionPreview, { getReferenceInfo: getReferenceInfo2, id: documentId, renderPreview, type: schemaType }) }) });
  }, [schemaType, getReferenceInfo2, renderPreview]);
  const renderValue = (0, import_react51.useCallback)(() => {
    var _a32, _b22, _c22, _d22;
    return ((_b22 = (_a32 = loadableReferenceInfo.result) == null ? void 0 : _a32.preview.draft) == null ? void 0 : _b22.title) || ((_d22 = (_c22 = loadableReferenceInfo.result) == null ? void 0 : _c22.preview.published) == null ? void 0 : _d22.title) || "";
  }, [(_b4 = (_a22 = loadableReferenceInfo.result) == null ? void 0 : _a22.preview.draft) == null ? void 0 : _b4.title, (_d4 = (_c4 = loadableReferenceInfo.result) == null ? void 0 : _c4.preview.published) == null ? void 0 : _d4.title]);
  const handleFocus = (0, import_react51.useCallback)(() => onPathFocus(["_ref"]), [onPathFocus]);
  const handleBlur = (0, import_react51.useCallback)((event) => {
    var _a32;
    if (!((_a32 = autocompletePopoverReferenceElementRef.current) == null ? void 0 : _a32.contains(event.relatedTarget))) {
      props2.elementProps.onBlur(event);
    }
  }, [props2.elementProps]);
  const isWeakRefToNonexistent = ((_f3 = (_e3 = loadableReferenceInfo == null ? void 0 : loadableReferenceInfo.result) == null ? void 0 : _e3.availability) == null ? void 0 : _f3.reason) === "NOT_FOUND" && !(value == null ? void 0 : value._strengthenOnPublish) && (value == null ? void 0 : value._weak);
  useDidUpdate((focusPath == null ? void 0 : focusPath[0]) === "_ref", (hadFocusAtRef, hasFocusAtRef) => {
    var _a32;
    if (!hadFocusAtRef && hasFocusAtRef) {
      (_a32 = elementProps.ref.current) == null ? void 0 : _a32.focus();
    }
  });
  const hits = (0, import_react51.useMemo)(() => searchState.hits.map((hit) => ({ value: hit.id, hit })), [searchState.hits]);
  const isEditing = focusPath.length === 1 && focusPath[0] === "_ref";
  const { menuRef, containerRef } = useReferenceItemRef();
  const clickOutsideBoundaryRef = (0, import_react51.useRef)(null);
  const autoCompletePortalRef = (0, import_react51.useRef)(null);
  const createButtonMenuPortalRef = (0, import_react51.useRef)(null);
  useOnClickOutside([containerRef, clickOutsideBoundaryRef, autoCompletePortalRef, createButtonMenuPortalRef, menuRef], () => {
    if (isEditing) {
      handleCancelEdit();
    }
  });
  return (0, import_jsx_runtime6.jsx)(Stack, { space: 1, "data-testid": "reference-input", ref: clickOutsideBoundaryRef, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [isWeakRefToNonexistent ? (0, import_jsx_runtime6.jsx)(Alert, { "data-testid": "alert-nonexistent-document", title: t3("inputs.reference.error.nonexistent-document-title"), suffix: (0, import_jsx_runtime6.jsx)(Stack, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Button, { text: t3("inputs.reference.error.nonexistent-document.clear-button-label"), onClick: handleClear }) }), children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { i18nKey: "inputs.reference.error.nonexistent-document-description", t: t3, values: { documentId: value._ref } }) }) }) : null, (0, import_jsx_runtime6.jsxs)(AutocompleteContainer, { ref: autocompletePopoverReferenceElementRef, children: [(0, import_jsx_runtime6.jsx)(ReferenceAutocomplete$1, { ...elementProps, onFocus: handleFocus, onBlur: handleBlur, "data-testid": "autocomplete", loading: searchState.isLoading, referenceElement: autocompletePopoverReferenceElementRef.current, options: hits, radius: 1, placeholder: t3("inputs.reference.search-placeholder"), onKeyDown: handleAutocompleteKeyDown, readOnly: loadableReferenceInfo.isLoading || readOnly, onQueryChange: handleQueryChange, searchString: searchState.searchString, onChange: handleChange, filterOption: NO_FILTER$1, renderOption, renderValue, openButton: { onClick: handleAutocompleteOpenButtonClick }, portalRef: autoCompletePortalRef, value: value == null ? void 0 : value._ref }), createOptions.length > 0 && (0, import_jsx_runtime6.jsx)(CreateButton, { id: "".concat(id4, "-selectTypeMenuButton"), readOnly, createOptions, onCreate: handleCreateNew, onKeyDown: handleCreateButtonKeyDown, menuRef: createButtonMenuPortalRef })] })] }) });
}
async function resolveUserDefinedFilter(options, document2, valuePath, getClient) {
  if (!options) {
    return {};
  }
  if (typeof options.filter === "function") {
    const parentPath = valuePath.slice(0, -1);
    const parent = get(document2, parentPath);
    const resolvedFilter = await options.filter({ document: document2, parentPath, parent, getClient });
    return resolvedFilter;
  }
  return { filter: options.filter, params: "filterParams" in options ? options.filterParams : void 0 };
}
function useValueRef(value) {
  const ref = (0, import_react51.useRef)(value);
  ref.current = value;
  return ref;
}
function StudioReferenceInput(props2) {
  var _a4, _b4, _c4, _d4;
  const source = useSource();
  const searchClient = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const schema = useSchema();
  const documentPreviewStore = useDocumentPreviewStore();
  const { path: path2, schemaType } = props2;
  const { EditReferenceLinkComponent, onEditReference, activePath, initialValueTemplateItems } = useReferenceInputOptions();
  const documentValue = useFormValue([]);
  const documentRef = useValueRef(documentValue);
  const documentTypeName = (_a4 = documentRef.current) == null ? void 0 : _a4._type;
  const refType = schema.get(documentTypeName);
  const isDocumentLiveEdit = (0, import_react51.useMemo)(() => refType == null ? void 0 : refType.liveEdit, [refType]);
  const disableNew = ((_b4 = schemaType.options) == null ? void 0 : _b4.disableNew) === true;
  const getClient = source.getClient;
  const handleSearch = (0, import_react51.useCallback)((searchString) => from(resolveUserDefinedFilter(schemaType.options, documentRef.current, path2, getClient)).pipe(mergeMap((_ref231) => {
    let { filter: filter3, params } = _ref231;
    return referenceSearch(searchClient, searchString, schemaType, { ...schemaType.options, filter: filter3, params, tag: "search.reference" });
  }), catchError((err) => {
    var _a22;
    const isQueryError = err.details && err.details.type === "queryParseError";
    if (((_a22 = schemaType.options) == null ? void 0 : _a22.filter) && isQueryError) {
      err.message = 'Invalid reference filter, please check the custom "filter" option';
    }
    return throwError(err);
  })), [documentRef, path2, searchClient, schemaType, getClient]);
  const template = (_d4 = (_c4 = props2.value) == null ? void 0 : _c4._strengthenOnPublish) == null ? void 0 : _d4.template;
  const EditReferenceLink = (0, import_react51.useMemo)(() => (0, import_react51.forwardRef)(function EditReferenceLink_(_props, forwardedRef) {
    return EditReferenceLinkComponent ? (0, import_jsx_runtime6.jsx)(EditReferenceLinkComponent, { ..._props, ref: forwardedRef, parentRefPath: path2, template }) : null;
  }), [EditReferenceLinkComponent, path2, template]);
  const handleEditReference = (0, import_react51.useCallback)((event) => {
    onEditReference == null ? void 0 : onEditReference({ parentRefPath: path2, id: event.id, type: event.type, template: event.template });
  }, [onEditReference, path2]);
  const selectedState = startsWith(path2, (activePath == null ? void 0 : activePath.path) || []) ? activePath == null ? void 0 : activePath.state : "none";
  const createOptions = (0, import_react51.useMemo)(() => {
    if (disableNew) {
      return [];
    }
    return (initialValueTemplateItems || []).filter((i) => {
      return schemaType.to.some((_refType) => {
        var _a22;
        return _refType.name === ((_a22 = i.template) == null ? void 0 : _a22.schemaType);
      });
    }).map((item) => {
      var _a22, _b22, _c22;
      return ((_a22 = item.template) == null ? void 0 : _a22.schemaType) ? { id: item.id, title: item.title || "".concat(item.template.schemaType, " from template ").concat((_b22 = item.template) == null ? void 0 : _b22.id), type: item.template.schemaType, icon: item.icon, template: { id: (_c22 = item.template) == null ? void 0 : _c22.id, params: item.parameters }, permission: { granted: item.granted, reason: item.reason } } : void 0;
    }).filter(isNonNullable$3);
  }, [disableNew, initialValueTemplateItems, schemaType.to]);
  const getReferenceInfo$1 = (0, import_react51.useCallback)((id4, _type) => getReferenceInfo(documentPreviewStore, id4, _type), [documentPreviewStore]);
  return (0, import_jsx_runtime6.jsx)(ReferenceInput, { ...props2, onSearch: handleSearch, liveEdit: isDocumentLiveEdit, getReferenceInfo: getReferenceInfo$1, selectedState, editReferenceLinkComponent: EditReferenceLink, createOptions, onEditReference: handleEditReference });
}
function isObjectItemProps(item) {
  return isObjectSchemaType(item.schemaType);
}
function isObjectInputProps(inputProps) {
  return isObjectSchemaType(inputProps.schemaType);
}
function isStringInputProps(inputProps) {
  return isStringSchemaType(inputProps.schemaType);
}
function isNumberInputProps(inputProps) {
  return isNumberSchemaType(inputProps.schemaType);
}
function isBooleanInputProps(inputProps) {
  return isBooleanSchemaType(inputProps.schemaType);
}
function isArrayOfObjectsInputProps(inputProps) {
  return isArrayOfObjectsSchemaType(inputProps.schemaType);
}
function isArrayOfBlocksInputProps(inputProps) {
  return isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function isArrayOfPrimitivesInputProps(inputProps) {
  return isArrayOfPrimitivesSchemaType(inputProps.schemaType);
}
function isEqual6(item, otherItem) {
  if (item === otherItem) {
    return true;
  }
  if (typeof item !== typeof otherItem) {
    return false;
  }
  if (typeof item !== "object" && !Array.isArray(item)) {
    return item === otherItem;
  }
  if (item._key && item._key === otherItem._key) {
    return true;
  }
  if (Array.isArray(item)) {
    if (!item.length !== otherItem.length) {
      return false;
    }
    return item.every((it, i) => isEqual6(item[i], otherItem[i]));
  }
  const keys = Object.keys(item);
  const otherKeys = Object.keys(item);
  if (keys.length !== otherKeys.length) {
    return false;
  }
  return keys.every((keyName) => isEqual6(item[keyName], otherItem[keyName]));
}
function inArray(array3, candidate) {
  return array3 ? array3.some((item) => isEqual6(item, candidate)) : false;
}
function getMemberTypeOfItem$1(schemaType, item) {
  return schemaType.of.find((memberType) => memberType.name === resolveTypeName(item));
}
var EMPTY_ARRAY2 = [];
function ArrayOfObjectOptionsInput(props2) {
  var _a4, _b4;
  const { renderPreview, schemaType, onChange, onPathFocus, value = [], readOnly, elementProps, path: path2, changed } = props2;
  const options = (0, import_react51.useMemo)(() => {
    var _a22;
    return (((_a22 = schemaType.options) == null ? void 0 : _a22.list) || EMPTY_ARRAY2).map((option, index) => isKeyedObject(option) ? option : { ...option, _key: "auto-generated-".concat(index) });
  }, [(_a4 = schemaType.options) == null ? void 0 : _a4.list]);
  const handleChange = (0, import_react51.useCallback)((isChecked, changedOption) => {
    if (!isChecked && isKeyedObject(changedOption)) {
      onChange(unset2([{ _key: changedOption._key }]));
      return;
    }
    const nextValue = options.filter((option) => isEqual6(changedOption, option) ? isChecked : inArray(value, option));
    onChange(nextValue.length > 0 ? set$2(nextValue) : unset2());
  }, [onChange, options, value]);
  const handleItemFocus = (0, import_react51.useCallback)((index) => {
    onPathFocus([index]);
  }, [onPathFocus]);
  const isGrid = ((_b4 = schemaType.options) == null ? void 0 : _b4.layout) === "grid";
  return (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: false, children: (0, import_jsx_runtime6.jsx)(Grid, { gap: 2, columns: isGrid ? Math.min(options.length, 4) : 1, tabIndex: 0, ...elementProps, children: options.map((option, index) => {
    const optionType = getMemberTypeOfItem$1(schemaType, option);
    const checked = inArray(value, option);
    const disabled = !optionType;
    return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", as: "label", muted: disabled, children: [(0, import_jsx_runtime6.jsx)(Checkbox, { disabled, checked, onChange: (e2) => handleChange(e2.currentTarget.checked, option), onFocus: () => handleItemFocus(index), readOnly }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, marginLeft: 2, children: optionType ? renderPreview({ layout: "default", schemaType: optionType, value: option }) : (0, import_jsx_runtime6.jsx)(Card, { tone: "caution", radius: 2, children: (0, import_jsx_runtime6.jsx)(IncompatibleItemType$2, { value: option, onFocus: () => handleItemFocus(index) }) }) })] }, index);
  }) }) });
}
var __freeze$1g = Object.freeze;
var __defProp$1g = Object.defineProperty;
var __template$1g = (cooked, raw) => __freeze$1g(__defProp$1g(cooked, "raw", { value: __freeze$1g(raw || cooked.slice()) }));
var _a$1g;
var PopoverCard$1 = st(Card)(_a$1g || (_a$1g = __template$1g(["\n  max-width: ", "px;\n"])), (_ref232) => {
  let { theme } = _ref232;
  return theme.sanity.container[1];
});
function IncompatibleItemType$1(props2) {
  const { value, onFocus, vertical, ...rest } = props2;
  const [showDetails, setShowDetails] = import_react51.default.useState(false);
  const [popoverRef, setPopoverRef] = import_react51.default.useState(null);
  const { t: t3 } = useTranslation2();
  useClickOutside(() => setShowDetails(false), [popoverRef]);
  const handleKeyDown = import_react51.default.useCallback((e2) => {
    if (e2.key === "Escape" || e2.key === "Tab") {
      setShowDetails(false);
    }
  }, []);
  const handleShowDetails = (0, import_react51.useCallback)(() => {
    setShowDetails((v) => !v);
  }, []);
  const typeName = resolveTypeName(value);
  return (0, import_jsx_runtime6.jsx)(Popover, { open: showDetails, ref: setPopoverRef, onKeyDown: handleKeyDown, portal: true, constrainSize: true, tone: "default", content: (0, import_jsx_runtime6.jsx)(PopoverCard$1, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: t3("inputs.array.error.type-is-incompatible-title") }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.current-schema-not-declare-description", values: { typeName } }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, children: [(0, import_jsx_runtime6.jsx)(BulbOutlineIcon, {}), " ", t3("inputs.array.error.can-delete-but-no-edit-description")] }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.array.error.json-representation-description") }), (0, import_jsx_runtime6.jsx)(Card, { padding: 2, overflow: "auto", border: true, children: (0, import_jsx_runtime6.jsx)(Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })] })] }) }), children: (0, import_jsx_runtime6.jsx)(Card, { as: "button", type: "button", radius: 2, tone: "inherit", paddingX: 2, paddingY: 3, flex: 1, onFocus, onClick: handleShowDetails, onKeyDown: handleKeyDown, __unstable_focusRing: true, ...rest, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { marginRight: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(UnknownIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, textOverflow: "ellipsis", children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.type-is-incompatible-prompt", values: { typeName } }) }) })] }) }) });
}
function isPrimitiveOption(option) {
  return Boolean(option && typeof option === "object" && "title" in option && "value" in option);
}
function normalizeOptions(options) {
  return options.map((option) => {
    if (isPrimitiveOption(option)) {
      return { title: option.title || (0, import_startCase2.default)(String(option.value)), value: option.value };
    }
    return { title: (0, import_startCase2.default)(String(option)), value: option };
  });
}
function getMemberTypeOfItem(schemaType, option) {
  return schemaType.of.find((memberType) => memberType.name === resolveTypeName(option.value));
}
function ArrayOfPrimitiveOptionsInput(props2) {
  var _a4, _b4;
  const { schemaType, onChange, value = [], readOnly, path: path2, changed, onIndexFocus, elementProps } = props2;
  const options = (0, import_react51.useMemo)(() => {
    var _a22;
    return normalizeOptions(((_a22 = schemaType.options) == null ? void 0 : _a22.list) || []);
  }, [(_a4 = schemaType.options) == null ? void 0 : _a4.list]);
  const handleChange = (isChecked, changedValue) => {
    const nextValue = options.map((option) => option.value).filter((optionValue) => (
      // note: sparse arrays are not supported here, so multiple options with same value will all be checked
      optionValue === changedValue ? isChecked : value.includes(optionValue)
    ));
    onChange(nextValue.length > 0 ? set$2(nextValue) : unset2());
  };
  const isGrid = ((_b4 = schemaType.options) == null ? void 0 : _b4.layout) === "grid";
  return (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: false, children: (0, import_jsx_runtime6.jsx)(Grid, { gap: 2, columns: isGrid ? Math.min(options.length, 4) : 1, ...elementProps, children: options.map((option, index) => {
    const optionType = getMemberTypeOfItem(schemaType, option);
    const checked = value.includes(option.value);
    const disabled = !optionType;
    return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", as: "label", muted: disabled, children: [(0, import_jsx_runtime6.jsx)(Checkbox, { disabled, checked, onChange: (e2) => handleChange(e2.currentTarget.checked, option.value), onFocus: () => onIndexFocus(index), readOnly }), (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { children: option.title }) }), !optionType && (0, import_jsx_runtime6.jsx)(IncompatibleItemType$1, { value: option, onFocus: () => onIndexFocus(index) })] }, index);
  }) }) });
}
function ArrayOfOptionsInput(props2) {
  return isArrayOfObjectsInputProps(props2) ? (0, import_jsx_runtime6.jsx)(ArrayOfObjectOptionsInput, { ...props2 }) : (0, import_jsx_runtime6.jsx)(ArrayOfPrimitiveOptionsInput, { ...props2 });
}
var __freeze$1f = Object.freeze;
var __defProp$1f = Object.defineProperty;
var __template$1f = (cooked, raw) => __freeze$1f(__defProp$1f(cooked, "raw", { value: __freeze$1f(raw || cooked.slice()) }));
var _a$1f;
var _b$B;
var _c$n;
var _d$e;
var OverlayContainer = st.div(_a$1f || (_a$1f = __template$1f(["\n  position: relative;\n"])));
var ContentContainer = st.div(_b$B || (_b$B = __template$1f(["\n  z-index: 13;\n  opacity: 0;\n  transition: opacity 300ms linear;\n"])));
var CardContainer = st(Card)(_c$n || (_c$n = __template$1f(["\n  border: 1px solid var(--card-border-color);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 12;\n  transition: opacity 150ms ease-in-out;\n  opacity: 0;\n  box-sizing: border-box;\n"])));
var FlexContainer = st(Flex)(_d$e || (_d$e = __template$1f(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n\n  &:hover,\n  &:focus {\n    & ", " {\n      opacity: 0.9;\n    }\n\n    & ", " {\n      opacity: 1;\n    }\n  }\n"])), CardContainer, ContentContainer);
var isTouchDevice = () => typeof window !== "undefined" && "ontouchstart" in window || typeof navigator !== "undefined" && navigator.maxTouchPoints > 0;
function ActivateOnFocus(props2) {
  const { children, message, onActivate, isOverlayActive } = props2;
  const [focused, setFocused] = (0, import_react51.useState)(false);
  const { t: t3 } = useTranslation2();
  const handleClick = (0, import_react51.useCallback)(() => {
    if (onActivate) {
      onActivate();
    }
  }, [onActivate]);
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    if (!isOverlayActive) {
      return;
    }
    if (event.code === "Space" && onActivate) {
      event.preventDefault();
      onActivate();
    }
  }, [isOverlayActive, onActivate]);
  const handleOnFocus = (0, import_react51.useCallback)(() => {
    setFocused(true);
  }, []);
  const handleBlur = (0, import_react51.useCallback)(() => {
    setFocused(false);
  }, []);
  const msg2 = (0, import_react51.useMemo)(() => {
    const isTouch = isTouchDevice();
    let messageContext;
    if (isTouch) {
      messageContext = "tap";
    } else if (focused) {
      messageContext = "click-focused";
    } else {
      messageContext = "click";
    }
    const text = message || t3("inputs.portable-text.activate-on-focus-message", { context: messageContext });
    return (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: text });
  }, [focused, message, t3]);
  return (0, import_jsx_runtime6.jsxs)(OverlayContainer, { onBlur: handleBlur, onClick: handleClick, onFocus: handleOnFocus, onKeyDown: handleKeyDown, children: [isOverlayActive && (0, import_jsx_runtime6.jsxs)(FlexContainer, { "data-testid": "activate-overlay", tabIndex: 0, align: "center", justify: "center", children: [(0, import_jsx_runtime6.jsx)(CardContainer, { radius: 1 }), (0, import_jsx_runtime6.jsx)(ContentContainer, { children: msg2 })] }), children] });
}
var __freeze$1e = Object.freeze;
var __defProp$1e = Object.defineProperty;
var __template$1e = (cooked, raw) => __freeze$1e(__defProp$1e(cooked, "raw", { value: __freeze$1e(raw || cooked.slice()) }));
var _a$1e;
var Root$d2 = st.span(_a$1e || (_a$1e = __template$1e(["\n  /* Make sure the annotation styling is visible */\n  &[data-mark='code'] {\n    mix-blend-mode: multiply;\n    color: inherit;\n  }\n"])));
function Decorator(props2) {
  const { value, focused, selected, children, schemaType } = props2;
  const tag = TEXT_DECORATOR_TAGS[value];
  const CustomComponent = schemaType.component;
  const DefaultComponent2 = (0, import_react51.useCallback)((defaultComponentProps) => {
    return (0, import_jsx_runtime6.jsx)(Root$d2, { as: tag, "data-mark": value, children: defaultComponentProps.children });
  }, [tag, value]);
  return (0, import_react51.useMemo)(() => {
    const componentProps = { focused, renderDefault: DefaultComponent2, schemaType, selected, title: schemaType.title, value };
    return CustomComponent ? (0, import_jsx_runtime6.jsx)(CustomComponent, { ...componentProps, children }) : (0, import_jsx_runtime6.jsx)(DefaultComponent2, { ...componentProps, children });
  }, [CustomComponent, DefaultComponent2, children, focused, schemaType, selected, value]);
}
var MENU_BUTTON_POPOVER_PROPS$1 = { portal: true, constrainSize: true };
var CollapseOverflowMenu = (0, import_react51.forwardRef)(function CollapseOverflowMenu2(props2, forwardedRef) {
  const { disableRestoreFocusOnClose, menuButton, menuButtonProps, menuOptions, onMenuClose } = props2;
  return (0, import_jsx_runtime6.jsx)(MenuButton, { __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose, id: "menu-button", ref: forwardedRef, onClose: onMenuClose, popover: MENU_BUTTON_POPOVER_PROPS$1, ...menuButtonProps, button: menuButton, menu: (0, import_jsx_runtime6.jsx)(Menu, { children: menuOptions.map((c, index) => {
    const {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      collapsedProps = {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      expandedProps = {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      tooltipProps = {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      tooltipText,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      dividerBefore,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      fontSize: fontSize2,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      padding,
      text,
      icon,
      selected,
      ...rest
    } = c.props;
    return (0, import_jsx_runtime6.jsxs)(import_react51.default.Fragment, { children: [dividerBefore && index !== 0 && (0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(MenuItem, { text, icon, pressed: selected, ...rest })] }, c.key);
  }) }) });
});
function ObserveElement(props2) {
  const { onIntersectionChange, children, options, ...rest } = props2;
  const [el, setEl] = (0, import_react51.useState)(null);
  (0, import_react51.useEffect)(() => {
    if (!el)
      return void 0;
    const io = new IntersectionObserver(onIntersectionChange, options);
    io.observe(el);
    return () => {
      io.unobserve(el);
      io.disconnect();
    };
  }, [el, onIntersectionChange, options]);
  return (0, import_jsx_runtime6.jsx)(Flex, { ref: setEl, ...rest, children });
}
var __freeze$1d = Object.freeze;
var __defProp$1d = Object.defineProperty;
var __template$1d = (cooked, raw) => __freeze$1d(__defProp$1d(cooked, "raw", { value: __freeze$1d(raw || cooked.slice()) }));
var _a$1d;
var DividerDiv = st.div(_a$1d || (_a$1d = __template$1d(["\n  border-right: 1px solid var(--card-border-color);\n  height: auto;\n\n  &[data-hidden] {\n    opacity: 0;\n  }\n"])));
function CollapseMenuDivider(props2) {
  const { hidden, ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(DividerDiv, { "data-ui": "CollapseMenuDivider", "data-hidden": hidden ? "" : void 0, ...rest });
}
var __freeze$1c = Object.freeze;
var __defProp$1c = Object.defineProperty;
var __template$1c = (cooked, raw) => __freeze$1c(__defProp$1c(cooked, "raw", { value: __freeze$1c(raw || cooked.slice()) }));
var _a$1c;
var _b$A;
var _c$m;
var _d$d;
var _e$6;
var FOCUS_RING_PADDING = 3;
var OPTION_STYLE = nt(_a$1c || (_a$1c = __template$1c(["\n  list-style: none;\n  display: flex;\n  white-space: nowrap;\n\n  &[data-hidden='true'] {\n    opacity: 0;\n    visibility: hidden;\n  }\n"])));
var OuterFlex = st(Flex)(_b$A || (_b$A = __template$1c(["\n  padding: ", "px;\n  margin: -", "px;\n  box-sizing: border-box;\n"])), FOCUS_RING_PADDING, FOCUS_RING_PADDING);
var RootFlex$3 = st(Flex)(_c$m || (_c$m = __template$1c(["\n  border-radius: inherit;\n  position: relative;\n"])));
var RowFlex = st(Flex)(_d$d || (_d$d = __template$1c(["\n  width: max-content;\n  &[data-hidden='true'] {\n    visibility: hidden;\n    position: relative;\n    margin-top: -1px;\n    height: 1px;\n  }\n"])));
var OptionObserveElement = st(ObserveElement)(_e$6 || (_e$6 = __template$1c(["\n  ", "\n"])), OPTION_STYLE);
function _isReactElement2(node) {
  return Boolean(node);
}
var CollapseMenu = (0, import_react51.forwardRef)(function CollapseMenu2(props2, ref) {
  const { children, collapsed, disableRestoreFocusOnClose, onMenuClose, menuButtonProps, ...rest } = props2;
  const menuOptions = (0, import_react51.useMemo)(() => import_react51.Children.toArray(children).filter(_isReactElement2), [children]);
  const menuButton = (0, import_react51.useMemo)(() => (menuButtonProps == null ? void 0 : menuButtonProps.button) || (0, import_jsx_runtime6.jsx)(Button, { icon: EllipsisVerticalIcon, mode: "bleed" }), [menuButtonProps]);
  if (collapsed) {
    return (0, import_jsx_runtime6.jsx)(CollapseOverflowMenu, { ref, disableRestoreFocusOnClose, menuButton, menuButtonProps, menuOptions, onMenuClose });
  }
  return (0, import_jsx_runtime6.jsx)(AutoCollapseMenu, { ...rest, ref, disableRestoreFocusOnClose, menuButtonProps, menuOptions, onMenuClose });
});
var AutoCollapseMenu = (0, import_react51.forwardRef)(function AutoCollapseMenu2(props2, ref) {
  const { collapseText = true, disableRestoreFocusOnClose, gap, menuOptions, menuButtonProps, onMenuClose, ...rest } = props2;
  const [rootEl, setRootEl] = (0, import_react51.useState)(null);
  const [expandedIntersections, setExpandedIntersections] = (0, import_react51.useState)({});
  const [collapsedIntersections, setCollapsedIntersections] = (0, import_react51.useState)({});
  const intersectionOptions = (0, import_react51.useMemo)(() => ({
    root: rootEl,
    // safari needs threshold to be < 1
    threshold: 0.99,
    rootMargin: "2px"
  }), [rootEl]);
  const menuOptionKeys = (0, import_react51.useMemo)(() => menuOptions.map((child) => child.key), [menuOptions]);
  const pendingIntersections = (0, import_react51.useMemo)(() => [...(0, import_difference3.default)(menuOptionKeys, Object.keys(expandedIntersections)), ...(0, import_difference3.default)(menuOptionKeys, Object.keys(collapsedIntersections))], [menuOptionKeys, expandedIntersections, collapsedIntersections]);
  const overflowingExpandedElements = (0, import_react51.useMemo)(() => menuOptions.filter((optionElement) => {
    const entry = expandedIntersections[optionElement.key];
    return entry && !entry.intersects;
  }), [expandedIntersections, menuOptions]);
  const handleExpandedIntersection = (0, import_react51.useCallback)((e2, element) => {
    setExpandedIntersections((current) => {
      const key2 = element.key;
      if (key2 === null) {
        throw new Error("Expected element to have a non-null key");
      }
      const nextState = { intersects: e2.isIntersecting, element };
      const currentState = current[key2];
      if (!currentState || currentState.intersects !== nextState.intersects) {
        return { ...current, [key2]: nextState };
      }
      return current;
    });
  }, []);
  const handleCollapsedIntersection = (0, import_react51.useCallback)((e2, element) => {
    setCollapsedIntersections((current) => {
      const key2 = element.key;
      if (key2 === null) {
        throw new Error("Expected child element to have a non-null key");
      }
      const currentElementIntersection = current[key2];
      const nextElementIntersection = { intersects: e2.isIntersecting, element };
      return (currentElementIntersection == null ? void 0 : currentElementIntersection.intersects) === nextElementIntersection.intersects ? current : { ...current, [key2]: nextElementIntersection };
    });
  }, []);
  const collapsedElements = (0, import_react51.useMemo)(() => menuOptions.map((optionElement) => {
    const { collapsedProps } = optionElement.props;
    const modeProps = collapsedProps;
    const text = collapseText ? void 0 : optionElement.props.text;
    return (0, import_react51.cloneElement)(optionElement, { ...modeProps, text });
  }), [menuOptions, collapseText]);
  const overflowingCollapsedOptionElements = (0, import_react51.useMemo)(() => menuOptions.filter((optionElement) => {
    const intersection3 = collapsedIntersections[optionElement.key];
    return (intersection3 == null ? void 0 : intersection3.intersects) === false;
  }), [menuOptions, collapsedIntersections]);
  const shouldCollapse = overflowingExpandedElements.length > 0;
  const visibleMenuOptions = shouldCollapse ? collapsedElements.filter((optionElement) => {
    const intersection3 = collapsedIntersections[optionElement.key];
    return (intersection3 == null ? void 0 : intersection3.intersects) === true;
  }) : menuOptions;
  const menuButton = (0, import_react51.useMemo)(() => (menuButtonProps == null ? void 0 : menuButtonProps.button) || (0, import_jsx_runtime6.jsx)(Button, { icon: EllipsisVerticalIcon, mode: "bleed" }), [menuButtonProps]);
  return (0, import_jsx_runtime6.jsxs)(OuterFlex, { align: "center", "data-ui": "CollapseMenu", overflow: "hidden", sizing: "border", ref, ...rest, children: [(0, import_jsx_runtime6.jsxs)(RootFlex$3, { direction: "column", flex: 1, justify: "center", ref: setRootEl, children: [(0, import_jsx_runtime6.jsx)(RowFlex, { gap, children: pendingIntersections.length === 0 && visibleMenuOptions.map((optionElement, index) => {
    const { dividerBefore, tooltipText = "", tooltipProps = {} } = optionElement.props;
    const hidden = !optionElement.key || !(optionElement.key in expandedIntersections) || overflowingCollapsedOptionElements.includes(optionElement);
    return (0, import_jsx_runtime6.jsxs)(import_react51.Fragment, { children: [dividerBefore && index !== 0 && (0, import_jsx_runtime6.jsx)(CollapseMenuDivider, { hidden }), (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, disabled: !tooltipText, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: tooltipText }) }), ...tooltipProps, children: (0, import_jsx_runtime6.jsx)(Flex, { children: (0, import_react51.cloneElement)(optionElement, { disabled: optionElement.props.disabled || hidden, "aria-hidden": hidden }) }) })] }, optionElement.key);
  }) }), (0, import_jsx_runtime6.jsx)(RenderHidden, { gap, elements: menuOptions, intersectionOptions, onIntersectionChange: handleExpandedIntersection }), (0, import_jsx_runtime6.jsx)(RenderHidden, { gap, elements: collapsedElements, intersectionOptions, onIntersectionChange: handleCollapsedIntersection })] }), overflowingCollapsedOptionElements.length > 0 && (0, import_jsx_runtime6.jsx)(Flex, { marginLeft: gap, children: (0, import_jsx_runtime6.jsx)(CollapseOverflowMenu, { disableRestoreFocusOnClose, menuButton, menuButtonProps, menuOptions: overflowingCollapsedOptionElements, onMenuClose }) })] });
});
var RenderHidden = (0, import_react51.memo)(function RenderHidden2(props2) {
  const { elements, gap, intersectionOptions, onIntersectionChange } = props2;
  return (0, import_jsx_runtime6.jsx)(RowFlex, { "data-hidden": true, "aria-hidden": "true", gap, overflow: "hidden", children: elements.map((element, index) => {
    const { dividerBefore } = element.props;
    return (0, import_jsx_runtime6.jsxs)(import_react51.Fragment, { children: [dividerBefore && index !== 0 && (0, import_jsx_runtime6.jsx)(CollapseMenuDivider, { hidden: true }), (0, import_jsx_runtime6.jsx)(OptionObserveElement, { options: intersectionOptions, onIntersectionChange: (e2) => onIntersectionChange(e2[0], element), children: (0, import_jsx_runtime6.jsx)(Flex, { children: (0, import_react51.cloneElement)(element, { disabled: true, "aria-hidden": true }) }) })] }, element.key);
  }) });
});
var CollapseMenuButton = (0, import_react51.forwardRef)(function CollapseMenuButton2(props2, ref) {
  const {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapsedProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    expandedProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tooltipProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tooltipText,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dividerBefore,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ...rest
  } = props2;
  return (0, import_jsx_runtime6.jsx)(Button, { "data-ui": "CollapseMenuButton", ...rest, ref });
});
var __freeze$1b = Object.freeze;
var __defProp$1b = Object.defineProperty;
var __template$1b = (cooked, raw) => __freeze$1b(__defProp$1b(cooked, "raw", { value: __freeze$1b(raw || cooked.slice()) }));
var _a$1b;
var CustomIconDiv = st.div(_a$1b || (_a$1b = __template$1b(["\n  width: 1em;\n  height: 1em;\n  border-radius: inherit;\n  background-origin: content-box;\n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: cover;\n  transform: scale(0.7);\n"])));
function CustomIcon(props2) {
  const { icon, active } = props2;
  const inlineStyle = (0, import_react51.useMemo)(() => ({ backgroundImage: "url(".concat(icon, ")"), filter: active ? "invert(100%)" : "invert(0%)" }), [active, icon]);
  return (0, import_jsx_runtime6.jsx)(CustomIconDiv, { style: inlineStyle });
}
function getPTEFormatActions(editor2, disabled, hotkeyOpts, t3) {
  const types3 = editor2.schemaTypes;
  return types3.decorators.map((decorator) => {
    const shortCutKey = Object.keys(hotkeyOpts.marks || {}).find((key2) => {
      var _a4;
      return ((_a4 = hotkeyOpts.marks) == null ? void 0 : _a4[key2]) === decorator.value;
    });
    let hotkeys = [];
    if (shortCutKey) {
      hotkeys = [shortCutKey];
    }
    return { type: "format", disabled, icon: decorator == null ? void 0 : decorator.icon, key: decorator.value, handle: () => {
      PortableTextEditor.toggleMark(editor2, decorator.value);
      PortableTextEditor.focus(editor2);
    }, hotkeys, title: decorator.i18nTitleKey && t3 ? t3(decorator.i18nTitleKey) : decorator.title };
  });
}
function getPTEListActions(editor2, disabled, t3) {
  const types3 = editor2.schemaTypes;
  return types3.lists.map((listItem) => {
    return { type: "listStyle", key: listItem.value, disabled, icon: listItem == null ? void 0 : listItem.icon, handle: () => {
      PortableTextEditor.toggleList(editor2, listItem.value);
    }, title: listItem.i18nTitleKey && t3 ? t3(listItem.i18nTitleKey) : listItem.title };
  });
}
function getAnnotationIcon(type) {
  return (0, import_get3.default)(type, "icon") || (0, import_get3.default)(type, "type.icon") || (0, import_get3.default)(type, "type.to.icon") || (0, import_get3.default)(type, "type.to[0].icon");
}
function getPTEAnnotationActions(editor2, disabled, onInsert, t3) {
  const types3 = editor2.schemaTypes;
  const focusChild = PortableTextEditor.focusChild(editor2);
  const hasText = focusChild && focusChild.text;
  return types3.annotations.map((aType) => {
    return { type: "annotation", disabled: !hasText || disabled, icon: getAnnotationIcon(aType), key: aType.name, handle: (active) => {
      if (active) {
        PortableTextEditor.removeAnnotation(editor2, aType);
        PortableTextEditor.focus(editor2);
      } else {
        onInsert(aType);
      }
    }, title: aType.i18nTitleKey && t3 ? t3(aType.i18nTitleKey) : aType.title || (0, import_capitalize2.default)(aType.name) };
  });
}
function getPTEToolbarActionGroups(editor2, disabled, onInsertAnnotation, hotkeyOpts, t3) {
  return [{ name: "format", actions: getPTEFormatActions(editor2, disabled, hotkeyOpts, t3) }, { name: "list", actions: getPTEListActions(editor2, disabled, t3) }, { name: "annotation", actions: getPTEAnnotationActions(editor2, disabled, onInsertAnnotation, t3) }];
}
function getBlockStyles(types3) {
  return types3.styles.map((style) => {
    return { key: "style-".concat(style.value), style: style.value, styleComponent: style && style.component, title: style.title, i18nTitleKey: style.i18nTitleKey };
  });
}
function getInsertMenuIcon(type, fallbackIcon) {
  const referenceIcon = (0, import_get3.default)(type, "to[0].icon");
  return type.icon || type.type && type.type.icon || referenceIcon || fallbackIcon;
}
function getInsertMenuItems(types3, disabled, onInsertBlock, onInsertInline) {
  const blockItems = types3.blockObjects.map((type, index) => ({ handle: () => onInsertBlock(type), icon: getInsertMenuIcon(type, BlockElementIcon), inline: false, key: "block-".concat(index), type }));
  const inlineItems = types3.inlineObjects.map((type, index) => ({ handle: () => onInsertInline(type), icon: getInsertMenuIcon(type, InlineElementIcon), inline: true, key: "inline-".concat(index), type }));
  const filteredBlockItems = blockItems.concat(inlineItems).filter((item) => {
    var _a4;
    return !((_a4 = item.type) == null ? void 0 : _a4.hidden);
  });
  return filteredBlockItems;
}
var annotationIcons = { link: LinkIcon };
var formatIcons = { strong: BoldIcon, em: ItalicIcon, "strike-through": StrikethroughIcon, underline: UnderlineIcon, code: CodeIcon };
var listStyleIcons = { number: OlistIcon, bullet: UlistIcon };
function getActionIcon(action, active) {
  if (action.icon) {
    if (typeof action.icon === "string") {
      return (0, import_jsx_runtime6.jsx)(CustomIcon, { active, icon: action.icon });
    }
    return action.icon;
  }
  if (action.type === "annotation") {
    return annotationIcons[action.key] || UnknownIcon;
  }
  if (action.type === "listStyle") {
    return listStyleIcons[action.key] || UnknownIcon;
  }
  return formatIcons[action.key] || UnknownIcon;
}
function useFocusBlock() {
  const editor2 = usePortableTextEditor();
  const selection = usePortableTextEditorSelection();
  return (0, import_react51.useMemo)(() => PortableTextEditor.focusBlock(editor2), [editor2, selection]);
}
function useActionGroups(_ref233) {
  let { hotkeys, onMemberOpen, resolveInitialValue: resolveInitialValue2, disabled } = _ref233;
  const editor2 = usePortableTextEditor();
  const { t: t3 } = useTranslation2();
  const handleInsertAnnotation = (0, import_react51.useCallback)(async (schemaType) => {
    const initialValue = await resolveInitialValue2(schemaType);
    const paths = PortableTextEditor.addAnnotation(editor2, schemaType, initialValue);
    if (paths && paths.markDefPath) {
      onMemberOpen(paths.markDefPath);
    }
  }, [editor2, onMemberOpen, resolveInitialValue2]);
  return (0, import_react51.useMemo)(() => editor2 ? getPTEToolbarActionGroups(editor2, disabled, handleInsertAnnotation, hotkeys, t3) : [], [disabled, editor2, handleInsertAnnotation, hotkeys, t3]);
}
function useActiveActionKeys(_ref234) {
  let { actions } = _ref234;
  const editor2 = usePortableTextEditor();
  const selection = usePortableTextEditorSelection();
  return useUnique2((0, import_react51.useMemo)(
    () => {
      const activeAnnotationKeys = PortableTextEditor.activeAnnotations(editor2).map((a) => a._type);
      return actions.filter((a) => {
        if (a.type === "annotation") {
          return activeAnnotationKeys.includes(a.key);
        }
        if (a.type === "listStyle") {
          return PortableTextEditor.hasListStyle(editor2, a.key);
        }
        return PortableTextEditor.isMarkActive(editor2, a.key);
      }).map((a) => a.key);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      editor2,
      // This is needed so that active actions update as `selection` changes
      selection
    ]
  ));
}
function useActiveStyleKeys(_ref235) {
  let { items } = _ref235;
  const editor2 = usePortableTextEditor();
  const focusBlock = useFocusBlock();
  const selection = usePortableTextEditorSelection();
  return useUnique2((0, import_react51.useMemo)(
    () => items.filter((i) => PortableTextEditor.hasBlockStyle(editor2, i.style)).map((i) => i.style),
    //  eslint-disable-next-line react-hooks/exhaustive-deps
    [
      focusBlock,
      // This is needed so that active styles update as `selection` changes
      selection
    ]
  ));
}
var CollapseMenuMemo$1 = (0, import_react51.memo)(CollapseMenu);
var MENU_POPOVER_PROPS$6 = { constrainSize: true, portal: true };
var COLLAPSE_BUTTON_PROPS = { padding: 2, mode: "bleed" };
var ActionMenu = (0, import_react51.memo)(function ActionMenu2(props2) {
  const { disabled: disabledProp, groups, isFullscreen, collapsed } = props2;
  const focusBlock = useFocusBlock();
  const editor2 = usePortableTextEditor();
  const isVoidBlock = (focusBlock == null ? void 0 : focusBlock._type) !== editor2.schemaTypes.block.name;
  const isEmptyTextBlock = !isVoidBlock && Array.isArray(focusBlock.children) && focusBlock.children.length === 1 && (focusBlock == null ? void 0 : focusBlock.children[0].text) === "";
  const disabled = disabledProp || isVoidBlock;
  const actions = (0, import_react51.useMemo)(() => groups.reduce((acc, group2) => {
    return acc.concat(group2.actions.map(
      // eslint-disable-next-line max-nested-callbacks
      (action, actionIndex) => {
        if (actionIndex === 0)
          return { ...action, firstInGroup: true };
        return action;
      }
    ));
  }, []), [groups]);
  const activeKeys = useActiveActionKeys({ actions });
  const handleMenuClose = (0, import_react51.useCallback)(() => {
    PortableTextEditor.focus(editor2);
  }, [editor2]);
  const children = (0, import_react51.useMemo)(() => actions.map((action) => {
    const annotationDisabled = action.type === "annotation" && isEmptyTextBlock;
    const active = activeKeys.includes(action.key);
    return (0, import_react51.createElement)(CollapseMenuButton, { "data-testid": "action-button-".concat(action.key), disabled: disabled || annotationDisabled, ...COLLAPSE_BUTTON_PROPS, dividerBefore: action.firstInGroup, icon: getActionIcon(action, active), key: action.key, onClick: () => action.handle(active), selected: active, text: action.title || action.key, tooltipText: action.title || action.key, tooltipProps: { disabled: disabled || annotationDisabled, placement: isFullscreen ? "bottom" : "top", portal: "default" } });
  }), [actions, activeKeys, disabled, isEmptyTextBlock, isFullscreen]);
  const menuButtonProps = (0, import_react51.useMemo)(() => ({ button: (0, import_jsx_runtime6.jsx)(Button, { icon: EllipsisVerticalIcon, mode: "bleed", padding: 2, disabled }), popover: MENU_POPOVER_PROPS$6 }), [disabled]);
  return (0, import_jsx_runtime6.jsx)(CollapseMenuMemo$1, { collapsed, disableRestoreFocusOnClose: true, gap: 1, menuButtonProps, onMenuClose: handleMenuClose, children });
});
var __freeze$1a = Object.freeze;
var __defProp$1a = Object.defineProperty;
var __template$1a = (cooked, raw) => __freeze$1a(__defProp$1a(cooked, "raw", { value: __freeze$1a(raw || cooked.slice()) }));
var _a$1a;
var _b$z;
var MenuButtonMemo = (0, import_react51.memo)(MenuButton);
var StyledMenuItem = st(MenuItem)(_a$1a || (_a$1a = __template$1a(["\n  // Change the border color variable used by BlockQuote\n  // to make the border visible when the MenuItem is selected\n  &[data-selected] {\n    [data-option='blockquote'] {\n      --card-border-color: var(--card-muted-fg-color);\n    }\n  }\n"])));
var StyledButton$1 = st(Button)(_b$z || (_b$z = __template$1a(["\n  width: 100%;\n"])));
var MENU_POPOVER_PROPS$5 = { constrainSize: true, placement: "bottom-start", portal: "default" };
var TEXT_STYLE_OPTIONS = { h1: (title) => (0, import_jsx_runtime6.jsx)(Heading1, { children: title }), h2: (title) => (0, import_jsx_runtime6.jsx)(Heading22, { children: title }), h3: (title) => (0, import_jsx_runtime6.jsx)(Heading3, { children: title }), h4: (title) => (0, import_jsx_runtime6.jsx)(Heading4, { children: title }), h5: (title) => (0, import_jsx_runtime6.jsx)(Heading5, { children: title }), h6: (title) => (0, import_jsx_runtime6.jsx)(Heading6, { children: title }), normal: (title) => (0, import_jsx_runtime6.jsx)(Normal, { children: title }), blockquote: (title) => (0, import_jsx_runtime6.jsx)(BlockQuote, { "data-option": "blockquote", children: title }) };
var TEXT_STYLE_KEYS = Object.keys(TEXT_STYLE_OPTIONS);
var preventDefault = (event) => event.preventDefault();
var emptyStyle = { key: "style-none", style: "", title: "No style", i18nTitleKey: "inputs.portable-text.style.none" };
var BlockStyleSelect = (0, import_react51.memo)(function BlockStyleSelect2(props2) {
  const { disabled, items: itemsProp } = props2;
  const editor2 = usePortableTextEditor();
  const focusBlock = useFocusBlock();
  const { t: t3 } = useTranslation2();
  const _disabled = disabled || (focusBlock ? editor2.schemaTypes.block.name !== focusBlock._type : false);
  const activeKeys = useActiveStyleKeys({ items: itemsProp });
  const { activeItems, items } = (0, import_react51.useMemo)(() => {
    const _activeItems = itemsProp.filter((item) => activeKeys.includes(item.style));
    let _items = itemsProp;
    if (_activeItems.length === 0 && _items.length > 1) {
      _items = _items.concat([emptyStyle]);
      _activeItems.push(emptyStyle);
    }
    return { activeItems: _activeItems, items: _items };
  }, [activeKeys, itemsProp]);
  const menuButtonText = (0, import_react51.useMemo)(() => {
    if (activeItems.length > 1) {
      return t3("inputs.portable-text.style.multiple");
    }
    if (activeItems.length !== 1) {
      return emptyStyle.i18nTitleKey ? t3(emptyStyle.i18nTitleKey) : emptyStyle.title;
    }
    return activeItems[0].i18nTitleKey ? t3(activeItems[0].i18nTitleKey) : activeItems[0].title;
  }, [activeItems, t3]);
  const handleChange = (0, import_react51.useCallback)((item) => {
    if (focusBlock && item.style !== focusBlock.style) {
      PortableTextEditor.toggleBlockStyle(editor2, item.style);
      PortableTextEditor.focus(editor2);
    }
  }, [editor2, focusBlock]);
  const renderOption = (0, import_react51.useCallback)((style, title) => {
    const hasTextStyle = TEXT_STYLE_KEYS.includes(style);
    const renderStyle2 = TEXT_STYLE_OPTIONS[style];
    if (hasTextStyle) {
      return renderStyle2(title);
    }
    return (0, import_jsx_runtime6.jsx)(Text3, { children: title });
  }, []);
  const button = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(StyledButton$1, { disabled: _disabled, iconRight: SelectIcon, mode: "bleed", onClick: preventDefault, padding: 2, text: menuButtonText }), [_disabled, menuButtonText]);
  const menu = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(Menu, { disabled: _disabled, children: items.map((item) => {
    return (0, import_jsx_runtime6.jsx)(StyledMenuItem, { pressed: activeItems.includes(item), onClick: _disabled ? void 0 : () => handleChange(item), children: renderOption(item.style, item.i18nTitleKey ? t3(item.i18nTitleKey) : (item == null ? void 0 : item.title) || item.style) }, item.key);
  }) }), [_disabled, activeItems, handleChange, items, renderOption, t3]);
  return (0, import_jsx_runtime6.jsx)(MenuButtonMemo, { popover: MENU_POPOVER_PROPS$5, id: "block-style-select", button, menu });
});
var CollapseMenuMemo = (0, import_react51.memo)(CollapseMenu);
var MENU_POPOVER_PROPS$4 = { constrainSize: true, portal: true };
var InsertMenu = (0, import_react51.memo)(function InsertMenu22(props2) {
  const { disabled, items, isFullscreen, collapsed } = props2;
  const { t: t3 } = useTranslation2();
  const focusBlock = useFocusBlock();
  const editor2 = usePortableTextEditor();
  const isVoidFocus = focusBlock && focusBlock._type !== editor2.schemaTypes.block.name;
  const handleMenuClose = (0, import_react51.useCallback)(() => {
    PortableTextEditor.focus(editor2);
  }, [editor2]);
  const children = (0, import_react51.useMemo)(() => {
    return items.map((item) => {
      const title = item.type.title || (0, import_upperFirst.default)(item.type.name);
      return (0, import_jsx_runtime6.jsx)(CollapseMenuButton, { "aria-label": t3(item.inline ? "inputs.portable-text.action.insert-inline-object-aria-label" : "inputs.portable-text.action.insert-block-aria-label", { typeName: title }), padding: 2, mode: "bleed", disabled: disabled || isVoidFocus && item.inline === true, icon: item.icon, onClick: item.handle, text: title, tooltipText: t3(item.inline ? "inputs.portable-text.action.insert-inline-object" : "inputs.portable-text.action.insert-block", { typeName: title }), tooltipProps: { disabled, placement: isFullscreen ? "bottom" : "top", portal: "default" } }, item.key);
    });
  }, [disabled, isFullscreen, isVoidFocus, items, t3]);
  const menuButtonProps = (0, import_react51.useMemo)(() => ({ button: (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "bleed", padding: 2, disabled }), popover: MENU_POPOVER_PROPS$4 }), [disabled]);
  return (0, import_jsx_runtime6.jsx)(CollapseMenuMemo, { collapsed, collapseText: false, disableRestoreFocusOnClose: true, gap: 1, menuButtonProps, onMenuClose: handleMenuClose, children });
});
var __freeze$19 = Object.freeze;
var __defProp$19 = Object.defineProperty;
var __template$19 = (cooked, raw) => __freeze$19(__defProp$19(cooked, "raw", { value: __freeze$19(raw || cooked.slice()) }));
var _a$19;
var _b$y;
var _c$l;
var _d$c;
var _e$5;
var _f$4;
var RootFlex$2 = st(Flex)(_a$19 || (_a$19 = __template$19(["\n  width: 100%;\n"])));
var StyleSelectBox = st(Box)(_b$y || (_b$y = __template$19(["\n  width: 8em;\n"])));
var StyleSelectFlex = st(Flex)(_c$l || (_c$l = __template$19(["\n  border-right: 1px solid var(--card-border-color);\n"])));
var ActionMenuBox = st(Box)(_e$5 || (_e$5 = __template$19(["\n  ", "\n"])), (_ref236) => {
  let { $withInsertMenu } = _ref236;
  return $withInsertMenu && nt(_d$c || (_d$c = __template$19(["\n      max-width: max-content;\n      border-right: 1px solid var(--card-border-color);\n    "])));
});
var FullscreenButtonBox = st(Box)(_f$4 || (_f$4 = __template$19(["\n  border-left: 1px solid var(--card-border-color);\n"])));
var SLOW_INITIAL_VALUE_LIMIT = 300;
var IS_MAC$1 = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var InnerToolbar = (0, import_react51.memo)(function InnerToolbar2(_ref237) {
  let { actionGroups, blockStyles, disabled, insertMenuItems, isFullscreen, onToggleFullscreen } = _ref237;
  const { t: t3 } = useTranslation2();
  const actionsLen = actionGroups.reduce((acc, x) => acc + x.actions.length, 0);
  const showActionMenu = actionsLen > 0;
  const showInsertMenu = insertMenuItems.length > 0;
  const [rootElement, setRootElement] = (0, import_react51.useState)(null);
  const rootElementRect = useElementRect(rootElement);
  const collapsed = rootElementRect ? (rootElementRect == null ? void 0 : rootElementRect.width) < 400 : false;
  const showBlockStyleSelect = blockStyles.length > 1;
  useRovingFocus({ rootElement });
  const preventEditorBlurOnToolbarMouseDown = (0, import_react51.useCallback)((e2) => {
    e2.preventDefault();
  }, []);
  return (0, import_jsx_runtime6.jsxs)(RootFlex$2, { align: "center", ref: setRootElement, onMouseDown: preventEditorBlurOnToolbarMouseDown, children: [showBlockStyleSelect && (0, import_jsx_runtime6.jsx)(StyleSelectFlex, { flex: collapsed ? 1 : void 0, children: (0, import_jsx_runtime6.jsx)(StyleSelectBox, { padding: isFullscreen ? 2 : 1, children: (0, import_jsx_runtime6.jsx)(BlockStyleSelect, { disabled, items: blockStyles }) }) }), (0, import_jsx_runtime6.jsxs)(Flex, { flex: 1, children: [showActionMenu && (0, import_jsx_runtime6.jsx)(ActionMenuBox, { flex: collapsed ? void 0 : 1, padding: isFullscreen ? 2 : 1, $withInsertMenu: showInsertMenu, children: (0, import_jsx_runtime6.jsx)(ActionMenu, { disabled, collapsed, groups: actionGroups, isFullscreen }) }), showInsertMenu && (0, import_jsx_runtime6.jsx)(Box, { flex: collapsed ? void 0 : 1, padding: isFullscreen ? 2 : 1, children: (0, import_jsx_runtime6.jsx)(InsertMenu, { disabled, collapsed, items: insertMenuItems, isFullscreen }) })] }), (0, import_jsx_runtime6.jsx)(FullscreenButtonBox, { padding: isFullscreen ? 2 : 1, children: (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", padding: 1, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, paddingX: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3(isFullscreen ? "inputs.portable-text.action.collapse-editor" : "inputs.portable-text.action.expand-editor") }) }), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Hotkeys, { keys: ["".concat(IS_MAC$1 ? "Cmd" : "Ctrl"), "Enter"] }) })] }), placement: isFullscreen ? "bottom" : "top", portal: "default", children: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, icon: isFullscreen ? CollapseIcon : ExpandIcon, mode: "bleed", onClick: onToggleFullscreen }) }) })] });
});
function Toolbar(props2) {
  const { hotkeys, isFullscreen, readOnly, onMemberOpen, onToggleFullscreen } = props2;
  const editor2 = usePortableTextEditor();
  const selection = usePortableTextEditorSelection();
  const resolveInitialValueForType2 = useResolveInitialValueForType();
  const disabled = readOnly || !selection;
  const { push } = useToast();
  const resolveInitialValue2 = (0, import_react51.useCallback)((type) => {
    let isSlow = false;
    const slowTimer = setTimeout(() => {
      isSlow = true;
      push({ id: "resolving-initial-value", status: "info", title: "Resolving initial value" });
    }, SLOW_INITIAL_VALUE_LIMIT);
    return resolveInitialValueForType2(type, {}).then((value) => {
      if (isSlow) {
        push({ id: "resolving-initial-value", status: "info", duration: 500, title: "Initial value resolved" });
      }
      return value;
    }).catch((error2) => {
      push({ title: "Could not resolve initial value", id: "resolving-initial-value", description: "Unable to resolve initial value for type: ".concat(type.name, ": ").concat(error2.message, "."), status: "error" });
      return void 0;
    }).finally(() => clearTimeout(slowTimer));
  }, [push, resolveInitialValueForType2]);
  const handleInsertBlock = (0, import_react51.useCallback)(async (type) => {
    const initialValue = await resolveInitialValue2(type);
    const path2 = PortableTextEditor.insertBlock(editor2, type, initialValue);
    if (path2) {
      onMemberOpen(path2);
    }
  }, [editor2, onMemberOpen, resolveInitialValue2]);
  const handleInsertInline = (0, import_react51.useCallback)(async (type) => {
    const initialValue = await resolveInitialValue2(type);
    const path2 = PortableTextEditor.insertChild(editor2, type, initialValue);
    if (path2) {
      onMemberOpen(path2);
    }
  }, [editor2, onMemberOpen, resolveInitialValue2]);
  const actionGroups = useActionGroups({ hotkeys, onMemberOpen, resolveInitialValue: resolveInitialValue2, disabled: true });
  const blockStyles = (0, import_react51.useMemo)(() => getBlockStyles(editor2.schemaTypes), [editor2]);
  const insertMenuItems = (0, import_react51.useMemo)(() => getInsertMenuItems(editor2.schemaTypes, disabled, handleInsertBlock, handleInsertInline), [disabled, editor2, handleInsertBlock, handleInsertInline]);
  return (0, import_jsx_runtime6.jsx)(InnerToolbar, { actionGroups, blockStyles, disabled, insertMenuItems, isFullscreen, onToggleFullscreen });
}
var __freeze$18 = Object.freeze;
var __defProp$18 = Object.defineProperty;
var __template$18 = (cooked, raw) => __freeze$18(__defProp$18(cooked, "raw", { value: __freeze$18(raw || cooked.slice()) }));
var _a$18;
var _b$x;
var _c$k;
var _d$b;
var _e$4;
var _f$3;
var _g$3;
var _h$1;
var Root$c2 = st(Card)(_a$18 || (_a$18 = __template$18(["\n  height: ", ";\n\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  flex-direction: column;\n"])), (_ref238) => {
  let { $fullscreen } = _ref238;
  return $fullscreen ? "100%" : "15em";
});
var ToolbarCard = st(Card)(_b$x || (_b$x = __template$18(["\n  z-index: 10;\n  line-height: 0;\n"])));
var EditableCard = st(Card)(_c$k || (_c$k = __template$18(["\n  position: relative;\n  overflow: hidden;\n  overflow: clip;\n\n  & > [data-portal] {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    pointer-events: none;\n\n    & > * {\n      pointer-events: initial;\n    }\n  }\n\n  &::selection,\n  *::selection {\n    background-color: transparent;\n  }\n"])));
var Scroller = st(ScrollContainer)(_d$b || (_d$b = __template$18(["\n  position: relative;\n  overflow: auto;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n\n  & > * {\n    flex: 1;\n    min-height: auto;\n  }\n"])));
var EditableContainer = st(Container)(_e$4 || (_e$4 = __template$18(["\n  /* @todo: calculate from theme */\n  /* max-width: 728px; */\n"])));
var EditableWrapper = st(Card)(_h$1 || (_h$1 = __template$18(["\n  height: 100%;\n  width: 100%;\n  counter-reset: ", ";\n  overflow: hidden;\n  overflow: clip;\n\n  & > div {\n    height: 100%;\n  }\n\n  & .pt-editable {\n    display: block;\n    width: 100%;\n    height: 100%;\n\n    ", "\n\n    & > .pt-list-item-bullet + .pt-list-item-number,\n    & > .pt-list-item-number + .pt-list-item-bullet {\n      margin-top: ", "px;\n      counter-reset: ", ";\n    }\n\n    & > :not(.pt-list-item) + .pt-list-item {\n      margin-top: ", "px;\n    }\n\n    /* Reset the list count if the element is not a numbered list item */\n    & > :not(.pt-list-item-number) {\n      counter-reset: ", ";\n    }\n\n    ", "\n\n    & > .pt-list-item + :not(.pt-list-item) {\n      margin-top: ", "px;\n    }\n\n    & > :first-child {\n      padding-top: ", "px;\n    }\n\n    & > :last-child {\n      padding-bottom: ", "px;\n    }\n\n    /* & > .pt-block {\n      & .pt-inline-object {\n      }\n    } */\n\n    & .pt-drop-indicator {\n      pointer-events: none;\n      border: 1px solid var(--card-focus-ring-color) !important;\n      height: 0px !important;\n      border-radius: 1px;\n      margin-top: -3px;\n      left: calc(\n        ", " - 1px\n      );\n      right: calc(\n        ", " - 1px\n      );\n      width: calc(\n        100% -\n          ", " + 2px\n      ) !important;\n    }\n  }\n"])), TEXT_LEVELS.map((l) => createListName(l)).join(" "), TEXT_LEVELS.map((l) => {
  return nt(_f$3 || (_f$3 = __template$18(["\n        & > .pt-list-item-number[class~='pt-list-item-level-", "'] {\n          counter-increment: ", ";\n        }\n      "])), l, createListName(l));
}), (_ref239) => {
  let { theme } = _ref239;
  return theme.sanity.space[3];
}, TEXT_LEVELS.map((l) => createListName(l)).join(" "), (_ref240) => {
  let { theme } = _ref240;
  return theme.sanity.space[2];
}, TEXT_LEVELS.map((l) => createListName(l)).join(" "), TEXT_LEVELS.slice(1).map((l) => {
  return nt(_g$3 || (_g$3 = __template$18(["\n        & > .pt-list-item-level-", " + .pt-list-item-level-", " {\n          counter-reset: ", ";\n        }\n      "])), l, l - 1, createListName(l));
}), (_ref241) => {
  let { theme } = _ref241;
  return theme.sanity.space[3];
}, (_ref242) => {
  let { $isFullscreen, theme } = _ref242;
  return theme.sanity.space[$isFullscreen ? 5 : 3];
}, (_ref243) => {
  let { $isFullscreen, theme } = _ref243;
  return theme.sanity.space[$isFullscreen ? 9 : 5];
}, (_ref244) => {
  let { $isFullscreen, theme } = _ref244;
  return $isFullscreen ? rem(theme.sanity.space[5]) : rem(theme.sanity.space[3]);
}, (_ref245) => {
  let { $isFullscreen, theme } = _ref245;
  return $isFullscreen ? rem(theme.sanity.space[5]) : rem(theme.sanity.space[3]);
}, (_ref246) => {
  let { $isFullscreen, theme } = _ref246;
  return $isFullscreen ? rem(theme.sanity.space[5] * 2) : rem(theme.sanity.space[3] * 2);
});
function useSpellcheck() {
  const editor2 = usePortableTextEditor();
  return (0, import_react51.useMemo)(() => {
    var _a4;
    const spellCheckOption = (_a4 = editor2.schemaTypes.block.options) == null ? void 0 : _a4.spellCheck;
    const isChrome96 = typeof navigator === "undefined" ? false : /Chrome\/96/.test(navigator.userAgent);
    return spellCheckOption === void 0 && isChrome96 === true ? false : spellCheckOption;
  }, [editor2]);
}
function useScrollSelectionIntoView(scrollElement) {
  return (0, import_react51.useMemo)(() => (editor2, domRange) => {
    const selection = PortableTextEditor.getSelection(editor2);
    if (selection) {
      const leafEl = domRange.startContainer.parentElement;
      if (!leafEl) {
        return;
      }
      e(leafEl, { scrollMode: "if-needed", boundary: scrollElement, block: "start", inline: "nearest" });
    }
  }, [scrollElement]);
}
var Style = (props2) => {
  const { block, focused, children, selected, schemaType } = props2;
  const DefaultComponentWithFallback = (0, import_react51.useMemo)(() => (block.style && TEXT_STYLES[block.style] ? TEXT_STYLES[block.style] : TEXT_STYLES[0]) || Normal, [block.style]);
  const DefaultComponent2 = (0, import_react51.useCallback)((defaultComponentProps) => {
    return (0, import_jsx_runtime6.jsx)(DefaultComponentWithFallback, { children: (0, import_jsx_runtime6.jsx)(TextContainer, { "data-testid": "text-style--".concat(block.style), children: defaultComponentProps.children }) });
  }, [DefaultComponentWithFallback, block.style]);
  return (0, import_react51.useMemo)(() => {
    const CustomComponent = schemaType.component;
    const { title, value } = schemaType;
    const componentProps = { block, focused, renderDefault: DefaultComponent2, schemaType, selected, title, value };
    return CustomComponent ? (0, import_jsx_runtime6.jsx)(CustomComponent, { ...componentProps, children }) : (0, import_jsx_runtime6.jsx)(DefaultComponent2, { ...componentProps, children });
  }, [DefaultComponent2, block, children, focused, schemaType, selected]);
};
var DefaultComponent = (dProps) => {
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: dProps.children });
};
var ListItem = (props2) => {
  const { block, children, schemaType, selected, focused, level, value } = props2;
  const { title, component: CustomComponent } = schemaType;
  return (0, import_react51.useMemo)(() => {
    const componentProps = { block, focused, level, renderDefault: DefaultComponent, schemaType, selected, title, value };
    return CustomComponent ? (0, import_jsx_runtime6.jsx)(CustomComponent, { ...componentProps, children }) : (0, import_jsx_runtime6.jsx)(DefaultComponent, { ...componentProps, children });
  }, [CustomComponent, block, children, focused, level, schemaType, selected, title, value]);
};
var noOutlineStyle = { outline: "none" };
var renderDecorator = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Decorator, { ...props2 });
};
var renderStyle = (props2) => {
  return (0, import_jsx_runtime6.jsx)(Style, { ...props2 });
};
var renderListItem = (props2) => {
  return (0, import_jsx_runtime6.jsx)(ListItem, { ...props2 });
};
function Editor2(props2) {
  const { hotkeys, initialSelection, isActive, isFullscreen, onCopy, onItemOpen, onPaste, onToggleFullscreen, path: path2, readOnly, renderAnnotation, renderBlock, renderChild, scrollElement, setPortalElement, setScrollElement, ariaDescribedBy } = props2;
  const { t: t3 } = useTranslation2();
  const { isTopLayer } = useLayer();
  const editableRef = (0, import_react51.useRef)(null);
  const { element: boundaryElement } = useBoundaryElement();
  useGlobalKeyDown((0, import_react51.useCallback)((event) => {
    if (!isTopLayer || !isFullscreen) {
      return;
    }
    if (event.key === "Escape") {
      onToggleFullscreen();
    }
  }, [onToggleFullscreen, isFullscreen, isTopLayer]));
  const renderPlaceholder = (0, import_react51.useCallback)(() => (0, import_jsx_runtime6.jsx)("span", { "data-testid": "pt-input-placeholder", children: t3("inputs.portable-text.empty-placeholder") }), [t3]);
  const spellcheck = useSpellcheck();
  const scrollSelectionIntoView = useScrollSelectionIntoView(scrollElement);
  const editable = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(PortableTextEditable, { "aria-describedby": ariaDescribedBy, hotkeys, onCopy, onPaste, ref: editableRef, renderAnnotation, renderBlock, renderChild, renderDecorator, renderListItem, renderPlaceholder, renderStyle, scrollSelectionIntoView, selection: initialSelection, spellCheck: spellcheck, style: noOutlineStyle }), [ariaDescribedBy, hotkeys, initialSelection, onCopy, onPaste, renderAnnotation, renderBlock, renderChild, renderPlaceholder, scrollSelectionIntoView, spellcheck]);
  const handleToolBarOnMemberOpen = (0, import_react51.useCallback)((relativePath) => {
    onItemOpen(path2.concat(relativePath));
  }, [onItemOpen, path2]);
  return (0, import_jsx_runtime6.jsxs)(Root$c2, { $fullscreen: isFullscreen, "data-testid": "pt-editor", children: [isActive && (0, import_jsx_runtime6.jsx)(ToolbarCard, { "data-testid": "pt-editor__toolbar-card", shadow: 1, children: (0, import_jsx_runtime6.jsx)(Toolbar, { hotkeys, isFullscreen, onMemberOpen: handleToolBarOnMemberOpen, onToggleFullscreen, readOnly }) }), (0, import_jsx_runtime6.jsxs)(EditableCard, { flex: 1, tone: readOnly ? "transparent" : "default", children: [(0, import_jsx_runtime6.jsx)(Scroller, { ref: setScrollElement, children: (0, import_jsx_runtime6.jsx)(EditableContainer, { padding: isFullscreen ? 2 : 0, sizing: "border", width: 1, children: (0, import_jsx_runtime6.jsx)(EditableWrapper, { $isFullscreen: isFullscreen, tone: readOnly ? "transparent" : "default", children: (0, import_jsx_runtime6.jsx)(BoundaryElementProvider, { element: isFullscreen ? scrollElement : boundaryElement, children: editable }) }) }) }), (0, import_jsx_runtime6.jsx)("div", { "data-portal": "", ref: setPortalElement })] })] });
}
var __freeze$17 = Object.freeze;
var __defProp$17 = Object.defineProperty;
var __template$17 = (cooked, raw) => __freeze$17(__defProp$17(cooked, "raw", { value: __freeze$17(raw || cooked.slice()) }));
var _a$17;
var _b$w;
var Root$b2 = st.div((_ref247) => {
  let { theme } = _ref247;
  const { focusRing, input } = theme.sanity;
  const base = theme.sanity.color.base;
  const color3 = theme.sanity.color.input;
  const border2 = { color: color3.default.enabled.border, width: input.border.width };
  return nt(_a$17 || (_a$17 = __template$17(["\n    --input-box-shadow: ", ";\n\n    position: relative;\n\n    & [data-wrapper] {\n      overflow: hidden;\n      overflow: clip;\n      position: relative;\n      z-index: 1;\n      padding: ", "px;\n    }\n\n    & [data-border] {\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      box-shadow: var(--input-box-shadow);\n      z-index: 2;\n      border-radius: 1px;\n      pointer-events: none;\n    }\n\n    &:not([data-read-only])[data-focused] [data-border] {\n      --input-box-shadow: ", ";\n    }\n  "])), focusRingBorderStyle$1(border2), input.border.width, focusRingStyle$1({ base, border: border2, focusRing }));
});
var ExpandedLayer = st(Layer)(_b$w || (_b$w = __template$17(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n"])));
function useHotkeys(hotkeys) {
  const editor2 = usePortableTextEditor();
  const [initialHotkeys] = (0, import_react51.useState)(() => hotkeys);
  if (initialHotkeys !== hotkeys) {
    console.warn("Make sure that hotkeys are a stable object across renders, or there will be issues with key handling in the Portable Text Editor.");
  }
  return (0, import_react51.useMemo)(() => {
    const defaultHotkeys = { marks: {} };
    editor2.schemaTypes.decorators.forEach((dec2) => {
      switch (dec2.value) {
        case "strong":
          defaultHotkeys.marks["mod+b"] = dec2.value;
          break;
        case "em":
          defaultHotkeys.marks["mod+i"] = dec2.value;
          break;
        case "underline":
          defaultHotkeys.marks["mod+u"] = dec2.value;
          break;
        case "code":
          defaultHotkeys.marks["mod+'"] = dec2.value;
          break;
      }
    });
    return { marks: { ...defaultHotkeys.marks, ...(initialHotkeys || {}).marks }, custom: initialHotkeys.custom };
  }, [editor2, initialHotkeys]);
}
function useTrackFocusPath(props2) {
  const { focusPath, boundaryElement, onItemClose } = props2;
  const portableTextMemberItems = usePortableTextMemberItems();
  const editor2 = usePortableTextEditor();
  const selection = usePortableTextEditorSelection();
  (0, import_react51.useLayoutEffect)(() => {
    var _a4, _b4, _c4, _d4, _e3;
    if (focusPath.length === 0) {
      return;
    }
    const openItem = portableTextMemberItems.find((m2) => m2.member.open);
    if (openItem && ((_a4 = openItem.elementRef) == null ? void 0 : _a4.current)) {
      if (boundaryElement) {
        e(boundaryElement, { scrollMode: "if-needed", block: "start", inline: "start" });
        e(openItem.elementRef.current, { scrollMode: "if-needed", boundary: boundaryElement, block: "start", inline: "start" });
      }
      if ((selection == null ? void 0 : selection.focus.path) && isEqual(selection.focus.path, focusPath)) {
        return;
      }
      const isTextBlock = openItem.kind === "textBlock";
      const isBlockFocusPath = focusPath.length === 1;
      if (isTextBlock || isBlockFocusPath) {
        const textBlockChildKey = isTextBlock && isKeyedObject(focusPath[2]) ? focusPath[2]._key : void 0;
        const child = textBlockChildKey && Array.isArray((_b4 = openItem.node.value) == null ? void 0 : _b4.children) ? (_c4 = openItem.node.value) == null ? void 0 : _c4.children.find((c) => c._key === textBlockChildKey) : void 0;
        const isSpanTextFocusPath = child && child._type === "span" && focusPath.length === 4 && focusPath[1] === "children" && focusPath[3] === "text" || false;
        const isTextChildFocusPath = isTextBlock && (focusPath.length === 3 && focusPath[1] === "children" || isSpanTextFocusPath);
        let path2 = [];
        if (isTextChildFocusPath) {
          path2 = focusPath.slice(0, 3);
        } else if (
          // Known text block, but unknown child. Select first child in that block.
          isTextBlock && isBlockFocusPath && Array.isArray((_d4 = openItem.node.value) == null ? void 0 : _d4.children)
        ) {
          path2 = [focusPath[0], "children", { _key: (_e3 = openItem.node.value) == null ? void 0 : _e3.children[0]._key }];
        } else if (isBlockFocusPath) {
          path2 = [{ _key: openItem.key }];
        }
        if (path2.length) {
          PortableTextEditor.select(editor2, { anchor: { path: path2, offset: 0 }, focus: { path: path2, offset: 0 } });
          if (isTextBlock) {
            PortableTextEditor.focus(editor2);
          }
        }
      }
    }
  }, [boundaryElement, editor2, focusPath, onItemClose, portableTextMemberItems, selection == null ? void 0 : selection.focus.path]);
}
function Compositor(props2) {
  const { changed, focused, focusPath = EMPTY_ARRAY$b, hasFocusWithin, hotkeys, isActive, isFullscreen, onActivate, onCopy, onItemClose, onItemOpen, onItemRemove, onPaste, onPathFocus, onToggleFullscreen, path: path2, readOnly, renderAnnotation, renderBlock, renderBlockActions, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, value } = props2;
  const editor2 = usePortableTextEditor();
  const boundaryElement = useBoundaryElement().element;
  const [wrapperElement, setWrapperElement] = (0, import_react51.useState)(null);
  const [scrollElement, setScrollElement] = (0, import_react51.useState)(null);
  const handleToggleFullscreen = (0, import_react51.useCallback)(() => {
    onToggleFullscreen();
  }, [onToggleFullscreen]);
  const hotkeysWithFullscreenToggle = (0, import_react51.useMemo)(() => ({ ...hotkeys, custom: { "mod+enter": onToggleFullscreen, ...(hotkeys == null ? void 0 : hotkeys.custom) || {} } }), [hotkeys, onToggleFullscreen]);
  const editorHotkeys = useHotkeys(hotkeysWithFullscreenToggle);
  const _renderBlockActions = !!value && renderBlockActions ? renderBlockActions : void 0;
  const _renderCustomMarkers = !!value && renderCustomMarkers ? renderCustomMarkers : void 0;
  const [portalElement, setPortalElement] = (0, import_react51.useState)(null);
  const renderTextBlock = (0, import_react51.useCallback)((blockProps) => {
    const { children, focused: blockFocused, path: blockPath, selected, schemaType: blockSchemaType, value: block } = blockProps;
    return (0, import_jsx_runtime6.jsx)(TextBlock, { floatingBoundary: boundaryElement, focused: blockFocused, isFullscreen, onItemClose, onItemOpen, onItemRemove, onPathFocus, path: path2.concat(blockPath), readOnly, referenceBoundary: scrollElement, renderAnnotation, renderField, renderInlineBlock, renderInput, renderItem, renderBlockActions: _renderBlockActions, renderCustomMarkers: _renderCustomMarkers, renderPreview, renderBlock, schemaType: blockSchemaType, selected, value: block, children });
  }, [_renderBlockActions, _renderCustomMarkers, scrollElement, isFullscreen, onItemClose, onItemOpen, onItemRemove, onPathFocus, boundaryElement, path2, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  const renderObjectBlock = (0, import_react51.useCallback)((blockProps) => {
    const { focused: blockFocused, path: blockPath, selected: blockSelected, schemaType: blockSchemaType, value: blockValue } = blockProps;
    return (0, import_jsx_runtime6.jsx)(BlockObject, { floatingBoundary: boundaryElement, focused: blockFocused, isFullscreen, onItemClose, onItemOpen, onItemRemove, onPathFocus, path: path2.concat(blockPath), readOnly, referenceBoundary: scrollElement, relativePath: blockPath, renderAnnotation, renderBlock, renderBlockActions: _renderBlockActions, renderCustomMarkers: _renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType: blockSchemaType, selected: blockSelected, value: blockValue });
  }, [boundaryElement, scrollElement, isFullscreen, onItemClose, onItemOpen, onItemRemove, onPathFocus, path2, readOnly, renderAnnotation, renderBlock, _renderBlockActions, _renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  const editorRenderBlock = (0, import_react51.useCallback)((blockProps) => {
    const { value: block } = blockProps;
    const isTextBlock = block._type === editor2.schemaTypes.block.name;
    if (isTextBlock) {
      return renderTextBlock(blockProps);
    }
    return renderObjectBlock(blockProps);
  }, [editor2.schemaTypes.block.name, renderObjectBlock, renderTextBlock]);
  const editorRenderChild = (0, import_react51.useCallback)((childProps) => {
    const { children, focused: childFocused, path: childPath, selected, schemaType: childSchemaType, value: child } = childProps;
    const isSpan = child._type === editor2.schemaTypes.span.name;
    if (isSpan) {
      return children;
    }
    return (0, import_jsx_runtime6.jsx)(InlineObject, { floatingBoundary: boundaryElement, focused: childFocused, onItemClose, onItemOpen, onPathFocus, path: path2.concat(childPath), readOnly, referenceBoundary: scrollElement, relativePath: childPath, renderAnnotation, renderBlock, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType: childSchemaType, selected, value: child });
  }, [boundaryElement, scrollElement, editor2.schemaTypes.span.name, onItemClose, onItemOpen, onPathFocus, path2, readOnly, renderAnnotation, renderBlock, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  const editorRenderAnnotation = (0, import_react51.useCallback)((annotationProps) => {
    const { children, focused: editorNodeFocused, path: aPath, selected, schemaType: aSchemaType, value: aValue } = annotationProps;
    return (0, import_jsx_runtime6.jsx)(Annotation, { editorNodeFocused, floatingBoundary: boundaryElement, focused: Boolean(focused), onItemClose, onItemOpen, onPathFocus, path: path2.concat(aPath), readOnly, referenceBoundary: scrollElement, renderAnnotation, renderBlock, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType: aSchemaType, selected, value: aValue, children });
  }, [boundaryElement, scrollElement, focused, onItemClose, onItemOpen, onPathFocus, path2, readOnly, renderAnnotation, renderBlock, renderCustomMarkers, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  const ariaDescribedBy = props2.elementProps["aria-describedby"];
  const initialSelection = (0, import_react51.useMemo)(() => {
    if (hasFocusWithin) {
      return { anchor: { path: focusPath, offset: 0 }, focus: { path: focusPath, offset: 0 } };
    }
    return void 0;
  }, []);
  const editorNode = (0, import_react51.useMemo)(
    () => (0, import_jsx_runtime6.jsx)(Editor2, { ariaDescribedBy, initialSelection, hotkeys: editorHotkeys, isActive, isFullscreen, onItemOpen, onCopy, onPaste, onToggleFullscreen: handleToggleFullscreen, path: path2, readOnly, renderAnnotation: editorRenderAnnotation, renderBlock: editorRenderBlock, renderChild: editorRenderChild, setPortalElement, scrollElement, setScrollElement }),
    // Keep only stable ones here!
    [ariaDescribedBy, editorHotkeys, editorRenderAnnotation, editorRenderBlock, editorRenderChild, handleToggleFullscreen, initialSelection, isActive, isFullscreen, onCopy, onItemOpen, onPaste, path2, readOnly, scrollElement]
  );
  const portal = usePortal();
  const portalElements = (0, import_react51.useMemo)(() => ({ collapsed: wrapperElement, default: portal.element, editor: portalElement, expanded: portal.element }), [portal.element, portalElement, wrapperElement]);
  useTrackFocusPath({ focusPath, boundaryElement: scrollElement, onItemClose });
  const editorFocused = focused || hasFocusWithin;
  return (0, import_jsx_runtime6.jsx)(PortalProvider, { __unstable_elements: portalElements, element: portal.element, children: (0, import_jsx_runtime6.jsx)(ActivateOnFocus, { onActivate, isOverlayActive: !isActive, children: (0, import_jsx_runtime6.jsx)(ChangeIndicator, { disabled: isFullscreen, hasFocus: Boolean(focused), isChanged: changed, path: path2, children: (0, import_jsx_runtime6.jsxs)(Root$b2, { "data-focused": editorFocused ? "" : void 0, "data-read-only": readOnly ? "" : void 0, children: [(0, import_jsx_runtime6.jsx)(Box, { "data-wrapper": "", ref: setWrapperElement, children: (0, import_jsx_runtime6.jsx)(Portal, { __unstable_name: isFullscreen ? "expanded" : "collapsed", children: isFullscreen ? (0, import_jsx_runtime6.jsx)(ExpandedLayer, { children: editorNode }) : editorNode }) }), (0, import_jsx_runtime6.jsx)("div", { "data-border": "" })] }) }) }) });
}
function InvalidValue(props2) {
  const { onChange, onIgnore, resolution, readOnly } = props2;
  const { t: t3 } = useTranslation2();
  const handleAction = (0, import_react51.useCallback)(() => {
    if (resolution) {
      onChange({ type: "mutation", patches: resolution.patches });
    }
  }, [onChange, resolution]);
  if (!resolution)
    return null;
  return (0, import_jsx_runtime6.jsx)(Alert, { title: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.portable-text.invalid-value.title") }), suffix: (0, import_jsx_runtime6.jsxs)(Stack, { padding: 2, children: [resolution.action && (0, import_jsx_runtime6.jsxs)(Grid, { columns: [1, 2], gap: 1, children: [(0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", onClick: onIgnore, text: t3("inputs.portable-text.invalid-value.ignore-button.text") }), !readOnly && (0, import_jsx_runtime6.jsx)(Button, { onClick: handleAction, text: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: resolution.i18n.action, values: resolution.i18n.values }), tone: "caution" })] }), (0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: resolution.action && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: t3("inputs.portable-text.invalid-value.action-disclaimer") }) })] }), children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: resolution.i18n.description, values: resolution.i18n.values }) }), (0, import_jsx_runtime6.jsx)(Card, { border: true, overflow: "auto", padding: 2, tone: "inherit", children: (0, import_jsx_runtime6.jsx)(Code, { language: "json", children: JSON.stringify(resolution.item, null, 2) }) })] }) });
}
function usePatches(props2) {
  const { path: path2 } = props2;
  const { patchChannel } = useFormBuilder().__internal;
  const subscribe = (0, import_react51.useCallback)((subscriber) => {
    return patchChannel.subscribe((_ref248) => {
      let { snapshot, patches } = _ref248;
      const filteredPatches = patches.filter((patch2) => _startsWith(patch2.path, path2)).map((patch2) => ({ ...patch2, path: patch2.path.slice(path2.length) }));
      if (filteredPatches.length) {
        subscriber({ shouldReset: _shouldReset(path2, patches), snapshot: isRecord$4(snapshot) ? _getValueAtPath(snapshot, path2) : {}, patches: filteredPatches });
      }
    });
  }, [path2, patchChannel]);
  return { subscribe };
}
function _isSegmentEqual(segment1, segment2) {
  const segment1Type = typeof segment1;
  if (segment1Type !== typeof segment2) {
    return false;
  }
  if (segment1Type === "object") {
    return (0, import_shallow_equals.default)(segment1, segment2);
  }
  return segment1 === segment2;
}
function _startsWith(subjectPath, checkPath) {
  if (subjectPath === checkPath) {
    return true;
  }
  if (!Array.isArray(subjectPath) || !Array.isArray(checkPath)) {
    return false;
  }
  if (subjectPath.length < checkPath.length) {
    return false;
  }
  for (let i = 0, len = checkPath.length; i < len; i++) {
    if (!_isSegmentEqual(checkPath[i], subjectPath[i])) {
      return false;
    }
  }
  return true;
}
function _isAncestor(path1, path2) {
  return path1.length === 0 || _startsWith(path2, path1) && !_startsWith(path1, path2);
}
function _shouldReset(path2, patches) {
  return patches.some((patch2) => _isAncestor(patch2.path, path2) && (patch2.type === "set" || patch2.type === "unset"));
}
function _getValueAtPath(value, path2) {
  return path2.reduce((result, segment) => {
    if (typeof segment === "object") {
      return (0, import_find3.default)(result, segment);
    }
    return (0, import_get3.default)(result, segment);
  }, value);
}
function PortableTextInput(props2) {
  const { elementProps, hotkeys, markers = EMPTY_ARRAY$b, onChange, onCopy, onInsert, onItemRemove, onPaste, onPathFocus, path: path2, readOnly, renderBlockActions, renderCustomMarkers, schemaType, value } = props2;
  const { onBlur } = elementProps;
  (0, import_react51.useImperativeHandle)(elementProps.ref, () => ({ focus() {
    if (editorRef.current) {
      PortableTextEditor.focus(editorRef.current);
    }
  } }));
  const { subscribe } = usePatches({ path: path2 });
  const editorRef = (0, import_react51.useRef)(null);
  const [ignoreValidationError, setIgnoreValidationError] = (0, import_react51.useState)(false);
  const [invalidValue, setInvalidValue] = (0, import_react51.useState)(null);
  const [isFullscreen, setIsFullscreen] = (0, import_react51.useState)(false);
  const [isActive, setIsActive] = (0, import_react51.useState)(false);
  const [isOffline, setIsOffline] = (0, import_react51.useState)(false);
  const [hasFocusWithin, setHasFocusWithin] = (0, import_react51.useState)(false);
  const toast = useToast();
  const patchSubject = (0, import_react51.useMemo)(() => new Subject(), []);
  const patches$ = (0, import_react51.useMemo)(() => patchSubject.asObservable(), [patchSubject]);
  const innerElementRef = (0, import_react51.useRef)(null);
  const handleToggleFullscreen = (0, import_react51.useCallback)(() => {
    if (editorRef.current) {
      setIsFullscreen((v) => !v);
    }
  }, []);
  (0, import_react51.useEffect)(() => {
    if (invalidValue && value !== invalidValue.value) {
      setInvalidValue(null);
    }
  }, [invalidValue, value]);
  (0, import_react51.useEffect)(() => {
    return subscribe((_ref249) => {
      let { patches, snapshot } = _ref249;
      patchSubject.next({ patches, snapshot });
    });
  }, [patchSubject, subscribe]);
  const portableTextMemberItems = usePortableTextMemberItemsFromProps(props2);
  (0, import_react51.useEffect)(() => {
    if (hasFocusWithin) {
      setIsActive(true);
    }
  }, [hasFocusWithin]);
  const handleEditorChange = (0, import_react51.useCallback)((change) => {
    switch (change.type) {
      case "mutation":
        onChange(toFormPatches(change.patches));
        break;
      case "connection":
        if (change.value === "offline") {
          setIsOffline(true);
        } else if (change.value === "online") {
          setIsOffline(false);
        }
        break;
      case "selection":
        (0, import_react51.startTransition)(() => {
          if (change.selection) {
            onPathFocus(change.selection.focus.path);
          }
        });
        break;
      case "focus":
        setIsActive(true);
        setHasFocusWithin(true);
        break;
      case "blur":
        onBlur(change.event);
        setHasFocusWithin(false);
        break;
      case "undo":
      case "redo":
        onChange(toFormPatches(change.patches));
        break;
      case "invalidValue":
        setInvalidValue(change);
        break;
      case "error":
        toast.push({ status: change.level, description: change.description });
        break;
    }
  }, [onBlur, onChange, onPathFocus, toast]);
  (0, import_react51.useEffect)(() => {
    setIgnoreValidationError(false);
  }, [value]);
  const handleIgnoreInvalidValue = (0, import_react51.useCallback)(() => {
    setIgnoreValidationError(true);
  }, []);
  const respondToInvalidContent = (0, import_react51.useMemo)(() => {
    if (invalidValue && invalidValue.resolution) {
      return (0, import_jsx_runtime6.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime6.jsx)(InvalidValue, { onChange: handleEditorChange, onIgnore: handleIgnoreInvalidValue, resolution: invalidValue.resolution, readOnly: isOffline || readOnly }) });
    }
    return null;
  }, [handleEditorChange, handleIgnoreInvalidValue, invalidValue, isOffline, readOnly]);
  const handleActivate = (0, import_react51.useCallback)(() => {
    if (!isActive) {
      setIsActive(true);
      if (editorRef.current) {
        PortableTextEditor.focus(editorRef.current);
      }
    }
  }, [isActive]);
  return (0, import_jsx_runtime6.jsxs)(Box, { ref: innerElementRef, children: [!ignoreValidationError && respondToInvalidContent, (!invalidValue || ignoreValidationError) && (0, import_jsx_runtime6.jsx)(PortableTextMarkersProvider, { markers, children: (0, import_jsx_runtime6.jsx)(PortableTextMemberItemsProvider, { memberItems: portableTextMemberItems, children: (0, import_jsx_runtime6.jsx)(PortableTextEditor, { ref: editorRef, patches$, onChange: handleEditorChange, maxBlocks: void 0, readOnly: isOffline || readOnly, schemaType, value, children: (0, import_jsx_runtime6.jsx)(Compositor, { ...props2, hasFocusWithin, hotkeys, isActive, isFullscreen, onActivate: handleActivate, onItemRemove, onCopy, onInsert, onPaste, onToggleFullscreen: handleToggleFullscreen, renderBlockActions, renderCustomMarkers }) }) }) })] });
}
function toFormPatches(patches) {
  return patches.map((p) => ({ ...p, patchType: SANITY_PATCH_TYPE }));
}
function focusRingBorderStyle2(border2) {
  return "inset 0 0 0 ".concat(border2.width, "px ").concat(border2.color);
}
function focusRingStyle2(opts) {
  const { base, border: border2, focusRing } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border2 && focusRingBorderStyle2(border2), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
var __freeze$16 = Object.freeze;
var __defProp$16 = Object.defineProperty;
var __template$16 = (cooked, raw) => __freeze$16(__defProp$16(cooked, "raw", { value: __freeze$16(raw || cooked.slice()) }));
var _a$16;
var _b$v;
var Root$a2 = st(Card)((props2) => {
  const { theme } = props2;
  const { focusRing, input, radius } = theme.sanity;
  const color3 = theme.sanity.color.input;
  const space = rem(theme.sanity.space[1]);
  return {
    position: "relative",
    borderRadius: "".concat(radius[1], "px"),
    color: color3.default.enabled.fg,
    boxShadow: focusRingBorderStyle2({ color: color3.default.enabled.border, width: input.border.width }),
    "& > .content": { position: "relative", lineHeight: 0, margin: "-".concat(space, " 0 0 -").concat(space) },
    "& > .content > div": { display: "inline-block", verticalAlign: "top", padding: "".concat(space, " 0 0 ").concat(space) },
    // enabled
    "&:not([data-read-only])": { cursor: "text" },
    // hovered
    "@media(hover:hover):not([data-disabled]):not([data-read-only]):hover": { borderColor: color3.default.hovered.border },
    // focused
    "&:not([data-disabled]):not([data-read-only])[data-focused]": { boxShadow: focusRingStyle2({ border: { color: color3.default.enabled.border, width: input.border.width }, focusRing }) },
    // disabled
    "*:disabled + &": { color: color3.default.disabled.fg, backgroundColor: color3.default.disabled.bg, boxShadow: focusRingBorderStyle2({ color: color3.default.disabled.border, width: input.border.width }) }
  };
});
var Input2 = st.input((props2) => {
  const { theme } = props2;
  const font = theme.sanity.fonts.text;
  const color3 = theme.sanity.color.input;
  const p = theme.sanity.space[2];
  const size2 = theme.sanity.fonts.text.sizes[2];
  return {
    appearance: "none",
    background: "none",
    border: 0,
    borderRadius: 0,
    outline: "none",
    fontSize: rem(size2.fontSize),
    lineHeight: size2.lineHeight / size2.fontSize,
    fontFamily: font.family,
    fontWeight: font.weights.regular,
    margin: 0,
    display: "block",
    minWidth: "1px",
    maxWidth: "100%",
    boxSizing: "border-box",
    paddingTop: rem(p - size2.ascenderHeight),
    paddingRight: rem(p),
    paddingBottom: rem(p - size2.descenderHeight),
    paddingLeft: rem(p),
    // enabled
    "&:not(:invalid):not(:disabled)": { color: color3.default.enabled.fg },
    // disabled
    "&:not(:invalid):disabled": { color: color3.default.disabled.fg }
  };
});
var Placeholder = st(Box)((props2) => {
  const { theme } = props2;
  const color3 = theme.sanity.color.input;
  return nt(_a$16 || (_a$16 = __template$16(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    pointer-events: none;\n    --card-fg-color: ", ";\n  "])), color3.default.enabled.placeholder);
});
var TagBox = st(Box)(_b$v || (_b$v = __template$16(['\n  // This is needed to make textOverflow="ellipsis" work properly for the Text primitive\n  max-width: 100%;\n'])));
var TagInput = (0, import_react51.forwardRef)((props2, ref) => {
  const { disabled, onChange, onFocus, placeholder: placeholderProp, readOnly, value = [], ...restProps } = props2;
  const placeholder = (0, import_react51.useMemo)(() => {
    if (placeholderProp)
      return placeholderProp;
    if (typeof window !== "undefined" && "ontouchstart" in window) {
      return "Enter tag";
    }
    return "Enter tag and press ENTER";
  }, [placeholderProp]);
  const [inputValue, setInputValue] = (0, import_react51.useState)("");
  const enabled = !disabled && !readOnly;
  const [focused, setFocused] = (0, import_react51.useState)(false);
  const forwardedRef = useForwardedRef(ref);
  const rootRef = (0, import_react51.useRef)(null);
  const handleRootPointerDown = (0, import_react51.useCallback)((event) => {
    const isTagElement = isHTMLElement(event.target) && event.target.closest('[data-ui="Tag"]');
    if (isTagElement)
      return;
    const inputElement = forwardedRef.current;
    if (inputElement) {
      setTimeout(() => inputElement.focus(), 0);
    }
  }, [forwardedRef]);
  const handleInputBlur = (0, import_react51.useCallback)(() => {
    setFocused(false);
  }, []);
  const handleInputChange = (0, import_react51.useCallback)((event) => {
    setInputValue(event.currentTarget.value);
  }, []);
  const handleInputFocus = (0, import_react51.useCallback)((event) => {
    setFocused(true);
    if (onFocus)
      onFocus(event);
  }, [onFocus]);
  const handleInputKeyDown = (0, import_react51.useCallback)((event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      if (onChange && inputValue) {
        const newValue = value.concat([{ value: inputValue }]);
        setInputValue("");
        if (onChange)
          onChange(newValue);
      }
    }
  }, [inputValue, onChange, value]);
  const handleTagRemove = (0, import_react51.useCallback)((index) => {
    if (!onChange)
      return;
    const newValue = value.slice(0);
    newValue.splice(index, 1);
    onChange(newValue);
  }, [onChange, value]);
  (0, import_react51.useEffect)(() => {
    const inputElement = forwardedRef.current;
    if (inputElement) {
      inputElement.style.width = "0";
      inputElement.style.width = "".concat(inputElement.scrollWidth, "px");
    }
  }, [forwardedRef, inputValue]);
  return (0, import_jsx_runtime6.jsxs)(Root$a2, { "data-disabled": disabled ? "" : void 0, "data-focused": focused ? "" : void 0, "data-read-only": readOnly ? "" : void 0, "data-ui": "TagInput", onPointerDown: handleRootPointerDown, overflow: "auto", padding: 1, ref: rootRef, children: [enabled && (0, import_jsx_runtime6.jsx)(Placeholder, { hidden: Boolean(inputValue || value.length), padding: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", children: placeholder }) }), (0, import_jsx_runtime6.jsxs)("div", { className: "content", children: [value.map((tag, tagIndex) => (
    // eslint-disable-next-line react/no-array-index-key
    (0, import_jsx_runtime6.jsx)(TagBox, { children: (0, import_jsx_runtime6.jsx)(Tag, { enabled, index: tagIndex, muted: !enabled, onRemove: handleTagRemove, tag }) }, "tag-".concat(tagIndex))
  )), (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Input2, { ...restProps, disabled: !enabled, onBlur: handleInputBlur, onChange: handleInputChange, onFocus: handleInputFocus, onKeyDown: handleInputKeyDown, ref: forwardedRef, type: "text", value: inputValue }) }, "tag-input")] })] });
});
TagInput.displayName = "TagInput";
function Tag(props2) {
  const { enabled, index, muted, onRemove, tag } = props2;
  const handleRemoveClick = (0, import_react51.useCallback)(() => {
    onRemove(index);
  }, [index, onRemove]);
  return (0, import_jsx_runtime6.jsx)(Card, { "data-ui": "Tag", padding: 1, radius: 2, tone: "transparent", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, padding: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { muted, textOverflow: "ellipsis", children: tag.value }) }), enabled && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Button, { icon: CloseIcon, mode: "bleed", onClick: handleRemoveClick, padding: 1 }) })] }) });
}
function TagsArrayInput(props2) {
  const { onChange, readOnly, value = [], elementProps, path: path2, changed } = props2;
  const tagInputValue = (0, import_react51.useMemo)(() => value == null ? void 0 : value.map((v) => ({ value: v })), [value]);
  const handleChange = (0, import_react51.useCallback)((nextValue) => {
    onChange(nextValue.length === 0 ? unset2() : set$2(nextValue.map((v) => v.value)));
  }, [onChange]);
  return (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: false, children: (0, import_jsx_runtime6.jsx)(TagInput, { onChange: handleChange, readOnly, value: tagInputValue, ...elementProps }) });
}
var MENU_POPOVER_PROPS$3 = { portal: true, tone: "default" };
function ErrorItem$1(props2) {
  const { member, sortable, onRemove } = props2;
  const id4 = (0, import_react51.useId)();
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime6.jsx)(RowLayout, { dragHandle: sortable, tone: "caution", menu: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(id4, "-menuButton"), menu: (0, import_jsx_runtime6.jsx)(Menu, { children: (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.remove-invalid-item"), tone: "critical", icon: TrashIcon, onClick: onRemove }) }), popover: MENU_POPOVER_PROPS$3 }), children: member.error.type === "INVALID_ITEM_TYPE" ? (0, import_jsx_runtime6.jsx)(IncompatibleItemType$1, { value: member.error.value }) : (0, import_jsx_runtime6.jsx)("div", { children: t3("inputs.array.error.unexpected-error", { error: member.error.type }) }) }) });
}
function DropMessage(props2) {
  const { hoveringFiles, types: types3, resolveUploader: resolveUploader2 } = props2;
  const acceptedFiles = hoveringFiles.filter((file2) => types3.some((type) => resolveUploader2(type, file2)));
  const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
  const multiple = types3.length > 1;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: acceptedFiles.length > 0 ? (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(UploadIcon, {}) }), multiple ? t3("inputs.files.common.drop-message.drop-to-upload-multi", { count: acceptedFiles.length }) : t3("inputs.files.common.drop-message.drop-to-upload"), (0, import_jsx_runtime6.jsx)(Text3, {})] }), rejectedFilesCount > 0 && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 4, children: (0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(AccessDeniedIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: t3("inputs.files.common.drop-message.drop-to-upload.rejected-file-message", { count: rejectedFilesCount }) })] }) })] }) : (0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(AccessDeniedIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { children: t3("inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message", { count: hoveringFiles.length }) })] }) });
}
var __freeze$15 = Object.freeze;
var __defProp$15 = Object.defineProperty;
var __template$15 = (cooked, raw) => __freeze$15(__defProp$15(cooked, "raw", { value: __freeze$15(raw || cooked.slice()) }));
var _a$15;
var Overlay$1 = st(Layer)(_a$15 || (_a$15 = __template$15(["\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  top: -2px;\n  left: -2px;\n  right: -2px;\n  bottom: -2px;\n  background-color: var(--card-bg-color);\n  opacity: 0.8;\n"])));
var __freeze$14 = Object.freeze;
var __defProp$14 = Object.defineProperty;
var __template$14 = (cooked, raw) => __freeze$14(__defProp$14(cooked, "raw", { value: __freeze$14(raw || cooked.slice()) }));
var _a$14;
var Root$92 = st.div(_a$14 || (_a$14 = __template$14(["\n  position: relative;\n"])));
function getUploadCandidates(types3, resolveUploader2, file2) {
  return types3.map((memberType) => ({ type: memberType, uploader: resolveUploader2(memberType, file2) })).filter((member) => member.uploader);
}
function uploadTarget(Component3) {
  const FileTarget2 = fileTarget(Component3);
  return import_react51.default.forwardRef(function UploadTarget(props2, forwardedRef) {
    const { children, resolveUploader: resolveUploader2, onUpload, types: types3, ...rest } = props2;
    const { push: pushToast } = useToast();
    const { t: t3 } = useTranslation2();
    const uploadFile2 = import_react51.default.useCallback((file2, resolvedUploader) => {
      const { type, uploader } = resolvedUploader;
      onUpload == null ? void 0 : onUpload({ file: file2, schemaType: type, uploader });
    }, [onUpload]);
    const handleFiles = import_react51.default.useCallback((files) => {
      if (!resolveUploader2) {
        return;
      }
      const tasks = files.map((file2) => ({ file: file2, uploaderCandidates: getUploadCandidates(types3, resolveUploader2, file2) }));
      const ready = tasks.filter((task) => task.uploaderCandidates.length > 0);
      const rejected = tasks.filter((task) => task.uploaderCandidates.length === 0);
      if (rejected.length > 0) {
        pushToast({ closable: true, status: "warning", title: t3("inputs.array.error.cannot-upload-unable-to-convert", { count: rejected.length }), description: rejected.map((task, i) => (0, import_jsx_runtime6.jsxs)(Flex, { padding: 2, children: [(0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: task.file.name }) }), (0, import_jsx_runtime6.jsx)(Box, { paddingLeft: 2, children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, children: ["(", task.file.type, ")"] }) })] }, i)) });
      }
      ready.forEach((task) => {
        uploadFile2(
          task.file,
          // eslint-disable-next-line max-nested-callbacks
          (0, import_sortBy.default)(task.uploaderCandidates, (candidate) => candidate.uploader.priority)[0]
        );
      });
    }, [pushToast, resolveUploader2, types3, uploadFile2, t3]);
    const [hoveringFiles, setHoveringFiles] = import_react51.default.useState([]);
    const handleFilesOut = import_react51.default.useCallback(() => setHoveringFiles([]), []);
    return (0, import_jsx_runtime6.jsx)(Root$92, { children: (0, import_jsx_runtime6.jsxs)(FileTarget2, { ...rest, ref: forwardedRef, onFiles: handleFiles, onFilesOver: setHoveringFiles, onFilesOut: handleFilesOut, children: [resolveUploader2 && hoveringFiles.length > 0 && (0, import_jsx_runtime6.jsx)(Overlay$1, { zOffset: 10, children: (0, import_jsx_runtime6.jsx)(DropMessage, { hoveringFiles, types: types3, resolveUploader: resolveUploader2 }) }), children] }) });
  });
}
var UploadTargetCard = withFocusRing(uploadTarget(Card));
function nearestIndexOf(array3, startIdx, searchElement) {
  return nearestIndex(array3, startIdx, (element) => element === searchElement);
}
function nearestIndex(array3, startIdx, predicate) {
  let lowerIdx = startIdx - 1;
  let upperIdx = startIdx;
  const len = array3.length;
  while (lowerIdx > -1 || upperIdx < len) {
    const upper = array3[upperIdx];
    if (upperIdx < len && predicate(upper, upperIdx)) {
      return upperIdx;
    }
    const lower = array3[lowerIdx];
    if (lowerIdx > -1 && predicate(lower, lowerIdx)) {
      return lowerIdx;
    }
    lowerIdx--;
    upperIdx++;
  }
  return -1;
}
var MENU_BUTTON_POPOVER_PROPS = { portal: true, tone: "default" };
var ItemRow = import_react51.default.forwardRef(function ItemRow2(props2, ref) {
  const { sortable, value, insertableTypes, onInsert, onRemove, readOnly, inputId, validation: validation2, children, presence, schemaType } = props2;
  const hasError = validation2.filter((item) => item.level === "error").length > 0;
  const hasWarning = validation2.filter((item) => item.level === "warning").length > 0;
  const handleInsert = (0, import_react51.useCallback)((pos, insertType) => {
    onInsert({ position: pos, items: [getEmptyValue(insertType)] });
  }, [onInsert]);
  const handleDuplicate = (0, import_react51.useCallback)(() => {
    if (value)
      onInsert({ position: "after", items: [value] });
  }, [onInsert, value]);
  const tone = (0, import_react51.useMemo)(() => {
    if (hasError) {
      return "critical";
    }
    if (hasWarning) {
      return "caution";
    }
    return void 0;
  }, [hasError, hasWarning]);
  const { t: t3 } = useTranslation2();
  const menu = (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(inputId, "-menuButton"), popover: MENU_BUTTON_POPOVER_PROPS, menu: (0, import_jsx_runtime6.jsxs)(Menu, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.remove"), tone: "critical", icon: TrashIcon, onClick: onRemove }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.duplicate"), icon: CopyIcon, onClick: handleDuplicate }), (0, import_jsx_runtime6.jsx)(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })] }) });
  return (0, import_jsx_runtime6.jsx)(RowLayout, { tone, menu: !readOnly && menu, dragHandle: !readOnly && sortable, presence: presence.length === 0 ? null : (0, import_jsx_runtime6.jsx)(FieldPresence, { presence, maxAvatars: 1 }), validation: validation2.length > 0 ? (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, paddingX: 1, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(FormFieldValidationStatus, { validation: validation2 }) }) : null, children: (0, import_jsx_runtime6.jsx)(Flex, { align: schemaType ? "flex-end" : "center", ref, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "flex-end", flex: 1, children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, marginRight: 2, children }) }) }) });
});
function ArrayOfPrimitivesFunctions(props2) {
  const { schemaType, readOnly, children, onValueCreate, onItemAppend } = props2;
  const menuButtonId = (0, import_react51.useId)();
  const { t: t3 } = useTranslation2();
  const insertItem = import_react51.default.useCallback((itemType) => {
    onItemAppend(onValueCreate(itemType));
  }, [onValueCreate, onItemAppend]);
  const handleAddBtnClick = import_react51.default.useCallback(() => {
    insertItem(schemaType.of[0]);
  }, [schemaType, insertItem]);
  const popoverProps = (0, import_react51.useMemo)(() => ({ constrainSize: true, portal: true }), []);
  const addItemI18nKey = schemaType.of.length > 1 ? "inputs.array.action.add-item-select-type" : "inputs.array.action.add-item";
  if (readOnly) {
    return (0, import_jsx_runtime6.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("inputs.array.read-only-label") }) }), children: (0, import_jsx_runtime6.jsx)(Grid, { children: (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "ghost", disabled: true, text: t3(addItemI18nKey) }) }) });
  }
  return (0, import_jsx_runtime6.jsxs)(Grid, { gap: 1, style: { gridTemplateColumns: "repeat(auto-fit, minmax(100px, 1fr))" }, children: [schemaType.of.length === 1 ? (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "ghost", onClick: handleAddBtnClick, text: t3(addItemI18nKey) }) : (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { icon: AddIcon, mode: "ghost", text: t3(addItemI18nKey) }), id: menuButtonId || "", menu: (0, import_jsx_runtime6.jsx)(Menu, { children: schemaType.of.map((memberDef, i) => {
    var _a4, _b4;
    const referenceIcon = isReferenceSchemaType(memberDef) && (memberDef.to || []).length === 1 && memberDef.to[0].icon;
    const icon = memberDef.icon || ((_a4 = memberDef.type) == null ? void 0 : _a4.icon) || referenceIcon;
    return (0, import_jsx_runtime6.jsx)(MenuItem, { text: memberDef.title || ((_b4 = memberDef.type) == null ? void 0 : _b4.name), onClick: () => insertItem(memberDef), icon }, i);
  }) }), popover: popoverProps }), children] });
}
var CARD_STYLE = { borderStyle: "dashed" };
function NoItemsPlaceholder(_ref250) {
  let { schemaType } = _ref250;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Card, { padding: 3, border: true, style: CARD_STYLE, radius: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: schemaType.placeholder || t3("inputs.array.no-items-label") }) });
}
var ArrayOfPrimitivesInput = class extends import_react51.default.PureComponent {
  constructor(props2) {
    super(props2);
    this._element = null;
    this.handleAppend = (itemValue) => {
      const { value = [], onIndexFocus, onItemAppend } = this.props;
      onItemAppend(itemValue);
      onIndexFocus(value.length);
    };
    this.handlePrepend = (itemValue) => {
      const { onIndexFocus, value = [], onItemPrepend } = this.props;
      onItemPrepend(itemValue);
      onIndexFocus(value.length);
    };
    this.handleSortEnd = (event) => {
      const { onIndexFocus, onMoveItem, value } = this.props;
      if (value)
        onMoveItem(event);
      onIndexFocus(event.toIndex);
    };
    this.handleItemMoveStart = () => {
      this.setState({ disableTransition: false });
    };
    this.handleItemMoveEnd = () => {
      this.setState({ disableTransition: true });
    };
    this.renderArrayItem = (props3) => {
      var _a4;
      const { schemaType } = this.props;
      const sortable = ((_a4 = schemaType.options) == null ? void 0 : _a4.sortable) !== false;
      return (0, import_jsx_runtime6.jsx)(ItemRow, { ...props3, sortable, insertableTypes: schemaType.of });
    };
    this.state = { disableTransition: false };
  }
  focus() {
    if (this._element) {
      this._element.focus();
    }
  }
  getSnapshotBeforeUpdate(prevProps) {
    var _a4;
    const { focusPath: prevFocusPath = [], value: prevValue = [] } = prevProps;
    const { focusPath = [], value = [] } = this.props;
    if (prevFocusPath[0] === focusPath[0] && prevValue.length !== value.length) {
      const focusIndex = focusPath[0];
      const selection = window.getSelection();
      if (!((selection == null ? void 0 : selection.focusNode) instanceof HTMLElement)) {
        return null;
      }
      const input = (_a4 = selection.focusNode) == null ? void 0 : _a4.querySelector("input,textarea");
      return input instanceof HTMLInputElement ? { prevFocusedIndex: focusIndex, restoreSelection: { text: selection.toString(), start: input.selectionStart, end: input.selectionEnd, value: input.value } } : {};
    }
    return null;
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    var _a4;
    const { onIndexFocus } = this.props;
    if ((snapshot == null ? void 0 : snapshot.restoreSelection) && prevProps.value) {
      const prevFocusedValue = prevProps.value[snapshot.prevFocusedIndex];
      const nearestIndex2 = nearestIndexOf(this.props.value || [], snapshot.prevFocusedIndex, prevFocusedValue);
      if (nearestIndex2 === -1) {
        return;
      }
      const newInput = (_a4 = this._element) == null ? void 0 : _a4.querySelector("[data-item-index='".concat(nearestIndex2, "'] input,textarea"));
      if (newInput instanceof HTMLInputElement) {
        newInput.focus();
        try {
          newInput.setSelectionRange(snapshot.restoreSelection.start, snapshot.restoreSelection.end);
        } catch {
        }
      }
      onIndexFocus(nearestIndex2);
    }
  }
  render() {
    const { schemaType, members, readOnly, renderInput, onUpload, onItemRemove, resolveUploader: resolveUploader2, elementProps, arrayFunctions: ArrayFunctions = ArrayOfPrimitivesFunctions, changed } = this.props;
    const isSortable = !readOnly && (0, import_get3.default)(schemaType, "options.sortable") !== false;
    const membersWithSortIds = members.map((member) => ({ id: "".concat(member.key, "-").concat(member.kind === "item" ? member.item.value : "error"), member }));
    return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, "data-testid": "array-primitives-input", children: [(0, import_jsx_runtime6.jsx)(UploadTargetCard, { types: schemaType.of, resolveUploader: resolveUploader2, onUpload, ...elementProps, tabIndex: 0, children: (0, import_jsx_runtime6.jsx)(Stack, { space: 1, children: membersWithSortIds.length === 0 ? (0, import_jsx_runtime6.jsx)(NoItemsPlaceholder, { schemaType }) : (0, import_jsx_runtime6.jsx)(Card, { padding: 1, border: true, children: (0, import_jsx_runtime6.jsx)(List, { onItemMove: this.handleSortEnd, onItemMoveStart: this.handleItemMoveStart, onItemMoveEnd: this.handleItemMoveEnd, items: membersWithSortIds.map((m2) => m2.id), sortable: isSortable, gap: 1, children: membersWithSortIds.map((_ref251, index) => {
      let { member, id: id4 } = _ref251;
      return (0, import_jsx_runtime6.jsxs)(Item2, { id: id4, sortable: isSortable, disableTransition: this.state.disableTransition, children: [member.kind === "item" && (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: member.item.path, isChanged: changed, hasFocus: false, children: (0, import_jsx_runtime6.jsx)(ArrayOfPrimitivesItem, { member, renderItem: this.renderArrayItem, renderInput }) }), member.kind === "error" && (0, import_jsx_runtime6.jsx)(ErrorItem$1, { sortable: isSortable, member, onRemove: () => onItemRemove(index) })] }, member.key);
    }) }) }) }) }), (0, import_jsx_runtime6.jsx)(ArrayFunctions, { onChange: this.props.onChange, onItemAppend: this.handleAppend, onItemPrepend: this.handlePrepend, onValueCreate: getEmptyValue, readOnly: this.props.readOnly, schemaType: this.props.schemaType, value: this.props.value })] });
  }
};
var __freeze$13 = Object.freeze;
var __defProp$132 = Object.defineProperty;
var __template$13 = (cooked, raw) => __freeze$13(__defProp$132(cooked, "raw", { value: __freeze$13(raw || cooked.slice()) }));
var _a$13;
var _b$u;
var _c$j;
var _d$a;
var FooterFlex = st(Flex)(_a$13 || (_a$13 = __template$13(["\n  min-height: 35px;\n"])));
var PresenceFlex = st(Flex)(_b$u || (_b$u = __template$13(["\n  position: absolute;\n  top: 0;\n  right: 0;\n  height: 35px;\n"])));
var DragHandleCard = st(Card)(_c$j || (_c$j = __template$13(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
var Root$82 = st(Card)(_d$a || (_d$a = __template$13(["\n  transition: border-color 250ms;\n  box-sizing: border-box;\n  position: relative;\n\n  @media (hover: hover) {\n    ", " {\n      opacity: 0;\n    }\n\n    &:hover,\n    &:focus-within {\n      ", " {\n        opacity: 1;\n      }\n    }\n  }\n\n  .", " & {\n    box-shadow:\n      0 0 0 0,\n      0 8px 17px 2px var(--card-shadow-umbra-color),\n      0 3px 14px 2px var(--card-shadow-penumbra-color),\n      0 5px 5px -3px var(--card-shadow-ambient-color);\n  }\n\n  &[aria-selected='true'] {\n    box-shadow: 0 0 0 2px var(--card-focus-ring-color);\n  }\n"])), DragHandleCard, DragHandleCard, MOVING_ITEM_CLASS_NAME);
function CellLayout(props2) {
  const { validation: validation2, selected, tone, presence, children, dragHandle, menu, footer, ...rest } = props2;
  return (0, import_jsx_runtime6.jsxs)(Root$82, { forwardedAs: Flex, direction: "column", border: true, selected, "aria-selected": selected, radius: 2, tone, ...rest, children: [children, dragHandle && (0, import_jsx_runtime6.jsx)(DragHandleCard, { margin: 1, radius: 2, display: "flex", tone: "inherit", "data-ui": "DragHandleCard", children: (0, import_jsx_runtime6.jsx)(DragHandle, { grid: true, padding: 2, mode: "ghost" }) }), presence && (0, import_jsx_runtime6.jsx)(PresenceFlex, { align: "center", marginX: 1, children: presence }), (0, import_jsx_runtime6.jsxs)(FooterFlex, { align: "center", paddingX: 1, sizing: "border", justify: "space-between", children: [(0, import_jsx_runtime6.jsx)(Flex, { children: validation2 }), (0, import_jsx_runtime6.jsx)(Box, { children: footer }), menu] })] });
}
var __freeze$12 = Object.freeze;
var __defProp$122 = Object.defineProperty;
var __template$12 = (cooked, raw) => __freeze$12(__defProp$122(cooked, "raw", { value: __freeze$12(raw || cooked.slice()) }));
var _a$12;
var PreviewCard = st(Card)(_a$12 || (_a$12 = __template$12(["\n  border-top-right-radius: inherit;\n  border-top-left-radius: inherit;\n  height: 100%;\n  position: relative;\n\n  @media (hover: hover) {\n    &:hover {\n      filter: brightness(95%);\n    }\n  }\n\n  &:focus:focus-visible {\n    box-shadow: 0 0 0 2px var(--card-focus-ring-color);\n  }\n"])));
function getTone(_ref252) {
  let { readOnly, hasErrors, hasWarnings } = _ref252;
  if (readOnly) {
    return "transparent";
  }
  if (hasErrors) {
    return "critical";
  }
  return hasWarnings ? "caution" : "default";
}
var MENU_POPOVER_PROPS$2 = { portal: true, tone: "default" };
var INITIAL_VALUE_CARD_STYLE = { position: "absolute", top: 0, left: 0, bottom: 0, right: 0 };
function GridItem(props2) {
  var _a22, _b4, _c4, _d4, _e3, _f3;
  const { schemaType, parentSchemaType, path: path2, readOnly, onRemove, value, open, onInsert, onFocus, onOpen, onClose, changed, focused, children, inputProps: { renderPreview } } = props2;
  const { t: t3 } = useTranslation2();
  const sortable = !readOnly && ((_a22 = parentSchemaType.options) == null ? void 0 : _a22.sortable) !== false;
  const insertableTypes = parentSchemaType.of;
  const previewCardRef = (0, import_react51.useRef)(null);
  useScrollIntoViewOnFocusWithin(previewCardRef, open);
  useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a32;
    if (!hadFocus && hasFocus && previewCardRef.current) {
      (_a32 = previewCardRef.current) == null ? void 0 : _a32.focus();
    }
  });
  const resolvingInitialValue = value._resolvingInitialValue;
  const handleDuplicate = (0, import_react51.useCallback)(() => {
    onInsert({ items: [{ ...value, _key: randomKey3() }], position: "after" });
  }, [onInsert, value]);
  const handleInsert = (0, import_react51.useCallback)((pos, insertType) => {
    onInsert({ items: [createProtoArrayValue(insertType)], position: pos });
  }, [onInsert]);
  const childPresence = useChildPresence(path2, true);
  const presence = (0, import_react51.useMemo)(() => {
    return childPresence.length === 0 ? null : (0, import_jsx_runtime6.jsx)(FieldPresence, { presence: childPresence, maxAvatars: 1 });
  }, [childPresence]);
  const childValidation = useChildValidation(path2, true);
  const validation2 = (0, import_react51.useMemo)(() => {
    return childValidation.length === 0 ? null : (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, paddingX: 1, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(FormFieldValidationStatus, { validation: childValidation, __unstable_showSummary: true }) });
  }, [childValidation]);
  const hasErrors = childValidation.some((v) => v.level === "error");
  const hasWarnings = childValidation.some((v) => v.level === "warning");
  const menu = (0, import_react51.useMemo)(() => readOnly ? null : (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(props2.inputId, "-menuButton"), menu: (0, import_jsx_runtime6.jsxs)(Menu, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.remove"), tone: "critical", icon: TrashIcon, onClick: onRemove }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.duplicate"), icon: CopyIcon, onClick: handleDuplicate }), (0, import_jsx_runtime6.jsx)(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })] }), popover: MENU_POPOVER_PROPS$2 }), [handleDuplicate, handleInsert, onRemove, insertableTypes, props2.inputId, readOnly, t3]);
  const tone = getTone({ readOnly, hasErrors, hasWarnings });
  const item = (0, import_jsx_runtime6.jsx)(CellLayout, { menu, presence, validation: validation2, tone, radius: 2, border: true, focused, dragHandle: sortable, selected: open, children: (0, import_jsx_runtime6.jsxs)(PreviewCard, { tone: "inherit", overflow: "auto", forwardedAs: "button", "data-ui": "PreviewCard", "data-as": "button", type: "button", flex: 1, tabIndex: 0, disabled: resolvingInitialValue, onClick: onOpen, ref: previewCardRef, onFocus, __unstable_focusRing: true, children: [renderPreview({ schemaType, value, layout: "media", withBorder: false, withShadow: false }), resolvingInitialValue && (0, import_jsx_runtime6.jsx)(Card, { as: Flex, style: INITIAL_VALUE_CARD_STYLE, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "center", gap: 1, padding: 1, children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime6.jsx)(Spinner, { muted: true }) }), (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: t3("inputs.array.resolving-initial-value") })] }) })] }) });
  const itemTypeTitle = getSchemaTypeTitle(schemaType);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: Boolean(focused), children: item }), open && (0, import_jsx_runtime6.jsx)(EditPortal, { header: readOnly ? t3("inputs.array.action.view", { itemTypeTitle }) : t3("inputs.array.action.edit", { itemTypeTitle }), type: ((_c4 = (_b4 = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _b4.modal) == null ? void 0 : _c4.type) || "dialog", width: (_f3 = (_e3 = (_d4 = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _d4.modal) == null ? void 0 : _e3.width) != null ? _f3 : 1, id: value._key, onClose, autofocus: focused, legacy_referenceElement: previewCardRef.current, children })] });
}
var __freeze$11 = Object.freeze;
var __defProp$11 = Object.defineProperty;
var __template$11 = (cooked, raw) => __freeze$11(__defProp$11(cooked, "raw", { value: __freeze$11(raw || cooked.slice()) }));
var _a$11;
var PopoverCard3 = st(Card)(_a$11 || (_a$11 = __template$11(["\n  max-width: ", "px;\n"])), (_ref253) => {
  let { theme } = _ref253;
  return theme.sanity.container[1];
});
function IncompatibleItemType(props2) {
  const { value, onFocus, vertical, ...rest } = props2;
  const [showDetails, setShowDetails] = import_react51.default.useState(false);
  const [popoverRef, setPopoverRef] = import_react51.default.useState(null);
  const { t: t3 } = useTranslation2();
  useClickOutside(() => setShowDetails(false), [popoverRef]);
  const handleKeyDown = import_react51.default.useCallback((e2) => {
    if (e2.key === "Escape" || e2.key === "Tab") {
      setShowDetails(false);
    }
  }, []);
  const handleShowDetails = (0, import_react51.useCallback)(() => {
    setShowDetails((v) => !v);
  }, []);
  const typeName = resolveTypeName(value);
  return (0, import_jsx_runtime6.jsx)(Popover, { open: showDetails, ref: setPopoverRef, onKeyDown: handleKeyDown, portal: true, constrainSize: true, tone: "default", content: (0, import_jsx_runtime6.jsx)(PopoverCard3, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: t3("inputs.array.error.type-is-incompatible-title") }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.current-schema-not-declare-description", values: { typeName } }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsxs)(Text3, { size: 1, children: [(0, import_jsx_runtime6.jsx)(BulbOutlineIcon, {}), " ", t3("inputs.array.error.can-delete-but-no-edit-description")] }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: t3("inputs.array.error.json-representation-description") }), (0, import_jsx_runtime6.jsx)(Card, { padding: 2, overflow: "auto", border: true, children: (0, import_jsx_runtime6.jsx)(Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })] })] }) }), children: (0, import_jsx_runtime6.jsx)(Card, { as: "button", type: "button", radius: 2, tone: "inherit", paddingX: 2, paddingY: 3, style: { height: "100%" }, onFocus, onClick: handleShowDetails, onKeyDown: handleKeyDown, __unstable_focusRing: true, ...rest, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, marginTop: 2, children: [(0, import_jsx_runtime6.jsx)(Box, { margin: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", size: 4, children: (0, import_jsx_runtime6.jsx)(UnknownIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Text3, { align: "center", size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.array.error.type-is-incompatible-prompt", values: { typeName } }) })] }) }) });
}
var MENU_POPOVER_PROPS$1 = { portal: true, tone: "default" };
function ErrorItem(props2) {
  const { member, sortable } = props2;
  const id4 = (0, import_react51.useId)();
  const { onChange } = useFormCallbacks();
  const { t: t3 } = useTranslation2();
  const handleRemove = (0, import_react51.useCallback)(() => {
    onChange(PatchEvent.from([unset2([{ _key: member.key }])]));
  }, [onChange, member.key]);
  return (0, import_jsx_runtime6.jsx)(CellLayout, { dragHandle: sortable, tone: "caution", style: { height: "100%" }, menu: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: "".concat(id4, "-menuButton"), menu: (0, import_jsx_runtime6.jsx)(Menu, { children: (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("inputs.array.action.remove-invalid-item"), tone: "critical", icon: TrashIcon, onClick: handleRemove }) }), popover: MENU_POPOVER_PROPS$1 }), children: member.error.type === "INVALID_ITEM_TYPE" ? (0, import_jsx_runtime6.jsx)(IncompatibleItemType, { value: member.error.value, vertical: true }) : (0, import_jsx_runtime6.jsx)("div", { children: t3("inputs.array.error.unexpected-error", { error: member.error.type }) }) });
}
var EMPTY$2 = [];
function GridArrayInput(props2) {
  var _a4;
  const { arrayFunctions: ArrayFunctions = ArrayOfObjectsFunctions, elementProps, members, onChange, onInsert, onItemMove, onUpload, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderPreview, resolveUploader: resolveUploader2, schemaType, value = EMPTY$2 } = props2;
  const { t: t3 } = useTranslation2();
  const handlePrepend = (0, import_react51.useCallback)((item) => {
    onInsert({ items: [item], position: "before", referenceItem: 0 });
  }, [onInsert]);
  const handleAppend = (0, import_react51.useCallback)((item) => {
    onInsert({ items: [item], position: "after", referenceItem: -1 });
  }, [onInsert]);
  const sortable = ((_a4 = schemaType.options) == null ? void 0 : _a4.sortable) !== false;
  const renderItem = (0, import_react51.useCallback)((itemProps) => {
    return (0, import_jsx_runtime6.jsx)(GridItem, { ...itemProps });
  }, []);
  const memberKeys = (0, import_react51.useMemo)(() => members.map((member) => member.key), [members]);
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(UploadTargetCard, { types: schemaType.of, resolveUploader: resolveUploader2, onUpload, ...elementProps, tabIndex: 0, children: (0, import_jsx_runtime6.jsxs)(Stack, { "data-ui": "ArrayInput__content", space: 3, children: [(members == null ? void 0 : members.length) === 0 && (0, import_jsx_runtime6.jsx)(Card, { padding: 3, border: true, style: { borderStyle: "dashed" }, radius: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: schemaType.placeholder || (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.array.no-items-label") }) }) }), (members == null ? void 0 : members.length) > 0 && (0, import_jsx_runtime6.jsx)(Card, { border: true, radius: 1, children: (0, import_jsx_runtime6.jsx)(List, { columns: [2, 3, 4], gap: 3, padding: 1, margin: 1, items: memberKeys, onItemMove, sortable, children: members.map((member) => (0, import_jsx_runtime6.jsxs)(Item2, { sortable, id: member.key, flex: 1, children: [member.kind === "item" && (0, import_jsx_runtime6.jsx)(ArrayOfObjectsItem, { member, renderAnnotation, renderBlock, renderInlineBlock, renderItem, renderField, renderInput, renderPreview }), member.kind === "error" && (0, import_jsx_runtime6.jsx)(ErrorItem, { sortable, member })] }, member.key)) }) })] }) }), (0, import_jsx_runtime6.jsx)(ArrayFunctions, { onChange, onItemAppend: handleAppend, onItemPrepend: handlePrepend, onValueCreate: createProtoArrayValue, readOnly, schemaType, value })] });
}
function useMemoCompare(next, compare) {
  const previousRef = (0, import_react51.useRef)(next);
  const previous = previousRef.current;
  const isEqual7 = compare(previous, next);
  (0, import_react51.useEffect)(() => {
    if (!isEqual7) {
      previousRef.current = next;
    }
  });
  return isEqual7 ? previous : next;
}
var EMPTY$1 = [];
function ListArrayInput(props2) {
  var _a4;
  const { arrayFunctions: ArrayFunctions = ArrayOfObjectsFunctions, elementProps, members, onChange, onInsert, onItemMove, onUpload, focusPath, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, resolveUploader: resolveUploader2, schemaType, value = EMPTY$1 } = props2;
  const { t: t3 } = useTranslation2();
  const [activeDragItemIndex, setActiveDragItemIndex] = (0, import_react51.useState)(null);
  const { space } = useTheme().sanity;
  const handlePrepend = (0, import_react51.useCallback)((item) => {
    onInsert({ items: [item], position: "before", referenceItem: 0 });
  }, [onInsert]);
  const handleAppend = (0, import_react51.useCallback)((item) => {
    onInsert({ items: [item], position: "after", referenceItem: -1 });
  }, [onInsert]);
  const memberKeys = useMemoCompare((0, import_react51.useMemo)(() => members.map((member) => member.key), [members]), import_shallow_equals.default);
  const { scrollElement, containerElement } = useVirtualizerScrollInstance();
  const parentRef = (0, import_react51.useRef)(null);
  const focusPathKey = (0, import_react51.useMemo)(() => {
    return isKeySegment(focusPath[0]) ? focusPath[0]._key : focusPath[0];
  }, [focusPath]);
  const rangeExtractor = (0, import_react51.useCallback)((range2) => {
    const newRange = { ...range2 };
    if (activeDragItemIndex !== null) {
      newRange.startIndex = Math.min(range2.startIndex, activeDragItemIndex);
      newRange.endIndex = Math.max(range2.endIndex, activeDragItemIndex);
    }
    if (focusPathKey) {
      const index = memberKeys.findIndex((key2) => key2 === focusPathKey);
      if (index !== -1) {
        newRange.startIndex = Math.min(newRange.startIndex, index);
        newRange.endIndex = Math.max(newRange.endIndex, index);
      }
    }
    return defaultRangeExtractor(newRange);
  }, [activeDragItemIndex, focusPathKey, memberKeys]);
  const observeElementOffset3 = (0, import_react51.useCallback)((instance2, callback) => {
    if (!instance2.scrollElement) {
      return void 0;
    }
    const scroll2 = instance2.scrollElement;
    const handleScroll = () => {
      var _a22, _b4, _c4, _d4;
      const containerElementTop = (_b4 = (_a22 = containerElement.current) == null ? void 0 : _a22.getBoundingClientRect().top) != null ? _b4 : 0;
      const parentElementTop = (_d4 = (_c4 = parentRef.current) == null ? void 0 : _c4.getBoundingClientRect().top) != null ? _d4 : 0;
      const itemOffset = Math.floor(parentElementTop - containerElementTop);
      callback(scroll2.scrollTop - itemOffset);
    };
    handleScroll();
    instance2.scrollElement.addEventListener("scroll", handleScroll, { capture: false, passive: true });
    return () => {
      scroll2.removeEventListener("scroll", handleScroll);
    };
  }, [containerElement]);
  const estimateSize = (0, import_react51.useCallback)(() => 53, []);
  const virtualizer = useVirtualizer({ count: members.length, estimateSize, getScrollElement: (0, import_react51.useCallback)(() => scrollElement, [scrollElement]), observeElementOffset: observeElementOffset3, rangeExtractor, getItemKey: (0, import_react51.useCallback)((index) => memberKeys[index], [memberKeys]), scrollToFn: (offset2, options, instance2) => {
    if (offset2 === instance2.scrollOffset) {
      return;
    }
    elementScroll(offset2, options, instance2);
  } });
  const items = virtualizer.getVirtualItems();
  const handleItemMoveStart = (0, import_react51.useCallback)((event) => {
    var _a22, _b4;
    const { active } = event;
    setActiveDragItemIndex((_b4 = (_a22 = active.data.current) == null ? void 0 : _a22.sortable) == null ? void 0 : _b4.index);
  }, []);
  const handleItemMoveEnd = (0, import_react51.useCallback)(() => {
    setActiveDragItemIndex(null);
  }, []);
  const sortable = ((_a4 = schemaType.options) == null ? void 0 : _a4.sortable) !== false;
  const listGridGap = 1;
  const paddingY = 1;
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, ref: parentRef, children: [(0, import_jsx_runtime6.jsx)(UploadTargetCard, { types: schemaType.of, resolveUploader: resolveUploader2, onUpload, ...elementProps, tabIndex: 0, children: (0, import_jsx_runtime6.jsx)(Stack, { "data-ui": "ArrayInput__content", space: 3, children: members.length === 0 ? (0, import_jsx_runtime6.jsx)(Card, { padding: 3, border: true, style: { borderStyle: "dashed" }, radius: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: schemaType.placeholder || (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.array.no-items-label") }) }) }) : (0, import_jsx_runtime6.jsx)(Card, { border: true, radius: 1, style: {
    // This is not memoized since it changes on scroll so it will change anyways making memo useless
    // Account for grid gap
    height: "".concat(virtualizer.getTotalSize() + items.length * space[listGridGap] + space[paddingY], "px"),
    width: "100%",
    position: "relative"
  }, children: (0, import_jsx_runtime6.jsx)(List, { axis: "y", gap: listGridGap, paddingY, items: memberKeys, onItemMove, onItemMoveStart: handleItemMoveStart, onItemMoveEnd: handleItemMoveEnd, sortable, style: {
    // This is not memoized since it changes on scroll so it will change anyways making memo useless
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    transform: "translateY(".concat(items[0].start, "px)")
  }, children: items.map((virtualRow) => {
    const member = members[virtualRow.index];
    return (0, import_jsx_runtime6.jsxs)(Item2, { ref: virtualizer.measureElement, sortable, "data-index": virtualRow.index, id: member.key, children: [member.kind === "item" && (0, import_jsx_runtime6.jsx)(ArrayOfObjectsItem, { member, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }), member.kind === "error" && (0, import_jsx_runtime6.jsx)(ErrorItem$1, { sortable, member, onRemove: () => props2.onItemRemove(member.key) })] }, virtualRow.key);
  }) }) }) }) }), (0, import_jsx_runtime6.jsx)(ArrayFunctions, { onChange, onItemAppend: handleAppend, onItemPrepend: handlePrepend, onValueCreate: createProtoArrayValue, readOnly, schemaType, value })] });
}
function ArrayOfObjectsInput(props2) {
  var _a4;
  const isGrid = ((_a4 = props2.schemaType.options) == null ? void 0 : _a4.layout) === "grid";
  return isGrid ? (0, import_jsx_runtime6.jsx)(GridArrayInput, { ...props2 }) : (0, import_jsx_runtime6.jsx)(ListArrayInput, { ...props2 });
}
var PRIMITIVES2 = ["string", "number", "boolean"];
function isArrayOfPrimitives$1(type) {
  return type.of.every((ofType) => PRIMITIVES2.includes(ofType.jsonType));
}
function isStringArray(type) {
  return type.of.length === 1 && is$1("string", type.of[0]);
}
function isTagsArray(type) {
  var _a4;
  return ((_a4 = type.options) == null ? void 0 : _a4.layout) === "tags";
}
function isPortableText(type) {
  return type.of.some((memberType) => is$1("block", memberType));
}
function hasListOptions(type) {
  var _a4;
  return Boolean((_a4 = type.options) == null ? void 0 : _a4.list);
}
function resolveArrayInput(type) {
  if (isStringArray(type) && isTagsArray(type)) {
    return TagsArrayInput;
  }
  if (hasListOptions(type)) {
    return ArrayOfOptionsInput;
  }
  if (isArrayOfPrimitives$1(type)) {
    return ArrayOfPrimitivesInput;
  }
  if (isPortableText(type)) {
    return PortableTextInput;
  }
  return ArrayOfObjectsInput;
}
function toSelectItem$1(option) {
  return isTitledListValue(option) ? option : { title: (0, import_capitalize2.default)("".concat(option)), value: option };
}
var EMPTY_ITEM = { title: "", value: void 0 };
function SelectInput(props2) {
  var _a4, _b4;
  const { value, readOnly, validationError, schemaType, onChange, path: path2, changed, focused, elementProps } = props2;
  const items = (0, import_react51.useMemo)(() => {
    var _a22;
    return (((_a22 = schemaType.options) == null ? void 0 : _a22.list) || []).map(toSelectItem$1);
  }, [(_a4 = schemaType.options) == null ? void 0 : _a4.list]);
  const currentItem = items.find((item) => item.value === value);
  const isRadio = schemaType.options && schemaType.options.layout === "radio";
  const itemFromOptionValue = (0, import_react51.useCallback)((optionValue) => {
    const index = Number(optionValue);
    return items[index];
  }, [items]);
  const optionValueFromItem = (0, import_react51.useCallback)((item) => {
    return String(items.indexOf(item));
  }, [items]);
  const inputId = (0, import_react51.useId)();
  const handleChange = import_react51.default.useCallback((nextItem) => {
    onChange(PatchEvent.from(typeof (nextItem == null ? void 0 : nextItem.value) === "undefined" ? unset2() : set$2(nextItem.value)));
  }, [onChange]);
  const handleSelectChange = (0, import_react51.useCallback)((event) => {
    const nextItem = itemFromOptionValue(event.currentTarget.value);
    if (!nextItem) {
      handleChange(EMPTY_ITEM);
      return;
    }
    handleChange(nextItem);
  }, [handleChange, itemFromOptionValue]);
  const content = isRadio ? (0, import_jsx_runtime6.jsx)(RadioSelect, { ...elementProps, value: currentItem, inputId, items, direction: ((_b4 = schemaType.options) == null ? void 0 : _b4.direction) || "vertical", customValidity: validationError, onChange: handleChange, readOnly }) : (0, import_jsx_runtime6.jsx)(Select, { ...elementProps, customValidity: validationError, value: optionValueFromItem(currentItem), readOnly, onChange: handleSelectChange, children: [EMPTY_ITEM, ...items].map((item, i) => (0, import_jsx_runtime6.jsx)("option", { value: i - 1, children: item.title }, "".concat(i - 1))) });
  return (0, import_jsx_runtime6.jsx)(ChangeIndicator, { path: path2, isChanged: changed, hasFocus: !!focused, children: content });
}
var RadioSelect = (0, import_react51.forwardRef)(function RadioSelect2(props2, ref) {
  const { items, value, onChange, onFocus, readOnly, customValidity, direction, inputId } = props2;
  const Layout2 = direction === "horizontal" ? Inline : Stack;
  return (0, import_jsx_runtime6.jsx)(Card, { border: true, padding: 3, radius: 1, children: (0, import_jsx_runtime6.jsx)(Layout2, { space: 3, role: "group", children: items.map((item, index) => (0, import_jsx_runtime6.jsx)(RadioSelectItem, { customValidity, inputId, item, onChange, onFocus, readOnly, ref: index === 0 ? ref : null, value }, index)) }) });
});
var RadioSelectItem = (0, import_react51.forwardRef)(function RadioSelectItem2(props2, ref) {
  const { customValidity, inputId, item, onChange, onFocus, readOnly, value } = props2;
  const handleChange = (0, import_react51.useCallback)(() => {
    onChange(item);
  }, [item, onChange]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { as: "label", align: "center", children: [(0, import_jsx_runtime6.jsx)(Radio, { ref, checked: value === item, onChange: handleChange, onFocus, readOnly, customValidity, name: inputId }), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: item.title }) })] });
});
function StringInput(props2) {
  const { validationError, elementProps } = props2;
  return (0, import_jsx_runtime6.jsx)(TextInput, { ...elementProps, customValidity: validationError, "data-testid": "string-input" });
}
function resolveStringInput(type) {
  return getOption(type, "list") ? SelectInput : StringInput;
}
var normalizeRules = (validation2, type) => {
  if (typeof validation2 === "function") {
    throw new Error('Schema type "'.concat((type == null ? void 0 : type.name) || "<not-found>", "\"'s `validation` was not run though `inferFromSchema`"));
  }
  if (!validation2)
    return [];
  if (Array.isArray(validation2))
    return validation2;
  return [validation2];
};
function getValidationRule(type, ruleName) {
  for (const rule of normalizeRules(type == null ? void 0 : type.validation, type)) {
    for (const ruleSpec of rule._rules) {
      if (ruleSpec.flag === ruleName) {
        return ruleSpec;
      }
    }
  }
  return null;
}
function NumberInput(props2) {
  const { schemaType, validationError, elementProps } = props2;
  const minRule = getValidationRule(schemaType, "min");
  const integerRule = getValidationRule(schemaType, "integer");
  const precisionRule = getValidationRule(schemaType, "precision");
  const onlyPositiveNumber = typeof (minRule == null ? void 0 : minRule.constraint) === "number" && (minRule == null ? void 0 : minRule.constraint) >= 0;
  const onlyIntegers = integerRule || (precisionRule == null ? void 0 : precisionRule.constraint) === 0;
  const inputMode = onlyPositiveNumber ? onlyIntegers ? "numeric" : "decimal" : "text";
  return (0, import_jsx_runtime6.jsx)(TextInput, { ...elementProps, type: "number", step: "any", inputMode, customValidity: validationError, placeholder: schemaType.placeholder, pattern: onlyPositiveNumber ? "[d]*" : void 0, max: Number.MAX_SAFE_INTEGER, min: Number.MIN_SAFE_INTEGER, "data-testid": "number-input" });
}
function resolveNumberInput(type) {
  return getOption(type, "list") ? SelectInput : NumberInput;
}
var __freeze$10 = Object.freeze;
var __defProp$10 = Object.defineProperty;
var __template$10 = (cooked, raw) => __freeze$10(__defProp$10(cooked, "raw", { value: __freeze$10(raw || cooked.slice()) }));
var _a$10;
var _b$t;
var CenterAlignedBox = st(Box)(_a$10 || (_a$10 = __template$10(["\n  align-self: center;\n"])));
var ZeroLineHeightBox = st(Box)(_b$t || (_b$t = __template$10(["\n  line-height: 0;\n"])));
function BooleanInput(props2) {
  var _a22;
  const { id: id4, value, schemaType, readOnly, elementProps, validation: validation2 } = props2;
  const layout2 = ((_a22 = schemaType.options) == null ? void 0 : _a22.layout) || "switch";
  const indeterminate = typeof value !== "boolean";
  const checked = value || false;
  const LayoutSpecificInput = layout2 === "checkbox" ? Checkbox : Switch;
  const tone = readOnly ? "transparent" : void 0;
  return (0, import_jsx_runtime6.jsx)(Card, { border: true, "data-testid": "boolean-input", radius: 1, tone, children: (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(ZeroLineHeightBox, { padding: 3, children: (0, import_jsx_runtime6.jsx)(LayoutSpecificInput, { label: schemaType.title, ...elementProps, checked, disabled: readOnly, indeterminate, style: { margin: -4 } }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(FormFieldHeaderText, { description: schemaType.description, inputId: id4, validation: validation2, title: schemaType.title }) }), (0, import_jsx_runtime6.jsx)(CenterAlignedBox, { paddingX: 3, paddingY: 1, children: (0, import_jsx_runtime6.jsx)(FormFieldStatus, { maxAvatars: 1, position: "top" }) })] }) });
}
function EmailInput(props2) {
  const { validationError, elementProps } = props2;
  return (0, import_jsx_runtime6.jsx)(TextInput, { ...elementProps, type: "email", inputMode: "email", customValidity: validationError });
}
function UnknownFields(props2) {
  const { fieldNames, onChange, readOnly, value } = props2;
  const fieldsLen = fieldNames.length;
  const handleUnsetClick = (0, import_react51.useCallback)((fieldName) => {
    onChange(unset2([fieldName]));
  }, [onChange]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Alert, { status: "warning", title: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.object.unknown-fields.warning.title", { count: fieldsLen }) }), children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.object.unknown-fields.warning.description", { count: fieldsLen }) }) }), (0, import_jsx_runtime6.jsxs)(Details, { marginTop: 4, open: isDev, title: t3("inputs.object.unknown-fields.warning.details.title"), children: [(0, import_jsx_runtime6.jsx)(Box, { marginBottom: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("inputs.object.unknown-fields.warning.details.description", { count: fieldsLen }) }) }) }), (0, import_jsx_runtime6.jsx)(Stack, { as: "ul", space: 3, children: fieldNames.map((fieldName) => {
    return (0, import_jsx_runtime6.jsx)(UnknownField, { fieldName, onUnsetClick: handleUnsetClick, readOnly, value: value == null ? void 0 : value[fieldName] }, fieldName);
  }) })] })] });
}
function UnknownField(_ref254) {
  let { fieldName, onUnsetClick, readOnly, value } = _ref254;
  const handleUnsetClick = (0, import_react51.useCallback)(() => {
    onUnsetClick(fieldName);
  }, [fieldName, onUnsetClick]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Card, { as: "li", padding: 3, radius: 2, shadow: 1, tone: "caution", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsxs)(Card, { border: true, radius: 1, children: [(0, import_jsx_runtime6.jsx)(Card, { borderBottom: true, padding: 3, children: (0, import_jsx_runtime6.jsx)(Code, { weight: "medium", children: fieldName }) }), (0, import_jsx_runtime6.jsx)(Box, { overflow: "auto", padding: 3, children: (0, import_jsx_runtime6.jsx)(Code, { language: "json", children: JSON.stringify(value, null, 2) }) })] }), readOnly && (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "inputs.object.unknown-fields.read-only.description" }) }), !readOnly && (0, import_jsx_runtime6.jsx)(Button, { icon: TrashIcon, onClick: handleUnsetClick, tone: "critical", text: t3("inputs.object.unknown-fields.remove-field-button.text") })] }) });
}
var __freeze$$ = Object.freeze;
var __defProp$$ = Object.defineProperty;
var __template$$ = (cooked, raw) => __freeze$$(__defProp$$(cooked, "raw", { value: __freeze$$(raw || cooked.slice()) }));
var _a$$;
var FieldGroupTabsWrapper = st(Card)(_a$$ || (_a$$ = __template$$(["\n  margin-bottom: ", "px;\n  padding-bottom: ", "px;\n"])), (_ref255) => {
  let { $level, theme } = _ref255;
  return $level === 0 ? 0 : theme.sanity.space[5] * -1;
}, (_ref256) => {
  let { $level, theme } = _ref256;
  return $level === 0 ? theme.sanity.space[4] : theme.sanity.space[4];
});
var GroupTab = (0, import_react51.forwardRef)(function GroupTab2(props2, ref) {
  const { onClick } = props2;
  const handleClick = import_react51.default.useCallback(() => {
    onClick == null ? void 0 : onClick(props2.name);
  }, [props2.name, onClick]);
  return (0, import_jsx_runtime6.jsx)(Tab, { "data-testid": "group-tab-".concat(props2.name), size: 1, id: "".concat(props2.name, "-tab"), label: props2.title, ref, ...props2, onClick: handleClick });
});
var GroupOption = (props2) => {
  const { name, title, ...rest } = props2;
  const { selected } = props2;
  return (0, import_jsx_runtime6.jsx)("option", { title, value: name, id: "".concat(name, "-tab"), "aria-controls": rest["aria-controls"], "data-testid": "group-select-".concat(name), "aria-selected": selected ? "true" : "false", children: title || name });
};
var __freeze$_ = Object.freeze;
var __defProp$_ = Object.defineProperty;
var __template$_ = (cooked, raw) => __freeze$_(__defProp$_(cooked, "raw", { value: __freeze$_(raw || cooked.slice()) }));
var _a$_;
var Root$72 = st(ElementQuery)(_a$_ || (_a$_ = __template$_(["\n  /* Hide on small screens */\n  &[data-eq-max~='0'] [data-ui='TabList'] {\n    display: none;\n  }\n\n  /* Hide on medium to large screens */\n  [data-ui='Select'] {\n    display: none;\n  }\n\n  /* Show on small screens */\n  &[data-eq-max~='0'] [data-ui='Select'] {\n    display: block;\n  }\n"])));
var GroupTabs = (_ref257) => {
  let { inputId, groups, onClick, shouldAutoFocus = true, disabled } = _ref257;
  return (0, import_jsx_runtime6.jsx)(TabList, { space: 2, "data-testid": "field-group-tabs", children: groups.map((group2) => {
    return (0, import_jsx_runtime6.jsx)(GroupTab, { "aria-controls": "".concat(inputId, "-field-group-fields"), autoFocus: shouldAutoFocus && group2.selected, disabled: disabled || group2.disabled, icon: group2 == null ? void 0 : group2.icon, name: group2.name, onClick, selected: Boolean(group2.selected), title: group2.title || group2.name }, "".concat(inputId, "-").concat(group2.name, "-tab"));
  }) });
};
var GroupSelect = (_ref258) => {
  let { disabled, groups, inputId, onSelect, shouldAutoFocus = true } = _ref258;
  var _a22;
  const handleSelect = (0, import_react51.useCallback)((event) => {
    onSelect(event.currentTarget.value);
  }, [onSelect]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Select, { "aria-label": t3("inputs.object.field-group-tabs.aria-label"), autoFocus: shouldAutoFocus, "data-testid": "field-group-select", disabled, fontSize: 2, muted: true, onChange: handleSelect, value: (_a22 = groups.find((g) => g.selected)) == null ? void 0 : _a22.name, children: groups.map((group2) => {
    return (0, import_jsx_runtime6.jsx)(GroupOption, { "aria-controls": "".concat(inputId, "-field-group-fields"), disabled: group2.disabled, name: group2.name, selected: Boolean(group2.selected), title: group2.title || group2.name }, "".concat(inputId, "-").concat(group2.name, "-tab"));
  }) });
};
var FieldGroupTabs = import_react51.default.memo(function FieldGroupTabs2(_ref259) {
  let { disabled = false, onClick, ...props2 } = _ref259;
  const handleClick = (0, import_react51.useCallback)((groupName) => {
    onClick == null ? void 0 : onClick(groupName);
  }, [onClick]);
  return (0, import_jsx_runtime6.jsxs)(Root$72, { "data-testid": "field-group-root", children: [(0, import_jsx_runtime6.jsx)(GroupTabs, { ...props2, disabled, onClick: handleClick }), (0, import_jsx_runtime6.jsx)(GroupSelect, { ...props2, disabled, onSelect: handleClick })] });
});
var ObjectInput = (0, import_react51.memo)(function ObjectInput2(props2) {
  const { schemaType, groups, members, onChange, renderAnnotation, renderBlock, renderInlineBlock, renderInput, renderField, renderItem, renderPreview, level, value, id: id4, onFieldGroupSelect } = props2;
  const { columns } = schemaType.options || {};
  const renderedUnknownFields = (0, import_react51.useMemo)(() => {
    if (!schemaType.fields) {
      return null;
    }
    const knownFieldNames = schemaType.fields.map((field) => field.name);
    const unknownFields = Object.keys(value || {}).filter((key2) => !key2.startsWith("_") && !knownFieldNames.includes(key2));
    if (unknownFields.length === 0) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(UnknownFields, { fieldNames: unknownFields, value, onChange });
  }, [onChange, schemaType.fields, value]);
  const renderObjectMembers = (0, import_react51.useCallback)(() => (0, import_jsx_runtime6.jsx)(ObjectInputMembers, { members, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview }), [members, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview]);
  if (members.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 5, children: [groups.length > 0 ? (0, import_jsx_runtime6.jsx)(FieldGroupTabsWrapper, { $level: level, "data-testid": "field-groups", children: (0, import_jsx_runtime6.jsx)(FieldGroupTabs, { groups, inputId: id4, onClick: onFieldGroupSelect, shouldAutoFocus: false }) }) : null, columns ? (0, import_jsx_runtime6.jsx)(Grid, { columns, gap: 4, marginTop: 1, children: renderObjectMembers() }) : renderObjectMembers(), renderedUnknownFields] });
});
function CalendarDay$1(props2) {
  const { date, focused, isCurrentMonth, isToday, onSelect, selected } = props2;
  const handleClick = (0, import_react51.useCallback)(() => {
    onSelect(date);
  }, [date, onSelect]);
  return (0, import_jsx_runtime6.jsx)("div", { "aria-selected": selected, "data-ui": "CalendarDay", children: (0, import_jsx_runtime6.jsx)(Card, { "aria-label": date.toDateString(), "aria-pressed": selected, as: "button", __unstable_focusRing: true, "data-weekday": true, "data-focused": focused ? "true" : "", role: "button", tabIndex: -1, onClick: handleClick, padding: 3, radius: 2, selected, tone: isToday || selected ? "primary" : "default", children: (0, import_jsx_runtime6.jsx)(Text3, { muted: !selected && !isCurrentMonth, style: { textAlign: "center" }, weight: isCurrentMonth ? "medium" : "regular", children: date.getDate() }) }) });
}
var HOURS_24 = (0, import_range.default)(0, 24);
var ARROW_KEYS$1 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var TAIL_WEEKDAYS$1 = [1, 2, 3, 4, 5, 6];
var getWeekStartsOfMonth$1 = (date) => {
  const firstDay = startOfMonth(date);
  return eachWeekOfInterval({ start: firstDay, end: lastDayOfMonth(firstDay) });
};
var getWeekDaysFromWeekStarts$1 = (weekStarts) => {
  return weekStarts.map((weekStart) => [weekStart, ...TAIL_WEEKDAYS$1.map((d) => addDays(weekStart, d))]);
};
var getWeeksOfMonth$1 = (date) => getWeekDaysFromWeekStarts$1(getWeekStartsOfMonth$1(date)).map((days) => ({ number: getWeek(days[0]), days }));
function CalendarMonth$1(props2) {
  return (0, import_jsx_runtime6.jsx)(Box, { "aria-hidden": props2.hidden || false, "data-ui": "CalendarMonth", children: (0, import_jsx_runtime6.jsxs)(Grid, { gap: 1, style: { gridTemplateColumns: "repeat(7, minmax(44px, 46px))" }, children: [props2.weekDayNames.map((weekday) => (0, import_jsx_runtime6.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "medium", style: { textAlign: "center" }, children: weekday }) }, weekday)), getWeeksOfMonth$1(props2.date).map((week, weekIdx) => week.days.map((date, dayIdx) => {
    const focused = props2.focused && isSameDay(date, props2.focused);
    const selected = props2.selected && isSameDay(date, props2.selected);
    const isToday = isSameDay(date, /* @__PURE__ */ new Date());
    const isCurrentMonth = props2.focused && isSameMonth(date, props2.focused);
    return (0, import_jsx_runtime6.jsx)(CalendarDay$1, { date, focused, isCurrentMonth, isToday, onSelect: props2.onSelect, selected }, "".concat(weekIdx, "-").concat(dayIdx));
  }))] }) });
}
var features = { dayPresets: false, timePresets: false };
var LazyTextInput = import_react51.default.forwardRef(function LazyTextInput2(_ref260, forwardedRef) {
  let { onChange, onBlur, onKeyPress, value, ...rest } = _ref260;
  const [inputValue, setInputValue] = import_react51.default.useState();
  const handleChange = import_react51.default.useCallback((event) => {
    setInputValue(event.currentTarget.value);
  }, []);
  const checkEvent = import_react51.default.useCallback((event) => {
    const currentValue = event.currentTarget.value;
    if (currentValue !== "".concat(value)) {
      if (onChange) {
        onChange(event);
      }
    }
    setInputValue(void 0);
  }, [onChange, value]);
  const handleBlur = import_react51.default.useCallback((e2) => {
    checkEvent(e2);
    if (onBlur) {
      onBlur(e2);
    }
  }, [checkEvent, onBlur]);
  const handleKeyPress = import_react51.default.useCallback((e2) => {
    if (e2.key === "Enter") {
      checkEvent(e2);
    }
    if (onKeyPress) {
      onKeyPress(e2);
    }
  }, [checkEvent, onKeyPress]);
  return (0, import_jsx_runtime6.jsx)(TextInput, { ...rest, "data-testid": "date-input", ref: forwardedRef, value: inputValue === void 0 ? value : inputValue, onChange: handleChange, onBlur: handleBlur, onKeyPress: handleKeyPress });
});
var YearInput = (_ref261) => {
  let { onChange, ...props2 } = _ref261;
  const handleChange = import_react51.default.useCallback((event) => {
    const numericValue = parseInt(event.currentTarget.value, 10);
    if (!isNaN(numericValue)) {
      onChange(numericValue);
    }
  }, [onChange]);
  return (0, import_jsx_runtime6.jsx)(LazyTextInput, { ...props2, onChange: handleChange, inputMode: "numeric" });
};
var PRESERVE_FOCUS_ELEMENT$1 = (0, import_jsx_runtime6.jsx)("span", { "data-preserve-focus": true, style: { overflow: "hidden", position: "absolute", outline: "none" }, tabIndex: -1 });
var Calendar$1 = (0, import_react51.forwardRef)(function Calendar2(props2, forwardedRef) {
  const { selectTime, onFocusedDateChange, selectedDate = /* @__PURE__ */ new Date(), focusedDate = selectedDate, timeStep = 1, onSelect, labels, ...restProps } = props2;
  const setFocusedDate = (0, import_react51.useCallback)((date) => onFocusedDateChange(date), [onFocusedDateChange]);
  const setFocusedDateMonth = (0, import_react51.useCallback)((month) => setFocusedDate(setDate(setMonth(focusedDate, month), 1)), [focusedDate, setFocusedDate]);
  const handleFocusedMonthChange = (0, import_react51.useCallback)((e2) => setFocusedDateMonth(Number(e2.currentTarget.value)), [setFocusedDateMonth]);
  const moveFocusedDate = (0, import_react51.useCallback)((by) => setFocusedDate(addMonths(focusedDate, by)), [focusedDate, setFocusedDate]);
  const setFocusedDateYear = (0, import_react51.useCallback)((year) => setFocusedDate(setYear(focusedDate, year)), [focusedDate, setFocusedDate]);
  const handleDateChange = (0, import_react51.useCallback)((date) => {
    onSelect(setMinutes(setHours(date, selectedDate.getHours()), selectedDate.getMinutes()));
  }, [onSelect, selectedDate]);
  const handleMinutesChange = (0, import_react51.useCallback)((event) => {
    const m2 = Number(event.currentTarget.value);
    onSelect(setMinutes(selectedDate, m2));
  }, [onSelect, selectedDate]);
  const handleHoursChange = (0, import_react51.useCallback)((event) => {
    const m2 = Number(event.currentTarget.value);
    onSelect(setHours(selectedDate, m2));
  }, [onSelect, selectedDate]);
  (0, import_react51.useCallback)((hours, mins) => {
    onSelect(setHours(setMinutes(selectedDate, mins), hours));
  }, [onSelect, selectedDate]);
  const ref = useForwardedRef(forwardedRef);
  const focusCurrentWeekDay = (0, import_react51.useCallback)(() => {
    var _a4, _b4;
    (_b4 = (_a4 = ref.current) == null ? void 0 : _a4.querySelector('[data-focused="true"]')) == null ? void 0 : _b4.focus();
  }, [ref]);
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    var _a4, _b4;
    if (!ARROW_KEYS$1.includes(event.key)) {
      return;
    }
    event.preventDefault();
    if (event.target.hasAttribute("data-calendar-grid")) {
      focusCurrentWeekDay();
      return;
    }
    if (event.key === "ArrowUp") {
      onFocusedDateChange(addDays(focusedDate, -7));
    }
    if (event.key === "ArrowDown") {
      onFocusedDateChange(addDays(focusedDate, 7));
    }
    if (event.key === "ArrowLeft") {
      onFocusedDateChange(addDays(focusedDate, -1));
    }
    if (event.key === "ArrowRight") {
      onFocusedDateChange(addDays(focusedDate, 1));
    }
    (_b4 = (_a4 = ref.current) == null ? void 0 : _a4.querySelector("[data-preserve-focus]")) == null ? void 0 : _b4.focus();
  }, [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]);
  (0, import_react51.useEffect)(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]);
  (0, import_react51.useEffect)(() => {
    var _a4;
    const currentFocusInCalendarGrid = (_a4 = document.activeElement) == null ? void 0 : _a4.matches("[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]");
    if (
      // Only move focus if it's currently in the calendar grid
      currentFocusInCalendarGrid
    ) {
      focusCurrentWeekDay();
    }
  }, [ref, focusCurrentWeekDay, focusedDate]);
  (0, import_react51.useCallback)(() => handleDateChange(addDays(/* @__PURE__ */ new Date(), -1)), [handleDateChange]);
  (0, import_react51.useCallback)(() => handleDateChange(/* @__PURE__ */ new Date()), [handleDateChange]);
  (0, import_react51.useCallback)(() => handleDateChange(addDays(/* @__PURE__ */ new Date(), 1)), [handleDateChange]);
  const handleNowClick = (0, import_react51.useCallback)(() => onSelect(/* @__PURE__ */ new Date()), [onSelect]);
  return (0, import_jsx_runtime6.jsxs)(Box, { "data-ui": "Calendar", ...restProps, ref, children: [(0, import_jsx_runtime6.jsxs)(Box, { padding: 2, children: [features.dayPresets, (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(CalendarMonthSelect, { moveFocusedDate, onChange: handleFocusedMonthChange, labels: { goToPreviousMonth: labels.goToPreviousMonth, goToNextMonth: labels.goToNextMonth }, monthNames: labels.monthNames, value: focusedDate == null ? void 0 : focusedDate.getMonth() }) }), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(CalendarYearSelect, { moveFocusedDate, labels: { goToNextYear: labels.goToNextYear, goToPreviousYear: labels.goToPreviousYear }, onChange: setFocusedDateYear, value: focusedDate.getFullYear() }) })] }), (0, import_jsx_runtime6.jsxs)(Box, { "data-calendar-grid": true, onKeyDown: handleKeyDown, marginTop: 2, overflow: "hidden", tabIndex: 0, children: [(0, import_jsx_runtime6.jsx)(CalendarMonth$1, { weekDayNames: labels.weekDayNamesShort, date: focusedDate, focused: focusedDate, onSelect: handleDateChange, selected: selectedDate }), PRESERVE_FOCUS_ELEMENT$1] })] }), selectTime && (0, import_jsx_runtime6.jsxs)(Box, { padding: 2, style: { borderTop: "1px solid var(--card-border-color)" }, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", flex: 1, children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Select, { "aria-label": labels.selectHour, value: selectedDate == null ? void 0 : selectedDate.getHours(), onChange: handleHoursChange, children: HOURS_24.map((h) => (0, import_jsx_runtime6.jsx)("option", { value: h, children: "".concat(h).padStart(2, "0") }, h)) }) }), (0, import_jsx_runtime6.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { children: ":" }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Select, { "aria-label": labels.selectMinute, value: selectedDate == null ? void 0 : selectedDate.getMinutes(), onChange: handleMinutesChange, children: (0, import_range.default)(0, 60, timeStep).map((m2) => (0, import_jsx_runtime6.jsx)("option", { value: m2, children: "".concat(m2).padStart(2, "0") }, m2)) }) })] }), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(Button, { text: labels.setToCurrentTime, mode: "bleed", onClick: handleNowClick }) })] }), features.timePresets] })] });
});
function CalendarMonthSelect(props2) {
  const { moveFocusedDate, onChange, value, labels, monthNames } = props2;
  const handlePrevMonthClick = (0, import_react51.useCallback)(() => moveFocusedDate(-1), [moveFocusedDate]);
  const handleNextMonthClick = (0, import_react51.useCallback)(() => moveFocusedDate(1), [moveFocusedDate]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { flex: 1, children: [(0, import_jsx_runtime6.jsx)(Button, { "aria-label": labels.goToPreviousMonth, onClick: handlePrevMonthClick, mode: "bleed", icon: ChevronLeftIcon, paddingX: 2, radius: 0 }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Select, { radius: 0, value, onChange, children: monthNames.map((monthName, i) => (
    // eslint-disable-next-line react/no-array-index-key
    (0, import_jsx_runtime6.jsx)("option", { value: i, children: monthName }, i)
  )) }) }), (0, import_jsx_runtime6.jsx)(Button, { "aria-label": labels.goToNextMonth, mode: "bleed", icon: ChevronRightIcon, onClick: handleNextMonthClick, paddingX: 2, radius: 0 })] });
}
function CalendarYearSelect(props2) {
  const { moveFocusedDate, onChange, value, labels } = props2;
  const handlePrevYearClick = (0, import_react51.useCallback)(() => moveFocusedDate(-12), [moveFocusedDate]);
  const handleNextYearClick = (0, import_react51.useCallback)(() => moveFocusedDate(12), [moveFocusedDate]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Button, { "aria-label": labels.goToPreviousYear, onClick: handlePrevYearClick, mode: "bleed", icon: ChevronLeftIcon, paddingX: 2, radius: 0 }), (0, import_jsx_runtime6.jsx)(YearInput, { value, onChange, radius: 0, style: { width: 65 } }), (0, import_jsx_runtime6.jsx)(Button, { "aria-label": labels.goToNextYear, onClick: handleNextYearClick, mode: "bleed", icon: ChevronRightIcon, paddingX: 2, radius: 0 })] });
}
var DatePicker$1 = import_react51.default.forwardRef(function DatePicker2(props2, ref) {
  const { value = /* @__PURE__ */ new Date(), onChange, calendarLabels, ...rest } = props2;
  const [focusedDate, setFocusedDay] = import_react51.default.useState();
  const handleSelect = import_react51.default.useCallback((nextDate) => {
    onChange(nextDate);
    setFocusedDay(void 0);
  }, [onChange]);
  return (0, import_jsx_runtime6.jsx)(Calendar$1, { ...rest, labels: calendarLabels, ref, selectedDate: value, onSelect: handleSelect, focusedDate: focusedDate || value, onFocusedDateChange: setFocusedDay });
});
var DateTimeInput$1 = (0, import_react51.forwardRef)(function DateTimeInput2(props2, ref) {
  const { value, inputValue, onInputChange, onChange, selectTime, timeStep, calendarLabels, ...rest } = props2;
  const [popoverRef, setPopoverRef] = (0, import_react51.useState)(null);
  const forwardedRef = useForwardedRef(ref);
  const buttonRef = (0, import_react51.useRef)(null);
  const [isPickerOpen, setPickerOpen] = (0, import_react51.useState)(false);
  useClickOutside(() => setPickerOpen(false), [popoverRef]);
  const handleDeactivation = (0, import_react51.useCallback)(() => {
    var _a4, _b4;
    (_a4 = forwardedRef.current) == null ? void 0 : _a4.focus();
    (_b4 = forwardedRef.current) == null ? void 0 : _b4.select();
  }, [forwardedRef]);
  const handleKeyUp = (0, import_react51.useCallback)((e2) => {
    if (e2.key === "Escape") {
      setPickerOpen(false);
    }
  }, []);
  const handleClick = (0, import_react51.useCallback)(() => setPickerOpen(true), []);
  const suffix = (0, import_jsx_runtime6.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime6.jsx)(Button, { ref: buttonRef, icon: CalendarIcon, mode: "bleed", padding: 2, onClick: handleClick, style: { display: "block" }, "data-testid": "select-date-button" }) });
  return (0, import_jsx_runtime6.jsx)(LazyTextInput, { ref: forwardedRef, ...rest, value: inputValue, onChange: onInputChange, suffix: isPickerOpen ? (
    // Note: we're conditionally inserting the popover here due to an
    // issue with popovers rendering incorrectly on subsequent renders
    // see https://github.com/sanity-io/design/issues/519
    (0, import_jsx_runtime6.jsx)(LayerProvider, { zOffset: 1e3, children: (0, import_jsx_runtime6.jsx)(Popover, { constrainSize: true, "data-testid": "date-input-dialog", portal: true, content: (0, import_jsx_runtime6.jsx)(Box, { overflow: "auto", children: (0, import_jsx_runtime6.jsx)(es2015_default, { onDeactivation: handleDeactivation, children: (0, import_jsx_runtime6.jsx)(DatePicker$1, { calendarLabels, selectTime, timeStep, onKeyUp: handleKeyUp, value, onChange }) }) }), open: true, placement: "bottom", ref: setPopoverRef, radius: 2, children: suffix }) })
  ) : suffix });
});
var DEFAULT_PLACEHOLDER_TIME = /* @__PURE__ */ new Date();
var CommonDateTimeInput = import_react51.default.forwardRef(function CommonDateTimeInput2(props2, ref) {
  const { id: id4, deserialize: deserialize2, formatInputValue, onChange, parseInputValue, placeholder, readOnly, selectTime, serialize: serialize2, timeStep, value, ...restProps } = props2;
  const [localValue, setLocalValue] = import_react51.default.useState(null);
  const { t: t3 } = useTranslation2();
  (0, import_react51.useEffect)(() => {
    setLocalValue(null);
  }, [value]);
  const handleDatePickerInputChange = import_react51.default.useCallback((event) => {
    const nextInputValue = event.currentTarget.value;
    const result = nextInputValue === "" ? null : parseInputValue(nextInputValue);
    if (result === null) {
      onChange(null);
      if (typeof value === "undefined" && localValue) {
        setLocalValue(null);
      }
    } else if (result.isValid) {
      onChange(serialize2(result.date));
    } else {
      setLocalValue(nextInputValue);
    }
  }, [parseInputValue, onChange, value, localValue, serialize2]);
  const handleDatePickerChange = import_react51.default.useCallback((nextDate) => {
    onChange(nextDate ? serialize2(nextDate) : null);
  }, [serialize2, onChange]);
  const forwardedRef = useForwardedRef(ref);
  const parseResult = localValue ? parseInputValue(localValue) : value ? deserialize2(value) : null;
  const inputValue = localValue ? localValue : (parseResult == null ? void 0 : parseResult.isValid) ? formatInputValue(parseResult.date) : value;
  return readOnly ? (0, import_jsx_runtime6.jsx)(TextInput, { value: inputValue, readOnly: true }) : (0, import_jsx_runtime6.jsx)(DateTimeInput$1, { ...restProps, calendarLabels: props2.calendarLabels, id: id4, selectTime, timeStep, placeholder: placeholder || t3("inputs.datetime.placeholder", { example: formatInputValue(DEFAULT_PLACEHOLDER_TIME) }), ref: forwardedRef, value: parseResult == null ? void 0 : parseResult.date, inputValue: inputValue || "", readOnly: Boolean(readOnly), onInputChange: handleDatePickerInputChange, onChange: handleDatePickerChange, customValidity: parseResult == null ? void 0 : parseResult.error });
});
function isValidDate(date) {
  return date instanceof Date && !isNaN(date.valueOf());
}
function getCalendarLabels(t3) {
  return { goToTomorrow: t3("calendar.action.go-to-tomorrow"), goToToday: t3("calendar.action.go-to-today"), goToYesterday: t3("calendar.action.go-to-yesterday"), goToNextMonth: t3("calendar.action.go-to-next-month"), goToPreviousMonth: t3("calendar.action.go-to-previous-month"), goToNextYear: t3("calendar.action.go-to-next-year"), goToPreviousYear: t3("calendar.action.go-to-previous-year"), setToCurrentTime: t3("calendar.action.set-to-current-time"), selectHour: t3("calendar.action.select-hour"), selectMinute: t3("calendar.action.select-minute"), monthNames: [t3("calendar.month-names.january"), t3("calendar.month-names.february"), t3("calendar.month-names.march"), t3("calendar.month-names.april"), t3("calendar.month-names.may"), t3("calendar.month-names.june"), t3("calendar.month-names.july"), t3("calendar.month-names.august"), t3("calendar.month-names.september"), t3("calendar.month-names.october"), t3("calendar.month-names.november"), t3("calendar.month-names.december")], weekDayNamesShort: [t3("calendar.weekday-names.short.monday"), t3("calendar.weekday-names.short.tuesday"), t3("calendar.weekday-names.short.wednesday"), t3("calendar.weekday-names.short.thursday"), t3("calendar.weekday-names.short.friday"), t3("calendar.weekday-names.short.saturday"), t3("calendar.weekday-names.short.sunday")], setToTimePreset: (time2, date) => t3("calendar.action.set-to-time-preset", { time: time2, date }) };
}
var DEFAULT_DATE_FORMAT$1 = "YYYY-MM-DD";
var DEFAULT_TIME_FORMAT = "HH:mm";
function parseOptions() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return { dateFormat: options.dateFormat || DEFAULT_DATE_FORMAT$1, timeFormat: options.timeFormat || DEFAULT_TIME_FORMAT, timeStep: "timeStep" in options && Number(options.timeStep) || 1 };
}
function serialize$2(date) {
  return date.toISOString();
}
function deserialize$1(isoString) {
  const deserialized = new Date(isoString);
  if (isValidDate(deserialized)) {
    return { isValid: true, date: deserialized };
  }
  return { isValid: false, error: 'Invalid date value: "'.concat(isoString, '"') };
}
function enforceTimeStep(dateString, timeStep) {
  if (!timeStep || timeStep === 1) {
    return dateString;
  }
  const date = parseISO(dateString);
  const minutes = getMinutes(date);
  const leftOver = minutes % timeStep;
  if (leftOver !== 0) {
    return serialize$2(setMinutes(date, minutes - leftOver));
  }
  return serialize$2(date);
}
function DateTimeInput(props2) {
  const { onChange, schemaType, value, elementProps } = props2;
  const { dateFormat, timeFormat, timeStep } = parseOptions(schemaType.options);
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((nextDate) => {
    let date = nextDate;
    if (date !== null && timeStep > 1) {
      date = enforceTimeStep(date, timeStep);
    }
    onChange(date === null ? unset2() : set$2(date));
  }, [onChange, timeStep]);
  const formatInputValue = import_react51.default.useCallback((date) => format3(date, "".concat(dateFormat, " ").concat(timeFormat)), [dateFormat, timeFormat]);
  const parseInputValue = import_react51.default.useCallback((inputValue) => parse5(inputValue, "".concat(dateFormat, " ").concat(timeFormat)), [dateFormat, timeFormat]);
  const calendarLabels = (0, import_react51.useMemo)(() => getCalendarLabels(t3), [t3]);
  return (0, import_jsx_runtime6.jsx)(CommonDateTimeInput, { ...elementProps, calendarLabels, onChange: handleChange, deserialize: deserialize$1, formatInputValue, parseInputValue, placeholder: schemaType.placeholder, selectTime: true, serialize: serialize$2, timeStep, value });
}
var VALUE_FORMAT = "YYYY-MM-DD";
var DEFAULT_DATE_FORMAT = VALUE_FORMAT;
var deserialize = (value) => parse5(value, VALUE_FORMAT);
var serialize$1 = (date) => format3(date, VALUE_FORMAT);
function DateInput(props2) {
  var _a4;
  const { readOnly, onChange, schemaType, elementProps, value } = props2;
  const dateFormat = ((_a4 = schemaType.options) == null ? void 0 : _a4.dateFormat) || DEFAULT_DATE_FORMAT;
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((nextDate) => {
    onChange(nextDate === null ? unset2() : set$2(nextDate));
  }, [onChange]);
  const formatInputValue = (0, import_react51.useCallback)((date) => format3(date, dateFormat), [dateFormat]);
  const parseInputValue = (0, import_react51.useCallback)((inputValue) => parse5(inputValue, dateFormat), [dateFormat]);
  const calendarLabels = (0, import_react51.useMemo)(() => getCalendarLabels(t3), [t3]);
  return (0, import_jsx_runtime6.jsx)(CommonDateTimeInput, { ...elementProps, deserialize, formatInputValue, onChange: handleChange, parseInputValue, placeholder: schemaType.placeholder, calendarLabels, readOnly, selectTime: false, serialize: serialize$1, value });
}
var __freeze$Z = Object.freeze;
var __defProp$Z = Object.defineProperty;
var __template$Z = (cooked, raw) => __freeze$Z(__defProp$Z(cooked, "raw", { value: __freeze$Z(raw || cooked.slice()) }));
var _a$Z;
var StyledTextArea = st(TextArea)(_a$Z || (_a$Z = __template$Z(["\n  &[data-as='textarea'] {\n    resize: vertical;\n  }\n"])));
function TextInput3(props2) {
  const { schemaType, validationError, value, elementProps } = props2;
  return (0, import_jsx_runtime6.jsx)(StyledTextArea, { customValidity: validationError, value: value || "", placeholder: schemaType.placeholder, rows: typeof schemaType.rows === "number" ? schemaType.rows : 10, ...elementProps });
}
function UrlInput(props2) {
  var _a4, _b4;
  const { schemaType, validationError, elementProps } = props2;
  const uriRule = getValidationRule(schemaType, "uri");
  const inputType = ((_b4 = (_a4 = uriRule == null ? void 0 : uriRule.constraint) == null ? void 0 : _a4.options) == null ? void 0 : _b4.allowRelative) ? "text" : "url";
  return (0, import_jsx_runtime6.jsx)(TextInput, { type: inputType, inputMode: "url", customValidity: validationError, ...elementProps });
}
var defaultSlugify = (value, type) => {
  var _a4;
  const maxLength = (_a4 = type.options) == null ? void 0 : _a4.maxLength;
  const slugifyOpts = { truncate: typeof maxLength === "number" ? maxLength : 200, symbols: true };
  return value ? (0, import_speakingurl.default)(value, slugifyOpts) : "";
};
async function slugify(sourceValue, type, context) {
  var _a4;
  if (!sourceValue) {
    return sourceValue;
  }
  const slugifier = ((_a4 = type.options) == null ? void 0 : _a4.slugify) || defaultSlugify;
  return slugifier(sourceValue, type, context);
}
function useAsync(fn, dependencies) {
  const [state, setState] = import_react51.default.useState(null);
  const lastId = import_react51.default.useRef(0);
  const wrappedCallback = import_react51.default.useCallback(
    (arg) => {
      const asyncId = ++lastId.current;
      setState({ status: "pending" });
      Promise.resolve().then(() => fn(arg)).then((res) => {
        if (asyncId === lastId.current) {
          setState({ status: "complete", result: res });
        }
      }, (err) => {
        if (asyncId === lastId.current) {
          setState({ status: "error", error: err });
        }
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- this is under control, and enforced by our linter setup
    [fn, ...dependencies]
  );
  return [state, wrappedCallback];
}
function useSlugContext() {
  const { getClient } = useSource();
  const schema = useSchema();
  const currentUser = useCurrentUser();
  const projectId2 = useProjectId$1();
  const dataset2 = useDataset();
  return (0, import_react51.useMemo)(() => {
    return { projectId: projectId2, dataset: dataset2, getClient, schema, currentUser };
  }, [getClient, schema, currentUser, projectId2, dataset2]);
}
function getSlugSourceContext(valuePath, document2, context) {
  const parentPath = valuePath.slice(0, -1);
  const parent = get(document2, parentPath);
  return { parentPath, parent, ...context };
}
async function getNewFromSource(source, document2, context) {
  return typeof source === "function" ? source(document2, context) : get(document2, source);
}
function SlugInput(props2) {
  var _a4;
  const getFormValue = useGetFormValue();
  const { path: path2, value, schemaType, validation: validation2, onChange, readOnly, elementProps } = props2;
  const sourceField = (_a4 = schemaType.options) == null ? void 0 : _a4.source;
  const errors = (0, import_react51.useMemo)(() => validation2.filter((item) => item.level === "error"), [validation2]);
  const slugContext = useSlugContext();
  const { t: t3 } = useTranslation2();
  const updateSlug = (0, import_react51.useCallback)((nextSlug) => {
    if (!nextSlug) {
      onChange(PatchEvent.from(unset2([])));
      return;
    }
    onChange(PatchEvent.from([setIfMissing2({ _type: schemaType.name }), set$2(nextSlug, ["current"])]));
  }, [onChange, schemaType.name]);
  const [generateState, handleGenerateSlug] = useAsync(() => {
    if (!sourceField) {
      return Promise.reject(new Error(t3("inputs.slug.error.missing-source", { schemaType: schemaType.name })));
    }
    const doc = getFormValue([]) || { _type: schemaType.name };
    const sourceContext = getSlugSourceContext(path2, doc, slugContext);
    return getNewFromSource(sourceField, doc, sourceContext).then((newFromSource) => slugify(newFromSource || "", schemaType, sourceContext)).then((newSlug) => updateSlug(newSlug));
  }, [sourceField, getFormValue, schemaType, path2, slugContext, updateSlug, t3]);
  const isUpdating = (generateState == null ? void 0 : generateState.status) === "pending";
  const handleChange = import_react51.default.useCallback((event) => updateSlug(event.currentTarget.value), [updateSlug]);
  return (0, import_jsx_runtime6.jsx)(Stack, { space: 3, children: (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsxs)(Box, { flex: 1, children: [(0, import_jsx_runtime6.jsx)(TextInput, { customValidity: errors.length > 0 ? errors[0].message : "", disabled: isUpdating, onChange: handleChange, value: (value == null ? void 0 : value.current) || "", readOnly, ...elementProps }), (generateState == null ? void 0 : generateState.status) === "error" && (0, import_jsx_runtime6.jsx)(Card, { padding: 2, tone: "critical", children: generateState.error.message })] }), sourceField && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", type: "button", disabled: readOnly || isUpdating, onClick: handleGenerateSlug, text: (generateState == null ? void 0 : generateState.status) === "pending" ? t3("inputs.slug.action.generating") : t3("inputs.slug.action.generate") }) })] }) });
}
function UniversalArrayInput(props2) {
  const isArrayOfOptionsInput = (0, import_react51.useMemo)(() => {
    var _a4;
    return Array.isArray((_a4 = props2.schemaType.options) == null ? void 0 : _a4.list);
  }, [props2.schemaType]);
  if (isArrayOfOptionsInput) {
    return (0, import_jsx_runtime6.jsx)(ArrayOfOptionsInput, { ...props2 });
  }
  return isArrayOfPrimitivesInputProps(props2) ? (0, import_jsx_runtime6.jsx)(ArrayOfPrimitivesInput, { ...props2 }) : (0, import_jsx_runtime6.jsx)(ArrayOfObjectsInput, { ...props2 });
}
var defaultInputs = { document: ObjectInput, object: ObjectInput, array: UniversalArrayInput, boolean: BooleanInput, number: NumberInput, text: TextInput3, email: EmailInput, datetime: DateTimeInput, date: DateInput, url: UrlInput, image: StudioImageInput, file: StudioFileInput, string: StringInput, slug: SlugInput, crossDatasetReference: StudioCrossDatasetReferenceInput };
function resolveComponentFromTypeVariants(type) {
  if (is$1("array", type)) {
    return resolveArrayInput(type);
  }
  if (is$1("reference", type)) {
    return StudioReferenceInput;
  }
  if (is$1("string", type)) {
    return resolveStringInput(type);
  }
  if (is$1("number", type)) {
    return resolveNumberInput(type);
  }
  return void 0;
}
function defaultResolveInputComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.input)
    return schemaType.components.input;
  const componentFromTypeVariants = resolveComponentFromTypeVariants(schemaType);
  if (componentFromTypeVariants) {
    return componentFromTypeVariants;
  }
  const typeChain = getTypeChain(schemaType, /* @__PURE__ */ new Set());
  const deduped = typeChain.reduce((acc, type) => {
    acc[type.name] = type;
    return acc;
  }, {});
  const subType = Object.values(deduped).find((t3) => defaultInputs[t3.name]);
  if (subType) {
    return defaultInputs[subType.name];
  }
  throw new Error("Could not find input component for schema type `".concat(schemaType.name, "`"));
}
function defaultResolvePreviewComponent(schemaType) {
  var _a4;
  if ((_a4 = schemaType.components) == null ? void 0 : _a4.preview)
    return schemaType.components.preview;
  return SanityDefaultPreview;
}
function useResolveDefaultComponent(props2) {
  const { componentResolver, componentProps } = props2;
  if (!componentProps.schemaType) {
    throw new Error("the `schemaType` property must be defined");
  }
  const defaultResolvedComponent = componentResolver(componentProps.schemaType);
  const renderDefault = (0, import_react51.useCallback)((parentTypeProps) => {
    var _a4;
    if (!((_a4 = parentTypeProps.schemaType) == null ? void 0 : _a4.type)) {
      throw new Error("Attempted to render form component of non-existent parent type");
    }
    const { components, ...restSchemaType } = parentTypeProps.schemaType;
    const parentTypeResolvedComponent = componentResolver(restSchemaType);
    return (0, import_react51.createElement)(parentTypeResolvedComponent, parentTypeProps);
  }, [componentResolver]);
  return (0, import_react51.createElement)(defaultResolvedComponent, { ...componentProps, renderDefault });
}
function DefaultInput(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolveInputComponent });
}
function DefaultField(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolveFieldComponent });
}
function DefaultItem(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolveItemComponent });
}
function DefaultPreview$1(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolvePreviewComponent });
}
function DefaultBlock(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolveBlockComponent });
}
function DefaultInlineBlock(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolveInlineBlockComponent });
}
function DefaultAnnotation2(props2) {
  return useResolveDefaultComponent({ componentProps: props2, componentResolver: defaultResolveAnnotationComponent });
}
function pickInputComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.input;
}
function pickFieldComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.field;
}
function pickPreviewComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.preview;
}
function pickItemComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.item;
}
function pickBlockComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.block;
}
function pickInlineBlockComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.inlineBlock;
}
function pickAnnotationComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.form) == null ? void 0 : _a4.components) == null ? void 0 : _b4.annotation;
}
function useInputComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultInput, pick: pickInputComponent });
}
function useFieldComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultField, pick: pickFieldComponent });
}
function usePreviewComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultPreview$1, pick: pickPreviewComponent });
}
function useItemComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultItem, pick: pickItemComponent });
}
function useBlockComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultBlock, pick: pickBlockComponent });
}
function useInlineBlockComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultInlineBlock, pick: pickInlineBlockComponent });
}
function useAnnotationComponent() {
  return useMiddlewareComponents({ defaultComponent: DefaultAnnotation2, pick: pickAnnotationComponent });
}
function Preview(props2) {
  const PreviewComponent = usePreviewComponent();
  return (0, import_jsx_runtime6.jsx)(PreviewLoader, { ...props2, component: PreviewComponent });
}
function getPreviewPaths(preview) {
  const selection = preview == null ? void 0 : preview.select;
  if (!selection)
    return void 0;
  return Object.values(selection).map((value) => String(value).split("."));
}
var isLiveEditEnabled$1 = (schemaType) => schemaType.liveEdit === true;
function getPreviewStateObservable(documentPreviewStore, schemaType, documentId, title) {
  const draft$ = isLiveEditEnabled$1(schemaType) ? of({ snapshot: null }) : documentPreviewStore.observeForPreview({ _type: "reference", _ref: getDraftId(documentId) }, schemaType);
  const published$ = documentPreviewStore.observeForPreview({ _type: "reference", _ref: getPublishedId(documentId) }, schemaType);
  return combineLatest([draft$, published$]).pipe(map((_ref262) => {
    let [draft, published] = _ref262;
    return { draft: draft.snapshot ? { title, ...draft.snapshot || {} } : null, isLoading: false, published: published.snapshot ? { title, ...published.snapshot || {} } : null };
  }), startWith({ draft: null, isLoading: true, published: null }));
}
var getMissingDocumentFallback = (item) => ({ title: (0, import_jsx_runtime6.jsx)("em", { children: item.title ? String(item.title) : "Missing document" }), subtitle: (0, import_jsx_runtime6.jsx)("em", { children: item.title ? "Missing document ID: ".concat(item._id) : "Document ID: ".concat(item._id) }), media: () => (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) });
var getPreviewValueWithFallback = (_ref263) => {
  let { value, draft, published } = _ref263;
  const snapshot = draft || published;
  if (!snapshot) {
    return getMissingDocumentFallback(value);
  }
  return (0, import_assignWith.default)({}, snapshot, value, (objValue, srcValue) => {
    return typeof srcValue === "undefined" ? objValue : srcValue;
  });
};
var INCLUDE_FIELDS_QUERY = ["_id", "_rev", "_type"];
var INCLUDE_FIELDS = [...INCLUDE_FIELDS_QUERY, "_key"];
var AVAILABILITY_READABLE = { available: true, reason: "READABLE" };
var AVAILABILITY_PERMISSION_DENIED = { available: false, reason: "PERMISSION_DENIED" };
var AVAILABILITY_NOT_FOUND = { available: false, reason: "NOT_FOUND" };
var INVALID_PREVIEW_FALLBACK = { title: "Invalid preview config", subtitle: "Check the error log in the console", media: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) };
function isPortableTextPreviewValue(value) {
  return Array.isArray(value) && (value.length === 0 || value.some(isPortableTextTextBlock));
}
function extractTextFromBlocks(blocks2) {
  const firstBlock = Array.isArray(blocks2) && blocks2.find(isPortableTextTextBlock);
  if (!firstBlock || !firstBlock.children) {
    return "";
  }
  return firstBlock.children.filter(isPortableTextSpan).map((span) => span.text).join("");
}
function keysOf(value) {
  return Object.keys(value);
}
var PRESERVE_KEYS2 = ["_id", "_type", "_upload", "_createdAt", "_updatedAt"];
var EMPTY2 = [];
var errorCollector = (() => {
  let errorsByType = {};
  return { add: (type, value, error2) => {
    if (!errorsByType[type.name]) {
      errorsByType[type.name] = [];
    }
    errorsByType[type.name].push({ error: error2, type, value });
  }, getAll() {
    return errorsByType;
  }, clear() {
    errorsByType = {};
  } };
})();
var reportErrors = (0, import_debounce2.default)(() => {
  const errorsByType = errorCollector.getAll();
  const uniqueErrors = (0, import_flatten5.default)(Object.keys(errorsByType).map((typeName) => {
    const entries = errorsByType[typeName];
    return (0, import_uniqBy2.default)(entries, (entry) => entry.error.message);
  }));
  const errorCount = uniqueErrors.length;
  if (errorCount === 0) {
    return;
  }
  console.groupCollapsed("%cHeads up! Got ".concat(errorCount === 1 ? "error" : "".concat(errorCount, " errors"), " while preparing data for preview. Click for details."), "color: #ff7e7c");
  Object.keys(errorsByType).forEach((typeName) => {
    const entries = errorsByType[typeName];
    const first2 = entries[0];
    console.group('Check the preview config for schema type "'.concat(typeName, '": %o'), first2.type.preview);
    const uniqued = (0, import_uniqBy2.default)(entries, (entry) => entry.error.message);
    uniqued.forEach((entry) => {
      var _a4;
      if (entry.error.type === "returnValueError") {
        const hasPrepare = typeof ((_a4 = entry.type.preview) == null ? void 0 : _a4.prepare) === "function";
        const { value, error: error2 } = entry;
        console.log("Encountered an invalid ".concat(hasPrepare ? "return value when calling prepare(%o)" : "value targeted by preview.select", ":"), value);
        console.error(error2);
      }
      if (entry.error.type === "prepareError") {
        const { value, error: error2 } = entry;
        console.log("Encountered an error when calling prepare(%o):", value);
        console.error(error2);
      }
    });
    console.groupEnd();
  });
  console.groupEnd();
  errorCollector.clear();
}, 1e3);
var isRenderable = (fieldName) => (value) => {
  const type = typeof value;
  if (value === null || type === "undefined" || type === "string" || type === "number" || type === "boolean") {
    return EMPTY2;
  }
  return [assignType("returnValueError", new Error('The "'.concat(fieldName, '" field should be a string, number, boolean, undefined or null, instead saw ').concat(inspect2(value))))];
};
var FIELD_NAME_VALIDATORS = { media: () => {
  return EMPTY2;
}, title: isRenderable("title"), subtitle: isRenderable("subtitle"), description: isRenderable("description"), imageUrl: isRenderable("imageUrl"), date: isRenderable("date") };
function inspect2(val) {
  let prefixType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (isRecord$4(val)) {
    const keys = Object.keys(val);
    const ellipse = keys.length > 3 ? "..." : "";
    const prefix = "object with keys ";
    return "".concat(prefixType ? prefix : "", "{").concat(keys.slice(0, 3).join(", ")).concat(ellipse, "}");
  }
  if (Array.isArray(val)) {
    const ellipse = val.length > 3 ? "..." : "";
    const prefix = "array with ";
    return "".concat(prefixType ? prefix : "", "[").concat(val.map((v) => inspect2(v, false))).concat(ellipse, "]");
  }
  return "the ".concat(typeof val, " ").concat(val);
}
function validateFieldValue(fieldName, fieldValue) {
  if (typeof fieldValue === "undefined") {
    return EMPTY2;
  }
  const validator = FIELD_NAME_VALIDATORS[fieldName];
  return validator && validator(fieldValue) || EMPTY2;
}
function assignType(type, error2) {
  return Object.assign(error2, { type });
}
function validatePreparedValue(preparedValue) {
  if (!(0, import_isPlainObject5.default)(preparedValue) || preparedValue === null) {
    return [assignType("returnValueError", new Error("Invalid return value. Expected a plain object with at least a 'title' field, instead saw ".concat(inspect2(preparedValue))))];
  }
  return Object.entries(preparedValue).reduce((acc, _ref264) => {
    let [fieldName, fieldValue] = _ref264;
    return [...acc, ...validateFieldValue(fieldName, fieldValue)];
  }, EMPTY2);
}
function validateReturnedPreview(result) {
  return { ...result, errors: [...result.errors || [], ...validatePreparedValue(result.returnValue)] };
}
function defaultPrepare(value) {
  return keysOf(value).reduce((acc, fieldName) => {
    const val = value[fieldName];
    return { ...acc, [fieldName]: isPortableTextPreviewValue(val) ? extractTextFromBlocks(val) : val };
  }, {});
}
function invokePrepare(type, value) {
  let viewOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _a4;
  const prepare2 = (_a4 = type.preview) == null ? void 0 : _a4.prepare;
  try {
    return { returnValue: prepare2 ? prepare2(value, viewOptions) : defaultPrepare(value), errors: EMPTY2 };
  } catch (error2) {
    return { returnValue: null, errors: [assignType("prepareError", error2)] };
  }
}
function withErrors(result, type, selectedValue) {
  result.errors.forEach((error2) => errorCollector.add(type, selectedValue, error2));
  reportErrors();
  return INVALID_PREVIEW_FALLBACK;
}
function hasEnumListOptions(type) {
  const options = type.options && typeof type.options === "object" ? type.options : false;
  if (!options || !("list" in options)) {
    return false;
  }
  const listOptions = options.list;
  return Array.isArray(listOptions);
}
function getListOptions(type) {
  if (!hasEnumListOptions(type)) {
    return void 0;
  }
  const listOptions = type.options.list;
  return listOptions.map((option) => isTitledListValue(option) ? option : { title: option, value: option });
}
function prepareForPreview(rawValue, type) {
  let viewOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _a4, _b4;
  const hasCustomPrepare = typeof ((_a4 = type.preview) == null ? void 0 : _a4.prepare) === "function";
  const selection = ((_b4 = type.preview) == null ? void 0 : _b4.select) || {};
  const targetKeys = Object.keys(selection);
  const selectedValue = targetKeys.reduce((acc, key2) => {
    var _a22;
    const typeWithFields = "fields" in type ? type : null;
    const targetFieldName = selection[key2];
    const valueField = (_a22 = typeWithFields == null ? void 0 : typeWithFields.fields) == null ? void 0 : _a22.find((f) => f.name === targetFieldName);
    const listOptions = valueField && getListOptions(valueField.type);
    if (!hasCustomPrepare && listOptions) {
      const selectedOption = listOptions && listOptions.find((opt) => opt.value === (0, import_get3.default)(rawValue, selection[key2]));
      acc[key2] = selectedOption ? selectedOption.value : (0, import_get3.default)(rawValue, selection[key2]);
    } else {
      acc[key2] = (0, import_get3.default)(rawValue, selection[key2]);
    }
    return acc;
  }, {});
  const prepareResult = invokePrepare(type, selectedValue, viewOptions);
  if (prepareResult.errors.length > 0) {
    return withErrors(prepareResult, type, selectedValue);
  }
  const returnValueResult = validateReturnedPreview(invokePrepare(type, selectedValue, viewOptions));
  return returnValueResult.errors.length > 0 ? withErrors(returnValueResult, type, selectedValue) : { ...(0, import_pick3.default)(rawValue, PRESERVE_KEYS2), ...prepareResult.returnValue };
}
function debounceCollect(fn, wait) {
  let timer2;
  let queue = {};
  let idx = 0;
  return function debounced() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return new Observable((obs) => {
      clearTimeout(timer2);
      timer2 = setTimeout(flush, wait);
      const queueItem = { args, observer: obs, completed: false };
      const id4 = idx++;
      queue[id4] = queueItem;
      return () => {
        queueItem.completed = true;
      };
    });
  };
  function flush() {
    const currentlyFlushingQueue = queue;
    queue = {};
    const queueItemIds = Object.keys(currentlyFlushingQueue).filter((id4) => {
      const queueItem = currentlyFlushingQueue[id4];
      return queueItem && !queueItem.completed;
    });
    if (queueItemIds.length === 0) {
      return;
    }
    const collectedArgs = queueItemIds.map((id4) => {
      const queueItem = currentlyFlushingQueue[id4];
      return queueItem && queueItem.args;
    }).filter(isNonNullable$3);
    fn(collectedArgs).subscribe({ next(results) {
      results.forEach((result, i) => {
        const queueItem = currentlyFlushingQueue[queueItemIds[i]];
        if (queueItem && !queueItem.completed) {
          queueItem.observer.next(results[i]);
        }
      });
    }, complete() {
      queueItemIds.forEach((id4) => {
        const entry = currentlyFlushingQueue[id4];
        if (entry && !entry.completed) {
          entry.observer.complete();
        }
      });
    }, error(err) {
      queueItemIds.forEach((id4) => {
        const entry = currentlyFlushingQueue[id4];
        if (entry && !entry.completed) {
          entry.observer.error(err);
        }
      });
    } });
  }
}
var MAX_DOCUMENT_ID_CHUNK_SIZE = 11164;
function chunkDocumentIds(documentIds) {
  let chunk = [];
  let chunkSize = 0;
  const chunks = [];
  for (const documentId of documentIds) {
    if (chunkSize + documentId.length + 1 >= MAX_DOCUMENT_ID_CHUNK_SIZE) {
      chunks.push(chunk);
      chunk = [];
      chunkSize = 0;
    }
    chunkSize += documentId.length + 1;
    chunk.push(documentId);
  }
  if (!chunks.includes(chunk)) {
    chunks.push(chunk);
  }
  return chunks;
}
function mutConcat(array3, chunks) {
  array3.push(...chunks);
  return array3;
}
function create_preview_availability(versionedClient, observePaths2) {
  function observeDocumentPairAvailability(id4) {
    const draftId = getDraftId(id4);
    const publishedId = getPublishedId(id4);
    return combineLatest([observeDocumentAvailability(draftId), observeDocumentAvailability(publishedId)]).pipe(distinctUntilChanged(import_shallow_equals.default), map((_ref265) => {
      let [draftReadability, publishedReadability] = _ref265;
      return { draft: draftReadability, published: publishedReadability };
    }));
  }
  function observeDocumentAvailability(id4) {
    return observePaths2({ _ref: id4 }, [["_rev"]]).pipe(map((res) => isRecord$4(res) && Boolean("_rev" in res && (res == null ? void 0 : res._rev))), distinctUntilChanged(), switchMap((hasRev) => {
      return hasRev ? (
        // short circuit: if we can read the _rev field we know it both exists and is readable
        of(AVAILABILITY_READABLE)
      ) : (
        // we can't read the _rev field for two possible reasons: 1) the document isn't readable or 2) the document doesn't exist
        fetchDocumentReadability(id4)
      );
    }));
  }
  const fetchDocumentReadability = debounceCollect(function fetchDocumentReadability2(args) {
    const uniqueIds = [...new Set((0, import_flatten5.default)(args))];
    return from(chunkDocumentIds(uniqueIds)).pipe(mergeMap(fetchDocumentReadabilityChunked, 10), reduce(mutConcat, []), map((res) => args.map((_ref266) => {
      let [id4] = _ref266;
      return res[uniqueIds.indexOf(id4)];
    })));
  }, 1);
  function fetchDocumentReadabilityChunked(ids) {
    return defer(() => {
      const requestOptions2 = { uri: versionedClient.getDataUrl("doc", ids.join(",")), json: true, query: { excludeContent: "true" }, tag: "preview.documents-availability" };
      return versionedClient.observable.request(requestOptions2).pipe(map((response) => {
        const omitted = (0, import_keyBy.default)(response.omitted || [], (entry) => entry.id);
        return ids.map((id4) => {
          const omittedEntry = omitted[id4];
          if (!omittedEntry) {
            return AVAILABILITY_READABLE;
          }
          if (omittedEntry.reason === "existence") {
            return AVAILABILITY_NOT_FOUND;
          }
          if (omittedEntry.reason === "permission") {
            return AVAILABILITY_PERMISSION_DENIED;
          }
          throw new Error('Unexpected reason for omission: "'.concat(omittedEntry.reason, '"'));
        });
      }));
    });
  }
  return { observeDocumentPairAvailability };
}
function setKey(source, key2, value) {
  return { ...source, [key2]: value };
}
function props() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return (source) => {
    return new Observable((observer) => source.subscribe(observer)).pipe(switchMap((object2) => {
      const keyObservables = keysOf(object2).map((key2) => {
        const value = object2[key2];
        return isObservable(value) ? from(value).pipe(map((val) => [key2, val])) : of([key2, value]);
      });
      return options.wait ? combineLatest(keyObservables).pipe(map((pairs) => pairs.reduce((acc, _ref267) => {
        let [key2, value] = _ref267;
        return setKey(acc, key2, value);
      }, {}))) : from(keyObservables).pipe(mergeAll(), scan((acc, _ref268) => {
        let [key2, value] = _ref268;
        return setKey(acc, key2, value);
      }, {}));
    }));
  };
}
function createEmpty(fields) {
  return fields.reduce((result, field) => {
    result[field] = void 0;
    return result;
  }, {});
}
function resolveMissingHeads(value, paths) {
  return paths.filter((path2) => !(path2[0] in value));
}
function getDocumentId(value) {
  if (isReference(value)) {
    return value._ref;
  }
  return "_id" in value ? value._id : void 0;
}
function observePaths(value, paths, observeFields, apiConfig) {
  if (!value || typeof value !== "object") {
    return of(value);
  }
  const id4 = getDocumentId(value);
  const currentValue = id4 ? { ...value, _id: id4 } : { ...value };
  if (currentValue._type === "reference") {
    delete currentValue._type;
    delete currentValue._ref;
    delete currentValue._weak;
    delete currentValue._dataset;
    delete currentValue._projectId;
    delete currentValue._strengthenOnPublish;
  }
  const pathsWithMissingHeads = resolveMissingHeads(currentValue, paths);
  if (id4 && pathsWithMissingHeads.length > 0) {
    const nextHeads = (0, import_uniq4.default)(pathsWithMissingHeads.map((path2) => path2[0]));
    const refApiConfig = isCrossDatasetReference(value) ? { projectId: value._projectId, dataset: value._dataset } : apiConfig;
    return observeFields(id4, nextHeads, refApiConfig).pipe(switchMap((snapshot) => {
      if (snapshot === null) {
        return of(null);
      }
      return observePaths({ ...createEmpty(nextHeads), ...isReference(value) ? { ...value, ...refApiConfig } : value, ...snapshot }, paths, observeFields, refApiConfig);
    }));
  }
  const leads = {};
  paths.forEach((path2) => {
    const [head, ...tail] = path2;
    if (!leads[head]) {
      leads[head] = [];
    }
    leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter((tail) => tail.length > 0);
    if (tails.length === 0) {
      res[head] = isRecord$4(value) ? value[head] : void 0;
    } else {
      res[head] = observePaths(value[head], tails, observeFields, apiConfig);
    }
    return res;
  }, currentValue);
  return of(next).pipe(props({ wait: true }));
}
function normalizePaths(path2) {
  return path2.map((segment) => typeof segment === "string" ? segment.split(".") : segment);
}
function createPathObserver(context) {
  const { observeFields } = context;
  return { observePaths(value, paths, apiConfig) {
    return observePaths(value, normalizePaths(paths), observeFields, apiConfig);
  } };
}
function isRecord$14(value) {
  return (0, import_isPlainObject5.default)(value);
}
function isReference3(value) {
  return (0, import_isPlainObject5.default)(value);
}
function createPreviewObserver(context) {
  const { observeDocumentTypeFromId, observePaths: observePaths2 } = context;
  return function observeForPreview(value, type, viewOptions, apiConfig) {
    if (isCrossDatasetReferenceSchemaType(type)) {
      if (!isCrossDatasetReference(value)) {
        return of({ snapshot: void 0 });
      }
      const refApiConfig = { projectId: value._projectId, dataset: value._dataset };
      return observeDocumentTypeFromId(value._ref, refApiConfig).pipe(switchMap((typeName) => {
        if (typeName) {
          const refType = type.to.find((toType) => toType.type === typeName);
          return observeForPreview(value, refType, {}, refApiConfig);
        }
        return of({ snapshot: void 0 });
      }));
    }
    if (isReferenceSchemaType(type)) {
      if (!isReference3(value)) {
        return of({ snapshot: void 0 });
      }
      return observeDocumentTypeFromId(value._ref).pipe(switchMap((typeName) => {
        if (typeName) {
          const refType = type.to.find((toType) => toType.name === typeName);
          return observeForPreview(value, refType);
        }
        return of({ snapshot: void 0 });
      }));
    }
    const paths = getPreviewPaths(type.preview);
    if (paths) {
      return observePaths2(value, paths, apiConfig).pipe(map((snapshot) => ({ type, snapshot: snapshot && prepareForPreview(snapshot, type, viewOptions) })));
    }
    return of({ type, snapshot: value && isRecord$14(value) ? invokePrepare(type, value, viewOptions).returnValue : null });
  };
}
function create_preview_documentPair(versionedClient, observePaths2) {
  const { observeDocumentPairAvailability } = create_preview_availability(versionedClient, observePaths2);
  const ALWAYS_INCLUDED_SNAPSHOT_PATHS = [["_updatedAt"], ["_createdAt"], ["_type"]];
  return { observePathsDocumentPair };
  function observePathsDocumentPair(id4, paths) {
    const { draftId, publishedId } = getIdPair(id4);
    return observeDocumentPairAvailability(draftId).pipe(switchMap((availability) => {
      if (!availability.draft.available && !availability.published.available) {
        return of({ id: publishedId, type: null, draft: { availability: availability.draft, snapshot: void 0 }, published: { availability: availability.published, snapshot: void 0 } });
      }
      const snapshotPaths = [...paths, ...ALWAYS_INCLUDED_SNAPSHOT_PATHS];
      return combineLatest([observePaths2({ _type: "reference", _ref: draftId }, snapshotPaths), observePaths2({ _type: "reference", _ref: publishedId }, snapshotPaths)]).pipe(map((_ref269) => {
        let [draftSnapshot, publishedSnapshot] = _ref269;
        const type = isRecord$4(draftSnapshot) && "_type" in draftSnapshot && draftSnapshot._type || isRecord$4(publishedSnapshot) && "_type" in publishedSnapshot && publishedSnapshot._type || null;
        return { id: publishedId, type: typeof type === "string" ? type : null, draft: { availability: availability.draft, snapshot: draftSnapshot }, published: { availability: availability.published, snapshot: publishedSnapshot } };
      }));
    }));
  }
}
function combineSelections(selections) {
  return (0, import_values.default)(selections.reduce((output, _ref270, index) => {
    let [id4, fields] = _ref270;
    const key2 = (0, import_sortBy.default)(fields.join(","), import_identity2.default).join(".");
    if (!output[key2]) {
      output[key2] = { fields, ids: [], map: [] };
    }
    const idx = output[key2].ids.length;
    output[key2].ids[idx] = id4;
    output[key2].map[idx] = index;
    return output;
  }, {}));
}
function stringifyId(id4) {
  return JSON.stringify(id4);
}
var maybeEscape = (fieldName) => fieldNeedsEscape(fieldName) ? '"'.concat(fieldName, '": @').concat(escapeField(fieldName)) : fieldName;
function toSubQuery(_ref271) {
  let { ids, fields } = _ref271;
  const allFields = [...INCLUDE_FIELDS_QUERY, ...fields];
  return "*[_id in [".concat(ids.map(stringifyId).join(","), "]][0...").concat(ids.length, "]{").concat(allFields.map(maybeEscape).join(","), "}");
}
function toQuery(combinedSelections) {
  return "[".concat(combinedSelections.map(toSubQuery).join(","), "][0...").concat(combinedSelections.length, "]");
}
function reassemble(queryResult, combinedSelections) {
  return queryResult.reduce((reprojected, subResult, index) => {
    const map3 = combinedSelections[index].map;
    map3.forEach((resultIdx, i) => {
      const id4 = combinedSelections[index].ids[i];
      const found = subResult.find((doc) => doc._id === id4);
      reprojected[resultIdx] = found || null;
    });
    return reprojected;
  }, []);
}
function hasEqualFields(fields) {
  return (object2, otherObject) => {
    if (object2 === otherObject) {
      return true;
    }
    if (!object2 || !otherObject) {
      return false;
    }
    if (typeof object2 !== "object" || typeof otherObject !== "object") {
      return false;
    }
    return fields.every((field) => object2[field] === otherObject[field]);
  };
}
var id3 = (value) => value;
function isUniqueBy(array3) {
  let itemSelector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : id3;
  let prevItem;
  let currItem;
  for (let i = 0; i < array3.length; i++) {
    if (i === 0) {
      prevItem = itemSelector(array3[i]);
      continue;
    }
    currItem = itemSelector(array3[i]);
    if (prevItem !== currItem) {
      return false;
    }
    prevItem = currItem;
  }
  return true;
}
function create_preview_observeFields(context) {
  const { observePaths: observePaths2, versionedClient } = context;
  let _globalListener;
  const getGlobalEvents = () => {
    if (!_globalListener) {
      const allEvents$ = from(versionedClient.listen('*[!(_id in path("_.**"))]', {}, { events: ["welcome", "mutation"], includeResult: false, visibility: "query", tag: "preview.global" })).pipe(share());
      const welcome$ = allEvents$.pipe(filter((event) => event.type === "welcome"), shareReplay({ refCount: true, bufferSize: 1 }));
      welcome$.subscribe();
      const mutations$ = allEvents$.pipe(filter((event) => event.type === "mutation"));
      _globalListener = { welcome$, mutations$ };
    }
    return _globalListener;
  };
  function listen2(id4) {
    const globalEvents = getGlobalEvents();
    return merge(globalEvents.welcome$, globalEvents.mutations$.pipe(filter((event) => event.documentId === id4)));
  }
  function fetchAllDocumentPathsWith(client) {
    return function fetchAllDocumentPath(selections) {
      const combinedSelections = combineSelections(selections);
      return client.observable.fetch(toQuery(combinedSelections), {}, { tag: "preview.document-paths" }).pipe(map((result) => reassemble(result, combinedSelections)));
    };
  }
  const fetchDocumentPathsFast = debounceCollect(fetchAllDocumentPathsWith(versionedClient), 100);
  const fetchDocumentPathsSlow = debounceCollect(fetchAllDocumentPathsWith(versionedClient), 1e3);
  function currentDatasetListenFields(id4, fields) {
    return listen2(id4).pipe(switchMap((event) => {
      if (event.type === "welcome" || event.visibility === "query") {
        return fetchDocumentPathsFast(id4, fields).pipe(mergeMap((result) => {
          return concat(of(result), result === void 0 ? (
            // just been created and is not yet indexed. We therefore need to wait a bit
            // and then re-fetch.
            fetchDocumentPathsSlow(id4, fields)
          ) : []);
        }));
      }
      return fetchDocumentPathsSlow(id4, fields);
    }));
  }
  const CACHE = {};
  const getBatchFetcherForDataset = (0, import_memoize.default)(function getBatchFetcherForDataset2(apiConfig) {
    const client = versionedClient.withConfig(apiConfig);
    const fetchAll = fetchAllDocumentPathsWith(client);
    return debounceCollect(fetchAll, 10);
  }, (apiConfig) => apiConfig.dataset + apiConfig.projectId);
  const CROSS_DATASET_PREVIEW_POLL_INTERVAL = 1e4;
  const visiblePoll$ = fromEvent(document, "visibilitychange").pipe(startWith(0), map(() => document.visibilityState === "visible"), switchMap((visible) => visible ? timer(0, CROSS_DATASET_PREVIEW_POLL_INTERVAL) : EMPTY), share());
  function crossDatasetListenFields(id4, fields, apiConfig) {
    return visiblePoll$.pipe(startWith(0)).pipe(switchMap(() => {
      const batchFetcher = getBatchFetcherForDataset(apiConfig);
      return batchFetcher(id4, fields);
    }));
  }
  function createCachedFieldObserver(id4, fields, apiConfig) {
    let latest = null;
    const changes$ = merge(defer(() => latest === null ? EMPTY : of(latest)), apiConfig ? crossDatasetListenFields(id4, fields, apiConfig) : currentDatasetListenFields(id4, fields)).pipe(tap((v) => latest = v), shareReplay({ refCount: true, bufferSize: 1 }));
    return { id: id4, fields, changes$ };
  }
  function cachedObserveFields(id4, fields, apiConfig) {
    const cacheKey = apiConfig ? "".concat(apiConfig.projectId, ":").concat(apiConfig.dataset, ":").concat(id4) : "$current$-".concat(id4);
    if (!(cacheKey in CACHE)) {
      CACHE[cacheKey] = [];
    }
    const existingObservers = CACHE[cacheKey];
    const missingFields = (0, import_difference3.default)(fields, (0, import_flatten5.default)(existingObservers.map((cachedFieldObserver) => cachedFieldObserver.fields)));
    if (missingFields.length > 0) {
      existingObservers.push(createCachedFieldObserver(id4, fields, apiConfig));
    }
    const cachedFieldObservers = existingObservers.filter((observer) => observer.fields.some((fieldName) => fields.includes(fieldName))).map((cached) => cached.changes$);
    return combineLatest(cachedFieldObservers).pipe(
      // in the event that a document gets deleted, the cached values will be updated to store `undefined`
      // if this happens, we should not pick any fields from it, but rather just return null
      map((snapshots) => snapshots.filter(Boolean)),
      // make sure all snapshots agree on same revision
      filter((snapshots) => isUniqueBy(snapshots, (snapshot) => snapshot._rev)),
      // pass on value with the requested fields (or null if value is deleted)
      map((snapshots) => snapshots.length === 0 ? null : pickFrom(snapshots, fields)),
      // emit values only if changed
      distinctUntilChanged(hasEqualFields(fields))
    );
  }
  return { observeFields: cachedObserveFields };
  function pickFrom(objects, fields) {
    return [...INCLUDE_FIELDS, ...fields].reduce((result, fieldName) => {
      const value = getFirstFieldValue(objects, fieldName);
      if (value !== void 0) {
        result[fieldName] = value;
      }
      return result;
    }, {});
  }
  function getFirstFieldValue(objects, fieldName) {
    let value;
    objects.some((object2) => {
      if (fieldName in object2) {
        value = object2[fieldName];
        return true;
      }
      return false;
    });
    return value;
  }
}
function createDocumentPreviewStore(_ref272) {
  let { client } = _ref272;
  const versionedClient = client.withConfig({ apiVersion: "1" });
  const __proxy_observePaths = (value, paths, apiConfig) => {
    return observePaths2(value, paths, apiConfig);
  };
  const { observeFields } = create_preview_observeFields({ observePaths: __proxy_observePaths, versionedClient });
  const { observePaths: observePaths2 } = createPathObserver({ observeFields });
  function observeDocumentTypeFromId(id4, apiConfig) {
    return observePaths2({ _type: "reference", _ref: id4 }, ["_type"], apiConfig).pipe(map((res) => isRecord$4(res) && typeof res._type === "string" ? res._type : void 0), distinctUntilChanged());
  }
  const observeForPreview = createPreviewObserver({ observeDocumentTypeFromId, observePaths: observePaths2 });
  const { observeDocumentPairAvailability } = create_preview_availability(versionedClient, observePaths2);
  const { observePathsDocumentPair } = create_preview_documentPair(versionedClient, observePaths2);
  return {
    observePaths: observePaths2,
    observeForPreview,
    observeDocumentTypeFromId,
    // eslint-disable-next-line camelcase
    unstable_observeDocumentPairAvailability: observeDocumentPairAvailability,
    unstable_observePathsDocumentPair: observePathsDocumentPair
  };
}
var getUpdatedSnapshot = (bufferedDocument) => {
  const LOCAL = bufferedDocument.LOCAL;
  const HEAD = bufferedDocument.document.HEAD;
  if (!LOCAL) {
    return LOCAL;
  }
  return { ...LOCAL, _type: (HEAD || LOCAL)._type, _rev: (HEAD || LOCAL)._rev, _updatedAt: (/* @__PURE__ */ new Date()).toISOString() };
};
var toSnapshotEvent = (document2) => ({ type: "snapshot", document: document2 });
var getDocument = (event) => event.document;
var createObservableBufferedDocument = (listenerEvent$) => {
  const actions$ = new Subject();
  const consistency$ = new BehaviorSubject(true);
  const mutations$ = new Subject();
  const rebase$ = new Subject();
  const remoteMutations = new Subject();
  const commitRequests = new Subject();
  const createInitialBufferedDocument = (initialSnapshot) => {
    const bufferedDocument = new BufferedDocument(initialSnapshot);
    bufferedDocument.onMutation = (_ref273) => {
      let { mutation, remote } = _ref273;
      mutations$.next({ type: "mutation", document: getUpdatedSnapshot(bufferedDocument), mutations: mutation.mutations, origin: remote ? "remote" : "local" });
    };
    bufferedDocument.onRemoteMutation = (mutation) => {
      remoteMutations.next({ type: "remoteMutation", head: bufferedDocument.document.HEAD, transactionId: mutation.transactionId, timestamp: mutation.timestamp, author: mutation.identity, effects: mutation.effects });
    };
    bufferedDocument.onRebase = (edge, nextRemoteMutations, localMutations) => {
      rebase$.next({ type: "rebase", document: edge, remoteMutations: nextRemoteMutations, localMutations });
    };
    bufferedDocument.onConsistencyChanged = (isConsistent) => {
      consistency$.next(isConsistent);
    };
    bufferedDocument.commitHandler = (commitArg) => commitRequests.next(commitArg);
    return bufferedDocument;
  };
  const currentBufferedDocument$ = listenerEvent$.pipe(scan((bufferedDocument, listenerEvent) => {
    if (listenerEvent.type === "snapshot") {
      if (bufferedDocument) {
        bufferedDocument.commit();
      }
      return createInitialBufferedDocument(listenerEvent.document || null);
    }
    if (bufferedDocument === null) {
      console.warn('Ignoring event of type "%s" since buffered document has not yet been set up with snapshot', listenerEvent.type);
      return null;
    }
    return bufferedDocument;
  }, null), filter((bufferedDocument) => bufferedDocument !== null), distinctUntilChanged(), publishReplay(1), refCount());
  const snapshotAfterSync$ = listenerEvent$.pipe(filter((ev) => ev.type === "mutation"), withLatestFrom(currentBufferedDocument$), map((_ref274) => {
    let [mutationEvent, bufferedDocument] = _ref274;
    bufferedDocument.arrive(new Mutation(mutationEvent));
    return getUpdatedSnapshot(bufferedDocument);
  }));
  const actionHandler$ = actions$.pipe(
    withLatestFrom(currentBufferedDocument$),
    tap((_ref275) => {
      let [action, bufferedDocument] = _ref275;
      if (action.type === "mutation") {
        bufferedDocument.add(new Mutation({ mutations: action.mutations }));
      }
      if (action.type === "commit") {
        bufferedDocument.commit();
      }
    }),
    // We subscribe to this only for the side effects
    mergeMapTo(EMPTY),
    share()
  );
  const emitAction = (action) => actions$.next(action);
  const addMutations = (mutations) => emitAction({ type: "mutation", mutations });
  const addMutation = (mutation) => addMutations([mutation]);
  const commit2 = () => {
    currentBufferedDocument$.pipe(take(1), tap((bufferedDocument) => bufferedDocument.commit())).subscribe();
  };
  const snapshot$ = merge(currentBufferedDocument$.pipe(map((bufferedDocument) => bufferedDocument.LOCAL)), mutations$.pipe(map(getDocument)), rebase$.pipe(map(getDocument)), snapshotAfterSync$).pipe(map(toSnapshotEvent), publishReplay(1), refCount());
  const remoteSnapshot$ = merge(currentBufferedDocument$.pipe(map((bufferedDocument) => bufferedDocument.document.HEAD), map(toSnapshotEvent)), remoteMutations).pipe(publishReplay(1), refCount());
  return { updates$: merge(snapshot$, actionHandler$, mutations$, rebase$), consistency$: consistency$.pipe(distinctUntilChanged(), publishReplay(1), refCount()), remoteSnapshot$, commitRequest$: commitRequests, addMutation, addMutations, commit: commit2 };
};
var prepare = (id4) => (document2) => {
  const { _id, _rev, _updatedAt, ...rest } = document2;
  return { _id: id4, ...rest };
};
var createBufferedDocument = (documentId, listenerEvent$) => {
  const bufferedDocument = createObservableBufferedDocument(listenerEvent$);
  const prepareDoc = prepare(documentId);
  const DELETE = { delete: { id: documentId } };
  return { events: bufferedDocument.updates$, consistency$: bufferedDocument.consistency$, remoteSnapshot$: bufferedDocument.remoteSnapshot$, commitRequest$: bufferedDocument.commitRequest$, patch: (patches) => patches.map((patch2) => ({ patch: { ...patch2, id: documentId } })), create: (document2) => ({ create: prepareDoc(document2) }), createIfNotExists: (document2) => ({ createIfNotExists: prepareDoc(document2) }), createOrReplace: (document2) => ({ createOrReplace: prepareDoc(document2) }), delete: () => DELETE, mutate: (mutations) => bufferedDocument.addMutations(mutations), commit: () => bufferedDocument.commit() };
};
var PENDING_START = { type: "pending", phase: "begin" };
var PENDING_END = { type: "pending", phase: "end" };
function isMutationEvent(msg2) {
  return msg2.type === "mutation";
}
function isMultiTransactionEvent(msg2) {
  return msg2.transactionTotalEvents > 1;
}
function allPendingTransactionEventsReceived(listenerEvents) {
  const groupedMutations = (0, import_groupBy.default)(listenerEvents.filter((ev) => ev.type === "mutation"), (e2) => e2.transactionId);
  return Object.values(groupedMutations).every((mutations) => mutations.length === mutations[0].transactionTotalEvents);
}
function getPairListener(client, idPair) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const { publishedId, draftId } = idPair;
  return defer(() => client.observable.listen("*[_id == $publishedId || _id == $draftId]", { publishedId, draftId }, { includeResult: false, events: ["welcome", "mutation", "reconnect"], effectFormat: "mendoza", tag: options.tag || "document.pair-listener" })).pipe(
    concatMap((event) => event.type === "welcome" ? fetchInitialDocumentSnapshots().pipe(concatMap((snapshots) => [createSnapshotEvent(draftId, snapshots.draft), createSnapshotEvent(publishedId, snapshots.published)])) : of(event)),
    scan((acc, msg2) => {
      if (!isMutationEvent(msg2)) {
        return { next: [msg2], buffer: [] };
      }
      const isBuffering = acc.buffer.length > 0;
      const isMulti = isMultiTransactionEvent(msg2);
      if (!isMulti && !isBuffering) {
        return { next: [msg2], buffer: [] };
      }
      if (!isMulti) {
        return { next: [], buffer: acc.buffer.concat(msg2) };
      }
      const nextBuffer = acc.buffer.concat(msg2);
      if (allPendingTransactionEventsReceived(nextBuffer)) {
        return { next: nextBuffer.concat(PENDING_END), buffer: [] };
      }
      return { next: nextBuffer.length === 1 ? [PENDING_START] : [], buffer: nextBuffer };
    }, { next: [], buffer: [] }),
    // note: this flattens the array, and in the case of an empty array, no event will be pushed downstream
    mergeMap((v) => v.next)
  );
  function fetchInitialDocumentSnapshots() {
    return client.observable.getDocuments([draftId, publishedId], { tag: "document.snapshots" }).pipe(map((_ref276) => {
      let [draft, published] = _ref276;
      return { draft, published };
    }));
  }
}
function createSnapshotEvent(documentId, document2) {
  return { type: "snapshot", documentId, document: document2 };
}
var isMutationEventForDocId = (id4) => (event) => {
  return event.type !== "reconnect" && event.type !== "pending" && event.documentId === id4;
};
function setVersion(version) {
  return (ev) => ({ ...ev, version });
}
function commitMutations(client, mutationParams) {
  const { resultRev, ...mutation } = mutationParams;
  return client.dataRequest("mutate", mutation, {
    visibility: "async",
    returnDocuments: false,
    tag: "document.commit",
    // This makes sure the studio doesn't crash when a draft is crated
    // because someone deleted a referenced document in the target dataset
    skipCrossDatasetReferenceValidation: true
  });
}
function submitCommitRequest(client, request) {
  return from(commitMutations(client, request.mutation.params)).pipe(tap({ error: (error2) => {
    const isBadRequest = "statusCode" in error2 && typeof error2.statusCode === "number" && error2.statusCode >= 400 && error2.statusCode <= 500;
    if (isBadRequest) {
      request.cancel(error2);
    } else {
      request.failure(error2);
    }
  }, next: () => request.success() }));
}
function checkoutPair(client, idPair) {
  const { publishedId, draftId } = idPair;
  const listenerEvents$ = getPairListener(client, idPair).pipe(share());
  const reconnect$ = listenerEvents$.pipe(filter((ev) => ev.type === "reconnect"));
  const draft = createBufferedDocument(draftId, listenerEvents$.pipe(filter(isMutationEventForDocId(draftId))));
  const published = createBufferedDocument(publishedId, listenerEvents$.pipe(filter(isMutationEventForDocId(publishedId))));
  const transactionsPendingEvents$ = listenerEvents$.pipe(filter((ev) => ev.type === "pending"));
  const commits$ = merge(draft.commitRequest$, published.commitRequest$).pipe(mergeMap((commitRequest) => submitCommitRequest(client, commitRequest)), mergeMapTo(EMPTY), share());
  return { transactionsPendingEvents$, draft: { ...draft, events: merge(commits$, reconnect$, draft.events).pipe(map(setVersion("draft"))), consistency$: draft.consistency$, remoteSnapshot$: draft.remoteSnapshot$.pipe(map(setVersion("draft"))) }, published: { ...published, events: merge(commits$, reconnect$, published.events).pipe(map(setVersion("published"))), consistency$: published.consistency$, remoteSnapshot$: published.remoteSnapshot$.pipe(map(setVersion("published"))) } };
}
function memoize(fn, keyGen) {
  const MEMO = /* @__PURE__ */ Object.create(null);
  return function() {
    const key2 = keyGen(...arguments);
    if (!(key2 in MEMO)) {
      MEMO[key2] = fn(...arguments);
    }
    return MEMO[key2];
  };
}
var isLiveEditEnabled = (schema, typeName) => {
  var _a4;
  return ((_a4 = schema.get(typeName)) == null ? void 0 : _a4.liveEdit) === true;
};
function memoizeKeyGen(client, idPair, typeName) {
  var _a4, _b4;
  const config = client.config();
  return "".concat((_a4 = config.dataset) != null ? _a4 : "", "-").concat((_b4 = config.projectId) != null ? _b4 : "", "-").concat(idPair.publishedId, "-").concat(typeName);
}
var memoizedPair = memoize((client, idPair, _typeName) => {
  return new Observable((subscriber) => {
    subscriber.next(checkoutPair(client, idPair));
  }).pipe(publishReplay(1), refCount());
}, memoizeKeyGen);
function isSnapshotEvent(event) {
  return event.type === "snapshot";
}
function withSnapshots(pair) {
  return { snapshots$: pair.events.pipe(filter(isSnapshotEvent), map((event) => event.document), publishReplay(1), refCount()), patch: pair.patch, create: pair.create, createIfNotExists: pair.createIfNotExists, createOrReplace: pair.createOrReplace, delete: pair.delete, mutate: pair.mutate, commit: pair.commit };
}
var snapshotPair = memoize((client, idPair, typeName) => {
  return memoizedPair(client, idPair, typeName).pipe(map((_ref277) => {
    let { published, draft, transactionsPendingEvents$ } = _ref277;
    return { transactionsPendingEvents$, published: withSnapshots(published), draft: withSnapshots(draft) };
  }), publishReplay(1), refCount());
}, (client, idPair, typeName) => {
  var _a4, _b4;
  const config = client.config();
  return "".concat((_a4 = config.dataset) != null ? _a4 : "", "-").concat((_b4 = config.projectId) != null ? _b4 : "", "-").concat(idPair.publishedId, "-").concat(typeName);
});
var LOCKED = { enabled: true };
var NOT_LOCKED = { enabled: false };
var editState = memoize((ctx, idPair, typeName) => {
  const liveEdit = isLiveEditEnabled(ctx.schema, typeName);
  return snapshotPair(ctx.client, idPair, typeName).pipe(switchMap((versions) => combineLatest([versions.draft.snapshots$, versions.published.snapshots$, versions.transactionsPendingEvents$.pipe(map((ev) => ev.phase === "begin" ? LOCKED : NOT_LOCKED), startWith(NOT_LOCKED))])), map((_ref278) => {
    let [draftSnapshot, publishedSnapshot, transactionSyncLock] = _ref278;
    return { id: idPair.publishedId, type: typeName, draft: draftSnapshot, published: publishedSnapshot, liveEdit, ready: true, transactionSyncLock };
  }), startWith({ id: idPair.publishedId, type: typeName, draft: null, published: null, liveEdit, ready: false, transactionSyncLock: null }), publishReplay(1), refCount());
}, (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName));
var operationArgs = memoize((ctx, idPair, typeName) => {
  return snapshotPair(ctx.client, idPair, typeName).pipe(switchMap((versions) => combineLatest([versions.draft.snapshots$, versions.published.snapshots$]).pipe(map((_ref279) => {
    let [draft, published] = _ref279;
    return { ...ctx, idPair, typeName, snapshots: { draft, published }, draft: versions.draft, published: versions.published };
  }))), publishReplay(1), refCount());
}, (ctx, idPair, typeName) => {
  var _a4, _b4;
  const config = ctx.client.config();
  return "".concat((_a4 = config.dataset) != null ? _a4 : "", "-").concat((_b4 = config.projectId) != null ? _b4 : "", "-").concat(idPair.publishedId, "-").concat(typeName);
});
var del = { disabled: (_ref280) => {
  let { snapshots } = _ref280;
  return snapshots.draft || snapshots.published ? false : "NOTHING_TO_DELETE";
}, execute: (_ref281) => {
  let { client, schema, idPair, typeName } = _ref281;
  const tx = client.observable.transaction().delete(idPair.publishedId);
  if (isLiveEditEnabled(schema, typeName)) {
    return tx.commit({ tag: "document.delete" });
  }
  return tx.delete(idPair.draftId).commit({
    tag: "document.delete",
    // this disables referential integrity for cross-dataset references. we
    // have this set because we warn against deletes in the `ConfirmDeleteDialog`
    // UI. This operation is run when "delete anyway" is clicked
    skipCrossDatasetReferenceValidation: true
  });
} };
function strengthenOnPublish(obj) {
  if (isReference(obj)) {
    if (obj._strengthenOnPublish) {
      return (0, import_omit4.default)(obj, ["_strengthenOnPublish"].concat(obj._strengthenOnPublish.weak ? [] : ["_weak"]));
    }
    return obj;
  }
  if (typeof obj !== "object" || !obj)
    return obj;
  if (Array.isArray(obj))
    return obj.map(strengthenOnPublish);
  return Object.fromEntries(Object.entries(obj).map((_ref282) => {
    let [key2, value] = _ref282;
    return [key2, strengthenOnPublish(value)];
  }));
}
var publish = { disabled: (_ref283) => {
  let { schema, typeName, snapshots } = _ref283;
  if (isLiveEditEnabled(schema, typeName)) {
    return "LIVE_EDIT_ENABLED";
  }
  if (!snapshots.draft) {
    return snapshots.published ? "ALREADY_PUBLISHED" : "NO_CHANGES";
  }
  return false;
}, execute: (_ref284) => {
  let { client, idPair, snapshots } = _ref284;
  if (!snapshots.draft) {
    throw new Error('cannot execute "publish" when draft is missing');
  }
  const value = strengthenOnPublish((0, import_omit4.default)(snapshots.draft, "_updatedAt"));
  const tx = client.observable.transaction();
  if (!snapshots.draft) {
    throw new Error('cannot execute "publish" when draft is missing');
  }
  if (snapshots.published) {
    tx.patch(idPair.publishedId, {
      // Hack until other mutations support revision locking
      unset: ["_revision_lock_pseudo_field_"],
      ifRevisionID: snapshots.published._rev
    });
    tx.createOrReplace({ ...value, _id: idPair.publishedId, _type: snapshots.draft._type });
  } else {
    tx.create({ ...value, _id: idPair.publishedId, _type: snapshots.draft._type });
  }
  tx.delete(idPair.draftId);
  return tx.commit({ tag: "document.publish", visibility: "async" });
} };
var patch = { disabled: () => false, execute: function(_ref285) {
  let { schema, snapshots, idPair, draft, published, typeName } = _ref285;
  let patches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let initialDocument = arguments.length > 2 ? arguments[2] : void 0;
  if (isLiveEditEnabled(schema, typeName)) {
    published.mutate([published.createIfNotExists({ _type: typeName, ...initialDocument }), ...published.patch(patches)]);
  } else {
    draft.mutate([draft.createIfNotExists({ ...initialDocument, ...snapshots.published, _id: idPair.draftId, _type: typeName }), ...draft.patch(patches)]);
  }
} };
var commit = { disabled: () => false, execute: (_ref286) => {
  let { draft, published } = _ref286;
  draft.commit();
  published.commit();
  return EMPTY;
} };
var discardChanges = { disabled: (_ref287) => {
  let { snapshots } = _ref287;
  if (!snapshots.draft) {
    return "NO_CHANGES";
  }
  if (!snapshots.published) {
    return "NOT_PUBLISHED";
  }
  return false;
}, execute: (_ref288) => {
  let { client, idPair } = _ref288;
  return client.observable.transaction().delete(idPair.draftId).commit({ tag: "document.discard-changes" });
} };
var unpublish = { disabled: (_ref289) => {
  let { schema, snapshots, typeName } = _ref289;
  if (isLiveEditEnabled(schema, typeName)) {
    return "LIVE_EDIT_ENABLED";
  }
  return snapshots.published ? false : "NOT_PUBLISHED";
}, execute: (_ref290) => {
  let { client, idPair, snapshots } = _ref290;
  let tx = client.observable.transaction().delete(idPair.publishedId);
  if (snapshots.published) {
    tx = tx.createIfNotExists({ ...(0, import_omit4.default)(snapshots.published, "_updatedAt"), _id: idPair.draftId, _type: snapshots.published._type });
  }
  return tx.commit({
    tag: "document.unpublish",
    visibility: "async",
    // this disables referential integrity for cross-dataset references. we
    // have this set because we warn against unpublishes in the `ConfirmDeleteDialog`
    // UI. This operation is run when "unpublish anyway" is clicked
    skipCrossDatasetReferenceValidation: true
  });
} };
var omitProps = ["_createdAt", "_updatedAt"];
var duplicate = { disabled: (_ref291) => {
  let { snapshots } = _ref291;
  return snapshots.published || snapshots.draft ? false : "NOTHING_TO_DUPLICATE";
}, execute: (_ref292, dupeId) => {
  let { schema, client, snapshots, typeName } = _ref292;
  const source = snapshots.draft || snapshots.published;
  if (!source) {
    throw new Error("cannot execute on empty document");
  }
  return client.observable.create({ ...(0, import_omit4.default)(source, omitProps), _id: isLiveEditEnabled(schema, typeName) ? dupeId : getDraftId(dupeId), _type: source._type }, { tag: "document.duplicate" });
} };
var restore$1 = { disabled: () => false, execute: (_ref293, fromRevision) => {
  let { historyStore, schema, idPair, typeName } = _ref293;
  const targetId = isLiveEditEnabled(schema, typeName) ? idPair.publishedId : idPair.draftId;
  return historyStore.restore(idPair.publishedId, targetId, fromRevision);
} };
var consistencyStatus = memoize((client, idPair, typeName) => {
  return memoizedPair(client, idPair, typeName).pipe(switchMap((_ref294) => {
    let { draft, published } = _ref294;
    return combineLatest([draft.consistency$, published.consistency$]);
  }), map((_ref295) => {
    let [draftIsConsistent, publishedIsConsistent] = _ref295;
    return draftIsConsistent && publishedIsConsistent;
  }), distinctUntilChanged(), publishReplay(1), refCount());
}, (client, idPair, typeName) => {
  var _a4, _b4;
  const config = client.config();
  return "".concat((_a4 = config.dataset) != null ? _a4 : "", "-").concat((_b4 = config.projectId) != null ? _b4 : "", "-").concat(idPair.publishedId, "-").concat(typeName);
});
function maybeObservable(v) {
  return typeof v === "undefined" ? of(null) : v;
}
var operationImpls = { del, delete: del, publish, patch, commit, discardChanges, unpublish, duplicate, restore: restore$1 };
var execute = (operationName, operationArguments, extraArgs) => {
  const operation = operationImpls[operationName];
  return defer(() => merge(of(null), maybeObservable(operation.execute(operationArguments, ...extraArgs)))).pipe(last());
};
var operationCalls$ = new Subject();
function emitOperation(operationName, idPair, typeName, extraArgs) {
  operationCalls$.next({ operationName, idPair, typeName, extraArgs });
}
var REQUIRES_CONSISTENCY = ["publish", "unpublish", "discardChanges", "delete"];
var operationEvents = memoize((ctx) => {
  const result$ = operationCalls$.pipe(groupBy((op) => op.idPair.publishedId), mergeMap((groups$) => groups$.pipe(
    // although it might look like a bug, dropping pending async operations here is actually a feature
    // E.g. if the user types `publish` which is async and then starts patching (sync) then the publish
    // should be cancelled
    switchMap((args) => operationArgs(ctx, args.idPair, args.typeName).pipe(take(1), switchMap((operationArguments) => {
      const requiresConsistency = REQUIRES_CONSISTENCY.includes(args.operationName);
      if (requiresConsistency) {
        operationArguments.published.commit();
        operationArguments.draft.commit();
      }
      const isConsistent$ = consistencyStatus(ctx.client, args.idPair, args.typeName).pipe(filter(Boolean));
      const ready$ = requiresConsistency ? isConsistent$.pipe(take(1)) : of(true);
      return ready$.pipe(switchMap(() => execute(args.operationName, operationArguments, args.extraArgs)));
    }), map(() => ({ type: "success", args })), catchError((err) => of({ type: "error", args, error: err }))))
  )), share());
  const AUTOCOMMIT_INTERVAL = 1e3;
  const autoCommit$ = result$.pipe(filter((result) => result.type === "success" && result.args.operationName === "patch"), throttleTime(AUTOCOMMIT_INTERVAL, asyncScheduler, { leading: true, trailing: true }), tap((result) => {
    emitOperation("commit", result.args.idPair, result.args.typeName, []);
  }));
  return merge(result$, autoCommit$.pipe(mergeMapTo(EMPTY)));
}, (ctx) => {
  var _a4, _b4;
  const config = ctx.client.config();
  return "".concat((_a4 = config.dataset) != null ? _a4 : "", "-").concat((_b4 = config.projectId) != null ? _b4 : "");
});
var remoteSnapshots = memoize((client, idPair, typeName) => {
  return memoizedPair(client, idPair, typeName).pipe(switchMap((_ref296) => {
    let { published, draft } = _ref296;
    return merge(published.remoteSnapshot$, draft.remoteSnapshot$);
  }));
}, memoizeKeyGen);
var INITIAL_VALIDATION_STATUS = { isValidating: true, validation: [] };
function findReferenceIds(obj) {
  return (0, import_json_reduce.reduce)(obj, (acc, node) => {
    if (isReference(node)) {
      acc.add(node._ref);
    }
    return acc;
  }, /* @__PURE__ */ new Set());
}
var EMPTY_VALIDATION = [];
var listenDocumentExists = (observeDocumentAvailability, id4) => observeDocumentAvailability(id4).pipe(map((_ref297) => {
  let { published } = _ref297;
  return published.available;
}));
var DOC_UPDATE_DELAY = 200;
var REF_UPDATE_DELAY = 1e3;
function shareLatestWithRefCount() {
  return shareReplay({ bufferSize: 1, refCount: true });
}
var validation = memoize((ctx, _ref298, typeName) => {
  let { draftId, publishedId } = _ref298;
  const document$ = editState(ctx, { draftId, publishedId }, typeName).pipe(map((_ref299) => {
    let { draft, published } = _ref299;
    return draft || published;
  }), throttleTime(DOC_UPDATE_DELAY, asyncScheduler, { trailing: true }), distinctUntilChanged((prev, next) => {
    if ((prev == null ? void 0 : prev._rev) === (next == null ? void 0 : next._rev)) {
      return true;
    }
    return (0, import_shallow_equals.default)((0, import_omit4.default)(prev, "_rev", "_updatedAt"), (0, import_omit4.default)(next, "_rev", "_updatedAt"));
  }), shareLatestWithRefCount());
  const referenceIds$ = document$.pipe(map((document2) => findReferenceIds(document2)), mergeMap((ids) => from(ids)));
  const referenceExistence$ = referenceIds$.pipe(groupBy((id4) => id4, { duration: () => timer(1e3 * 60 * 30) }), mergeMap((id$) => id$.pipe(distinct(), mergeMap((id4) => listenDocumentExists(ctx.observeDocumentPairAvailability, id4).pipe(map(
    // eslint-disable-next-line max-nested-callbacks
    (result) => [id4, result]
  ))))), scan((acc, _ref300) => {
    let [id4, result] = _ref300;
    if (acc[id4] === result) {
      return acc;
    }
    return { ...acc, [id4]: result };
  }, {}), distinctUntilChanged(import_shallow_equals.default), shareLatestWithRefCount());
  const getDocumentExists = (_ref301) => {
    let { id: id4 } = _ref301;
    return lastValueFrom(referenceExistence$.pipe(
      // If the id is not present as key in the `referenceExistence` map it means it's existence status
      // isn't yet loaded, so we want to wait until it is
      first((referenceExistence) => id4 in referenceExistence),
      map((referenceExistence) => referenceExistence[id4])
    ));
  };
  const referenceDocumentUpdates$ = referenceExistence$.pipe(
    // we'll skip the first emission since the document already gets an initial validation pass
    // we're only interested in updates in referenced documents after that
    skip(1),
    throttleTime(REF_UPDATE_DELAY, asyncScheduler, { leading: true, trailing: true })
  );
  return combineLatest([document$, concat(of(null), referenceDocumentUpdates$)]).pipe(map((_ref302) => {
    let [document2] = _ref302;
    return document2;
  }), exhaustMapWithTrailing((document2) => {
    return defer(() => {
      if (!(document2 == null ? void 0 : document2._type)) {
        return of({ validation: EMPTY_VALIDATION, isValidating: false });
      }
      return concat(of({ isValidating: true, revision: document2._rev }), validateDocumentObservable(ctx.getClient, document2, ctx.schema, { getDocumentExists, i18n: ctx.i18n }).pipe(map((validationMarkers) => ({ validation: validationMarkers, isValidating: false }))));
    });
  }), scan((acc, next) => ({ ...acc, ...next }), INITIAL_VALIDATION_STATUS), shareLatestWithRefCount());
}, (ctx, idPair, typeName) => {
  var _a4, _b4;
  const config = ctx.client.config();
  return "".concat((_a4 = config.dataset) != null ? _a4 : "", "-").concat((_b4 = config.projectId) != null ? _b4 : "", "-").concat(idPair.publishedId, "-").concat(typeName);
});
var documentEvents = memoize((client, idPair, typeName) => {
  return memoizedPair(client, idPair, typeName).pipe(switchMap((_ref303) => {
    let { draft, published } = _ref303;
    return merge(draft.events, published.events);
  }));
}, memoizeKeyGen);
function createOperationGuard(opName) {
  return { disabled: "NOT_READY", execute: () => {
    throw new Error("Called ".concat(opName, " before it was ready."));
  } };
}
var GUARDED = { commit: createOperationGuard("commit"), delete: createOperationGuard("delete"), del: createOperationGuard("del"), publish: createOperationGuard("publish"), patch: createOperationGuard("patch"), discardChanges: createOperationGuard("discardChanges"), unpublish: createOperationGuard("unpublish"), duplicate: createOperationGuard("duplicate"), restore: createOperationGuard("restore") };
var createEmitter = (operationName, idPair, typeName) => function() {
  for (var _len6 = arguments.length, executeArgs = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
    executeArgs[_key7] = arguments[_key7];
  }
  return emitOperation(operationName, idPair, typeName, executeArgs);
};
function wrap4(opName, op, operationArgs2) {
  const disabled = op.disabled(operationArgs2);
  return { disabled, execute: createEmitter(opName, operationArgs2.idPair, operationArgs2.typeName) };
}
function createOperationsAPI(args) {
  return { commit: wrap4("commit", commit, args), delete: wrap4("delete", del, args), del: wrap4("delete", del, args), publish: wrap4("publish", publish, args), patch: wrap4("patch", patch, args), discardChanges: wrap4("discardChanges", discardChanges, args), unpublish: wrap4("unpublish", unpublish, args), duplicate: wrap4("duplicate", duplicate, args), restore: wrap4("restore", restore$1, args) };
}
var editOperations = memoize((ctx, idPair, typeName) => {
  const operationEvents$ = operationEvents(ctx);
  const operationArgs$ = operationArgs(ctx, idPair, typeName);
  const operations$ = operationArgs$.pipe(map(createOperationsAPI));
  return concat(of(GUARDED), merge(operationEvents$.pipe(mergeMap(() => EMPTY)), operations$)).pipe(shareReplay({ refCount: true, bufferSize: 1 }));
}, (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName));
var fetch$1 = (client, query, params, options) => defer(() => client.observable.fetch(query, params, { tag: options.tag, filterResponse: true, perspective: options.perspective }));
var listen = (client, query, params, options) => defer(() => client.listen(query, params, { events: ["welcome", "mutation", "reconnect"], includeResult: false, visibility: "query", tag: options.tag }));
function isWelcomeEvent(event) {
  return event.type === "welcome";
}
function listenQuery(client, query) {
  let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const fetchQuery = typeof query === "string" ? query : query.fetch;
  const listenerQuery = typeof query === "string" ? query : query.listen;
  const events$ = listen(client, listenerQuery, params, options).pipe(mergeMap((ev, i) => {
    const isFirst = i === 0;
    if (isFirst && !isWelcomeEvent(ev)) {
      return throwError(() => new Error(ev.type === "reconnect" ? "Could not establish EventSource connection" : 'Received unexpected type of first event "'.concat(ev.type, '"')));
    }
    return of(ev);
  }), share());
  const [welcome$, mutationAndReconnect$] = partition(events$, isWelcomeEvent);
  const isRelevantEvent = (event) => {
    if (!options.transitions || event.type !== "mutation") {
      return true;
    }
    return options.transitions.includes(event.transition);
  };
  const doFetch = () => fetch$1(client, fetchQuery, params, options);
  return merge(welcome$.pipe(take(1)), mutationAndReconnect$.pipe(filter(isRelevantEvent), throttleTime(options.throttleTime || 1e3, asyncScheduler, { leading: true, trailing: true }))).pipe(exhaustMapWithTrailing((event) => {
    if (event.type === "mutation" && event.visibility !== "query") {
      return timer(1200).pipe(mergeMap(doFetch));
    }
    return doFetch();
  }));
}
function resolveTypeForDocument(client, id4) {
  let specifiedType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "*";
  if (specifiedType && specifiedType !== "*") {
    return of(specifiedType);
  }
  const query = "*[_id in [$documentId, $draftId]]._type";
  const documentId = getPublishedId(id4);
  const draftId = getDraftId(documentId);
  return client.observable.fetch(query, { documentId, draftId }).pipe(map((types3) => types3[0]));
}
function isRecord6(value) {
  return (0, import_isPlainObject5.default)(value);
}
var ALLOWED_REF_PROPS = ["_key", "_ref", "_weak", "_type"];
var REQUIRED_TEMPLATE_PROPS = ["id", "title", "schemaType", "value"];
function templateId(template, i) {
  return quote3(template.id || template.title) || typeof i === "number" && "at index ".concat(i) || "";
}
function quote3(str) {
  return str && str.length > 0 ? '"'.concat(str, '"') : str;
}
function validateTemplates(schema, templates) {
  const idMap = /* @__PURE__ */ new Map();
  templates.forEach((template, i) => {
    const id4 = templateId(template, i);
    if (typeof template.values !== "undefined" && !template.value) {
      throw new Error("Template ".concat(id4, ' is missing "value" property, but contained "values". Typo?'));
    }
    const missing = REQUIRED_TEMPLATE_PROPS.filter((prop) => !template[prop]);
    if (missing.length > 0) {
      throw new Error("Template ".concat(id4, " is missing required properties: ").concat(missing.join(", ")));
    }
    if (typeof template.value !== "function" && !isRecord6(template.value)) {
      throw new Error("Template ".concat(id4, ' has an invalid "value" property; should be a function or an object'));
    }
    if (typeof template.parameters !== "undefined") {
      if (Array.isArray(template.parameters)) {
        template.parameters.forEach((param, j) => validateParameter(schema, param, template, j));
      } else {
        throw new Error("Template ".concat(id4, ' has an invalid "parameters" property; must be an array'));
      }
    }
    if (idMap.has(template.id)) {
      const dupeIndex = idMap.get(template.id);
      const dupe = "".concat(quote3(templates[dupeIndex].title), " at index ").concat(dupeIndex);
      throw new Error('Template "'.concat(template.title, '" at index ').concat(i, ' has the same ID ("').concat(template.id, '") as template ').concat(dupe));
    }
    idMap.set(template.id, i);
  });
  return templates;
}
function validateInitialObjectValue(value, template) {
  const contextError = (msg2) => 'Template "'.concat(template.id, '" initial value: ').concat(msg2);
  if (!isRecord6(value)) {
    throw new Error(contextError("resolved to a non-object"));
  }
  if (value._type && template.schemaType !== value._type) {
    throw new Error(contextError('includes "_type"-property ('.concat(value._type, ") that does not match template (").concat(template.schemaType, ")")));
  }
  try {
    return validateValue2(value);
  } catch (err) {
    err.message = contextError(err.message);
    throw err;
  }
}
function validateValue2(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let parentIsArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (Array.isArray(value)) {
    return value.map((item, i) => {
      if (Array.isArray(item)) {
        throw new Error('multidimensional arrays are not supported (at path "'.concat(toString(path2), '")'));
      }
      return validateValue2(item, path2.concat(i), true);
    });
  }
  if (!isRecord6(value)) {
    return value;
  }
  const initial = parentIsArray && !value._key ? { _key: randomKey() } : {};
  if (path2.length > 0 && !value._type) {
    if (value._ref) {
      initial._type = "reference";
    }
  }
  if (value._ref) {
    validateReference(value, path2);
  }
  return Object.keys(value).reduce((acc, key2) => {
    acc[key2] = validateValue2(value[key2], path2.concat([key2]));
    return acc;
  }, initial);
}
function validateParameter(schema, parameter, template, index) {
  if (!parameter.name) {
    throw new Error("Template ".concat(template.id, " has a parameter at index ").concat(index, ' that is missing its "name"-property'));
  }
  if (parameter.name === "template") {
    throw new Error('Template parameters cannot be named "template", see parameter #'.concat(index, " for template ").concat(template.id));
  }
  if (!schema.get(parameter.type)) {
    throw new Error('Template parameter "'.concat(parameter.name, '" has an invalid/unknown type: "').concat(parameter.type, '"'));
  }
}
function validateReference(value) {
  let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!value._type && value.type) {
    throw new Error('Reference is missing "_type", but has a "type" property at path "'.concat(toString(path2), '"'));
  }
  const disallowed = Object.keys(value).filter((key2) => !ALLOWED_REF_PROPS.includes(key2));
  if (disallowed.length > 0) {
    const plural = disallowed.length > 1 ? "properties" : "property";
    throw new Error("Disallowed ".concat(plural, " found in reference: ").concat(disallowed.map(quote3).join(", "), ' at path "').concat(toString(path2), '"'));
  }
}
function deepAssign(target, source) {
  const result = { ...target, ...source };
  Object.keys(result).forEach((key2) => {
    const sourceVal = source[key2];
    const targetVal = target[key2];
    if (isRecord6(sourceVal) && isRecord6(targetVal)) {
      result[key2] = deepAssign(targetVal, sourceVal);
    }
  });
  return result;
}
function isBuilder(template) {
  return isRecord6(template) && typeof template.serialize === "function";
}
async function resolveValue(initialValueOpt, params, context) {
  return typeof initialValueOpt === "function" ? initialValueOpt(params, context) : initialValueOpt;
}
async function resolveInitialValue(schema, template) {
  let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (isBuilder(template)) {
    return resolveInitialValue(schema, template.serialize(), params, context);
  }
  const { id: id4, schemaType: schemaTypeName, value } = template;
  if (!value) {
    throw new Error('Template "'.concat(id4, '" has invalid "value" property'));
  }
  let resolvedValue = await resolveValue(value, params, context);
  if (!isRecord6(resolvedValue)) {
    throw new Error('Template "'.concat(id4, '" has invalid "value" property - must be a plain object or a resolver function returning a plain object'));
  }
  if (isRecord6(resolvedValue) && !Object.keys(resolvedValue).length) {
    resolvedValue = { _type: schemaTypeName };
  }
  resolvedValue = validateInitialObjectValue(resolvedValue, template);
  const schemaType = schema.get(schemaTypeName);
  if (!schemaType) {
    throw new Error('Could not find schema type with name "'.concat(schemaTypeName, '".'));
  }
  const newValue = deepAssign(await resolveInitialValueForType(schemaType, params, DEFAULT_MAX_RECURSION_DEPTH, context) || {}, resolvedValue);
  return validateInitialObjectValue(newValue, template);
}
function getItemType$1(arrayType, item) {
  const itemTypeName = resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
var DEFAULT_MAX_RECURSION_DEPTH = 10;
function resolveInitialValueForType(type, params) {
  let maxDepth2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_MAX_RECURSION_DEPTH;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (maxDepth2 <= 0) {
    return Promise.resolve(void 0);
  }
  if (isObjectSchemaType(type)) {
    return resolveInitialObjectValue(type, params, maxDepth2, context);
  }
  if (isArraySchemaType(type)) {
    return resolveInitialArrayValue(type, params, maxDepth2, context);
  }
  return resolveValue(type.initialValue, params, context);
}
async function resolveInitialArrayValue(type, params, maxDepth2, context) {
  const initialArray = await resolveValue(type.initialValue, void 0, context);
  if (!Array.isArray(initialArray)) {
    return void 0;
  }
  return Promise.all(initialArray.map(async (initialItem) => {
    const itemType = getItemType$1(type, initialItem);
    return isObjectSchemaType(itemType) ? { ...initialItem, ...await resolveInitialValueForType(itemType, params, maxDepth2 - 1, context), _key: randomKey() } : initialItem;
  }));
}
async function resolveInitialObjectValue(type, params, maxDepth2, context) {
  const initialObject = { ...await resolveValue(type.initialValue, params, context) || {} };
  const fieldValues = {};
  await Promise.all(type.fields.map(async (field) => {
    const initialFieldValue = await resolveInitialValueForType(field.type, params, maxDepth2 - 1, context);
    if (initialFieldValue !== void 0 && initialFieldValue !== null) {
      fieldValues[field.name] = initialFieldValue;
    }
  }));
  const merged = deepAssign(fieldValues, initialObject);
  if (isDeepEmpty(merged)) {
    return void 0;
  }
  if (type.name !== "object") {
    merged._type = type.name;
  }
  return merged;
}
function maybeSerialize(template) {
  return isBuilder(template) ? template.serialize() : template;
}
function isNonNullable(t3) {
  return !!t3;
}
function prepareTemplates(schema, initialValueTemplates) {
  const serialized = initialValueTemplates.map(maybeSerialize);
  return validateTemplates(schema, serialized);
}
function defaultTemplateForType(schemaType) {
  return { id: schemaType.name, schemaType: schemaType.name, title: schemaType.title || schemaType.name, icon: schemaType.icon, value: schemaType.initialValue || { _type: schemaType.name } };
}
function defaultTemplatesForSchema(schema) {
  const schemaTypes = schema.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema.get(typeName)).filter(isNonNullable).filter((schemaType) => {
    var _a4;
    return ((_a4 = schemaType.type) == null ? void 0 : _a4.name) === "document";
  });
  return prepareTemplates(schema, schemaTypes.map((schemaType) => defaultTemplateForType(schemaType)));
}
var LOADING_MSG = { type: "loading" };
function getInitialValueStream(schema, initialValueTemplates, documentPreviewStore, opts, context) {
  const draft$ = documentPreviewStore.observePaths({ _type: "reference", _ref: getDraftId(opts.documentId) }, ["_type"]);
  const published$ = documentPreviewStore.observePaths({ _type: "reference", _ref: getPublishedId(opts.documentId) }, ["_type"]);
  const value$ = merge(draft$.pipe(map((draft) => ({ draft }))), published$.pipe(map((published) => ({ published })))).pipe(
    scan((prev, res) => ({ ...prev, ...res }), {}),
    // Wait until we know the state of both draft and published
    filter((res) => "draft" in res && "published" in res),
    map((res) => res.draft || res.published),
    // Only update if we didn't previously have a document but we now do
    distinctUntilChanged((prev, next) => Boolean(prev) !== Boolean(next)),
    // Prevent rapid re-resolving when transitioning between different templates
    debounceTime(25)
  );
  return value$.pipe(switchMap((document2) => {
    if (document2) {
      return of({ type: "success", value: null });
    }
    if (!opts.templateName) {
      return of({ isResolving: false, initialValue: void 0 });
    }
    const template = initialValueTemplates.find((t3) => t3.id === opts.templateName);
    if (!template) {
      console.warn('Template "%s" not defined, using empty initial value', opts.templateName);
      return of({ isResolving: false, initialValue: void 0 });
    }
    const initialValueWithParams$ = from(resolveInitialValue(schema, template, opts.templateParams, context)).pipe(map((initialValue) => ({ isResolving: false, initialValue }))).pipe(catchError((resolveError) => {
      console.group("Failed to resolve initial value");
      console.error(resolveError);
      console.error("Template ID: %s", opts.templateName);
      console.error("Parameters: %o", opts.templateParams);
      console.groupEnd();
      const msg2 = { type: "error", error: resolveError };
      return of(msg2);
    }));
    return merge(of({ isResolving: true }), initialValueWithParams$).pipe(switchMap((_ref304) => {
      let { isResolving, initialValue, resolveError } = _ref304;
      if (resolveError) {
        return of({ type: "error", message: "Failed to resolve initial value" });
      }
      if (isResolving) {
        return of(LOADING_MSG);
      }
      const msg2 = { type: "success", value: initialValue };
      return of(msg2);
    }));
  }), startWith(LOADING_MSG), distinctUntilChanged());
}
function getIdPairFromPublished(publishedId) {
  if (isDraftId(publishedId)) {
    throw new Error("editOpsOf does not expect a draft id.");
  }
  return { publishedId, draftId: getDraftId(publishedId) };
}
function createDocumentStore(_ref305) {
  let { getClient, documentPreviewStore, historyStore, initialValueTemplates, schema, i18n } = _ref305;
  const observeDocumentPairAvailability = documentPreviewStore.unstable_observeDocumentPairAvailability;
  const client = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const ctx = { client, getClient, observeDocumentPairAvailability, historyStore, schema, i18n };
  return {
    // Public API
    checkoutPair(idPair) {
      return checkoutPair(client, idPair);
    },
    initialValue(opts, context) {
      return getInitialValueStream(schema, initialValueTemplates, documentPreviewStore, opts, context);
    },
    listenQuery(query, params, options) {
      return listenQuery(client, query, params, options);
    },
    resolveTypeForDocument(id4, specifiedType) {
      return resolveTypeForDocument(client, id4, specifiedType);
    },
    pair: { consistencyStatus(publishedId, type) {
      return consistencyStatus(ctx.client, getIdPairFromPublished(publishedId), type);
    }, documentEvents(publishedId, type) {
      return documentEvents(ctx.client, getIdPairFromPublished(publishedId), type);
    }, editOperations(publishedId, type) {
      return editOperations(ctx, getIdPairFromPublished(publishedId), type);
    }, editState(publishedId, type) {
      return editState(ctx, getIdPairFromPublished(publishedId), type);
    }, operationEvents(publishedId, type) {
      return operationEvents({ client, historyStore, schema }).pipe(filter((result) => result.args.idPair.publishedId === publishedId && result.args.typeName === type), map((result) => {
        const { operationName, idPair: documentIds } = result.args;
        return result.type === "success" ? { type: "success", op: operationName, id: documentIds.publishedId } : { type: "error", op: operationName, id: documentIds.publishedId, error: result.error };
      }));
    }, validation(publishedId, type) {
      return validation(ctx, getIdPairFromPublished(publishedId), type);
    } }
  };
}
var LOADING_STATE = { isLoaded: false, documentType: void 0 };
function useDocumentType(documentId) {
  let specifiedType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "*";
  const documentStore = useDocumentStore();
  const publishedId = getPublishedId(documentId);
  const isResolved = Boolean(specifiedType && specifiedType !== "*");
  const SYNC_RESOLVED_STATE = (0, import_react51.useMemo)(() => ({ documentType: specifiedType, isLoaded: true }), [specifiedType]);
  const [resolvedState, setDocumentType] = (0, import_react51.useState)(isResolved ? SYNC_RESOLVED_STATE : LOADING_STATE);
  (0, import_react51.useEffect)(() => setDocumentType(LOADING_STATE), [publishedId, specifiedType]);
  (0, import_react51.useEffect)(() => {
    if (isResolved) {
      return void 0;
    }
    const sub2 = documentStore.resolveTypeForDocument(publishedId, specifiedType).subscribe((documentType) => setDocumentType({ documentType, isLoaded: true }));
    return () => sub2.unsubscribe();
  }, [documentStore, publishedId, specifiedType, isResolved]);
  return isResolved ? (
    // `isResolved` is only true when we're _synchronously_ resolved
    SYNC_RESOLVED_STATE
  ) : (
    // Using the document type resolved from the API
    resolvedState
  );
}
function useDocumentValues(documentId, paths) {
  const documentPreviewStore = useDocumentPreviewStore();
  const documentValues$ = (0, import_react51.useMemo)(() => documentId ? documentPreviewStore.observePaths({ _type: "reference", _ref: documentId }, paths) : of(void 0), [documentId, documentPreviewStore, paths]);
  return useLoadable(documentValues$);
}
function useInitialValue(props2) {
  const { documentId, documentType, templateName, templateParams: templateParamsRaw } = props2;
  const templateParams = useUnique2(templateParamsRaw);
  const documentStore = useDocumentStore();
  const context = useInitialValueResolverContext();
  const defaultValue = (0, import_react51.useMemo)(() => ({ _id: documentId, _type: documentType }), [documentId, documentType]);
  const [state, setState] = (0, import_react51.useState)({ loading: false, error: null, value: defaultValue });
  (0, import_react51.useEffect)(() => {
    const initialValueOptions = { documentId, documentType, templateName, templateParams };
    if (!templateName) {
      setState({ loading: true, error: null, value: defaultValue });
      return void 0;
    }
    const initialValueMsg$ = documentStore.initialValue(initialValueOptions, context);
    const sub2 = initialValueMsg$.subscribe((msg2) => {
      if (msg2.type === "loading") {
        setState({ loading: true, error: null, value: defaultValue });
      }
      if (msg2.type === "success") {
        setState({ loading: false, error: null, value: msg2.value ? { ...defaultValue, ...msg2.value } : defaultValue });
      }
      if (msg2.type === "error") {
        setState({ loading: false, error: msg2.error, value: defaultValue });
      }
    });
    setState({ loading: true, error: null, value: defaultValue });
    return () => sub2.unsubscribe();
  }, [defaultValue, documentId, documentStore, documentType, templateName, templateParams, context]);
  return state;
}
function useInitialValueResolverContext() {
  const source = useSource();
  const schema = useSchema();
  const currentUser = useCurrentUser();
  const projectId2 = useProjectId$1();
  const dataset2 = useDataset();
  const getClient = source.getClient;
  return (0, import_react51.useMemo)(() => {
    return { projectId: projectId2, dataset: dataset2, getClient, schema, currentUser };
  }, [getClient, schema, currentUser, projectId2, dataset2]);
}
function useResolveInitialValueForType() {
  const initialValueContext = useInitialValueResolverContext();
  return (0, import_react51.useCallback)((type, params) => {
    return resolveInitialValueForType(type, params, DEFAULT_MAX_RECURSION_DEPTH, initialValueContext);
  }, [initialValueContext]);
}
function getSchemaType(schema, typeName) {
  const type = schema.get(typeName);
  if (!type) {
    throw new Error("No such schema type: ".concat(typeName));
  }
  return type;
}
function getPairPermissions(_ref306) {
  let { grantsStore, permission, draft, published, liveEdit } = _ref306;
  const effectiveVersion = draft || published;
  const effectiveVersionType = effectiveVersion === draft ? "draft" : "published";
  const { checkDocumentPermission } = grantsStore;
  switch (permission) {
    case "delete": {
      if (liveEdit) {
        return [["delete published document (live-edit)", checkDocumentPermission("update", published)]];
      }
      return [["delete draft document", checkDocumentPermission("update", draft)], ["delete published document", checkDocumentPermission("update", published)]];
    }
    case "discardDraft": {
      if (liveEdit)
        return [];
      return [["delete draft document", checkDocumentPermission("update", draft)]];
    }
    case "publish": {
      if (liveEdit)
        return [];
      return [
        // precondition
        ["update published document at its current state", checkDocumentPermission("update", published)],
        // post condition
        ["delete draft document", checkDocumentPermission("update", draft)],
        ["create published document from draft", checkDocumentPermission("create", draft && { ...draft, _id: getPublishedId(draft._id) })]
      ];
    }
    case "unpublish": {
      if (liveEdit)
        return [];
      return [
        // precondition
        ["update draft document at its current state", checkDocumentPermission("create", draft)],
        // post condition
        ["delete published document", checkDocumentPermission("update", published)],
        ["create draft document from published version", checkDocumentPermission("create", published && { ...published, _id: getDraftId(published._id) })]
      ];
    }
    case "update": {
      if (liveEdit) {
        return [["update published document (live-edit)", checkDocumentPermission("update", published)]];
      }
      return [["update ".concat(effectiveVersionType, " document"), checkDocumentPermission("update", effectiveVersion)]];
    }
    case "duplicate": {
      if (liveEdit) {
        return [["create new published document from existing document (live-edit)", checkDocumentPermission("create", { ...published, _id: "dummy-id" })]];
      }
      return [["create new draft document from existing ".concat(effectiveVersionType, " document"), checkDocumentPermission("create", { ...effectiveVersion, _id: getDraftId("dummy-id") })]];
    }
    default: {
      throw new Error("Could not match permission: ".concat(permission));
    }
  }
}
function getDocumentPairPermissions(_ref307) {
  let { client, grantsStore, schema, id: id4, permission, type } = _ref307;
  if (type === "*") {
    return of({ granted: false, reason: "Type specified was `*`" });
  }
  const liveEdit = Boolean(getSchemaType(schema, type).liveEdit);
  return snapshotPair(client, { draftId: getDraftId(id4), publishedId: getPublishedId(id4) }, type).pipe(switchMap((pair) => combineLatest([pair.draft.snapshots$, pair.published.snapshots$]).pipe(map((_ref308) => {
    let [draft, published] = _ref308;
    return { draft, published };
  }))), switchMap((_ref309) => {
    let { draft, published } = _ref309;
    const pairPermissions = getPairPermissions({ grantsStore, permission, draft, published, liveEdit }).map((_ref310) => {
      let [label, observable2] = _ref310;
      return observable2.pipe(map((_ref311) => {
        let { granted, reason } = _ref311;
        return { granted, reason: granted ? "" : "not allowed to ".concat(label, ": ").concat(reason), label, permission };
      }));
    });
    if (!pairPermissions.length)
      return of({ granted: true, reason: "" });
    return combineLatest(pairPermissions).pipe(map((permissionResults) => {
      const granted = permissionResults.every((permissionResult) => permissionResult.granted);
      const reason = granted ? "" : "Unable to ".concat(permission, ":\n	").concat(permissionResults.filter((permissionResult) => !permissionResult.granted).map((permissionResult) => permissionResult.reason).join("\n	"));
      return { granted, reason };
    }));
  }));
}
var useDocumentPairPermissionsFromHookFactory = createHookFromObservableFactory(getDocumentPairPermissions);
function useDocumentPairPermissions(_ref312) {
  let { id: id4, type, permission, client: overrideClient, schema: overrideSchema, grantsStore: overrideGrantsStore } = _ref312;
  const defaultClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const defaultSchema = useSchema();
  const defaultGrantsStore = useGrantsStore();
  const client = (0, import_react51.useMemo)(() => overrideClient || defaultClient, [defaultClient, overrideClient]);
  const schema = (0, import_react51.useMemo)(() => overrideSchema || defaultSchema, [defaultSchema, overrideSchema]);
  const grantsStore = (0, import_react51.useMemo)(() => overrideGrantsStore || defaultGrantsStore, [defaultGrantsStore, overrideGrantsStore]);
  return useDocumentPairPermissionsFromHookFactory((0, import_react51.useMemo)(() => ({ client, schema, grantsStore, id: id4, permission, type }), [client, grantsStore, id4, permission, schema, type]));
}
function getDocumentValuePermissions(_ref313) {
  let { grantsStore, document: document2, permission } = _ref313;
  const { checkDocumentPermission } = grantsStore;
  return checkDocumentPermission(permission, document2);
}
var useDocumentValuePermissionsFromHookFactory = createHookFromObservableFactory(getDocumentValuePermissions);
function useDocumentValuePermissions(_ref314) {
  let { document: document2, permission, ...rest } = _ref314;
  const grantsStore = useGrantsStore();
  return useDocumentValuePermissionsFromHookFactory({ grantsStore: rest.grantsStore || grantsStore, document: document2, permission });
}
function serialize(item) {
  if (typeof item === "object" && item !== null && "serialize" in item) {
    return serialize(item.serialize());
  }
  return item;
}
function getTemplatePermissions(_ref315) {
  let { grantsStore, templateItems, templates, schema, context } = _ref315;
  if (!(templateItems == null ? void 0 : templateItems.length))
    return of([]);
  return combineLatest(templateItems.map(serialize).map(async (item) => {
    const template = templates.find((t3) => t3.id === item.templateId);
    if (!template) {
      throw new Error('template not found: "'.concat(item.templateId, '"'));
    }
    const resolvedInitialValue = await resolveInitialValue(schema, template, item.parameters, context);
    return { template, item, resolvedInitialValue };
  }).map((promise2) => from(promise2).pipe(switchMap((_ref316) => {
    let { item, resolvedInitialValue, template } = _ref316;
    const schemaType = schema.get(template.schemaType);
    if (!schemaType) {
      throw new Error('schema type not found: "'.concat(template.schemaType, '"'));
    }
    const liveEdit = schemaType == null ? void 0 : schemaType.liveEdit;
    const { initialDocumentId = "dummy-id" } = item;
    return getDocumentValuePermissions({ grantsStore, permission: "create", document: { _id: liveEdit ? getPublishedId(initialDocumentId) : getDraftId(initialDocumentId), ...resolvedInitialValue } }).pipe(map((_ref317) => {
      let { granted, reason } = _ref317;
      const title = item.title || template.title;
      const result = { ...item, granted, reason, resolvedInitialValue, template, title, subtitle: schemaType.title === title ? void 0 : schemaType.title, description: item.description || template.description, icon: item.icon || template.icon };
      return result;
    }));
  }))));
}
var useTemplatePermissionsFromHookFactory = createHookFromObservableFactory(getTemplatePermissions);
function useTemplatePermissions(_ref318) {
  let { templateItems, ...rest } = _ref318;
  const schema = useSchema();
  const templates = useTemplates();
  const grantsStore = useGrantsStore();
  const initialValueContext = useInitialValueResolverContext();
  return useTemplatePermissionsFromHookFactory({ templateItems, grantsStore: rest.grantsStore || grantsStore, schema: rest.schema || schema, templates: rest.templates || templates, context: initialValueContext });
}
var DEBUG_PREFIX = "_debug_";
var hashchange$ = typeof window === "undefined" ? of({}) : fromEvent(window, "hashchange");
var debugParams$ = concat(of(0), hashchange$).pipe(map(() => typeof document === "undefined" ? "#" : document.location.hash), distinctUntilChanged(), map((hash3) => hash3.substring(1).split(";").filter((p) => p.toLowerCase().startsWith(DEBUG_PREFIX)).map((param) => param.substring(DEBUG_PREFIX.length))));
var debugRolesParam$ = debugParams$.pipe(map((args) => args.find((arg) => arg.startsWith("roles="))), map((arg) => (arg == null ? void 0 : arg.split("roles=")[1].split(",").map((r2) => r2.trim())) || []));
var administrator = [{ filter: '_id in path("**")', permissions: ["read", "create", "history", "update"] }];
var editor = [{ filter: '_id in path("**")', permissions: ["read", "create", "history", "update"] }];
var developer = [{ filter: '_id in path("**")', permissions: ["read", "create", "history", "update"] }];
var contributor = [{ filter: '_id in path("**")', permissions: ["read"] }, { filter: '_id in path("drafts.**")', permissions: ["create", "history", "update"] }];
var viewer = [{ filter: '_id in path("**")', permissions: ["read", "history"] }];
var requiresApproval = [{ filter: "!locked", permissions: ["read", "create", "update"] }];
var restricted = [{ filter: '_id in path("drafts.**") && _type in ["stringsTest", "book", "author", "referenceTest"]', permissions: ["read", "create", "history", "update"] }, { filter: '_id in path("**")', permissions: ["read"] }];
var DEBUG_ROLE_GRANTS_MAP = {
  // basic
  administrator,
  editor,
  developer,
  contributor,
  viewer,
  // custom
  restricted,
  requiresApproval,
  // legacy
  read: viewer,
  write: editor
};
var debugGrants$ = debugRolesParam$.pipe(map((roles) => {
  if (!roles.length)
    return null;
  return roles.filter((value) => Boolean(value) && value in DEBUG_ROLE_GRANTS_MAP).flatMap((roleName) => DEBUG_ROLE_GRANTS_MAP[roleName] || []);
}));
async function getDatasetGrants(client, projectId2, dataset2) {
  const grants = await client.request({ uri: "/projects/".concat(projectId2, "/datasets/").concat(dataset2, "/acl"), tag: "acl.get", withCredentials: true });
  return grants;
}
function getParams(currentUser) {
  const params = {};
  if (currentUser !== null) {
    params.identity = currentUser.id;
  }
  return params;
}
var PARSED_FILTERS_MEMO = /* @__PURE__ */ new Map();
async function matchesFilter(currentUser, filter3, document2) {
  if (!PARSED_FILTERS_MEMO.has(filter3)) {
    PARSED_FILTERS_MEMO.set(filter3, parse6("*[".concat(filter3, "]")));
  }
  const parsed = PARSED_FILTERS_MEMO.get(filter3);
  const evalParams = getParams(currentUser);
  const { identity: identity4 } = evalParams;
  const params = { ...evalParams };
  const data = await (await evaluateQuery(parsed, { dataset: [document2], identity: identity4, params })).get();
  return (data == null ? void 0 : data.length) === 1;
}
function createGrantsStore(_ref319) {
  let { client, currentUser } = _ref319;
  const versionedClient = client.withConfig({ apiVersion: "2021-06-07" });
  const datasetGrants$ = defer(() => of(versionedClient.config())).pipe(switchMap((_ref320) => {
    let { projectId: projectId2, dataset: dataset2 } = _ref320;
    if (!projectId2 || !dataset2) {
      throw new Error("Missing projectId or dataset");
    }
    return getDatasetGrants(versionedClient, projectId2, dataset2);
  }));
  const currentUserDatasetGrants = debugGrants$.pipe(switchMap((debugGrants) => debugGrants ? of(debugGrants) : datasetGrants$), publishReplay(1), refCountDelay(1e3));
  return { checkDocumentPermission(permission, document2) {
    return currentUserDatasetGrants.pipe(switchMap((grants) => grantsPermissionOn(currentUser, grants, permission, document2)), distinctUntilChanged(import_shallow_equals.default));
  } };
}
async function grantsPermissionOn(currentUser, grants, permission, document2) {
  if (!document2) {
    return { granted: true, reason: "Null document, nothing to check" };
  }
  if (!grants.length) {
    return { granted: false, reason: "No document grants" };
  }
  const matchingGrants = [];
  for (const grant of grants) {
    if (await matchesFilter(currentUser, grant.filter, document2)) {
      matchingGrants.push(grant);
    }
  }
  const foundMatch = matchingGrants.some((grant) => grant.permissions.some((p) => p === permission));
  return { granted: foundMatch, reason: foundMatch ? "Matching grant" : "No matching grants found" };
}
async function getJsonStream(url, token) {
  const options = token ? { headers: { Authorization: "Bearer ".concat(token) } } : { credentials: "include" };
  const response = await fetch(url, options);
  return getStream(response);
}
function getStream(response) {
  const body = response.body;
  if (!body) {
    throw new Error("Failed to read body from response");
  }
  let reader;
  let cancelled = false;
  return new ReadableStream({ start(controller) {
    reader = body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    reader.read().then(function processResult(result) {
      if (result.done) {
        if (cancelled) {
          return;
        }
        buffer = buffer.trim();
        if (buffer.length === 0) {
          controller.close();
          return;
        }
        controller.enqueue(JSON.parse(buffer));
        controller.close();
        return;
      }
      buffer += decoder.decode(result.value, { stream: true });
      const lines = buffer.split("\n");
      for (let i = 0; i < lines.length - 1; ++i) {
        const line = lines[i].trim();
        if (line.length === 0) {
          continue;
        }
        try {
          controller.enqueue(JSON.parse(line));
        } catch (err) {
          controller.error(err);
          cancelled = true;
          reader.cancel();
          return;
        }
      }
      buffer = lines[lines.length - 1];
      return reader.read().then(processResult).catch((err) => controller.error(err));
    }).catch((err) => controller.error(err));
  }, cancel() {
    cancelled = true;
    reader.cancel();
  } });
}
function emptyVersionState(id4) {
  return { id: id4, hasAttrs: false, attrs: null, rev: null, events: [], aligned: false };
}
function align(history2, state) {
  const idx = state.events.findIndex((evt) => history2.id === evt.transactionId);
  if (idx >= 0) {
    return idx + 1;
  }
  if (state.rev) {
    return state.rev === history2.id ? 0 : -1;
  }
  return 0;
}
function startFromSnapshot(state, doc) {
  state.hasAttrs = true;
  if (doc) {
    state.attrs = { ...doc };
    if (typeof state.attrs._rev != "string")
      throw new Error("snapshot has no _rev");
    state.rev = state.attrs._rev;
    delete state.attrs._rev;
  } else {
    state.attrs = null;
    state.rev = null;
  }
  state.events = [];
}
var Aligner = class {
  constructor(timeline) {
    this.earliestTransactionId = null;
    this.timeline = timeline;
    this._states = { draft: emptyVersionState(timeline.draftId), published: emptyVersionState(timeline.publishedId) };
  }
  appendRemoteSnapshotEvent(evt) {
    const state = this._states[evt.version];
    if (evt.type === "snapshot") {
      this._maybeInvalidateHistory();
      startFromSnapshot(state, evt.document);
      return;
    }
    if (evt.type === "remoteMutation") {
      if (state.aligned) {
        this._apply(state, evt);
        this.timeline.addRemoteMutation(evt);
      } else if (state.hasAttrs) {
        state.events.push(evt);
      } else {
        startFromSnapshot(state, evt.head);
      }
    }
  }
  prependHistoryEvent(evt) {
    if (!this.acceptsHistory)
      throw new Error("cannot prepend history at this point");
    for (const state of Object.values(this._states)) {
      if (!state.aligned) {
        const idx = align(evt, state);
        if (idx >= 0) {
          this._alignAtIndex(state, idx);
        }
      }
    }
    this.timeline.addTranslogEntry(evt);
    this.earliestTransactionId = evt.id;
  }
  didReachEarliestEntry() {
    for (const state of Object.values(this._states)) {
      if (!state.aligned) {
        if (state.attrs !== null)
          throw new Error("unable to find translog entry to align to");
        this._alignAtIndex(state, 0);
      }
    }
    this.timeline.didReachEarliestEntry();
  }
  get isAligned() {
    return Object.values(this._states).every((state) => state.aligned);
  }
  get acceptsHistory() {
    return this._isComplete;
  }
  get currentDocument() {
    return { draft: this._states.draft.attrs, published: this._states.published.attrs };
  }
  _alignAtIndex(state, idx) {
    for (const mutEvt of state.events.slice(0, idx)) {
      this._apply(state, mutEvt);
    }
    for (const mutEvt of state.events.slice(idx)) {
      this._apply(state, mutEvt);
      this.timeline.addRemoteMutation(mutEvt);
    }
    state.events = [];
    state.aligned = true;
  }
  get _isComplete() {
    return Object.values(this._states).every((state) => state.hasAttrs);
  }
  // eslint-disable-next-line class-methods-use-this
  _apply(state, evt) {
    state.attrs = applyPatch3(state.attrs, evt.effects.apply);
    state.rev = evt.transactionId;
  }
  _maybeInvalidateHistory() {
    if (this._isComplete) {
      for (const state of Object.values(this._states)) {
        state.aligned = false;
      }
      this.earliestTransactionId = null;
      this.timeline.reset();
    }
  }
};
var Reconstruction = class {
  constructor(timeline, doc, start, end) {
    this.timeline = timeline;
    this.start = start;
    this.end = end;
    this.doc = doc;
  }
  same(start, end) {
    return this.start === start && this.end === end;
  }
  /** Returns the attributes as seen at the end of the range. */
  endAttributes() {
    return getAttrs$1(this.endDocument());
  }
  endDocument() {
    if (!this._endDocument) {
      this._endDocument = this.timeline.replayBackwardsUntil(this.end.end, this.doc);
    }
    return this._endDocument;
  }
  /** Returns the attributes as seen at the end of the range. */
  startAttributes() {
    return getAttrs$1(this.startDocument());
  }
  startDocument() {
    if (!this.start)
      throw new Error("start required");
    if (!this._startDocument) {
      this._startDocument = this.timeline.replayBackwardsBetween(this.start.end, this.end.end - 1, this.endDocument());
    }
    return this._startDocument;
  }
  diff() {
    if (!this._diff) {
      if (!this.start)
        throw new Error("start required");
      this._diff = this.timeline.calculateDiff(this.startDocument(), this.endDocument(), this.start.index + 1, this.end.index);
    }
    return this._diff;
  }
};
function getAttrs$1(doc) {
  return doc.draft || doc.published;
}
var TRANSLOG_ENTRY_LIMIT = 50;
var TimelineController = class {
  constructor(options) {
    this.version = 0;
    this.selectionState = "inactive";
    this._fetchMore = false;
    this._fetchAtLeast = 0;
    this._isRunning = false;
    this._isSuspended = false;
    this._didErr = false;
    this._since = null;
    this._sinceTime = null;
    this._rev = null;
    this._revTime = null;
    this.timeline = options.timeline;
    this.client = options.client;
    this.handler = options.handler;
    this._aligner = new Aligner(this.timeline);
    this.markChange();
  }
  clearRange() {
    this.setRange(null, null);
  }
  setRange(since, rev) {
    if (rev !== this._rev)
      this.setRevTime(rev);
    if (since !== this._since)
      this.setSinceTime(since);
    let _fetchAtLeast = 10;
    if (this._sinceTime === "loading" || this._revTime === "loading" || !this._aligner.isAligned) {
      this.selectionState = "loading";
    } else if (this._sinceTime === "invalid" || this._revTime === "invalid") {
      this.selectionState = "invalid";
    } else if (this._sinceTime) {
      this.selectionState = "range";
      const targetRev = this._revTime || this.timeline.lastChunk();
      if (this._sinceTime.index > targetRev.index) {
        this._revTime = "invalid";
        this.selectionState = "invalid";
      } else {
        this.setReconstruction(this._sinceTime, targetRev);
      }
    } else if (this._revTime) {
      this.selectionState = "rev";
      this.setReconstruction(null, this._revTime);
    } else {
      this.selectionState = "inactive";
      _fetchAtLeast = 0;
    }
    this._fetchAtLeast = _fetchAtLeast;
    this.start();
  }
  setLoadMore(flag) {
    this._fetchMore = flag;
    this.start();
  }
  get sinceTime() {
    return this._sinceTime && typeof this._sinceTime === "object" ? this._sinceTime : null;
  }
  get revTime() {
    return this._revTime && typeof this._revTime === "object" ? this._revTime : null;
  }
  get realRevChunk() {
    return this.revTime || this.timeline.lastChunk();
  }
  /** Returns true when there's an older revision we want to render. */
  onOlderRevision() {
    return Boolean(this._rev) && (this.selectionState === "range" || this.selectionState === "rev");
  }
  findRangeForNewRev(rev) {
    const revTimeId = this.timeline.isLatestChunk(rev) ? null : this.timeline.createTimeId(rev);
    if (!this._since) {
      return [null, revTimeId];
    }
    const sinceChunk = this.sinceTime;
    if (sinceChunk && sinceChunk.index < rev.index) {
      return [this._since, revTimeId];
    }
    return ["@lastPublished", revTimeId];
  }
  findRangeForNewSince(since) {
    const revChunk = this.revTime;
    if (revChunk && since.index < revChunk.index) {
      return [this.timeline.createTimeId(since), this._rev];
    }
    return [this.timeline.createTimeId(since), null];
  }
  setRevTime(rev) {
    this._rev = rev;
    this._revTime = rev ? this.timeline.parseTimeId(rev) : null;
    if (this._since === "@lastPublished") {
      this._since = null;
      this._sinceTime = null;
    }
  }
  setSinceTime(since) {
    if (since === "@lastPublished") {
      if (typeof this._revTime === "string") {
        this._sinceTime = this._revTime;
      } else {
        this._sinceTime = this.timeline.findLastPublishedBefore(this._revTime);
      }
    } else {
      this._sinceTime = since ? this.timeline.parseTimeId(since) : null;
    }
    this._since = since;
  }
  sinceAttributes() {
    return this._sinceTime && this._reconstruction ? this._reconstruction.startAttributes() : null;
  }
  displayed() {
    return this._revTime && this._reconstruction ? this._reconstruction.endAttributes() : null;
  }
  setReconstruction(since, rev) {
    if (this._reconstruction && this._reconstruction.same(since, rev))
      return;
    this._reconstruction = new Reconstruction(this.timeline, this._aligner.currentDocument, since, rev);
  }
  currentDiff() {
    return this._reconstruction ? this._reconstruction.diff() : null;
  }
  currentObjectDiff() {
    const diff4 = this.currentDiff();
    if (diff4) {
      if (diff4.type === "null")
        return null;
      if (diff4.type !== "object")
        throw new Error("ObjectDiff expected, got ".concat(diff4.type));
    }
    return diff4;
  }
  handleRemoteMutation(ev) {
    this._aligner.appendRemoteSnapshotEvent(ev);
    this.markChange();
    if (this._aligner.acceptsHistory)
      this.start();
  }
  start() {
    if (this._didErr)
      return;
    if (!this._isRunning) {
      this._isRunning = true;
      this.tick().then(() => {
        this._isRunning = false;
      });
    }
  }
  resume() {
    this._isSuspended = false;
  }
  suspend() {
    this._isSuspended = true;
  }
  async tick() {
    var _a4;
    const shouldFetchMore = this._aligner.acceptsHistory && !this.timeline.reachedEarliestEntry && (this.selectionState === "loading" || this._fetchMore || this.timeline.chunkCount <= this._fetchAtLeast) && !this._isSuspended;
    if (!shouldFetchMore) {
      return;
    }
    try {
      await this.fetchMoreTransactions();
    } catch (err) {
      this._didErr = true;
      (_a4 = this.handler) == null ? void 0 : _a4.call(this, err, this);
      return;
    }
    await this.tick();
  }
  async fetchMoreTransactions() {
    const publishedId = this.timeline.publishedId;
    const draftId = this.timeline.draftId;
    const clientConfig = this.client.config();
    const limit = TRANSLOG_ENTRY_LIMIT;
    let queryParams = "tag=sanity.studio.desk.history&effectFormat=mendoza&excludeContent=true&excludeMutations=true&includeIdentifiedDocumentsOnly=true&reverse=true&limit=".concat(limit);
    let tid = this._aligner.earliestTransactionId;
    if (tid) {
      queryParams += "&toTransaction=".concat(tid);
    }
    const transactionsUrl = this.client.getUrl("/data/history/".concat(clientConfig.dataset, "/transactions/").concat(publishedId, ",").concat(draftId, "?").concat(queryParams));
    const stream = await getJsonStream(transactionsUrl, clientConfig.token);
    const reader = stream.getReader();
    let count2 = 0;
    for (; ; ) {
      const result = await reader.read();
      if (result.done)
        break;
      if ("error" in result.value) {
        throw new Error(result.value.error.description || result.value.error.type);
      }
      count2++;
      if (result.value.id === tid) {
        continue;
      }
      if (this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory) {
        return;
      }
      this._aligner.prependHistoryEvent(result.value);
      tid = this._aligner.earliestTransactionId;
    }
    if (this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory) {
      return;
    }
    if (count2 < limit) {
      this._aligner.didReachEarliestEntry();
    }
    this.markChange();
  }
  markChange() {
    var _a4;
    this.timeline.updateChunks();
    this.setRevTime(this._rev);
    this.setSinceTime(this._rev);
    this.version++;
    (_a4 = this.handler) == null ? void 0 : _a4.call(this, null, this);
  }
};
function isSameAnnotation(a, b) {
  if (a && b) {
    return a.author === b.author && a.chunk === b.chunk;
  }
  if (!a && !b) {
    return true;
  }
  return false;
}
function getAttrs(doc) {
  return doc.draft || doc.published;
}
var ArrayContentWrapper = class {
  constructor(content, value, annotation, extractor) {
    this.type = "array";
    this.elements = [];
    this.content = content;
    this.value = value;
    this.annotation = annotation;
    this.extractor = extractor;
    this.length = content.elements.length;
  }
  at(idx) {
    if (idx >= this.length)
      throw new Error("out of bounds");
    const input = this.elements[idx];
    if (input) {
      return input;
    }
    return this.elements[idx] = wrapValue(this.content.elements[idx], this.value[idx], this.extractor);
  }
  annotationAt(idx) {
    const meta = this.content.metas[idx];
    return this.extractor.fromMeta(meta);
  }
};
var ObjectContentWrapper = class {
  constructor(content, value, annotation, extractor) {
    this.type = "object";
    this.fields = {};
    this.content = content;
    this.value = value;
    this.annotation = annotation;
    this.extractor = extractor;
    this.keys = Object.keys(content.fields);
  }
  get(key2) {
    const input = this.fields[key2];
    if (input) {
      return input;
    }
    const value = this.content.fields[key2];
    if (!value)
      return void 0;
    return this.fields[key2] = wrapValue(value, this.value[key2], this.extractor);
  }
};
var StringContentWrapper = class {
  constructor(content, value, annotation, extractor) {
    this.type = "string";
    this.content = content;
    this.value = value;
    this.annotation = annotation;
    this.extractor = extractor;
  }
  sliceAnnotation(start, end) {
    const result = [];
    let idx = 0;
    function push(text, annotation) {
      if (result.length > 0) {
        const lst = result[result.length - 1];
        if (isSameAnnotation(lst.annotation, annotation)) {
          lst.text += text;
          return;
        }
      }
      result.push({ text, annotation });
    }
    for (const part of this.content.parts) {
      const length2 = part.value.length;
      const subStart = Math.max(0, start - idx);
      if (subStart < length2) {
        const subEnd = Math.min(length2, end - idx);
        if (subEnd <= 0)
          break;
        push(part.value.slice(subStart, subEnd), this.extractor.fromValue(part));
      }
      idx += length2;
    }
    return result;
  }
};
function wrapValue(value, raw, extractor) {
  const annotation = extractor.fromValue(value);
  if (value.content) {
    switch (value.content.type) {
      case "array":
        return new ArrayContentWrapper(value.content, raw, annotation, extractor);
      case "object":
        return new ObjectContentWrapper(value.content, raw, annotation, extractor);
      case "string":
        return new StringContentWrapper(value.content, raw, annotation, extractor);
    }
  }
  return wrap3(raw, annotation);
}
function extractAnnotationForFromInput(timeline, firstChunk, meta) {
  if (meta) {
    return annotationForTransactionIndex(timeline, meta.transactionIndex + 1, meta.chunk.index);
  } else if (firstChunk) {
    return annotationForTransactionIndex(timeline, firstChunk.start, firstChunk.index);
  }
  return null;
}
function extractAnnotationForToInput(timeline, meta) {
  if (meta) {
    return annotationForTransactionIndex(timeline, meta.transactionIndex, meta.chunk.index);
  }
  return null;
}
function annotationForTransactionIndex(timeline, idx, chunkIdx) {
  const tx = timeline.transactionByIndex(idx);
  if (!tx)
    return null;
  const chunk = timeline.chunkByTransactionIndex(idx, chunkIdx);
  if (!chunk)
    return null;
  return { chunk, timestamp: tx.timestamp, author: tx.author };
}
function diffValue(timeline, firstChunk, from2, fromRaw, to, toRaw) {
  const fromInput = wrapValue(from2, fromRaw, { fromValue(value) {
    return extractAnnotationForFromInput(timeline, firstChunk, value.endMeta);
  }, fromMeta(meta) {
    return extractAnnotationForFromInput(timeline, firstChunk, meta);
  } });
  const toInput = wrapValue(to, toRaw, { fromValue(value) {
    return extractAnnotationForToInput(timeline, value.startMeta);
  }, fromMeta(meta) {
    return extractAnnotationForToInput(timeline, meta);
  } });
  return diffInput(fromInput, toInput);
}
var TwoEndedArray = class {
  constructor() {
    this._postive = [];
    this._negative = [];
  }
  addToEnd(elem) {
    elem.index = this._postive.length;
    this._postive.push(elem);
  }
  addToBeginning(elem) {
    if (this.length == 0) {
      this.addToEnd(elem);
      return;
    }
    elem.index = -(this._negative.length + 1);
    this._negative.push(elem);
  }
  mergeAtEnd(value, merger) {
    if (this.length === 0) {
      this.addToEnd(value);
      return;
    }
    const idx = this.lastIdx;
    const result = merger(this.get(idx), value);
    if (Array.isArray(result)) {
      this.set(idx, result[0]);
      this.addToEnd(result[1]);
    } else {
      this.set(idx, result);
    }
  }
  mergeAtBeginning(value, merger) {
    if (this.length === 0) {
      this.addToEnd(value);
      return;
    }
    const idx = this.firstIdx;
    const result = merger(value, this.get(idx));
    if (Array.isArray(result)) {
      this.set(idx, result[1]);
      this.addToBeginning(result[0]);
    } else {
      this.set(idx, result);
    }
  }
  removeFromEnd() {
    if (this._postive.length === 0) {
      this._negative.shift();
    } else {
      this._postive.pop();
    }
  }
  has(idx) {
    if (idx >= 0) {
      return idx < this._postive.length;
    }
    return -(idx + 1) < this._negative.length;
  }
  get(idx) {
    if (idx >= 0) {
      return this._postive[idx];
    }
    return this._negative[-(idx + 1)];
  }
  set(idx, value) {
    if (idx >= 0) {
      value.index = idx;
      this._postive[idx] = value;
    } else {
      value.index = idx;
      this._negative[-(idx + 1)] = value;
    }
  }
  get lastIdx() {
    return this._postive.length - 1;
  }
  get last() {
    return this.get(this.lastIdx);
  }
  get firstIdx() {
    return -this._negative.length;
  }
  get first() {
    return this.get(this.firstIdx);
  }
  get length() {
    return this._postive.length + this._negative.length;
  }
};
function canMergeEdit(type) {
  return type === "create" || type === "editDraft";
}
var CHUNK_WINDOW = 5 * 60 * 1e3;
function isWithinMergeWindow(a, b) {
  return Date.parse(b) - Date.parse(a) < CHUNK_WINDOW;
}
function mergeChunk(left, right) {
  if (left.end !== right.start)
    throw new Error("chunks are not next to each other");
  const draftState = combineState(left.draftState, right.draftState);
  const publishedState = combineState(left.publishedState, right.publishedState);
  if (left.type === "delete" && right.type === "editDraft") {
    return [left, { ...right, type: "create", draftState, publishedState }];
  }
  if (right.type === "delete") {
    if (draftState === "missing" && publishedState === "present") {
      return [left, { ...right, type: "discardDraft", draftState, publishedState }];
    }
    if (draftState === "present" && publishedState === "missing") {
      return [left, { ...right, type: "unpublish", draftState, publishedState }];
    }
  }
  if (canMergeEdit(left.type) && right.type === "editDraft" && isWithinMergeWindow(left.endTimestamp, right.startTimestamp)) {
    const authors = /* @__PURE__ */ new Set();
    for (const author of left.authors)
      authors.add(author);
    for (const author of right.authors)
      authors.add(author);
    return { index: 0, id: right.id, type: left.type, start: left.start, end: right.end, startTimestamp: left.startTimestamp, endTimestamp: right.endTimestamp, authors, draftState, publishedState };
  }
  return [left, { ...right, draftState, publishedState }];
}
function getChunkState(effect) {
  const modified = Boolean(effect);
  const deleted = effect && isDeletePatch(effect == null ? void 0 : effect.apply);
  if (deleted) {
    return "deleted";
  }
  if (modified) {
    return "upsert";
  }
  return "unedited";
}
function getChunkType(transaction) {
  const draftState = getChunkState(transaction.draftEffect);
  const publishedState = getChunkState(transaction.publishedEffect);
  if (publishedState === "unedited") {
    if (draftState === "deleted") {
      return "delete";
    }
    if (draftState === "upsert") {
      return "editDraft";
    }
  }
  if (publishedState === "deleted") {
    return "delete";
  }
  if (publishedState === "upsert") {
    if (draftState === "unedited") {
      return "editLive";
    }
    if (draftState === "deleted") {
      return "publish";
    }
    if (draftState === "upsert") {
      return "editLive";
    }
  }
  return "editLive";
}
function chunkFromTransaction(transaction) {
  const modifiedDraft = Boolean(transaction.draftEffect);
  const modifiedPublished = Boolean(transaction.publishedEffect);
  const draftDeleted = transaction.draftEffect && isDeletePatch(transaction.draftEffect.apply);
  const publishedDeleted = transaction.publishedEffect && isDeletePatch(transaction.publishedEffect.apply);
  const type = getChunkType(transaction);
  return { index: 0, id: transaction.id, type, start: transaction.index, end: transaction.index + 1, startTimestamp: transaction.timestamp, endTimestamp: transaction.timestamp, authors: /* @__PURE__ */ new Set([transaction.author]), draftState: modifiedDraft ? draftDeleted ? "missing" : "present" : "unknown", publishedState: modifiedPublished ? publishedDeleted ? "missing" : "present" : "unknown" };
}
function combineState(left, right) {
  return right === "unknown" ? left : right;
}
function isDeletePatch(patch2) {
  return patch2[0] === 0 && patch2[1] === null;
}
var Timeline = class {
  constructor(opts) {
    this.reachedEarliestEntry = false;
    this._transactions = new TwoEndedArray();
    this._chunks = new TwoEndedArray();
    this._possiblePendingTransactions = /* @__PURE__ */ new Map();
    this.publishedId = opts.publishedId;
    this.draftId = "drafts.".concat(opts.publishedId);
    if (opts.enableTrace) {
      this._trace = [];
      this._trace.push({ type: "initial", publishedId: opts.publishedId });
      window.__sanityTimelineTrace = this._trace;
    }
  }
  get chunkCount() {
    return this._chunks.length;
  }
  /** Maps over the chunk from newest to oldest. */
  mapChunks(mapper) {
    const result = [];
    const firstIdx = this._chunks.firstIdx;
    const lastIdx = this._chunks.lastIdx;
    for (let idx = lastIdx; idx >= firstIdx; idx--) {
      result.push(mapper(this._chunks.get(idx), idx));
    }
    return result;
  }
  reset() {
    this._transactions = new TwoEndedArray();
    this._chunks = new TwoEndedArray();
    this._possiblePendingTransactions = /* @__PURE__ */ new Map();
    this._recreateTransactionsFrom = void 0;
    this.reachedEarliestEntry = false;
  }
  /**
  * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
  * come in correct order for their respective version, but has no ordering requirements
  * across draft/published.
  *
  * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
  * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
  * the mutation for the draft is out of order.
  */
  addRemoteMutation(entry) {
    if (this._trace)
      this._trace.push({ type: "addRemoteMutation", event: entry });
    const pending = this._possiblePendingTransactions.get(entry.transactionId);
    const transaction = pending ? pending.transaction : { index: 0, id: entry.transactionId, timestamp: entry.timestamp.toISOString(), author: entry.author };
    if (entry.version === "draft") {
      transaction.draftEffect = entry.effects;
    } else {
      transaction.publishedEffect = entry.effects;
    }
    if (pending) {
      this._possiblePendingTransactions.delete(entry.transactionId);
      this._invalidateTransactionFrom(pending.idx);
    } else {
      this._transactions.addToEnd(transaction);
      this._possiblePendingTransactions.set(entry.transactionId, { transaction, idx: this._transactions.lastIdx });
    }
  }
  addTranslogEntry(event) {
    if (this._trace)
      this._trace.push({ type: "addTranslogEntry", event });
    this._transactions.addToBeginning({ index: 0, id: event.id, author: event.author, timestamp: event.timestamp, draftEffect: event.effects[this.draftId], publishedEffect: event.effects[this.publishedId] });
  }
  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry() {
    if (this._trace)
      this._trace.push({ type: "didReachEarliestEntry" });
    this.reachedEarliestEntry = true;
  }
  /**
  * updateChunks synchronizes the chunks to match the current state
  * of the transactions array. After calling this method you need
  * to invalidate all Chunks.
  */
  updateChunks() {
    if (this._trace)
      this._trace.push({ type: "updateChunks" });
    this._removeInvalidatedChunks();
    this._addChunksFromTransactions();
    this._createInitialChunk();
  }
  _removeInvalidatedChunks() {
    if (this._recreateTransactionsFrom) {
      while (this._chunks.length > 0) {
        const chunk = this._chunks.last;
        if (this._recreateTransactionsFrom < chunk.end) {
          this._chunks.removeFromEnd();
        } else {
          break;
        }
      }
      this._recreateTransactionsFrom = void 0;
    }
  }
  _addChunksFromTransactions() {
    const firstIdx = this._transactions.firstIdx;
    const lastIdx = this._transactions.lastIdx;
    const nextTransactionToChunk = this._chunks.length > 0 ? this._chunks.last.end : firstIdx;
    for (let idx = nextTransactionToChunk; idx <= lastIdx; idx++) {
      const transaction = this._transactions.get(idx);
      this._chunks.mergeAtEnd(chunkFromTransaction(transaction), mergeChunk);
    }
    if (this._chunks.length == 0)
      return;
    const firstTransactionChunked = this._chunks.first.start;
    for (let idx = firstTransactionChunked - 1; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx);
      this._chunks.mergeAtBeginning(chunkFromTransaction(transaction), mergeChunk);
    }
  }
  _invalidateTransactionFrom(idx) {
    if (this._recreateTransactionsFrom === void 0 || idx < this._recreateTransactionsFrom) {
      this._recreateTransactionsFrom = idx;
    }
  }
  _createInitialChunk() {
    var _a4;
    if (this.reachedEarliestEntry) {
      if (((_a4 = this._chunks.first) == null ? void 0 : _a4.type) === "initial")
        return;
      const firstTx = this._transactions.first;
      if (!firstTx)
        return;
      const initialChunk = chunkFromTransaction(firstTx);
      initialChunk.type = "initial";
      initialChunk.id = "@initial";
      initialChunk.end = initialChunk.start;
      this._chunks.addToBeginning(initialChunk);
    }
  }
  /**
  * Resolves a time reference.
  *
  * Note that the chunk returned is only valid if the timeline stays constant.
  * Once the timeline is updated, you must re-parse all references.
  */
  parseTimeId(id4) {
    if (this._chunks.length === 0) {
      return this.reachedEarliestEntry ? "invalid" : "loading";
    }
    const idSegments = id4.split("/", 3);
    const timestampStr = idSegments.shift();
    const chunkId = idSegments.shift();
    const timestamp = Number(timestampStr);
    for (let idx = this._chunks.lastIdx; idx >= this._chunks.firstIdx; idx--) {
      const chunk = this._chunks.get(idx);
      if (chunk.id === chunkId) {
        return chunk;
      }
      if (Date.parse(chunk.endTimestamp) + 60 * 60 * 1e3 < timestamp) {
        return "invalid";
      }
    }
    return this.reachedEarliestEntry ? "invalid" : "loading";
  }
  findLastPublishedBefore(chunk) {
    for (let chunkIdx = chunk ? chunk.index - 1 : this._chunks.lastIdx; chunkIdx >= this._chunks.firstIdx; chunkIdx--) {
      const currentChunk = this._chunks.get(chunkIdx);
      if (currentChunk.type === "publish" || currentChunk.type === "initial") {
        return currentChunk;
      }
    }
    if (!this.reachedEarliestEntry)
      return "loading";
    return this._chunks.first;
  }
  isLatestChunk(chunk) {
    return chunk === this._chunks.last;
  }
  // eslint-disable-next-line class-methods-use-this
  createTimeId(chunk) {
    return "".concat(chunk.endTimestamp.valueOf(), "/").concat(chunk.id);
  }
  lastChunk() {
    return this._chunks.last;
  }
  transactionByIndex(idx) {
    if (!this._transactions.has(idx))
      return null;
    return this._transactions.get(idx);
  }
  chunkByTransactionIndex(idx) {
    let startChunkIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let chunkIdx = startChunkIdx;
    for (; ; ) {
      const chunk = this._chunks.get(chunkIdx);
      if (!chunk)
        throw new Error("transaction does not belong in any chunk");
      if (idx >= chunk.end) {
        chunkIdx++;
      } else if (idx < chunk.start) {
        chunkIdx--;
      } else {
        return chunk;
      }
    }
  }
  replayBackwardsBetween(firstIdx, lastIdx, doc) {
    let draft = doc.draft;
    let published = doc.published;
    for (let idx = lastIdx; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx);
      if (transaction.draftEffect) {
        draft = applyPatch3(draft, transaction.draftEffect.revert);
      }
      if (transaction.publishedEffect) {
        published = applyPatch3(published, transaction.publishedEffect.revert);
      }
    }
    return { draft, published };
  }
  replayBackwardsUntil(firstIdx, doc) {
    return this.replayBackwardsBetween(firstIdx, this._transactions.lastIdx, doc);
  }
  calculateDiff(initialDoc, finalDoc, firstIdx, lastIdx) {
    let draftValue = incrementalPatcher.wrap(initialDoc.draft, null);
    let publishedValue = incrementalPatcher.wrap(initialDoc.published, null);
    const initialValue = getValue2(draftValue, publishedValue);
    const initialAttributes = getAttrs(initialDoc);
    let firstChunk = null;
    for (let chunkIdx = firstIdx; chunkIdx <= lastIdx; chunkIdx++) {
      const chunk = this._chunks.get(chunkIdx);
      if (!firstChunk)
        firstChunk = chunk;
      for (let idx = chunk.start; idx < chunk.end; idx++) {
        const transaction = this._transactions.get(idx);
        const meta = { chunk, transactionIndex: idx };
        const preDraftValue = draftValue;
        const prePublishedValue = publishedValue;
        if (transaction.draftEffect) {
          draftValue = incrementalPatcher.applyPatch(draftValue, transaction.draftEffect.apply, meta);
        }
        if (transaction.publishedEffect) {
          publishedValue = incrementalPatcher.applyPatch(publishedValue, transaction.publishedEffect.apply, meta);
        }
        const didHaveDriaft = incrementalPatcher.getType(preDraftValue) !== "null";
        const haveDraft = incrementalPatcher.getType(draftValue) !== "null";
        const havePublished = incrementalPatcher.getType(publishedValue) !== "null";
        if (havePublished && !haveDraft) {
          publishedValue = incrementalPatcher.rebaseValue(preDraftValue, publishedValue);
        }
        if (haveDraft && !didHaveDriaft) {
          draftValue = incrementalPatcher.rebaseValue(prePublishedValue, draftValue);
        }
      }
    }
    const finalValue = incrementalPatcher.getType(draftValue) === "null" ? publishedValue : draftValue;
    const finalAttributes = getAttrs(finalDoc);
    return diffValue(this, firstChunk, initialValue, initialAttributes, finalValue, finalAttributes);
  }
};
function getValue2(draftValue, publishedValue) {
  return incrementalPatcher.getType(draftValue) === "null" ? publishedValue : draftValue;
}
var documentRevisionCache = /* @__PURE__ */ Object.create(null);
var getHistory = function(client, documentIds) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const ids = Array.isArray(documentIds) ? documentIds : [documentIds];
  const { time: time2, revision } = options;
  if (time2 && revision) {
    throw new Error("getHistory can't handle both time and revision parameters");
  }
  const dataset2 = client.config().dataset;
  let url = "/data/history/".concat(dataset2, "/documents/").concat(ids.join(","));
  if (revision) {
    url = "".concat(url, "?revision=").concat(revision);
  } else {
    const timestamp = time2 || (/* @__PURE__ */ new Date()).toISOString();
    url = "".concat(url, "?time=").concat(timestamp);
  }
  return client.request({ url });
};
var getDocumentAtRevision = (client, documentId, revision) => {
  const publishedId = getPublishedId(documentId);
  const draftId = getDraftId(documentId);
  const cacheKey = "".concat(publishedId, "@").concat(revision);
  const cached = documentRevisionCache[cacheKey];
  if (cached) {
    return cached;
  }
  const dataset2 = client.config().dataset;
  const url = "/data/history/".concat(dataset2, "/documents/").concat(publishedId, ",").concat(draftId, "?revision=").concat(revision);
  const entry = client.request({ url }).then((result) => {
    const documents = result.documents || [];
    const published = documents.find((res) => res._id === publishedId);
    const draft = documents.find((res) => res._id === draftId);
    return draft || published;
  });
  documentRevisionCache[cacheKey] = entry;
  return entry;
};
var getTimelineController = (_ref321) => {
  let { client, documentId, documentType } = _ref321;
  const timeline = new Timeline({ enableTrace: isDev, publishedId: documentId });
  return new TimelineController({ client, documentId, documentType, timeline });
};
var getTransactions = async (client, documentIds) => {
  const ids = Array.isArray(documentIds) ? documentIds : [documentIds];
  const dataset2 = client.config().dataset;
  const query = { excludeContent: "true", includeIdentifiedDocumentsOnly: "true" };
  const url = "/data/history/".concat(dataset2, "/transactions/").concat(ids.join(","));
  const result = await client.request({ url, query });
  const transactions = result.toString("utf8").split("\n").filter(Boolean).map((line) => JSON.parse(line));
  return transactions;
};
var getAllRefIds = (doc) => (0, import_json_reduce.reduce)(doc, (acc, node) => isReference(node) && !acc.includes(node._ref) ? [...acc, node._ref] : acc, []);
function jsonMap(value, mapFn) {
  if (Array.isArray(value)) {
    return mapFn(value.map((item) => jsonMap(item, mapFn)).filter((item) => typeof item !== "undefined"));
  }
  if (isRecord$4(value)) {
    return mapFn(Object.keys(value).reduce((res, key2) => {
      const mappedValue = jsonMap(value[key2], mapFn);
      if (typeof mappedValue !== "undefined") {
        res[key2] = mappedValue;
      }
      return res;
    }, {}));
  }
  return mapFn(value);
}
var mapRefNodes = (doc, mapFn) => jsonMap(doc, (node) => isReference(node) ? mapFn(node) : node);
var removeMissingReferences = (doc, existingIds) => mapRefNodes(doc, (refNode) => {
  const documentExists = existingIds[refNode._ref];
  return documentExists ? refNode : void 0;
});
function restore(client, documentId, targetDocumentId, rev) {
  return from(getDocumentAtRevision(client, documentId, rev)).pipe(mergeMap((documentAtRevision) => {
    if (!documentAtRevision) {
      throw new Error("Unable to find document with ID ".concat(documentId, " at revision ").concat(rev));
    }
    const existingIdsQuery = getAllRefIds(documentAtRevision).map((refId) => '"'.concat(refId, '": defined(*[_id=="').concat(refId, '"]._id)')).join(",");
    return client.observable.fetch("{".concat(existingIdsQuery, "}")).pipe(map((existingIds) => removeMissingReferences(documentAtRevision, existingIds)));
  }), map((documentAtRevision) => {
    const { _updatedAt, ...document2 } = documentAtRevision;
    return { ...document2, _id: targetDocumentId };
  }), mergeMap((restoredDraft) => client.observable.createOrReplace(restoredDraft, { visibility: "async" })));
}
function createHistoryStore(_ref322) {
  let { client } = _ref322;
  return { getDocumentAtRevision: (documentId, revision) => getDocumentAtRevision(client, documentId, revision), getHistory: (documentIds, options) => getHistory(client, documentIds, options), getTransactions: (documentIds) => getTransactions(client, documentIds), restore: (id4, targetId, rev) => restore(client, id4, targetId, rev), getTimelineController };
}
var INITIAL_TIMELINE_STATE = { chunks: [], diff: null, hasMoreChunks: null, isLoading: false, isPristine: null, lastNonDeletedRevId: null, onOlderRevision: false, realRevChunk: null, revTime: null, selectionState: "inactive", sinceAttributes: null, sinceTime: null, timelineDisplayed: null, timelineReady: false };
function useTimelineStore(_ref323) {
  let { documentId, documentType, onError, rev, since } = _ref323;
  const historyStore = useHistoryStore();
  const snapshotsSubscriptionRef = (0, import_react51.useRef)(null);
  const timelineStateRef = (0, import_react51.useRef)(INITIAL_TIMELINE_STATE);
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const controller = (0, import_react51.useMemo)(() => historyStore.getTimelineController({ client, documentId, documentType }), [client, documentId, documentType, historyStore]);
  const timelineController$ = (0, import_react51.useMemo)(() => new BehaviorSubject(controller), [controller]);
  (0, import_react51.useEffect)(() => {
    controller.setRange(since || null, rev || null);
    timelineController$.next(controller);
    controller.handler = (err, innerController) => {
      if (err) {
        timelineController$.error(err);
      } else {
        setTimeout(() => {
          innerController.setRange(since || null, rev || null);
          timelineController$.next(innerController);
        }, 0);
      }
    };
    controller.resume();
    return () => controller.suspend();
  }, [rev, since, controller, timelineController$]);
  (0, import_react51.useEffect)(() => {
    if (!snapshotsSubscriptionRef.current) {
      snapshotsSubscriptionRef.current = remoteSnapshots(client, { draftId: "drafts.".concat(documentId), publishedId: documentId }, documentType).subscribe((ev) => {
        controller.handleRemoteMutation(ev);
      });
    }
    return () => {
      if (snapshotsSubscriptionRef.current) {
        snapshotsSubscriptionRef.current.unsubscribe();
        snapshotsSubscriptionRef.current = null;
      }
    };
  }, [client, controller, documentId, documentType]);
  const timelineStore = (0, import_react51.useMemo)(() => {
    return { findRangeForRev: (chunk) => controller.findRangeForNewRev(chunk), findRangeForSince: (chunk) => controller.findRangeForNewSince(chunk), loadMore: () => {
      controller.setLoadMore(true);
      timelineStateRef.current.isLoading = true;
    }, getSnapshot: () => timelineStateRef.current, subscribe: (callback) => {
      const subscription = timelineController$.pipe(
        // Manually stop loading transactions in TimelineController, otherwise transaction history
        // will continue to be fetched  even if unwanted.
        tap((innerController) => innerController.setLoadMore(false)),
        map((innerController) => {
          var _a4;
          const chunks = innerController.timeline.mapChunks((c) => c);
          const lastNonDeletedChunk = chunks.filter((chunk) => !["delete", "initial"].includes(chunk.type));
          const hasMoreChunks = !innerController.timeline.reachedEarliestEntry;
          const timelineReady = !["invalid", "loading"].includes(innerController.selectionState);
          return { chunks, diff: innerController.sinceTime ? innerController.currentObjectDiff() : null, isLoading: false, isPristine: timelineReady ? chunks.length === 0 && hasMoreChunks === false : null, hasMoreChunks: !innerController.timeline.reachedEarliestEntry, lastNonDeletedRevId: (_a4 = lastNonDeletedChunk == null ? void 0 : lastNonDeletedChunk[0]) == null ? void 0 : _a4.id, onOlderRevision: innerController.onOlderRevision(), realRevChunk: innerController.realRevChunk, revTime: innerController.revTime, selectionState: innerController.selectionState, sinceAttributes: innerController.sinceAttributes(), sinceTime: innerController.sinceTime, timelineDisplayed: innerController.displayed(), timelineReady };
        }),
        // Only emit (and in turn, re-render) when values have changed
        distinctUntilChanged(import_react_fast_compare.default),
        // Emit initial timeline state whenever we encounter an error in TimelineController's `handler` callback.
        // A little ham-fisted, but also reflects how we handle timeline errors in the UI
        // (i.e. no timeline state or diffs are rendered and we revert to the current editable document)
        catchError((err) => {
          onError == null ? void 0 : onError(err);
          return of(INITIAL_TIMELINE_STATE);
        }),
        tap((timelineState) => {
          timelineStateRef.current = timelineState;
        }),
        // Trigger callback function required by `useSyncExternalStore` to denote when to re-render
        tap(callback)
      ).subscribe();
      return () => subscription.unsubscribe();
    } };
  }, [controller, onError, timelineController$]);
  return timelineStore;
}
function useTimelineSelector(timelineStore, selector) {
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(timelineStore.subscribe, timelineStore.getSnapshot, null, selector);
}
function createProjectStore(context) {
  const { client } = context;
  const projectId2 = client.config().projectId;
  const versionedClient = client.withConfig({ apiVersion: "2021-12-15" });
  function get6() {
    return versionedClient.observable.request({ url: "/projects/".concat(projectId2) });
  }
  function getDatasets() {
    return versionedClient.observable.request({ url: "/projects/".concat(projectId2, "/datasets") });
  }
  return { get: get6, getDatasets };
}
function useProject() {
  const projectStore = useProjectStore();
  const [value, setValue] = (0, import_react51.useState)(null);
  (0, import_react51.useEffect)(() => {
    const project$ = projectStore.get();
    const sub2 = project$.subscribe(setValue);
    return () => sub2.unsubscribe();
  }, [projectStore]);
  return { value };
}
function useProjectDatasets() {
  const projectStore = useProjectStore();
  const [value, setValue] = (0, import_react51.useState)(null);
  (0, import_react51.useEffect)(() => {
    const project$ = projectStore.getDatasets();
    const sub2 = project$.subscribe(setValue);
    return () => sub2.unsubscribe();
  }, [projectStore]);
  return { value };
}
var tryParse = (val, defValue) => {
  try {
    return JSON.parse(val);
  } catch (err) {
    console.warn("Failed to parse settings: ".concat(err.message));
    return defValue;
  }
};
var get$1 = (key2, defValue) => {
  const val = localStorage.getItem(key2);
  return of(val === null ? defValue : tryParse(val, defValue));
};
var set$1 = (key2, nextValue) => {
  if (typeof nextValue === "undefined" || nextValue === null) {
    localStorage.removeItem(key2);
  } else {
    localStorage.setItem(key2, JSON.stringify(nextValue));
  }
  return of(nextValue);
};
var localStorageBackend = { get: get$1, set: set$1 };
var DB = /* @__PURE__ */ Object.create(null);
var get5 = (key2, defValue) => of(key2 in DB ? DB[key2] : defValue);
var set3 = (key2, nextValue) => {
  if (typeof nextValue === "undefined" || nextValue === null) {
    delete DB[key2];
  } else {
    DB[key2] = nextValue;
  }
  return of(nextValue);
};
var memoryBackend = { get: get5, set: set3 };
function resolveBackend() {
  return supportsLocalStorage ? localStorageBackend : memoryBackend;
}
function createSettingsStore() {
  const storageBackend = resolveBackend();
  const set$ = new Subject();
  const prefixNamespace = (ns, key2) => "".concat(ns, "::").concat(key2);
  const updates$ = set$.pipe(switchMap((event) => storageBackend.set(event.key, event.value).pipe(map((nextValue) => ({ key: event.key, value: nextValue })))));
  const listen2 = (key2, defValue) => {
    return merge(storageBackend.get(key2, defValue), updates$.pipe(filter((update) => update.key === key2), map((update) => update.value)));
  };
  const set4 = (key2, value) => {
    set$.next({ key: key2, value });
  };
  const forNamespace = (ns) => {
    return { forKey: (key2) => {
      const namespacedKey = prefixNamespace(ns, key2);
      return { listen: (defaultValue) => listen2(namespacedKey, defaultValue), set: (value) => set4(namespacedKey, value), del: () => set4(namespacedKey, void 0) };
    }, listen: (key2, defaultValue) => {
      return listen2(prefixNamespace(ns, key2), defaultValue);
    }, set: (key2, value) => {
      return set4(prefixNamespace(ns, key2), value);
    }, del: (key2) => {
      return set4(prefixNamespace(ns, key2), void 0);
    }, forNamespace: (sub2) => {
      return forNamespace(prefixNamespace(ns, sub2));
    } };
  };
  return { forNamespace };
}
var INTERNAL_USER_IDS = [{ id: "<system>", displayName: "Sanity", imageUrl: "https://public.sanity.io/logos/favicon-192.png" }];
function createUserStore(_ref324) {
  let { client: _client3, currentUser } = _ref324;
  const client = _client3.withConfig({ apiVersion: "2021-06-07" });
  const userLoader = new import_dataloader.default(async (userIds) => {
    const value = await client.request({ uri: "/users/".concat(userIds.join(",")), withCredentials: true, tag: "users.get" });
    const response = Array.isArray(value) ? value : [value];
    const users = response.reduce((acc, next) => {
      if (next == null ? void 0 : next.id) {
        acc[next.id] = next;
      }
      return acc;
    }, {});
    return userIds.map((id4) => users[id4] || null);
  }, { batchScheduleFn: (cb) => (0, import_raf.default)(cb) });
  const userFromCurrentUser = currentUser && { id: currentUser.id, displayName: currentUser.name, imageUrl: currentUser.profileImage };
  userLoader.prime("me", userFromCurrentUser);
  if (userFromCurrentUser == null ? void 0 : userFromCurrentUser.id) {
    userLoader.prime(userFromCurrentUser.id, userFromCurrentUser);
  }
  INTERNAL_USER_IDS.forEach((user) => userLoader.prime(user.id, user));
  return { getUser: async (userId) => {
    try {
      return await userLoader.load(userId);
    } catch (err) {
      if (err.statusCode === 403) {
        return Promise.resolve(null);
      }
      throw err;
    }
  }, getUsers: async (userIds) => {
    const results = await userLoader.loadMany(userIds);
    return results.filter((result) => isRecord$4(result) && typeof result.id === "string");
  } };
}
var USERIDS = [
  "pqSMwf6hH",
  "pnLYqNfv5",
  "priDVVmy8",
  "p0NFOU0j8",
  "pTDl2jw8d",
  "pHMeQnTse",
  "pDQYzJbyS",
  "pZyoPHKUs",
  "p4Tyi2Be5",
  "pb9vii060",
  "pE8yhOisw",
  "p7Fd2C6Cj",
  "p3exSgYCx",
  "pbIQRYViC",
  "p8GJaTEhN",
  "p27ewL8aM",
  "pYg97z75S",
  "pdLr4quHv",
  "pkJXiDgg6",
  "pkl4UAKcA",
  // Included to ensure we handle the case when a user profile cannot
  // be fetched due to insufficient privileges or similar
  "pNoExists"
];
var PATHS = [["nested", "first"], ["nested", "second"], ["nestedArray", { _key: "565c867c8dac" }, "arrayNo1", { _key: "a645548a8f01" }, "arrayNo1", { _key: "1685e372c40f" }, "fieldNo0"], ["nestedArray", { _key: "565c867c8dac" }, "fieldNo0"], ["nestedArray", { _key: "565c867c8dac" }, "arrayNo19", { _key: "a02e7a93e2a2" }, "fieldNo0"], ["nestedArray", { _key: "565c867c8dac" }, "arrayNo19", { _key: "a02e7a93e2a2" }, "fieldNo19"], ["address", "country"], ["address", "street"], ["customInputWithDefaultPresence", "row3", "cell3"]];
var mock$ = defer(() => timer(0, 1e4)).pipe(mergeMapTo(USERIDS), map((id4, n) => ({ type: "state", userId: id4, sessionId: id4 + n, timestamp: (/* @__PURE__ */ new Date()).toISOString(), locations: [{ type: "document", documentId: "presence-debug", lastActiveAt: (/* @__PURE__ */ new Date()).toISOString(), path: (0, import_sample.default)(PATHS) }] })), shareReplay());
var handleIncomingMessage = (event) => {
  if (event.type === "rollCall") {
    return { type: "rollCall", userId: event.i, sessionId: event.session };
  }
  if (event.type === "state") {
    const { sessionId: sessionId2, locations } = event.m;
    return { type: "state", userId: event.i, sessionId: sessionId2, timestamp: (/* @__PURE__ */ new Date()).toISOString(), locations };
  }
  if (event.type === "disconnect") {
    return { type: "disconnect", userId: event.i, sessionId: event.m.session, timestamp: (/* @__PURE__ */ new Date()).toISOString() };
  }
  throw new Error("Got unknown presence event: ".concat(JSON.stringify(event)));
};
var createBifurTransport = (bifur, sessionId2) => {
  const incomingEvents$ = bifur.request("presence").pipe(map(handleIncomingMessage));
  const dispatchMessage = (message) => {
    if (message.type === "rollCall") {
      return bifur.request("presence_rollcall", { session: sessionId2 });
    }
    if (message.type === "state") {
      return bifur.request("presence_announce", { data: { locations: message.locations, sessionId: sessionId2 } });
    }
    if (message.type === "disconnect") {
      return bifur.request("presence_disconnect", { session: sessionId2 });
    }
    return EMPTY;
  };
  return [incomingEvents$.pipe(share()), dispatchMessage];
};
var KEY = "presence_session_id";
var generate = () => nanoid(16);
function getSessionId() {
  try {
    return window.sessionStorage.getItem(KEY);
  } catch (err) {
  }
  return null;
}
function setSessionId(id4) {
  try {
    window.sessionStorage.setItem(KEY, id4);
  } catch (err) {
  }
  return id4;
}
var SESSION_ID = getSessionId() || setSessionId(generate());
function __tmp_wrap_presenceStore(context) {
  const { bifur, connectionStatusStore, userStore } = context;
  const [presenceEvents$, sendMessage] = createBifurTransport(bifur, SESSION_ID);
  const currentLocation$ = new BehaviorSubject([]);
  const locationChange$ = currentLocation$.pipe(distinctUntilChanged());
  const setLocation = (nextLocation) => {
    currentLocation$.next(nextLocation);
  };
  const reportLocations = (locations) => sendMessage({ type: "state", locations });
  const requestRollCall = () => sendMessage({ type: "rollCall" });
  const rollCallRequests$ = presenceEvents$.pipe(
    filter((event) => event.type === "rollCall"),
    // do not respond to my own rollcall requests
    filter((event) => event.sessionId !== SESSION_ID)
  );
  const REPORT_MIN_INTERVAL = 3e4;
  const reportLocationInterval$ = timer(0, REPORT_MIN_INTERVAL);
  const reportLocation$ = defer(() => merge(locationChange$, rollCallRequests$)).pipe(switchMap(() => reportLocationInterval$), withLatestFrom(currentLocation$), map((_ref325) => {
    let [, locations] = _ref325;
    return locations;
  }), auditTime(200), switchMap((locations) => reportLocations(locations)), mergeMapTo(EMPTY), share());
  const myRollCall$ = defer(() => requestRollCall()).pipe(mergeMapTo(EMPTY));
  const connectionChange$ = connectionStatusStore.connectionStatus$.pipe(map((status) => status.type), filter((statusType) => statusType === "connected" || statusType === "error"), distinctUntilChanged());
  const debugPresenceParam$ = debugParams$.pipe(map((args) => args.find((arg) => arg.startsWith("presence="))), map((arg) => (arg == null ? void 0 : arg.split("presence=")[1].split(",").map((r2) => r2.trim())) || []));
  const useMock$ = debugPresenceParam$.pipe(filter((args) => args.includes("fake_others")), tap(() => {
    console.log('Faking other users present in the studio. They will hang out in the document with _type: "presence" and _id: "presence-debug"');
  }), switchMapTo(mock$));
  const debugIntrospect$ = debugPresenceParam$.pipe(map((args) => args.includes("show_own")));
  const syncEvent$ = merge(myRollCall$, presenceEvents$).pipe(filter((event) => event.type === "state" || event.type === "disconnect"));
  const stateEventToSession = (stateEvent) => {
    return { lastActiveAt: stateEvent.timestamp, locations: stateEvent.locations, sessionId: stateEvent.sessionId, userId: stateEvent.userId };
  };
  const states$ = merge(syncEvent$, useMock$).pipe(scan((keyed, event) => event.type === "disconnect" ? (0, import_omit4.default)(keyed, event.sessionId) : { ...keyed, [event.sessionId]: stateEventToSession(event) }, {}));
  const allSessions$ = connectionChange$.pipe(switchMap((status) => status === "connected" ? merge(states$, reportLocation$) : NEVER), map((keyedSessions) => Object.values(keyedSessions)), switchMap((sessions) => {
    const userIds = (0, import_uniq4.default)(sessions.map((sess) => sess.userId));
    return from(userStore.getUsers(userIds)).pipe(map((users) => sessions.map((session) => ({
      // eslint-disable-next-line max-nested-callbacks
      user: users.find((res) => res.id === session.userId),
      session
    })).filter(userSessionPairHasUser)));
  }), takeUntil(fromEvent(window, "beforeunload").pipe(switchMap(() => sendMessage({ type: "disconnect" })))), shareReplay({ refCount: true, bufferSize: 1 }));
  function userSessionPairHasUser(pair) {
    return Boolean(pair.user && pair.session);
  }
  const globalPresence$ = allSessions$.pipe(map((sessions) => {
    const grouped = (0, import_groupBy.default)(sessions.map((s) => s.session), (e2) => e2.userId);
    return Object.keys(grouped).map((userId) => {
      var _a4;
      return { user: (_a4 = sessions.find((s) => s.user.id === userId)) == null ? void 0 : _a4.user, sessions: grouped[userId] };
    });
  }), withLatestFrom(debugIntrospect$), map((_ref326) => {
    let [userAndSessions, debugIntrospect] = _ref326;
    return userAndSessions.filter((userAndSession) => {
      if (debugIntrospect) {
        return true;
      }
      const isCurrent = userAndSession.sessions.some((sess) => sess.sessionId === SESSION_ID);
      return !isCurrent;
    });
  }), map((userAndSessions) => userAndSessions.map((userAndSession) => {
    var _a4;
    return { user: userAndSession.user, status: "online", lastActiveAt: (_a4 = userAndSession.sessions.sort()[0]) == null ? void 0 : _a4.lastActiveAt, locations: (0, import_flatten5.default)((userAndSession.sessions || []).map((session) => session.locations || [])).map((location) => ({ type: location.type, documentId: location.documentId, path: location.path, lastActiveAt: location.lastActiveAt })).reduce((prev, curr) => prev.concat(curr), []) };
  })));
  const documentPresence = (documentId) => {
    return allSessions$.pipe(withLatestFrom(debugIntrospect$), switchMap((_ref327) => {
      let [userAndSessions, debugIntrospect] = _ref327;
      return from(userAndSessions).pipe(filter((userAndSession) => debugIntrospect || userAndSession.session.sessionId !== SESSION_ID), flatMap((userAndSession) => (userAndSession.session.locations || []).filter((item) => item.documentId === documentId).map((location) => ({ user: userAndSession.user, lastActiveAt: userAndSession.session.lastActiveAt, path: location.path || [], sessionId: userAndSession.session.sessionId }))), toArray());
    }));
  };
  return { setLocation, reportLocations, debugPresenceParam$, globalPresence$, documentPresence };
}
function useUserStore() {
  const { getClient, currentUser } = useSource();
  const resourceCache = useResourceCache();
  const client = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return (0, import_react51.useMemo)(() => {
    const userStore = resourceCache.get({ namespace: "userStore", dependencies: [client, currentUser] }) || createUserStore({ client, currentUser });
    resourceCache.set({ namespace: "userStore", dependencies: [client, currentUser], value: userStore });
    return userStore;
  }, [client, currentUser, resourceCache]);
}
function useGrantsStore() {
  const { getClient } = useSource();
  const client = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const currentUser = useCurrentUser();
  const resourceCache = useResourceCache();
  return (0, import_react51.useMemo)(() => {
    const grantsStore = resourceCache.get({ namespace: "grantsStore", dependencies: [client, currentUser] }) || createGrantsStore({ client, currentUser });
    resourceCache.set({ namespace: "grantsStore", dependencies: [client, currentUser], value: grantsStore });
    return grantsStore;
  }, [client, currentUser, resourceCache]);
}
function useHistoryStore() {
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const resourceCache = useResourceCache();
  return (0, import_react51.useMemo)(() => {
    const historyStore = resourceCache.get({ namespace: "historyStore", dependencies: [client] }) || createHistoryStore({ client });
    resourceCache.set({ namespace: "historyStore", dependencies: [client], value: historyStore });
    return historyStore;
  }, [client, resourceCache]);
}
function useDocumentPreviewStore() {
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const resourceCache = useResourceCache();
  return (0, import_react51.useMemo)(() => {
    const documentPreviewStore = resourceCache.get({ namespace: "documentPreviewStore", dependencies: [client] }) || createDocumentPreviewStore({ client });
    resourceCache.set({ namespace: "documentPreviewStore", dependencies: [client], value: documentPreviewStore });
    return documentPreviewStore;
  }, [client, resourceCache]);
}
function useDocumentStore() {
  const { getClient, i18n } = useSource();
  const schema = useSchema();
  const templates = useTemplates();
  const resourceCache = useResourceCache();
  const historyStore = useHistoryStore();
  const documentPreviewStore = useDocumentPreviewStore();
  return (0, import_react51.useMemo)(() => {
    const documentStore = resourceCache.get({ namespace: "documentStore", dependencies: [getClient, documentPreviewStore, historyStore, schema, i18n] }) || createDocumentStore({ getClient, documentPreviewStore, historyStore, initialValueTemplates: templates, schema, i18n });
    resourceCache.set({ namespace: "documentStore", dependencies: [getClient, documentPreviewStore, historyStore, schema, i18n], value: documentStore });
    return documentStore;
  }, [getClient, documentPreviewStore, historyStore, resourceCache, schema, templates, i18n]);
}
function useConnectionStatusStore() {
  const { bifur } = useSource().__internal;
  const resourceCache = useResourceCache();
  return (0, import_react51.useMemo)(() => {
    const connectionStatusStore = resourceCache.get({ namespace: "connectionStatusStore", dependencies: [bifur] }) || createConnectionStatusStore({ bifur });
    resourceCache.set({ namespace: "connectionStatusStore", dependencies: [bifur], value: connectionStatusStore });
    return connectionStatusStore;
  }, [bifur, resourceCache]);
}
function usePresenceStore() {
  const { __internal: { bifur } } = useSource();
  const resourceCache = useResourceCache();
  const userStore = useUserStore();
  const connectionStatusStore = useConnectionStatusStore();
  return (0, import_react51.useMemo)(() => {
    const presenceStore = resourceCache.get({ namespace: "presenceStore", dependencies: [bifur, connectionStatusStore, userStore] }) || __tmp_wrap_presenceStore({ bifur, connectionStatusStore, userStore });
    resourceCache.set({ namespace: "presenceStore", dependencies: [bifur, connectionStatusStore, userStore], value: presenceStore });
    return presenceStore;
  }, [bifur, connectionStatusStore, resourceCache, userStore]);
}
function useProjectStore() {
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const resourceCache = useResourceCache();
  return (0, import_react51.useMemo)(() => {
    const projectStore = resourceCache.get({ namespace: "projectStore", dependencies: [client] }) || createProjectStore({ client });
    resourceCache.set({ namespace: "projectStore", dependencies: [client], value: projectStore });
    return projectStore;
  }, [client, resourceCache]);
}
function useSettingsStore() {
  const resourceCache = useResourceCache();
  const workspace = useWorkspace();
  return (0, import_react51.useMemo)(() => {
    const settingsStore = resourceCache.get({ dependencies: [workspace], namespace: "settingsStore" }) || createSettingsStore();
    resourceCache.set({ dependencies: [workspace], namespace: "settingsStore", value: settingsStore });
    return settingsStore;
  }, [resourceCache, workspace]);
}
function useGlobalPresence() {
  const [presence, setPresence] = (0, import_react51.useState)([]);
  const presenceStore = usePresenceStore();
  (0, import_react51.useEffect)(() => {
    const subscription = presenceStore.globalPresence$.subscribe(setPresence);
    return () => {
      subscription.unsubscribe();
    };
  }, [presenceStore]);
  return presence;
}
function useDocumentPresence(documentId) {
  const presenceStore = usePresenceStore();
  const [presence, setPresence] = (0, import_react51.useState)([]);
  (0, import_react51.useEffect)(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(setPresence);
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  return presence;
}
function SpinnerWithText(props2) {
  const { text } = props2;
  return (0, import_jsx_runtime6.jsxs)(Flex, { direction: "row", justify: "center", align: "center", children: [(0, import_jsx_runtime6.jsx)(Spinner, {}), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { children: text }) })] });
}
var INITIAL_STATE = { referringDocuments: [], isLoading: true };
function useReferringDocuments(id4) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.listenQuery("*[references($docId)] [0...101]", { docId: id4 }, { tag: "use-referring-documents" }).pipe(map((docs) => ({ referringDocuments: docs, isLoading: false })), startWith(INITIAL_STATE)), [documentStore, id4], INITIAL_STATE);
}
var AssetUsageList = (_ref328) => {
  let { asset, assetType, referringDocuments } = _ref328;
  const { t: t3 } = useTranslation2();
  const count2 = referringDocuments.length;
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Card, { borderBottom: true, marginTop: 2, paddingBottom: 2, marginBottom: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: [1, 1, 2, 2], as: "h2", weight: "regular", children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "asset-source.usage-list.documents-using-".concat(assetType), context: asset.originalFilename ? "named" : "unnamed", values: { filename: asset.originalFilename, count: count2 } }) }) }), referringDocuments.map((document2) => (0, import_jsx_runtime6.jsx)(DocumentLink, { document: document2 }, document2._id))] });
};
var DocumentLink = (_ref329) => {
  let { document: document2 } = _ref329;
  const schema = useSchema();
  const LinkComponent = (0, import_react51.useCallback)((linkProps) => (0, import_jsx_runtime6.jsx)(IntentLink, { ...linkProps, params: { id: document2._id, type: document2._type }, intent: "edit" }), [document2]);
  return (0, import_jsx_runtime6.jsx)(Card, { as: LinkComponent, paddingY: 2, paddingX: 1, radius: 2, "data-as": "a", tabIndex: 0, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", gap: 2, children: (0, import_jsx_runtime6.jsx)(Preview, { layout: "default", value: { _type: "reference", _ref: document2._id }, schemaType: schema.get(document2._type) }) }) }, document2._id);
};
var STYLE_ASSET_IMAGE = { maxWidth: "100%", height: "120px", objectFit: "contain", objectPosition: "center" };
var STYLE_CONFIRM_CARD = { gridColumn: "span 1", overflow: "hidden", display: "flex", alignSelf: "center", justifyContent: "center" };
var STYLE_IMAGE_WRAPPER = { height: "100%" };
var ConfirmMessage = (_ref330) => {
  let { asset, assetType, hasResults = false } = _ref330;
  const isImage2 = assetType === "image";
  const { t: t3 } = useTranslation2();
  if (hasResults) {
    return (0, import_jsx_runtime6.jsx)(Card, { tone: "caution", padding: [3, 3, 4], border: true, radius: 2, marginBottom: 3, children: (0, import_jsx_runtime6.jsxs)(Grid, { columns: 3, gap: [2, 3, 4], children: [(0, import_jsx_runtime6.jsxs)(Flex, { gap: [3, 4], align: "center", style: { gridColumn: isImage2 ? "span 2" : "span 3" }, children: [(0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("asset-source.delete-dialog.usage-list.warning-".concat(assetType, "-is-in-use"), { context: asset.originalFilename ? "named" : "unnamed", filename: asset.originalFilename }) })] }), isImage2 && (0, import_jsx_runtime6.jsx)(Card, { __unstable_checkered: true, border: true, radius: 1, style: STYLE_CONFIRM_CARD, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "center", style: STYLE_IMAGE_WRAPPER, children: (0, import_jsx_runtime6.jsx)("img", { src: "".concat(asset.url, "?w=200"), style: STYLE_ASSET_IMAGE, alt: t3("asset-source.usage-list.image-alt"), referrerPolicy: "strict-origin-when-cross-origin" }) }) })] }) });
  }
  return (0, import_jsx_runtime6.jsx)(Card, { paddingX: [2, 3, 4], paddingY: [3, 3, 3, 4], children: (0, import_jsx_runtime6.jsxs)(Grid, { columns: 3, gap: 3, children: [(0, import_jsx_runtime6.jsx)(Flex, { style: { gridColumn: isImage2 ? "span 2" : "span 3" }, align: "center", children: (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "asset-source.delete-dialog.usage-list.confirm-delete-".concat(assetType), context: asset.originalFilename ? "named" : "unnamed", values: { filename: asset.originalFilename } }) }) }), isImage2 && (0, import_jsx_runtime6.jsx)(Card, { __unstable_checkered: true, border: true, radius: 1, style: STYLE_CONFIRM_CARD, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "center", style: STYLE_IMAGE_WRAPPER, children: (0, import_jsx_runtime6.jsx)("img", { src: "".concat(asset.url, "?w=200"), style: STYLE_ASSET_IMAGE, alt: t3("asset-source.asset-list.table.preview-alt"), referrerPolicy: "strict-origin-when-cross-origin" }) }) })] }) });
};
function AssetDeleteDialog(_ref331) {
  let { asset, assetType, isDeleting = false, onClose, onDelete } = _ref331;
  const { isLoading, referringDocuments } = useReferringDocuments(asset._id);
  const publishedDocuments = (0, import_react51.useMemo)(() => {
    const drafts = referringDocuments.reduce((acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc, []);
    return referringDocuments.filter((doc) => !drafts.includes(doc._id));
  }, [referringDocuments]);
  const hasResults = publishedDocuments.length > 0;
  const { t: t3 } = useTranslation2();
  const footer = (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsxs)(Grid, { padding: 2, gap: 2, columns: 2, children: [(0, import_jsx_runtime6.jsx)(Button, { mode: "bleed", text: t3("asset-source.delete-dialog.action.cancel"), onClick: onClose }), (0, import_jsx_runtime6.jsx)(Button, { text: t3("asset-source.delete-dialog.action.delete"), tone: "critical", icon: TrashIcon, onClick: onDelete, loading: isDeleting, disabled: hasResults })] }), [hasResults, isDeleting, onClose, onDelete, t3]);
  return (0, import_jsx_runtime6.jsx)(Dialog, { __unstable_autoFocus: isLoading, footer, header: t3("asset-source.delete-dialog.header", { context: assetType }), id: "asset-dialog", onClickOutside: onClose, onClose, width: 1, children: isLoading ? (0, import_jsx_runtime6.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime6.jsx)(SpinnerWithText, { text: t3("asset-source.delete-dialog.loading") }) }) : (0, import_jsx_runtime6.jsxs)(Stack, { paddingX: hasResults ? [2, 3, 4] : 0, paddingY: hasResults ? [3, 3, 3, 4] : 0, space: 1, children: [(0, import_jsx_runtime6.jsx)(ConfirmMessage, { asset, assetType, hasResults }), hasResults && (0, import_jsx_runtime6.jsx)(AssetUsageList, { asset, referringDocuments: publishedDocuments, assetType })] }) });
}
var MENU_POPOVER_PROPS = { portal: true, placement: "right" };
function AssetMenu(_ref332) {
  let { isSelected, border: border2 = true, onAction } = _ref332;
  const triggerButtonMode = isSelected ? "default" : "bleed";
  const triggerButtonTone = isSelected ? "primary" : "default";
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { padding: 2, mode: border2 ? "ghost" : triggerButtonMode, icon: EllipsisVerticalIcon, tone: border2 ? "default" : triggerButtonTone }), id: "asset-menu", menu: (0, import_jsx_runtime6.jsxs)(Menu, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("asset-source.asset-list.menu.show-usage"), icon: LinkIcon, onClick: () => {
    onAction({ type: "showUsage" });
  } }), (0, import_jsx_runtime6.jsx)(MenuItem, { text: t3("asset-source.asset-list.menu.delete"), icon: TrashIcon, tone: "critical", onClick: () => {
    onAction({ type: "delete" });
  } })] }), popover: MENU_POPOVER_PROPS });
}
var MIME_TYPES = {
  // Images
  "image/bmp": { title: "Bitmap Image" },
  "image/jpeg": { title: "JPEG Image" },
  "image/gif": { title: "GIF Image" },
  "image/vnd.microsoft.icon": { title: "Icon" },
  "image/png": { title: "PNG Image" },
  "image/svg+xml": { title: "SVG Image" },
  "image/webp": { title: "WebP Image" },
  "image/tiff": { title: "TIFF Image" },
  "image/heic": { title: "HEIC Image" },
  // Audio
  "audio/midi": { title: "MIDI Audio" },
  "audio/midi-x": { title: "MIDI Audio" },
  "audio/mpeg": { title: "MP3 Audio" },
  "audio/ogg": { title: "OGG Audio" },
  "audio/wav": { title: "WAV Audio" },
  "audio/webm": { title: "WebM Audio" },
  "audio/aac": { title: "AAC Audio" },
  // Video
  "video/x-msvideo": { title: "AVI Video" },
  "video/mp4": { title: "MP4 Video" },
  "video/mpeg": { title: "MPEG Video" },
  "video/ogg": { title: "OGG Video" },
  "video/webm": { title: "WebM Video" },
  "video/quicktime": { title: "QuickTime Video" },
  // Documents
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { title: "Excel Spreadsheet" },
  "application/vnd.ms-excel": { title: "Excel Spreadsheet" },
  "text/plain": { title: "Text" },
  "text/javascript": { title: "JavaScript" },
  "text/markdown": { title: "Markdown" },
  "text/csv": { title: "CSV" },
  "text/css": { title: "CSS" },
  "application/pdf": { title: "PDF Document" },
  "application/xml": { title: "XML Document" },
  "text/xml": { title: "XML Document" },
  "application/zip": { title: "ZIP Archive" },
  "application/vnd.rar": { title: "RAR Archive" },
  "application/x-7z-compressed": { title: "7-zip Archive" },
  "application/octet-stream": { title: "Binary" }
};
function convertMimeTypeToSomethingNice(mimeType) {
  const part = mimeType.replace("x-", "").split("/")[1];
  return part.charAt(0).toUpperCase() + part.slice(1);
}
function formatMimeType(mimeType) {
  if (MIME_TYPES == null ? void 0 : MIME_TYPES[mimeType]) {
    return MIME_TYPES[mimeType].title;
  }
  return convertMimeTypeToSomethingNice(mimeType);
}
function AssetUsageDialog(_ref333) {
  let { asset, assetType, onClose } = _ref333;
  const { isLoading, referringDocuments } = useReferringDocuments(asset._id);
  const publishedDocuments = (0, import_react51.useMemo)(() => {
    const drafts = referringDocuments.reduce((acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc, []);
    return referringDocuments.filter((doc) => !drafts.includes(doc._id));
  }, [referringDocuments]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Dialog, { __unstable_autoFocus: true, header: t3("asset-source.asset-usage-dialog.header", { context: assetType }), id: "asset-dialog", onClickOutside: onClose, onClose, width: 1, children: isLoading ? (0, import_jsx_runtime6.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime6.jsx)(SpinnerWithText, { text: t3("asset-source.asset-usage-dialog.loading") }) }) : (0, import_jsx_runtime6.jsx)(Stack, { paddingX: [2, 3, 4], paddingY: [3, 3, 3, 4], space: 1, children: (0, import_jsx_runtime6.jsx)(AssetUsageList, { asset, referringDocuments: publishedDocuments, assetType }) }) });
}
var __freeze$Y = Object.freeze;
var __defProp$Y = Object.defineProperty;
var __template$Y = (cooked, raw) => __freeze$Y(__defProp$Y(cooked, "raw", { value: __freeze$Y(raw || cooked.slice()) }));
var _a$Y;
var _b$s;
var _c$i;
var _d$9;
var _e$3;
var _f$22;
var _g$2;
var _h;
var CardIconWrapper = st.span(_a$Y || (_a$Y = __template$Y(["\n  background-color: transparent;\n  flex-shrink: 0;\n"])));
var CustomFlex = st(Flex)(_b$s || (_b$s = __template$Y([""])));
var CustomCard$1 = st(Card)(_d$9 || (_d$9 = __template$Y(["\n  ", "\n"])), (props2) => props2.isSelected && nt(_c$i || (_c$i = __template$Y(["\n      --card-muted-fg-color: var(--card-bg-color);\n      --card-fg-color: var(--card-bg-color);\n    "]))));
var RowButton = st(Button)(_g$2 || (_g$2 = __template$Y(["\n  box-shadow: none;\n  min-width: 0;\n  cursor: pointer;\n  position: initial;\n\n  &:before,\n  &:after {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 2;\n  }\n\n  &:before {\n    z-index: 0;\n    pointer-events: none;\n    border-radius: 0.1875rem;\n  }\n\n  ", "\n\n  ", "\n"])), (props2) => props2.isSelected && nt(_e$3 || (_e$3 = __template$Y(["\n      --card-muted-fg-color: var(--card-bg-color);\n      --card-fg-color: var(--card-bg-color);\n\n      &:before {\n        background-color: var(--card-focus-ring-color);\n      }\n\n      ", " {\n        --card-muted-fg-color: var(--card-bg-color);\n      }\n\n      ", " {\n        --card-muted-fg-color: var(--card-bg-color);\n        --card-fg-color: var(--card-bg-color);\n      }\n    "])), CardIconWrapper, CustomFlex), (props2) => !props2.isSelected && nt(_f$22 || (_f$22 = __template$Y(["\n      &:hover:before {\n        background-color: var(--card-bg-color);\n      }\n\n      &:focus:before {\n        background-color: var(--card-code-bg-color);\n      }\n\n      &:focus-within:before {\n        background-color: var(--card-bg-color);\n      }\n    "]))));
var TypeText = st(Text3)(_h || (_h = __template$Y(["\n  overflow-wrap: anywhere;\n"])));
var STYLES_ROW_CARD = { position: "relative" };
var STYLES_ICON_CARD = { flexShrink: 0 };
var STYLES_BUTTON_TEXT = { minWidth: 0 };
var STYLES_ASSETMENU_WRAPPER = { zIndex: 3, marginTop: "-0.5rem", marginBottom: "-0.5rem" };
var AssetRow = (props2) => {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const toast = useToast();
  const deleteRef$ = (0, import_react51.useRef)();
  const [showUsageDialog, setShowUsageDialog] = (0, import_react51.useState)(false);
  const [showDeleteDialog, setShowDeleteDialog] = (0, import_react51.useState)(false);
  const [isDeleting, setIsDeleting] = (0, import_react51.useState)(false);
  const [isOpen, setIsOpen] = (0, import_react51.useState)(false);
  const { asset, onClick, onKeyPress, onDeleteFinished, isSelected, isMobile } = props2;
  const { originalFilename, _id, mimeType, size: size2, _createdAt } = asset;
  const formattedTime = useRelativeTime(_createdAt, { useTemporalPhrase: true });
  const formattedMimeType = formatMimeType(mimeType);
  const formatUnit = useUnitFormatter({ unitDisplay: "short", maximumFractionDigits: 2 });
  const formattedSize = getHumanFriendlyBytes(size2, formatUnit);
  const showTooltip = (originalFilename || "").length > 37;
  const { t: t3 } = useTranslation2();
  const handleConfirmDelete = (0, import_react51.useCallback)(() => {
    setShowDeleteDialog(true);
  }, []);
  const handleDeleteError = (0, import_react51.useCallback)((error2) => {
    toast.push({ closable: true, status: "error", title: t3("asset-source.file.asset-list.delete-failed"), description: error2.message });
  }, [t3, toast]);
  const handleDeleteSuccess = (0, import_react51.useCallback)(() => {
    toast.push({ status: "success", title: t3("asset-source.file.asset-list.delete-successful") });
  }, [t3, toast]);
  const handleDeleteAsset = (0, import_react51.useCallback)(() => {
    setIsDeleting(true);
    deleteRef$.current = versionedClient.observable.delete(asset._id).subscribe({ next: () => {
      setIsDeleting(false);
      onDeleteFinished == null ? void 0 : onDeleteFinished(asset._id);
      setShowDeleteDialog(false);
      handleDeleteSuccess();
    }, error: (err) => {
      setIsDeleting(false);
      handleDeleteError(err);
      console.error("Could not delete asset", err);
    } });
  }, [asset._id, handleDeleteError, handleDeleteSuccess, onDeleteFinished, versionedClient.observable]);
  const handleDialogClose = () => {
    setShowUsageDialog(false);
    setShowDeleteDialog(false);
  };
  const handleToggleUsageDialog = () => {
    setShowUsageDialog(true);
  };
  const handleToggleOpen = () => {
    setIsOpen(!isOpen);
  };
  const handleMenuAction = (action) => {
    if (action.type === "delete") {
      handleConfirmDelete();
    }
    if (action.type === "showUsage") {
      handleToggleUsageDialog();
    }
  };
  const usageDialog = (0, import_react51.useMemo)(() => {
    return showUsageDialog && (0, import_jsx_runtime6.jsx)(AssetUsageDialog, { assetType: "file", asset, onClose: handleDialogClose });
  }, [asset, showUsageDialog]);
  const deleteDialog = (0, import_react51.useMemo)(() => {
    return showDeleteDialog && (0, import_jsx_runtime6.jsx)(AssetDeleteDialog, { assetType: "file", asset, onClose: handleDialogClose, onDelete: handleDeleteAsset, isDeleting });
  }, [asset, handleDeleteAsset, isDeleting, showDeleteDialog]);
  if (isMobile) {
    return (0, import_jsx_runtime6.jsxs)(Card, { paddingBottom: 2, style: STYLES_ROW_CARD, children: [(0, import_jsx_runtime6.jsxs)(Grid, { columns: 4, gap: 1, style: { position: "relative", gridTemplateColumns: "1fr 30px", opacity: isDeleting ? 0.5 : 1 }, children: [(0, import_jsx_runtime6.jsx)(RowButton, { asset, mode: "bleed", padding: 0, "data-id": _id, onClick, paddingY: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { gap: 2, flex: 2, align: "center", children: [(0, import_jsx_runtime6.jsx)(Card, { as: CardIconWrapper, padding: 2, tone: "transparent", radius: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 2, style: STYLES_ICON_CARD, children: (0, import_jsx_runtime6.jsx)(DocumentIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename })] }) }), (0, import_jsx_runtime6.jsx)(Flex, { justify: "flex-end", align: "center", paddingRight: 1, style: STYLES_ASSETMENU_WRAPPER, children: (0, import_jsx_runtime6.jsx)(Button, { mode: "bleed", fontSize: 1, padding: 2, onClick: handleToggleOpen, icon: isOpen ? ChevronUpIcon : ChevronDownIcon }) })] }), isOpen && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsxs)(Grid, { marginTop: 3, columns: 3, gap: 1, children: [(0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("asset-source.file.asset-list.header.size") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: formattedSize })] }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("asset-source.file.asset-list.header.type") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: formattedMimeType })] }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("asset-source.file.asset-list.header.date-added") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: formattedTime })] })] }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, marginTop: 3, children: [(0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, tone: "default", mode: "ghost", text: t3("asset-source.file.asset-list.action.show-usage.title"), onClick: handleToggleUsageDialog, icon: LinkIcon }), (0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, tone: "critical", mode: "ghost", text: t3("asset-source.file.asset-list.action.delete.title"), icon: TrashIcon, disabled: isSelected, title: t3(isSelected ? "asset-source.file.asset-list.action.delete.disabled-cannot-delete-current-file" : "asset-source.file.asset-list.action.delete.title"), onClick: handleConfirmDelete })] })] }), usageDialog || deleteDialog] });
  }
  return (0, import_jsx_runtime6.jsxs)(CustomCard$1, { asset, paddingBottom: 1, style: STYLES_ROW_CARD, radius: 0, overflow: "hidden", isSelected, "aria-selected": "true", children: [(0, import_jsx_runtime6.jsxs)(Grid, { columns: 4, gap: 1, "data-id": _id, paddingY: 1, style: { position: "relative", gridTemplateColumns: "3fr 1fr 1fr 2fr 30px", opacity: isDeleting ? 0.5 : 1 }, children: [(0, import_jsx_runtime6.jsx)(RowButton, { asset, mode: "bleed", "data-id": _id, onClick, padding: 0, onKeyPress, title: t3("asset-source.file.asset-list.item.select-file-tooltip", { filename: originalFilename }), isSelected, children: (0, import_jsx_runtime6.jsxs)(CustomFlex, { gap: 2, flex: 2, paddingRight: 1, align: "center", onClick, onKeyPress, "data-id": _id, children: [(0, import_jsx_runtime6.jsx)(Card, { as: CardIconWrapper, padding: 2, tone: "transparent", radius: 2, style: STYLES_ICON_CARD, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 2, children: (0, import_jsx_runtime6.jsx)(DocumentIcon, {}) }) }), showTooltip && (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: originalFilename }) }), fallbackPlacements: ["right", "left"], placement: "top", portal: true, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename }) }), !showTooltip && (0, import_jsx_runtime6.jsx)(Text3, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename })] }) }), (0, import_jsx_runtime6.jsx)(CustomFlex, { align: "center", children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: formattedSize }) }), (0, import_jsx_runtime6.jsx)(CustomFlex, { align: "center", children: (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(TypeText, { size: 1, muted: true, textOverflow: "ellipsis", children: formattedMimeType }) }) }), (0, import_jsx_runtime6.jsx)(CustomFlex, { align: "center", children: (0, import_jsx_runtime6.jsx)(Text3, { as: "time", size: 1, muted: true, dateTime: _createdAt, children: formattedTime }) }), (0, import_jsx_runtime6.jsx)(CustomFlex, { justify: "flex-end", align: "center", paddingX: 1, paddingY: 1, style: STYLES_ASSETMENU_WRAPPER, children: (0, import_jsx_runtime6.jsx)(AssetMenu, { border: false, isSelected: false, onAction: handleMenuAction }) })] }), usageDialog || deleteDialog] });
};
var STYLES_FILENAME = { paddingLeft: "2.2rem" };
var STYLES_GRID = { gridTemplateColumns: "3fr 1fr 1fr 2fr 30px" };
function FileListView(props2) {
  const mediaIndex = useMediaIndex();
  const isMobile = mediaIndex < 2;
  const { assets, onClick, onKeyPress, onDeleteFinished, selectedAssets, isLoading } = props2;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Box, { padding: 4, children: [(0, import_jsx_runtime6.jsx)(Card, { borderBottom: true, paddingBottom: 2, marginBottom: 1, children: isMobile ? (0, import_jsx_runtime6.jsx)(Grid, { style: STYLES_GRID, children: (0, import_jsx_runtime6.jsx)(Box, { flex: 2, paddingLeft: 5, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("asset-source.file.asset-list.header.filename") }) }) }) : (0, import_jsx_runtime6.jsxs)(Grid, { gap: 1, style: STYLES_GRID, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 2, style: STYLES_FILENAME, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("asset-source.file.asset-list.header.filename") }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("asset-source.file.asset-list.header.size") }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("asset-source.file.asset-list.header.type") }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("asset-source.file.asset-list.header.date-added") }) })] }) }), (0, import_jsx_runtime6.jsxs)(Stack, { children: [isLoading && assets.length === 0 && (0, import_jsx_runtime6.jsx)(Box, { paddingTop: 4, paddingBottom: 2, children: (0, import_jsx_runtime6.jsx)(Flex, { justify: "center", children: (0, import_jsx_runtime6.jsx)(Spinner, { muted: true }) }) }), assets.map((asset) => (0, import_jsx_runtime6.jsx)(AssetRow, { asset, isMobile, isSelected: selectedAssets.some((selected) => selected._id === asset._id), onClick, onKeyPress, onDeleteFinished }, asset._id))] })] });
}
var __freeze$X = Object.freeze;
var __defProp$X = Object.defineProperty;
var __template$X = (cooked, raw) => __freeze$X(__defProp$X(cooked, "raw", { value: __freeze$X(raw || cooked.slice()) }));
var _a$X;
var FullscreenLayer = st(Layer)(_a$X || (_a$X = __template$X(["\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n"])));
function FullscreenSpinner() {
  return (0, import_jsx_runtime6.jsx)(FullscreenLayer, { children: (0, import_jsx_runtime6.jsx)(Flex, { height: "fill", align: "center", justify: "center", children: (0, import_jsx_runtime6.jsx)(Spinner, {}) }) });
}
var __freeze$W = Object.freeze;
var __defProp$W = Object.defineProperty;
var __template$W = (cooked, raw) => __freeze$W(__defProp$W(cooked, "raw", { value: __freeze$W(raw || cooked.slice()) }));
var _a$W;
var _b$r;
var _c$h;
var _d$8;
var DPI = typeof window === "undefined" || !window.devicePixelRatio ? 1 : Math.round(window.devicePixelRatio);
var Image$2 = st.img(_a$W || (_a$W = __template$W(["\n  position: absolute;\n  z-index: 1;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: block;\n  object-fit: contain;\n"])));
var Container$1 = st(Card)(_b$r || (_b$r = __template$W(["\n  position: relative;\n  z-index: 1;\n  padding-bottom: 100%;\n"])));
var Root$62 = st.div(_c$h || (_c$h = __template$W(["\n  position: relative;\n  display: inherit;\n"])));
var MenuContainer = st.div(_d$8 || (_d$8 = __template$W(["\n  box-sizing: border-box;\n  position: absolute;\n  z-index: 2;\n  top: 3px;\n  right: 3px;\n\n  & button[data-selected] {\n    display: block;\n  }\n\n  @media (hover: hover) {\n    // If hover is supported, hide the buttons until the user hovers or focuses the asset\n    // Use opacity to enable the buttons to still be focusable\n    & button {\n      opacity: 0;\n    }\n\n    ", ":hover & {\n      button {\n        opacity: 1;\n      }\n    }\n\n    ", ":focus-within & {\n      button {\n        opacity: 1;\n      }\n    }\n  }\n"])), Root$62, Root$62);
var AssetThumb = import_react51.default.memo(function AssetThumb2(props2) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const toast = useToast();
  const deleteRef$ = (0, import_react51.useRef)();
  const { asset, onClick, onKeyPress, onDeleteFinished, isSelected } = props2;
  const [showUsageDialog, setShowUsageDialog] = (0, import_react51.useState)(false);
  const [showDeleteDialog, setShowDeleteDialog] = (0, import_react51.useState)(false);
  const [isDeleting, setIsDeleting] = (0, import_react51.useState)(false);
  const { t: t3 } = useTranslation2();
  (0, import_react51.useEffect)(() => {
    return () => {
      if (deleteRef$.current) {
        deleteRef$.current.unsubscribe();
      }
    };
  }, []);
  const handleConfirmDelete = (0, import_react51.useCallback)(() => {
    setShowDeleteDialog(true);
  }, [setShowDeleteDialog]);
  const handleDialogClose = (0, import_react51.useCallback)(() => {
    setShowUsageDialog(false);
    setShowDeleteDialog(false);
  }, [setShowUsageDialog, setShowDeleteDialog]);
  const handleToggleUsageDialog = (0, import_react51.useCallback)(() => {
    setShowUsageDialog(true);
  }, [setShowUsageDialog]);
  const handleDeleteError = (0, import_react51.useCallback)((error2) => {
    toast.push({ closable: true, status: "error", title: t3("asset-source.image.asset-list.delete-failed"), description: error2.message });
  }, [t3, toast]);
  const handleDeleteSuccess = (0, import_react51.useCallback)(() => {
    toast.push({ status: "success", title: t3("asset-source.image.asset-list.delete-successful") });
  }, [t3, toast]);
  const handleDeleteAsset = (0, import_react51.useCallback)(() => {
    setIsDeleting(true);
    deleteRef$.current = versionedClient.observable.delete(asset._id).subscribe({ next: () => {
      setIsDeleting(false);
      onDeleteFinished(asset._id);
      setShowDeleteDialog(false);
      handleDeleteSuccess();
    }, error: (err) => {
      setIsDeleting(false);
      handleDeleteError(err);
      console.error("Could not delete asset", err);
    } });
  }, [asset._id, handleDeleteError, handleDeleteSuccess, onDeleteFinished, versionedClient.observable]);
  const handleMenuAction = (0, import_react51.useCallback)((action) => {
    if (action.type === "delete") {
      handleConfirmDelete();
    }
    if (action.type === "showUsage") {
      handleToggleUsageDialog();
    }
  }, [handleConfirmDelete, handleToggleUsageDialog]);
  const usageDialog = (0, import_react51.useMemo)(() => {
    return showUsageDialog && (0, import_jsx_runtime6.jsx)(AssetUsageDialog, { assetType: "file", asset, onClose: handleDialogClose });
  }, [asset, handleDialogClose, showUsageDialog]);
  const deleteDialog = (0, import_react51.useMemo)(() => {
    return showDeleteDialog && (0, import_jsx_runtime6.jsx)(AssetDeleteDialog, { assetType: "file", asset, onClose: handleDialogClose, onDelete: handleDeleteAsset, isDeleting });
  }, [asset, handleDeleteAsset, handleDialogClose, isDeleting, showDeleteDialog]);
  const { originalFilename, _id, url } = asset;
  const imgH = 200 * Math.max(1, DPI);
  const imageUrl = url.includes(".gif") ? "".concat(url, "?h=").concat(imgH, "&fit=max&fm=jpg") : "".concat(url, "?h=").concat(imgH, "&fit=max");
  return (0, import_jsx_runtime6.jsxs)(Root$62, { children: [(0, import_jsx_runtime6.jsx)(Button, { tone: "primary", selected: isSelected, tabIndex: 0, "data-id": _id, mode: "ghost", onKeyPress, padding: 0, style: { padding: 2 }, children: (0, import_jsx_runtime6.jsxs)(Container$1, { __unstable_checkered: true, children: [(0, import_jsx_runtime6.jsx)(Image$2, { alt: originalFilename, src: imageUrl, onClick, "data-id": _id }), isDeleting && (0, import_jsx_runtime6.jsx)(FullscreenSpinner, {})] }) }), (0, import_jsx_runtime6.jsx)(MenuContainer, { children: (0, import_jsx_runtime6.jsx)(AssetMenu, { isSelected, onAction: handleMenuAction }) }), usageDialog || deleteDialog] });
});
var __freeze$V = Object.freeze;
var __defProp$V = Object.defineProperty;
var __template$V = (cooked, raw) => __freeze$V(__defProp$V(cooked, "raw", { value: __freeze$V(raw || cooked.slice()) }));
var _a$V;
var ThumbGrid = st(Grid)(_a$V || (_a$V = __template$V(["\n  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));\n"])));
function ImageListView(props2) {
  const { isLoading, assets, selectedAssets, onItemClick, onItemKeyPress, onDeleteFinished } = props2;
  return (0, import_jsx_runtime6.jsxs)(Box, { padding: 4, children: [(0, import_jsx_runtime6.jsx)(ThumbGrid, { gap: 2, children: assets.map((asset) => (0, import_jsx_runtime6.jsx)(AssetThumb, { asset, isSelected: selectedAssets.some((selected) => selected._id === asset._id), onClick: onItemClick, onKeyPress: onItemKeyPress, onDeleteFinished }, asset._id)) }), isLoading && assets.length === 0 && (0, import_jsx_runtime6.jsx)(Flex, { justify: "center", children: (0, import_jsx_runtime6.jsx)(Spinner, { muted: true }) }), !isLoading && assets.length === 0 && (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true })] });
}
var __freeze$U = Object.freeze;
var __defProp$U = Object.defineProperty;
var __template$U = (cooked, raw) => __freeze$U(__defProp$U(cooked, "raw", { value: __freeze$U(raw || cooked.slice()) }));
var _a$U;
var PER_PAGE = 200;
var ASSET_TYPE_IMAGE = "sanity.imageAsset";
var ASSET_TYPE_FILE = "sanity.fileAsset";
var buildFilterQuery = (acceptParam) => {
  const WILDCARD_ACCEPT = ["image/*", "audio/*", "video/*"];
  const acceptItems = acceptParam.split(",").map((accept) => accept.trim());
  const typesForFilter = acceptItems.reduce((acceptTypes, acceptValue) => {
    if (WILDCARD_ACCEPT.includes(acceptValue)) {
      return { ...acceptTypes, wildcards: "mimeType match '".concat(acceptValue, "' || ").concat(acceptTypes.wildcards) };
    }
    if (acceptValue.indexOf(".") === 0) {
      return { ...acceptTypes, extensions: "'".concat(acceptValue.replace(".", ""), "', ").concat(acceptTypes.extensions) };
    }
    return { ...acceptTypes, mimes: "'".concat(acceptValue, "', ").concat(acceptTypes.mimes) };
  }, { mimes: "", extensions: "", wildcards: "" });
  return "&&\n  (\n    ".concat(typesForFilter.wildcards, "\n    extension in [").concat(typesForFilter.extensions, "] ||\n    mimeType in [").concat(typesForFilter.mimes, "]\n  )");
};
var buildQuery = function() {
  let start = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  let end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : PER_PAGE;
  let assetType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ASSET_TYPE_IMAGE;
  let acceptParam = arguments.length > 3 ? arguments[3] : void 0;
  const hasAccept = acceptParam.length > 0;
  const filterCondition = hasAccept ? buildFilterQuery(acceptParam) : "";
  return '\n  *[_type == "'.concat(assetType, '" ').concat(filterCondition, "] | order(_updatedAt desc) [").concat(start, "...").concat(end, "] {\n    _id,\n    _updatedAt,\n    _createdAt,\n    url,\n    originalFilename,\n    mimeType,\n    extension,\n    size,\n    metadata {dimensions}\n  }\n");
};
var CardLoadMore = st(Card)(_a$U || (_a$U = __template$U(["\n  border-top: 1px solid var(--card-border-color);\n  position: sticky;\n  bottom: 0;\n  z-index: 200;\n"])));
var DefaultAssetSource = function DefaultAssetSource2(props2, ref) {
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const versionedClient = (0, import_react51.useMemo)(() => client.withConfig({ apiVersion: "2023-02-14" }), [client]);
  const _elementId = (0, import_react51.useRef)("default-asset-source-".concat((0, import_uniqueId.default)()));
  const currentPageNumber = (0, import_react51.useRef)(0);
  const { t: t3 } = useTranslation2();
  const fetch$ = (0, import_react51.useRef)();
  const [assets, setAssets] = (0, import_react51.useState)([]);
  const [isLastPage, setIsLastPage] = (0, import_react51.useState)(false);
  const [hasResetAutoFocus, setHasResetFocus] = (0, import_react51.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react51.useState)(true);
  const { selectedAssets, assetType = "image", dialogHeaderTitle, onClose, onSelect, accept } = props2;
  const isImageOnlyWildCard = accept && accept === "image/*" && assetType === "image";
  const fetchPage = (0, import_react51.useCallback)((pageNumber) => {
    const start = pageNumber * PER_PAGE;
    const end = start + PER_PAGE;
    const isImageAssetType = assetType === "image";
    const tag = isImageAssetType ? "asset.image-list" : "asset.file-list";
    const assetTypeParam = isImageAssetType ? ASSET_TYPE_IMAGE : ASSET_TYPE_FILE;
    setIsLoading(true);
    if (typeof accept !== "undefined") {
      fetch$.current = versionedClient.observable.fetch(buildQuery(start, end, assetTypeParam, accept), {}, { tag }).subscribe((result) => {
        setIsLastPage(result.length < PER_PAGE);
        setAssets((prevState) => prevState.concat(result));
        setIsLoading(false);
      });
    }
  }, [assetType, accept, versionedClient]);
  const handleDeleteFinished = (0, import_react51.useCallback)((id4) => {
    setAssets((prevState) => prevState.filter((asset) => asset._id !== id4));
  }, [setAssets]);
  const select2 = (0, import_react51.useCallback)((id4) => {
    const selected = assets.find((doc) => doc._id === id4);
    if (selected) {
      const selectedSource = [{ kind: "assetDocumentId", value: id4 }];
      onSelect(selectedSource);
    }
  }, [assets, onSelect]);
  const handleItemClick = (0, import_react51.useCallback)((event) => {
    event.preventDefault();
    const id4 = event.currentTarget.getAttribute("data-id");
    if (!id4) {
      throw new Error("Missing data-id attribute on item");
    }
    select2(id4);
  }, [select2]);
  const handleItemKeyPress = (0, import_react51.useCallback)((event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      const id4 = event.currentTarget.getAttribute("data-id");
      if (!id4) {
        throw new Error("Missing data-id attribute on item");
      }
      select2(id4);
    }
  }, [select2]);
  const handleClose = (0, import_react51.useCallback)(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  const handleFetchNextPage = (0, import_react51.useCallback)((event) => {
    event.preventDefault();
    fetchPage(++currentPageNumber.current);
  }, [fetchPage]);
  (0, import_react51.useEffect)(() => {
    fetchPage(currentPageNumber.current);
    return () => {
      if (fetch$.current) {
        fetch$.current.unsubscribe();
      }
    };
  }, [fetchPage]);
  (0, import_react51.useEffect)(() => {
    if (!isLoading && (!currentPageNumber.current || currentPageNumber.current === 0)) {
      setHasResetFocus(true);
    }
  }, [isLoading]);
  const listFormat = useIntlListFormat({ style: "narrow" });
  return (0, import_jsx_runtime6.jsxs)(Dialog, { __unstable_autoFocus: hasResetAutoFocus, header: dialogHeaderTitle || t3("asset-source.dialog.default-title", { context: assetType }), id: _elementId.current, onClickOutside: handleClose, onClose: handleClose, ref, width: 2, children: [!isImageOnlyWildCard && !isLoading && (accept == null ? void 0 : accept.length) > 0 && (0, import_jsx_runtime6.jsx)(Card, { tone: "primary", marginTop: 4, marginX: 4, padding: [3, 3, 4], border: true, radius: 2, children: (0, import_jsx_runtime6.jsxs)(Flex, { gap: [3, 4], align: "center", children: [(0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(InfoOutlineIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "asset-source.dialog.accept-message", values: { acceptTypes: listFormat.format(accept.split(",").map((type) => type.trim())) } }) })] }) }), assetType === "file" && (0, import_jsx_runtime6.jsx)(FileListView, { assets, onDeleteFinished: handleDeleteFinished, onClick: handleItemClick, onKeyPress: handleItemKeyPress, isLoading, selectedAssets }), assetType === "image" && (0, import_jsx_runtime6.jsx)(ImageListView, { assets, onDeleteFinished: handleDeleteFinished, onItemClick: handleItemClick, onItemKeyPress: handleItemKeyPress, isLoading, selectedAssets }), assets.length > 0 && !isLastPage && (0, import_jsx_runtime6.jsx)(CardLoadMore, { tone: "default", padding: 4, children: (0, import_jsx_runtime6.jsx)(Flex, { direction: "column", children: (0, import_jsx_runtime6.jsx)(Button, { type: "button", icon: DownloadIcon, loading: isLoading, onClick: handleFetchNextPage, text: t3("asset-source.dialog.load-more"), tone: "primary" }) }) })] });
};
var DefaultSource = import_react51.default.memo(import_react51.default.forwardRef(DefaultAssetSource));
var FileSource = { name: "sanity-default", title: "Uploaded files", i18nKey: "asset-source.file.title", component: DefaultSource, icon: DocumentsIcon };
var ImageSource = { name: "sanity-default", title: "Uploaded images", i18nKey: "asset-source.image.title", component: DefaultSource, icon: ImageIcon };
function createFilterDefinitionDictionary(filterDefinitions2) {
  return filterDefinitions2.reduce((acc, val) => {
    acc[val.name] = val;
    return acc;
  }, {});
}
function defineSearchFilter(filterDef) {
  return filterDef;
}
function defineSearchFilterOperators(operators2) {
  return operators2;
}
function getFilterDefinition(definitions, filterName) {
  return definitions[filterName];
}
function getSupportedFieldTypes(filterDefs) {
  return filterDefs.reduce((acc, val) => {
    if (val.type === "field") {
      acc.push(val.fieldType);
    }
    return acc;
  }, []);
}
var filterDefinitions = [
  // 'Pinned' filters
  defineSearchFilter({ fieldPath: "_updatedAt", icon: CalendarIcon, operators: [{ name: "dateTimeLast", type: "item" }, { type: "divider" }, { name: "dateTimeRange", type: "item" }, { name: "dateTimeAfter", type: "item" }, { name: "dateTimeBefore", type: "item" }, { type: "divider" }, { name: "dateTimeEqual", type: "item" }, { name: "dateTimeNotEqual", type: "item" }], title: "Updated at", name: "updatedAt", type: "pinned" }),
  defineSearchFilter({ fieldPath: "_createdAt", icon: CalendarIcon, operators: [{ name: "dateTimeLast", type: "item" }, { type: "divider" }, { name: "dateTimeRange", type: "item" }, { name: "dateTimeAfter", type: "item" }, { name: "dateTimeBefore", type: "item" }, { type: "divider" }, { name: "dateTimeEqual", type: "item" }, { name: "dateTimeNotEqual", type: "item" }], title: "Created at", name: "createdAt", type: "pinned" }),
  defineSearchFilter({ icon: LinkIcon, operators: [{ name: "referencesDocument", type: "item" }, { name: "referencesAssetImage", type: "item" }, { name: "referencesAssetFile", type: "item" }], title: "Contains document, image or file", name: "references", type: "pinned" }),
  // 'Field' filters
  defineSearchFilter({ fieldType: "array", icon: UlistIcon, name: "array", operators: [{ name: "defined", type: "item" }, { name: "notDefined", type: "item" }, { type: "divider" }, { name: "arrayCountEqual", type: "item" }, { name: "arrayCountNotEqual", type: "item" }, { type: "divider" }, { name: "arrayCountGt", type: "item" }, { name: "arrayCountGte", type: "item" }, { name: "arrayCountLt", type: "item" }, { name: "arrayCountLte", type: "item" }, { type: "divider" }, { name: "arrayCountRange", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "array", icon: UlistIcon, name: "arrayList", operators: [{ name: "arrayListIncludes", type: "item" }, { name: "arrayListNotIncludes", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }, { type: "divider" }, { name: "arrayCountEqual", type: "item" }, { name: "arrayCountNotEqual", type: "item" }, { type: "divider" }, { name: "arrayCountGt", type: "item" }, { name: "arrayCountGte", type: "item" }, { name: "arrayCountLt", type: "item" }, { name: "arrayCountLte", type: "item" }, { type: "divider" }, { name: "arrayCountRange", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "array", icon: UlistIcon, name: "arrayReferences", operators: [{ name: "arrayReferenceIncludes", type: "item" }, { name: "arrayReferenceNotIncludes", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }, { type: "divider" }, { name: "arrayCountEqual", type: "item" }, { name: "arrayCountNotEqual", type: "item" }, { type: "divider" }, { name: "arrayCountGt", type: "item" }, { name: "arrayCountGte", type: "item" }, { name: "arrayCountLt", type: "item" }, { name: "arrayCountLte", type: "item" }, { type: "divider" }, { name: "arrayCountRange", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "boolean", icon: CheckmarkCircleIcon, name: "boolean", operators: [{ name: "booleanEqual", type: "item" }, { type: "divider" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "date", icon: CalendarIcon, name: "date", operators: [{ name: "dateLast", type: "item" }, { type: "divider" }, { name: "dateRange", type: "item" }, { name: "dateAfter", type: "item" }, { name: "dateBefore", type: "item" }, { type: "divider" }, { name: "dateEqual", type: "item" }, { name: "dateNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "datetime", icon: CalendarIcon, name: "datetime", operators: [{ name: "dateTimeLast", type: "item" }, { type: "divider" }, { name: "dateTimeRange", type: "item" }, { name: "dateTimeAfter", type: "item" }, { name: "dateTimeBefore", type: "item" }, { type: "divider" }, { name: "dateTimeEqual", type: "item" }, { name: "dateTimeNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "email", icon: StringIcon, name: "email", operators: [{ name: "stringMatches", type: "item" }, { name: "stringNotMatches", type: "item" }, { type: "divider" }, { name: "stringEqual", type: "item" }, { name: "stringNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "file", icon: DocumentIcon, name: "file", operators: [{ name: "assetFileEqual", type: "item" }, { name: "assetFileNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "image", icon: ImageIcon, name: "image", operators: [{ name: "assetImageEqual", type: "item" }, { name: "assetImageNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "number", icon: NumberIcon, name: "number", operators: [{ name: "numberEqual", type: "item" }, { name: "numberNotEqual", type: "item" }, { type: "divider" }, { name: "numberGt", type: "item" }, { name: "numberGte", type: "item" }, { name: "numberLt", type: "item" }, { name: "numberLte", type: "item" }, { type: "divider" }, { name: "numberRange", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "array", icon: BlockContentIcon, name: "portableText", operators: [{ name: "portableTextMatches", type: "item" }, { name: "portableTextNotMatches", type: "item" }, { type: "divider" }, { name: "portableTextEqual", type: "item" }, { name: "portableTextNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "reference", icon: LinkIcon, name: "reference", operators: [{ name: "referenceEqual", type: "item" }, { name: "referenceNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "slug", icon: StringIcon, name: "slug", operators: [{ name: "slugMatches", type: "item" }, { name: "slugNotMatches", type: "item" }, { type: "divider" }, { name: "slugEqual", type: "item" }, { name: "slugNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "string", icon: StringIcon, name: "string", operators: [{ name: "stringMatches", type: "item" }, { name: "stringNotMatches", type: "item" }, { type: "divider" }, { name: "stringEqual", type: "item" }, { name: "stringNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "string", icon: SelectIcon, name: "stringList", operators: [{ name: "stringListEqual", type: "item" }, { name: "stringListNotEqual", type: "item" }, { type: "divider" }, { name: "stringMatches", type: "item" }, { name: "stringNotMatches", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "text", icon: StringIcon, name: "text", operators: [{ name: "stringMatches", type: "item" }, { name: "stringNotMatches", type: "item" }, { type: "divider" }, { name: "stringEqual", type: "item" }, { name: "stringNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" }),
  defineSearchFilter({ fieldType: "url", icon: StringIcon, name: "url", operators: [{ name: "stringMatches", type: "item" }, { name: "stringNotMatches", type: "item" }, { type: "divider" }, { name: "stringEqual", type: "item" }, { name: "stringNotEqual", type: "item" }, { type: "divider" }, { name: "defined", type: "item" }, { name: "notDefined", type: "item" }], type: "field" })
];
function ReferencePreviewTitle(_ref334) {
  let { documentId, schemaType } = _ref334;
  const documentPreviewStore = useDocumentPreviewStore();
  const { draft, published, isLoading } = useMemoObservable(() => getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]);
  const sanityDocument = (0, import_react51.useMemo)(() => {
    return { _id: documentId, _type: schemaType.name };
  }, [documentId, schemaType.name]);
  const previewValue = getPreviewValueWithFallback({ draft, published, value: sanityDocument });
  if (isLoading) {
    return (0, import_jsx_runtime6.jsx)(Skeleton, { animated: true, marginLeft: 1, radius: 2, style: { width: "10ch", height: "1em" } });
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: previewValue.title || documentId.slice(0, 8) });
}
function SearchButtonValueDate(_ref335) {
  let { value } = _ref335;
  const dateFormat = useIntlDateTimeFormat({ dateStyle: "medium", timeStyle: value.includeTime ? "short" : void 0 });
  const date = (value == null ? void 0 : value.date) ? new Date(value.date) : null;
  if (!date || !isValid(date)) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: dateFormat.format(date) });
}
function SearchButtonValueDateLast(_ref336) {
  let { value } = _ref336;
  var _a4;
  const formatUnit = useUnitFormatter();
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: formatUnit(Math.floor((_a4 = value == null ? void 0 : value.unitValue) != null ? _a4 : 0), value.unit) });
}
function SearchButtonValueDateRange(_ref337) {
  let { value } = _ref337;
  const dateFormat = useIntlDateTimeFormat({ dateStyle: "medium", timeStyle: value.includeTime ? "short" : void 0 });
  const startDate = (value == null ? void 0 : value.from) ? new Date(value.from) : null;
  const endDate = (value == null ? void 0 : value.to) ? new Date(value.to) : null;
  if (!endDate || !startDate || !isValid(endDate) || !isValid(startDate)) {
    return null;
  }
  const from2 = dateFormat.format(startDate);
  const to = dateFormat.format(endDate);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: "".concat(from2, "  ").concat(to) });
}
function SearchButtonValueReference(_ref338) {
  let { value } = _ref338;
  const schema = useSchema();
  const documentId = value._ref;
  const schemaType = schema.get(value._type);
  if (!schemaType) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(ReferencePreviewTitle, { documentId, schemaType });
}
var SearchContext = (0, import_react51.createContext)(void 0);
function useSearchState() {
  const context = (0, import_react51.useContext)(SearchContext);
  if (context === void 0) {
    throw new Error("useSearchState must be used within an SearchProvider");
  }
  return context;
}
function SearchFilterNumberInput(_ref339) {
  let { value, onChange } = _ref339;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react51.useState)(value != null ? value : "");
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((event) => {
    setUncontrolledValue(event.currentTarget.value);
    const numValue = parseFloat(event.currentTarget.value);
    onChange(Number.isFinite(numValue) ? numValue : null);
  }, [onChange]);
  return (0, import_jsx_runtime6.jsx)(TextInput, { fontSize: fullscreen ? 2 : 1, onChange: handleChange, placeholder: t3("search.filter-number-value-placeholder"), radius: 2, step: "any", type: "number", value: uncontrolledValue });
}
function SearchFilterNumberRangeInput(_ref340) {
  let { onChange, value } = _ref340;
  var _a4, _b4;
  const [to, setTo] = (0, import_react51.useState)((_a4 = value == null ? void 0 : value.to) != null ? _a4 : "");
  const [from2, setFrom] = (0, import_react51.useState)((_b4 = value == null ? void 0 : value.from) != null ? _b4 : "");
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleToChange = (0, import_react51.useCallback)((event) => {
    var _a22;
    setTo(event.currentTarget.value);
    const numValue = parseFloat(event.currentTarget.value);
    onChange({ to: Number.isFinite(numValue) ? numValue : null, from: (_a22 = value == null ? void 0 : value.from) != null ? _a22 : null });
  }, [value == null ? void 0 : value.from, onChange]);
  const handleFromChange = (0, import_react51.useCallback)((event) => {
    var _a22;
    setFrom(event.currentTarget.value);
    const numValue = parseFloat(event.currentTarget.value);
    onChange({ to: (_a22 = value == null ? void 0 : value.to) != null ? _a22 : null, from: Number.isFinite(numValue) ? numValue : null });
  }, [value == null ? void 0 : value.to, onChange]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { gap: 2, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(TextInput, { fontSize: fullscreen ? 2 : 1, onChange: handleFromChange, placeholder: t3("search.filter-number-min-value-placeholder"), radius: 2, step: "any", type: "number", value: from2 }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(TextInput, { fontSize: fullscreen ? 2 : 1, onChange: handleToChange, placeholder: t3("search.filter-number-max-value-placeholder"), radius: 2, step: "any", type: "number", value: to }) })] });
}
function getSchemaField(schemaType, fieldPath) {
  const paths = fieldPath.split(".");
  const firstPath = paths[0];
  if (firstPath && isObjectSchemaType(schemaType)) {
    const field = schemaType.fields.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = paths.slice(1).join(".");
      if (nextPath) {
        return getSchemaField(field.type, nextPath);
      }
      return field;
    }
  }
  return void 0;
}
var __freeze$T = Object.freeze;
var __defProp$T = Object.defineProperty;
var __template$T = (cooked, raw) => __freeze$T(__defProp$T(cooked, "raw", { value: __freeze$T(raw || cooked.slice()) }));
var _a$T;
var _b$q;
var SearchResultItemPreviewBox = st(Box)(_a$T || (_a$T = __template$T(["\n  @supports (-webkit-overflow-scrolling: touch) {\n    * [data-ui='Box'] {\n      background-attachment: scroll;\n    }\n  }\n"])));
var TypeLabel = st(Label)(_b$q || (_b$q = __template$T(["\n  max-width: 150px;\n"])));
function SearchResultItemPreview(_ref341) {
  let { documentId, presence, schemaType } = _ref341;
  const documentPreviewStore = useDocumentPreviewStore();
  const { draft, published, isLoading } = useMemoObservable(() => getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]);
  const sanityDocument = (0, import_react51.useMemo)(() => {
    return { _id: documentId, _type: schemaType.name };
  }, [documentId, schemaType.name]);
  const status = (0, import_react51.useMemo)(() => {
    if (isLoading)
      return null;
    return (0, import_jsx_runtime6.jsxs)(Inline, { space: 3, children: [presence && presence.length > 0 && (0, import_jsx_runtime6.jsx)(DocumentPreviewPresence, { presence }), (0, import_jsx_runtime6.jsx)(TypeLabel, { size: 0, muted: true, textOverflow: "ellipsis", children: schemaType.title })] });
  }, [isLoading, presence, schemaType.title]);
  return (0, import_jsx_runtime6.jsx)(SearchResultItemPreviewBox, { children: (0, import_jsx_runtime6.jsx)(SanityDefaultPreview, { ...getPreviewValueWithFallback({ draft, published, value: sanityDocument }), isPlaceholder: isLoading != null ? isLoading : true, layout: "default", icon: schemaType.icon, status }) });
}
function SearchResultItem(_ref342) {
  let { compact: compact3, disableIntentLink, documentId, documentType, onClick, ...rest } = _ref342;
  const schema = useSchema();
  const type = schema.get(documentType);
  const documentPresence = useDocumentPresence(documentId);
  const params = (0, import_react51.useMemo)(() => ({ id: documentId, type: type == null ? void 0 : type.name }), [documentId, type == null ? void 0 : type.name]);
  const { onClick: onIntentClick, href } = useIntentLink({ intent: "edit", params });
  const handleClick = (0, import_react51.useCallback)((e2) => {
    if (!disableIntentLink) {
      onIntentClick(e2);
    }
    onClick == null ? void 0 : onClick();
  }, [disableIntentLink, onClick, onIntentClick]);
  if (!type)
    return null;
  return (0, import_jsx_runtime6.jsx)(Box, { ...rest, children: (0, import_jsx_runtime6.jsx)(PreviewCard$1, { as: "a", "data-as": "a", flex: 1, href: disableIntentLink ? void 0 : href, onClick: handleClick, padding: compact3 ? 1 : 2, radius: 2, tabIndex: -1, children: (0, import_jsx_runtime6.jsx)(SearchResultItemPreview, { documentId, presence: documentPresence, schemaType: type }) }) });
}
var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var DEBUG_FRAGMENT = "_debug_search_score";
var DEBUG_MODE = false;
var SEARCH_LIMIT = 1e3;
var GLOBAL_SEARCH_KEY = "k";
var GLOBAL_SEARCH_KEY_MODIFIER = IS_MAC ? "Cmd" : "Ctrl";
var POPOVER_INPUT_PADDING = studioTheme.space[1];
var POPOVER_MAX_HEIGHT = 735;
var POPOVER_MAX_WIDTH = 800;
var POPOVER_VERTICAL_MARGIN = 5;
var POPOVER_RADIUS = 2;
function hasSearchableTerms(_ref343) {
  let { allowEmptyQueries, terms } = _ref343;
  const hasQuery = allowEmptyQueries ? true : terms.query.length > 0;
  const hasFilter = !!terms.filter;
  const hasSelectedTypes = terms.types.length > 0;
  return hasQuery || hasFilter || hasSelectedTypes;
}
function getSelectableOmnisearchTypes(schema, typeFilter) {
  return getSearchableOmnisearchTypes(schema).filter((type) => inTypeFilter(type, typeFilter)).sort(sortTypes);
}
function getSearchableOmnisearchTypes(schema) {
  return getSearchableTypes(schema).filter((type) => !(type.__experimental_omnisearch_visibility === false));
}
function sortTypes(a, b) {
  var _a4, _b4;
  return ((_a4 = a.title) != null ? _a4 : a.name).localeCompare((_b4 = b.title) != null ? _b4 : b.name);
}
function inTypeFilter(type, typeFilter) {
  var _a4;
  return !typeFilter || ((_a4 = type.title) != null ? _a4 : type.name).toLowerCase().includes(typeFilter == null ? void 0 : typeFilter.toLowerCase());
}
var DEFAULT_DEBOUNCE_TIME = 300;
var INITIAL_SEARCH_STATE = { error: null, hits: [], loading: false, terms: { query: "", types: [] } };
function nonNullable(v) {
  return v !== null;
}
function sanitizeRequest(request) {
  var _a4;
  return { ...request, terms: { ...request.terms, filter: (_a4 = request.terms.filter) == null ? void 0 : _a4.trim(), query: request.terms.query.trim() } };
}
function useSearch(_ref344) {
  let { allowEmptyQueries, initialState, onComplete, onError, onStart, schema } = _ref344;
  const [searchState, setSearchState] = (0, import_react51.useState)(initialState);
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const searchWeighted = (0, import_react51.useMemo)(() => createWeightedSearch(getSearchableOmnisearchTypes(schema), client, { tag: "search.global", unique: true }), [client, schema]);
  const handleQueryChange = useObservableCallback(
    (inputValue$) => {
      return inputValue$.pipe(
        // Ignore null values
        filter(nonNullable),
        // Sanitize request (trim query and filter)
        map(sanitizeRequest),
        // Only emit when values have changed
        distinctUntilChanged(import_isEqual5.default),
        // Debounce requests
        debounce((request) => timer((request == null ? void 0 : request.debounceTime) || DEFAULT_DEBOUNCE_TIME)),
        // Trigger `onStart` callback
        tap(onStart),
        switchMap((request) => {
          return concat(
            // Emit loading start
            of({ ...INITIAL_SEARCH_STATE, loading: true, options: request.options, terms: request.terms }),
            // Conditionally trigger search ONLY if we have valid searchable terms.
            // Typically, search terms are valid if either query, filter or selected types is non-empty.
            // There are exceptions (e.g. searching within <AutoComplete> components) where empty queries are permitted,
            // which is what `allowEmptyQueries` is used for.
            iif(
              () => hasSearchableTerms({ allowEmptyQueries, terms: request.terms }),
              // If we have a valid search, run async fetch, map results and trigger `onComplete` / `onError` callbacks
              searchWeighted(request.terms, request.options).pipe(map((hits) => ({ hits })), tap((_ref345) => {
                let { hits } = _ref345;
                return onComplete == null ? void 0 : onComplete(hits);
              }), catchError((error2) => {
                onError == null ? void 0 : onError(error2);
                return of({ ...INITIAL_SEARCH_STATE, error: error2, loading: false, options: request.options, terms: request.terms });
              })),
              // If there is no valid search, emit an empty observable and trigger `onComplete` event
              of(EMPTY).pipe(tap(() => onComplete == null ? void 0 : onComplete([])))
            ),
            // Emit loading completed
            of({ loading: false })
          );
        }),
        scan((prevState, nextState) => {
          return { ...prevState, ...nextState };
        }, INITIAL_SEARCH_STATE),
        // Update local search state
        tap(setSearchState)
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- @todo: add onComplete, onError and onStart to the deps list when it's verified that it's safe to do so
    [allowEmptyQueries, searchWeighted]
  );
  const handleSearch = (0, import_react51.useCallback)((searchRequest) => handleQueryChange(searchRequest), [handleQueryChange]);
  return { handleSearch, searchState };
}
var DEFAULT_AVAILABLE_CHARS = 40;
function getDocumentTypesTruncated(_ref346) {
  let { availableCharacters = DEFAULT_AVAILABLE_CHARS, types: types3 } = _ref346;
  if (types3.length === 0) {
    return { remainingCount: 0, types: [] };
  }
  const visibleTypes = types3.reduce(function() {
    let remaining = availableCharacters;
    return function(acc, val, index) {
      const title = typeTitle(val);
      remaining -= title.length;
      if (index === 0) {
        acc.push(val);
      } else if (availableCharacters > title.length && remaining > title.length) {
        acc.push(val);
      }
      return acc;
    };
  }(), []);
  return { remainingCount: types3.length - visibleTypes.length, types: visibleTypes.map(typeTitle) };
}
function documentTypesTruncated(_ref347) {
  let { t: t3, availableCharacters, types: types3 } = _ref347;
  if (types3.length === 0) {
    return t3("search.document-type-list-all-types");
  }
  const { remainingCount, types: visibleTypes } = getDocumentTypesTruncated({ availableCharacters, types: types3 });
  const key2 = remainingCount > 0 ? "search.document-type-list-truncated" : "search.document-type-list";
  return t3(key2, { count: remainingCount, types: visibleTypes, formatParams: { types: { style: "short", type: "unit" } } });
}
function typeTitle(schemaType) {
  var _a4;
  return (_a4 = schemaType.title) != null ? _a4 : schemaType.name;
}
var __freeze$S = Object.freeze;
var __defProp$S = Object.defineProperty;
var __template$S = (cooked, raw) => __freeze$S(__defProp$S(cooked, "raw", { value: __freeze$S(raw || cooked.slice()) }));
var _a$S;
var NO_FILTER = () => true;
var StyledText$1 = st(Text3)(_a$S || (_a$S = __template$S(["\n  word-break: break-word;\n"])));
var ReferenceAutocomplete = (0, import_react51.forwardRef)(function ReferenceAutocomplete23(_ref348, ref) {
  let { onSelect, types: types3 = [], value } = _ref348;
  const autocompletePopoverReferenceElementRef = (0, import_react51.useRef)(null);
  const schema = useSchema();
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const autocompleteId = (0, import_react51.useId)();
  const [hits, setHits] = (0, import_react51.useState)([]);
  const { handleSearch, searchState } = useSearch({ allowEmptyQueries: true, initialState: { hits: [], loading: false, error: null, terms: { query: "", types: types3 } }, onComplete: (weightedHits) => {
    setHits(weightedHits.map((weightedHit) => ({ hit: weightedHit, value: weightedHit.hit._id })));
  }, schema });
  const handleAutocompleteOpenButtonClick = (0, import_react51.useCallback)(() => {
    handleSearch({ debounceTime: 0, options: { limit: 100 }, terms: { query: "", types: types3 } });
  }, [handleSearch, types3]);
  const handleQueryChange = (0, import_react51.useCallback)((query) => {
    if (query) {
      handleSearch({ options: { limit: 100 }, terms: { query: query || "", types: types3 } });
    } else {
      handleSearch({ debounceTime: 0, options: { limit: 0 }, terms: { query: "", types: types3 } });
    }
  }, [handleSearch, types3]);
  const handleSelect = (0, import_react51.useCallback)((val) => {
    var _a22;
    const hit = (_a22 = hits.find((h) => h.value === val)) == null ? void 0 : _a22.hit.hit;
    if (hit) {
      onSelect == null ? void 0 : onSelect({ _ref: getPublishedId(hit._id), _type: hit._type });
    }
  }, [hits, onSelect]);
  const placeholderText = (0, import_react51.useMemo)(() => {
    if (types3.length === 0) {
      return t3("search.action.search-all-types");
    }
    const { remainingCount, types: visibleTypes } = getDocumentTypesTruncated({ types: types3 });
    const key2 = remainingCount > 0 ? "search.action.search-specific-types-truncated" : "search.action.search-specific-types";
    return t3(key2, { count: remainingCount, types: visibleTypes, formatParams: { types: { style: "short", type: "unit" } } });
  }, [types3, t3]);
  const renderOption = (0, import_react51.useCallback)((option) => {
    const documentType = option.hit.hit._type;
    return (0, import_jsx_runtime6.jsx)(SearchResultItem, { compact: true, disableIntentLink: true, documentId: option.value, documentType });
  }, []);
  const renderPopover = (0, import_react51.useCallback)((props2, contentRef) => {
    const { content, hidden, onMouseEnter, onMouseLeave } = props2;
    const hasResults = hits && hits.length > 0;
    return (0, import_jsx_runtime6.jsx)(Popover, { arrow: false, constrainSize: true, content: (0, import_jsx_runtime6.jsx)("div", { ref: contentRef, children: hasResults ? content : searchState.terms.query && (0, import_jsx_runtime6.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", height: "fill", justify: "center", children: (0, import_jsx_runtime6.jsx)(StyledText$1, { align: "center", muted: true, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "new-document.no-results", values: { searchQuery: searchState.terms.query } }) }) }) }) }), matchReferenceWidth: true, onMouseEnter, onMouseLeave, open: !searchState.loading && !hidden, overflow: "auto", placement: "bottom-start", radius: POPOVER_RADIUS, referenceElement: autocompletePopoverReferenceElementRef.current });
  }, [hits, searchState.loading, searchState.terms.query, t3]);
  return (0, import_jsx_runtime6.jsx)("div", { ref: autocompletePopoverReferenceElementRef, children: (0, import_jsx_runtime6.jsx)(Autocomplete, { "aria-label": placeholderText, filterOption: NO_FILTER, fontSize: fullscreen ? 2 : 1, id: autocompleteId, loading: searchState.loading, openButton: { onClick: handleAutocompleteOpenButtonClick }, options: hits, onQueryChange: handleQueryChange, onSelect: handleSelect, placeholder: placeholderText, radius: 2, ref, renderOption, renderPopover, value: value == null ? void 0 : value._ref }) });
});
function SearchFilterReferenceInput(_ref349) {
  let { fieldDefinition, onChange, value } = _ref349;
  const { onClose, state: { documentTypesNarrowed, fullscreen } } = useSearchState();
  const schema = useSchema();
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((referenceValue) => onChange(referenceValue), [onChange]);
  const searchableTypes = (0, import_react51.useMemo)(() => {
    if (!fieldDefinition) {
      return [];
    }
    return fieldDefinition.documentTypes.filter((d) => documentTypesNarrowed.includes(d)).flatMap((type) => {
      const schemaType = schema.get(type);
      if (schemaType) {
        const field = getSchemaField(schemaType, fieldDefinition.fieldPath);
        if (isArraySchemaType(field == null ? void 0 : field.type)) {
          return field == null ? void 0 : field.type.of.filter(isReferenceSchemaType).flatMap((i) => i.to);
        }
        if (isReferenceSchemaType(field == null ? void 0 : field.type)) {
          return field == null ? void 0 : field.type.to;
        }
      }
      return [];
    }).reduce((acc, val) => {
      if (acc.findIndex((v) => v.name === (val == null ? void 0 : val.name)) < 0) {
        acc.push(val);
      }
      return acc;
    }, []);
  }, [documentTypesNarrowed, fieldDefinition, schema]);
  const handleClear = (0, import_react51.useCallback)(() => handleChange(null), [handleChange]);
  const handleClick = (0, import_react51.useCallback)(() => {
    onClose == null ? void 0 : onClose();
  }, [onClose]);
  return (0, import_jsx_runtime6.jsx)(Box, { style: { width: "min(calc(100vw - 40px), 420px)" }, children: (value == null ? void 0 : value._ref) && (value == null ? void 0 : value._type) ? (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Card, { padding: 1, radius: 1, shadow: 1, children: (0, import_jsx_runtime6.jsx)(SearchResultItem, { compact: true, documentId: value._ref, documentType: value._type, onClick: handleClick }) }), (0, import_jsx_runtime6.jsx)(Button, { fontSize: fullscreen ? 2 : 1, mode: "ghost", onClick: handleClear, text: t3("search.filter-reference-clear"), tone: "critical" })] }) : (0, import_jsx_runtime6.jsx)(ReferenceAutocomplete, { onSelect: handleChange, types: searchableTypes, value }) });
}
function CustomMenuItem$2(_ref350) {
  let { onClick, selected, title, value } = _ref350;
  const handleClick = (0, import_react51.useCallback)(() => onClick(value), [onClick, value]);
  return (0, import_jsx_runtime6.jsx)(MenuItem, { onClick: handleClick, padding: 3, pressed: selected, tone: "default", children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "space-between", gap: 3, children: (0, import_jsx_runtime6.jsxs)(Stack, { paddingRight: 2, space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "regular", children: title }), value && (0, import_jsx_runtime6.jsx)(Code, { muted: true, size: 0, children: value })] }) }) });
}
function SearchFilterStringListInput(_ref351) {
  let { fieldDefinition, onChange, value } = _ref351;
  const menuButtonId = (0, import_react51.useId)();
  const { state: { documentTypesNarrowed } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const schema = useSchema();
  const items = (0, import_react51.useMemo)(() => {
    if (!fieldDefinition) {
      return [];
    }
    const options = fieldDefinition.documentTypes.filter((d) => documentTypesNarrowed.includes(d)).map((type) => {
      const schemaType = schema.get(type);
      if (schemaType) {
        const field = getSchemaField(schemaType, fieldDefinition.fieldPath);
        return field == null ? void 0 : field.type.options;
      }
      return null;
    }).filter(isNonNullable$3);
    const selectOptions = options.map((o) => o.list).flatMap((list) => list == null ? void 0 : list.map((l) => toSelectItem(l))).filter(isNonNullable$3);
    return selectOptions.reduce((acc, val) => {
      const prevIndex = acc.findIndex((v) => v.value === (val == null ? void 0 : val.value));
      if (prevIndex > -1) {
        const prevValue = acc[prevIndex];
        acc[prevIndex] = { ...acc[prevIndex], title: (0, import_uniq4.default)([...prevValue.title, val.title]).sort() };
      } else {
        acc.push({ ...val, title: [val.title] });
      }
      return acc;
    }, []);
  }, [documentTypesNarrowed, fieldDefinition, schema]);
  const handleClick = (0, import_react51.useCallback)((v) => {
    onChange(v);
  }, [onChange]);
  return (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", padding: 3, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, justify: "space-between", children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "regular", children: value ? value : t3("search.filter-string-value-select-predefined-value") }), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(SelectIcon, {}) }) })] }) }), id: menuButtonId || "", menu: (0, import_jsx_runtime6.jsx)(Menu, { children: items.map((item, index) => (0, import_jsx_runtime6.jsx)(CustomMenuItem$2, { onClick: handleClick, selected: item.value === value, title: item.title.join(", "), value: item.value || "" }, index)) }), popover: { constrainSize: true, placement: "bottom-start", portal: false, radius: 2 } });
}
function toSelectItem(option) {
  return isTitledListValue(option) ? option : { title: (0, import_capitalize2.default)("".concat(option)), value: option };
}
var GteIcon = () => (0, import_jsx_runtime6.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime6.jsx)("path", { d: "M7.04 19V17.512H17.36V19H7.04ZM7.04 15.328V13.624L12.08 11.872L15.32 10.816V10.72L12.08 9.664L7.04 7.912V6.208L17.36 9.88V11.656L7.04 15.328Z", fill: "currentColor" }) });
var GtIcon = () => (0, import_jsx_runtime6.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime6.jsx)("path", { d: "M7.568 18.848V16.952L14.792 12.08V11.984L7.568 7.112V5.216L16.52 11.288V12.776L7.568 18.848Z", fill: "currentColor" }) });
var LteIcon = () => (0, import_jsx_runtime6.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime6.jsx)("path", { d: "M7.04 19V17.512H17.36V19H7.04ZM17.36 15.328L7.04 11.656V9.88L17.36 6.208V7.912L12.32 9.664L9.08 10.72V10.816L12.32 11.872L17.36 13.624V15.328Z", fill: "currentColor" }) });
var LtIcon = () => (0, import_jsx_runtime6.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime6.jsx)("path", { d: "M16.952 19.632L8 13.56V12.072L16.952 6V7.896L9.728 12.768V12.864L16.952 17.736V19.632Z", fill: "currentColor" }) });
function defineSearchOperator(definition) {
  return definition;
}
function toJSON(val) {
  return JSON.stringify(val);
}
var arrayOperators = { arrayCountEqual: defineSearchOperator({ nameKey: "search.operator.array-count-equal.name", descriptionKey: "search.operator.array-count-equal.description", groqFilter: (_ref352) => {
  let { fieldPath, value } = _ref352;
  return Number.isFinite(value) && fieldPath ? "count(".concat(fieldPath, ") == ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterNumberInput, type: "arrayCountEqual" }), arrayCountGt: defineSearchOperator({ nameKey: "search.operator.array-count-gt.name", descriptionKey: "search.operator.array-count-gt.description", groqFilter: (_ref353) => {
  let { fieldPath, value } = _ref353;
  return Number.isFinite(value) && fieldPath ? "count(".concat(fieldPath, ") > ").concat(toJSON(value)) : null;
}, icon: GtIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "arrayCountGt" }), arrayCountGte: defineSearchOperator({ nameKey: "search.operator.array-count-gte.name", descriptionKey: "search.operator.array-count-gte.description", groqFilter: (_ref354) => {
  let { fieldPath, value } = _ref354;
  return Number.isFinite(value) && fieldPath ? "count(".concat(fieldPath, ") >= ").concat(toJSON(value)) : null;
}, icon: GteIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "arrayCountGte" }), arrayCountLt: defineSearchOperator({ nameKey: "search.operator.array-count-lt.name", descriptionKey: "search.operator.array-count-lt.description", groqFilter: (_ref355) => {
  let { fieldPath, value } = _ref355;
  return Number.isFinite(value) && fieldPath ? "count(".concat(fieldPath, ") < ").concat(toJSON(value)) : null;
}, icon: LtIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "arrayCountLt" }), arrayCountLte: defineSearchOperator({ nameKey: "search.operator.array-count-lte.name", descriptionKey: "search.operator.array-count-lte.description", groqFilter: (_ref356) => {
  let { fieldPath, value } = _ref356;
  return Number.isFinite(value) && fieldPath ? "count(".concat(fieldPath, ") <= ").concat(toJSON(value)) : null;
}, icon: LteIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "arrayCountLte" }), arrayCountNotEqual: defineSearchOperator({ nameKey: "search.operator.array-count-not-equal.name", descriptionKey: "search.operator.array-count-not-equal.description", groqFilter: (_ref357) => {
  let { fieldPath, value } = _ref357;
  return Number.isFinite(value) && fieldPath ? "count(".concat(fieldPath, ") != ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterNumberInput, type: "arrayCountNotEqual" }), arrayCountRange: defineSearchOperator({ nameKey: "search.operator.array-count-range.name", descriptionKey: "search.operator.array-count-range.description", groqFilter: (_ref358) => {
  let { fieldPath, value } = _ref358;
  return Number.isFinite(value == null ? void 0 : value.to) && Number.isFinite(value == null ? void 0 : value.from) && fieldPath ? "count(".concat(fieldPath, ") > ").concat(toJSON(value == null ? void 0 : value.from), " && count(").concat(fieldPath, ") < ").concat(toJSON(value == null ? void 0 : value.to)) : "";
}, initialValue: null, inputComponent: SearchFilterNumberRangeInput, type: "arrayCountRange" }), arrayListIncludes: defineSearchOperator({ nameKey: "search.operator.array-list-includes.name", descriptionKey: "search.operator.array-list-includes.description", groqFilter: (_ref359) => {
  let { fieldPath, value } = _ref359;
  return value && fieldPath ? "".concat(toJSON(value), " in ").concat(fieldPath) : null;
}, initialValue: null, inputComponent: SearchFilterStringListInput, type: "arrayListIncludes" }), arrayListNotIncludes: defineSearchOperator({ nameKey: "search.operator.array-list-not-includes.name", descriptionKey: "search.operator.array-list-not-includes.description", groqFilter: (_ref360) => {
  let { fieldPath, value } = _ref360;
  return value && fieldPath ? "!(".concat(toJSON(value), " in ").concat(fieldPath, ")") : null;
}, initialValue: null, inputComponent: SearchFilterStringListInput, type: "arrayListNotIncludes" }), arrayReferenceIncludes: defineSearchOperator({ nameKey: "search.operator.array-reference-includes.name", descriptionKey: "search.operator.array-reference-includes.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref361) => {
  let { fieldPath, value } = _ref361;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(toJSON(value._ref), " in ").concat(fieldPath, "[]._ref") : null;
}, initialValue: null, inputComponent: SearchFilterReferenceInput, type: "arrayReferenceIncludes" }), arrayReferenceNotIncludes: defineSearchOperator({ nameKey: "search.operator.array-reference-not-includes.name", descriptionKey: "search.operator.array-reference-not-includes.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref362) => {
  let { fieldPath, value } = _ref362;
  return (value == null ? void 0 : value._ref) && fieldPath ? "!(".concat(toJSON(value._ref), " in ").concat(fieldPath, "[]._ref)") : null;
}, initialValue: null, inputComponent: SearchFilterReferenceInput, type: "arrayReferenceNotIncludes" }) };
var WorkspaceContext = (0, import_react51.createContext)(null);
function WorkspaceProvider(_ref363) {
  let { children, workspace } = _ref363;
  return (0, import_jsx_runtime6.jsx)(WorkspaceContext.Provider, { value: workspace, children });
}
function useWorkspace() {
  const workspace = (0, import_react51.useContext)(WorkspaceContext);
  if (!workspace)
    throw new Error("Workspace: missing context value");
  return workspace;
}
var SourceContext = (0, import_react51.createContext)(null);
function SourceProvider(_ref364) {
  let { children, ...props2 } = _ref364;
  const parentSource = (0, import_react51.useContext)(SourceContext);
  const { unstable_sources: sources } = useWorkspace();
  if ("source" in props2) {
    const { source } = props2;
    return (0, import_jsx_runtime6.jsx)(SourceContext.Provider, { value: source, children });
  }
  if ("name" in props2) {
    const { name } = props2;
    const source = sources.find((s) => s.name === name);
    if (!source) {
      throw new Error("Could not find source with name `".concat(name, "` in current workspace"));
    }
    if (parentSource === source)
      return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children });
    return (0, import_jsx_runtime6.jsx)(SourceContext.Provider, { value: source, children });
  }
  throw new Error("Invalid props passed into SourceProvider. A `name` or a `source` object is required.");
}
function useSource() {
  const source = (0, import_react51.useContext)(SourceContext);
  if (!source)
    throw new Error("Could not find `source` context");
  return source;
}
function AssetSourceError(props2) {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Box, { ...props2, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "flex-start", gap: 3, children: [(0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "caution", children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "caution", weight: "semibold", children: t3("search.error.no-valid-asset-source-title") }), (0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "caution", children: t3("search.error.no-valid-asset-source-only-default-description") }), (0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "caution", children: t3("search.error.no-valid-asset-source-check-config-description") })] })] }) });
}
function FileReferencePreview(_ref365) {
  let { reference: reference2 } = _ref365;
  const documentPreviewStore = useDocumentPreviewStore();
  const observeAsset = (0, import_react51.useCallback)((id4) => observeFileAsset(documentPreviewStore, id4), [documentPreviewStore]);
  return (0, import_jsx_runtime6.jsx)(WithReferencedAsset, { observeAsset, reference: reference2, waitPlaceholder: (0, import_jsx_runtime6.jsx)(FileSkeleton, {}), children: (asset) => (0, import_jsx_runtime6.jsx)(FilePreview, { asset }) });
}
function FilePreview(_ref366) {
  let { asset } = _ref366;
  return (0, import_jsx_runtime6.jsx)(Card, { padding: 2, shadow: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "space-between", wrap: "nowrap", children: [(0, import_jsx_runtime6.jsx)(Card, { padding: 3, radius: 1, shadow: 1, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(BinaryDocumentIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, marginLeft: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 2, textOverflow: "ellipsis", muted: true, children: (asset == null ? void 0 : asset.originalFilename) || asset._id }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: formatBytes(asset.size) })] })] }) });
}
function FileSkeleton() {
  return (0, import_jsx_runtime6.jsx)(Card, { padding: 2, shadow: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "flex-start", children: [(0, import_jsx_runtime6.jsx)(Card, { padding: 3, radius: 1, shadow: 1, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(BinaryDocumentIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, marginLeft: 3, children: [(0, import_jsx_runtime6.jsx)(LabelSkeleton, { animated: true, style: { width: "100%" }, radius: 1 }), (0, import_jsx_runtime6.jsx)(LabelSkeleton, { animated: true, style: { width: "100%" }, radius: 1 })] })] }) });
}
var __freeze$R = Object.freeze;
var __defProp$R = Object.defineProperty;
var __template$R = (cooked, raw) => __freeze$R(__defProp$R(cooked, "raw", { value: __freeze$R(raw || cooked.slice()) }));
var _a$R;
var _b$p;
var _c$g;
var Container3 = st(Card)(_a$R || (_a$R = __template$R(["\n  position: relative;\n  padding-bottom: 100%;\n"])));
var Image$1 = st.img(_b$p || (_b$p = __template$R(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: block;\n  object-fit: contain;\n"])));
var SpinnerFlex = st(Flex)(_c$g || (_c$g = __template$R(["\n  height: 100%;\n  position: absolute;\n  width: 100%;\n"])));
function ImageReferencePreview(_ref367) {
  let { reference: reference2 } = _ref367;
  const documentPreviewStore = useDocumentPreviewStore();
  const observeAsset = (0, import_react51.useCallback)((id4) => observeImageAsset(documentPreviewStore, id4), [documentPreviewStore]);
  return (0, import_jsx_runtime6.jsx)(WithReferencedAsset, { observeAsset, reference: reference2, children: (asset) => (0, import_jsx_runtime6.jsx)(ImagePreview, { asset }) });
}
function ImagePreview(_ref368) {
  let { asset } = _ref368;
  const [loaded, setLoaded] = (0, import_react51.useState)(false);
  const imageUrl = "".concat(asset.url, "?h=800&fit=max");
  const handleLoad = (0, import_react51.useCallback)(() => setLoaded(true), []);
  return (0, import_jsx_runtime6.jsxs)(Container3, { __unstable_checkered: true, border: true, children: [!loaded && (0, import_jsx_runtime6.jsx)(SpinnerFlex, { align: "center", justify: "center", children: (0, import_jsx_runtime6.jsx)(Spinner, {}) }), (0, import_jsx_runtime6.jsx)(Image$1, { onLoad: handleLoad, src: imageUrl })] });
}
function AssetPreview(_ref369) {
  let { reference: reference2 } = _ref369;
  if (!reference2) {
    return null;
  }
  if (reference2._type.startsWith("sanity.fileAsset")) {
    return (0, import_jsx_runtime6.jsx)(FileReferencePreview, { reference: reference2 });
  }
  if (reference2._type.startsWith("sanity.imageAsset")) {
    return (0, import_jsx_runtime6.jsx)(ImageReferencePreview, { reference: reference2 });
  }
  return null;
}
var __freeze$Q = Object.freeze;
var __defProp$Q = Object.defineProperty;
var __template$Q = (cooked, raw) => __freeze$Q(__defProp$Q(cooked, "raw", { value: __freeze$Q(raw || cooked.slice()) }));
var _a$Q;
var ASSET_TYPE = { file: "sanity.fileAsset", image: "sanity.imageAsset" };
var ContainerBox = st(Box)(_a$Q || (_a$Q = __template$Q(["\n  width: min(calc(100vw - 40px), 320px);\n"])));
function SearchFilterAssetInput(type) {
  return function FieldInputAssetWithType(_ref370) {
    let { onChange, value } = _ref370;
    const [selectedAssetSource, setSelectedAssetSource] = (0, import_react51.useState)(null);
    const [selectedAssetFromSource, setSelectedAssetFromSource] = (0, import_react51.useState)(null);
    const { state: { fullscreen } } = useSearchState();
    const { file: file2, image: image2 } = useSource().form;
    const { t: t3 } = useTranslation2();
    const assetSources = (0, import_react51.useMemo)(() => {
      switch (type) {
        case "file":
          return file2.assetSources.filter((a) => a.name === FileSource.name);
        case "image":
          return image2.assetSources.filter((a) => a.name === ImageSource.name);
        default:
          throw Error("Unknown asset source found");
      }
    }, [file2.assetSources, image2.assetSources]);
    const menuButtonId = (0, import_react51.useId)();
    const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
    const handleClear = (0, import_react51.useCallback)(() => {
      setSelectedAssetFromSource(null);
      onChange(null);
    }, [onChange]);
    const handleCloseAssetSource = (0, import_react51.useCallback)(() => {
      setSelectedAssetSource(null);
    }, []);
    const handleSelectAssetFromSource2 = (0, import_react51.useCallback)((assetFromSource) => {
      const firstAsset = assetFromSource[0];
      setSelectedAssetFromSource(firstAsset);
      handleCloseAssetSource();
    }, [handleCloseAssetSource]);
    const handleSelectAssetSource = (0, import_react51.useCallback)((source) => setSelectedAssetSource(source), []);
    (0, import_react51.useEffect)(() => {
      if ((selectedAssetFromSource == null ? void 0 : selectedAssetFromSource.kind) === "assetDocumentId" && typeof (selectedAssetFromSource == null ? void 0 : selectedAssetFromSource.value) === "string") {
        if (type) {
          onChange({ _ref: selectedAssetFromSource.value, _type: ASSET_TYPE[type] });
        }
      }
    }, [client, onChange, selectedAssetFromSource]);
    const AssetSourceComponent = selectedAssetSource == null ? void 0 : selectedAssetSource.component;
    const fontSize2 = fullscreen ? 2 : 1;
    const buttonText = t3(value ? "search.filter-asset-change" : "search.filter-asset-select", { context: type });
    const accept = (0, import_get3.default)(type, "options.accept", type === "image" ? "image/*" : "");
    return (0, import_jsx_runtime6.jsx)(ContainerBox, { children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [selectedAssetSource && AssetSourceComponent && (0, import_jsx_runtime6.jsx)(Portal, { children: (0, import_jsx_runtime6.jsx)(AssetSourceComponent, { assetType: type, dialogHeaderTitle: t3("search.action.select-asset", { context: type }), onClose: handleCloseAssetSource, onSelect: handleSelectAssetFromSource2, selectedAssets: [], selectionType: "single", accept }) }), value && (0, import_jsx_runtime6.jsx)(AssetPreview, { reference: value }), (0, import_jsx_runtime6.jsxs)(Flex, { gap: 2, children: [assetSources.length === 0 && (0, import_jsx_runtime6.jsx)(AssetSourceError, { padding: 2 }), assetSources.length > 0 && (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: assetSources.length > 1 ? (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { fontSize: fontSize2, icon: value ? UndoIcon : SearchIcon, iconRight: ChevronDownIcon, mode: "ghost", style: { flex: value ? 1 : 0 }, text: buttonText }), id: menuButtonId, menu: (0, import_jsx_runtime6.jsx)(Menu, { children: assetSources.map((source) => (0, import_jsx_runtime6.jsx)(MenuItem, { fontSize: fontSize2, icon: source.icon || ImageIcon, onClick: () => handleSelectAssetSource(source), text: (source.i18nKey ? t3(source.i18nKey) : source.title) || (0, import_startCase2.default)(source.name) }, source.name)) }), popover: { constrainSize: true, portal: false, radius: 2 } }) : (0, import_jsx_runtime6.jsx)(Button, { fontSize: fontSize2, icon: value ? UndoIcon : SearchIcon, mode: "ghost", onClick: () => handleSelectAssetSource(assetSources[0]), style: { flex: value ? 1 : 0 }, text: buttonText }) }), value && (0, import_jsx_runtime6.jsx)(Button, { fontSize: fullscreen ? 2 : 1, mode: "ghost", onClick: handleClear, style: { flex: 1 }, text: t3("search.filter-asset-clear"), tone: "critical" })] })] }) });
  };
}
var assetOperators = { assetFileEqual: defineSearchOperator({ nameKey: "search.operator.asset-file-equal.name", descriptionKey: "search.operator.asset-file-equal.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref371) => {
  let { fieldPath, value } = _ref371;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(fieldPath, ".asset._ref == ").concat(toJSON(value._ref)) : null;
}, initialValue: null, inputComponent: SearchFilterAssetInput("file"), label: "is", type: "assetFileEqual" }), assetFileNotEqual: defineSearchOperator({ nameKey: "search.operator.asset-file-not-equal.name", descriptionKey: "search.operator.asset-file-not-equal.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref372) => {
  let { fieldPath, value } = _ref372;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(fieldPath, ".asset._ref != ").concat(toJSON(value._ref)) : null;
}, initialValue: null, inputComponent: SearchFilterAssetInput("file"), label: "is not", type: "assetFileNotEqual" }), assetImageEqual: defineSearchOperator({ nameKey: "search.operator.asset-image-equal.name", descriptionKey: "search.operator.asset-image-equal.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref373) => {
  let { fieldPath, value } = _ref373;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(fieldPath, ".asset._ref == ").concat(toJSON(value._ref)) : null;
}, initialValue: null, inputComponent: SearchFilterAssetInput("image"), label: "is", type: "assetImageEqual" }), assetImageNotEqual: defineSearchOperator({ nameKey: "search.operator.asset-image-not-equal.name", descriptionKey: "search.operator.asset-image-not-equal.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref374) => {
  let { fieldPath, value } = _ref374;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(fieldPath, ".asset._ref != ").concat(toJSON(value._ref)) : null;
}, initialValue: null, inputComponent: SearchFilterAssetInput("image"), label: "is not", type: "assetImageNotEqual" }) };
function SearchFilterBooleanInput(_ref375) {
  let { onChange, value } = _ref375;
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((event) => {
    onChange(event.currentTarget.value === "true");
  }, [onChange]);
  return (0, import_jsx_runtime6.jsxs)(Select, { fontSize: fullscreen ? 2 : 1, onChange: handleChange, radius: 2, value: String(value != null ? value : true), children: [(0, import_jsx_runtime6.jsx)("option", { value: "true", children: t3("search.filter-boolean-true") }), (0, import_jsx_runtime6.jsx)("option", { value: "false", children: t3("search.filter-boolean-false") })] });
}
var booleanOperators = { booleanEqual: defineSearchOperator({ nameKey: "search.operator.boolean-equal.name", descriptionKey: "search.operator.boolean-equal.description", groqFilter: (_ref376) => {
  let { fieldPath, value } = _ref376;
  return typeof value !== "undefined" && fieldPath ? "".concat(fieldPath, " == ").concat(toJSON(value)) : null;
}, initialValue: true, inputComponent: SearchFilterBooleanInput, type: "booleanEqual" }) };
var definedOperators = { defined: defineSearchOperator({ nameKey: "search.operator.defined.name", descriptionKey: "search.operator.defined.description", groqFilter: (_ref377) => {
  let { fieldPath } = _ref377;
  return fieldPath ? "defined(".concat(fieldPath, ")") : null;
}, type: "defined" }), notDefined: defineSearchOperator({ nameKey: "search.operator.not-defined.name", descriptionKey: "search.operator.not-defined.description", i18nKey: "search.operator.not-defined", groqFilter: (_ref378) => {
  let { fieldPath } = _ref378;
  return fieldPath ? "!defined(".concat(fieldPath, ")") : null;
}, type: "notDefined" }) };
var __freeze$P = Object.freeze;
var __defProp$P = Object.defineProperty;
var __template$P = (cooked, raw) => __freeze$P(__defProp$P(cooked, "raw", { value: __freeze$P(raw || cooked.slice()) }));
var _a$P;
var TimeLabelText = st(Text3)(_a$P || (_a$P = __template$P(["\n  cursor: default;\n"])));
function DateIncludeTimeFooter(_ref379) {
  let { onChange, value } = _ref379;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, justify: "flex-end", marginTop: 1, children: [(0, import_jsx_runtime6.jsx)(Stack, { children: (0, import_jsx_runtime6.jsx)(TimeLabelText, { muted: true, onClick: onChange, size: 1, weight: "medium", children: t3("calendar.action.include-time-label") }) }), (0, import_jsx_runtime6.jsx)(Switch, { checked: value, label: t3("calendar.action.include-time-label"), onChange })] });
}
var CalendarContext = (0, import_react51.createContext)(void 0);
function useCalendar() {
  const context = (0, import_react51.useContext)(CalendarContext);
  if (context === void 0) {
    throw new Error("useCalendar must be used within an CalendarContext.Provider");
  }
  return context;
}
function CalendarHeader(props2) {
  const { t: t3 } = useTranslation2();
  const monthFormatter = useIntlDateTimeFormat({ month: "long", year: "numeric" });
  const { focusedDate } = useCalendar();
  const { fontSize: fontSize2, moveFocusedDate, onNowClick } = props2;
  const handlePrevMonthClick = (0, import_react51.useCallback)(() => moveFocusedDate(-1), [moveFocusedDate]);
  const handleNextMonthClick = (0, import_react51.useCallback)(() => moveFocusedDate(1), [moveFocusedDate]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", flex: 1, justify: "space-between", children: [(0, import_jsx_runtime6.jsx)(Inline, { paddingLeft: 2, space: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "medium", children: (0, import_upperFirst.default)(monthFormatter.format(focusedDate)) }) }), (0, import_jsx_runtime6.jsxs)(Box, { children: [(0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("calendar.action.go-to-today-aria-label"), fontSize: fontSize2, mode: "bleed", onClick: onNowClick, text: t3("calendar.action.go-to-today") }), (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("calendar.action.go-to-previous-month"), icon: ChevronLeftIcon, mode: "bleed", onClick: handlePrevMonthClick }), (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("calendar.action.go-to-next-month"), icon: ChevronRightIcon, mode: "bleed", onClick: handleNextMonthClick })] })] });
}
var __freeze$O = Object.freeze;
var __defProp$O = Object.defineProperty;
var __template$O = (cooked, raw) => __freeze$O(__defProp$O(cooked, "raw", { value: __freeze$O(raw || cooked.slice()) }));
var _a$O;
var _b$o;
var CircleSvg = st.svg((_ref380) => {
  let { theme } = _ref380;
  return nt(_a$O || (_a$O = __template$O(["\n    bottom: 0;\n    left: 0;\n    position: absolute;\n    right: 0;\n    top: 0;\n\n    circle {\n      stroke: ", ";\n      stroke-width: 3;\n      fill: none;\n    }\n  "])), theme.sanity.color.card.enabled.border);
});
var CustomCard = st(Card)(_b$o || (_b$o = __template$O(["\n  position: relative;\n\n  &[data-focused='true'] {\n    z-index: 1;\n  }\n\n  &[data-start-date='true'] {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  &[data-end-date='true'] {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  &[data-within-range='true'] {\n    border-radius: 0;\n  }\n"])));
function CalendarDay(_ref381) {
  let { date, onSelect } = _ref381;
  const handleClick = (0, import_react51.useCallback)(() => {
    onSelect(date);
  }, [date, onSelect]);
  const { date: selectedDate, endDate: selectedEndDate, focusedDate, fontSize: fontSize2, selectRange } = useCalendar();
  const isSelected = selectedDate && isSameDay(date, selectedDate);
  const isStartDate = selectRange && selectedDate && isSameDay(date, selectedDate);
  const isEndDate = selectRange && selectedEndDate && isSameDay(date, selectedEndDate);
  const isCurrentMonth = isSameMonth(date, focusedDate);
  const isFocused = focusedDate && isSameDay(date, focusedDate);
  const isToday = isSameDay(date, /* @__PURE__ */ new Date());
  const isWithinRange = selectedDate && selectedEndDate && !isStartDate && !isEndDate && isAfter(date, selectedDate) && isBefore(date, selectedEndDate);
  return (0, import_jsx_runtime6.jsxs)(CustomCard, { __unstable_focusRing: true, "aria-label": date.toDateString(), "aria-pressed": isSelected, "data-end-date": isEndDate ? true : void 0, "data-focused": isFocused ? "true" : "", "data-ui": "CalendarDay", "aria-selected": isSelected, "data-start-date": isStartDate ? true : void 0, "data-within-range": isWithinRange ? true : void 0, forwardedAs: "button", onClick: handleClick, padding: 3, radius: 2, role: "button", selected: isSelected || isStartDate || isEndDate, tabIndex: -1, tone: isWithinRange ? "primary" : "default", children: [isToday && (0, import_jsx_runtime6.jsx)(CircleSvg, { height: "100%", preserveAspectRatio: "xMidYMid meet", vectorEffect: "non-scaling-stroke", viewBox: "0 0 100 100", width: "100%", children: (0, import_jsx_runtime6.jsx)("circle", { cx: "50", cy: "50", r: "40%" }) }), (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: !isSelected && !isCurrentMonth, size: fontSize2, weight: isToday ? "medium" : "regular", children: date.getDate() })] });
}
var SHORT_WEEK_DAY_KEYS = ["calendar.weekday-names.short.sunday", "calendar.weekday-names.short.monday", "calendar.weekday-names.short.tuesday", "calendar.weekday-names.short.wednesday", "calendar.weekday-names.short.thursday", "calendar.weekday-names.short.friday", "calendar.weekday-names.short.saturday"];
(0, import_range.default)(0, 24);
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var TAIL_WEEKDAYS = [1, 2, 3, 4, 5, 6];
var getWeekStartsOfMonth = (date) => {
  const firstDay = startOfMonth(date);
  return eachWeekOfInterval({ start: firstDay, end: lastDayOfMonth(firstDay) });
};
var getWeekDaysFromWeekStarts = (weekStarts) => {
  return weekStarts.map((weekStart) => [weekStart, ...TAIL_WEEKDAYS.map((d) => addDays(weekStart, d))]);
};
var getWeeksOfMonth = (date) => getWeekDaysFromWeekStarts(getWeekStartsOfMonth(date)).map((days) => ({ number: getWeek(days[0]), days }));
var __freeze$N = Object.freeze;
var __defProp$N = Object.defineProperty;
var __template$N = (cooked, raw) => __freeze$N(__defProp$N(cooked, "raw", { value: __freeze$N(raw || cooked.slice()) }));
var _a$N;
var CustomGrid = st(Grid)(_a$N || (_a$N = __template$N(["\n  grid-template-columns: repeat(7, minmax(44px, auto));\n"])));
function CalendarMonth(_ref382) {
  let { hidden, onSelect } = _ref382;
  const { focusedDate, fontSize: fontSize2 } = useCalendar();
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Box, { "aria-hidden": hidden || false, "data-ui": "CalendarMonth", children: (0, import_jsx_runtime6.jsxs)(CustomGrid, { children: [SHORT_WEEK_DAY_KEYS.map((weekdayDay) => (0, import_jsx_runtime6.jsx)(Box, { paddingBottom: 3, paddingTop: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", size: fontSize2, weight: "medium", children: t3(weekdayDay) }) }, weekdayDay)), getWeeksOfMonth(focusedDate).map((week, weekIdx) => week.days.map((weekDayDate, dayIdx) => {
    return (0, import_jsx_runtime6.jsx)(CalendarDay, { date: weekDayDate, onSelect }, "".concat(weekIdx, "-").concat(dayIdx));
  }))] }) });
}
var PRESERVE_FOCUS_ELEMENT = (0, import_jsx_runtime6.jsx)("span", { "data-preserve-focus": true, style: { overflow: "hidden", position: "absolute", outline: "none" }, tabIndex: -1 });
function Calendar(props2) {
  const { date, endDate, fontSize: fontSize2, onSelect, selectRange, selectTime } = props2;
  const [calendarElement, setCalendarElement] = (0, import_react51.useState)(null);
  const [selectEndValue, setSelectEndValue] = (0, import_react51.useState)(false);
  const [focusedDate, setFocusedDate] = (0, import_react51.useState)(date || /* @__PURE__ */ new Date());
  const previousDate = (0, import_react51.useRef)(date || null);
  const previousEndDate = (0, import_react51.useRef)(endDate || null);
  const focusCurrentWeekDay = (0, import_react51.useCallback)(() => {
    var _a4;
    (_a4 = calendarElement == null ? void 0 : calendarElement.querySelector('[data-focused="true"]')) == null ? void 0 : _a4.focus();
  }, [calendarElement]);
  const handleDateChange = (0, import_react51.useCallback)((d) => {
    const selectedDate = set(d, { hours: d.getHours(), minutes: d.getMinutes(), seconds: 0, milliseconds: 0 });
    const dateIsBeforeStartDate = date && isBefore(selectedDate, date);
    const dateIsAfterEndDate = endDate && isAfter(selectedDate, endDate);
    if (selectRange) {
      if (dateIsBeforeStartDate || dateIsAfterEndDate) {
        onSelect({ date: selectedDate, endDate: null });
        return;
      }
      if (selectEndValue) {
        onSelect({ date: date || null, endDate: selectedDate });
      } else {
        onSelect({ date: selectedDate, endDate: date ? null : endDate || null });
      }
    } else {
      onSelect({ date: selectedDate });
    }
  }, [date, endDate, onSelect, selectEndValue, selectRange]);
  const handleNowClick = (0, import_react51.useCallback)(() => {
    const now3 = /* @__PURE__ */ new Date();
    if (selectRange) {
      setFocusedDate(now3);
    } else {
      onSelect({ date: now3 });
    }
  }, [onSelect, selectRange, setFocusedDate]);
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    var _a4;
    if (!ARROW_KEYS.includes(event.key)) {
      return;
    }
    event.preventDefault();
    if (event.target.hasAttribute("data-calendar-grid")) {
      focusCurrentWeekDay();
      return;
    }
    if (event.key === "ArrowUp") {
      setFocusedDate(addDays(focusedDate, -7));
    }
    if (event.key === "ArrowDown") {
      setFocusedDate(addDays(focusedDate, 7));
    }
    if (event.key === "ArrowLeft") {
      setFocusedDate(addDays(focusedDate, -1));
    }
    if (event.key === "ArrowRight") {
      setFocusedDate(addDays(focusedDate, 1));
    }
    (_a4 = calendarElement == null ? void 0 : calendarElement.querySelector("[data-preserve-focus]")) == null ? void 0 : _a4.focus();
  }, [calendarElement, focusCurrentWeekDay, focusedDate, setFocusedDate]);
  const moveFocusedDate = (0, import_react51.useCallback)((by) => setFocusedDate(addMonths(focusedDate, by)), [focusedDate, setFocusedDate]);
  (0, import_react51.useEffect)(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]);
  (0, import_react51.useEffect)(() => {
    var _a4;
    const currentFocusInCalendarGrid = (_a4 = document.activeElement) == null ? void 0 : _a4.matches("[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]");
    if (
      // Only move focus if it's currently in the calendar grid
      currentFocusInCalendarGrid
    ) {
      focusCurrentWeekDay();
    }
  }, [focusCurrentWeekDay, focusedDate]);
  (0, import_react51.useEffect)(() => {
    var _a4, _b4;
    const dateChanged = (date == null ? void 0 : date.getTime()) !== ((_a4 = previousDate.current) == null ? void 0 : _a4.getTime());
    const endDateChanged = (endDate == null ? void 0 : endDate.getTime()) !== ((_b4 = previousEndDate.current) == null ? void 0 : _b4.getTime());
    const onlyDateChanged = dateChanged && !endDateChanged;
    const onlyEndDateChanged = !dateChanged && endDateChanged;
    const dateIsAfterEndDate = date && endDate && isAfter(date, endDate);
    if (onlyDateChanged) {
      if (dateIsAfterEndDate) {
        setSelectEndValue(true);
        onSelect({ date, endDate: null });
      }
      setSelectEndValue(!!date);
      if (date)
        setFocusedDate(date);
    }
    if (onlyEndDateChanged) {
      if (dateIsAfterEndDate) {
        setSelectEndValue(true);
        onSelect({ date: endDate, endDate: null });
      }
      setSelectEndValue(!!date && !endDate);
      if (endDate)
        setFocusedDate(endDate);
    }
    if (dateChanged && endDateChanged) {
      setSelectEndValue(true);
      if (date)
        setFocusedDate(date);
    }
    previousDate.current = date || null;
    previousEndDate.current = endDate || null;
  }, [date, endDate, onSelect]);
  return (0, import_jsx_runtime6.jsx)(CalendarContext.Provider, { value: { date, endDate, focusedDate, fontSize: fontSize2, selectRange, selectTime }, children: (0, import_jsx_runtime6.jsxs)(Box, { "data-ui": "Calendar", ref: setCalendarElement, children: [(0, import_jsx_runtime6.jsx)(Flex, { children: (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(CalendarHeader, { fontSize: fontSize2, moveFocusedDate, onNowClick: handleNowClick }) }) }), (0, import_jsx_runtime6.jsxs)(Box, { "data-calendar-grid": true, onKeyDown: handleKeyDown, marginTop: 2, overflow: "hidden", tabIndex: 0, children: [(0, import_jsx_runtime6.jsx)(CalendarMonth, { onSelect: handleDateChange }), PRESERVE_FOCUS_ELEMENT] })] }) });
}
function DatePicker(_ref383) {
  let { date, endDate, onChange, selectRange, selectTime } = _ref383;
  const { state: { fullscreen } } = useSearchState();
  const handleSelect = (0, import_react51.useCallback)((dates) => {
    onChange(dates);
  }, [onChange]);
  return (0, import_jsx_runtime6.jsx)(Calendar, { date, endDate, fontSize: fullscreen ? 2 : 1, onSelect: handleSelect, selectRange, selectTime });
}
var __freeze$M = Object.freeze;
var __defProp$M = Object.defineProperty;
var __template$M = (cooked, raw) => __freeze$M(__defProp$M(cooked, "raw", { value: __freeze$M(raw || cooked.slice()) }));
var _a$M;
var CustomTextInputBox = st(Box)((_ref384) => {
  let { $background, $smallClearButton } = _ref384;
  return nt(_a$M || (_a$M = __template$M(["\n    width: 100%;\n\n    input + span {\n      background: ", ";\n    }\n\n    [data-qa='clear-button'] {\n      background: none;\n      box-shadow: none;\n      display: flex; /* TODO: hack, currently used to vertically center <TextInput>'s clearButton */\n      transform: ", ";\n      &:hover {\n        opacity: 0.5;\n      }\n    }\n  "])), (_ref385) => {
    let { theme } = _ref385;
    return $background ? theme.sanity.color.card.disabled.bg2 : "transparent";
  }, $smallClearButton ? "scale(0.8)" : "scale(1)");
});
var CustomTextInput = (0, import_react51.forwardRef)(function CustomTextInput2(props2, ref) {
  const { background, smallClearButton, ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(CustomTextInputBox, { $background: background, $smallClearButton: smallClearButton, children: (0, import_jsx_runtime6.jsx)(TextInput, { ...rest, ref }) });
});
function getDateISOString(_ref386) {
  let { date, dateOnly, roundDay } = _ref386;
  let adjustedDate;
  switch (roundDay) {
    case "end":
      adjustedDate = endOfDay(date);
      break;
    case "start":
      adjustedDate = startOfDay(date);
      break;
    default:
      adjustedDate = date;
      break;
  }
  return dateOnly ? adjustedDate.toISOString().split("T")[0] : adjustedDate.toISOString();
}
var __freeze$L = Object.freeze;
var __defProp$L = Object.defineProperty;
var __template$L = (cooked, raw) => __freeze$L(__defProp$L(cooked, "raw", { value: __freeze$L(raw || cooked.slice()) }));
var _a$L;
var _b$n;
var FORMAT = { date: { exampleDate: "Jan 1, 2000", pattern: "MMM d, yyyy" }, datetime: { exampleDate: "Jan 1, 2000 12:00 AM", pattern: "MMM d, yyyy p" } };
var Emphasis = st.span((_ref387) => {
  let { theme } = _ref387;
  return nt(_a$L || (_a$L = __template$L(["\n    font-weight: ", ";\n  "])), theme.sanity.fonts.text.weights.medium);
});
var IconTextCritical = st(Text3)(_b$n || (_b$n = __template$L(["\n  color: ", ";\n"])), hues.red[500].hex);
function ParsedDateTextInput(_ref388) {
  let { isDateTime, onChange, placeholderDate, isDateTimeFormat, value, ...rest } = _ref388;
  const { t: t3 } = useTranslation2();
  const dateFormat = isDateTimeFormat ? FORMAT.datetime.pattern : FORMAT.date.pattern;
  const [customValidity, setCustomValidity] = (0, import_react51.useState)(void 0);
  const [inputValue, setInputValue] = (0, import_react51.useState)(() => {
    if (!value) {
      return "";
    }
    const inputValueDate = new Date(value);
    return format(inputValueDate, dateFormat);
  });
  const formattedPlaceholder = (0, import_react51.useMemo)(() => {
    const date = placeholderDate || /* @__PURE__ */ new Date();
    return format(date, dateFormat);
  }, [dateFormat, placeholderDate]);
  const processInputString = (0, import_react51.useCallback)((_ref389) => {
    let { dateString, triggerOnChange } = _ref389;
    if (!dateString) {
      return;
    }
    const dateParsed = parse(dateString, dateFormat, /* @__PURE__ */ new Date());
    const validDate = isValid(dateParsed);
    if (validDate) {
      if (triggerOnChange) {
        onChange(getDateISOString({ date: dateParsed, dateOnly: !isDateTime }));
      }
      setInputValue(format(dateParsed, dateFormat));
    }
    setCustomValidity(validDate ? void 0 : "Invalid ".concat(isDateTime ? "datetime" : "date"));
  }, [dateFormat, isDateTime, onChange]);
  const handleTextInputBlur = (0, import_react51.useCallback)(() => {
    processInputString({ dateString: inputValue, triggerOnChange: true });
  }, [inputValue, processInputString]);
  const handleTextInputChange = (0, import_react51.useCallback)((event) => {
    setInputValue(event.currentTarget.value);
  }, []);
  const handleTextInputClear = (0, import_react51.useCallback)(() => {
    onChange(null);
    setCustomValidity(void 0);
    setInputValue("");
  }, [onChange]);
  const handleTextInputKeyDown = (0, import_react51.useCallback)((event) => {
    if (event.key === "Enter") {
      processInputString({ dateString: inputValue, triggerOnChange: true });
    }
  }, [inputValue, processInputString]);
  (0, import_react51.useEffect)(() => {
    const updatedDate = value && new Date(value);
    if (updatedDate) {
      processInputString({ dateString: format(updatedDate, dateFormat), triggerOnChange: false });
    }
  }, [dateFormat, processInputString, isDateTimeFormat, value]);
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsxs)(Flex, { gap: 2, children: [(0, import_jsx_runtime6.jsx)(IconTextCritical, { size: 1, children: (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "calendar.error.must-be-in-format", components: { Emphasis }, values: { exampleDate: isDateTimeFormat ? FORMAT.datetime.exampleDate : FORMAT.date.exampleDate } }) })] }), disabled: !customValidity, padding: 3, placement: "top", portal: true, children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(CustomTextInput, { ...rest, clearButton: !!inputValue, customValidity, onBlur: handleTextInputBlur, onChange: handleTextInputChange, onClear: handleTextInputClear, onKeyDown: handleTextInputKeyDown, placeholder: formattedPlaceholder, value: inputValue }) }) });
}
function CommonDateEqualInput(_ref390) {
  let { isDateTime, onChange, value } = _ref390;
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleDatePickerChange = (0, import_react51.useCallback)((_ref391) => {
    let { date } = _ref391;
    if (date) {
      const dateISOString = getDateISOString({ date, dateOnly: !isDateTime });
      onChange({ includeTime: value == null ? void 0 : value.includeTime, date: dateISOString });
    } else {
      onChange(null);
    }
  }, [isDateTime, onChange, value == null ? void 0 : value.includeTime]);
  const handleIncludeTimeChange = (0, import_react51.useCallback)(() => {
    const includeTime = !(value == null ? void 0 : value.includeTime);
    const date = (value == null ? void 0 : value.date) ? new Date(value.date) : null;
    let dateISOString = null;
    if (date) {
      dateISOString = getDateISOString({ date, dateOnly: !isDateTime });
    }
    onChange({ includeTime, date: dateISOString });
  }, [isDateTime, onChange, value]);
  const handleTextDateChange = (0, import_react51.useCallback)((date) => {
    onChange({ includeTime: value == null ? void 0 : value.includeTime, date: date || null });
  }, [onChange, value == null ? void 0 : value.includeTime]);
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(ParsedDateTextInput, { "aria-label": t3("search.filter-date-aria-label"), fontSize: fullscreen ? 2 : 1, isDateTime, isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime), onChange: handleTextDateChange, radius: 2, value: value == null ? void 0 : value.date }), (0, import_jsx_runtime6.jsx)(DatePicker, { date: (value == null ? void 0 : value.date) ? new Date(value.date) : void 0, onChange: handleDatePickerChange, selectTime: isDateTime }), isDateTime && (0, import_jsx_runtime6.jsx)(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value == null ? void 0 : value.includeTime) })] });
}
function SearchFilterDateEqualInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateEqualInput, { ...props2, isDateTime: false });
}
function CommonDateDirectionInput(_ref392) {
  let { direction, isDateTime, onChange, value } = _ref392;
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const roundDay = (0, import_react51.useMemo)(() => {
    switch (direction) {
      case "after":
        return "end";
      case "before":
        return "start";
      default:
        return void 0;
    }
  }, [direction]);
  const handleDatePickerChange = (0, import_react51.useCallback)((_ref393) => {
    let { date } = _ref393;
    let dateISOString = null;
    if (date) {
      dateISOString = getDateISOString({ date, dateOnly: !isDateTime, roundDay: (value == null ? void 0 : value.includeTime) ? void 0 : roundDay });
    }
    onChange({ includeTime: value == null ? void 0 : value.includeTime, date: dateISOString });
  }, [isDateTime, onChange, roundDay, value == null ? void 0 : value.includeTime]);
  const handleIncludeTimeChange = (0, import_react51.useCallback)(() => {
    const includeTime = !(value == null ? void 0 : value.includeTime);
    const date = (value == null ? void 0 : value.date) ? new Date(value.date) : null;
    let dateISOString = null;
    if (date) {
      dateISOString = getDateISOString({ date, dateOnly: !isDateTime, roundDay: includeTime ? "start" : roundDay });
    }
    onChange({ includeTime, date: dateISOString });
  }, [isDateTime, onChange, roundDay, value]);
  const handleTextDateChange = (0, import_react51.useCallback)((date) => {
    onChange({ includeTime: value == null ? void 0 : value.includeTime, date: date || null });
  }, [onChange, value == null ? void 0 : value.includeTime]);
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(ParsedDateTextInput, { "aria-label": t3("search.filter-date-aria-label"), fontSize: fullscreen ? 2 : 1, isDateTime, isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime), onChange: handleTextDateChange, radius: 2, value: value == null ? void 0 : value.date }), (0, import_jsx_runtime6.jsx)(DatePicker, { date: (value == null ? void 0 : value.date) ? new Date(value.date) : void 0, onChange: handleDatePickerChange, selectTime: isDateTime }), isDateTime && (0, import_jsx_runtime6.jsx)(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value == null ? void 0 : value.includeTime) })] });
}
function SearchFilterDateAfterInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateDirectionInput, { ...props2, direction: "after", isDateTime: false });
}
function SearchFilterDateBeforeInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateDirectionInput, { ...props2, direction: "before", isDateTime: false });
}
var UNIT_CHOICES = [{ unit: "day", key: "search.filter-date-unit_days" }, { unit: "month", key: "search.filter-date-unit_months" }, { unit: "year", key: "search.filter-date-unit_years" }];
function SearchFilterDateLastInput(_ref394) {
  let { onChange, value } = _ref394;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react51.useState)((value == null ? void 0 : value.unitValue) || "");
  const dateUnit = (0, import_react51.useRef)("day");
  const dateValue = (0, import_react51.useRef)((value == null ? void 0 : value.unitValue) || null);
  const { t: t3 } = useTranslation2();
  const { state: { fullscreen } } = useSearchState();
  const handleChange = (0, import_react51.useCallback)(() => {
    onChange({ unit: dateUnit == null ? void 0 : dateUnit.current, unitValue: dateValue == null ? void 0 : dateValue.current });
  }, [onChange]);
  const handleUnitChange = (0, import_react51.useCallback)((event) => {
    dateUnit.current = event.currentTarget.value;
    handleChange();
  }, [handleChange]);
  const handleValueChange = (0, import_react51.useCallback)((event) => {
    setUncontrolledValue(event.currentTarget.value);
    const numValue = parseFloat(event.currentTarget.value);
    dateValue.current = Number.isFinite(numValue) ? numValue : null;
    handleChange();
  }, [handleChange]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { gap: 2, children: [(0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(TextInput, { "aria-label": t3("search.filter-date-value-aria-label"), fontSize: fullscreen ? 2 : 1, onChange: handleValueChange, pattern: "\\d*", radius: 2, step: "1", type: "number", value: uncontrolledValue }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Select, { "aria-label": t3("search.filter-date-unit-aria-label"), fontSize: fullscreen ? 2 : 1, onChange: handleUnitChange, radius: 2, value: value == null ? void 0 : value.unit, children: UNIT_CHOICES.map((choice) => (0, import_jsx_runtime6.jsx)("option", { value: choice.unit, children: t3(choice.key) }, choice.key)) }) })] });
}
var PLACEHOLDER_START_DATE_OFFSET = -7;
function CommonDateRangeInput(_ref395) {
  let { isDateTime, onChange, value } = _ref395;
  const { t: t3 } = useTranslation2();
  const { state: { fullscreen } } = useSearchState();
  const placeholderStartDate = (0, import_react51.useMemo)(() => addDays(/* @__PURE__ */ new Date(), PLACEHOLDER_START_DATE_OFFSET), []);
  const placeholderEndDate = (0, import_react51.useMemo)(() => /* @__PURE__ */ new Date(), []);
  const handleDatePickerChange = (0, import_react51.useCallback)((_ref396) => {
    let { date, endDate } = _ref396;
    onChange(getStartAndEndDate({ date, endDate, includeTime: value == null ? void 0 : value.includeTime, isDateTime }));
  }, [isDateTime, onChange, value == null ? void 0 : value.includeTime]);
  const handleIncludeTimeChange = (0, import_react51.useCallback)(() => {
    const includeTime = !(value == null ? void 0 : value.includeTime);
    onChange(getStartAndEndDate({ date: (value == null ? void 0 : value.from) ? new Date(value.from) : null, endDate: (value == null ? void 0 : value.to) ? new Date(value.to) : null, includeTime, isDateTime }));
  }, [isDateTime, onChange, value]);
  const handleTextEndDateChange = (0, import_react51.useCallback)((date) => {
    onChange({ includeTime: value == null ? void 0 : value.includeTime, to: date || null, from: (value == null ? void 0 : value.from) || null });
  }, [onChange, value]);
  const handleTextStartDateChange = (0, import_react51.useCallback)((date) => {
    onChange({ includeTime: value == null ? void 0 : value.includeTime, to: (value == null ? void 0 : value.to) || null, from: date || null });
  }, [onChange, value]);
  return (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", gap: 3, children: [(0, import_jsx_runtime6.jsx)(ParsedDateTextInput, { "aria-label": t3("search.filter-date-range-start-date-aria-label"), fontSize: fullscreen ? 2 : 1, isDateTime, isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime), onChange: handleTextStartDateChange, placeholderDate: placeholderStartDate, radius: 2, value: value == null ? void 0 : value.from }), (0, import_jsx_runtime6.jsx)(ParsedDateTextInput, { "aria-label": t3("search.filter-date-range-end-date-aria-label"), fontSize: fullscreen ? 2 : 1, isDateTime, isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime), onChange: handleTextEndDateChange, placeholderDate: placeholderEndDate, radius: 2, value: value == null ? void 0 : value.to })] }), (0, import_jsx_runtime6.jsx)(DatePicker, { date: (value == null ? void 0 : value.from) ? new Date(value.from) : void 0, endDate: (value == null ? void 0 : value.to) ? new Date(value.to) : void 0, onChange: handleDatePickerChange, selectRange: true, selectTime: isDateTime }), isDateTime && (0, import_jsx_runtime6.jsx)(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value == null ? void 0 : value.includeTime) })] }) });
}
function getStartAndEndDate(_ref397) {
  let { date, endDate, includeTime, isDateTime } = _ref397;
  if (includeTime) {
    return { includeTime, to: endDate ? getDateISOString({ date: endDate, dateOnly: !isDateTime, roundDay: "start" }) : null, from: date ? getDateISOString({ date, dateOnly: !isDateTime, roundDay: "start" }) : null };
  }
  return { includeTime, to: endDate ? getDateISOString({ date: endDate, dateOnly: !isDateTime, roundDay: "end" }) : null, from: date ? getDateISOString({ date, dateOnly: !isDateTime, roundDay: "start" }) : null };
}
function SearchFilterDateRangeInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateRangeInput, { ...props2, isDateTime: false });
}
function SearchFilterDateTimeEqualInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateEqualInput, { ...props2, isDateTime: true });
}
function SearchFilterDateTimeAfterInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateDirectionInput, { ...props2, direction: "after", isDateTime: true });
}
function SearchFilterDateTimeBeforeInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateDirectionInput, { ...props2, direction: "before", isDateTime: true });
}
function SearchFilterDateTimeRangeInput(props2) {
  return (0, import_jsx_runtime6.jsx)(CommonDateRangeInput, { ...props2, isDateTime: true });
}
var COMMON = { dateAfter: { buttonValueComponent: SearchButtonValueDate, initialValue: null }, dateBefore: { buttonValueComponent: SearchButtonValueDate, initialValue: null }, dateEqual: { buttonValueComponent: SearchButtonValueDate, initialValue: { date: null, includeTime: false } }, dateLast: { buttonValueComponent: SearchButtonValueDateLast }, dateNotEqual: { buttonValueComponent: SearchButtonValueDate, initialValue: { date: null, includeTime: false } }, dateRange: { initialValue: null } };
var dateOperators = { dateAfter: defineSearchOperator({ ...COMMON.dateAfter, nameKey: "search.operator.date-after.name", descriptionKey: "search.operator.date-after.description", groqFilter: (_ref398) => {
  let { fieldPath, value } = _ref398;
  return (value == null ? void 0 : value.date) && fieldPath ? "".concat(fieldPath, " > ").concat(toJSON(value == null ? void 0 : value.date)) : null;
}, inputComponent: SearchFilterDateAfterInput, type: "dateAfter" }), dateBefore: defineSearchOperator({ ...COMMON.dateBefore, nameKey: "search.operator.date-before.name", descriptionKey: "search.operator.date-before.description", groqFilter: (_ref399) => {
  let { fieldPath, value } = _ref399;
  return (value == null ? void 0 : value.date) && fieldPath ? "".concat(fieldPath, " < ").concat(toJSON(value == null ? void 0 : value.date)) : null;
}, inputComponent: SearchFilterDateBeforeInput, type: "dateBefore" }), dateEqual: defineSearchOperator({ ...COMMON.dateEqual, nameKey: "search.operator.date-equal.name", descriptionKey: "search.operator.date-equal.description", groqFilter: (_ref400) => {
  let { fieldPath, value } = _ref400;
  return (value == null ? void 0 : value.date) && fieldPath ? "".concat(fieldPath, " == ").concat(toJSON(value.date)) : null;
}, inputComponent: SearchFilterDateEqualInput, type: "dateEqual" }), dateLast: defineSearchOperator({ ...COMMON.dateLast, nameKey: "search.operator.date-last.name", descriptionKey: "search.operator.date-last.description", groqFilter: (_ref401) => {
  let { fieldPath, value } = _ref401;
  const flooredValue = typeof (value == null ? void 0 : value.unitValue) === "number" ? Math.floor(value.unitValue) : void 0;
  const timestampAgo = Number.isFinite(flooredValue) ? sub(/* @__PURE__ */ new Date(), { days: (value == null ? void 0 : value.unit) === "day" ? flooredValue : 0, months: (value == null ? void 0 : value.unit) === "month" ? flooredValue : 0, years: (value == null ? void 0 : value.unit) === "year" ? flooredValue : 0 }).toISOString().split("T")[0] : null;
  return timestampAgo && fieldPath ? "".concat(fieldPath, " > ").concat(toJSON(timestampAgo)) : null;
}, inputComponent: SearchFilterDateLastInput, initialValue: { unit: "day", unitValue: 7 }, type: "dateLast" }), dateNotEqual: defineSearchOperator({ ...COMMON.dateNotEqual, nameKey: "search.operator.date-not-equal.name", descriptionKey: "search.operator.date-not-equal.description", groqFilter: (_ref402) => {
  let { fieldPath, value } = _ref402;
  return (value == null ? void 0 : value.date) && fieldPath ? "".concat(fieldPath, " != ").concat(toJSON(value.date)) : null;
}, inputComponent: SearchFilterDateEqualInput, type: "dateNotEqual" }), dateRange: defineSearchOperator({ ...COMMON.dateRange, nameKey: "search.operator.date-range.name", descriptionKey: "search.operator.date-range.description", buttonValueComponent: SearchButtonValueDateRange, groqFilter: (_ref403) => {
  let { fieldPath, value } = _ref403;
  return (value == null ? void 0 : value.to) && (value == null ? void 0 : value.from) && fieldPath ? "".concat(fieldPath, " >= ").concat(toJSON(value.from), " && ").concat(fieldPath, " <= ").concat(toJSON(value.to)) : null;
}, initialValue: { includeTime: false, to: startOfToday().toISOString(), from: null }, inputComponent: SearchFilterDateRangeInput, type: "dateRange" }), dateTimeAfter: defineSearchOperator({ ...COMMON.dateAfter, nameKey: "search.operator.date-time-after.name", descriptionKey: "search.operator.date-time-after.description", groqFilter: (_ref404) => {
  let { fieldPath, value } = _ref404;
  return (value == null ? void 0 : value.date) && fieldPath ? "dateTime(".concat(fieldPath, ") > dateTime(").concat(toJSON(value.date), ")") : null;
}, inputComponent: SearchFilterDateTimeAfterInput, type: "dateTimeAfter" }), dateTimeBefore: defineSearchOperator({ ...COMMON.dateBefore, nameKey: "search.operator.date-time-before.name", descriptionKey: "search.operator.date-time-before.description", groqFilter: (_ref405) => {
  let { fieldPath, value } = _ref405;
  return (value == null ? void 0 : value.date) && fieldPath ? "dateTime(".concat(fieldPath, ") < dateTime(").concat(toJSON(value.date), ")") : null;
}, inputComponent: SearchFilterDateTimeBeforeInput, type: "dateTimeBefore" }), dateTimeEqual: defineSearchOperator({ ...COMMON.dateEqual, nameKey: "search.operator.date-time-equal.name", descriptionKey: "search.operator.date-time-equal.description", groqFilter: (_ref406) => {
  let { fieldPath, value } = _ref406;
  const date = (value == null ? void 0 : value.date) && new Date(value.date);
  if (!date || !isValid(date) || !fieldPath) {
    return null;
  }
  const dateStart = ((value == null ? void 0 : value.includeTime) ? startOfMinute(date) : startOfDay(date)).toISOString();
  const dateEnd = ((value == null ? void 0 : value.includeTime) ? endOfMinute(date) : endOfDay(date)).toISOString();
  return "dateTime(".concat(fieldPath, ") > dateTime(").concat(toJSON(dateStart), ") && dateTime(").concat(fieldPath, ") < dateTime(").concat(toJSON(dateEnd), ")");
}, inputComponent: SearchFilterDateTimeEqualInput, type: "dateTimeEqual" }), dateTimeLast: defineSearchOperator({ ...COMMON.dateLast, nameKey: "search.operator.date-time-last.name", descriptionKey: "search.operator.date-time-last.description", groqFilter: (_ref407) => {
  let { fieldPath, value } = _ref407;
  const flooredValue = typeof (value == null ? void 0 : value.unitValue) === "number" ? Math.floor(value.unitValue) : void 0;
  const timestampAgo = Number.isFinite(flooredValue) ? sub(/* @__PURE__ */ new Date(), { days: (value == null ? void 0 : value.unit) === "day" ? flooredValue : 0, months: (value == null ? void 0 : value.unit) === "month" ? flooredValue : 0, years: (value == null ? void 0 : value.unit) === "year" ? flooredValue : 0 }).toISOString() : null;
  return timestampAgo && fieldPath ? "dateTime(".concat(fieldPath, ") > dateTime(").concat(toJSON(timestampAgo), ")") : null;
}, initialValue: { unit: "day", unitValue: 7 }, inputComponent: SearchFilterDateLastInput, type: "dateTimeLast" }), dateTimeNotEqual: defineSearchOperator({ ...COMMON.dateNotEqual, nameKey: "search.operator.date-time-not-equal.name", descriptionKey: "search.operator.date-time-not-equal.description", groqFilter: (_ref408) => {
  let { fieldPath, value } = _ref408;
  const date = (value == null ? void 0 : value.date) && new Date(value.date);
  if (!date || !isValid(date) || !fieldPath) {
    return null;
  }
  const dateStart = ((value == null ? void 0 : value.includeTime) ? startOfMinute(date) : startOfDay(date)).toISOString();
  const dateEnd = ((value == null ? void 0 : value.includeTime) ? endOfMinute(date) : endOfDay(date)).toISOString();
  return "dateTime(".concat(fieldPath, ") < dateTime(").concat(toJSON(dateStart), ") || dateTime(").concat(fieldPath, ") > dateTime(").concat(toJSON(dateEnd), ")");
}, inputComponent: SearchFilterDateTimeEqualInput, type: "dateTimeNotEqual" }), dateTimeRange: defineSearchOperator({ ...COMMON.dateRange, nameKey: "search.operator.date-time-range.name", descriptionKey: "search.operator.date-time-range.description", buttonValueComponent: SearchButtonValueDateRange, groqFilter: (_ref409) => {
  let { fieldPath, value } = _ref409;
  return (value == null ? void 0 : value.to) && (value == null ? void 0 : value.from) && fieldPath ? "dateTime(".concat(fieldPath, ") >= dateTime(").concat(toJSON(value.from), ") && dateTime(").concat(fieldPath, ") <= dateTime(").concat(toJSON(value.to), ")") : null;
}, initialValue: { includeTime: false, to: startOfToday().toISOString(), from: null }, inputComponent: SearchFilterDateTimeRangeInput, type: "dateTimeRange" }) };
var numberOperators = { numberEqual: defineSearchOperator({ nameKey: "search.operator.number-equal.name", descriptionKey: "search.operator.number-equal.description", groqFilter: (_ref410) => {
  let { fieldPath, value } = _ref410;
  return Number.isFinite(value) && fieldPath ? "".concat(fieldPath, " == ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterNumberInput, type: "numberEqual" }), numberGt: defineSearchOperator({ nameKey: "search.operator.number-gt.name", descriptionKey: "search.operator.number-gt.description", groqFilter: (_ref411) => {
  let { fieldPath, value } = _ref411;
  return Number.isFinite(value) && fieldPath ? "".concat(fieldPath, " > ").concat(toJSON(value)) : null;
}, icon: GtIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "numberGt" }), numberGte: defineSearchOperator({ nameKey: "search.operator.number-gte.name", descriptionKey: "search.operator.number-gte.description", groqFilter: (_ref412) => {
  let { fieldPath, value } = _ref412;
  return Number.isFinite(value) && fieldPath ? "".concat(fieldPath, " >= ").concat(toJSON(value)) : null;
}, icon: GteIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "numberGte" }), numberLt: defineSearchOperator({ nameKey: "search.operator.number-lt.name", descriptionKey: "search.operator.number-lt.description", groqFilter: (_ref413) => {
  let { fieldPath, value } = _ref413;
  return Number.isFinite(value) && fieldPath ? "".concat(fieldPath, " < ").concat(toJSON(value)) : null;
}, icon: LtIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "numberLt" }), numberLte: defineSearchOperator({ nameKey: "search.operator.number-lte.name", descriptionKey: "search.operator.number-lte.description", groqFilter: (_ref414) => {
  let { fieldPath, value } = _ref414;
  return Number.isFinite(value) && fieldPath ? "".concat(fieldPath, " <= ").concat(toJSON(value)) : null;
}, icon: LteIcon, initialValue: null, inputComponent: SearchFilterNumberInput, type: "numberLte" }), numberNotEqual: defineSearchOperator({ nameKey: "search.operator.number-not-equal.name", descriptionKey: "search.operator.number-not-equal.description", groqFilter: (_ref415) => {
  let { fieldPath, value } = _ref415;
  return Number.isFinite(value) && fieldPath ? "".concat(fieldPath, " != ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterNumberInput, type: "numberNotEqual" }), numberRange: defineSearchOperator({ nameKey: "search.operator.number-range.name", descriptionKey: "search.operator.number-range.description", groqFilter: (_ref416) => {
  let { fieldPath, value } = _ref416;
  return Number.isFinite(value == null ? void 0 : value.to) && Number.isFinite(value == null ? void 0 : value.from) && fieldPath ? "".concat(fieldPath, " > ").concat(toJSON(value == null ? void 0 : value.from), " && ").concat(fieldPath, " < ").concat(toJSON(value == null ? void 0 : value.to)) : "";
}, initialValue: null, inputComponent: SearchFilterNumberRangeInput, type: "numberRange" }) };
function SearchFilterStringInput(_ref417) {
  let { onChange, value } = _ref417;
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((event) => onChange(event.currentTarget.value || null), [onChange]);
  return (0, import_jsx_runtime6.jsx)(TextInput, { fontSize: fullscreen ? 2 : 1, onChange: handleChange, placeholder: t3("search.filter-string-value-placeholder"), radius: 2, value: value || "" });
}
var portableTextOperators = { portableTextEqual: defineSearchOperator({ nameKey: "search.operator.portable-text-equal.name", descriptionKey: "search.operator.portable-text-equal.description", groqFilter: (_ref418) => {
  let { fieldPath, value } = _ref418;
  return value && fieldPath ? "pt::text(".concat(fieldPath, ") == ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "portableTextEqual" }), portableTextMatches: defineSearchOperator({ nameKey: "search.operator.portable-text-contains.name", descriptionKey: "search.operator.portable-text-contains.description", groqFilter: (_ref419) => {
  let { fieldPath, value } = _ref419;
  return value && fieldPath ? "pt::text(".concat(fieldPath, ") match ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "portableTextMatches" }), portableTextNotEqual: defineSearchOperator({ nameKey: "search.operator.portable-text-not-equal.name", descriptionKey: "search.operator.portable-text-not-equal.description", groqFilter: (_ref420) => {
  let { fieldPath, value } = _ref420;
  return value && fieldPath ? "pt::text(".concat(fieldPath, ") != ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "portableTextNotEqual" }), portableTextNotMatches: defineSearchOperator({ nameKey: "search.operator.portable-text-not-contains.name", descriptionKey: "search.operator.portable-text-not-contains.description", groqFilter: (_ref421) => {
  let { fieldPath, value } = _ref421;
  return value && fieldPath ? "!(pt::text(".concat(fieldPath, ") match ").concat(toJSON(value), ")") : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "portableTextNotMatches" }) };
var referenceOperators = { referenceEqual: defineSearchOperator({ nameKey: "search.operator.reference-equal.name", descriptionKey: "search.operator.reference-equal.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref422) => {
  let { fieldPath, value } = _ref422;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(fieldPath, "._ref == ").concat(toJSON(value._ref)) : null;
}, initialValue: null, inputComponent: SearchFilterReferenceInput, type: "referenceEqual" }), referenceNotEqual: defineSearchOperator({ nameKey: "search.operator.reference-not-equal.name", descriptionKey: "search.operator.reference-not-equal.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref423) => {
  let { fieldPath, value } = _ref423;
  return (value == null ? void 0 : value._ref) && fieldPath ? "".concat(fieldPath, "._ref != ").concat(toJSON(value._ref)) : null;
}, initialValue: null, inputComponent: SearchFilterReferenceInput, type: "referenceNotEqual" }), referencesAssetFile: defineSearchOperator({ nameKey: "search.operator.reference-asset-file.name", descriptionKey: "search.operator.reference-asset-file.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref424) => {
  let { value } = _ref424;
  return (value == null ? void 0 : value._ref) ? "references(".concat(toJSON(value._ref), ")") : null;
}, initialValue: null, inputComponent: SearchFilterAssetInput("file"), type: "referencesAssetFile" }), referencesAssetImage: defineSearchOperator({ nameKey: "search.operator.reference-asset-image.name", descriptionKey: "search.operator.reference-asset-image.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref425) => {
  let { value } = _ref425;
  return (value == null ? void 0 : value._ref) ? "references(".concat(toJSON(value._ref), ")") : null;
}, initialValue: null, inputComponent: SearchFilterAssetInput("image"), type: "referencesAssetImage" }), referencesDocument: defineSearchOperator({ nameKey: "search.operator.reference-document.name", descriptionKey: "search.operator.reference-document.description", buttonValueComponent: SearchButtonValueReference, groqFilter: (_ref426) => {
  let { value } = _ref426;
  return (value == null ? void 0 : value._ref) ? "references(".concat(toJSON(value._ref), ")") : null;
}, initialValue: null, inputComponent: SearchFilterReferenceInput, type: "referencesDocument" }) };
var slugOperators = { slugEqual: defineSearchOperator({ nameKey: "search.operator.slug-equal.name", descriptionKey: "search.operator.slug-equal.description", groqFilter: (_ref427) => {
  let { fieldPath, value } = _ref427;
  return value && fieldPath ? "".concat(fieldPath, ".current == ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "slugEqual" }), slugMatches: defineSearchOperator({ nameKey: "search.operator.slug-contains.name", descriptionKey: "search.operator.slug-contains.description", groqFilter: (_ref428) => {
  let { fieldPath, value } = _ref428;
  return value && fieldPath ? "".concat(fieldPath, ".current match ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, label: "contains", type: "slugMatches" }), slugNotEqual: defineSearchOperator({ nameKey: "search.operator.slug-not-equal.name", descriptionKey: "search.operator.slug-not-equal.description", groqFilter: (_ref429) => {
  let { fieldPath, value } = _ref429;
  return value && fieldPath ? "".concat(fieldPath, ".current != ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "slugNotEqual" }), slugNotMatches: defineSearchOperator({ nameKey: "search.operator.slug-not-contains.name", descriptionKey: "search.operator.slug-not-contains.description", groqFilter: (_ref430) => {
  let { fieldPath, value } = _ref430;
  return value && fieldPath ? "!(".concat(fieldPath, ".current match ").concat(toJSON(value), ")") : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "slugNotMatches" }) };
var stringOperators = { stringEqual: defineSearchOperator({ nameKey: "search.operator.string-equal.name", descriptionKey: "search.operator.string-equal.description", groqFilter: (_ref431) => {
  let { fieldPath, value } = _ref431;
  return value && fieldPath ? "".concat(fieldPath, " == ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "stringEqual" }), stringListEqual: defineSearchOperator({ nameKey: "search.operator.string-list-equal.name", descriptionKey: "search.operator.string-list-equal.description", groqFilter: (_ref432) => {
  let { fieldPath, value } = _ref432;
  return value && fieldPath ? "".concat(fieldPath, " == ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringListInput, type: "stringListEqual" }), stringListNotEqual: defineSearchOperator({ nameKey: "search.operator.string-list-not-equal.name", descriptionKey: "search.operator.string-list-not-equal.description", groqFilter: (_ref433) => {
  let { fieldPath, value } = _ref433;
  return value && fieldPath ? "".concat(fieldPath, " != ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringListInput, type: "stringListNotEqual" }), stringMatches: defineSearchOperator({ nameKey: "search.operator.string-contains.name", descriptionKey: "search.operator.string-contains.description", groqFilter: (_ref434) => {
  let { fieldPath, value } = _ref434;
  return value && fieldPath ? "".concat(fieldPath, " match ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "stringMatches" }), stringNotEqual: defineSearchOperator({ nameKey: "search.operator.string-not-equal.name", descriptionKey: "search.operator.string-not-equal.description", groqFilter: (_ref435) => {
  let { fieldPath, value } = _ref435;
  return value && fieldPath ? "".concat(fieldPath, " != ").concat(toJSON(value)) : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "stringNotEqual" }), stringNotMatches: defineSearchOperator({ nameKey: "search.operator.string-not-contains.name", descriptionKey: "search.operator.string-not-contains.description", groqFilter: (_ref436) => {
  let { fieldPath, value } = _ref436;
  return value && fieldPath ? "!(".concat(fieldPath, " match ").concat(toJSON(value), ")") : null;
}, initialValue: null, inputComponent: SearchFilterStringInput, type: "stringNotMatches" }) };
var searchOperators = { ...arrayOperators, ...assetOperators, ...booleanOperators, ...dateOperators, ...definedOperators, ...numberOperators, ...portableTextOperators, ...referenceOperators, ...slugOperators, ...stringOperators };
var operatorDefinitions = Object.values(searchOperators);
var ConfigPropertyError = class extends Error {
  constructor(_ref437) {
    let { propertyName, path: path2, cause } = _ref437;
    const message = isRecord$4(cause) && typeof (cause == null ? void 0 : cause.message) === "string" ? ": ".concat(cause.message) : "";
    super("An error occurred while resolving `".concat(propertyName, "` from ").concat(path2.join(" > ")).concat(message));
    this.propertyName = propertyName;
    this.cause = cause;
    this.path = path2;
  }
};
var flattenConfig = (_ref438, path2) => {
  let { plugins = [], ...currentConfig } = _ref438;
  const rootConfig = { config: currentConfig, path: [...path2, currentConfig.name] };
  const allPlugins = plugins.flatMap((plugin) => flattenConfig(plugin, [...path2, currentConfig.name]));
  const resolved = [...allPlugins, rootConfig];
  return resolved;
};
function resolveConfigProperty(_ref439) {
  let { config: inputConfig, context, initialValue, propertyName, ...reducers } = _ref439;
  const configs = flattenConfig(inputConfig, []);
  if ("reducer" in reducers) {
    return configs.reduce((acc, _ref440) => {
      let { config, path: path2 } = _ref440;
      try {
        return reducers.reducer(acc, config, context);
      } catch (e2) {
        throw new ConfigPropertyError({ propertyName, path: path2, cause: e2 });
      }
    }, initialValue);
  }
  const reducer = reducers.asyncReducer;
  return (async () => {
    let current = initialValue;
    for (const { config, path: path2 } of configs) {
      try {
        current = await reducer(current, config, context);
      } catch (e2) {
        throw new ConfigPropertyError({ propertyName, path: path2, cause: e2 });
      }
    }
    return current;
  })();
}
var initialDocumentBadges = [];
var initialDocumentActions = [];
var initialLanguageFilter = [];
var schemaTypesReducer = (prev, _ref441, context) => {
  let { schema } = _ref441;
  const schemaTypes = schema == null ? void 0 : schema.types;
  if (!schemaTypes)
    return prev;
  if (typeof schemaTypes === "function")
    return schemaTypes(prev, context);
  if (Array.isArray(schemaTypes))
    return [...prev, ...schemaTypes];
  throw new Error("Expected `schema.types` to be an array or a function, but received ".concat(getPrintableType(schemaTypes)));
};
var resolveProductionUrlReducer = async (prev, _ref442, context) => {
  let { document: document2 } = _ref442;
  const resolveProductionUrl = document2 == null ? void 0 : document2.productionUrl;
  if (resolveProductionUrl)
    return await resolveProductionUrl(prev, context);
  return prev;
};
var toolsReducer = (prev, _ref443, context) => {
  let { tools } = _ref443;
  if (!tools)
    return prev;
  if (typeof tools === "function")
    return tools(prev, context);
  if (Array.isArray(tools))
    return [...prev, ...tools];
  throw new Error("Expected `tools` to be an array or a function, but received ".concat(getPrintableType(tools)));
};
var schemaTemplatesReducer = (prev, _ref444, context) => {
  let { schema } = _ref444;
  const schemaTemplates = schema == null ? void 0 : schema.templates;
  if (!schemaTemplates)
    return prev;
  if (typeof schemaTemplates === "function")
    return schemaTemplates(prev, context);
  if (Array.isArray(schemaTemplates))
    return [...prev, ...schemaTemplates];
  throw new Error("Expected `schema.templates` to be an array or a function, but received ".concat(getPrintableType(schemaTemplates)));
};
var localeDefReducer = (prev, _ref445, context) => {
  let { i18n } = _ref445;
  const locales = i18n == null ? void 0 : i18n.locales;
  if (!locales)
    return prev;
  if (typeof locales === "function")
    return locales(prev, context);
  if (Array.isArray(locales))
    return [...prev, ...locales];
  throw new Error("Expected `i18n.locales` to be an array or a function, but received ".concat(getPrintableType(locales)));
};
var localeBundlesReducer = (prev, _ref446, context) => {
  let { i18n } = _ref446;
  const bundles = i18n == null ? void 0 : i18n.bundles;
  if (!bundles)
    return prev;
  if (Array.isArray(bundles))
    return [...prev, ...bundles];
  if (typeof bundles === "function")
    return bundles(prev, context);
  throw new Error("Expected `i18n.bundles` to be an array or a function, but received ".concat(typeof bundles));
};
var documentBadgesReducer = (prev, _ref447, context) => {
  let { document: document2 } = _ref447;
  const documentBadges = document2 == null ? void 0 : document2.badges;
  if (!documentBadges)
    return prev;
  if (typeof documentBadges === "function")
    return documentBadges(prev, context);
  if (Array.isArray(documentBadges))
    return [...prev, ...documentBadges];
  throw new Error("Expected `document.badges` to be an array or a function, but received ".concat(getPrintableType(documentBadges)));
};
var documentActionsReducer = (prev, _ref448, context) => {
  let { document: document2 } = _ref448;
  const documentActions = document2 == null ? void 0 : document2.actions;
  if (!documentActions)
    return prev;
  if (typeof documentActions === "function")
    return documentActions(prev, context);
  if (Array.isArray(documentActions))
    return [...prev, ...documentActions];
  throw new Error("Expected `document.actions` to be an array or a function, but received ".concat(getPrintableType(documentActions)));
};
var newDocumentOptionsResolver = (prev, _ref449, context) => {
  let { document: document2 } = _ref449;
  const resolveNewDocumentOptions = document2 == null ? void 0 : document2.newDocumentOptions;
  if (!resolveNewDocumentOptions)
    return prev;
  if (typeof resolveNewDocumentOptions !== "function") {
    throw new Error("Expected `document.resolveNewDocumentOptions` to be a function, but received ".concat(getPrintableType(resolveNewDocumentOptions)));
  }
  return resolveNewDocumentOptions(prev, context);
};
var fileAssetSourceResolver = (prev, _ref450, context) => {
  let { form } = _ref450;
  var _a4;
  const assetSources = (_a4 = form == null ? void 0 : form.file) == null ? void 0 : _a4.assetSources;
  if (!assetSources)
    return prev;
  if (typeof assetSources === "function")
    return assetSources(prev, context);
  if (Array.isArray(assetSources))
    return [...prev, ...assetSources];
  throw new Error("Expected `form.file.assetSources` to be an array or a function, but received ".concat(getPrintableType(assetSources)));
};
var imageAssetSourceResolver = (prev, _ref451, context) => {
  let { form } = _ref451;
  var _a4;
  const assetSources = (_a4 = form == null ? void 0 : form.image) == null ? void 0 : _a4.assetSources;
  if (!assetSources)
    return prev;
  if (typeof assetSources === "function")
    return assetSources(prev, context);
  if (Array.isArray(assetSources))
    return [...prev, ...assetSources];
  throw new Error("Expected `form.image.assetSources` to be an array or a function, but received ".concat(getPrintableType(assetSources)));
};
var documentLanguageFilterReducer = (prev, _ref452, context) => {
  let { document: document2 } = _ref452;
  const resolveDocumentLanguageFilter = document2 == null ? void 0 : document2.unstable_languageFilter;
  if (!resolveDocumentLanguageFilter)
    return prev;
  if (typeof resolveDocumentLanguageFilter === "function")
    return resolveDocumentLanguageFilter(prev, context);
  if (Array.isArray(resolveDocumentLanguageFilter))
    return [...prev, ...resolveDocumentLanguageFilter];
  throw new Error("Expected `document.unstable_languageFilter` to be an array or a function, but received ".concat(getPrintableType(resolveDocumentLanguageFilter)));
};
var documentInspectorsReducer = (prev, _ref453, context) => {
  let { document: document2 } = _ref453;
  const resolveInspectorsFilter = document2 == null ? void 0 : document2.inspectors;
  if (!resolveInspectorsFilter)
    return prev;
  if (typeof resolveInspectorsFilter === "function")
    return resolveInspectorsFilter(prev, context);
  if (Array.isArray(resolveInspectorsFilter))
    return [...prev, ...resolveInspectorsFilter];
  throw new Error("Expected `document.inspectors` to be an array or a function, but received ".concat(getPrintableType(resolveInspectorsFilter)));
};
var documentCommentsEnabledReducer = (opts) => {
  const { config, context, initialValue } = opts;
  const flattenedConfig = flattenConfig(config, []);
  const result = flattenedConfig.reduce((acc, _ref454) => {
    let { config: innerConfig } = _ref454;
    var _a4, _b4;
    const resolver = (_b4 = (_a4 = innerConfig.document) == null ? void 0 : _a4.unstable_comments) == null ? void 0 : _b4.enabled;
    if (!resolver && typeof resolver !== "boolean")
      return acc;
    if (typeof resolver === "function")
      return resolver(context);
    if (typeof resolver === "boolean")
      return resolver;
    throw new Error("Expected `document.unstable_comments.enabled` to be a boolean or a function, but received ".concat(getPrintableType(resolver)));
  }, initialValue);
  return result;
};
function createSanityI18nBackend(options) {
  const { bundles } = options;
  function init2() {
  }
  function read2(locale, namespace, callback) {
    const loadable = bundles.filter((bundle) => bundle.locale === locale && bundle.namespace === namespace);
    if (loadable.length === 0) {
      callback(
        'No translations found for namespace "'.concat(namespace, '", language "').concat(locale, '"'),
        void 0
        // Returning undefined here will i18next _not_ retry
      );
      return;
    }
    loadBundles(loadable).then((resources) => callback(null, resources)).catch((err) => callback(err, true));
  }
  return { type: "backend", init: init2, read: read2 };
}
async function loadBundles(bundles) {
  var _a4, _b4;
  const resolved = await Promise.all(bundles.map(async (bundle) => ({ ...bundle, resources: await loadBundleResources(bundle) })));
  const base = {};
  for (const item of resolved) {
    const deep = (_a4 = item.deep) != null ? _a4 : true;
    const overwrite = (_b4 = item.overwrite) != null ? _b4 : true;
    if (deep) {
      deepExtend2(base, item.resources, overwrite);
    } else if (overwrite) {
      Object.assign(base, item.resources);
    } else {
      Object.assign({}, item.resources, base);
    }
  }
  return base;
}
async function loadBundleResources(bundle) {
  if (typeof bundle.resources !== "function") {
    return bundle.resources;
  }
  const resources = await bundle.resources();
  return maybeUnwrapModule(resources);
}
function deepExtend2(target, source) {
  let overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  for (const prop in source) {
    if (prop === "__proto__" || prop === "constructor") {
      continue;
    }
    if (!(prop in target)) {
      target[prop] = source[prop];
      continue;
    }
    const targetLeaf = target[prop];
    const sourceLeaf = source[prop];
    const targetIsString = isStringLeaf(targetLeaf);
    const sourceIsString = isStringLeaf(sourceLeaf);
    if ((targetIsString || sourceIsString) && overwrite) {
      target[prop] = source[prop];
      continue;
    }
    if (targetIsString || sourceIsString) {
      continue;
    }
    const sourceIsArray = Array.isArray(sourceLeaf);
    const targetIsArray = Array.isArray(targetLeaf);
    if (sourceIsArray || targetIsArray) {
      if (overwrite) {
        target[prop] = sourceLeaf;
      }
      continue;
    }
    deepExtend2(targetLeaf, sourceLeaf, overwrite);
  }
  return target;
}
function isStringLeaf(target) {
  return typeof target === "string" || target instanceof String;
}
function maybeUnwrapModule(maybeModule) {
  return isWrappedModule(maybeModule) ? maybeModule.default : maybeModule;
}
function isWrappedModule(mod) {
  return "default" in mod && typeof mod.default === "object" && (0, import_isPlainObject5.default)(mod.default);
}
var LOCAL_STORAGE_PREFIX = "sanity-locale";
function getPreferredLocale(projectId2, sourceId) {
  if (!supportsLocalStorage) {
    return void 0;
  }
  const locale = localStorage.getItem(getItemKey(projectId2, sourceId));
  return locale != null ? locale : void 0;
}
function storePreferredLocale(projectId2, sourceId, locale) {
  if (!supportsLocalStorage) {
    return;
  }
  localStorage.setItem(getItemKey(projectId2, sourceId), locale);
}
function getItemKey(projectId2, sourceId) {
  return [LOCAL_STORAGE_PREFIX, projectId2, sourceId].join(":");
}
function prepareI18n(source) {
  const { projectId: projectId2, dataset: dataset2, name: sourceName } = source;
  const context = { projectId: projectId2, dataset: dataset2 };
  const locales = resolveConfigProperty({ config: source, context, propertyName: "i18n.locales", reducer: localeDefReducer, initialValue: [defaultLocale] });
  const bundles = resolveConfigProperty({ config: source, context, propertyName: "i18n.bundles", reducer: localeBundlesReducer, initialValue: normalizeResourceBundles(locales) });
  return createI18nApi({ locales, bundles, projectId: projectId2, sourceName });
}
function createI18nApi(_ref455) {
  let { locales, bundles, projectId: projectId2, sourceName } = _ref455;
  const options = getI18NextOptions(projectId2, sourceName, locales);
  const i18nInstance = createInstance().use(createSanityI18nBackend({ bundles })).use(initReactI18next);
  i18nInstance.init(options).catch((err) => {
    console.error("Failed to initialize i18n backend: %s", err);
  });
  const reducedLocales = locales.map((_ref456) => {
    let { id: id4, title } = _ref456;
    return { id: id4, title };
  });
  return {
    /** @public */
    source: { get currentLocale() {
      return i18nInstance.language;
    }, loadNamespaces(namespaces2) {
      const missing = namespaces2.filter((ns) => !i18nInstance.hasLoadedNamespace(ns));
      return missing.length === 0 ? Promise.resolve() : i18nInstance.loadNamespaces(namespaces2);
    }, locales: reducedLocales, t: maybeWrapT(i18nInstance.t) },
    /** @internal */
    i18next: i18nInstance
  };
}
function normalizeResourceBundles(locales) {
  const normalized = [];
  for (const lang of locales) {
    if (lang.bundles && !Array.isArray(lang.bundles)) {
      throw new Error("Resource bundle for locale ".concat(lang.id, " is not an array"));
    }
    if (!lang.bundles) {
      continue;
    }
    for (const bundle of lang.bundles) {
      if ("locale" in bundle && bundle.locale !== lang.id) {
        throw new Error("Resource bundle inside locale ".concat(lang.id, " has mismatching locale id"));
      }
      const ns = bundle.namespace;
      if (!ns) {
        throw new Error("Resource bundle for locale ".concat(lang.id, " is missing namespace"));
      }
      normalized.push("locale" in bundle ? bundle : { ...bundle, locale: lang.id });
    }
  }
  return normalized;
}
var defaultOptions4 = {
  /**
  * Even though we're only defining the studio namespace, i18next will still load requested
  * namespaces through the backend. The reason why we're defining the namespace at all is to
  * prevent i18next from (trying) to load the i18next default `translation` namespace.
  */
  ns: [studioLocaleNamespace],
  defaultNS: studioLocaleNamespace,
  partialBundledLanguages: true,
  // Fall back to English (US) locale
  fallbackLng: defaultLocale.id,
  // This will be overriden with the users detected/preferred locale before initing,
  // but to satisfy the init options and prevent mistakes, we include a defualt here.
  lng: defaultLocale.id,
  // In rare cases we'll want to be able to debug i18next - there is a `debug` option
  // in the studio i18n configuration for that, which will override this value.
  debug: DEBUG_I18N,
  // When specifying language 'en-US', do not load 'en-US', 'en', 'dev' - only `en-US`.
  load: "currentOnly",
  // We always use our "backend" for loading translations, allowing us to handle i18n resources
  // in a single place with a single approach. This means we shouldn't need to wait for the init,
  // as any missing translations will be loaded async (through react suspense).
  initImmediate: true,
  // Because we use i18next-react, we do not need to escale values
  interpolation: { escapeValue: false },
  // Theoretically, if the framework somehow gets new translations added, re-render.
  // Note that this shouldn't actually happen, as we only use the Sanity backend
  react: { bindI18nStore: "added" }
};
function getI18NextOptions(projectId2, sourceName, locales) {
  var _a4, _b4, _c4;
  const preferredLocaleId = getPreferredLocale(projectId2, sourceName);
  const preferredLocale = locales.find((l) => l.id === preferredLocaleId);
  const locale = (_c4 = (_b4 = preferredLocale == null ? void 0 : preferredLocale.id) != null ? _b4 : (_a4 = locales[0]) == null ? void 0 : _a4.id) != null ? _c4 : defaultOptions4.lng;
  return { ...defaultOptions4, lng: locale, supportedLngs: locales.map((def) => def.id) };
}
var ConfigResolutionError = class extends Error {
  constructor(_ref457) {
    let { causes, name, type } = _ref457;
    const messages = causes.filter(Boolean).map((cause) => isRecord$4(cause) && typeof (cause == null ? void 0 : cause.message) === "string" ? cause.message : String(cause));
    super("Could not resolve ".concat(type).concat(name ? " `".concat(name, "`") : "", ":\n").concat(messages.map((message) => "	- ".concat(message)).join("\n"), "\n\n"));
    this.name = name;
    this.causes = causes;
    this.type = type;
  }
};
var SchemaError = class extends Error {
  constructor(schema) {
    super("SchemaError");
    this.schema = schema;
  }
};
var __freeze$K = Object.freeze;
var __defProp$K = Object.defineProperty;
var __template$K = (cooked, raw) => __freeze$K(__defProp$K(cooked, "raw", { value: __freeze$K(raw || cooked.slice()) }));
var _a$K;
function pseudoRandomNumber(seed) {
  const hashCode = seed.split("").reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0) | 0, 0);
  return Math.abs(hashCode * 16807 % 2147483647) / 2147483647;
}
var SvgText = st.text(_a$K || (_a$K = __template$K(["\n  font-family: ", ";\n  font-weight: ", ";\n  font-size: 16px;\n  transform: translateY(1px);\n"])), (_ref458) => {
  let { theme } = _ref458;
  return theme.sanity.fonts.heading.family;
}, (_ref459) => {
  let { theme } = _ref459;
  return theme.sanity.fonts.heading.weights.bold;
});
function createDefaultIcon(title, subtitle) {
  const rng1 = pseudoRandomNumber("".concat(title, " ").concat(subtitle));
  const huesWithoutGray = COLOR_HUES.filter((hue) => hue !== "gray");
  const colorHue = huesWithoutGray[Math.floor(rng1 * huesWithoutGray.length)];
  const possibleTints = ["300", "400", "500", "600", "700"];
  const rng2 = pseudoRandomNumber(rng1.toString());
  const tint = possibleTints[Math.floor(rng2 * possibleTints.length)];
  const color3 = hues[colorHue][tint].hex;
  const letters = title.split(/\s/g).map((word) => word.replace(/\\W/g, "")).filter(Boolean).slice(0, 2).map((i) => i.charAt(0).toUpperCase());
  const darkened = darken(color3, 0.4);
  const lightened = lighten(color3, 0.4);
  const textColor = !hasBadContrast(color3, "readable", darkened) ? darkened : !hasBadContrast(color3, "readable", lightened) ? lightened : readableColor(color3);
  return (0, import_jsx_runtime6.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: [(0, import_jsx_runtime6.jsx)("rect", { width: 32, height: 32, rx: 2, fill: color3 }), (0, import_jsx_runtime6.jsx)(SvgText, { x: "50%", y: "50%", textAnchor: "middle", alignmentBaseline: "middle", dominantBaseline: "middle", fill: textColor, children: letters })] });
}
var isError = (p) => p.severity === "error";
function normalizeIcon(icon, title) {
  let subtitle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if ((0, import_react_is2.isValidElementType)(icon))
    return (0, import_react51.createElement)(icon);
  if ((0, import_react51.isValidElement)(icon))
    return icon;
  return createDefaultIcon(title, subtitle);
}
var preparedWorkspaces = /* @__PURE__ */ new WeakMap();
function prepareConfig(config, options) {
  if (!Array.isArray(config) && "missingConfigFile" in config) {
    throw new ConfigResolutionError({ name: "", type: "configuration file", causes: ["No `sanity.config.ts` file found", "No `sanity.config.js` file found"] });
  }
  const rootPath = getRootPath(options == null ? void 0 : options.basePath);
  const workspaceOptions = Array.isArray(config) ? config : [config];
  try {
    validateWorkspaces({ workspaces: workspaceOptions });
  } catch (e2) {
    throw new ConfigResolutionError({ name: "", type: "workspace", causes: [e2.message] });
  }
  const workspaces = workspaceOptions.map((rawWorkspace) => {
    if (preparedWorkspaces.has(rawWorkspace)) {
      return preparedWorkspaces.get(rawWorkspace);
    }
    const { unstable_sources: nestedSources = [], ...rootSource } = rawWorkspace;
    const sources = [rootSource, ...nestedSources];
    const resolvedSources = sources.map((source) => {
      const { projectId: projectId2, dataset: dataset2 } = source;
      let schemaTypes;
      try {
        schemaTypes = resolveConfigProperty({ propertyName: "schema.types", config: source, context: { projectId: projectId2, dataset: dataset2 }, initialValue: [], reducer: schemaTypesReducer });
      } catch (e2) {
        throw new ConfigResolutionError({ name: source.name, type: "source", causes: [e2] });
      }
      const schema = createSchema({ name: source.name, types: schemaTypes });
      const schemaValidationProblemGroups = schema._validation;
      const schemaErrors = schemaValidationProblemGroups == null ? void 0 : schemaValidationProblemGroups.filter((msg2) => msg2.problems.some(isError));
      if (schemaValidationProblemGroups && (schemaErrors == null ? void 0 : schemaErrors.length)) {
        throw new SchemaError(schema);
      }
      const auth = getAuthStore(source);
      const i18n = prepareI18n(source);
      const source$ = auth.state.pipe(map((_ref460) => {
        let { client, authenticated, currentUser } = _ref460;
        return resolveSource({ config: source, client, currentUser, schema, authenticated, auth, i18n });
      }), shareReplay(1));
      return { name: source.name, projectId: source.projectId, dataset: source.dataset, title: source.title || (0, import_startCase2.default)(source.name), auth, schema, i18n: i18n.source, source: source$ };
    });
    const title = rootSource.title || (0, import_startCase2.default)(rootSource.name);
    const workspaceSummary = { type: "workspace-summary", auth: resolvedSources[0].auth, basePath: joinBasePath(rootPath, rootSource.basePath), dataset: rootSource.dataset, schema: resolvedSources[0].schema, i18n: resolvedSources[0].i18n, icon: normalizeIcon(rootSource.icon, title, "".concat(rootSource.projectId, " ").concat(rootSource.dataset)), name: rootSource.name || "default", projectId: rootSource.projectId, theme: rootSource.theme || studioTheme, title, subtitle: rootSource.subtitle, __internal: { sources: resolvedSources } };
    preparedWorkspaces.set(rawWorkspace, workspaceSummary);
    return workspaceSummary;
  });
  return { type: "prepared-config", workspaces };
}
function getAuthStore(source) {
  if (isAuthStore(source.auth)) {
    return source.auth;
  }
  const clientFactory = source.unstable_clientFactory || createClient;
  const { projectId: projectId2, dataset: dataset2, apiHost } = source;
  return createAuthStore({ apiHost, ...source.auth, clientFactory, dataset: dataset2, projectId: projectId2 });
}
function getBifurClient(client, auth) {
  const bifurVersionedClient = client.withConfig({ apiVersion: "2022-06-30" });
  const { dataset: dataset2, url: baseUrl, requestTagPrefix = "sanity.studio" } = bifurVersionedClient.config();
  const url = "".concat(baseUrl.replace(/\/+$/, ""), "/socket/").concat(dataset2).replace(/^http/, "ws");
  const urlWithTag = "".concat(url, "?tag=").concat(requestTagPrefix);
  const options = auth.token ? { token$: auth.token } : {};
  return fromUrl(urlWithTag, options);
}
function resolveSource(_ref461) {
  let { config, client, currentUser, schema, authenticated, auth, i18n } = _ref461;
  var _a4, _b4, _c4, _d4;
  const { dataset: dataset2, projectId: projectId2 } = config;
  const bifur = getBifurClient(client, auth);
  const errors = [];
  const clients = {};
  const getClient = (options) => {
    if (!options || !options.apiVersion) {
      throw new Error("Missing required `apiVersion` option");
    }
    if (!clients[options.apiVersion]) {
      clients[options.apiVersion] = client.withConfig(options);
    }
    return clients[options.apiVersion];
  };
  const context = { client, getClient, currentUser, dataset: dataset2, projectId: projectId2, schema, i18n: i18n.source };
  const wrappedClient = client;
  context.client = [...Object.keys(client), ...Object.keys(wrappedClient.__proto__)].reduce((acc, key2) => {
    const original = Object.hasOwnProperty.call(client, key2) ? wrappedClient[key2] : wrappedClient.__proto__[key2];
    return Object.defineProperty(acc, key2, { get() {
      console.warn('`configContext.client` is deprecated and will be removed in the next release! Use `context.getClient({apiVersion: "2021-06-07"})` instead');
      return original;
    } });
  }, {});
  let templates;
  try {
    templates = resolveConfigProperty({ config, context, propertyName: "schema.templates", reducer: schemaTemplatesReducer, initialValue: schema.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema.get(typeName)).filter(isNonNullable$3).filter((schemaType) => {
      var _a22;
      return ((_a22 = schemaType.type) == null ? void 0 : _a22.name) === "document";
    }).map((schemaType) => {
      const template = { id: schemaType.name, schemaType: schemaType.name, title: schemaType.title || schemaType.name, icon: schemaType.icon, value: schemaType.initialValue || { _type: schemaType.name } };
      return template;
    }) });
  } catch (e2) {
    throw new ConfigResolutionError({ name: config.name, type: "source", causes: [e2] });
  }
  let tools;
  try {
    tools = resolveConfigProperty({ config, context, initialValue: [], propertyName: "tools", reducer: toolsReducer });
  } catch (e2) {
    throw new ConfigResolutionError({ name: config.name, type: "source", causes: [e2] });
  }
  if (tools.some((_ref462) => {
    let { name } = _ref462;
    return name === "tool";
  })) {
    throw new Error('A tool cannot have the name "tool". Please enter a different name.');
  }
  const initialTemplatesResponses = templates.filter((template) => {
    var _a22;
    return !((_a22 = template.parameters) == null ? void 0 : _a22.length);
  }).map((template) => ({ templateId: template.id, description: template.description, icon: template.icon, title: template.title }));
  const templateMap = templates.reduce((acc, template) => {
    acc.set(template.id, template);
    return acc;
  }, /* @__PURE__ */ new Map());
  const resolveNewDocumentOptions = (creationContext) => {
    const { schemaType: schemaTypeName } = creationContext;
    const templateResponses = resolveConfigProperty({ config, context: { ...context, creationContext }, initialValue: initialTemplatesResponses, propertyName: "document.resolveNewDocumentOptions", reducer: newDocumentOptionsResolver });
    const templateErrors = [];
    if (templateErrors.length) {
      throw new ConfigResolutionError({ name: config.name, type: "source", causes: templateErrors });
    }
    return templateResponses.map((response, index) => {
      const template = templateMap.get(response.templateId);
      if (!template) {
        throw new Error("Could not find template with ID `".concat(response.templateId, "`"));
      }
      const schemaType = schema.get(template.schemaType);
      if (!schemaType) {
        throw new Error("Could not find matching schema type `".concat(template.schemaType, "` for template `").concat(template.id, "`"));
      }
      const title = response.title || template.title;
      const defaultSubtitle = (schemaType == null ? void 0 : schemaType.title) === title ? void 0 : schemaType == null ? void 0 : schemaType.title;
      return { id: "".concat(response.templateId, "-").concat(index), templateId: response.templateId, type: "initialValueTemplateItem", title, subtitle: response.subtitle || defaultSubtitle, description: response.description || template.description, icon: response.icon || template.icon || (schemaType == null ? void 0 : schemaType.icon), initialDocumentId: response.initialDocumentId, parameters: response.parameters, schemaType: template.schemaType };
    }).filter((item) => {
      var _a22;
      if (!schemaTypeName)
        return true;
      if (creationContext.type === "document")
        return true;
      return schemaTypeName === ((_a22 = templateMap.get(item.templateId)) == null ? void 0 : _a22.schemaType);
    });
  };
  let staticInitialValueTemplateItems;
  try {
    staticInitialValueTemplateItems = resolveNewDocumentOptions({ type: "global" });
  } catch (e2) {
    errors.push(e2);
  }
  if (errors.length) {
    throw new ConfigResolutionError({ name: config.name, type: "source", causes: errors });
  }
  const source = { type: "source", name: config.name, title: config.title || (0, import_startCase2.default)(config.name), schema, getClient, dataset: dataset2, projectId: projectId2, tools, currentUser, authenticated, templates, auth, i18n: i18n.source, document: { actions: (partialContext) => resolveConfigProperty({ config, context: { ...context, ...partialContext }, initialValue: initialDocumentActions, propertyName: "document.actions", reducer: documentActionsReducer }), badges: (partialContext) => resolveConfigProperty({ config, context: { ...context, ...partialContext }, initialValue: initialDocumentBadges, propertyName: "document.badges", reducer: documentBadgesReducer }), unstable_fieldActions: (partialContext) => resolveConfigProperty({ config, context: { ...context, ...partialContext }, initialValue: initialDocumentFieldActions, propertyName: "document.unstable_fieldActions", reducer: documentFieldActionsReducer }), inspectors: (partialContext) => resolveConfigProperty({ config, context: { ...context, ...partialContext }, initialValue: EMPTY_ARRAY$b, propertyName: "document.inspectors", reducer: documentInspectorsReducer }), resolveProductionUrl: (partialContext) => resolveConfigProperty({ config, context: { ...context, ...partialContext }, initialValue: void 0, propertyName: "resolveProductionUrl", asyncReducer: resolveProductionUrlReducer }), resolveNewDocumentOptions, unstable_languageFilter: (partialContext) => resolveConfigProperty({ config, context: { ...context, ...partialContext }, initialValue: initialLanguageFilter, propertyName: "document.unstable_languageFilter", reducer: documentLanguageFilterReducer }), unstable_comments: { enabled: (partialContext) => {
    return documentCommentsEnabledReducer({ context: partialContext, config, initialValue: false });
  } } }, form: { file: { assetSources: resolveConfigProperty({ config, context, initialValue: [FileSource], propertyName: "formBuilder.file.assetSources", reducer: fileAssetSourceResolver }), directUploads: (
    // TODO: consider refactoring this to `noDirectUploads` or similar
    // default value for this is `true`
    ((_b4 = (_a4 = config.form) == null ? void 0 : _a4.file) == null ? void 0 : _b4.directUploads) === void 0 ? true : config.form.file.directUploads
  ) }, image: { assetSources: resolveConfigProperty({ config, context, initialValue: [ImageSource], propertyName: "formBuilder.image.assetSources", reducer: imageAssetSourceResolver }), directUploads: (
    // TODO: consider refactoring this to `noDirectUploads` or similar
    // default value for this is `true`
    ((_d4 = (_c4 = config.form) == null ? void 0 : _c4.image) == null ? void 0 : _d4.directUploads) === void 0 ? true : config.form.image.directUploads
  ) } }, search: {
    filters: filterDefinitions,
    operators: operatorDefinitions
    // we will use this when we add search config to PluginOptions
    /*filters: resolveConfigProperty({
            config,
            context: context,
            initialValue: filterDefinitions,
            propertyName: 'search.filters',
            reducer: searchFilterReducer,
          }),
          operators: resolveConfigProperty({
            config,
            context: context,
            initialValue: operatorDefinitions as SearchOperatorDefinition[],
            propertyName: 'search.operators',
            reducer: searchOperatorsReducer,
          }),*/
  }, __internal: { bifur, i18next: i18n.i18next, staticInitialValueTemplateItems, options: config } };
  return source;
}
function getRootPath(basePath) {
  const rootPath = basePath || "";
  if (typeof rootPath !== "string" || rootPath.length > 0 && !rootPath.startsWith("/")) {
    throw new ConfigResolutionError({ name: "", type: "options", causes: ["basePath must be a string, and must start with a slash"] });
  }
  return rootPath === "/" ? "" : rootPath;
}
function joinBasePath(rootPath, basePath) {
  const joined = [rootPath, basePath || ""].map((path2) => path2.replace(/^\/+/g, "").replace(/\/+$/g, "")).filter(Boolean).join("/");
  return "/".concat(joined);
}
function resolveConfig(config) {
  const { workspaces } = prepareConfig(config);
  return combineLatest(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workspaces.flatMap((workspaceSummary) => combineLatest(workspaceSummary.__internal.sources.map((_ref463) => {
      let { source } = _ref463;
      return source;
    })).pipe(map((sources) => ({ ...workspaceSummary, ...sources[0], unstable_sources: sources, type: "workspace" }))))
  );
}
async function createWorkspaceFromConfig(options) {
  const client = "getClient" in options ? options.getClient({ apiVersion: "2022-09-09" }) : void 0;
  const [workspace] = await firstValueFrom(resolveConfig({ ...options, ...client && "currentUser" in options && { auth: createMockAuthStore({ ...options, client }) } }));
  return workspace;
}
async function createSourceFromConfig(options) {
  const workspace = await createWorkspaceFromConfig(options);
  return workspace.unstable_sources[0];
}
function useConfigContextFromSource(source) {
  const { projectId: projectId2, dataset: dataset2, schema, currentUser, getClient, i18n } = source;
  return (0, import_react51.useMemo)(() => {
    return { projectId: projectId2, dataset: dataset2, schema, currentUser, getClient, i18n };
  }, [projectId2, dataset2, schema, currentUser, getClient, i18n]);
}
function getConfigContextFromSource(source) {
  const { projectId: projectId2, dataset: dataset2, schema, currentUser, getClient, i18n } = source;
  return { projectId: projectId2, dataset: dataset2, schema, currentUser, getClient, i18n };
}
var errorChannel = globalScope2.__sanityErrorChannel;
function ErrorLogger() {
  const { push: pushToast } = useToast();
  (0, import_react51.useEffect)(() => {
    if (!errorChannel)
      return void 0;
    return errorChannel.subscribe((msg2) => {
      if (!msg2.error) {
        return;
      }
      if (isKnownError(msg2.error)) {
        return;
      }
      console.error(msg2.error);
      pushToast({
        // Use the error message as the ID in order to prevent duplicates from showing
        // A bit of a hack, but serves
        id: msg2.error.message,
        closable: true,
        description: msg2.error.message,
        duration: 5e3,
        title: "Uncaught error",
        status: "error"
      });
    });
  }, [pushToast]);
  return null;
}
function isKnownError(err) {
  if (err instanceof SchemaError) {
    return true;
  }
  if (err instanceof CorsOriginError) {
    return true;
  }
  if (err instanceof ConfigResolutionError) {
    return true;
  }
  return false;
}
function LoadingScreen() {
  return (
    // TODO: improve the design of this
    // think about having it load in the `_document` too
    (0, import_jsx_runtime6.jsxs)(Flex, { as: Card, justify: "center", align: "center", height: "fill", direction: "column", gap: 4, children: [(0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: "Loading" }), (0, import_jsx_runtime6.jsx)(Spinner, { muted: true })] })
  );
}
var __freeze$J = Object.freeze;
var __defProp$J = Object.defineProperty;
var __template$J = (cooked, raw) => __freeze$J(__defProp$J(cooked, "raw", { value: __freeze$J(raw || cooked.slice()) }));
var _a$J;
var _b$m2;
var TONES = { error: "critical", warning: "caution" };
var SegmentSpan = st.code(_a$J || (_a$J = __template$J(["\n  && {\n    background: none;\n    color: inherit;\n  }\n"])));
var ErrorMessageText = st(Text3)(_b$m2 || (_b$m2 = __template$J(["\n  white-space: pre-line;\n"])));
function SchemaProblemGroups(props2) {
  const { problemGroups } = props2;
  useTranslation2();
  const items = (0, import_react51.useMemo)(() => {
    const ret = [];
    for (const problemGroup of problemGroups) {
      for (const problem of problemGroup.problems) {
        ret.push({ group: problemGroup, problem });
      }
    }
    return ret;
  }, [problemGroups]);
  return (0, import_jsx_runtime6.jsx)(Stack, { as: "ul", space: 4, children: items.map((_ref464, i) => {
    let { group: group2, problem } = _ref464;
    const isError2 = problem.severity === "error";
    const isWarning = problem.severity === "warning";
    const schemaType = getTypeInfo(group2);
    return (0, import_jsx_runtime6.jsxs)(Card, { border: true, padding: 4, radius: 2, tone: TONES[problem.severity], children: [(0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { marginRight: 3, children: (0, import_jsx_runtime6.jsxs)(Text3, { muted: true, size: 1, children: [isError2 && (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {}), isWarning && (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {})] }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "semibold", children: schemaType ? (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_capitalize2.default)(schemaType.type), ' type "', schemaType.name, '"'] }) : null }) })] }), (0, import_jsx_runtime6.jsx)(Box, { marginTop: 4, children: (0, import_jsx_runtime6.jsx)(Card, { border: true, overflow: "auto", padding: 2, tone: "inherit", children: (0, import_jsx_runtime6.jsx)(Breadcrumbs, { separator: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: "" }), children: group2.path.map((segment, j) => {
      if (segment.kind === "type") {
        const text = "".concat(_renderSegmentName(segment.name), ":").concat(segment.type);
        return (0, import_jsx_runtime6.jsx)(Text3, { title: text, size: 1, textOverflow: "ellipsis", children: (0, import_jsx_runtime6.jsx)(SegmentSpan, { children: text }) }, j);
      }
      if (segment.kind === "property") {
        return (0, import_jsx_runtime6.jsx)(Text3, { title: segment.name, size: 1, textOverflow: "ellipsis", children: (0, import_jsx_runtime6.jsx)(SegmentSpan, { children: segment.name }) }, j);
      }
      return null;
    }) }) }) }), (0, import_jsx_runtime6.jsx)(Box, { as: "ul", marginTop: 4, children: (0, import_jsx_runtime6.jsx)(Box, { as: "li", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(ErrorMessageText, { muted: true, size: 1, children: problem.message }), problem.helpId && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)("a", { href: generateHelpUrl2(problem.helpId), target: "_blank", rel: "noopener noreferrer", children: "View documentation " }) })] }) }) })] }, i);
  }) });
}
function getTypeInfo(problem) {
  const first2 = problem.path[0];
  if (first2.kind === "type") {
    return { name: first2.name, type: first2.type };
  }
  return null;
}
function _renderSegmentName(str) {
  if (str == null ? void 0 : str.startsWith("<unnamed_type_@_index")) {
    const parts = str.slice(1, -1).split("_");
    return "[".concat(parts[4], "]");
  }
  return str;
}
function renderPath(path2) {
  return path2.map((segment) => {
    if (segment.kind === "type") {
      return "".concat(segment.name || "<unnamed>", "(").concat(segment.type, ")");
    }
    if (segment.kind === "property") {
      return segment.name;
    }
    return null;
  }).filter(Boolean).join(" > ");
}
function reportWarnings(schema) {
  const problemGroups = schema._validation;
  const groupsWithWarnings = problemGroups == null ? void 0 : problemGroups.filter((group2) => group2.problems.some((problem) => problem.severity === "warning"));
  if ((groupsWithWarnings == null ? void 0 : groupsWithWarnings.length) === 0) {
    return;
  }
  console.groupCollapsed(" Schema has ".concat(groupsWithWarnings == null ? void 0 : groupsWithWarnings.length, " warnings"));
  groupsWithWarnings == null ? void 0 : groupsWithWarnings.forEach((group2) => {
    const path2 = renderPath(group2.path);
    console.group("%cAt ".concat(path2), "color: #FF7636");
    group2.problems.forEach((problem) => {
      console.log(problem.message);
    });
    console.groupEnd();
  });
  console.groupEnd();
}
function SchemaErrorsScreen(_ref465) {
  let { schema } = _ref465;
  var _a4;
  const groupsWithErrors = ((_a4 = schema._validation) == null ? void 0 : _a4.filter((group2) => group2.problems.some((problem) => problem.severity === "error"))) || [];
  (0, import_react51.useEffect)(() => reportWarnings(schema), [schema]);
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", overflow: "auto", paddingY: [4, 5, 6, 7], paddingX: 4, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Container, { width: 1, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 5, children: [(0, import_jsx_runtime6.jsx)(Heading, { as: "h1", children: "Schema errors" }), (0, import_jsx_runtime6.jsx)(SchemaProblemGroups, { problemGroups: groupsWithErrors })] }) }) });
}
function NotFoundScreen(props2) {
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", sizing: "border", tone: "caution", display: "flex", children: (0, import_jsx_runtime6.jsx)(Flex, { direction: "row", justify: "center", flex: 1, align: "center", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Heading, { as: "h1", children: "Workspace not found" }), (0, import_jsx_runtime6.jsx)(Inline, { children: (0, import_jsx_runtime6.jsx)(Button, { text: "Go to default workspace", onClick: props2.onNavigateToDefaultWorkspace, mode: "ghost" }) })] }) }) });
}
var ActiveWorkspaceMatcherContext = (0, import_react51.createContext)(null);
var WorkspacesContext = (0, import_react51.createContext)(null);
function WorkspacesProvider(_ref466) {
  let { config, children, basePath } = _ref466;
  const { workspaces } = (0, import_react51.useMemo)(() => prepareConfig(config, { basePath }), [config, basePath]);
  return (0, import_jsx_runtime6.jsx)(WorkspacesContext.Provider, { value: workspaces, children });
}
function getWorkspaceIdentifier(_ref467, index) {
  let { name, title } = _ref467;
  if (typeof name === "string" && name.trim().length > 0) {
    return name;
  }
  return getNamelessWorkspaceIdentifier(title, index);
}
function getNamelessWorkspaceIdentifier(title, index) {
  const withTitle = typeof title === "string" && title.trim().length > 0 ? ' (titled "'.concat(title, '")') : "";
  return "at index ".concat(index).concat(withTitle);
}
function useWorkspaces() {
  const workspaces = (0, import_react51.useContext)(WorkspacesContext);
  if (!workspaces)
    throw new Error("Could not find `workspaces` context");
  return workspaces;
}
var WorkspaceValidationError = class extends Error {
  constructor(message, options) {
    super(message);
    this.index = options == null ? void 0 : options.index;
    this.identifier = (options == null ? void 0 : options.workspace) && getWorkspaceIdentifier(options.workspace, options.index);
  }
};
function validateWorkspaces(_ref468) {
  let { workspaces } = _ref468;
  if (workspaces.length === 0) {
    throw new WorkspaceValidationError("At least one workspace is required.");
  }
  validateNames(workspaces);
  validateBasePaths(workspaces);
}
function validateNames(workspaces) {
  const isSingleWorkspace = workspaces.length === 1;
  const names = /* @__PURE__ */ new Map();
  workspaces.forEach((workspace, index) => {
    const { name: rawName, title } = workspace;
    const thisIdentifier = getNamelessWorkspaceIdentifier(title, index);
    if (!rawName && !isSingleWorkspace) {
      throw new WorkspaceValidationError("All workspaces must have a `name`, unless only a single workspace is defined. " + "Workspace ".concat(thisIdentifier, " did not define a `name`."), { workspace, index });
    }
    const name = isSingleWorkspace && typeof rawName === "undefined" ? "default" : rawName;
    if (typeof name !== "string") {
      throw new WorkspaceValidationError("Workspace at index ".concat(index, " defined an invalid `name` - must be a string."), { workspace, index });
    }
    const normalized = name.toLowerCase();
    const existingWorkspace = names.get(normalized);
    if (existingWorkspace) {
      const prevIdentifier = getNamelessWorkspaceIdentifier(existingWorkspace.workspace.title, existingWorkspace.index);
      throw new WorkspaceValidationError("`name`s must be unique. Workspace ".concat(prevIdentifier, " and ") + "workspace ".concat(thisIdentifier, " both have the `name` `").concat(name, "`"), { workspace, index });
    }
    names.set(normalized, { index, workspace });
    if (!/^[a-z0-9][a-z0-9_-]*$/i.test(name)) {
      throw new WorkspaceValidationError("All workspace `name`s must consist of only a-z, 0-9, underscore and dashes, and cannot begin with an underscore or dash. " + "Workspace ".concat(thisIdentifier, " has the invalid name `").concat(name, "`"), { workspace, index });
    }
  });
}
function validateBasePaths(workspaces) {
  if (workspaces.length > 1) {
    workspaces.every(hasBasePath);
  }
  workspaces.every(validateBasePath);
  const [firstWorkspace, ...restOfWorkspaces] = workspaces;
  const firstWorkspaceSegmentCount = (firstWorkspace.basePath || "/").substring(1).split("/").filter(Boolean).length;
  restOfWorkspaces.forEach((workspace, index) => {
    const workspaceSegmentCount = (workspace.basePath || "/").substring(1).split("/").length;
    if (firstWorkspaceSegmentCount !== workspaceSegmentCount) {
      throw new WorkspaceValidationError("All workspace `basePath`s must have the same amount of segments. Workspace `".concat(getWorkspaceIdentifier(firstWorkspace, index), "` had ").concat(firstWorkspaceSegmentCount, " segment").concat(firstWorkspaceSegmentCount === 1 ? "" : "s", " `").concat(firstWorkspace.basePath, "` but workspace `").concat(getWorkspaceIdentifier(workspace, index), "` had ").concat(workspaceSegmentCount, " segment").concat(workspaceSegmentCount === 1 ? "" : "s", " `").concat(workspace.basePath, "`"), { workspace, index });
    }
  });
  const basePaths = /* @__PURE__ */ new Map();
  workspaces.forEach((workspace, index) => {
    const basePath = (workspace.basePath || "").toLowerCase();
    const existingWorkspace = basePaths.get(basePath);
    if (existingWorkspace) {
      throw new WorkspaceValidationError("`basePath`s must be unique. Workspaces `".concat(existingWorkspace, "` and ") + "`".concat(getWorkspaceIdentifier(workspace, index), "` both have the `basePath` `").concat(basePath, "`"), { workspace, index });
    }
    basePaths.set(basePath, getWorkspaceIdentifier(workspace, index));
  });
}
function hasBasePath(workspace, index) {
  const { name, basePath } = workspace;
  if (basePath && typeof basePath === "string") {
    return true;
  }
  if (typeof basePath === "undefined") {
    throw new WorkspaceValidationError("If more than one workspace is defined, every workspace must have a `basePath` defined. " + "Workspace `".concat(name, "` is missing a `basePath`"), { workspace, index });
  }
  throw new WorkspaceValidationError("If more than one workspace is defined, every workspace must have a `basePath` defined. " + "Workspace `".concat(name, "` has an invalid `basePath` (must be a non-empty string)"), { workspace, index });
}
function validateBasePath(workspace, index) {
  const { name, basePath } = workspace;
  if (!basePath || basePath === "/") {
    return;
  }
  if (!/^\/[a-z0-9/_-]*[a-z0-9_-]+$/i.test(basePath)) {
    throw new WorkspaceValidationError("All workspace `basePath`s must start with a leading `/`, consist of only URL safe characters, and cannot end with a trailing `/`. " + "Workspace `".concat(name, "`'s basePath is `").concat(basePath, "`"), { workspace, index });
  }
}
function matchWorkspace(_ref469) {
  let { pathname, workspaces, basePathRegex } = _ref469;
  const [firstWorkspace] = workspaces;
  for (const { workspace, basePath, basePathRegex: basePathRegex2 } of workspaces) {
    if (basePathRegex2.test(pathname) || basePath === "/") {
      return { type: "match", workspace };
    }
  }
  if (pathname === "/") {
    return { type: "redirect", pathname: firstWorkspace.basePath };
  }
  if (basePathRegex.test(pathname)) {
    return { type: "redirect", pathname: firstWorkspace.basePath };
  }
  return { type: "not-found" };
}
function createCommonBasePathRegex(workspaces) {
  const workspaceSegments = workspaces.map((workspace) => (
    // gets the segments from the basePath
    workspace.basePath.substring(1).split("/")
  ));
  const commonBasePath = workspaceSegments.reduce((commonSegments, segments) => {
    for (let i = 0; i < commonSegments.length; i++) {
      const commonSegment = commonSegments[i];
      const segment = segments[i].toLowerCase();
      if (commonSegment !== segment) {
        return commonSegments.slice(0, i);
      }
    }
    return commonSegments;
  });
  function createCommonBasePathRegexRecursively(_ref470) {
    let [first2, ...rest] = _ref470;
    if (!first2)
      return "";
    return "(\\/".concat((0, import_escapeRegExp.default)(first2)).concat(createCommonBasePathRegexRecursively(rest), "(\\/|$))?");
  }
  return new RegExp("^".concat(createCommonBasePathRegexRecursively(commonBasePath), "$"), "i");
}
function useNormalizedWorkspaces(workspaces) {
  return (0, import_react51.useMemo)(() => normalizedWorkspaces(workspaces), [workspaces]);
}
function normalizedWorkspaces(workspaces) {
  return workspaces.map((workspace) => {
    const basePath = workspace.basePath || "/";
    return {
      workspace,
      name: workspace.name,
      basePath,
      // this regex ends with a `(\\/|$)` (forward slash or end) to prevent false
      // matches where the pathname is a false subset of the current pathname.
      // e.g. if the `workspace.basePath` is `/base/foobar` and the current
      // pathname is `/base/foo`, then that should not be a match
      basePathRegex: new RegExp("^".concat((0, import_escapeRegExp.default)(basePath), "(\\/|$)"), "i")
    };
  });
}
function useSyncPathnameWithWorkspace(history2, _workspaces) {
  const workspaces = useNormalizedWorkspaces(_workspaces);
  const basePathRegex = (0, import_react51.useMemo)(() => createCommonBasePathRegex(workspaces), [workspaces]);
  const [serverSnapshot] = (0, import_react51.useState)(() => history2.location.pathname);
  const store = (0, import_react51.useMemo)(() => {
    return { subscribe: (onStoreChange) => history2.listen(onStoreChange), getSnapshot: () => history2.location.pathname, getServerSnapshot: () => serverSnapshot, selector: (pathname) => matchWorkspace({ basePathRegex, pathname, workspaces }), isEqual: (a, b) => {
      if (a.type !== b.type)
        return false;
      switch (a.type) {
        case "match":
          return a.workspace === b.workspace;
        case "redirect":
          return a.pathname === b.pathname;
        case "not-found":
          return true;
        default:
          throw new Error("Unknown type: ".concat(a.type));
      }
    } };
  }, [basePathRegex, history2, serverSnapshot, workspaces]);
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, store.getSnapshot, store.getServerSnapshot, store.selector, store.isEqual);
}
var RouterHistoryContext = (0, import_react51.createContext)(null);
function RouterHistoryProvider(_ref471) {
  let { children, history: history2 } = _ref471;
  return (0, import_jsx_runtime6.jsx)(RouterHistoryContext.Provider, { value: history2, children });
}
function useRouterHistory() {
  const value = (0, import_react51.useContext)(RouterHistoryContext);
  if (!value)
    throw new Error("Could not find `RouterHistoryProvider` context");
  return value;
}
var ActiveWorkspaceMatcherProvider = (0, import_react51.memo)(function ActiveWorkspaceMatcherContextProvider(_ref472) {
  let { children, history: history2, activeWorkspace, setActiveWorkspace } = _ref472;
  const value = (0, import_react51.useMemo)(() => ({ activeWorkspace, setActiveWorkspace }), [activeWorkspace, setActiveWorkspace]);
  return (0, import_jsx_runtime6.jsx)(ActiveWorkspaceMatcherContext.Provider, { value, children: (0, import_jsx_runtime6.jsx)(RouterHistoryProvider, { history: history2, children }) });
});
var createHistory = () => typeof document === "undefined" ? createMemoryHistory() : createBrowserHistory();
function ActiveWorkspaceMatcher(_ref473) {
  let { children, LoadingComponent, NotFoundComponent, unstable_history: historyProp } = _ref473;
  const workspaces = useWorkspaces();
  const history2 = (0, import_react51.useMemo)(() => historyProp || createHistory(), [historyProp]);
  const setActiveWorkspaceName = (0, import_react51.useCallback)((workspaceName) => {
    const foundWorkspace = workspaces.find((workspace) => workspace.name === workspaceName);
    if (foundWorkspace) {
      history2.push(foundWorkspace.basePath);
    }
  }, [history2, workspaces]);
  const handleNavigateToDefaultWorkspace = (0, import_react51.useCallback)(() => {
    setActiveWorkspaceName(workspaces[0].name);
  }, [setActiveWorkspaceName, workspaces]);
  const result = useSyncPathnameWithWorkspace(history2, workspaces);
  (0, import_react51.useEffect)(() => {
    if (result.type === "redirect") {
      history2.replace(result.pathname);
    }
  }, [history2, result]);
  switch (result.type) {
    case "match":
      return (0, import_jsx_runtime6.jsx)(ActiveWorkspaceMatcherProvider, { activeWorkspace: result.workspace, history: history2, setActiveWorkspace: setActiveWorkspaceName, children });
    case "redirect":
      return (0, import_jsx_runtime6.jsx)(LoadingComponent, {});
    case "not-found":
      return (0, import_jsx_runtime6.jsx)(NotFoundComponent, { onNavigateToDefaultWorkspace: handleNavigateToDefaultWorkspace });
    default:
      throw new Error("Unknown type: ".concat(result.type));
  }
}
function useActiveWorkspace() {
  const value = (0, import_react51.useContext)(ActiveWorkspaceMatcherContext);
  if (!value)
    throw new Error("Could not find `ActiveWorkspaceMatcher` context");
  return value;
}
var __freeze$I = Object.freeze;
var __defProp$I = Object.defineProperty;
var __template$I = (cooked, raw) => __freeze$I(__defProp$I(cooked, "raw", { value: __freeze$I(raw || cooked.slice()) }));
var _a$I;
var STATE_TITLES = { "logged-in": "", "logged-out": "Signed out", "no-access": "" };
var MediaCard$1 = st(Card)(_a$I || (_a$I = __template$I(["\n  width: 35px;\n  height: 35px;\n\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n"])));
var createIcon = (icon) => {
  if ((0, import_react_is2.isValidElementType)(icon))
    return (0, import_react51.createElement)(icon);
  if ((0, import_react51.isValidElement)(icon))
    return icon;
  return void 0;
};
function WorkspacePreview(props2) {
  const { state, subtitle, selected, title, icon, iconRight } = props2;
  const iconComponent = (0, import_react51.useMemo)(() => createIcon(icon), [icon]);
  const iconRightComponent = (0, import_react51.useMemo)(() => createIcon(iconRight), [iconRight]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", flex: "none", gap: 3, children: [(0, import_jsx_runtime6.jsx)(MediaCard$1, { radius: 2, tone: "transparent", children: iconComponent }), (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", weight: "medium", children: title }), subtitle && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: subtitle })] }), state && STATE_TITLES[state] && (0, import_jsx_runtime6.jsx)(Box, { paddingLeft: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, textOverflow: "ellipsis", children: STATE_TITLES[state] }) }), (selected || iconRightComponent) && (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 4, paddingLeft: 3, paddingRight: 2, children: [selected && (0, import_jsx_runtime6.jsx)(Text3, { children: (0, import_jsx_runtime6.jsx)(CheckmarkIcon, {}) }), iconRightComponent && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: iconRightComponent })] })] });
}
var useWorkspaceAuthStates = createHookFromObservableFactory((workspaces) => combineLatest(workspaces.map((workspace) => (
  // eslint-disable-next-line max-nested-callbacks
  workspace.auth.state.pipe(map((state) => [workspace.name, state]))
))).pipe(map((entries) => Object.fromEntries(entries))));
var WORKSPACES_DOCS_URL = "https://beta.sanity.io/docs/platform/studio/config/workspaces";
var __freeze$H = Object.freeze;
var __defProp$H = Object.defineProperty;
var __template$H = (cooked, raw) => __freeze$H(__defProp$H(cooked, "raw", { value: __freeze$H(raw || cooked.slice()) }));
var _a$H;
var LINKS = [{ url: "https://slack.sanity.io/", i18nKey: "workspaces.community-title", title: "Community" }, { url: "https://www.sanity.io/docs", i18nKey: "workspaces.docs-title", title: "Docs" }, { url: "https://www.sanity.io/legal/privacy", i18nKey: "workspaces.privacy-title", title: "Privacy" }, { url: "https://www.sanity.io", i18nKey: "workspaces.sanity-io-title", title: "sanity.io" }];
var StyledText = st(Text3)(_a$H || (_a$H = __template$H(["\n  a {\n    color: inherit;\n  }\n"])));
function Layout(props2) {
  const { children, footer, header } = props2;
  useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: 6, children: [(0, import_jsx_runtime6.jsx)(Card, { border: true, radius: 3, overflow: "auto", children: (0, import_jsx_runtime6.jsxs)(Stack, { children: [typeof header === "object" && (0, import_jsx_runtime6.jsx)(Box, { children: header }), typeof header === "string" && (0, import_jsx_runtime6.jsx)(Box, { paddingY: 4, children: (0, import_jsx_runtime6.jsx)(Heading, { align: "center", size: 1, children: header }) }), (0, import_jsx_runtime6.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime6.jsx)(Card, { borderTop: Boolean(header), borderBottom: Boolean(footer), children }) }), footer && (0, import_jsx_runtime6.jsx)(Box, { children: footer })] }) }), (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", gap: 4, justify: "center", align: "center", paddingBottom: 4, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 3, children: (0, import_jsx_runtime6.jsx)(SanityLogo, {}) }), (0, import_jsx_runtime6.jsx)(Flex, { align: "center", gap: 2, children: LINKS.map((link, index) => (0, import_jsx_runtime6.jsxs)(import_react51.default.Fragment, { children: [(0, import_jsx_runtime6.jsx)(StyledText, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)("a", { href: link.url, target: "_blank", rel: "noopener noreferrer", children: link.title }) }), index < LINKS.length - 1 && (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: "" })] }, link.title)) })] })] });
}
function WorkspaceAuth() {
  var _a4;
  const workspaces = useWorkspaces();
  const { activeWorkspace, setActiveWorkspace } = useActiveWorkspace();
  const [authStates] = useWorkspaceAuthStates(workspaces);
  const [selectedWorkspaceName, setSelectedWorkspaceName] = (0, import_react51.useState)((activeWorkspace == null ? void 0 : activeWorkspace.name) || null);
  const selectedWorkspace = workspaces.length === 1 ? workspaces[0] : workspaces.find((workspace) => workspace.name === selectedWorkspaceName);
  const LoginComponent = (_a4 = selectedWorkspace == null ? void 0 : selectedWorkspace.auth) == null ? void 0 : _a4.LoginComponent;
  const handleBack = (0, import_react51.useCallback)(() => setSelectedWorkspaceName(null), []);
  const { t: t3 } = useTranslation2();
  if (!authStates)
    return (0, import_jsx_runtime6.jsx)(LoadingScreen, {});
  if (LoginComponent && selectedWorkspace) {
    return (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [workspaces.length > 1 && (0, import_jsx_runtime6.jsx)(Flex, { children: (0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, icon: ArrowLeftIcon, mode: "bleed", onClick: handleBack, padding: 2, text: t3("workspaces.action.choose-another-workspace") }) }), (0, import_jsx_runtime6.jsx)(Layout, { header: (0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime6.jsx)(WorkspacePreview, { icon: selectedWorkspace.icon, title: selectedWorkspace.title, subtitle: selectedWorkspace == null ? void 0 : selectedWorkspace.subtitle }) }), children: (0, import_jsx_runtime6.jsx)(Stack, { padding: 2, paddingBottom: 3, paddingTop: 4, children: (0, import_react51.createElement)(LoginComponent, { ...(0, import_omit4.default)(selectedWorkspace, ["type", "__internal"]), key: selectedWorkspaceName }) }) })] });
  }
  return (0, import_jsx_runtime6.jsx)(Layout, { header: t3("workspaces.choose-your-workspace-label"), footer: (0, import_jsx_runtime6.jsx)(Stack, { padding: 1, children: (0, import_jsx_runtime6.jsx)(Button, { as: "a", href: WORKSPACES_DOCS_URL, icon: AddIcon, justify: "flex-start", mode: "bleed", rel: "noopener noreferrer", target: "__blank", text: t3("workspaces.action.add-workspace") }) }), children: (0, import_jsx_runtime6.jsx)(Stack, { space: 1, paddingX: 1, paddingY: 2, children: workspaces.map((workspace) => {
    const authState = authStates[workspace.name];
    const state = authState.authenticated ? "logged-in" : workspace.auth.LoginComponent ? "logged-out" : "no-access";
    const handleSelectWorkspace = () => {
      if (state === "logged-in" && workspace.name !== activeWorkspace.name) {
        setActiveWorkspace(workspace.name);
      }
      if (state === "logged-out") {
        setSelectedWorkspaceName(workspace.name);
      }
    };
    return (0, import_jsx_runtime6.jsx)(Card, { as: "button", radius: 2, padding: 2, onClick: handleSelectWorkspace, children: (0, import_jsx_runtime6.jsx)(WorkspacePreview, { icon: workspace == null ? void 0 : workspace.icon, iconRight: ChevronRightIcon, state, subtitle: workspace == null ? void 0 : workspace.subtitle, title: (workspace == null ? void 0 : workspace.title) || workspace.name }) }, workspace.name);
  }) }) });
}
var ColorSchemeValueContext = (0, import_react51.createContext)(null);
var ColorSchemeSetValueContext = (0, import_react51.createContext)(null);
function useSystemScheme() {
  const prefersDark = usePrefersDark();
  return prefersDark ? "dark" : "light";
}
function ColorThemeProvider(_ref474) {
  let { children, scheme: _scheme } = _ref474;
  const systemScheme = useSystemScheme();
  const scheme = _scheme === "system" ? systemScheme : _scheme;
  return (0, import_jsx_runtime6.jsx)(ThemeProvider, { scheme, theme: studioTheme, children });
}
var LOCAL_STORAGE_KEY = "sanityStudio:ui:colorScheme";
function ColorSchemeProvider(_ref475) {
  let { children, onSchemeChange, scheme: schemeProp } = _ref475;
  if (schemeProp) {
    return (0, import_jsx_runtime6.jsx)(ColorSchemeCustomProvider, { scheme: schemeProp, onSchemeChange, children });
  }
  return (0, import_jsx_runtime6.jsx)(ColorSchemeLocalStorageProvider, { onSchemeChange, children });
}
function ColorSchemeLocalStorageProvider(_ref476) {
  let { children, onSchemeChange } = _ref476;
  const store = (0, import_react51.useMemo)(() => {
    let snapshot;
    const subscribers = /* @__PURE__ */ new Set();
    return {
      subscribe: (onStoreChange) => {
        if (!snapshot) {
          snapshot = getScheme(localStorage.getItem(LOCAL_STORAGE_KEY)) || "system";
        }
        subscribers.add(onStoreChange);
        return () => {
          subscribers.delete(onStoreChange);
        };
      },
      getSnapshot: () => snapshot,
      setSnapshot: (nextScheme) => {
        snapshot = getScheme(nextScheme);
        for (const subscription of subscribers) {
          subscription();
        }
      },
      // Only called during server-side rendering, and hydration if using hydrateRoot
      // https://beta.reactjs.org/apis/react/useSyncExternalStore#adding-support-for-server-rendering
      getServerSnapshot: () => "system"
    };
  }, []);
  const scheme = (0, import_react51.useSyncExternalStore)(store.subscribe, store.getSnapshot, store.getServerSnapshot);
  (0, import_react51.useEffect)(() => {
    if (typeof onSchemeChange === "function") {
      onSchemeChange(scheme);
    }
    localStorage.setItem(LOCAL_STORAGE_KEY, scheme);
  }, [onSchemeChange, scheme]);
  return (0, import_jsx_runtime6.jsx)(ColorSchemeSetValueContext.Provider, { value: store.setSnapshot, children: (0, import_jsx_runtime6.jsx)(ColorSchemeValueContext.Provider, { value: scheme, children: (0, import_jsx_runtime6.jsx)(ColorThemeProvider, { scheme, children }) }) });
}
function getScheme(scheme) {
  switch (scheme) {
    case "dark":
    case "light":
      return scheme;
    default:
      return "system";
  }
}
function ColorSchemeCustomProvider(_ref477) {
  let { children, onSchemeChange, scheme } = _ref477;
  return (0, import_jsx_runtime6.jsx)(ColorSchemeSetValueContext.Provider, { value: typeof onSchemeChange === "function" ? onSchemeChange : false, children: (0, import_jsx_runtime6.jsx)(ColorSchemeValueContext.Provider, { value: scheme, children: (0, import_jsx_runtime6.jsx)(ColorThemeProvider, { scheme, children }) }) });
}
function useColorSchemeSetValue() {
  const setValue = (0, import_react51.useContext)(ColorSchemeSetValueContext);
  if (setValue === null)
    throw new Error("Could not find `ColorSchemeSetValueContext` context");
  return setValue;
}
function _useColorSchemeInternalValue() {
  const value = (0, import_react51.useContext)(ColorSchemeValueContext);
  if (value === null)
    throw new Error("Could not find `ColorSchemeValueContext` context");
  return value;
}
function useColorSchemeValue() {
  const scheme = _useColorSchemeInternalValue();
  const systemScheme = useSystemScheme();
  return scheme === "system" ? systemScheme : scheme;
}
function useColorScheme() {
  const scheme = useColorSchemeValue();
  const setScheme = useColorSchemeSetValue();
  return (0, import_react51.useMemo)(() => ({ scheme, setScheme }), [scheme, setScheme]);
}
function useColorSchemeOptions(setScheme, t3) {
  const scheme = _useColorSchemeInternalValue();
  return (0, import_react51.useMemo)(() => {
    return [{ title: t3("user-menu.color-scheme.system-title"), name: "system", label: t3("user-menu.color-scheme.system-description"), selected: scheme === "system", onSelect: () => setScheme("system"), icon: DesktopIcon }, { title: t3("user-menu.color-scheme.dark-title"), name: "dark", label: t3("user-menu.color-scheme.dark-description"), selected: scheme === "dark", onSelect: () => setScheme("dark"), icon: MoonIcon }, { title: t3("user-menu.color-scheme.light-title"), name: "light", label: t3("user-menu.color-scheme.light-description"), selected: scheme === "light", onSelect: () => setScheme("light"), icon: SunIcon }];
  }, [scheme, setScheme, t3]);
}
var __freeze$G = Object.freeze;
var __defProp$G = Object.defineProperty;
var __template$G = (cooked, raw) => __freeze$G(__defProp$G(cooked, "raw", { value: __freeze$G(raw || cooked.slice()) }));
var _a$G;
var StyledMenu$3 = st(Menu)(_a$G || (_a$G = __template$G(["\n  max-width: 350px;\n  min-width: 250px;\n"])));
function WorkspaceMenuButton(props2) {
  const { collapsed = false } = props2;
  const [menuOpen, setMenuOpen] = (0, import_react51.useState)(false);
  const { scheme } = useColorScheme();
  const workspaces = useWorkspaces();
  const { activeWorkspace, setActiveWorkspace } = useActiveWorkspace();
  const [authStates] = useWorkspaceAuthStates(workspaces);
  const { navigateUrl } = useRouter();
  const { t: t3 } = useTranslation2();
  const handleOnOpen = (0, import_react51.useCallback)(() => setMenuOpen(true), []);
  const handleOnClose = (0, import_react51.useCallback)(() => setMenuOpen(false), []);
  const popoverProps = (0, import_react51.useMemo)(() => ({ constrainSize: true, scheme, portal: true }), [scheme]);
  const tooltipDisabled = menuOpen || !collapsed;
  const ariaLabel = collapsed ? t3("workspaces.select-workspace-aria-label") : void 0;
  const buttonText = collapsed ? void 0 : t3("workspaces.select-workspace-label");
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("workspaces.title") }) }), disabled: tooltipDisabled, placement: "bottom", portal: true, scheme, children: (0, import_jsx_runtime6.jsx)(Stack, { children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { icon: SelectIcon, mode: "bleed", text: buttonText, disabled: !authStates, "aria-label": ariaLabel, justify: collapsed ? void 0 : "flex-start" }), id: "workspaces", menu: (0, import_jsx_runtime6.jsxs)(StyledMenu$3, { children: [(0, import_jsx_runtime6.jsx)(Box, { paddingX: 3, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("workspaces.title") }) }), authStates && workspaces.map((workspace) => {
    const authState = authStates[workspace.name];
    const state = authState.authenticated ? "logged-in" : workspace.auth.LoginComponent ? "logged-out" : "no-access";
    const handleSelectWorkspace = () => {
      if (state === "logged-in" && workspace.name !== activeWorkspace.name) {
        setActiveWorkspace(workspace.name);
      }
      if (state === "logged-out") {
        navigateUrl({ path: workspace.basePath });
      }
    };
    return (0, import_jsx_runtime6.jsx)(MenuItem, { onClick: handleSelectWorkspace, padding: 2, pressed: workspace.name === activeWorkspace.name, children: (0, import_jsx_runtime6.jsx)(WorkspacePreview, { icon: workspace == null ? void 0 : workspace.icon, selected: workspace.name === activeWorkspace.name, state, subtitle: workspace == null ? void 0 : workspace.subtitle, title: (workspace == null ? void 0 : workspace.title) || workspace.name }) }, workspace.name);
  })] }), onClose: handleOnClose, onOpen: handleOnOpen, popover: popoverProps }) }) });
}
function AuthenticateScreen() {
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", overflow: "auto", children: (0, import_jsx_runtime6.jsx)(Flex, { height: "fill", direction: "column", align: "center", justify: "center", paddingTop: 4, children: (0, import_jsx_runtime6.jsx)(Container, { width: 0, children: (0, import_jsx_runtime6.jsx)(WorkspaceAuth, {}) }) }) });
}
function ConfigErrorsScreen() {
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: "TODO: implement config errors screen" });
}
function NotAuthenticatedScreen() {
  const [currentUser, setCurrentUser] = (0, import_react51.useState)(null);
  const [error2, handleError] = (0, import_react51.useState)(null);
  if (error2)
    throw error2;
  const { activeWorkspace } = useActiveWorkspace();
  const handleLogout = (0, import_react51.useCallback)(() => {
    var _a4, _b4;
    (_b4 = (_a4 = activeWorkspace.auth).logout) == null ? void 0 : _b4.call(_a4);
  }, [activeWorkspace]);
  (0, import_react51.useEffect)(() => {
    const subscription = activeWorkspace.auth.state.subscribe({ next: (_ref478) => {
      let { currentUser: user } = _ref478;
      setCurrentUser(user);
    }, error: handleError });
    return () => {
      subscription.unsubscribe();
    };
  }, [activeWorkspace]);
  const providerTitle = getProviderTitle(currentUser == null ? void 0 : currentUser.provider);
  const providerHelp = providerTitle ? " through ".concat(providerTitle) : "";
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", children: (0, import_jsx_runtime6.jsx)(Dialog, { id: "not-authorized-dialog", header: "Not authorized", width: 1, footer: (0, import_jsx_runtime6.jsx)(Stack, { paddingX: 3, paddingY: 2, children: (0, import_jsx_runtime6.jsx)(Button, { text: "Sign out", onClick: handleLogout }) }), children: (0, import_jsx_runtime6.jsxs)(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [(0, import_jsx_runtime6.jsx)(Text3, { children: "You are not authorized to access this studio. Maybe you could ask someone to invite you to collaborate on this project?" }), (0, import_jsx_runtime6.jsxs)(Text3, { children: ["If you think this is an error, verify that you are signed in with the correct account. You are currently signed in as", " ", (0, import_jsx_runtime6.jsxs)("strong", { children: [currentUser == null ? void 0 : currentUser.name, " (", currentUser == null ? void 0 : currentUser.email, ")"] }), providerHelp, "."] })] }) }) });
}
var __freeze$F = Object.freeze;
var __defProp$F = Object.defineProperty;
var __template$F = (cooked, raw) => __freeze$F(__defProp$F(cooked, "raw", { value: __freeze$F(raw || cooked.slice()) }));
var _a$F;
var ScreenReaderLabel = st.label(_a$F || (_a$F = __template$F(["\n  clip: rect(0 0 0 0);\n  clip-path: inset(50%);\n  height: 1px;\n  overflow: hidden;\n  overflow: clip;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n"])));
function CorsOriginErrorScreen(props2) {
  const { projectId: projectId2 } = props2;
  const origin = window.location.origin;
  const corsUrl = (0, import_react51.useMemo)(() => {
    const url = new URL("https://sanity.io/manage/project/".concat(projectId2, "/api"));
    url.searchParams.set("cors", "add");
    url.searchParams.set("origin", origin);
    url.searchParams.set("credentials", "");
    return url.toString();
  }, [origin, projectId2]);
  (0, import_react51.useEffect)(() => {
    const handleFocus = () => {
      window.location.reload();
    };
    window.addEventListener("focus", handleFocus);
    return () => {
      window.removeEventListener("focus", handleFocus);
    };
  }, []);
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", children: (0, import_jsx_runtime6.jsx)(Dialog, { id: "cors-error-dialog", header: "Before you continue...", width: 1, children: (0, import_jsx_runtime6.jsxs)(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [(0, import_jsx_runtime6.jsxs)(Text3, { children: ["To access your content, you need to ", (0, import_jsx_runtime6.jsx)("b", { children: "add the following URL as a CORS origin" }), " to your Sanity project."] }), (0, import_jsx_runtime6.jsx)(ScreenReaderLabel, { "aria-hidden": "true", children: "CORS URL to be added" }), (0, import_jsx_runtime6.jsx)(TextInput, { value: origin, readOnly: true }), (0, import_jsx_runtime6.jsx)(Button, { as: "a", href: corsUrl, target: "_blank", rel: "noopener noreferrer", tone: "primary", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "center", gap: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { weight: "medium", children: "Continue" }), (0, import_jsx_runtime6.jsx)(Text3, { weight: "medium", children: (0, import_jsx_runtime6.jsx)(LaunchIcon, {}) })] }) })] }) }) });
}
function AuthBoundary(_ref479) {
  let { children, AuthenticateComponent = AuthenticateScreen, LoadingComponent = LoadingScreen, NotAuthenticatedComponent = NotAuthenticatedScreen } = _ref479;
  const [error2, handleError] = (0, import_react51.useState)(null);
  if (error2)
    throw error2;
  const [loggedIn, setLoggedIn] = (0, import_react51.useState)("loading");
  const { activeWorkspace } = useActiveWorkspace();
  (0, import_react51.useEffect)(() => {
    var _a4, _b4;
    (_b4 = (_a4 = activeWorkspace.auth).handleCallbackUrl) == null ? void 0 : _b4.call(_a4).catch(handleError);
  }, [activeWorkspace.auth]);
  (0, import_react51.useEffect)(() => {
    const subscription = activeWorkspace.auth.state.subscribe({ next: (_ref480) => {
      let { authenticated, currentUser } = _ref480;
      var _a4;
      if (((_a4 = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _a4.length) === 0) {
        setLoggedIn("unauthorized");
        return;
      }
      setLoggedIn(authenticated ? "logged-in" : "logged-out");
    }, error: handleError });
    return () => {
      subscription.unsubscribe();
    };
  }, [activeWorkspace]);
  if (loggedIn === "loading")
    return (0, import_jsx_runtime6.jsx)(LoadingComponent, {});
  if (loggedIn === "unauthorized")
    return (0, import_jsx_runtime6.jsx)(NotAuthenticatedComponent, {});
  if (loggedIn === "logged-out")
    return (0, import_jsx_runtime6.jsx)(AuthenticateComponent, {});
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children });
}
function StudioThemeProvider(_ref481) {
  let { children } = _ref481;
  const theme = useActiveWorkspace().activeWorkspace.theme;
  if (theme.__legacy) {
    const scheme = theme.__dark ? "dark" : "light";
    return (0, import_jsx_runtime6.jsx)(ColorSchemeSetValueContext.Provider, { value: false, children: (0, import_jsx_runtime6.jsx)(ColorSchemeValueContext.Provider, { value: scheme, children: (0, import_jsx_runtime6.jsx)(ThemeProvider, { scheme, theme, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(LayerProvider, { children }) }) }) });
  }
  return (0, import_jsx_runtime6.jsx)(ThemeProvider, { theme, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(LayerProvider, { children }) });
}
function StudioErrorBoundary(_ref482) {
  let { children, heading = "An error occured" } = _ref482;
  const [{ error: error2 }, setError] = (0, import_react51.useState)({ error: null });
  const message = isRecord$4(error2) && typeof error2.message === "string" && error2.message;
  const stack = isRecord$4(error2) && typeof error2.stack === "string" && error2.stack;
  const handleResetError = (0, import_react51.useCallback)(() => setError({ error: null }), [setError]);
  useHotModuleReload(handleResetError);
  if (error2 instanceof CorsOriginError) {
    return (0, import_jsx_runtime6.jsx)(CorsOriginErrorScreen, { projectId: error2 == null ? void 0 : error2.projectId });
  }
  if (error2 instanceof SchemaError) {
    return (0, import_jsx_runtime6.jsx)(SchemaErrorsScreen, { schema: error2.schema });
  }
  if (!error2) {
    return (0, import_jsx_runtime6.jsx)(ErrorBoundary, { onCatch: setError, children });
  }
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", overflow: "auto", paddingY: [4, 5, 6, 7], paddingX: 4, sizing: "border", tone: "critical", children: (0, import_jsx_runtime6.jsx)(Container, { width: 3, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(Heading, { children: heading }), (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Button, { onClick: handleResetError, text: "Retry", tone: "default" }) }), (0, import_jsx_runtime6.jsx)(Card, { border: true, radius: 2, overflow: "auto", padding: 4, tone: "inherit", children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [message && (0, import_jsx_runtime6.jsx)(Code, { size: 1, children: (0, import_jsx_runtime6.jsxs)("strong", { children: ["Error: ", message] }) }), stack && (0, import_jsx_runtime6.jsx)(Code, { size: 1, children: stack })] }) })] }) }) });
}
var Z_OFFSET = { toast: [100, 11e3] };
var __freeze$E = Object.freeze;
var __defProp$E2 = Object.defineProperty;
var __template$E = (cooked, raw) => __freeze$E(__defProp$E2(cooked, "raw", { value: __freeze$E(raw || cooked.slice()) }));
var _a$E;
var _b$l2;
st(Flex)(_a$E || (_a$E = __template$E([""])));
st(Box).attrs({ padding: 4 })(_b$l2 || (_b$l2 = __template$E([""])));
function createRouter(opts) {
  const { basePath = "/", tools } = opts;
  const toolRoute = route.create("/:tool", (toolParams) => {
    let tool = tools.find((current) => current.name === toolParams.tool);
    if (!tool && toolParams.tool === "desk") {
      tool = tools.find((current) => current.name === "structure");
    }
    return tool ? route.scope(tool.name, "/", tool.router) : route.create("/");
  });
  return route.create(basePath, [route.intents("/intent"), toolRoute]);
}
function getOrderedTools(tools) {
  const pluginConfig = {};
  const config = pluginConfig.toolSwitcher || {};
  const order2 = config.order || [];
  const hidden = config.hidden || [];
  if (!order2.length && !hidden.length) {
    return tools;
  }
  const keyed = tools.reduce((target, tool) => {
    const title = tool.title || "<unknown>";
    if (!tool.name) {
      console.warn('Tool "'.concat(title, '" does not have the required "name" property'));
      return target;
    }
    if (target[tool.name]) {
      const existing = target[tool.name].tool.title;
      console.warn('Tools with duplicate name "'.concat(tool.name, '" found ("').concat(title, '" and "').concat(existing, '")'));
      return target;
    }
    const toolIndex = order2.indexOf(tool.name);
    target[tool.name] = { tool, index: toolIndex === -1 ? Infinity : toolIndex };
    return target;
  }, {});
  const isVisible = (tool) => hidden.indexOf(tool.name) === -1;
  const ret = tools.filter(isVisible);
  ret.sort((tool1, tool2) => {
    const toolA = keyed[tool1.name];
    const toolB = keyed[tool2.name];
    const indexA = toolA ? toolA.index : Infinity;
    const indexB = toolB ? toolB.index : Infinity;
    if (indexA === indexB) {
      return 0;
    }
    return indexA - indexB;
  });
  return ret;
}
var WEIGHTED_CREATE_INTENT_PARAMS = ["template"];
var WEIGHTED_EDIT_INTENT_PARAMS = ["mode"];
function resolveUrlStateWithDefaultTool(tools, state) {
  const orderedTools = getOrderedTools(tools);
  const defaultTool = orderedTools[0];
  if (!state || state.tool || !defaultTool) {
    return state;
  }
  return Object.assign({}, state, { tool: defaultTool.name });
}
function makeBackwardsCompatible(tools, state) {
  if (!state) {
    return state;
  }
  if (getOrderedTools(tools).find((tool) => tool.name === state.space)) {
    return { ...state, tool: state.space, space: void 0 };
  }
  return state;
}
function resolveDefaultState(tools, state) {
  const urlStateWithDefaultTool = resolveUrlStateWithDefaultTool(tools, makeBackwardsCompatible(tools, state));
  return urlStateWithDefaultTool;
}
function resolveIntentState(tools, prevState, nextState) {
  var _a4;
  const { intent, params, payload } = nextState;
  if (typeof intent !== "string") {
    throw new Error("intent must be a string");
  }
  if (!isRecord$4(params)) {
    throw new Error("intent params must be a string");
  }
  const orderedTools = getOrderedTools(tools);
  const currentTool = (prevState == null ? void 0 : prevState.tool) ? orderedTools.find((tool) => tool.name === prevState.tool) : null;
  const otherTools = currentTool ? orderedTools.filter((tool) => tool !== currentTool) : orderedTools;
  let weightedParams = [];
  if (intent === "create") {
    weightedParams = WEIGHTED_CREATE_INTENT_PARAMS;
  } else if (intent === "edit") {
    weightedParams = WEIGHTED_EDIT_INTENT_PARAMS;
  }
  const initialMatch = { score: -1, tool: null };
  const { tool: matchingTool } = (currentTool ? [currentTool, ...otherTools] : orderedTools).reduce((prev, tool) => {
    if (!tool || typeof tool.canHandleIntent !== "function") {
      return prev;
    }
    const canHandle = tool.canHandleIntent(intent, params, prevState && prevState[tool.name]);
    if (typeof canHandle === "boolean") {
      return canHandle && prev.score < 0 ? { score: 0, tool } : prev;
    }
    if (!isRecord$4(canHandle)) {
      return prev;
    }
    const score2 = weightedParams.reduce((prevScore, weightedParam) => {
      return weightedParam in params && canHandle[weightedParam] === true ? prevScore + 1 : prevScore;
    }, 0);
    return score2 > prev.score ? { score: score2, tool } : prev;
  }, initialMatch);
  if (matchingTool == null ? void 0 : matchingTool.getIntentState) {
    const _toolState = matchingTool.getIntentState(intent, params, prevState && prevState[matchingTool.name], payload);
    const { _searchParams, ...toolState } = _toolState;
    const nextUrlState = { ...prevState, tool: matchingTool.name, [matchingTool.name]: toolState };
    if ((_a4 = matchingTool.router) == null ? void 0 : _a4.__unsafe_disableScopedSearchParams) {
      nextUrlState._searchParams = _searchParams;
    } else {
      toolState._searchParams = _searchParams;
    }
    return { type: "state", isNotFound: false, state: nextUrlState };
  }
  return { type: "intent", isNotFound: true, intent: { name: intent, params } };
}
function decodeUrlState(rootRouter, pathname) {
  return { type: "state", state: rootRouter.decode(pathname) || {}, isNotFound: rootRouter.isNotFound(pathname) };
}
function WorkspaceRouterProvider(_ref483) {
  let { children, LoadingComponent, workspace } = _ref483;
  const { basePath, tools } = workspace;
  const history2 = useRouterHistory();
  const router = (0, import_react51.useMemo)(() => createRouter({ basePath, tools }), [basePath, tools]);
  const [state, onNavigate] = useRouterFromWorkspaceHistory(history2, router, tools);
  if (!state)
    return (0, import_jsx_runtime6.jsx)(LoadingComponent, {});
  return (0, import_jsx_runtime6.jsx)(RouterProvider, { onNavigate, router, state, children });
}
function useRouterFromWorkspaceHistory(history2, router, tools) {
  var _a4;
  const store = (0, import_react51.useMemo)(() => {
    const routerBasePath = router.getBasePath();
    const routerBasePathRegex = new RegExp("^".concat((0, import_escapeRegExp.default)(routerBasePath), "(\\/|$)"), "i");
    const shouldHandle = (pathname) => (
      // this is necessary to prevent emissions intended for other workspaces.
      routerBasePath === "/" ? true : routerBasePathRegex.test(pathname)
    );
    return {
      subscribe: (onStoreChange) => history2.listen(onStoreChange),
      getSnapshot: () => "".concat(history2.location.pathname).concat(history2.location.search || ""),
      // Always return null for the server snapshot, as we can't know how to resolve intents until after authentication is done, which is browser-only
      getServerSnapshot: () => null,
      selector: (pathname) => typeof pathname === "string" && shouldHandle(pathname) ? decodeUrlState(router, pathname) : null
    };
  }, [history2, router]);
  const event = (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, store.getSnapshot, store.getServerSnapshot, store.selector, import_isEqual4.default);
  const prevEvent = (0, import_react51.useRef)(event);
  (0, import_react51.useEffect)(() => {
    var _a22;
    if ((event == null ? void 0 : event.type) === "state" && !((_a22 = event.state) == null ? void 0 : _a22.intent)) {
      const defaultState = resolveDefaultState(tools, event.state);
      if (defaultState && defaultState !== event.state) {
        history2.replace(router.encode(defaultState));
      }
    }
  }, [event == null ? void 0 : event.state, event == null ? void 0 : event.type, history2, router, tools]);
  (0, import_react51.useEffect)(() => {
    const resolvedIntent = maybeResolveIntent(event, router, tools, prevEvent);
    if (resolvedIntent) {
      history2.replace(resolvedIntent);
    } else {
      prevEvent.current = event;
    }
  }, [event, history2, router, tools]);
  const handleNavigate = (0, import_react51.useMemo)(() => {
    return (_ref484) => {
      let { path: path2, replace } = _ref484;
      const predictedEvent = store.selector(path2);
      const resolvedIntent = maybeResolveIntent(predictedEvent, router, tools, prevEvent);
      const resolvedPath = typeof resolvedIntent === "string" ? resolvedIntent : path2;
      if (replace) {
        history2.replace(resolvedPath);
      } else {
        history2.push(resolvedPath);
      }
    };
  }, [history2, router, store, tools]);
  return [(_a4 = event == null ? void 0 : event.state) != null ? _a4 : null, handleNavigate];
}
function maybeResolveIntent(event, router, tools, prevEvent) {
  var _a4, _b4;
  if ((event == null ? void 0 : event.type) === "state" && ((_a4 = event.state) == null ? void 0 : _a4.intent)) {
    const redirectState = resolveIntentState(tools, ((_b4 = prevEvent.current) == null ? void 0 : _b4.type) === "state" ? prevEvent.current.state : {}, event.state);
    if ((redirectState == null ? void 0 : redirectState.type) === "state") {
      return router.encode(redirectState.state);
    }
  }
  return null;
}
function WorkspaceLoader(_ref485) {
  let { children, LoadingComponent } = _ref485;
  const [error2, handleError] = (0, import_react51.useState)(null);
  if (error2)
    throw error2;
  const { activeWorkspace } = useActiveWorkspace();
  const [workspace, setWorkspace] = (0, import_react51.useState)(null);
  (0, import_react51.useEffect)(() => {
    const subscription = combineLatest(activeWorkspace.__internal.sources.map((_ref486) => {
      let { source } = _ref486;
      return source.pipe(catchError((err) => {
        if (err instanceof ConfigResolutionError)
          return of(err);
        throw err;
      }));
    })).pipe(map((results) => {
      const errors = results.filter((result) => result instanceof ConfigResolutionError);
      if (errors.length) {
        throw new ConfigResolutionError({ name: activeWorkspace.name, causes: errors, type: "workspace" });
      }
      return results;
    }), map((_ref487) => {
      let [rootSource, ...restOfSources] = _ref487;
      return { ...activeWorkspace, ...rootSource, unstable_sources: [rootSource, ...restOfSources], type: "workspace" };
    })).subscribe({ next: setWorkspace, error: handleError });
    return () => subscription.unsubscribe();
  }, [activeWorkspace]);
  if (!workspace)
    return (0, import_jsx_runtime6.jsx)(LoadingComponent, {});
  return (0, import_jsx_runtime6.jsx)(WorkspaceProvider, { workspace, children: (0, import_jsx_runtime6.jsx)(SourceProvider, { source: workspace.unstable_sources[0], children: (0, import_jsx_runtime6.jsx)(WorkspaceRouterProvider, { LoadingComponent, workspace, children }) }) });
}
function WorkspaceLoaderBoundary(_ref488) {
  let { ConfigErrorsComponent, ...props2 } = _ref488;
  const [{ error: error2 }, setError] = (0, import_react51.useState)({ error: null });
  if (error2)
    throw error2;
  return (0, import_jsx_runtime6.jsx)(ErrorBoundary, { onCatch: setError, children: (0, import_jsx_runtime6.jsx)(WorkspaceLoader, { ...props2 }) });
}
import_react_refractor2.default.registerLanguage(import_bash.default);
import_react_refractor2.default.registerLanguage(import_javascript.default);
import_react_refractor2.default.registerLanguage(import_json.default);
import_react_refractor2.default.registerLanguage(import_jsx.default);
import_react_refractor2.default.registerLanguage(import_typescript.default);
function StudioProvider(_ref489) {
  let { children, config, basePath, onSchemeChange, scheme, unstable_history: history2, unstable_noAuthBoundary: noAuthBoundary } = _ref489;
  const _children = (0, import_jsx_runtime6.jsx)(WorkspaceLoaderBoundary, { LoadingComponent: LoadingScreen, ConfigErrorsComponent: ConfigErrorsScreen, children: (0, import_jsx_runtime6.jsx)(LocaleProvider, { children: (0, import_jsx_runtime6.jsx)(ResourceCacheProvider, { children }) }) });
  return (0, import_jsx_runtime6.jsx)(ColorSchemeProvider, { onSchemeChange, scheme, children: (0, import_jsx_runtime6.jsxs)(ToastProvider, { paddingY: 7, zOffset: Z_OFFSET.toast, children: [(0, import_jsx_runtime6.jsx)(ErrorLogger, {}), (0, import_jsx_runtime6.jsx)(StudioErrorBoundary, { children: (0, import_jsx_runtime6.jsx)(WorkspacesProvider, { config, basePath, children: (0, import_jsx_runtime6.jsx)(ActiveWorkspaceMatcher, { unstable_history: history2, NotFoundComponent: NotFoundScreen, LoadingComponent: LoadingScreen, children: (0, import_jsx_runtime6.jsx)(StudioThemeProvider, { children: (0, import_jsx_runtime6.jsx)(UserColorManagerProvider, { children: noAuthBoundary ? _children : (0, import_jsx_runtime6.jsx)(AuthBoundary, { LoadingComponent: LoadingScreen, AuthenticateComponent: AuthenticateScreen, NotAuthenticatedComponent: NotAuthenticatedScreen, children: _children }) }) }) }) }) })] }) });
}
function NoToolsScreen() {
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Container, { width: 0, children: (0, import_jsx_runtime6.jsx)(Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, marginLeft: 3, space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { as: "h1", size: 1, weight: "bold", children: "No configured tools" }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: "Please configure a tool in your Studio configuration." }), (0, import_jsx_runtime6.jsx)(Text3, { as: "p", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)("a", { href: "https://www.sanity.io/docs/studio-tools", rel: "noreferrer", target: "_blank", children: "Learn how to add a tool " }) })] })] }) }) }) }) });
}
function RedirectingScreen(props2) {
  const { reason = "Redirecting" } = props2;
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Container, { width: 0, children: (0, import_jsx_runtime6.jsx)(Card, { padding: 4, radius: 2, shadow: 1, tone: "primary", children: (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(DoubleChevronRightIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Stack, { flex: 1, marginLeft: 3, space: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { as: "h1", size: 1, weight: "bold", children: reason }) })] }) }) }) }) });
}
function ToolNotFoundScreen(props2) {
  const { toolName } = props2;
  return (0, import_jsx_runtime6.jsx)(Card, { height: "fill", children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Container, { width: 0, children: (0, import_jsx_runtime6.jsx)(Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: (0, import_jsx_runtime6.jsxs)(Flex, { children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Stack, { flex: 1, marginLeft: 3, space: 3, children: (0, import_jsx_runtime6.jsxs)(Text3, { as: "h1", size: 1, weight: "bold", children: ["Tool not found: ", (0, import_jsx_runtime6.jsx)("code", { children: toolName })] }) })] }) }) }) }) });
}
function StudioLogo(props2) {
  const { title } = props2;
  return (0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { weight: "bold", children: title }) });
}
var __freeze$D2 = Object.freeze;
var __defProp$D2 = Object.defineProperty;
var __template$D2 = (cooked, raw) => __freeze$D2(__defProp$D2(cooked, "raw", { value: __freeze$D2(raw || cooked.slice()) }));
var _a$D2;
var Root$52 = st.div(_a$D2 || (_a$D2 = __template$D2(["\n  position: absolute;\n  width: 18px;\n  height: 18px;\n  background: var(--card-bg-color);\n  bottom: -4px;\n  right: -4px;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 1px solid var(--card-bg-color);\n  box-sizing: content-box;\n\n  svg {\n    box-sizing: content-box;\n    border: 1px solid var(--card-hairline-soft-color);\n    border-radius: 50%;\n    padding: 2px;\n    width: 12px;\n    height: 12px;\n  }\n\n  &[data-logo='github'] {\n    svg {\n      path {\n        fill: var(--card-fg-color);\n      }\n    }\n  }\n\n  &[data-logo='saml'] {\n    svg {\n      path {\n        fill: var(--card-fg-color);\n      }\n    }\n  }\n"])));
var Google = (0, import_jsx_runtime6.jsxs)("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime6.jsxs)("g", { clipPath: "url(#clip0)", children: [(0, import_jsx_runtime6.jsx)("path", { d: "M12 6.13764C12 5.72977 11.9663 5.31971 11.8943 4.91846H6.12036V7.22895H9.42684C9.28963 7.97412 8.84876 8.63332 8.20322 9.05221V10.5514H10.1759C11.3342 9.50637 12 7.9631 12 6.13764Z", fill: "#4285F4" }), (0, import_jsx_runtime6.jsx)("path", { d: "M6.12019 12.0002C7.77118 12.0002 9.16349 11.4688 10.1779 10.5517L8.20529 9.05253C7.65646 9.41851 6.94793 9.62574 6.12244 9.62574C4.52544 9.62574 3.17136 8.56971 2.68552 7.1499H0.649902V8.69537C1.68908 10.7215 3.80567 12.0002 6.12019 12.0002V12.0002Z", fill: "#34A853" }), (0, import_jsx_runtime6.jsx)("path", { d: "M2.68332 7.14986C2.4269 6.40469 2.4269 5.59778 2.68332 4.8526V3.30713H0.649951C-0.218278 5.00252 -0.218278 6.99995 0.649951 8.69533L2.68332 7.14986V7.14986Z", fill: "#FBBC04" }), (0, import_jsx_runtime6.jsx)("path", { d: "M6.12019 2.37483C6.99291 2.3616 7.8364 2.68348 8.46845 3.27433L10.2161 1.56131C9.1095 0.542752 7.64071 -0.017233 6.12019 0.000404333C3.80566 0.000404333 1.68908 1.27911 0.649902 3.3074L2.68326 4.85288C3.16686 3.43087 4.52319 2.37483 6.12019 2.37483V2.37483Z", fill: "#EA4335" })] }), (0, import_jsx_runtime6.jsx)("defs", { children: (0, import_jsx_runtime6.jsx)("clipPath", { id: "clip0", children: (0, import_jsx_runtime6.jsx)("rect", { width: "12", height: "12", fill: "white" }) }) })] });
var GitHub = (0, import_jsx_runtime6.jsxs)("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime6.jsx)("g", { clipPath: "url(#clip0)", children: (0, import_jsx_runtime6.jsx)("path", { d: "M11.195 3.13503C10.6711 2.22838 9.91808 1.47537 9.01144 0.951471C8.09222 0.414976 7.08837 0.146729 5.99987 0.146729C4.91137 0.146729 3.90752 0.414976 2.98831 0.951471C2.08163 1.47534 1.32862 2.22836 0.804744 3.13503C0.268248 4.05497 0 5.05883 0 6.14659C0 7.45399 0.381531 8.62978 1.14459 9.67394C1.90765 10.7181 2.89327 11.4408 4.10143 11.8419C4.24208 11.868 4.34624 11.8497 4.41392 11.7872C4.44666 11.7577 4.47263 11.7215 4.49006 11.681C4.50749 11.6405 4.51595 11.5967 4.51488 11.5527C4.51488 11.537 4.51361 11.3963 4.51105 11.1307C4.5085 10.8651 4.50722 10.6334 4.50722 10.4355L4.32745 10.4666C4.18407 10.4895 4.03885 10.4986 3.89375 10.494C3.71159 10.4908 3.53001 10.4725 3.35087 10.4393C3.16049 10.4045 2.98119 10.3246 2.82796 10.2064C2.66705 10.0846 2.54715 9.91661 2.48428 9.72484L2.40602 9.54506C2.34022 9.40286 2.25754 9.2691 2.15976 9.14666C2.04775 9.00072 1.93447 8.90176 1.81991 8.84977L1.76518 8.81064C1.72769 8.78356 1.6936 8.75205 1.66367 8.71679C1.63479 8.6841 1.61108 8.64719 1.59334 8.60734C1.57766 8.57085 1.5907 8.54085 1.63247 8.51731C1.67461 8.49405 1.75123 8.48256 1.86068 8.48256L2.01692 8.50582C2.12108 8.52662 2.24996 8.5891 2.40356 8.69326C2.5585 8.79876 2.68797 8.93748 2.78254 9.09932C2.90239 9.31294 3.04695 9.47575 3.21624 9.58775C3.38552 9.69976 3.55609 9.75576 3.72793 9.75576C3.87725 9.7578 4.02641 9.74479 4.17312 9.7169C4.29459 9.69195 4.41264 9.65254 4.52473 9.59952C4.57162 9.25037 4.69931 8.98212 4.90782 8.79477C4.63684 8.76849 4.36827 8.72157 4.10444 8.6544C3.84797 8.58382 3.60133 8.48141 3.37029 8.34958C3.12825 8.218 2.91442 8.04015 2.74095 7.82613C2.57421 7.6178 2.4374 7.34417 2.3305 7.00524C2.2236 6.6663 2.1707 6.27584 2.1718 5.83383C2.1718 5.20357 2.37757 4.66708 2.7891 4.22435C2.59629 3.75006 2.61453 3.21885 2.84383 2.63073C2.99487 2.58385 3.21879 2.61897 3.51559 2.73608C3.81239 2.85319 4.02983 2.95352 4.16792 3.03707C4.30601 3.12025 4.41665 3.19058 4.49983 3.24804C5.48153 2.9773 6.51821 2.9773 7.49991 3.24804L7.79679 3.0606C8.0249 2.92356 8.26549 2.80849 8.51535 2.71693C8.79135 2.61276 9.00231 2.58412 9.14825 2.63101C9.38248 3.21949 9.40327 3.7507 9.21064 4.22462C9.62199 4.66735 9.82776 5.20385 9.82795 5.83411C9.82795 6.27684 9.77459 6.66904 9.66787 7.01071C9.56116 7.35238 9.42325 7.62601 9.25415 7.8316C9.07785 8.04326 8.86311 8.21966 8.62124 8.35149C8.39008 8.48329 8.14337 8.5857 7.88682 8.65632C7.62412 8.72277 7.35674 8.76915 7.087 8.79505C7.35698 9.02927 7.49206 9.3994 7.49225 9.90543V11.5527C7.49115 11.5964 7.49929 11.6398 7.51612 11.6802C7.53295 11.7206 7.5581 11.7569 7.58993 11.7869C7.65505 11.8493 7.75794 11.8675 7.89858 11.8416C9.10693 11.4403 10.0926 10.7177 10.8557 9.67367C11.6188 8.62968 12.0003 7.4539 12.0003 6.14632C11.9997 5.05873 11.7313 4.05497 11.195 3.13503V3.13503Z", fill: "black" }) }), (0, import_jsx_runtime6.jsx)("defs", { children: (0, import_jsx_runtime6.jsx)("clipPath", { id: "clip0", children: (0, import_jsx_runtime6.jsx)("rect", { width: "12", height: "12", fill: "white" }) }) })] });
var Saml = (0, import_jsx_runtime6.jsxs)("svg", { width: "17", height: "9", viewBox: "0 0 17 9", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime6.jsx)("path", { d: "M0.0691681 5.98162C0.115833 7.24157 1.07247 8.00221 2.59841 8.00221C4.17102 8.00221 5.12299 7.19957 5.12299 5.86962C5.12299 4.83832 4.55367 4.25501 3.25172 3.96569L2.56108 3.80703C1.8331 3.64837 1.53445 3.38704 1.53445 2.91106C1.53445 2.40708 1.94977 2.09442 2.61708 2.09442C3.27505 2.09442 3.6997 2.43508 3.75103 2.99039H5.00166C4.95966 1.78643 4.01236 0.997795 2.60308 0.997795C1.14713 0.997795 0.218496 1.79577 0.218496 3.05105C0.218496 4.04968 0.815808 4.69366 2.03376 4.96898L2.73374 5.13231C3.51304 5.30497 3.8117 5.54763 3.8117 6.00495C3.8117 6.55093 3.34972 6.90092 2.62174 6.90092C1.85644 6.90092 1.38045 6.56493 1.31979 5.98162H0.0691681Z" }), (0, import_jsx_runtime6.jsx)("path", { d: "M5.97695 5.98162C6.02362 7.24157 6.98025 8.00221 8.5062 8.00221C10.0788 8.00221 11.0308 7.19957 11.0308 5.86962C11.0308 4.83832 10.4615 4.25501 9.15951 3.96569L8.46886 3.80703C7.74089 3.64837 7.44223 3.38704 7.44223 2.91106C7.44223 2.40708 7.85755 2.09442 8.52486 2.09442C9.18284 2.09442 9.60749 2.43508 9.65882 2.99039H10.9094C10.8674 1.78643 9.92015 0.997795 8.51086 0.997795C7.05492 0.997795 6.12628 1.79577 6.12628 3.05105C6.12628 4.04968 6.72359 4.69366 7.94155 4.96898L8.64153 5.13231C9.42083 5.30497 9.71949 5.54763 9.71949 6.00495C9.71949 6.55093 9.2575 6.90092 8.52953 6.90092C7.76422 6.90092 7.28824 6.56493 7.22758 5.98162H5.97695Z" }), (0, import_jsx_runtime6.jsx)("path", { d: "M16.9852 5.01565V3.98435C16.9852 2.11309 16.0099 0.997795 14.3953 0.997795C12.7807 0.997795 11.8054 2.11309 11.8054 3.98435V5.01565C11.8054 6.88692 12.7807 8.00221 14.3953 8.00221C16.0099 8.00221 16.9852 6.88692 16.9852 5.01565ZM14.3953 6.82625C13.5833 6.82625 13.154 6.21494 13.154 5.00165V3.99835C13.154 2.78506 13.5833 2.17375 14.3953 2.17375C15.2073 2.17375 15.6366 2.78506 15.6366 3.99835V5.00165C15.6366 6.21494 15.2073 6.82625 14.3953 6.82625Z" })] });
var LoginProviderLogo = (_ref490) => {
  let { provider } = _ref490;
  const isSaml = provider == null ? void 0 : provider.startsWith("saml-");
  const logoName = isSaml ? "saml" : provider;
  return (0, import_jsx_runtime6.jsxs)(Root$52, { "data-logo": logoName, children: [provider === "google" && Google, provider === "github" && GitHub, provider === "sanity" && (0, import_jsx_runtime6.jsx)(SanityMonogram, {}), isSaml && Saml] });
};
function LocaleMenu() {
  const { changeLocale, currentLocale, locales } = useLocale();
  const { t: t3 } = useTranslation2();
  if (!locales || locales.length < 2) {
    return null;
  }
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("user-menu.locale-title") }) }), locales.map((item) => (0, import_jsx_runtime6.jsx)(LocaleItem, { locale: item, changeLocale, selectedLocale: currentLocale }, item.id))] });
}
function LocaleItem(props2) {
  const { locale, changeLocale, selectedLocale: selectedLang } = props2;
  const localeId = locale.id;
  const onClick = (0, import_react51.useCallback)(() => changeLocale(localeId), [localeId, changeLocale]);
  return (0, import_jsx_runtime6.jsx)(MenuItem, { "aria-label": locale.title, pressed: selectedLang == localeId, onClick, text: locale.title });
}
var __freeze$C2 = Object.freeze;
var __defProp$C2 = Object.defineProperty;
var __template$C2 = (cooked, raw) => __freeze$C2(__defProp$C2(cooked, "raw", { value: __freeze$C2(raw || cooked.slice()) }));
var _a$C2;
var _b$k2;
var AVATAR_SIZE = 1;
var StyledMenu$2 = st(Menu)(_a$C2 || (_a$C2 = __template$C2(["\n  min-width: 200px;\n  max-width: 300px;\n"])));
var AvatarBox = st(Box)(_b$k2 || (_b$k2 = __template$C2(["\n  position: relative;\n  min-width: ", "px;\n  min-height: ", "px;\n"])), (_ref491) => {
  let { theme } = _ref491;
  return theme.sanity.avatar.sizes[AVATAR_SIZE].size;
}, (_ref492) => {
  let { theme } = _ref492;
  return theme.sanity.avatar.sizes[AVATAR_SIZE].size;
});
function AppearanceMenu$1(_ref493) {
  let { setScheme } = _ref493;
  const { t: t3 } = useTranslation2();
  const options = useColorSchemeOptions(setScheme, t3);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("user-menu.appearance-title") }) }), options.map((_ref494) => {
    let { icon, label, name, onSelect, selected, title } = _ref494;
    return (0, import_jsx_runtime6.jsx)(MenuItem, { "aria-label": label, icon, onClick: onSelect, pressed: selected, text: title, iconRight: selected && (0, import_jsx_runtime6.jsx)(CheckmarkIcon, {}) }, name);
  })] });
}
function UserMenu() {
  const { currentUser, projectId: projectId2, auth } = useWorkspace();
  const scheme = useColorSchemeValue();
  const setScheme = useColorSchemeSetValue();
  const isAdmin = Boolean(currentUser && userHasRole(currentUser, "administrator"));
  const providerTitle = getProviderTitle(currentUser == null ? void 0 : currentUser.provider);
  const { t: t3 } = useTranslation2();
  const popoverProps = (0, import_react51.useMemo)(() => ({ placement: "bottom-end", portal: true, preventOverflow: true, scheme, constrainSize: true }), [scheme]);
  return (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { mode: "bleed", padding: 0, paddingX: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 1, children: [(0, import_jsx_runtime6.jsx)(UserAvatar, { user: "me", size: 1 }), (0, import_jsx_runtime6.jsx)(Text3, { size: AVATAR_SIZE, muted: true, children: (0, import_jsx_runtime6.jsx)(ChevronDownIcon, {}) })] }) }), id: "user-menu", menu: (0, import_jsx_runtime6.jsxs)(StyledMenu$2, { children: [(0, import_jsx_runtime6.jsx)(Card, { padding: 2, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Tooltip, { disabled: !providerTitle, portal: true, content: providerTitle && (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("user-menu.login-provider", { providerTitle }) }) }), children: (0, import_jsx_runtime6.jsxs)(AvatarBox, { marginRight: 3, children: [(0, import_jsx_runtime6.jsx)(UserAvatar, { size: AVATAR_SIZE, user: "me" }), (currentUser == null ? void 0 : currentUser.provider) && (0, import_jsx_runtime6.jsx)(LoginProviderLogo, { provider: currentUser.provider })] }) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, flex: 1, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 2, weight: "medium", textOverflow: "ellipsis", children: currentUser == null ? void 0 : currentUser.name }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, textOverflow: "ellipsis", children: currentUser == null ? void 0 : currentUser.email })] })] }) }), setScheme && (0, import_jsx_runtime6.jsx)(AppearanceMenu$1, { setScheme }), (0, import_jsx_runtime6.jsx)(LocaleMenu, {}), (0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", "aria-label": t3("user-menu.action.manage-project-aria-label"), href: "https://sanity.io/manage/project/".concat(projectId2), target: "_blank", text: t3("user-menu.action.manage-project"), icon: CogIcon }), isAdmin && (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", "aria-label": t3("user-menu.action.invite-members-aria-label"), href: "https://sanity.io/manage/project/".concat(projectId2, "/members"), target: "_blank", text: t3("user-menu.action.invite-members"), icon: UsersIcon }), auth.logout && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(MenuItem, { iconRight: LeaveIcon, text: t3("user-menu.action.sign-out"), disabled: !auth.logout, ...auth.logout && { onClick: auth.logout } })] })] }), popover: popoverProps });
}
var __freeze$B2 = Object.freeze;
var __defProp$B2 = Object.defineProperty;
var __template$B2 = (cooked, raw) => __freeze$B2(__defProp$B2(cooked, "raw", { value: __freeze$B2(raw || cooked.slice()) }));
var _a$B2;
var TooltipContentBox$1 = st(Box)(_a$B2 || (_a$B2 = __template$B2(["\n  max-width: 300px;\n"])));
var INLINE_PREVIEW_HEIGHT = 33;
function NewDocumentListOption(props2) {
  const { option, currentUser, onClick, preview } = props2;
  useTranslation2();
  const params = (0, import_react51.useMemo)(() => ({ template: option.templateId, type: option.schemaType }), [option.schemaType, option.templateId]);
  const { onClick: onIntentClick, href } = useIntentLink({ intent: "create", params });
  const handleDocumentClick = (0, import_react51.useCallback)((event) => {
    onIntentClick(event);
    onClick(option);
  }, [onIntentClick, onClick, option]);
  return (0, import_jsx_runtime6.jsx)(Tooltip, { disabled: option.hasPermission, portal: true, content: (0, import_jsx_runtime6.jsx)(TooltipContentBox$1, { padding: 2, children: (0, import_jsx_runtime6.jsx)(InsufficientPermissionsMessage, { currentUser, context: "create-document" }) }), children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Card, { as: option.hasPermission ? "a" : "button", disabled: !option.hasPermission, href, marginBottom: 1, onClick: handleDocumentClick, padding: preview === "inline" ? 3 : 4, radius: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: preview === "inline" ? 1 : void 0, children: option.title }) }) }) }, option.id);
}
var __freeze$A2 = Object.freeze;
var __defProp$A2 = Object.defineProperty;
var __template$A2 = (cooked, raw) => __freeze$A2(__defProp$A2(cooked, "raw", { value: __freeze$A2(raw || cooked.slice()) }));
var _a$A2;
var _b$j2;
var ContentFlex = st(Flex)(_a$A2 || (_a$A2 = __template$A2(["\n  min-height: 100px;\n"])));
st.strong(_b$j2 || (_b$j2 = __template$A2(["\n  word-break: break-all;\n"])));
function NewDocumentList(props2) {
  const { currentUser, loading, onDocumentClick, options, preview, searchQuery, textInputElement } = props2;
  const { t: t3 } = useTranslation2();
  const hasOptions = options.length > 0 && !loading;
  const handleDocumentClick = (0, import_react51.useCallback)(() => {
    onDocumentClick();
  }, [onDocumentClick]);
  const getItemDisabled = (0, import_react51.useCallback)((index) => {
    var _a22;
    return ((_a22 = options[index]) == null ? void 0 : _a22.hasPermission) === false;
  }, [options]);
  const renderItem = (0, import_react51.useCallback)((item) => {
    return (0, import_jsx_runtime6.jsx)(NewDocumentListOption, { currentUser, onClick: handleDocumentClick, option: item, preview }, item.id);
  }, [currentUser, handleDocumentClick, preview]);
  if (loading) {
    return (0, import_jsx_runtime6.jsx)(ContentFlex, { align: "center", flex: 1, height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime6.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Spinner, { muted: true, size: 1 }), (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: t3("new-document.loading") })] }) });
  }
  if (!hasOptions && searchQuery) {
    return (0, import_jsx_runtime6.jsx)(ContentFlex, { align: "center", flex: 1, height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "new-document.no-results", values: { searchQuery } }) }) });
  }
  if (!hasOptions) {
    return (0, import_jsx_runtime6.jsx)(ContentFlex, { align: "center", flex: 1, height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: t3("new-document.no-document-types-found") }) });
  }
  return (0, import_jsx_runtime6.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t3("new-document.new-document"), autoFocus: supportsTouch ? void 0 : "input", getItemDisabled, inputElement: textInputElement, itemHeight: INLINE_PREVIEW_HEIGHT, items: options, overscan: 5, padding: preview === "inline" ? 1 : 2, paddingBottom: 0, renderItem });
}
function isQueryMatch(query, option) {
  const lowercaseTitle = option.title.toLowerCase();
  const lowercaseQuery = query.trim().toLowerCase();
  const words2 = lowercaseQuery.split(/[\s\-_]+/);
  return words2.every((word) => lowercaseTitle.includes(word));
}
function sortResultRelevance(query, a, b) {
  const titleA = a.title.toLowerCase();
  const titleB = b.title.toLowerCase();
  const lowercaseQuery = query.trim().toLowerCase();
  if (titleA.startsWith(lowercaseQuery) && !titleB.startsWith(lowercaseQuery)) {
    return -1;
  }
  if (titleB.startsWith(lowercaseQuery) && !titleA.startsWith(lowercaseQuery)) {
    return 1;
  }
  if (titleA.includes(lowercaseQuery) && !titleB.includes(lowercaseQuery)) {
    return -1;
  }
  if (titleB.includes(lowercaseQuery) && !titleA.includes(lowercaseQuery)) {
    return 1;
  }
  return 0;
}
function filterOptions(options, query) {
  const optionsWithTitle = options.map((option) => ({ ...option, title: (option == null ? void 0 : option.title) || option.id }));
  const alphabetized = optionsWithTitle.sort((a, b) => a.title.localeCompare(b.title));
  return alphabetized.filter((option) => isQueryMatch(query, option)).sort((a, b) => sortResultRelevance(query, a, b));
}
var __freeze$z2 = Object.freeze;
var __defProp$z2 = Object.defineProperty;
var __template$z2 = (cooked, raw) => __freeze$z2(__defProp$z2(cooked, "raw", { value: __freeze$z2(raw || cooked.slice()) }));
var _a$z2;
var _b$i2;
var _c$f;
var _d$7;
var _e$22;
var _f$12;
var _g$1;
var StyledPopover = st(Popover)(() => {
  return nt(_a$z2 || (_a$z2 = __template$z2(["\n    [data-ui='Popover__wrapper'] {\n      width: 320px;\n      display: flex;\n      flex-direction: column;\n      border-radius: ", "px;\n      position: relative;\n      overflow: hidden;\n      overflow: clip;\n    }\n  "])), (_ref495) => {
    let { theme } = _ref495;
    return theme.sanity.radius[3];
  });
});
var StyledDialog = st(Dialog)(() => {
  return nt(_b$i2 || (_b$i2 = __template$z2(["\n    [data-ui='DialogCard'] {\n      justify-content: flex-start;\n    }\n  "])));
});
var TooltipContentBox = st(Box)(_c$f || (_c$f = __template$z2(["\n  max-width: 300px;\n"])));
var RootFlex$1 = st(Flex)(_d$7 || (_d$7 = __template$z2([""])));
var PopoverHeaderCard = st(Card)(_e$22 || (_e$22 = __template$z2(["\n  min-height: max-content;\n"])));
var DialogHeaderCard = st(Card)(_f$12 || (_f$12 = __template$z2(["\n  min-height: max-content;\n"])));
var PopoverListFlex = st(Flex)((props2) => {
  const { $maxDisplayedItems, $itemHeight } = props2;
  return nt(_g$1 || (_g$1 = __template$z2(["\n    --item-height: ", "px;\n    --max-items: ", ";\n    --list-padding: 0.5rem;\n\n    position: relative;\n    max-height: calc(var(--item-height) * var(--max-items) + var(--list-padding));\n    min-height: calc((var(--item-height) * 1));\n  "])), $itemHeight, $maxDisplayedItems);
});
var MAX_DISPLAYED_ITEMS = 10;
function NewDocumentButton(props2) {
  const { canCreateDocument, modal = "popover", loading, options } = props2;
  const [open, setOpen] = (0, import_react51.useState)(false);
  const [searchQuery, setSearchQuery] = (0, import_react51.useState)("");
  const [popoverElement, setPopoverElement] = (0, import_react51.useState)(null);
  const [dialogElement, setDialogElement] = (0, import_react51.useState)(null);
  const [buttonElement, setButtonElement] = (0, import_react51.useState)(null);
  const [searchInputElement, setSearchInputElement] = (0, import_react51.useState)(null);
  const { t: t3 } = useTranslation2();
  const { scheme } = useColorScheme();
  const currentUser = useCurrentUser();
  const hasNewDocumentOptions = options.length > 0;
  const disabled = !canCreateDocument || !hasNewDocumentOptions;
  const placeholder = t3("new-document.filter-placeholder");
  const title = t3("new-document.title");
  const openDialogAriaLabel = t3("new-document.open-dialog-aria-label");
  const filteredOptions = (0, import_react51.useMemo)(() => filterOptions(options, searchQuery), [options, searchQuery]);
  const handleSearchChange = (0, import_react51.useCallback)((event) => {
    setSearchQuery(event.currentTarget.value);
  }, []);
  const handleToggleOpen = (0, import_react51.useCallback)(() => setOpen((v) => !v), []);
  const handleClose = (0, import_react51.useCallback)(() => {
    setOpen(false);
    setSearchQuery("");
    buttonElement == null ? void 0 : buttonElement.focus();
  }, [buttonElement]);
  const handleOpenButtonKeyDown = (0, import_react51.useCallback)((e2) => {
    if (e2.key === "ArrowDown" && !open) {
      setOpen(true);
    }
  }, [open]);
  const handlePopoverKeyDown = (0, import_react51.useCallback)((e2) => {
    if ((e2.key === "Escape" || e2.key === "Tab") && open) {
      handleClose();
    }
  }, [handleClose, open]);
  useClickOutside(() => {
    if (open) {
      handleClose();
    }
  }, [buttonElement, dialogElement, popoverElement]);
  const sharedListProps = (0, import_react51.useMemo)(() => ({ currentUser, loading, onDocumentClick: handleToggleOpen, options: filteredOptions, searchQuery, preview: modal === "popover" ? "inline" : "default", textInputElement: searchInputElement }), [currentUser, filteredOptions, handleToggleOpen, loading, modal, searchInputElement, searchQuery]);
  const sharedTextInputProps = (0, import_react51.useMemo)(() => ({ border: false, defaultValue: searchQuery, disabled: loading, icon: SearchIcon, onChange: handleSearchChange, placeholder, ref: setSearchInputElement }), [handleSearchChange, loading, placeholder, searchQuery]);
  const sharedOpenButtonProps = (0, import_react51.useMemo)(() => ({ "aria-label": openDialogAriaLabel, disabled: disabled || loading, icon: AddIcon, mode: "bleed", onClick: handleToggleOpen, ref: setButtonElement, selected: open }), [disabled, handleToggleOpen, loading, open, openDialogAriaLabel]);
  const tooltipContent = (0, import_react51.useMemo)(() => {
    if (!hasNewDocumentOptions) {
      return (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("new-document.no-document-types-label") });
    }
    if (canCreateDocument) {
      return (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("new-document.create-new-document-label") });
    }
    return (0, import_jsx_runtime6.jsx)(InsufficientPermissionsMessage, { currentUser, context: "create-any-document" });
  }, [canCreateDocument, currentUser, hasNewDocumentOptions, t3]);
  const sharedTooltipProps = (0, import_react51.useMemo)(() => ({ content: (0, import_jsx_runtime6.jsx)(TooltipContentBox, { padding: 2, children: tooltipContent }), disabled: loading || open, placement: "bottom", portal: true, scheme }), [loading, open, scheme, tooltipContent]);
  if (modal === "dialog") {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Tooltip, { ...sharedTooltipProps, children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Button, { ...sharedOpenButtonProps }) }) }), open && (0, import_jsx_runtime6.jsx)(StyledDialog, { header: title, id: "create-new-document-dialog", onClickOutside: handleClose, onClose: handleClose, ref: setDialogElement, scheme, width: 1, children: (0, import_jsx_runtime6.jsxs)(RootFlex$1, { direction: "column", flex: 1, height: "fill", children: [(0, import_jsx_runtime6.jsx)(DialogHeaderCard, { padding: 2, borderBottom: true, children: (0, import_jsx_runtime6.jsx)(TextInput, { ...sharedTextInputProps }) }), (0, import_jsx_runtime6.jsx)(Flex, { direction: "column", overflow: "hidden", children: (0, import_jsx_runtime6.jsx)(NewDocumentList, { ...sharedListProps }) })] }) })] });
  }
  return (0, import_jsx_runtime6.jsx)(StyledPopover, { constrainSize: true, onKeyDown: handlePopoverKeyDown, open, portal: true, radius: 3, ref: setPopoverElement, scheme, content: (0, import_jsx_runtime6.jsxs)(RootFlex$1, { direction: "column", flex: 1, forwardedAs: es2015_default, height: "fill", returnFocus: true, children: [(0, import_jsx_runtime6.jsx)(PopoverHeaderCard, { sizing: "border", children: (0, import_jsx_runtime6.jsxs)(Stack, { children: [(0, import_jsx_runtime6.jsx)(Box, { paddingX: 3, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: title }) }) }), (0, import_jsx_runtime6.jsx)(Card, { borderTop: true, borderBottom: true, padding: 1, children: (0, import_jsx_runtime6.jsx)(TextInput, { ...sharedTextInputProps, fontSize: 1, radius: 1 }) })] }) }), (0, import_jsx_runtime6.jsx)(PopoverListFlex, { $itemHeight: INLINE_PREVIEW_HEIGHT, $maxDisplayedItems: MAX_DISPLAYED_ITEMS, direction: "column", overflow: "hidden", children: (0, import_jsx_runtime6.jsx)(NewDocumentList, { ...sharedListProps }) })] }), children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Tooltip, { ...sharedTooltipProps, children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Button, { ...sharedOpenButtonProps, "aria-expanded": open, "aria-haspopup": "true", onKeyDown: handleOpenButtonKeyDown }) }) }) }) });
}
function useNewDocumentOptions() {
  const { __internal: { staticInitialValueTemplateItems } } = useSource();
  const [permissions, loading] = useTemplatePermissions({ templateItems: staticInitialValueTemplateItems });
  const canCreateDocument = (permissions == null ? void 0 : permissions.some((p) => staticInitialValueTemplateItems.some((t3) => t3.id === p.id))) || false;
  const optionsWithPermissions = (0, import_react51.useMemo)(() => {
    return staticInitialValueTemplateItems.map((item) => {
      var _a4;
      return { ...item, title: (item == null ? void 0 : item.title) || item.id, hasPermission: ((_a4 = permissions == null ? void 0 : permissions.find((p) => p.id === item.id)) == null ? void 0 : _a4.granted) || false };
    });
  }, [permissions, staticInitialValueTemplateItems]);
  return { canCreateDocument, loading, options: optionsWithPermissions };
}
var __freeze$y2 = Object.freeze;
var __defProp$y2 = Object.defineProperty;
var __template$y2 = (cooked, raw) => __freeze$y2(__defProp$y2(cooked, "raw", { value: __freeze$y2(raw || cooked.slice()) }));
var _a$y2;
var AvatarCard = st(Card)(_a$y2 || (_a$y2 = __template$y2(["\n  background: transparent;\n  margin: calc((-35px + 11px) / 2);\n"])));
var PresenceMenuItem = (0, import_react51.memo)(function PresenceMenuItem2(props2) {
  const { presence, focused, onFocus } = props2;
  const [menuItemElement, setMenuItemElement] = (0, import_react51.useState)(null);
  const { t: t3 } = useTranslation2();
  const lastActiveLocation = (0, import_orderBy.default)(presence.locations || [], ["lastActiveAt"], ["desc"]).find((location) => location.documentId);
  const hasLink = Boolean(lastActiveLocation == null ? void 0 : lastActiveLocation.documentId);
  (0, import_react51.useEffect)(() => {
    if (focused && menuItemElement) {
      menuItemElement.focus();
      menuItemElement.setAttribute("data-selected", "");
    }
    if (!focused) {
      menuItemElement == null ? void 0 : menuItemElement.removeAttribute("data-selected");
    }
  }, [menuItemElement, focused]);
  const handleFocus = (0, import_react51.useCallback)(() => {
    onFocus(presence.user.id);
  }, [onFocus, presence.user.id]);
  const LinkComponent = (0, import_react51.useMemo)(() => (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (0, import_react51.forwardRef)(function LinkComponent2(linkProps, ref) {
      if (!(lastActiveLocation == null ? void 0 : lastActiveLocation.path))
        return null;
      return (0, import_jsx_runtime6.jsx)(IntentLink, { ...linkProps, intent: "edit", params: { id: lastActiveLocation == null ? void 0 : lastActiveLocation.documentId, path: toString(lastActiveLocation == null ? void 0 : lastActiveLocation.path) }, ref });
    })
  ), [lastActiveLocation]);
  return (0, import_jsx_runtime6.jsx)(MenuItem, { as: lastActiveLocation ? LinkComponent : "div", "data-as": lastActiveLocation ? "a" : "div", onFocus: handleFocus, paddingY: hasLink ? 4 : 3, paddingLeft: 4, paddingRight: 3, ref: setMenuItemElement, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(AvatarCard, { children: (0, import_jsx_runtime6.jsx)(UserAvatar, { size: 1, user: presence.user, status: hasLink ? "editing" : "inactive" }, presence.user.id) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, marginLeft: 4, children: [(0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", children: presence.user.displayName }), !hasLink && (0, import_jsx_runtime6.jsx)(Text3, { size: 0, muted: true, textOverflow: "ellipsis", children: t3("presence.not-in-a-document") })] })] }) });
});
var __freeze$x2 = Object.freeze;
var __defProp$x2 = Object.defineProperty;
var __template$x2 = (cooked, raw) => __freeze$x2(__defProp$x2(cooked, "raw", { value: __freeze$x2(raw || cooked.slice()) }));
var _a$x2;
var _b$h2;
var _c$e;
var MAX_AVATARS = 4;
var AvatarStackCard = st(Card)(_a$x2 || (_a$x2 = __template$x2(["\n  background: transparent;\n"])));
var StyledMenu$1 = st(Menu)(_b$h2 || (_b$h2 = __template$x2(["\n  max-width: 350px;\n  min-width: 250px;\n"])));
var FooterStack = st(Stack)(_c$e || (_c$e = __template$x2(["\n  position: sticky;\n  bottom: 0;\n  background-color: var(--card-bg-color);\n"])));
function PresenceMenu(props2) {
  const { collapse } = props2;
  const presence = useGlobalPresence();
  const { projectId: projectId2 } = useWorkspace();
  const { scheme } = useColorScheme();
  const { t: t3 } = useTranslation2();
  const hasPresence = presence.length > 0;
  const [focusedId, setFocusedId] = (0, import_react51.useState)();
  const handleItemFocus = (0, import_react51.useCallback)((id4) => {
    setFocusedId(id4);
  }, []);
  const handleClearFocusedItem = (0, import_react51.useCallback)(() => {
    setFocusedId("");
  }, []);
  const button = (0, import_react51.useMemo)(() => {
    if (collapse) {
      return (0, import_jsx_runtime6.jsx)(StatusButton, { icon: UsersIcon, mode: "bleed", tone: hasPresence ? "positive" : void 0 });
    }
    return (0, import_jsx_runtime6.jsx)(Button, { mode: "bleed", padding: 1, children: (0, import_jsx_runtime6.jsx)(AvatarStackCard, { children: (0, import_jsx_runtime6.jsx)(AvatarStack, { maxLength: MAX_AVATARS, "aria-label": t3("presence.aria-label"), children: presence.map((item) => (0, import_jsx_runtime6.jsx)(UserAvatar, { user: item.user }, item.user.id)) }) }) });
  }, [collapse, hasPresence, presence, t3]);
  const popoverProps = (0, import_react51.useMemo)(() => ({ constrainSize: true, fallbackPlacements: ["bottom"], placement: "bottom", portal: true, scheme }), [scheme]);
  return (0, import_jsx_runtime6.jsx)(MenuButton, { button, id: "global-presence-menu", onClose: handleClearFocusedItem, menu: (0, import_jsx_runtime6.jsxs)(StyledMenu$1, { padding: 1, paddingBottom: 0, children: [hasPresence && (0, import_jsx_runtime6.jsx)(Stack, { children: presence.map((item) => (0, import_jsx_runtime6.jsx)(PresenceMenuItem, { focused: focusedId === item.user.id, onFocus: handleItemFocus, presence: item }, item.user.id)) }), !hasPresence && (0, import_jsx_runtime6.jsx)(Box, { paddingX: 3, paddingY: 4, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", size: 2, children: t3("presence.no-one-else-title") }), (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, children: t3("presence.no-one-else-description") })] }) }), (0, import_jsx_runtime6.jsxs)(FooterStack, { space: 1, paddingBottom: 1, children: [(0, import_jsx_runtime6.jsx)(MenuDivider, {}), (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", href: "https://sanity.io/manage/project/".concat(projectId2), iconRight: CogIcon, onFocus: handleClearFocusedItem, paddingY: 4, rel: "noopener noreferrer", target: "_blank", text: t3("presence.action.manage-members") })] })] }), popover: popoverProps });
}
var __freeze$w2 = Object.freeze;
var __defProp$w2 = Object.defineProperty;
var __template$w2 = (cooked, raw) => __freeze$w2(__defProp$w2(cooked, "raw", { value: __freeze$w2(raw || cooked.slice()) }));
var _a$w2;
var _b$g2;
var _c$d2;
var ANIMATION_TRANSITION = { duration: 0.2 };
var BACKDROP_VARIANTS = { open: { opacity: 1 }, closed: { opacity: 0 } };
var INNER_CARD_VARIANTS = { open: { x: "0%" }, closed: { x: "-100%" } };
var Root$42 = st(Layer)(_a$w2 || (_a$w2 = __template$w2(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n"])));
var BackdropMotion = st(motion(Card))(_b$g2 || (_b$g2 = __template$w2(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: var(--card-shadow-penumbra-color);\n"])));
var InnerCardMotion = st(motion(Card))(_c$d2 || (_c$d2 = __template$w2(["\n  position: relative;\n  pointer-events: all;\n  flex-direction: column;\n  height: 100%;\n  min-width: 200px;\n  max-width: 280px;\n  overflow: auto;\n"])));
function AppearanceMenu(_ref496) {
  let { setScheme } = _ref496;
  const { t: t3 } = useTranslation2();
  const options = useColorSchemeOptions(setScheme, t3);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (0, import_jsx_runtime6.jsxs)(Card, { borderTop: true, flex: "none", padding: 3, overflow: "auto", children: [(0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Label, { size: 1, muted: true, children: t3("user-menu.appearance-title") }) }), (0, import_jsx_runtime6.jsx)(Stack, { as: "ul", marginTop: 1, space: 1, children: options.map((_ref497) => {
    let { icon, label, name, onSelect, selected, title } = _ref497;
    return (0, import_jsx_runtime6.jsx)(Stack, { as: "li", children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": label, icon, iconRight: selected && (0, import_jsx_runtime6.jsx)(CheckmarkIcon, {}), justify: "flex-start", mode: "bleed", onClick: onSelect, selected, text: title }) }, name);
  }) })] }) });
}
var NavDrawer = (0, import_react51.memo)(function NavDrawer2(props2) {
  const { activeToolName, isOpen, onClose, tools } = props2;
  const setScheme = useColorSchemeSetValue();
  const { auth, currentUser, projectId: projectId2 } = useWorkspace();
  const workspaces = useWorkspaces();
  const ToolMenu = useToolMenuComponent();
  const isAdmin = Boolean(currentUser && userHasRole(currentUser, "administrator"));
  const { t: t3 } = useTranslation2();
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    if (event.key === "Escape") {
      onClose();
    }
  }, [onClose]);
  return (0, import_jsx_runtime6.jsx)(AnimatePresence, { children: isOpen && (0, import_jsx_runtime6.jsx)(es2015_default, { autoFocus: true, returnFocus: true, children: (0, import_jsx_runtime6.jsxs)(Root$42, { onKeyDown: handleKeyDown, children: [(0, import_jsx_runtime6.jsx)(BackdropMotion, { animate: "open", "data-open": isOpen, exit: "closed", initial: "closed", onClick: onClose, transition: ANIMATION_TRANSITION, variants: BACKDROP_VARIANTS }), (0, import_jsx_runtime6.jsxs)(InnerCardMotion, { animate: "open", "data-open": isOpen, display: "flex", exit: "closed", height: "fill", initial: "closed", shadow: 1, transition: ANIMATION_TRANSITION, variants: INNER_CARD_VARIANTS, children: [(0, import_jsx_runtime6.jsx)(Card, { borderBottom: true, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, padding: 3, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(Flex, { flex: 1, align: "center", paddingRight: 2, children: (0, import_jsx_runtime6.jsxs)(Flex, { flex: 1, align: "center", children: [(0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(UserAvatar, { size: 1, user: "me" }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, marginLeft: 2, title: (currentUser == null ? void 0 : currentUser.name) || (currentUser == null ? void 0 : currentUser.email), children: (0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", children: (currentUser == null ? void 0 : currentUser.name) || (currentUser == null ? void 0 : currentUser.email) }) })] }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(Button, { icon: CloseIcon, mode: "bleed", onClick: onClose, title: t3("user-menu.close-menu") }) })] }), workspaces.length > 1 && (0, import_jsx_runtime6.jsx)(WorkspaceMenuButton, {})] }) }), (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", flex: 1, justify: "space-between", overflow: "auto", children: [(0, import_jsx_runtime6.jsx)(Card, { flex: "none", padding: 3, children: (0, import_jsx_runtime6.jsx)(ToolMenu, { activeToolName, closeSidebar: onClose, context: "sidebar", isSidebarOpen: isOpen, tools }) }), (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", children: [setScheme && (0, import_jsx_runtime6.jsx)(AppearanceMenu, { setScheme }), (0, import_jsx_runtime6.jsx)(Card, { borderTop: true, flex: "none", padding: 3, children: (0, import_jsx_runtime6.jsxs)(Stack, { as: "ul", space: 1, children: [(0, import_jsx_runtime6.jsx)(Stack, { as: "li", children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("user-menu.action.manage-project-aria-label"), as: "a", href: "https://sanity.io/manage/project/".concat(projectId2), icon: CogIcon, justify: "flex-start", mode: "bleed", target: "_blank", text: t3("user-menu.action.manage-project") }) }), isAdmin && (0, import_jsx_runtime6.jsx)(Stack, { as: "li", children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("user-menu.action.invite-members-aria-label"), as: "a", href: "https://sanity.io/manage/project/".concat(projectId2, "/members"), icon: UsersIcon, justify: "flex-start", mode: "bleed", target: "_blank", text: t3("user-menu.action.invite-members") }) })] }) })] })] }), auth.logout && (0, import_jsx_runtime6.jsx)(Card, { flex: "none", padding: 3, borderTop: true, children: (0, import_jsx_runtime6.jsx)(Stack, { children: (0, import_jsx_runtime6.jsx)(Button, { iconRight: LeaveIcon, justify: "flex-start", mode: "bleed", onClick: auth.logout, text: t3("user-menu.action.sign-out") }) }) })] })] }) }) });
});
function ConfigIssuesButton() {
  var _a4;
  const schema = useSchema();
  const groupsWithWarnings = ((_a4 = schema._validation) == null ? void 0 : _a4.filter((group2) => group2.problems.some((problem) => problem.severity === "warning"))) || [];
  const { scheme } = useColorScheme();
  useTranslation2();
  const dialogId = (0, import_react51.useId)();
  const [isDialogOpen, setDialogOpen] = (0, import_react51.useState)(false);
  const [buttonElement, setButtonElement] = (0, import_react51.useState)(null);
  const handleOpen = (0, import_react51.useCallback)(() => setDialogOpen(true), []);
  const handleClose = (0, import_react51.useCallback)(() => {
    setDialogOpen(false);
    if (buttonElement) {
      buttonElement.focus();
    }
  }, [buttonElement]);
  if (groupsWithWarnings.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(StatusButton, { icon: WarningOutlineIcon, label: "Found configuration issues", mode: "bleed", onClick: handleOpen, ref: setButtonElement, selected: isDialogOpen, tone: "caution", tooltip: { scheme } }), isDialogOpen && (0, import_jsx_runtime6.jsx)(Dialog, { header: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { weight: "semibold", children: "Configuration issues" }), (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: "Configuration checks are only performed during development and will not be visible in production builds" })] }), width: 2, onClickOutside: handleClose, onClose: handleClose, scheme, id: dialogId, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, padding: 4, children: [(0, import_jsx_runtime6.jsxs)(Heading, { as: "h2", size: 1, children: ["Found ", groupsWithWarnings.length, " schema warnings"] }), (0, import_jsx_runtime6.jsx)(SchemaProblemGroups, { problemGroups: groupsWithWarnings })] }) })] });
}
function LogoButton(props2) {
  const { title, children, href, onClick } = props2;
  return (0, import_jsx_runtime6.jsx)(Button, { "aria-label": title, as: "a", "data-testid": "logo", href, mode: "bleed", onClick, padding: 0, children });
}
var isSearchHotKey = (0, import_is_hotkey2.default)("mod+".concat(GLOBAL_SEARCH_KEY));
var isEscape$1 = (0, import_is_hotkey2.default)("escape");
function useSearchHotkeys(_ref498) {
  let { open, onClose, onOpen } = _ref498;
  const { isTopLayer } = useLayer();
  const handleClose = (0, import_react51.useCallback)(() => {
    onClose == null ? void 0 : onClose();
  }, [onClose]);
  const handleGlobalKeyDown = (0, import_react51.useCallback)((event) => {
    if (isSearchHotKey(event)) {
      event.preventDefault();
      if (open) {
        handleClose();
      } else {
        onOpen == null ? void 0 : onOpen();
      }
    }
    if (isEscape$1(event) && open && isTopLayer) {
      handleClose();
    }
  }, [handleClose, isTopLayer, open, onOpen]);
  useGlobalKeyDown(handleGlobalKeyDown);
}
function SearchWrapper(_ref499) {
  let { children, hasValidTerms, onClose, onOpen, open } = _ref499;
  const isMountedRef = (0, import_react51.useRef)(false);
  const { dispatch, searchCommandList, setOnClose, state: { result } } = useSearchState();
  const handleClose = (0, import_react51.useCallback)(() => {
    var _a4;
    dispatch({ index: (_a4 = searchCommandList == null ? void 0 : searchCommandList.getTopIndex()) != null ? _a4 : -1, type: "LAST_ACTIVE_INDEX_SET" });
    onClose();
  }, [dispatch, onClose, searchCommandList]);
  useSearchHotkeys({ onClose: handleClose, onOpen, open });
  (0, import_react51.useEffect)(() => {
    setOnClose(handleClose);
  }, [handleClose, setOnClose]);
  (0, import_react51.useEffect)(() => {
    if ((!hasValidTerms || result.loaded) && isMountedRef.current) {
      dispatch({ index: 0, type: "LAST_ACTIVE_INDEX_SET" });
    }
  }, [dispatch, hasValidTerms, result.loaded]);
  (0, import_react51.useEffect)(() => {
    if (!hasValidTerms && isMountedRef.current && !open) {
      dispatch({ type: "ORDERING_RESET" });
    }
  }, [dispatch, hasValidTerms, open]);
  (0, import_react51.useEffect)(() => {
    if (!(isMountedRef == null ? void 0 : isMountedRef.current)) {
      isMountedRef.current = true;
    }
  }, []);
  if (!open) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)("div", { children });
}
function createOperatorDefinitionDictionary(operatorDefinitions2) {
  return operatorDefinitions2.reduce((acc, val) => {
    acc[val.type] = val;
    return acc;
  }, {});
}
function getOperatorDefinition(operators2, operatorType) {
  return operatorType ? operators2[operatorType] : void 0;
}
function getOperatorInitialValue(operators2, operatorType) {
  var _a4;
  return (_a4 = getOperatorDefinition(operators2, operatorType)) == null ? void 0 : _a4.initialValue;
}
function buildSearchFilter(filterDefinition, fieldId) {
  var _a4;
  return { fieldId, filterName: filterDefinition.name, operatorType: ((_a4 = filterDefinition == null ? void 0 : filterDefinition.operators.find((operator) => {
    return operator.type === "item";
  })) == null ? void 0 : _a4.name) || "" };
}
function generateFilterQuery(_ref500) {
  let { fieldDefinitions, filterDefinitions: filterDefinitions2, filters, operatorDefinitions: operatorDefinitions2 } = _ref500;
  return filters.filter((filter3) => validateFilter({ filter: filter3, filterDefinitions: filterDefinitions2, fieldDefinitions, operatorDefinitions: operatorDefinitions2 })).map((filter3) => {
    var _a4;
    return (_a4 = getOperatorDefinition(operatorDefinitions2, filter3.operatorType)) == null ? void 0 : _a4.groqFilter({ fieldPath: resolveFieldPath({ filter: filter3, fieldDefinitions, filterDefinitions: filterDefinitions2 }), value: filter3 == null ? void 0 : filter3.value });
  }).filter((filter3) => !(0, import_isEmpty.default)(filter3)).filter(isNonNullable$3).join(" && ");
}
function getFieldFromFilter(fields, filter3) {
  return (filter3 == null ? void 0 : filter3.fieldId) ? fields[filter3.fieldId] : void 0;
}
function getFilterKey(filter3) {
  return [filter3.filterName, ...filter3.fieldId ? [filter3.fieldId] : []].join("-");
}
function narrowDocumentTypes(_ref501) {
  let { fieldDefinitions, filters, types: types3 } = _ref501;
  const selectedDocumentTypes = types3.map((type) => type.name);
  const filteredDocumentTypes = Object.values(fieldDefinitions).filter((field) => filters.map((filter3) => filter3 == null ? void 0 : filter3.fieldId).includes(field.id)).filter((field) => field.documentTypes.length > 0).map((field) => field.documentTypes);
  const intersectingDocumentTypes = (0, import_intersection3.default)(...filteredDocumentTypes);
  const documentTypes = [];
  if (selectedDocumentTypes.length > 0) {
    documentTypes.push(selectedDocumentTypes);
  }
  if (intersectingDocumentTypes.length > 0) {
    documentTypes.push(intersectingDocumentTypes);
  }
  return (0, import_intersection3.default)(...documentTypes).sort();
}
function resolveFieldPath(_ref502) {
  let { filter: filter3, fieldDefinitions, filterDefinitions: filterDefinitions2 } = _ref502;
  const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter3);
  const filterDefinition = getFilterDefinition(filterDefinitions2, filter3.filterName);
  if (!filterDefinition) {
    return void 0;
  }
  switch (filterDefinition.type) {
    case "field":
      return fieldDefinition == null ? void 0 : fieldDefinition.fieldPath;
    case "pinned":
      return filterDefinition == null ? void 0 : filterDefinition.fieldPath;
    default:
      return void 0;
  }
}
function validateFilter(_ref503) {
  let { filter: filter3, filterDefinitions: filterDefinitions2, fieldDefinitions, operatorDefinitions: operatorDefinitions2 } = _ref503;
  const filterDef = getFilterDefinition(filterDefinitions2, filter3.filterName);
  const operatorDef = getOperatorDefinition(operatorDefinitions2, filter3.operatorType);
  const fieldDef = getFieldFromFilter(fieldDefinitions, filter3);
  if (!filterDef) {
    return false;
  }
  if (!operatorDef) {
    return false;
  }
  if (filter3.fieldId) {
    if (!fieldDef) {
      return false;
    }
  }
  if (filterDef.type === "field") {
    if (!(fieldDef == null ? void 0 : fieldDef.fieldPath)) {
      return false;
    }
    if (!filter3.fieldId) {
      return false;
    }
    const hasFilterValue = operatorDef.groqFilter({ fieldPath: fieldDef.fieldPath, value: filter3.value });
    if (!hasFilterValue) {
      return false;
    }
  }
  if (filterDef.type === "pinned") {
    const hasFilterValue = operatorDef.groqFilter({ fieldPath: filterDef.fieldPath, value: filter3.value });
    if (!hasFilterValue) {
      return false;
    }
  }
  return true;
}
var __freeze$v2 = Object.freeze;
var __defProp$v2 = Object.defineProperty;
var __template$v2 = (cooked, raw) => __freeze$v2(__defProp$v2(cooked, "raw", { value: __freeze$v2(raw || cooked.slice()) }));
var _a$v2;
var isEscape = (0, import_is_hotkey2.default)("escape");
var MAX_HEIGHT = 500;
var HiddenOverlay = st.div(_a$v2 || (_a$v2 = __template$v2(["\n  background: transparent;\n  height: 100%;\n  left: 0;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: -1;\n"])));
function FilterPopoverWrapper(_ref504) {
  let { anchorElement, children, onClose } = _ref504;
  const { isTopLayer } = useLayer();
  const handleGlobalKeyDown = (0, import_react51.useCallback)((event) => {
    if (isEscape(event) && isTopLayer) {
      onClose();
    }
  }, [isTopLayer, onClose]);
  useGlobalKeyDown(handleGlobalKeyDown);
  const popoverOffset = usePopoverOffset(anchorElement || null);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(HiddenOverlay, { onClick: onClose }), (0, import_jsx_runtime6.jsx)(es2015_default, { autoFocus: false, returnFocus: true, children: (0, import_jsx_runtime6.jsx)(Card, { display: "flex", overflow: "hidden", radius: POPOVER_RADIUS, style: { maxHeight: "min(calc(100vh - ".concat(popoverOffset, "px - ").concat(POPOVER_VERTICAL_MARGIN, "px - ").concat(POPOVER_INPUT_PADDING, "px), ").concat(MAX_HEIGHT, "px"), zIndex: 1 }, children: (0, import_jsx_runtime6.jsx)(Flex, { children }) }) })] });
}
function calcPopoverOffset(element) {
  const rect = element.getBoundingClientRect();
  const offset2 = rect.y + rect.height + POPOVER_VERTICAL_MARGIN;
  return offset2;
}
function usePopoverOffset(element) {
  const [offset2, setOffset] = (0, import_react51.useState)(element && calcPopoverOffset(element));
  const handleWindowResize = (0, import_react51.useCallback)(() => {
    if (element) {
      setOffset(calcPopoverOffset(element));
    }
  }, [element]);
  (0, import_react51.useEffect)(() => {
    if (element) {
      setOffset(calcPopoverOffset(element));
    }
  }, [element]);
  (0, import_react51.useEffect)(() => {
    window.addEventListener("resize", handleWindowResize);
    return () => window.removeEventListener("resize", handleWindowResize);
  }, [handleWindowResize]);
  return offset2;
}
var __freeze$u2 = Object.freeze;
var __defProp$u2 = Object.defineProperty;
var __template$u2 = (cooked, raw) => __freeze$u2(__defProp$u2(cooked, "raw", { value: __freeze$u2(raw || cooked.slice()) }));
var _a$u2;
var _b$f2;
var SearchHeaderBox = st(Box)(_a$u2 || (_a$u2 = __template$u2(["\n  border-bottom: 1px solid ", ";\n  flex-shrink: 0;\n"])), (_ref505) => {
  let { theme } = _ref505;
  return theme.sanity.color.base.border;
});
var SearchHeaderContentFlex = st(Flex)(_b$f2 || (_b$f2 = __template$u2(["\n  box-sizing: border-box;\n"])));
var FilterPopoverContentHeader = (0, import_react51.forwardRef)(function FilterPopoverContentHeader2(_ref506, ref) {
  let { ariaInputLabel, onChange, onClear, typeFilter } = _ref506;
  const { state: { fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(SearchHeaderBox, { children: (0, import_jsx_runtime6.jsx)(SearchHeaderContentFlex, { align: "center", flex: 1, padding: 1, children: (0, import_jsx_runtime6.jsx)(CustomTextInput, { "aria-label": ariaInputLabel, autoComplete: "off", border: false, clearButton: !!typeFilter, fontSize: fullscreen ? 2 : 1, icon: SearchIcon, muted: true, onChange, onClear, placeholder: t3("search.filter-placeholder"), ref, smallClearButton: true, spellCheck: false, radius: 2, value: typeFilter }) }) });
});
function createFilterMenuItems(_ref507) {
  let { documentTypesNarrowed, fieldDefinitions, filterDefinitions: filterDefinitions2, schema, titleFilter, types: types3, t: t3 } = _ref507;
  const fieldFilters = Object.values(fieldDefinitions).filter((fieldDef) => includesTitleInFieldDefinition(fieldDef, titleFilter)).map((fieldDef) => {
    const filterDef = getFilterDefinition(filterDefinitions2, fieldDef.filterName);
    if (filterDef) {
      return buildSearchFilter(filterDef, fieldDef.id);
    }
    return null;
  }).filter(isNonNullable$3);
  const pinnedItems = buildPinnedMenuItems({ fieldDefinitions, filterDefinitions: filterDefinitions2, titleFilter });
  if (documentTypesNarrowed.length === 0) {
    return [
      ...pinnedItems,
      // All fields
      ...filterGroup({ fieldDefinitions, filterDefinitions: filterDefinitions2, filters: fieldFilters, headerTitle: t3("search.filter-all-fields-header"), id: "field" })
    ];
  }
  return [
    ...pinnedItems,
    // All shared / narrowed items
    ...buildFieldMenuItemsNarrowed({ documentTypesNarrowed, fieldDefinitions, filterDefinitions: filterDefinitions2, filters: fieldFilters, schema, types: types3, t: t3 })
  ];
}
function filterGroup(_ref508) {
  let { fieldDefinitions, filterDefinitions: filterDefinitions2, filters, id: id4, headerTitle, tone } = _ref508;
  const header = { title: headerTitle || "", tone: tone || "default", type: "header" };
  const filterItems = filters.map((filter3) => ({ fieldDefinition: getFieldFromFilter(fieldDefinitions, filter3), filterDefinition: getFilterDefinition(filterDefinitions2, filter3.filterName), filter: filter3, group: id4, tone: tone || "default", type: "filter" }));
  return filterItems.length > 0 ? [
    ...headerTitle ? [header] : [],
    //
    ...filterItems
  ] : [];
}
function buildFieldMenuItemsNarrowed(_ref509) {
  let { documentTypesNarrowed, fieldDefinitions, filterDefinitions: filterDefinitions2, filters, schema, types: types3, t: t3 } = _ref509;
  const sharedFilters = filters.filter((filter3) => {
    const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter3);
    return sharesDocumentTypes(documentTypesNarrowed, fieldDefinition);
  });
  const sharedItems = documentTypesNarrowed.length > 1 && types3.length > 1 ? filterGroup({ fieldDefinitions, filterDefinitions: filterDefinitions2, filters: sharedFilters, headerTitle: t3("search.filter-shared-fields-header"), id: "shared", tone: "primary" }) : [];
  const groupedItems = documentTypesNarrowed.map((documentType) => {
    const docType = schema.get(documentType);
    return {
      // Note: it shouldn't be possible to select document types that do not exist in schema,
      // and there is no way to inject it into state (eg not persisted in URL), thus we leave
      // this fallback (`Unknown type`) only as a edge-case safety net and will not translate it.
      title: (docType == null ? void 0 : docType.title) || (0, import_startCase2.default)(docType == null ? void 0 : docType.name) || "(Unknown type)",
      documentType
    };
  }).sort((a, b) => a.title.localeCompare(b.title)).map((_ref510) => {
    let { documentType, title } = _ref510;
    const groupFilters = filters.filter((filter3) => {
      const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter3);
      return includesDocumentTypes([documentType], fieldDefinition);
    });
    return filterGroup({ fieldDefinitions, filterDefinitions: filterDefinitions2, filters: groupFilters, id: title, headerTitle: title });
  }).flat();
  return [...sharedItems, ...groupedItems];
}
function buildPinnedMenuItems(_ref511) {
  let { fieldDefinitions, filterDefinitions: filterDefinitions2, titleFilter } = _ref511;
  const ungroupedPinnedFilters = Object.values(filterDefinitions2).filter(isPinnedFilterDefWithoutGroup).filter((filterDef) => includesTitleInPinnedFilterDefinition(filterDef, titleFilter)).map((filterDef) => buildSearchFilter(filterDef));
  const groupedPinnedFilters = Object.values(filterDefinitions2).filter(isPinnedFilterDefWithGroup).filter((filterDef) => includesTitleInPinnedFilterDefinition(filterDef, titleFilter)).reduce((acc, val) => {
    acc[val.group] = acc[val.group] || [];
    acc[val.group].push(buildSearchFilter(val));
    return acc;
  }, {});
  return [
    // Ungrouped
    ...filterGroup({ fieldDefinitions, filterDefinitions: filterDefinitions2, filters: ungroupedPinnedFilters, id: "pinned-ungrouped", tone: "primary" }),
    // Grouped
    ...Object.entries(groupedPinnedFilters).flatMap((_ref512) => {
      let [groupTitle, filters] = _ref512;
      return filterGroup({ fieldDefinitions, filterDefinitions: filterDefinitions2, filters, headerTitle: groupTitle, id: groupTitle, tone: "primary" });
    })
  ];
}
function includesDocumentTypes(documentTypes, fieldDefinition) {
  return fieldDefinition == null ? void 0 : fieldDefinition.documentTypes.some((type) => documentTypes.includes(type));
}
function includesTitleInFieldDefinition(field, currentTitle) {
  const fieldTitle = field.titlePath.join("/");
  return fieldTitle.toLowerCase().includes(currentTitle.toLowerCase());
}
function includesTitleInPinnedFilterDefinition(filter3, currentTitle) {
  return filter3.title.toLowerCase().includes(currentTitle.toLowerCase());
}
function isPinnedFilterDefWithGroup(filterDef) {
  return filterDef.type === "pinned" && typeof (filterDef == null ? void 0 : filterDef.group) !== "undefined";
}
function isPinnedFilterDefWithoutGroup(filterDef) {
  return filterDef.type === "pinned" && typeof (filterDef == null ? void 0 : filterDef.group) === "undefined";
}
function sharesDocumentTypes(documentTypes, fieldDefinition) {
  return (0, import_difference3.default)(documentTypes, (fieldDefinition == null ? void 0 : fieldDefinition.documentTypes) || []).length === 0;
}
function FilterTitle(_ref513) {
  let { filter: filter3, maxLength } = _ref513;
  const { state: { definitions } } = useSearchState();
  const title = (0, import_react51.useMemo)(() => {
    const filterDef = getFilterDefinition(definitions.filters, filter3.filterName);
    switch (filterDef == null ? void 0 : filterDef.type) {
      case "field": {
        const fieldDefinition = getFieldFromFilter(definitions.fields, filter3);
        if (fieldDefinition == null ? void 0 : fieldDefinition.titlePath) {
          return fieldDefinition.titlePath[fieldDefinition.titlePath.length - 1];
        }
        return null;
      }
      case "pinned":
        return filterDef.title;
      default:
        return null;
    }
  }, [definitions, filter3]);
  if (!title) {
    return null;
  }
  return maxLength && title.length > maxLength ? (0, import_jsx_runtime6.jsxs)("span", { children: [title.slice(0, maxLength), ""] }) : (0, import_jsx_runtime6.jsx)("span", { children: title });
}
function FilterIcon3(_ref514) {
  let { filter: filter3 } = _ref514;
  var _a4;
  const { state: { definitions } } = useSearchState();
  const icon = (_a4 = getFilterDefinition(definitions.filters, filter3.filterName)) == null ? void 0 : _a4.icon;
  if (icon) {
    return (0, import_react51.createElement)(icon);
  }
  return (0, import_jsx_runtime6.jsx)(UnknownIcon, {});
}
function FilterDetails(_ref515) {
  let { filter: filter3, small = true } = _ref515;
  var _a4;
  const { state: { definitions } } = useSearchState();
  const fieldDefinition = getFieldFromFilter(definitions.fields, filter3);
  return (0, import_jsx_runtime6.jsxs)(Stack, { space: small ? 2 : 3, children: [(fieldDefinition == null ? void 0 : fieldDefinition.titlePath) && ((_a4 = fieldDefinition.titlePath) == null ? void 0 : _a4.length) > 1 && (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 4, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: small ? 0 : 1, children: fieldDefinition.titlePath.slice(0, -1).map((pathTitle, index) => {
    return (0, import_jsx_runtime6.jsxs)(import_react51.default.Fragment, { children: [(0, import_jsx_runtime6.jsx)("span", { children: pathTitle }), index !== fieldDefinition.titlePath.length - 2 && (0, import_jsx_runtime6.jsx)("span", { style: { opacity: 0.75, paddingLeft: "0.25em", paddingRight: "0.25em" }, children: (0, import_jsx_runtime6.jsx)(ChevronRightIcon, {}) })] }, index);
  }) }) }), (0, import_jsx_runtime6.jsxs)(Flex, { align: "flex-start", gap: 3, children: [(0, import_jsx_runtime6.jsx)(Box, { style: { flexShrink: 0 }, children: (0, import_jsx_runtime6.jsx)(Text3, { size: small ? 1 : 2, children: (0, import_jsx_runtime6.jsx)(FilterIcon3, { filter: filter3 }) }) }), (0, import_jsx_runtime6.jsx)(Text3, { size: small ? 1 : 2, weight: "medium", children: (0, import_jsx_runtime6.jsx)(FilterTitle, { filter: filter3 }) })] })] });
}
function sanitizeFieldValue(name) {
  if ((0, import_react51.isValidElement)(name)) {
    return stripHtmlTags((0, import_server.renderToString)(name));
  }
  return typeof name === "string" ? name : "";
}
function stripHtmlTags(str) {
  var _a4;
  return ((_a4 = new DOMParser().parseFromString(str, "text/html")) == null ? void 0 : _a4.body.textContent) || "";
}
var MAX_VISIBLE_TYPES = 10;
function FilterTooltip(_ref516) {
  let { children, fieldDefinition, filterDefinition, visible } = _ref516;
  const { state: { documentTypesNarrowed } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const schema = useSchema();
  const fieldDefinitionDocumentTypeTitles = (0, import_react51.useMemo)(() => {
    if (fieldDefinition == null ? void 0 : fieldDefinition.documentTypes) {
      return fieldDefinition.documentTypes.map((d) => {
        const defType = schema.get(d);
        return (defType == null ? void 0 : defType.title) || (0, import_startCase2.default)(defType == null ? void 0 : defType.name);
      }).filter(isNonNullable$3).sort();
    }
    return [];
  }, [fieldDefinition == null ? void 0 : fieldDefinition.documentTypes, schema]);
  const fieldDefinitionDescription = (0, import_react51.useMemo)(() => {
    if (fieldDefinition == null ? void 0 : fieldDefinition.documentTypes) {
      const descriptions = fieldDefinition.documentTypes.map((d) => {
        const defType = schema.get(d);
        if (defType) {
          const field = getSchemaField(defType, fieldDefinition.fieldPath);
          return (field == null ? void 0 : field.type.description) && sanitizeFieldValue(field == null ? void 0 : field.type.description);
        }
        return null;
      }).filter(isNonNullable$3).sort();
      const uniqueDescriptions = (0, import_uniq4.default)(descriptions);
      if (uniqueDescriptions.length === 1) {
        return uniqueDescriptions[0];
      }
    }
    return void 0;
  }, [fieldDefinition == null ? void 0 : fieldDefinition.documentTypes, fieldDefinition == null ? void 0 : fieldDefinition.fieldPath, schema]);
  return (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Card, { tone: "default", radius: 2, style: { maxWidth: "250px" }, children: (0, import_jsx_runtime6.jsxs)(Stack, { padding: 3, space: 4, children: [fieldDefinition && (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 0, children: t3("search.filter-field-tooltip-name") }), (0, import_jsx_runtime6.jsx)(Inline, { children: (0, import_jsx_runtime6.jsx)(Card, { tone: "caution", padding: 1, radius: 2, children: (0, import_jsx_runtime6.jsx)(Code, { size: 0, children: fieldDefinition == null ? void 0 : fieldDefinition.name }) }) })] }), fieldDefinitionDescription && (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 0, children: t3("search.filter-field-tooltip-description") }), (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 0, children: truncateString(fieldDefinitionDescription, 256) })] }), (filterDefinition == null ? void 0 : filterDefinition.description) && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 0, children: truncateString(filterDefinition.description, 256) }), !documentTypesNarrowed.length && fieldDefinitionDocumentTypeTitles.length > 0 && (0, import_jsx_runtime6.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 1, children: [(0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 0, children: t3("search.filter-field-tooltip-used-in-document-types") }), (0, import_jsx_runtime6.jsx)(Card, { padding: 1, radius: 2, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(Text3, { size: 0, muted: true, children: fieldDefinitionDocumentTypeTitles.length }) })] }), (0, import_jsx_runtime6.jsxs)(Text3, { size: 0, weight: "regular", muted: true, children: [fieldDefinitionDocumentTypeTitles.slice(0, MAX_VISIBLE_TYPES).join(", "), (fieldDefinitionDocumentTypeTitles == null ? void 0 : fieldDefinitionDocumentTypeTitles.length) > MAX_VISIBLE_TYPES ? " +".concat(fieldDefinitionDocumentTypeTitles.length - MAX_VISIBLE_TYPES, " more") : ""] })] })] }) }), disabled: !visible, fallbackPlacements: ["left"], placement: "right", portal: true, children });
}
var MenuItemFilter = import_react51.default.memo(function MenuItemFilter2(_ref517) {
  let { item, onClose, ...rest } = _ref517;
  const [tooltipVisible, setTooltipVisible] = (0, import_react51.useState)(false);
  const { dispatch, state: { filters } } = useSearchState();
  const handleClick = (0, import_react51.useCallback)(() => {
    dispatch({ filter: item.filter, type: "TERMS_FILTERS_ADD" });
    onClose == null ? void 0 : onClose();
  }, [dispatch, item.filter, onClose]);
  const isAlreadyActive = !!filters.find((f) => getFilterKey(f) === getFilterKey(item.filter));
  const timeoutRef = (0, import_react51.useRef)();
  const handleMouseEnter = (0, import_react51.useCallback)(() => {
    timeoutRef.current = setTimeout(() => setTooltipVisible(true), 500);
  }, []);
  const handleMouseLeave = (0, import_react51.useCallback)(() => {
    setTooltipVisible(false);
    clearTimeout(timeoutRef.current);
  }, []);
  (0, import_react51.useEffect)(() => {
    return () => clearTimeout(timeoutRef.current);
  }, []);
  const tooltipEnabled = !!(item.fieldDefinition || item.filterDefinition.description);
  return (0, import_jsx_runtime6.jsx)(Box, { ...rest, children: (0, import_jsx_runtime6.jsx)(Button, { disabled: isAlreadyActive, fontSize: 1, justify: "flex-start", mode: "bleed", onClick: isAlreadyActive ? void 0 : handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, padding: 0, style: { position: "relative", whiteSpace: "normal", width: "100%" }, tabIndex: -1, tone: item == null ? void 0 : item.tone, children: (0, import_jsx_runtime6.jsx)(FilterTooltip, { fieldDefinition: item.fieldDefinition, filterDefinition: item.filterDefinition, visible: tooltipEnabled && tooltipVisible, children: (0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime6.jsx)(FilterDetails, { filter: item.filter }) }) }) }) });
});
var MenuItemHeader = import_react51.default.memo(function MenuItemHeader2(_ref518) {
  let { item } = _ref518;
  return (0, import_jsx_runtime6.jsx)(Box, { paddingTop: 1, children: (0, import_jsx_runtime6.jsx)(Card, { borderBottom: true, padding: 3, tone: item == null ? void 0 : item.tone, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 0, textOverflow: "ellipsis", children: item.title }) }) });
});
var POPOVER_STYLES$1 = { width: "300px" };
function AddFilterPopoverContent(_ref519) {
  let { onClose } = _ref519;
  const [inputElement, setInputElement] = (0, import_react51.useState)(null);
  const [titleFilter, setTitleFilter] = (0, import_react51.useState)("");
  const { t: t3 } = useTranslation2();
  const handleFilterChange = (0, import_react51.useCallback)((e2) => setTitleFilter(e2.currentTarget.value), [setTitleFilter]);
  const handleFilterClear = (0, import_react51.useCallback)(() => setTitleFilter(""), []);
  const schema = useSchema();
  const { state: { documentTypesNarrowed, definitions, filters, terms: { types: types3 } } } = useSearchState();
  const filteredMenuItems = (0, import_react51.useMemo)(() => createFilterMenuItems({ documentTypesNarrowed, fieldDefinitions: definitions.fields, filterDefinitions: definitions.filters, schema, titleFilter, types: types3, t: t3 }), [documentTypesNarrowed, definitions.fields, definitions.filters, schema, titleFilter, types3, t3]);
  const renderItem = (0, import_react51.useCallback)((item) => {
    if (item.type === "filter") {
      return (0, import_jsx_runtime6.jsx)(MenuItemFilter, { item, onClose, paddingBottom: 1 });
    }
    if (item.type === "header") {
      return (0, import_jsx_runtime6.jsx)(MenuItemHeader, { item });
    }
    return null;
  }, [onClose]);
  const getItemDisabled = (0, import_react51.useCallback)((index) => {
    const filterItem = filteredMenuItems[index];
    return filterItem.type !== "filter" || !!filters.find((f) => getFilterKey(f) === getFilterKey(filterItem.filter));
  }, [filteredMenuItems, filters]);
  const getItemKey2 = (0, import_react51.useCallback)((index) => {
    const menuItem = filteredMenuItems[index];
    switch (menuItem.type) {
      case "filter":
        return [
          ...menuItem.group ? [menuItem.group] : [],
          //
          getFilterKey(menuItem.filter)
        ].join("-");
      case "header":
        return "".concat(menuItem.type, "-").concat(menuItem.title);
      default:
        return index;
    }
  }, [filteredMenuItems]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", style: POPOVER_STYLES$1, children: [(0, import_jsx_runtime6.jsx)(FilterPopoverContentHeader, { ariaInputLabel: t3("search.filter-by-title-aria-label"), onChange: handleFilterChange, onClear: handleFilterClear, ref: setInputElement, typeFilter: titleFilter }), (0, import_jsx_runtime6.jsxs)(Flex, { children: [filteredMenuItems.length > 0 && (0, import_jsx_runtime6.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t3("search.filters-aria-label", { count: filteredMenuItems.length }), autoFocus: "input", getItemDisabled, getItemKey: getItemKey2, inputElement, itemHeight: 45, items: filteredMenuItems, overscan: 20, padding: 1, paddingBottom: 0, renderItem }), filteredMenuItems.length == 0 && (0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: t3("search.filter-no-matches-found", { filter: titleFilter }) }) })] })] });
}
function AddFilterButton() {
  const [open, setOpen] = (0, import_react51.useState)(false);
  const [buttonElement, setButtonElement] = (0, import_react51.useState)(null);
  const { t: t3 } = useTranslation2();
  const { state: { fullscreen } } = useSearchState();
  const handleClose = (0, import_react51.useCallback)(() => setOpen(false), []);
  const handleOpen = (0, import_react51.useCallback)(() => setOpen(true), []);
  return (0, import_jsx_runtime6.jsx)(Popover, { __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0], content: (0, import_jsx_runtime6.jsx)(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: (0, import_jsx_runtime6.jsx)(AddFilterPopoverContent, { onClose: handleClose }) }), open, placement: "bottom-start", radius: POPOVER_RADIUS, portal: true, children: (0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, icon: AddIcon, mode: "bleed", onClick: handleOpen, padding: fullscreen ? 3 : 2, ref: setButtonElement, selected: open, space: 2, text: t3("search.action.add-filter") }) });
}
var DocumentTypeFilterItem = import_react51.default.memo(function TypeFilterItem(_ref520) {
  let { selected, type, ...rest } = _ref520;
  var _a4, _b4;
  const { dispatch } = useSearchState();
  const handleTypeAdd = (0, import_react51.useCallback)(() => {
    dispatch({ type: "TERMS_TYPE_ADD", schemaType: type });
  }, [dispatch, type]);
  const handleTypeRemove = (0, import_react51.useCallback)(() => {
    dispatch({ type: "TERMS_TYPE_REMOVE", schemaType: type });
  }, [dispatch, type]);
  const handleClick = (0, import_react51.useCallback)(() => {
    if (selected) {
      handleTypeRemove();
    } else {
      handleTypeAdd();
    }
  }, [handleTypeAdd, handleTypeRemove, selected]);
  return (0, import_jsx_runtime6.jsx)(Box, { ...rest, children: (0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, iconRight: selected && CheckmarkIcon, justify: "flex-start", mode: "bleed", onClick: handleClick, style: { width: "100%" }, tabIndex: -1, text: (_b4 = type.title) != null ? _b4 : type.name, tone: selected ? "primary" : "default" }, (_a4 = type.title) != null ? _a4 : type.name) });
});
var __freeze$t2 = Object.freeze;
var __defProp$t2 = Object.defineProperty;
var __template$t2 = (cooked, raw) => __freeze$t2(__defProp$t2(cooked, "raw", { value: __freeze$t2(raw || cooked.slice()) }));
var _a$t2;
var ClearButtonBox = st(Box)(_a$t2 || (_a$t2 = __template$t2(["\n  border-top: 1px solid ", ";\n  flex-shrink: 0;\n"])), (_ref521) => {
  let { theme } = _ref521;
  return theme.sanity.color.base.border;
});
var POPOVER_STYLES = { width: "250px" };
function DocumentTypesPopoverContent() {
  const [inputElement, setInputElement] = (0, import_react51.useState)(null);
  const [typeFilter, setTypeFilter] = (0, import_react51.useState)("");
  const commandListRef = (0, import_react51.useRef)(null);
  const { t: t3 } = useTranslation2();
  const schema = useSchema();
  const { dispatch, state: { terms: { types: selectedTypes } } } = useSearchState();
  const [selectedTypesSnapshot, setSelectedTypesSnapshot] = (0, import_react51.useState)(selectedTypes);
  const documentTypeItems = useGetDocumentTypeItems(schema, selectedTypes, selectedTypesSnapshot, typeFilter);
  const handleFilterChange = (0, import_react51.useCallback)((e2) => setTypeFilter(e2.currentTarget.value), [setTypeFilter]);
  const handleFilterClear = (0, import_react51.useCallback)(() => setTypeFilter(""), []);
  const handleTypesClear = (0, import_react51.useCallback)(() => {
    var _a22, _b4;
    setSelectedTypesSnapshot([]);
    dispatch({ type: "TERMS_TYPES_CLEAR" });
    (_a22 = commandListRef == null ? void 0 : commandListRef.current) == null ? void 0 : _a22.focusInputElement();
    (_b4 = commandListRef == null ? void 0 : commandListRef.current) == null ? void 0 : _b4.scrollToIndex(0);
  }, [dispatch]);
  const getItemKey2 = (0, import_react51.useCallback)((index) => {
    const virtualItem = documentTypeItems[index];
    switch (virtualItem.type) {
      case "divider":
        return "".concat(virtualItem.type, "-").concat(index);
      case "header":
        return "".concat(virtualItem.type, "-").concat(virtualItem.title);
      case "item":
        return "".concat(virtualItem.type, "-").concat(virtualItem.item.name);
      default:
        return index;
    }
  }, [documentTypeItems]);
  const renderItem = (0, import_react51.useCallback)((item) => {
    if (item.type === "divider") {
      return (0, import_jsx_runtime6.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime6.jsx)(MenuDivider, {}) });
    }
    if (item.type === "header") {
      return (0, import_jsx_runtime6.jsx)(Box, { margin: 1, paddingBottom: 2, paddingTop: 3, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 0, children: item.title }) });
    }
    if (item.type === "item") {
      return (0, import_jsx_runtime6.jsx)(DocumentTypeFilterItem, { paddingBottom: 1, selected: item.selected, type: item.item });
    }
    return null;
  }, []);
  const getItemDisabled = (0, import_react51.useCallback)((index) => {
    const item = documentTypeItems[index];
    return item.type !== "item";
  }, [documentTypeItems]);
  const getItemSelected = (0, import_react51.useCallback)((index) => {
    const item = documentTypeItems[index];
    return item.type === "item" && item.selected;
  }, [documentTypeItems]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", style: POPOVER_STYLES, children: [(0, import_jsx_runtime6.jsx)(FilterPopoverContentHeader, { ariaInputLabel: t3("search.action.filter-by-document-type-aria-label"), onChange: handleFilterChange, onClear: handleFilterClear, ref: setInputElement, typeFilter }), (0, import_jsx_runtime6.jsxs)(Flex, { children: [documentTypeItems.length > 0 && (0, import_jsx_runtime6.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t3("search.document-types-aria-label"), ariaMultiselectable: true, autoFocus: "input", getItemDisabled, getItemSelected, getItemKey: getItemKey2, inputElement, itemHeight: 37, items: documentTypeItems, overscan: 20, padding: 1, paddingBottom: 0, ref: commandListRef, renderItem }), !documentTypeItems.length && (0, import_jsx_runtime6.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: t3("search.document-types-no-matches-found", { filter: typeFilter }) }) })] }), !typeFilter && selectedTypes.length > 0 && (0, import_jsx_runtime6.jsx)(ClearButton, { onClick: handleTypesClear, selectedTypes })] });
}
function ClearButton(_ref522) {
  let { onClick, selectedTypes } = _ref522;
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(ClearButtonBox, { padding: 1, children: (0, import_jsx_runtime6.jsx)(Stack, { children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("search.action.clear-type-filters-aria-label"), "data-name": "type-filter-button", disabled: selectedTypes.length === 0, fontSize: 1, mode: "bleed", onClick, padding: 3, text: t3("search.action.clear-type-filters-label"), tone: "primary" }) }) });
}
function useGetDocumentTypeItems(schema, selectedTypes, selectedTypesSnapshot, typeFilter) {
  return (0, import_react51.useMemo)(() => {
    const [itemsSelected, itemsUnselected] = (0, import_partition2.default)(getSelectableOmnisearchTypes(schema, typeFilter), (type) => selectedTypesSnapshot.includes(type));
    const hasSelectedItems = itemsSelected.length > 0;
    const hasUnselectedItems = itemsSelected.length > 0;
    const items = [];
    if (hasSelectedItems) {
      items.push({ title: "Selected", type: "header" });
    }
    itemsSelected.forEach((item) => items.push({ item, selected: selectedTypes.includes(item), type: "item" }));
    if (hasSelectedItems && hasUnselectedItems) {
      items.push({ type: "divider" });
    }
    itemsUnselected.forEach((item) => items.push({ item, selected: selectedTypes.includes(item), type: "item" }));
    return items;
  }, [schema, selectedTypes, selectedTypesSnapshot, typeFilter]);
}
var __freeze$s2 = Object.freeze;
var __defProp$s2 = Object.defineProperty;
var __template$s2 = (cooked, raw) => __freeze$s2(__defProp$s2(cooked, "raw", { value: __freeze$s2(raw || cooked.slice()) }));
var _a$s2;
var StyledButton = st(Button)((_ref523) => {
  let { theme } = _ref523;
  const { regular } = theme.sanity.fonts.text.weights;
  return nt(_a$s2 || (_a$s2 = __template$s2(["\n    [data-ui='Text'] {\n      font-weight: ", ";\n    }\n  "])), regular);
});
var FALLBACK_PLACEMENTS = ["top-start", "bottom-start"];
function DocumentTypesButton() {
  const [open, setOpen] = (0, import_react51.useState)(false);
  const [buttonElement, setButtonElement] = (0, import_react51.useState)(null);
  const [popoverElement, setPopoverElement] = (0, import_react51.useState)(null);
  const { state: { fullscreen, terms: { types: types3 } } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleClose = (0, import_react51.useCallback)(() => setOpen(false), []);
  const handleOpen = (0, import_react51.useCallback)(() => setOpen(true), []);
  useClickOutside(handleClose, [buttonElement, popoverElement]);
  const title = (0, import_react51.useMemo)(() => documentTypesTruncated({ types: types3, t: t3 }), [types3, t3]);
  return (0, import_jsx_runtime6.jsx)(Popover, { __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0], content: (0, import_jsx_runtime6.jsx)(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: (0, import_jsx_runtime6.jsx)(DocumentTypesPopoverContent, {}) }), open, placement: "bottom-start", fallbackPlacements: FALLBACK_PLACEMENTS, portal: true, radius: POPOVER_RADIUS, ref: setPopoverElement, children: (0, import_jsx_runtime6.jsx)(StyledButton, { fontSize: 1, iconRight: SelectIcon, mode: "ghost", onClick: handleOpen, padding: fullscreen ? 3 : 2, ref: setButtonElement, selected: open, style: { maxWidth: "100%" }, text: title, tone: "default" }) });
}
var __freeze$r2 = Object.freeze;
var __defProp$r2 = Object.defineProperty;
var __template$r2 = (cooked, raw) => __freeze$r2(__defProp$r2(cooked, "raw", { value: __freeze$r2(raw || cooked.slice()) }));
var _a$r2;
var CustomBox = st(Box)(_a$r2 || (_a$r2 = __template$r2(["\n  flex-shrink: ", ";\n"])), (_ref524) => {
  let { $flexShrink = 0 } = _ref524;
  return $flexShrink;
});
function FilterLabel(_ref525) {
  let { filter: filter3, fontSize: fontSize2 = 1, showContent = true } = _ref525;
  const { t: t3 } = useTranslation2();
  const { state: { definitions, fullscreen } } = useSearchState();
  const operator = getOperatorDefinition(definitions.operators, filter3.operatorType);
  const ButtonValue = operator == null ? void 0 : operator.buttonValueComponent;
  const filterValue = filter3.value;
  const components = (0, import_react51.useMemo)(() => ({ Field: () => (0, import_jsx_runtime6.jsx)(CustomBox, { $flexShrink: fullscreen ? 1 : 0, children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "default", size: fontSize2, textOverflow: "ellipsis", weight: "semibold", children: (0, import_jsx_runtime6.jsx)(FilterTitle, { filter: filter3, maxLength: fullscreen ? 25 : 40 }) }) }), Operator: (_ref526) => {
    let { children } = _ref526;
    return showContent && (0, import_jsx_runtime6.jsx)(CustomBox, { $flexShrink: 0, children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "default", size: fontSize2, textOverflow: "ellipsis", weight: "regular", children }) });
  }, Value: (_ref527) => {
    let { children } = _ref527;
    return showContent && (0, import_jsx_runtime6.jsx)(CustomBox, { $flexShrink: 1, children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "default", size: fontSize2, textOverflow: "ellipsis", weight: "semibold", children: ButtonValue ? (0, import_jsx_runtime6.jsx)(ButtonValue, { value: filterValue }) : children }) });
  } }), [filter3, fontSize2, fullscreen, showContent, ButtonValue, filterValue]);
  if (!(operator == null ? void 0 : operator.descriptionKey)) {
    console.warn("Missing `descriptionKey` for operator `%s`", filter3.operatorType);
  }
  if (!showContent || !(operator == null ? void 0 : operator.descriptionKey)) {
    const Field = components.Field;
    return (0, import_jsx_runtime6.jsx)(Flex, { align: "center", gap: 1, children: (0, import_jsx_runtime6.jsx)(Field, {}) });
  }
  return (0, import_jsx_runtime6.jsx)(Flex, { align: "center", gap: 1, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: operator == null ? void 0 : operator.descriptionKey, components, values: getFilterValues(filter3) }) });
}
function getFilterValues(filter3) {
  const values2 = {};
  if (typeof filter3.value === "number") {
    values2.count = filter3.value;
  }
  if (isStringOrNumber(filter3.value)) {
    values2.value = filter3.value;
  }
  if (isRecord$4(filter3.value) && "from" in filter3.value && isStringOrNumber(filter3.value.from)) {
    values2.from = filter3.value.from;
  }
  if (isRecord$4(filter3.value) && "to" in filter3.value && isStringOrNumber(filter3.value.to)) {
    values2.to = filter3.value.to;
  }
  return values2;
}
function isStringOrNumber(value) {
  return typeof value === "string" || typeof value === "number";
}
function FilterError(props2) {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Box, { ...props2, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "flex-start", gap: 3, children: [(0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "critical", children: (0, import_jsx_runtime6.jsx)(ErrorOutlineIcon, {}) }), (0, import_jsx_runtime6.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "critical", weight: "semibold", children: t3("search.error.display-filter-title") }), (0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "critical", children: t3("search.error.display-filter-description") })] })] }) });
}
function CustomMenuItem$1(_ref528) {
  let { onClick, operator, selected } = _ref528;
  const handleClick = (0, import_react51.useCallback)(() => onClick(operator.type), [onClick, operator.type]);
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(MenuItem, { onClick: handleClick, padding: 3, pressed: selected, tone: "default", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "space-between", gap: 3, children: [(0, import_jsx_runtime6.jsx)(Box, { paddingRight: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "regular", children: t3(operator.nameKey) }) }), (operator == null ? void 0 : operator.icon) && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_react51.createElement)(operator.icon) })] }) });
}
function OperatorsMenuButton(_ref529) {
  let { filter: filter3, operator } = _ref529;
  var _a4;
  const menuButtonId = (0, import_react51.useId)();
  const { t: t3 } = useTranslation2();
  const { dispatch, state } = useSearchState();
  const operatorItems = (_a4 = getFilterDefinition(state.definitions.filters, filter3.filterName)) == null ? void 0 : _a4.operators;
  const handleClick = (0, import_react51.useCallback)((operatorType) => {
    dispatch({ filterKey: getFilterKey(filter3), operatorType, type: "TERMS_FILTERS_SET_OPERATOR" });
  }, [dispatch, filter3]);
  if (!operator || !operatorItems || operatorItems.length <= 1) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(Inline, { children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { mode: "ghost", padding: 3, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, justify: "space-between", children: [(0, import_jsx_runtime6.jsx)(Text3, { size: state.fullscreen ? 2 : 1, weight: "regular", children: t3(operator.nameKey) }), (0, import_jsx_runtime6.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(SelectIcon, {}) }) })] }) }), id: menuButtonId || "", menu: (0, import_jsx_runtime6.jsx)(Menu, { children: operatorItems.map((item, index) => {
    if (item.type === "item") {
      const menuOperator = getOperatorDefinition(state.definitions.operators, item.name);
      if (!menuOperator) {
        return null;
      }
      return (0, import_jsx_runtime6.jsx)(CustomMenuItem$1, { onClick: handleClick, operator: menuOperator, selected: operator.type === item.name }, index);
    }
    if (item.type === "divider") {
      return (0, import_jsx_runtime6.jsx)(MenuDivider, {}, index);
    }
    return null;
  }) }), placement: "bottom-start", popover: { constrainSize: true, portal: false, radius: 2 } }) });
}
function FilterForm(_ref530) {
  let { filter: filter3 } = _ref530;
  const [errorParams, setErrorParams] = (0, import_react51.useState)(null);
  const { dispatch, state: { definitions, fullscreen } } = useSearchState();
  const filterDefinition = getFilterDefinition(definitions.filters, filter3.filterName);
  const operator = getOperatorDefinition(definitions.operators, filter3.operatorType);
  const fieldDefinition = getFieldFromFilter(definitions.fields, filter3);
  const filterKey = getFilterKey(filter3);
  const handleClose = (0, import_react51.useCallback)(() => {
    dispatch({ filterKey: getFilterKey(filter3), type: "TERMS_FILTERS_REMOVE" });
  }, [dispatch, filter3]);
  const handleValueChange = (0, import_react51.useCallback)((value) => {
    dispatch({ filterKey, type: "TERMS_FILTERS_SET_VALUE", value });
  }, [dispatch, filterKey]);
  const handleCatchError = (0, import_react51.useCallback)((params) => {
    setErrorParams(params);
  }, []);
  const Component3 = operator == null ? void 0 : operator.inputComponent;
  if (errorParams) {
    return (0, import_jsx_runtime6.jsx)(FilterError, { padding: 4 });
  }
  return (0, import_jsx_runtime6.jsx)(ErrorBoundary, { onCatch: handleCatchError, children: (0, import_jsx_runtime6.jsx)(es2015_default, { autoFocus: !supportsTouch, returnFocus: true, children: (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column-reverse", children: [Component3 && (0, import_jsx_runtime6.jsx)(Card, { borderTop: true, padding: 3, children: (0, import_jsx_runtime6.jsx)(Component3, { fieldDefinition, onChange: handleValueChange, value: filter3.value }, filter3.operatorType) }), (0, import_jsx_runtime6.jsx)(Card, { padding: 3, children: (0, import_jsx_runtime6.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "flex-start", gap: 3, justify: "space-between", children: [(0, import_jsx_runtime6.jsx)(Box, { paddingBottom: 1, paddingLeft: 1, paddingRight: 2, paddingTop: fullscreen ? 2 : 1, children: (0, import_jsx_runtime6.jsx)(FilterDetails, { filter: filter3, small: !fullscreen }) }), fullscreen && (0, import_jsx_runtime6.jsx)(Button, { fontSize: 2, icon: TrashIcon, mode: "bleed", onClick: handleClose, padding: 2, tone: "critical" })] }), (filterDefinition == null ? void 0 : filterDefinition.description) && (0, import_jsx_runtime6.jsx)(Card, { border: true, padding: 3, radius: 2, tone: "transparent", children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: filterDefinition.description }) }), (0, import_jsx_runtime6.jsx)(OperatorsMenuButton, { filter: filter3, operator })] }) })] }) }) });
}
var __freeze$q2 = Object.freeze;
var __defProp$q2 = Object.defineProperty;
var __template$q2 = (cooked, raw) => __freeze$q2(__defProp$q2(cooked, "raw", { value: __freeze$q2(raw || cooked.slice()) }));
var _a$q2;
var ContainerFlex = st(Flex)(_a$q2 || (_a$q2 = __template$q2(["\n  max-width: 480px;\n  min-width: 150px;\n  overflow: hidden;\n  overflow: clip;\n  width: 100%;\n"])));
function FilterPopoverContent(_ref531) {
  let { filter: filter3 } = _ref531;
  return (0, import_jsx_runtime6.jsxs)(ContainerFlex, { direction: "column", children: [(0, import_jsx_runtime6.jsx)(FilterForm, { filter: filter3 }), DEBUG_MODE] });
}
var __freeze$p2 = Object.freeze;
var __defProp$p2 = Object.defineProperty;
var __template$p2 = (cooked, raw) => __freeze$p2(__defProp$p2(cooked, "raw", { value: __freeze$p2(raw || cooked.slice()) }));
var _a$p2;
var _b$e2;
var _c$c2;
var _d$6;
var CloseButton = st(Button)(_a$p2 || (_a$p2 = __template$p2(["\n  border-radius: ", ";\n"])), (_ref532) => {
  let { theme } = _ref532;
  return "0 ".concat(rem(theme.sanity.radius[2]), " ").concat(rem(theme.sanity.radius[2]), " 0");
});
var CloseCard = st(Card)(_b$e2 || (_b$e2 = __template$p2(["\n  position: absolute;\n  right: 0;\n"])));
var ContainerDiv = st.div(_c$c2 || (_c$c2 = __template$p2(["\n  align-items: center;\n  display: inline-flex;\n  max-width: 100%;\n  position: relative;\n"])));
var LabelButton = st(Button)(_d$6 || (_d$6 = __template$p2(["\n  border: none;\n  width: 100%;\n"])));
function FilterButton(_ref533) {
  let { filter: filter3, initialOpen } = _ref533;
  const [open, setOpen] = (0, import_react51.useState)(initialOpen);
  const { dispatch, state: { definitions, fullscreen } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleClose = (0, import_react51.useCallback)(() => setOpen(false), []);
  const handleOpen = (0, import_react51.useCallback)(() => setOpen(true), []);
  const handleRemove = (0, import_react51.useCallback)(() => dispatch({ filterKey: getFilterKey(filter3), type: "TERMS_FILTERS_REMOVE" }), [dispatch, filter3]);
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    if (["Backspace", "Delete"].includes(event.key)) {
      handleRemove();
    }
  }, [handleRemove]);
  const isValid2 = validateFilter({ fieldDefinitions: definitions.fields, filter: filter3, filterDefinitions: definitions.filters, operatorDefinitions: definitions.operators });
  return (0, import_jsx_runtime6.jsx)(Popover, { __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0], content: (0, import_jsx_runtime6.jsx)(FilterPopoverWrapper, { onClose: handleClose, children: (0, import_jsx_runtime6.jsx)(FilterPopoverContent, { filter: filter3 }) }), constrainSize: true, open, overflow: "auto", placement: "bottom-start", portal: true, radius: POPOVER_RADIUS, children: (0, import_jsx_runtime6.jsxs)(ContainerDiv, { children: [(0, import_jsx_runtime6.jsx)(Card, { __unstable_focusRing: true, display: "flex", radius: 2, tone: isValid2 ? "primary" : "transparent", children: (0, import_jsx_runtime6.jsx)(LabelButton, { mode: "bleed", onClick: handleOpen, onKeyDown: handleKeyDown, paddingLeft: fullscreen ? 3 : 2, paddingRight: fullscreen ? 3 : 5, paddingY: fullscreen ? 3 : 2, children: (0, import_jsx_runtime6.jsx)(FilterLabel, { filter: filter3, showContent: isValid2 }) }) }), !fullscreen && (0, import_jsx_runtime6.jsx)(CloseCard, { __unstable_focusRing: true, display: "flex", radius: 2, tone: isValid2 ? "primary" : "transparent", children: (0, import_jsx_runtime6.jsx)(CloseButton, { "aria-label": t3("search.action.remove-filter-aria-label"), fontSize: 1, icon: CloseIcon, mode: "bleed", onClick: handleRemove, onKeyDown: handleKeyDown, padding: 2, radius: 2 }) })] }) });
}
function Filters() {
  const { dispatch, state: { filters, fullscreen, lastAddedFilter, terms: { types: types3 } } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const isMounted = (0, import_react51.useRef)(false);
  const handleClear = (0, import_react51.useCallback)(() => {
    dispatch({ type: "TERMS_FILTERS_CLEAR" });
    dispatch({ type: "TERMS_TYPES_CLEAR" });
  }, [dispatch]);
  const clearFiltersButtonVisible = filters.length > 0 || types3.length > 0;
  (0, import_react51.useEffect)(() => {
    isMounted.current = true;
  }, []);
  const lastAddedFilterKey = lastAddedFilter && getFilterKey(lastAddedFilter);
  const ClearFiltersButton = () => (0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, mode: "bleed", onClick: handleClear, padding: fullscreen ? 3 : 2, text: t3("search.action.clear-filters"), tone: "critical" });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "flex-start", gap: 3, justify: "space-between", padding: 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { flex: 1, gap: 2, wrap: "wrap", children: [(0, import_jsx_runtime6.jsx)(DocumentTypesButton, {}), filters == null ? void 0 : filters.map((filter3) => {
    const key2 = getFilterKey(filter3);
    return (0, import_jsx_runtime6.jsx)(FilterButton, { filter: filter3, initialOpen: isMounted.current && lastAddedFilterKey === key2 }, key2);
  }), !fullscreen && (0, import_jsx_runtime6.jsx)(AddFilterButton, {})] }), clearFiltersButtonVisible && !fullscreen && (0, import_jsx_runtime6.jsx)(ClearFiltersButton, {})] }), fullscreen && (0, import_jsx_runtime6.jsxs)(Flex, { justify: "space-between", paddingBottom: 2, paddingX: 2, children: [(0, import_jsx_runtime6.jsx)(AddFilterButton, {}), clearFiltersButtonVisible && (0, import_jsx_runtime6.jsx)(ClearFiltersButton, {})] }), DEBUG_MODE] });
}
function Instructions() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Flex, { align: "center", direction: "column", gap: 4, paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime6.jsx)(Inline, { space: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: (0, import_jsx_runtime6.jsx)(Translate, { t: t3, i18nKey: "search.instructions", components: { ControlsIcon: () => (0, import_jsx_runtime6.jsx)(ControlsIcon, { style: { padding: "0 0.25rem" } }, 0) } }) }) }) });
}
function DocumentTypesPill(_ref534) {
  let { availableCharacters, types: types3 } = _ref534;
  const { t: t3 } = useTranslation2();
  const title = (0, import_react51.useMemo)(() => documentTypesTruncated({ availableCharacters, types: types3, t: t3 }), [availableCharacters, types3, t3]);
  return (0, import_jsx_runtime6.jsx)(Card, { border: true, padding: 2, radius: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: title }) });
}
var __freeze$o2 = Object.freeze;
var __defProp$o2 = Object.defineProperty;
var __template$o2 = (cooked, raw) => __freeze$o2(__defProp$o2(cooked, "raw", { value: __freeze$o2(raw || cooked.slice()) }));
var _a$o2;
var FilterPillCard = st(Card)(_a$o2 || (_a$o2 = __template$o2(["\n  cursor: default;\n"])));
function FilterPill(_ref535) {
  let { filter: filter3 } = _ref535;
  return (0, import_jsx_runtime6.jsx)(FilterPillCard, { border: true, padding: 2, radius: 2, tone: "primary", children: (0, import_jsx_runtime6.jsx)(FilterLabel, { filter: filter3 }) });
}
var __freeze$n2 = Object.freeze;
var __defProp$n2 = Object.defineProperty;
var __template$n2 = (cooked, raw) => __freeze$n2(__defProp$n2(cooked, "raw", { value: __freeze$n2(raw || cooked.slice()) }));
var _a$n2;
var _b$d2;
var _c$b2;
var _d$52;
var DEFAULT_COMBINED_TYPE_COUNT = 40;
var RecentSearchItemButton = st(Button)(_a$n2 || (_a$n2 = __template$n2(["\n  border-radius: ", ";\n  cursor: default;\n  width: 100%;\n"])), (_ref536) => {
  let { theme } = _ref536;
  return rem(theme.sanity.radius[2]);
});
var SearchItemPillsBox = st(Box)(_b$d2 || (_b$d2 = __template$n2(["\n  flex-shrink: 3;\n"])));
var SearchItemQueryBox = st(Box)(_c$b2 || (_c$b2 = __template$n2(["\n  flex-shrink: 2;\n"])));
var CloseButtonDiv = st.div(_d$52 || (_d$52 = __template$n2(["\n  opacity: 0.8;\n  visibility: hidden;\n\n  @media (hover: hover) {\n    ", ":hover & {\n      visibility: visible;\n    }\n    &:hover {\n      opacity: 0.4;\n    }\n  }\n"])), RecentSearchItemButton);
function RecentSearchItem(_ref537) {
  let { index, maxVisibleTypePillChars = DEFAULT_COMBINED_TYPE_COUNT, value, ...rest } = _ref537;
  var _a22;
  const { dispatch, recentSearchesStore } = useSearchState();
  const availableCharacters = maxVisibleTypePillChars - value.query.length;
  const handleClick = (0, import_react51.useCallback)(() => {
    dispatch({ type: "TERMS_SET", filters: value == null ? void 0 : value.filters, terms: value });
    if (recentSearchesStore) {
      const updatedRecentSearches = recentSearchesStore == null ? void 0 : recentSearchesStore.addSearch(value, value == null ? void 0 : value.filters);
      dispatch({ recentSearches: updatedRecentSearches, type: "RECENT_SEARCHES_SET" });
    }
  }, [dispatch, recentSearchesStore, value]);
  const handleDelete = (0, import_react51.useCallback)((event) => {
    event.stopPropagation();
    if (recentSearchesStore) {
      const updatedRecentSearches = recentSearchesStore == null ? void 0 : recentSearchesStore.removeSearchAtIndex(index);
      dispatch({ recentSearches: updatedRecentSearches, type: "RECENT_SEARCHES_SET" });
    }
  }, [dispatch, index, recentSearchesStore]);
  return (0, import_jsx_runtime6.jsx)(Box, { ...rest, children: (0, import_jsx_runtime6.jsx)(RecentSearchItemButton, { mode: "bleed", onClick: handleClick, paddingLeft: 3, paddingRight: 1, paddingY: 1, tabIndex: -1, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "stretch", children: [(0, import_jsx_runtime6.jsxs)(Inline, { paddingY: 2, children: [(0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: (0, import_jsx_runtime6.jsx)(ClockIcon, {}) }), (0, import_jsx_runtime6.jsx)(Text3, { children: "" })] }), (0, import_jsx_runtime6.jsxs)(Flex, { align: "stretch", flex: 1, gap: 2, justify: "flex-start", marginLeft: 3, wrap: "wrap", children: [value.query && (0, import_jsx_runtime6.jsx)(SearchItemQueryBox, { paddingY: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, textOverflow: "ellipsis", children: value.query }) }), value.types.length > 0 && (0, import_jsx_runtime6.jsx)(SearchItemPillsBox, { children: (0, import_jsx_runtime6.jsx)(DocumentTypesPill, { availableCharacters, types: value.types }) }), (_a22 = value == null ? void 0 : value.filters) == null ? void 0 : _a22.map((filter3, i) => {
    return (0, import_jsx_runtime6.jsx)(FilterPill, { filter: filter3 }, i);
  })] }), (0, import_jsx_runtime6.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime6.jsx)(CloseButtonDiv, { onClick: handleDelete, children: (0, import_jsx_runtime6.jsx)(Flex, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(CloseIcon, {}) }) }) }) })] }) }) });
}
var __freeze$m2 = Object.freeze;
var __defProp$m2 = Object.defineProperty;
var __template$m2 = (cooked, raw) => __freeze$m2(__defProp$m2(cooked, "raw", { value: __freeze$m2(raw || cooked.slice()) }));
var _a$m2;
var VIRTUAL_LIST_RECENT_SEARCH_ITEM_HEIGHT = 36;
var MAX_COMBINED_TYPE_COUNT_SMALL = 20;
var MAX_COMBINED_TYPE_COUNT_LARGE = 40;
var RecentSearchesBox = st(Card)(_a$m2 || (_a$m2 = __template$m2(["\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: relative;\n"])));
function RecentSearches(_ref538) {
  let { inputElement } = _ref538;
  const { dispatch, recentSearchesStore, state: { filtersVisible, fullscreen, recentSearches } } = useSearchState();
  const commandListRef = (0, import_react51.useRef)(null);
  const { t: t3 } = useTranslation2();
  const handleClearRecentSearchesClick = (0, import_react51.useCallback)(() => {
    var _a22;
    if (recentSearchesStore) {
      const updatedRecentSearches = recentSearchesStore.removeSearch();
      dispatch({ recentSearches: updatedRecentSearches, type: "RECENT_SEARCHES_SET" });
    }
    (_a22 = commandListRef == null ? void 0 : commandListRef.current) == null ? void 0 : _a22.focusInputElement();
  }, [dispatch, recentSearchesStore]);
  const mediaIndex = useMediaIndex();
  const maxVisibleTypePillChars = (0, import_react51.useMemo)(() => {
    return mediaIndex < 2 ? MAX_COMBINED_TYPE_COUNT_SMALL : MAX_COMBINED_TYPE_COUNT_LARGE;
  }, [mediaIndex]);
  const renderItem = (0, import_react51.useCallback)((item, _ref539) => {
    let { virtualIndex } = _ref539;
    return (0, import_jsx_runtime6.jsx)(RecentSearchItem, { index: virtualIndex, maxVisibleTypePillChars, paddingBottom: 1, value: item });
  }, [maxVisibleTypePillChars]);
  const hasRecentSearches = !!recentSearches.length;
  return (0, import_jsx_runtime6.jsx)(RecentSearchesBox, { borderTop: hasRecentSearches || !hasRecentSearches && !filtersVisible && fullscreen, flex: 1, children: recentSearches.length > 0 ? (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Box, { paddingBottom: 2, paddingTop: 4, paddingX: 3, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: t3("search.recent-searches-label") }) }), (0, import_jsx_runtime6.jsx)(Box, { children: (0, import_jsx_runtime6.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t3("search.recent-searches-aria-label"), inputElement, initialIndex: 0, itemHeight: VIRTUAL_LIST_RECENT_SEARCH_ITEM_HEIGHT, items: recentSearches, paddingX: 2, paddingY: 1, renderItem }) }), (0, import_jsx_runtime6.jsx)(Box, { paddingBottom: 2, paddingTop: 1, paddingX: 2, children: (0, import_jsx_runtime6.jsx)(Button, { fontSize: 1, justify: "flex-start", mode: "bleed", onClick: handleClearRecentSearchesClick, padding: 2, tone: "default", children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: t3("search.action.clear-recent-searches") }) }) })] }) : !filtersVisible && fullscreen && (0, import_jsx_runtime6.jsx)(Instructions, {}) });
}
var __freeze$l2 = Object.freeze;
var __defProp$l2 = Object.defineProperty;
var __template$l2 = (cooked, raw) => __freeze$l2(__defProp$l2(cooked, "raw", { value: __freeze$l2(raw || cooked.slice()) }));
var _a$l2;
var _b$c2;
var _c$a2;
var _d$42;
var rotate2 = ct(_a$l2 || (_a$l2 = __template$l2(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var AnimatedSpinnerIcon2 = st(SpinnerIcon)(_b$c2 || (_b$c2 = __template$l2(["\n  animation: ", " 500ms linear infinite;\n"])), rotate2);
var FilterBox = st(Box)(_c$a2 || (_c$a2 = __template$l2(["\n  position: relative;\n"])));
var NotificationBadge = st.div(_d$42 || (_d$42 = __template$l2(["\n  background: ", ";\n  border-radius: 100%;\n  height: 6px;\n  position: absolute;\n  right: 2px;\n  top: 2px;\n  width: 6px;\n"])), (_ref540) => {
  let { theme } = _ref540;
  var _a22;
  return (_a22 = theme.sanity.color.selectable) == null ? void 0 : _a22.primary.enabled.fg;
});
var SearchHeader = (0, import_react51.forwardRef)(function SearchHeader2(_ref541, ref) {
  let { ariaInputLabel, onClose } = _ref541;
  const isMountedRef = (0, import_react51.useRef)(false);
  const { dispatch, state: { filters, filtersVisible, fullscreen, result: { loading }, terms: { types: types3, query } } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleFiltersToggle = (0, import_react51.useCallback)(() => dispatch({ type: "FILTERS_VISIBLE_SET", visible: !filtersVisible }), [dispatch, filtersVisible]);
  const handleQueryChange = (0, import_react51.useCallback)((e2) => dispatch({ type: "TERMS_QUERY_SET", query: e2.currentTarget.value }), [dispatch]);
  const handleQueryClear = (0, import_react51.useCallback)(() => {
    dispatch({ type: "TERMS_QUERY_SET", query: "" });
  }, [dispatch]);
  (0, import_react51.useEffect)(() => {
    if (!fullscreen) {
      dispatch({ type: "FILTERS_VISIBLE_SET", visible: true });
    }
  }, [dispatch, fullscreen]);
  (0, import_react51.useEffect)(() => {
    isMountedRef.current = true;
  }, []);
  const notificationBadgeVisible = filters.length > 0 || types3.length > 0;
  return (0, import_jsx_runtime6.jsx)(Card, { flex: "none", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", flex: 1, gap: fullscreen ? 2 : 1, padding: fullscreen ? 2 : 1, children: [fullscreen && (0, import_jsx_runtime6.jsx)(Card, { children: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("search.action.close-search-aria-label"), icon: ArrowLeftIcon, mode: "bleed", onClick: onClose }) }), (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(CustomTextInput, { "aria-label": ariaInputLabel, autoComplete: "off", background: fullscreen, border: false, clearButton: !!query, fontSize: 2, icon: loading ? AnimatedSpinnerIcon2 : SearchIcon, onChange: handleQueryChange, onClear: handleQueryClear, placeholder: t3("search.placeholder"), radius: fullscreen ? 2 : 1, ref, smallClearButton: fullscreen, spellCheck: false, value: query }) }), fullscreen && (0, import_jsx_runtime6.jsxs)(FilterBox, { children: [(0, import_jsx_runtime6.jsx)(Button, { "aria-expanded": filtersVisible, "aria-label": t3("search.action.toggle-filters-aria-label", { context: filtersVisible ? "hide" : "show" }), height: "fill", icon: ControlsIcon, mode: "bleed", onClick: handleFiltersToggle, padding: 3, selected: filtersVisible, tone: "default" }), notificationBadgeVisible && (0, import_jsx_runtime6.jsx)(NotificationBadge, {})] })] }) });
});
function NoResults() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsx)(Container, { width: 0, children: (0, import_jsx_runtime6.jsxs)(Stack, { "aria-live": "assertive", space: 4, paddingX: 4, paddingY: 5, children: [(0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, weight: "semibold", children: t3("search.no-results-title") }), (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: t3("search.no-results-help-description") })] }) });
}
var __freeze$k2 = Object.freeze;
var __defProp$k2 = Object.defineProperty;
var __template$k2 = (cooked, raw) => __freeze$k2(__defProp$k2(cooked, "raw", { value: __freeze$k2(raw || cooked.slice()) }));
var _a$k2;
var TextWithToneStyle = st(Text3)((_ref542) => {
  let { $tone, theme } = _ref542;
  const tone = theme.sanity.color.muted[$tone];
  return nt(_a$k2 || (_a$k2 = __template$k2(["\n    &:not([data-muted]) {\n      --card-fg-color: ", ";\n    }\n\n    &[data-dimmed] {\n      opacity: 0.3;\n    }\n  "])), tone ? tone.enabled.fg : void 0);
});
var TextWithTone = import_react51.default.forwardRef(function TextWithTone2(props2, ref) {
  const { tone, dimmed, muted, ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(TextWithToneStyle, { "data-ui": "TextWithTone", "data-dimmed": dimmed ? "" : void 0, "data-muted": muted ? "" : void 0, $tone: tone, muted, ref, ...rest });
});
function SearchError() {
  const { t: t3 } = useTranslation2();
  return (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", "aria-live": "assertive", direction: "column", flex: 1, gap: 3, marginY: 2, padding: 4, children: [(0, import_jsx_runtime6.jsx)(Box, { marginBottom: 1, children: (0, import_jsx_runtime6.jsx)(TextWithTone, { tone: "critical", children: (0, import_jsx_runtime6.jsx)(WarningOutlineIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(TextWithTone, { size: 2, tone: "critical", weight: "semibold", children: t3("search.error.unspecified-error-title") }), (0, import_jsx_runtime6.jsx)(TextWithTone, { size: 1, tone: "critical", children: t3("search.error.unspecified-error-help-description") })] });
}
var ORDERINGS = { createdAsc: { ignoreScore: true, sort: { direction: "asc", field: "_createdAt" }, titleKey: "search.ordering.created-ascending-label" }, createdDesc: { ignoreScore: true, sort: { direction: "desc", field: "_createdAt" }, titleKey: "search.ordering.created-descending-label" }, relevance: { customMeasurementLabel: "relevance", sort: { direction: "desc", field: "_updatedAt" }, titleKey: "search.ordering.best-match-label" }, updatedAsc: { ignoreScore: true, sort: { direction: "asc", field: "_updatedAt" }, titleKey: "search.ordering.updated-ascending-label" }, updatedDesc: { ignoreScore: true, sort: { direction: "desc", field: "_updatedAt" }, titleKey: "search.ordering.updated-descending-label" } };
var __freeze$j2 = Object.freeze;
var __defProp$j2 = Object.defineProperty;
var __template$j2 = (cooked, raw) => __freeze$j2(__defProp$j2(cooked, "raw", { value: __freeze$j2(raw || cooked.slice()) }));
var _a$j2;
var MENU_ORDERINGS = [ORDERINGS.relevance, { type: "divider" }, ORDERINGS.createdAsc, ORDERINGS.createdDesc, { type: "divider" }, ORDERINGS.updatedAsc, ORDERINGS.updatedDesc];
var SortMenuContentFlex = st(Flex)(_a$j2 || (_a$j2 = __template$j2(["\n  box-sizing: border-box;\n"])));
function isSearchDivider(item) {
  return item.type === "divider";
}
function CustomMenuItem(_ref543) {
  let { ordering } = _ref543;
  const { t: t3 } = useTranslation2();
  const { dispatch, state: { ordering: currentOrdering } } = useSearchState();
  const handleClick = (0, import_react51.useCallback)(() => {
    dispatch({ ordering, type: "ORDERING_SET" });
  }, [dispatch, ordering]);
  const isSelected = (0, import_react51.useMemo)(() => (0, import_isEqual5.default)(currentOrdering, ordering), [currentOrdering, ordering]);
  return (0, import_jsx_runtime6.jsx)(MenuItem, { onClick: handleClick, padding: 3, pressed: isSelected, tone: "default", children: (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "space-between", paddingRight: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "medium", children: t3(ordering.titleKey) }) }) });
}
function SortMenu() {
  const { t: t3 } = useTranslation2();
  const { state: { ordering } } = useSearchState();
  const menuButtonId = (0, import_react51.useId)();
  const currentMenuItem = MENU_ORDERINGS.find((item) => (0, import_isEqual5.default)(ordering, item) && !isSearchDivider(item));
  if (!currentMenuItem) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(Card, { borderBottom: true, children: (0, import_jsx_runtime6.jsx)(SortMenuContentFlex, { align: "center", flex: 1, padding: 2, children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { mode: "bleed", padding: 2, children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 1, justify: "space-between", children: [(0, import_jsx_runtime6.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: (0, import_jsx_runtime6.jsx)(SortIcon, {}) }) }), (0, import_jsx_runtime6.jsx)(Inline, { space: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, weight: "medium", children: t3(currentMenuItem.titleKey) }) })] }) }), id: menuButtonId || "", menu: (0, import_jsx_runtime6.jsx)(Menu, { children: MENU_ORDERINGS.map((item, index) => {
    if (isSearchDivider(item)) {
      return (0, import_jsx_runtime6.jsx)(MenuDivider, {}, index);
    }
    return (0, import_jsx_runtime6.jsx)(CustomMenuItem, { ordering: item }, index);
  }) }), placement: "bottom-start", popover: { portal: true, radius: 2 } }) }) });
}
var __freeze$i2 = Object.freeze;
var __defProp$i2 = Object.defineProperty;
var __template$i2 = (cooked, raw) => __freeze$i2(__defProp$i2(cooked, "raw", { value: __freeze$i2(raw || cooked.slice()) }));
var _a$i2;
var DebugScoreCard = st(Card)(_a$i2 || (_a$i2 = __template$i2(["\n  cursor: help;\n  left: 0;\n  position: absolute;\n  top: 0;\n"])));
function DebugOverlay(_ref544) {
  let { data } = _ref544;
  const { score: score2 } = data;
  let tone = "default";
  if (score2 <= 0.1) {
    tone = "critical";
  } else if (score2 >= 0.5) {
    tone = "primary";
  }
  const matchingStories = data.stories.filter((story) => story.score > 0);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Stack, { space: 2, children: matchingStories.length ? (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: matchingStories.map((story) => (0, import_jsx_runtime6.jsxs)(Inline, { space: 3, children: [(0, import_jsx_runtime6.jsx)(Code, { size: 0, weight: "semibold", children: story.path }), (0, import_jsx_runtime6.jsx)(Code, { size: 0, children: story.why })] }, story.path)) }) : (0, import_jsx_runtime6.jsx)(Code, { size: 0, children: "No matches" }) }) }), placement: "bottom-start", portal: true, children: (0, import_jsx_runtime6.jsx)(DebugScoreCard, { padding: 1, shadow: 1, tone, children: (0, import_jsx_runtime6.jsxs)(Code, { size: 0, children: ["score: ", score2] }) }) }) });
}
var __freeze$h2 = Object.freeze;
var __defProp$h2 = Object.defineProperty;
var __template$h2 = (cooked, raw) => __freeze$h2(__defProp$h2(cooked, "raw", { value: __freeze$h2(raw || cooked.slice()) }));
var _a$h2;
var VIRTUAL_LIST_SEARCH_RESULT_ITEM_HEIGHT = 59;
var VIRTUAL_LIST_OVERSCAN = 4;
var SearchResultsInnerFlex = st(Flex)(_a$h2 || (_a$h2 = __template$h2(["\n  opacity: ", ";\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: relative;\n  transition: 300ms opacity;\n  width: 100%;\n"])), (_ref545) => {
  let { $loading } = _ref545;
  return $loading ? 0.5 : 1;
});
function SearchResults(_ref546) {
  let { inputElement } = _ref546;
  const { dispatch, onClose, recentSearchesStore, setSearchCommandList, state: { debug: debug5, filters, fullscreen, lastActiveIndex, result, terms } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const hasSearchResults = !!result.hits.length;
  const hasNoSearchResults = !result.hits.length && result.loaded;
  const hasError = result.error;
  const handleSearchResultClick = (0, import_react51.useCallback)(() => {
    if (recentSearchesStore) {
      const updatedRecentSearches = recentSearchesStore.addSearch(terms, filters);
      dispatch({ recentSearches: updatedRecentSearches, type: "RECENT_SEARCHES_SET" });
    }
    onClose == null ? void 0 : onClose();
  }, [dispatch, filters, onClose, recentSearchesStore, terms]);
  const renderItem = (0, import_react51.useCallback)((item) => {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(SearchResultItem, { documentId: getPublishedId(item.hit._id) || "", documentType: item.hit._type, onClick: handleSearchResultClick, paddingBottom: 2 }), debug5 && (0, import_jsx_runtime6.jsx)(DebugOverlay, { data: item })] });
  }, [debug5, handleSearchResultClick]);
  return (0, import_jsx_runtime6.jsx)(Flex, { children: (0, import_jsx_runtime6.jsx)(Card, { borderTop: fullscreen || !!(hasError || hasSearchResults || hasNoSearchResults), flex: 1, children: (0, import_jsx_runtime6.jsxs)(Flex, { direction: "column", height: "fill", children: [hasSearchResults && (0, import_jsx_runtime6.jsx)(SortMenu, {}), (0, import_jsx_runtime6.jsx)(SearchResultsInnerFlex, { $loading: result.loading, "aria-busy": result.loading, flex: 1, children: hasError ? (0, import_jsx_runtime6.jsx)(SearchError, {}) : (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [hasSearchResults && (0, import_jsx_runtime6.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t3("search.search-results-label"), fixedHeight: true, initialIndex: lastActiveIndex, inputElement, itemHeight: VIRTUAL_LIST_SEARCH_RESULT_ITEM_HEIGHT, items: result.hits, overscan: VIRTUAL_LIST_OVERSCAN, padding: 2, paddingBottom: 0, ref: setSearchCommandList, renderItem }), hasNoSearchResults && (0, import_jsx_runtime6.jsx)(NoResults, {})] }) })] }) }) });
}
var __freeze$g2 = Object.freeze;
var __defProp$g2 = Object.defineProperty;
var __template$g2 = (cooked, raw) => __freeze$g2(__defProp$g2(cooked, "raw", { value: __freeze$g2(raw || cooked.slice()) }));
var _a$g2;
var _b$b2;
var InnerCard = st(Card)(_a$g2 || (_a$g2 = __template$g2(["\n  flex-direction: column;\n  overflow: hidden;\n  overflow: clip;\n  pointer-events: all;\n  position: relative;\n"])));
var SearchDialogBox = st(Box)(_b$b2 || (_b$b2 = __template$g2(["\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  overflow: clip;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 1;\n"])));
function SearchDialog(_ref547) {
  let { onClose, onOpen, open } = _ref547;
  const [inputElement, setInputElement] = (0, import_react51.useState)(null);
  const { scheme } = useColorScheme();
  const { t: t3 } = useTranslation2();
  const { state: { filtersVisible, terms } } = useSearchState();
  const hasValidTerms = hasSearchableTerms({ terms });
  return (0, import_jsx_runtime6.jsx)(SearchWrapper, { hasValidTerms, onClose, onOpen, open, children: (0, import_jsx_runtime6.jsx)(Portal, { children: (0, import_jsx_runtime6.jsx)(es2015_default, { autoFocus: !supportsTouch, returnFocus: true, children: (0, import_jsx_runtime6.jsx)(SearchDialogBox, { children: (0, import_jsx_runtime6.jsxs)(InnerCard, { display: "flex", height: "fill", scheme, tone: "default", children: [(0, import_jsx_runtime6.jsx)(SearchHeader, { ariaInputLabel: hasValidTerms ? t3("search.search-results-aria-label") : t3("search.recent-searches-aria-label"), onClose, ref: setInputElement }), filtersVisible && (0, import_jsx_runtime6.jsx)(Card, { borderTop: true, flex: "none", children: (0, import_jsx_runtime6.jsx)(Filters, {}) }), hasValidTerms ? (0, import_jsx_runtime6.jsx)(SearchResults, { inputElement }) : (0, import_jsx_runtime6.jsx)(RecentSearches, { inputElement })] }) }) }) }) });
}
var __freeze$f2 = Object.freeze;
var __defProp$f2 = Object.defineProperty;
var __template$f2 = (cooked, raw) => __freeze$f2(__defProp$f2(cooked, "raw", { value: __freeze$f2(raw || cooked.slice()) }));
var _a$f2;
var _b$a2;
var _c$92;
var KeyboardShortcutFlex = st(Flex)(_a$f2 || (_a$f2 = __template$f2(["\n  position: absolute;\n  right: 0;\n  top: 0;\n\n  & > :first-child {\n    margin-right: 1px;\n  }\n"])));
var PlaceholderSearchInputFlex = st(Flex)(_b$a2 || (_b$a2 = __template$f2(["\n  min-width: 253px;\n  max-width: 350px;\n  position: relative;\n"])));
var PlaceholderTextInput = st(TextInput)(_c$92 || (_c$92 = __template$f2(["\n  padding-right: 60px;\n"])));
var PlaceholderSearchInput = (0, import_react51.forwardRef)(function DummyInput(_ref548, ref) {
  let { onOpen } = _ref548;
  var _a22;
  const { dispatch, state: { terms } } = useSearchState();
  const { t: t3 } = useTranslation2();
  const handleChange = (0, import_react51.useCallback)((event) => {
    dispatch({ type: "TERMS_QUERY_SET", query: event.currentTarget.value });
    onOpen();
  }, [dispatch, onOpen]);
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    if (event.key === "Enter") {
      onOpen();
    }
  }, [onOpen]);
  return (0, import_jsx_runtime6.jsxs)(PlaceholderSearchInputFlex, { align: "center", children: [(0, import_jsx_runtime6.jsx)(PlaceholderTextInput, { "aria-autocomplete": "list", "aria-expanded": "false", autoComplete: "off", icon: SearchIcon, "data-testid": "studio-search", onChange: handleChange, onClick: onOpen, onKeyDown: handleKeyDown, placeholder: (_a22 = t3("search.placeholder")) != null ? _a22 : void 0, radius: 2, ref, role: "combobox", value: terms.query }), (0, import_jsx_runtime6.jsxs)(KeyboardShortcutFlex, { align: "center", height: "fill", marginRight: 2, children: [(0, import_jsx_runtime6.jsx)(KBD, { children: GLOBAL_SEARCH_KEY_MODIFIER }), (0, import_jsx_runtime6.jsx)(KBD, { children: GLOBAL_SEARCH_KEY.toUpperCase() })] })] });
});
var __freeze$e2 = Object.freeze;
var __defProp$e2 = Object.defineProperty;
var __template$e2 = (cooked, raw) => __freeze$e2(__defProp$e2(cooked, "raw", { value: __freeze$e2(raw || cooked.slice()) }));
var _a$e2;
var _b$92;
var _c$82;
var _d$32;
var Overlay = st.div(_a$e2 || (_a$e2 = __template$e2(["\n  background-color: ", ";\n  bottom: 0;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n"])), (_ref549) => {
  let { theme } = _ref549;
  return theme.sanity.color.base.shadow.ambient;
});
var SearchPopoverCard = st(Card)(_d$32 || (_d$32 = __template$e2(["\n  ", "\n  display: flex !important;\n  flex-direction: column;\n  max-height: ", ";\n  position: absolute;\n  top: ", "px;\n  width: min(calc(100vw - ", "px), ", "px);\n"])), (_ref550) => {
  let { $position } = _ref550;
  return $position.x ? nt(_b$92 || (_b$92 = __template$e2(["\n          left: ", "px;\n        "])), $position.x) : nt(_c$82 || (_c$82 = __template$e2(["\n          left: 50%;\n          transform: translateX(-50%);\n        "])));
}, (_ref551) => {
  let { $position } = _ref551;
  return "min(calc(100vh - ".concat($position.y, "px - ").concat(POPOVER_INPUT_PADDING, "px), ").concat(POPOVER_MAX_HEIGHT, "px)");
}, (_ref552) => {
  let { $position } = _ref552;
  return $position.y;
}, POPOVER_INPUT_PADDING * 2, POPOVER_MAX_WIDTH);
function SearchPopover(_ref553) {
  let { disableFocusLock, onClose, onOpen, open, position } = _ref553;
  const [popoverElement, setPopoverElement] = (0, import_react51.useState)(null);
  const [inputElement, setInputElement] = (0, import_react51.useState)(null);
  const { isTopLayer, zIndex } = useLayer();
  const { scheme } = useColorScheme();
  const { t: t3 } = useTranslation2();
  const { onClose: onSearchClose, state: { filtersVisible, terms } } = useSearchState();
  const hasValidTerms = hasSearchableTerms({ terms });
  const handleClickOutside = (0, import_react51.useCallback)(() => {
    if (isTopLayer && onSearchClose && open) {
      onSearchClose();
    }
  }, [isTopLayer, onSearchClose, open]);
  useClickOutside(handleClickOutside, [popoverElement]);
  return (0, import_jsx_runtime6.jsx)(SearchWrapper, { hasValidTerms, onClose, onOpen, open, children: (0, import_jsx_runtime6.jsx)(Portal, { children: (0, import_jsx_runtime6.jsxs)(es2015_default, { autoFocus: !supportsTouch, disabled: disableFocusLock, returnFocus: true, children: [(0, import_jsx_runtime6.jsx)(Overlay, { style: { zIndex } }), (0, import_jsx_runtime6.jsxs)(SearchPopoverCard, { $position: position, overflow: "hidden", radius: POPOVER_RADIUS, ref: setPopoverElement, scheme, shadow: 2, style: { zIndex }, children: [(0, import_jsx_runtime6.jsx)(SearchHeader, { ariaInputLabel: hasValidTerms ? t3("search.search-results-aria-label") : t3("search.recent-searches-aria-label"), onClose, ref: setInputElement }), filtersVisible && (0, import_jsx_runtime6.jsx)(Card, { borderTop: true, flex: "none", children: (0, import_jsx_runtime6.jsx)(Filters, {}) }), hasValidTerms ? (0, import_jsx_runtime6.jsx)(SearchResults, { inputElement }) : (0, import_jsx_runtime6.jsx)(RecentSearches, { inputElement })] })] }) }) });
}
function SearchField() {
  const [placeholderElement, setPlaceholderElement] = (0, import_react51.useState)(null);
  const [open, setOpen] = (0, import_react51.useState)(false);
  const handleClose = (0, import_react51.useCallback)(() => setOpen(false), []);
  const handleOpen = (0, import_react51.useCallback)(() => setOpen(true), []);
  const popoverPosition = usePopoverPosition(placeholderElement);
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(PlaceholderSearchInput, { onOpen: handleOpen, ref: setPlaceholderElement }), popoverPosition && (0, import_jsx_runtime6.jsx)(SearchPopover, { onClose: handleClose, onOpen: handleOpen, open, position: popoverPosition })] });
}
function calcDialogPosition(element) {
  const placeholderRect = element.getBoundingClientRect();
  return { x: window.innerWidth - placeholderRect.x > POPOVER_MAX_WIDTH ? placeholderRect.x - POPOVER_INPUT_PADDING : null, y: placeholderRect.y - POPOVER_INPUT_PADDING };
}
function usePopoverPosition(element) {
  const [popoverPosition, setPopoverPosition] = (0, import_react51.useState)(null);
  const handleWindowResize = (0, import_react51.useCallback)(() => {
    if (element) {
      setPopoverPosition(calcDialogPosition(element));
    }
  }, [element]);
  (0, import_react51.useEffect)(() => {
    if (element) {
      setPopoverPosition(calcDialogPosition(element));
    }
  }, [element]);
  (0, import_react51.useEffect)(() => {
    window.addEventListener("resize", handleWindowResize);
    return () => window.removeEventListener("resize", handleWindowResize);
  }, [handleWindowResize]);
  return popoverPosition;
}
var RECENT_SEARCHES_KEY = "search::recent";
var MAX_RECENT_SEARCHES = 5;
var RECENT_SEARCH_VERSION = 2;
function createRecentSearchesStore(_ref554) {
  let { dataset: dataset2, fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2, projectId: projectId2, schema, user, version = RECENT_SEARCH_VERSION } = _ref554;
  if (!dataset2 || !projectId2 || !supportsLocalStorage || !user) {
    return void 0;
  }
  const lsKey = "".concat(RECENT_SEARCHES_KEY, "__").concat(projectId2, ":").concat(dataset2, ":").concat(user.id);
  return {
    /**
    * Write a search term to Local Storage and return updated recent searches.
    */
    addSearch: (searchTerm, filters) => {
      const storedFilters = (filters || []).map((filter3) => ({ fieldId: filter3.fieldId, filterName: filter3.filterName, operatorType: filter3.operatorType, value: filter3.value }));
      const validStoredFilters = storedFilters.filter((filter3) => validateFilter({ fieldDefinitions, filter: filter3, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 }));
      const newSearchItem = { created: (/* @__PURE__ */ new Date()).toISOString(), filters: validStoredFilters, terms: { query: searchTerm.query.trim(), typeNames: searchTerm.types.map((s) => s.name) } };
      const comparator = JSON.stringify((0, import_omit5.default)(newSearchItem, "created"));
      const newRecent = { version, recentSearches: [newSearchItem, ...getRecentStoredSearch(lsKey, version).recentSearches.filter((r2) => {
        return JSON.stringify((0, import_omit5.default)(r2, "created")) !== comparator;
      })].slice(0, MAX_RECENT_SEARCHES) };
      window.localStorage.setItem(lsKey, JSON.stringify(newRecent));
      return getRecentSearchTerms({ fieldDefinitions, filterDefinitions: filterDefinitions2, lsKey, operatorDefinitions: operatorDefinitions2, schema, version });
    },
    /**
    * Fetch all recent searches from Local Storage.
    * Invalid search terms will be filtered out and terms will be re-written to Local Storage.
    */
    getRecentSearches: () => getRecentSearchTerms({ fieldDefinitions, filterDefinitions: filterDefinitions2, lsKey, operatorDefinitions: operatorDefinitions2, schema, version }),
    /**
    * Remove all search terms from Local Storage and return updated recent searches.
    */
    removeSearch: () => {
      const searchTerms = getRecentStoredSearch(lsKey, version);
      const newRecent = { ...searchTerms, recentSearches: [] };
      window.localStorage.setItem(lsKey, JSON.stringify(newRecent));
      return getRecentSearchTerms({ fieldDefinitions, filterDefinitions: filterDefinitions2, lsKey, operatorDefinitions: operatorDefinitions2, schema, version });
    },
    /**
    * Remove a search term from Local Storage and return updated recent searches.
    */
    removeSearchAtIndex: (index) => {
      const searchTerms = getRecentStoredSearch(lsKey, version);
      if (index < 0 || index > searchTerms.recentSearches.length) {
        return getRecentSearchTerms({ fieldDefinitions, filterDefinitions: filterDefinitions2, lsKey, operatorDefinitions: operatorDefinitions2, schema, version });
      }
      const newRecent = { ...searchTerms, recentSearches: [...searchTerms.recentSearches.slice(0, index), ...searchTerms.recentSearches.slice(index + 1)] };
      window.localStorage.setItem(lsKey, JSON.stringify(newRecent));
      return getRecentSearchTerms({ fieldDefinitions, filterDefinitions: filterDefinitions2, lsKey, operatorDefinitions: operatorDefinitions2, schema, version });
    }
  };
}
function getRecentStoredSearch(lsKey, version) {
  const recentString = supportsLocalStorage ? window.localStorage.getItem(lsKey) : void 0;
  return recentString ? JSON.parse(recentString) : { version, recentSearches: [] };
}
function getRecentSearchTerms(_ref555) {
  let { lsKey, schema, fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2, version } = _ref555;
  const storedSearchTerms = verifySearchVersionNumber({ lsKey, storedSearch: getRecentStoredSearch(lsKey, version) });
  return sanitizeStoredSearch({ studioSchema: schema, storedSearch: storedSearchTerms, lsKey, filterDefinitions: filterDefinitions2, fieldDefinitions, operatorDefinitions: operatorDefinitions2, version }).recentSearches.filter((r2) => !!r2.terms).map((r2, index) => ({ __recent: { index, timestamp: new Date(r2.created).getTime() }, filters: r2.filters, query: r2.terms.query, types: r2.terms.typeNames.map((typeName) => schema.get(typeName)).filter((s) => !!(s && s.jsonType === "object")) }));
}
function verifySearchVersionNumber(_ref556) {
  let { lsKey, storedSearch } = _ref556;
  if (storedSearch.version !== RECENT_SEARCH_VERSION) {
    const newStoredSearch = { version: RECENT_SEARCH_VERSION, recentSearches: [] };
    window.localStorage.setItem(lsKey, JSON.stringify(newStoredSearch));
    return newStoredSearch;
  }
  return storedSearch;
}
function sanitizeStoredSearch(_ref557) {
  let { fieldDefinitions, filterDefinitions: filterDefinitions2, lsKey, operatorDefinitions: operatorDefinitions2, storedSearch, studioSchema, version } = _ref557;
  const searchableTypeNames = getSearchableOmnisearchTypes(studioSchema).map((schema) => schema.name);
  const filteredSearch = storedSearch.recentSearches.filter((recentSearch) => {
    return (
      // Has valid searchable types (not hidden by omnisearch)
      recentSearch.terms.typeNames.every((typeName) => searchableTypeNames.includes(typeName)) && recentSearch.filters.every((filter3) => validateFilter({ fieldDefinitions, filter: filter3, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 }))
    );
  });
  const newStoredSearch = { version: RECENT_SEARCH_VERSION, recentSearches: filteredSearch };
  if (newStoredSearch.recentSearches.length < storedSearch.recentSearches.length) {
    window.localStorage.setItem(lsKey, JSON.stringify(newStoredSearch));
  }
  return getRecentStoredSearch(lsKey, version);
}
var MAX_OBJECT_TRAVERSAL_DEPTH = 3;
function createFieldDefinitions(schema, filterDefinitions2) {
  var _a4;
  const searchableDocumentTypeNames = getSearchableOmnisearchTypes(schema).map((s) => s.name);
  const { documentTypes, objectTypes } = (((_a4 = schema._original) == null ? void 0 : _a4.types) || []).filter((t3) => isDocumentObjectDefinition(t3) ? searchableDocumentTypeNames.includes(t3.name) : true).filter((schemaType) => schemaType.name !== "slug").filter((schemaType) => !schemaType.name.startsWith("sanity.")).reduce((acc, schemaType) => {
    if (isDocumentObjectDefinition(schemaType)) {
      acc.documentTypes[schemaType.name] = schemaType;
    }
    if (isObjectDefinition(schemaType)) {
      acc.objectTypes[schemaType.name] = schemaType;
    }
    return acc;
  }, { documentTypes: {}, objectTypes: {} }) || { documentTypes: {}, objectTypes: {} };
  const supportedFieldTypes = getSupportedFieldTypes(filterDefinitions2);
  return getDocumentFieldDefinitions(supportedFieldTypes, documentTypes, objectTypes);
}
function createFieldDefinitionDictionary(fieldDefinitions) {
  return fieldDefinitions.reduce((acc, val) => {
    acc[val.id] = val;
    return acc;
  }, {});
}
function generateFieldId(field) {
  return [field.type, field.fieldPath, field.filterName, field.documentTypes.join(",")].join("-");
}
function getDocumentFieldDefinitions(supportedFieldTypes, documentTypes, objectTypes) {
  function addFieldDefinitionRecursive(_ref558) {
    let { acc, defType, depth = 0, documentType, prevFieldPath, prevTitlePath } = _ref558;
    var _a4;
    const continueRecursion = depth <= MAX_OBJECT_TRAVERSAL_DEPTH;
    const isInternalField = defType.name.startsWith("_");
    const title = (defType == null ? void 0 : defType.title) ? sanitizeFieldValue(defType.title) : (0, import_startCase3.default)(defType.name);
    const fieldPath = prevFieldPath ? "".concat(prevFieldPath, ".").concat(defType.name) : defType.name;
    const titlePath = prevTitlePath ? [...prevTitlePath, title] : [title];
    if (!continueRecursion)
      return;
    const existingObject = objectTypes[defType.type];
    const existingDocument = documentTypes[defType.type];
    const inlineObject = isObjectDefinition(defType) ? defType : null;
    const targetObject = existingDocument || existingObject || inlineObject;
    if (targetObject) {
      (_a4 = targetObject == null ? void 0 : targetObject.fields) == null ? void 0 : _a4.forEach((field) => addFieldDefinitionRecursive({ acc, defType: field, depth: depth + 1, documentType, prevFieldPath: fieldPath, prevTitlePath: titlePath }));
      return;
    }
    if (!supportedFieldTypes.includes(defType.type))
      return;
    acc.push({ documentTypes: documentType && !isInternalField ? [documentType] : [], fieldPath, filterName: resolveFilterName(defType), id: "", name: defType.name, titlePath, title, type: defType.type });
  }
  const fieldDefinitions = Object.values(documentTypes).reduce((acc, documentType) => {
    const documentFields = documentType.fields.reduce((a, field) => {
      addFieldDefinitionRecursive({ acc: a, defType: field, documentType: documentType.name });
      return a;
    }, []);
    acc.push(...documentFields);
    return acc;
  }, []).reduce((acc, val) => {
    const prevIndex = acc.findIndex((v) => v.fieldPath === val.fieldPath && v.title === val.title && v.type === val.type);
    if (prevIndex > -1) {
      acc[prevIndex] = { ...acc[prevIndex], documentTypes: [...acc[prevIndex].documentTypes, ...val.documentTypes] };
    } else {
      acc.push(val);
    }
    return acc;
  }, []).map(addFieldDefinitionId).sort(sortFieldDefinitions);
  return fieldDefinitions;
}
function addFieldDefinitionId(field) {
  return { ...field, id: generateFieldId(field) };
}
function isArrayOfPrimitives(schemaType) {
  var _a4;
  if (isArrayDefinition(schemaType)) {
    return schemaType.of.every((item) => ["boolean", "number", "string"].includes(item.type)) && (((_a4 = schemaType.options) == null ? void 0 : _a4.list) ? schemaType.options.list.length > 0 : false);
  }
  return false;
}
function isArrayDefinition(schemaType) {
  return schemaType.type === "array";
}
function isDocumentObjectDefinition(schemaType) {
  return schemaType.type === "document";
}
function isObjectDefinition(schemaType) {
  return schemaType.type === "object";
}
function isStringDefinition(schemaType) {
  return schemaType.type === "string";
}
function isStringListDefinition(schemaType) {
  var _a4;
  if (isStringDefinition(schemaType)) {
    return ((_a4 = schemaType.options) == null ? void 0 : _a4.list) ? schemaType.options.list.length > 0 : false;
  }
  return false;
}
function resolveFilterName(schemaType) {
  if (isStringListDefinition(schemaType)) {
    return "stringList";
  }
  if (isArrayDefinition(schemaType)) {
    if (schemaType.of.some((item) => item.type === "reference")) {
      return "arrayReferences";
    }
    if (schemaType.of.find((item) => item.type === "block")) {
      return "portableText";
    }
    if (isArrayOfPrimitives(schemaType)) {
      return "arrayList";
    }
  }
  return schemaType.type;
}
function sortFieldDefinitions(a, b) {
  const aTitlePath = a.titlePath.slice(0, -1).join("/");
  const bTitlePath = b.titlePath.slice(0, -1).join("/");
  return a.title.localeCompare(b.title) || aTitlePath.localeCompare(bTitlePath) || a.fieldPath.localeCompare(b.fieldPath);
}
function isRecentSearchTerms(terms) {
  return typeof terms.__recent !== "undefined";
}
var rootName2 = "core:studio:navbar:search:";
(0, import_debug5.default)(rootName2);
function debugWithName2(name) {
  const namespace = "".concat(rootName2).concat(name);
  if (import_debug5.default && import_debug5.default.enabled(namespace)) {
    return (0, import_debug5.default)(namespace);
  }
  return (0, import_debug5.default)(rootName2);
}
function isDebugMode() {
  return typeof window === "undefined" ? false : window.location.hash.slice(1).split(";").includes(DEBUG_FRAGMENT);
}
function initialSearchState(_ref559) {
  let { currentUser, fullscreen, recentSearches = [], definitions } = _ref559;
  return { currentUser, debug: isDebugMode(), documentTypesNarrowed: [], filters: [], filtersVisible: true, fullscreen, lastActiveIndex: -1, ordering: ORDERINGS.relevance, pageIndex: 0, recentSearches, result: { error: null, hasMore: null, hits: [], loaded: false, loading: false }, terms: { query: "", types: [] }, definitions };
}
var debug4 = debugWithName2("reducer");
function searchReducer(state, action) {
  let prefix = "";
  if (action.type.startsWith("SEARCH_REQUEST")) {
    prefix = "";
  }
  if (action.type.startsWith("RECENT_SEARCHES")) {
    prefix = "";
  }
  debug4(prefix, action);
  switch (action.type) {
    case "FILTERS_VISIBLE_SET":
      return { ...state, filtersVisible: action.visible };
    case "LAST_ACTIVE_INDEX_SET":
      return { ...state, lastActiveIndex: action.index };
    case "ORDERING_RESET":
      return { ...state, ordering: ORDERINGS.relevance, terms: stripRecent(state.terms) };
    case "ORDERING_SET":
      return { ...state, ordering: action.ordering, terms: stripRecent(state.terms) };
    case "PAGE_INCREMENT":
      return { ...state, pageIndex: state.pageIndex + 1, terms: stripRecent(state.terms) };
    case "RECENT_SEARCHES_SET":
      return { ...state, recentSearches: action.recentSearches };
    case "SEARCH_CLEAR":
      return { ...state, pageIndex: 0, result: { ...state.result, hasMore: null, hits: [] } };
    case "SEARCH_REQUEST_COMPLETE":
      return { ...state, result: { ...state.result, error: null, hasMore: action.hits.length > 0, hits: state.pageIndex > 0 ? [...state.result.hits, ...action.hits] : action.hits, loaded: true, loading: false } };
    case "SEARCH_REQUEST_ERROR":
      return { ...state, result: { ...state.result, error: action.error, loaded: false, loading: false } };
    case "SEARCH_REQUEST_START":
      return { ...state, result: { ...state.result, loaded: false, loading: true } };
    case "TERMS_FILTERS_ADD": {
      const newFilter = { ...action.filter, value: getOperatorInitialValue(state.definitions.operators, action.filter.operatorType) };
      const filters = [...state.filters, newFilter];
      return { ...state, documentTypesNarrowed: narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters, types: state.terms.types }), filters, lastAddedFilter: newFilter, terms: { ...state.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, filters, operatorDefinitions: state.definitions.operators }) } };
    }
    case "TERMS_FILTERS_CLEAR": {
      const filters = [];
      return { ...state, documentTypesNarrowed: narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters, types: state.terms.types }), filters, terms: { ...state.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, filters, operatorDefinitions: state.definitions.operators }) } };
    }
    case "TERMS_FILTERS_REMOVE": {
      const index = state.filters.findIndex((filter3) => getFilterKey(filter3) === action.filterKey);
      const filters = [
        ...state.filters.slice(0, index),
        //
        ...state.filters.slice(index + 1)
      ];
      return { ...state, documentTypesNarrowed: narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters, types: state.terms.types }), filters, terms: { ...state.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, filters, operatorDefinitions: state.definitions.operators }) } };
    }
    case "TERMS_FILTERS_SET_OPERATOR": {
      const matchedFilter = state.filters.find((filter3) => getFilterKey(filter3) === action.filterKey);
      const currentOperator = getOperatorDefinition(state.definitions.operators, matchedFilter == null ? void 0 : matchedFilter.operatorType);
      const nextOperator = getOperatorDefinition(state.definitions.operators, action.operatorType);
      const nextInitialValue = nextOperator == null ? void 0 : nextOperator.initialValue;
      const inputComponentChanged = (currentOperator == null ? void 0 : currentOperator.inputComponent) != (nextOperator == null ? void 0 : nextOperator.inputComponent);
      const filters = state.filters.map((filter3) => {
        if (getFilterKey(filter3) === action.filterKey) {
          return { ...filter3, operatorType: action.operatorType, ...inputComponentChanged ? { value: nextInitialValue } : {} };
        }
        return filter3;
      });
      return { ...state, filters, terms: { ...state.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, filters, operatorDefinitions: state.definitions.operators }) } };
    }
    case "TERMS_FILTERS_SET_VALUE": {
      const filters = state.filters.map((filter3) => {
        if (getFilterKey(filter3) === action.filterKey) {
          return { ...filter3, value: action.value };
        }
        return filter3;
      });
      return { ...state, filters, terms: { ...state.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, filters, operatorDefinitions: state.definitions.operators }) } };
    }
    case "TERMS_QUERY_SET":
      return { ...state, pageIndex: 0, result: { ...state.result, loaded: false }, terms: stripRecent({ ...state.terms, query: action.query }) };
    case "TERMS_SET": {
      const filters = action.filters || [];
      const types3 = [
        ...state.terms.types || [],
        //
        ...action.terms.types
      ].sort(sortTypes);
      return { ...state, documentTypesNarrowed: narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters, types: types3 }), filters, lastAddedFilter: null, pageIndex: 0, result: { ...state.result, loaded: false }, terms: { ...action.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, filters, operatorDefinitions: state.definitions.operators }) } };
    }
    case "TERMS_TYPE_ADD": {
      const types3 = [
        ...state.terms.types || [],
        //
        action.schemaType
      ].sort(sortTypes);
      const documentTypesNarrowed = narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters: [], types: types3 });
      const filters = state.filters.filter((f) => {
        const fieldDefinition = getFieldFromFilter(state.definitions.fields, f);
        if (fieldDefinition) {
          if (fieldDefinition.documentTypes.length === 0) {
            return true;
          }
          return documentTypesNarrowed.every((type) => fieldDefinition.documentTypes.findIndex((t3) => t3 === type) > -1);
        }
        return true;
      });
      return { ...state, documentTypesNarrowed, filters, pageIndex: 0, result: { ...state.result, loaded: false }, terms: stripRecent({ ...state.terms, filter: generateFilterQuery({ fieldDefinitions: state.definitions.fields, filterDefinitions: state.definitions.filters, operatorDefinitions: state.definitions.operators, filters }), types: types3 }) };
    }
    case "TERMS_TYPE_REMOVE": {
      const types3 = (state.terms.types || []).filter((s) => s !== action.schemaType);
      return { ...state, documentTypesNarrowed: narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters: state.filters, types: types3 }), pageIndex: 0, result: { ...state.result, loaded: false }, terms: stripRecent({ ...state.terms, types: types3 }) };
    }
    case "TERMS_TYPES_CLEAR": {
      const types3 = [];
      return { ...state, documentTypesNarrowed: narrowDocumentTypes({ fieldDefinitions: state.definitions.fields, filters: state.filters, types: types3 }), pageIndex: 0, result: { ...state.result, loaded: false }, terms: stripRecent({ ...state.terms, types: [] }) };
    }
    default:
      return state;
  }
}
function stripRecent(terms) {
  if (isRecentSearchTerms(terms)) {
    const { __recent, ...rest } = terms;
    return rest;
  }
  return terms;
}
function SearchProvider(_ref560) {
  let { children, fullscreen } = _ref560;
  const onCloseRef = (0, import_react51.useRef)(null);
  const [searchCommandList, setSearchCommandList] = (0, import_react51.useState)(null);
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const schema = useSchema();
  const currentUser = useCurrentUser();
  const { search: { operators: operators2, filters } } = useSource();
  const { dataset: dataset2, projectId: projectId2 } = client.config();
  const { fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 } = (0, import_react51.useMemo)(() => {
    return { fieldDefinitions: createFieldDefinitionDictionary(createFieldDefinitions(schema, filters)), filterDefinitions: createFilterDefinitionDictionary(filters), operatorDefinitions: createOperatorDefinitionDictionary(operators2) };
  }, [filters, operators2, schema]);
  const recentSearchesStore = (0, import_react51.useMemo)(() => createRecentSearchesStore({ dataset: dataset2, fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2, projectId: projectId2, schema, user: currentUser, version: RECENT_SEARCH_VERSION }), [currentUser, dataset2, fieldDefinitions, filterDefinitions2, operatorDefinitions2, projectId2, schema]);
  const recentSearches = (0, import_react51.useMemo)(() => recentSearchesStore == null ? void 0 : recentSearchesStore.getRecentSearches(), [recentSearchesStore]);
  const initialState = (0, import_react51.useMemo)(() => initialSearchState({ currentUser, fullscreen, recentSearches, definitions: { fields: fieldDefinitions, operators: operatorDefinitions2, filters: filterDefinitions2 } }), [currentUser, fieldDefinitions, filterDefinitions2, fullscreen, operatorDefinitions2, recentSearches]);
  const [state, dispatch] = (0, import_react51.useReducer)(searchReducer, initialState);
  const { documentTypesNarrowed, filters: currentFilters, ordering, pageIndex, result, terms } = state;
  const isMountedRef = (0, import_react51.useRef)(false);
  const previousOrderingRef = (0, import_react51.useRef)(initialState.ordering);
  const previousPageIndexRef = (0, import_react51.useRef)(initialState.pageIndex);
  const previousTermsRef = (0, import_react51.useRef)(initialState.terms);
  const { handleSearch, searchState } = useSearch({ initialState: { ...result, terms }, onComplete: (hits) => dispatch({ hits, type: "SEARCH_REQUEST_COMPLETE" }), onError: (error2) => dispatch({ error: error2, type: "SEARCH_REQUEST_ERROR" }), onStart: () => dispatch({ type: "SEARCH_REQUEST_START" }), schema });
  const hasValidTerms = hasSearchableTerms({ terms });
  const documentTypes = documentTypesNarrowed.map((documentType) => schema.get(documentType));
  const completeFilters = currentFilters.filter((filter3) => validateFilter({ fieldDefinitions, filter: filter3, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 }));
  const handleSetOnClose = (0, import_react51.useCallback)((onClose) => {
    onCloseRef.current = onClose;
  }, []);
  (0, import_react51.useEffect)(() => {
    const orderingChanged = !(0, import_isEqual5.default)(ordering, previousOrderingRef.current);
    const pageIndexChanged = pageIndex !== previousPageIndexRef.current;
    const termsChanged = !(0, import_isEqual5.default)(terms, previousTermsRef.current);
    if (orderingChanged || pageIndexChanged || termsChanged) {
      const sortLabel = (ordering == null ? void 0 : ordering.customMeasurementLabel) || "".concat(ordering.sort.field, " ").concat(ordering.sort.direction);
      handleSearch({ options: {
        // Comments prepended to each query for future measurement
        comments: [...isRecentSearchTerms(terms) ? ["findability-recent-search:".concat(terms.__recent.index)] : [], "findability-selected-types:".concat(terms.types.length), "findability-sort:".concat(sortLabel), "findability-source: global", "findability-filter-count:".concat(completeFilters.length)],
        limit: SEARCH_LIMIT,
        offset: pageIndex * SEARCH_LIMIT,
        skipSortByScore: ordering.ignoreScore,
        sort: [ordering.sort]
      }, terms: {
        ...terms,
        // Narrow document type search
        ...documentTypes ? { types: documentTypes } : {}
      } });
      previousPageIndexRef.current = pageIndex;
    }
    previousOrderingRef.current = ordering;
    previousTermsRef.current = terms;
  }, [completeFilters.length, currentFilters, documentTypes, handleSearch, hasValidTerms, ordering, pageIndex, searchState.terms, terms]);
  (0, import_react51.useEffect)(() => {
    if (!hasValidTerms && (isMountedRef == null ? void 0 : isMountedRef.current) && result.hits.length > 0) {
      dispatch({ type: "SEARCH_CLEAR" });
    }
    isMountedRef.current = true;
  }, [dispatch, hasValidTerms, result.hits, terms.query, terms.types]);
  return (0, import_jsx_runtime6.jsx)(SearchContext.Provider, { value: { dispatch, onClose: onCloseRef == null ? void 0 : onCloseRef.current, recentSearchesStore, searchCommandList, setSearchCommandList, setOnClose: handleSetOnClose, state: { ...state, fullscreen } }, children });
}
var SANITY_VERSION = "3.21.1";
function getHelpResources(client, locale) {
  return client.withConfig({ apiVersion: "1" }).observable.request({
    url: "/help",
    /*
    query and tag is used by analytics for tracking.
    Builds to: `{m: ['sanity@3.0.2']}' and serializes to: `?m=sanity@3.0.2`.
    Final format will be e.g. https://api.sanity.io/v1/help?tag=sanity.studio.module.version-check&m=sanity%403.0.2
    */
    query: { m: ["sanity@".concat(SANITY_VERSION)], locale },
    tag: "module.version-check",
    json: true
  });
}
function useGetHelpResources() {
  const client = useClient({ apiVersion: "1" });
  const locale = useCurrentLocale();
  const moduleStatus$ = (0, import_react51.useMemo)(() => getHelpResources(client, locale), [client, locale]);
  return useLoadable(moduleStatus$);
}
function ResourcesMenuItems(_ref561) {
  let { error: error2, isLoading, value } = _ref561;
  var _a4;
  const sections = (_a4 = value == null ? void 0 : value.resources) == null ? void 0 : _a4.sectionArray;
  const latestStudioVersion = value == null ? void 0 : value.latestVersion;
  const { t: t3 } = useTranslation2();
  if (isLoading) {
    return (0, import_jsx_runtime6.jsx)(Flex, { align: "center", justify: "center", padding: 3, children: (0, import_jsx_runtime6.jsx)(Spinner, {}) });
  }
  const fallbackLinks = (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", text: t3("help-resources.action.join-our-community"), size: 0, href: "https://www.sanity.io/exchange/community", target: "_blank", muted: false }), (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", text: t3("help-resources.action.help-and-support"), size: 0, href: "https://www.sanity.io/contact/support", target: "_blank", muted: false }), (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", text: t3("help-resources.action.contact-sales"), size: 0, href: "https://www.sanity.io/contact/sales?ref=studio", target: "_blank", muted: false }), (0, import_jsx_runtime6.jsx)(MenuDivider, {})] });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(value === void 0 || error2) && (0, import_jsx_runtime6.jsx)("div", { children: fallbackLinks }), !error2 && (sections == null ? void 0 : sections.map((subSection) => {
    if (!subSection)
      return null;
    return (0, import_jsx_runtime6.jsx)(SubSection, { subSection }, subSection._key);
  })), (0, import_jsx_runtime6.jsxs)(Box, { padding: 3, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, weight: "medium", textOverflow: "ellipsis", children: t3("help-resources.studio-version", { studioVersion: SANITY_VERSION }) }), !error2 && latestStudioVersion && (0, import_jsx_runtime6.jsx)(Box, { paddingTop: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, muted: true, textOverflow: "ellipsis", children: t3("help-resources.latest-sanity-version", { latestVersion: latestStudioVersion }) }) })] })] });
}
function SubSection(_ref562) {
  let { subSection } = _ref562;
  var _a4;
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [subSection.sectionTitle && (0, import_jsx_runtime6.jsx)(Card, { padding: 2, paddingTop: 3, marginLeft: 1, children: (0, import_jsx_runtime6.jsx)(Label, { muted: true, size: 1, children: subSection.sectionTitle }) }), (_a4 = subSection == null ? void 0 : subSection.items) == null ? void 0 : _a4.map((item) => {
    if (!item || !item.title)
      return null;
    switch (item._type) {
      case "externalLink":
        if (!item.url)
          return null;
        return (0, import_jsx_runtime6.jsx)(MenuItem, { as: "a", tone: "default", text: item.title, size: 0, href: item.url, target: "_blank" }, item._key);
      case "internalAction":
        if (!item.type)
          return null;
        return item.type === "show-welcome-modal" && (0, import_jsx_runtime6.jsx)(MenuItem, { text: item.title, size: 0 }, item._key);
      default:
        return null;
    }
  }), (0, import_jsx_runtime6.jsx)(MenuDivider, {})] });
}
var __freeze$d2 = Object.freeze;
var __defProp$d2 = Object.defineProperty;
var __template$d2 = (cooked, raw) => __freeze$d2(__defProp$d2(cooked, "raw", { value: __freeze$d2(raw || cooked.slice()) }));
var _a$d2;
var StyledMenu = st(Menu)(_a$d2 || (_a$d2 = __template$d2(["\n  max-width: 300px;\n  min-width: 200px;\n"])));
function ResourcesButton() {
  const { scheme } = useColorScheme();
  const [menuOpen, setMenuOpen] = (0, import_react51.useState)(false);
  const { t: t3 } = useTranslation2();
  const { value, error: error2, isLoading } = useGetHelpResources();
  const handleOnOpen = (0, import_react51.useCallback)(() => setMenuOpen(true), []);
  const handleOnClose = (0, import_react51.useCallback)(() => setMenuOpen(false), []);
  return (0, import_jsx_runtime6.jsx)(Flex, { children: (0, import_jsx_runtime6.jsx)(Tooltip, { content: (0, import_jsx_runtime6.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: t3("help-resources.title") }) }), scheme, placement: "bottom", portal: true, disabled: menuOpen, children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(MenuButton, { button: (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("help-resources.title"), icon: HelpCircleIcon, mode: "bleed", fontSize: 2 }), id: "menu-button-resources", menu: (0, import_jsx_runtime6.jsx)(StyledMenu, { children: (0, import_jsx_runtime6.jsx)(ResourcesMenuItems, { error: error2, isLoading, value }) }), popover: { constrainSize: true, placement: "bottom", portal: true, scheme }, onClose: handleOnClose, onOpen: handleOnOpen }) }) }) });
}
var __freeze$c2 = Object.freeze;
var __defProp$c2 = Object.defineProperty;
var __template$c2 = (cooked, raw) => __freeze$c2(__defProp$c2(cooked, "raw", { value: __freeze$c2(raw || cooked.slice()) }));
var _a$c2;
var _b$82;
var _c$72;
var RootLayer = st(Layer)(_a$c2 || (_a$c2 = __template$c2(["\n  min-height: auto;\n  position: relative;\n\n  &[data-search-open='true'] {\n    top: 0;\n    position: sticky;\n  }\n"])));
var RootCard = st(Card)(_b$82 || (_b$82 = __template$c2(["\n  line-height: 0;\n"])));
var LeftFlex = st(Flex)(_c$72 || (_c$72 = __template$c2(["\n  width: max-content;\n"])));
function StudioNavbar() {
  const { name, tools, ...workspace } = useWorkspace();
  const theme = useRootTheme().theme;
  const workspaces = useWorkspaces();
  const routerState = useRouterState();
  const { scheme } = useColorScheme();
  const { href: rootHref, onClick: handleRootClick } = useStateLink({ state: {} });
  const mediaIndex = useMediaIndex();
  const activeToolName = typeof routerState.tool === "string" ? routerState.tool : void 0;
  const newDocumentOptions = useNewDocumentOptions();
  const { onSearchFullscreenOpenChange, searchFullscreenOpen, searchFullscreenPortalEl } = (0, import_react51.useContext)(NavbarContext);
  const Logo = useLogoComponent();
  const ToolMenu = useToolMenuComponent();
  const [drawerOpen, setDrawerOpen] = (0, import_react51.useState)(false);
  const routerStateRef = (0, import_react51.useRef)(routerState);
  const workspaceNameRef = (0, import_react51.useRef)(name);
  const { t: t3 } = useTranslation2();
  (0, import_react51.useEffect)(() => {
    if (routerStateRef.current.tool !== routerState.tool || name !== workspaceNameRef.current) {
      setDrawerOpen(false);
    }
    routerStateRef.current = routerState;
    workspaceNameRef.current = name;
  }, [name, routerState]);
  const [drawerButtonEl, setDrawerButtonEl] = (0, import_react51.useState)(null);
  const [searchOpenButtonEl, setSearchOpenButtonEl] = (0, import_react51.useState)(null);
  const shouldRender = (0, import_react51.useMemo)(() => ({ brandingCenter: mediaIndex <= 1, resources: mediaIndex > 1, collapsedPresenceMenu: mediaIndex <= 1, loginStatus: mediaIndex > 1, searchFullscreen: mediaIndex <= 1, configIssues: mediaIndex > 1 && isDev, workspaces: mediaIndex >= 3 && workspaces.length > 1, tools: mediaIndex >= 3 }), [mediaIndex, workspaces.length]);
  const formattedName = typeof name === "string" && name !== "root" ? (0, import_startCase2.default)(name) : null;
  const title = workspace.title || formattedName || "Studio";
  (0, import_react51.useEffect)(() => {
    onSearchFullscreenOpenChange(searchFullscreenOpen);
  }, [searchFullscreenOpen, onSearchFullscreenOpenChange]);
  (0, import_react51.useEffect)(() => {
    if (onSearchFullscreenOpenChange && !shouldRender.searchFullscreen) {
      onSearchFullscreenOpenChange(false);
    }
  }, [onSearchFullscreenOpenChange, shouldRender.searchFullscreen]);
  const handleOpenSearchFullscreen = (0, import_react51.useCallback)(() => {
    onSearchFullscreenOpenChange(true);
  }, [onSearchFullscreenOpenChange]);
  const handleCloseSearchFullscreen = (0, import_react51.useCallback)(() => {
    onSearchFullscreenOpenChange(false);
    searchOpenButtonEl == null ? void 0 : searchOpenButtonEl.focus();
  }, [onSearchFullscreenOpenChange, searchOpenButtonEl]);
  const handleCloseDrawer = (0, import_react51.useCallback)(() => {
    setDrawerOpen(false);
    drawerButtonEl == null ? void 0 : drawerButtonEl.focus();
  }, [drawerButtonEl]);
  const handleOpenDrawer = (0, import_react51.useCallback)(() => {
    setDrawerOpen(true);
  }, []);
  return (0, import_jsx_runtime6.jsxs)(RootLayer, { zOffset: 100, "data-search-open": searchFullscreenOpen, children: [(0, import_jsx_runtime6.jsx)(RootCard, { "data-testid": "navbar", "data-ui": "Navbar", padding: 2, scheme: "dark", shadow: theme.__legacy || scheme === "dark" ? 1 : void 0, sizing: "border", children: (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", justify: "space-between", children: [(0, import_jsx_runtime6.jsxs)(LeftFlex, { align: "center", flex: shouldRender.brandingCenter ? void 0 : 1, children: [!shouldRender.tools && (0, import_jsx_runtime6.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime6.jsx)(Button, { mode: "bleed", icon: MenuIcon, onClick: handleOpenDrawer, ref: setDrawerButtonEl }) }), !shouldRender.brandingCenter && (0, import_jsx_runtime6.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime6.jsx)(LogoButton, { href: rootHref, onClick: handleRootClick, title, children: (0, import_jsx_runtime6.jsx)(Logo, { title }) }) }), shouldRender.workspaces && (0, import_jsx_runtime6.jsx)(Box, { marginRight: 2, children: (0, import_jsx_runtime6.jsx)(WorkspaceMenuButton, { collapsed: true }) }), (0, import_jsx_runtime6.jsx)(Box, { marginRight: shouldRender.brandingCenter ? void 0 : 2, children: (0, import_jsx_runtime6.jsx)(NewDocumentButton, { ...newDocumentOptions, modal: shouldRender.brandingCenter ? "dialog" : "popover" }) }), (0, import_jsx_runtime6.jsx)(LayerProvider, { children: (0, import_jsx_runtime6.jsx)(SearchProvider, { fullscreen: shouldRender.searchFullscreen, children: (0, import_jsx_runtime6.jsxs)(BoundaryElementProvider, { element: document.body, children: [(0, import_jsx_runtime6.jsx)(PortalProvider, { element: searchFullscreenPortalEl, children: shouldRender.searchFullscreen && (0, import_jsx_runtime6.jsx)(SearchDialog, { onClose: handleCloseSearchFullscreen, onOpen: handleOpenSearchFullscreen, open: searchFullscreenOpen }) }), !shouldRender.searchFullscreen && (0, import_jsx_runtime6.jsx)(SearchField, {})] }) }) }), shouldRender.tools && (0, import_jsx_runtime6.jsx)(Card, { flex: 1, marginX: 2, overflow: "visible", paddingRight: 1, children: (0, import_jsx_runtime6.jsx)(ToolMenu, { activeToolName, closeSidebar: handleCloseDrawer, context: "topbar", isSidebarOpen: false, tools }) })] }), shouldRender.brandingCenter && (0, import_jsx_runtime6.jsx)(Box, { marginX: 1, children: (0, import_jsx_runtime6.jsx)(LogoButton, { href: rootHref, onClick: handleRootClick, title, children: (0, import_jsx_runtime6.jsx)(Logo, { title }) }) }), (0, import_jsx_runtime6.jsxs)(Flex, { gap: 2, children: [(shouldRender.configIssues || shouldRender.resources) && (0, import_jsx_runtime6.jsx)(Card, { borderRight: true, children: (0, import_jsx_runtime6.jsxs)(Flex, { gap: 1, paddingX: 2, children: [shouldRender.configIssues && (0, import_jsx_runtime6.jsx)(ConfigIssuesButton, {}), shouldRender.resources && (0, import_jsx_runtime6.jsx)(ResourcesButton, {})] }) }), (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 1, children: [(0, import_jsx_runtime6.jsx)(PresenceMenu, { collapse: shouldRender.collapsedPresenceMenu }), shouldRender.tools && (0, import_jsx_runtime6.jsx)(UserMenu, {}), shouldRender.searchFullscreen && (0, import_jsx_runtime6.jsx)(Button, { "aria-label": t3("search.action-open-aria-label"), icon: SearchIcon, mode: "bleed", onClick: handleOpenSearchFullscreen, ref: setSearchOpenButtonEl })] })] })] }) }), !shouldRender.tools && (0, import_jsx_runtime6.jsx)(NavDrawer, { activeToolName, isOpen: drawerOpen, onClose: handleCloseDrawer, tools })] });
}
var ToolLink = (0, import_react51.forwardRef)(function ToolLink2(props2, ref) {
  const { name, ...rest } = props2;
  const state = useRouterState((0, import_react51.useCallback)(() => ({
    tool: name,
    // make sure to clear tool state when navigating to another tool
    [name]: void 0
  }), [name]));
  return (0, import_jsx_runtime6.jsx)(StateLink, { state, ...rest, ref });
});
function ToolCollapseMenu(props2) {
  const { activeToolName, tools } = props2;
  const { scheme } = useColorScheme();
  const [collapseMenuEl, setCollapseMenuEl] = (0, import_react51.useState)(null);
  useRovingFocus({ rootElement: collapseMenuEl, navigation: ["arrows"] });
  const menuButtonProps = (0, import_react51.useMemo)(() => ({ popover: { constrainSize: true, portal: true, scheme } }), [scheme]);
  const children = (0, import_react51.useMemo)(() => tools.map((tool, index) => {
    const title = (tool == null ? void 0 : tool.title) || (0, import_startCase2.default)(tool.name) || void 0;
    const Link3 = (0, import_react51.forwardRef)(function Link22(linkProps, ref) {
      return (0, import_jsx_runtime6.jsx)(ToolLink, { ...linkProps, ref, name: tool.name });
    });
    return (0, import_jsx_runtime6.jsx)(CollapseMenuButton, { as: Link3, "data-as": "a", collapsedProps: { tooltipText: tool.title }, icon: tool.icon || UnknownIcon, mode: "bleed", selected: activeToolName === tool.name, text: title, tooltipProps: { scheme } }, "".concat(tool.name, "-").concat(index));
  }), [activeToolName, scheme, tools]);
  return (0, import_jsx_runtime6.jsx)(CollapseMenu, { "data-testid": "tool-collapse-menu", gap: 1, menuButtonProps, ref: setCollapseMenuEl, children });
}
function ToolVerticalMenu(props2) {
  const { activeToolName, isVisible, tools } = props2;
  return (0, import_react51.useMemo)(() => (0, import_jsx_runtime6.jsx)(Stack, { as: "ul", space: 1, children: tools.map((tool) => {
    const title = (tool == null ? void 0 : tool.title) || (0, import_startCase2.default)(tool.name) || void 0;
    const Link3 = (0, import_react51.forwardRef)(function Link22(linkProps, ref) {
      return (0, import_jsx_runtime6.jsx)(ToolLink, { ...linkProps, ref, name: tool.name });
    });
    return (0, import_jsx_runtime6.jsx)(Stack, { as: "li", children: (0, import_jsx_runtime6.jsx)(Button, { as: Link3, icon: tool.icon || PlugIcon, justify: "flex-start", mode: "bleed", selected: activeToolName === tool.name, tabIndex: isVisible ? 0 : -1, text: title }) }, tool.name);
  }) }), [activeToolName, isVisible, tools]);
}
function StudioToolMenu(props2) {
  const { context, isSidebarOpen, ...restProps } = props2;
  if (context === "sidebar") {
    return (0, import_jsx_runtime6.jsx)(ToolVerticalMenu, { isVisible: isSidebarOpen, ...restProps });
  }
  return (0, import_jsx_runtime6.jsx)(ToolCollapseMenu, { ...restProps });
}
function pickToolMenuComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.studio) == null ? void 0 : _a4.components) == null ? void 0 : _b4.toolMenu;
}
function pickNavbarComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.studio) == null ? void 0 : _a4.components) == null ? void 0 : _b4.navbar;
}
function pickLayoutComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.studio) == null ? void 0 : _a4.components) == null ? void 0 : _b4.layout;
}
function pickLogoComponent(plugin) {
  var _a4, _b4;
  return (_b4 = (_a4 = plugin.studio) == null ? void 0 : _a4.components) == null ? void 0 : _b4.logo;
}
function useToolMenuComponent() {
  return useMiddlewareComponents({ defaultComponent: StudioToolMenu, pick: pickToolMenuComponent });
}
function useNavbarComponent() {
  return useMiddlewareComponents({ defaultComponent: StudioNavbar, pick: pickNavbarComponent });
}
function useLogoComponent() {
  return useMiddlewareComponents({ defaultComponent: StudioLogo, pick: pickLogoComponent });
}
function useLayoutComponent() {
  return useMiddlewareComponents({ defaultComponent: StudioLayoutComponent, pick: pickLayoutComponent });
}
var __freeze$b2 = Object.freeze;
var __defProp$b2 = Object.defineProperty;
var __template$b2 = (cooked, raw) => __freeze$b2(__defProp$b2(cooked, "raw", { value: __freeze$b2(raw || cooked.slice()) }));
var _a$b2;
var SearchFullscreenPortalCard = st(Card)(_a$b2 || (_a$b2 = __template$b2(["\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  overflow: clip;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 200;\n"])));
var NavbarContext = (0, import_react51.createContext)({ onSearchFullscreenOpenChange: () => "", searchFullscreenOpen: false, searchFullscreenPortalEl: null });
function StudioLayout() {
  const Layout2 = useLayoutComponent();
  return (0, import_jsx_runtime6.jsx)(Layout2, {});
}
function StudioLayoutComponent() {
  var _a22;
  const { name, title, tools } = useWorkspace();
  const router = useRouter();
  const activeToolName = useRouterState((0, import_react51.useCallback)((routerState) => typeof routerState.tool === "string" ? routerState.tool : void 0, []));
  const activeTool = (0, import_react51.useMemo)(() => tools.find((tool) => tool.name === activeToolName), [activeToolName, tools]);
  const [searchFullscreenOpen, setSearchFullscreenOpen] = (0, import_react51.useState)(false);
  const [searchFullscreenPortalEl, setSearchFullscreenPortalEl] = (0, import_react51.useState)(null);
  const documentTitle = (0, import_react51.useMemo)(() => {
    const mainTitle = title || (0, import_startCase2.default)(name);
    if (activeToolName) {
      return "".concat((0, import_startCase2.default)(activeToolName), " | ").concat(mainTitle);
    }
    return mainTitle;
  }, [activeToolName, name, title]);
  const toolControlsDocumentTitle = !!(activeTool == null ? void 0 : activeTool.controlsDocumentTitle);
  (0, import_react51.useEffect)(() => {
    if (toolControlsDocumentTitle) {
      return;
    }
    document.title = documentTitle;
  }, [documentTitle, toolControlsDocumentTitle]);
  const handleSearchFullscreenOpenChange = (0, import_react51.useCallback)((open) => {
    setSearchFullscreenOpen(open);
  }, []);
  const navbarContextValue = (0, import_react51.useMemo)(() => ({ searchFullscreenOpen, searchFullscreenPortalEl, onSearchFullscreenOpenChange: handleSearchFullscreenOpenChange }), [searchFullscreenOpen, searchFullscreenPortalEl, handleSearchFullscreenOpenChange]);
  const Navbar = useNavbarComponent();
  const isLegacyDeskRedirect = !activeTool && (activeToolName === "desk" || !activeToolName) && typeof window !== "undefined" && /\/desk(\/|$)/.test(window.location.pathname) && tools.some((tool) => tool.name === "structure");
  (0, import_react51.useEffect)(() => {
    if (!isLegacyDeskRedirect) {
      return;
    }
    router.navigateUrl({ path: window.location.pathname.replace(/\/desk/, "/structure"), replace: true });
  }, [isLegacyDeskRedirect, router]);
  return (0, import_jsx_runtime6.jsxs)(Flex, { "data-ui": "ToolScreen", direction: "column", height: "fill", "data-testid": "studio-layout", children: [(0, import_jsx_runtime6.jsx)(NavbarContext.Provider, { value: navbarContextValue, children: (0, import_jsx_runtime6.jsx)(Navbar, {}) }), isLegacyDeskRedirect && (0, import_jsx_runtime6.jsx)(RedirectingScreen, {}), tools.length === 0 && (0, import_jsx_runtime6.jsx)(NoToolsScreen, {}), tools.length > 0 && !activeTool && activeToolName && !isLegacyDeskRedirect && (0, import_jsx_runtime6.jsx)(ToolNotFoundScreen, { toolName: activeToolName }), searchFullscreenOpen && (0, import_jsx_runtime6.jsx)(SearchFullscreenPortalCard, { ref: setSearchFullscreenPortalEl, overflow: "auto" }), (0, import_jsx_runtime6.jsx)(StudioErrorBoundary, { heading: "The ".concat(activeTool == null ? void 0 : activeTool.name, " tool crashed"), children: (0, import_jsx_runtime6.jsx)(Card, { flex: 1, hidden: searchFullscreenOpen, children: activeTool && activeToolName && (0, import_jsx_runtime6.jsx)(RouteScope, { scope: activeToolName, __unsafe_disableScopedSearchParams: (_a22 = activeTool.router) == null ? void 0 : _a22.__unsafe_disableScopedSearchParams, children: (0, import_jsx_runtime6.jsx)(import_react51.Suspense, { fallback: (0, import_jsx_runtime6.jsx)(LoadingTool, {}), children: (0, import_react51.createElement)(activeTool.component, { tool: activeTool }) }) }) }) }, activeTool == null ? void 0 : activeTool.name)] });
}
function LoadingTool() {
  return (0, import_jsx_runtime6.jsxs)(Flex, { justify: "center", align: "center", height: "fill", direction: "column", gap: 4, children: [(0, import_jsx_runtime6.jsx)(Text3, { muted: true, children: "Loading" }), (0, import_jsx_runtime6.jsx)(Spinner, { muted: true })] });
}
function Studio(props2) {
  const { basePath, config, onSchemeChange, scheme, unstable_globalStyles: globalStyles2, unstable_history, unstable_noAuthBoundary } = props2;
  return (0, import_jsx_runtime6.jsxs)(StudioProvider, { basePath, config, onSchemeChange, scheme, unstable_history, unstable_noAuthBoundary, children: [globalStyles2 && (0, import_jsx_runtime6.jsx)(GlobalStyle, {}), (0, import_jsx_runtime6.jsx)(StudioLayout, {})] });
}
function renderStudio(rootElement, config) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (!rootElement) {
    throw new Error("Missing root element to mount application into");
  }
  const opts = typeof options === "boolean" ? { reactStrictMode: options } : options;
  const { reactStrictMode = false, basePath } = opts;
  const root = (0, import_client2.createRoot)(rootElement);
  root.render(reactStrictMode ? (0, import_jsx_runtime6.jsx)(import_react51.StrictMode, { children: (0, import_jsx_runtime6.jsx)(Studio, { config, basePath, unstable_globalStyles: true }) }) : (0, import_jsx_runtime6.jsx)(Studio, { config, basePath, unstable_globalStyles: true }));
  return () => root.unmount();
}
function LocaleProvider(props2) {
  const { projectId: projectId2, name: sourceId, i18n: { locales }, __internal: { i18next } } = useSource();
  return (0, import_jsx_runtime6.jsx)(LocaleProviderBase, { ...props2, projectId: projectId2, sourceId, locales, i18next });
}
function LocaleProviderBase(_ref563) {
  let { projectId: projectId2, sourceId, locales, i18next, children } = _ref563;
  const subscribe = (0, import_react51.useCallback)((callback) => {
    i18next.on("languageChanged", callback);
    return () => i18next.off("languageChanged", callback);
  }, [i18next]);
  const currentLocale = (0, import_react51.useSyncExternalStore)(subscribe, () => i18next.language);
  const context = (0, import_react51.useMemo)(() => ({ locales, currentLocale, __internal: { i18next }, changeLocale: async (newLocale) => {
    storePreferredLocale(projectId2, sourceId, newLocale);
    await i18next.changeLanguage(newLocale);
  } }), [currentLocale, i18next, locales, projectId2, sourceId]);
  return (0, import_jsx_runtime6.jsx)(import_react51.Suspense, { fallback: (0, import_jsx_runtime6.jsx)(LoadingScreen, {}), children: (0, import_jsx_runtime6.jsx)(I18nextProvider, { i18n: i18next, children: (0, import_jsx_runtime6.jsx)(LocaleContext.Provider, { value: context, children }, currentLocale) }) });
}
var PREVIEW_MEDIA_SIZE = { block: { width: 33, height: 33 }, blockImage: { width: 600, height: 400 }, default: { width: 35, height: 35 }, detail: { width: 75, height: 75 }, inline: { width: 15, height: 15 }, media: { width: 160, height: 160 } };
var PREVIEW_ICON_SIZE = { block: 31, blockImage: 45, default: 33, detail: 45, inline: 15, media: 45 };
var __freeze$a2 = Object.freeze;
var __defProp$a2 = Object.defineProperty;
var __template$a2 = (cooked, raw) => __freeze$a2(__defProp$a2(cooked, "raw", { value: __freeze$a2(raw || cooked.slice()) }));
var _a$a2;
var MediaWrapper = st.span((props2) => {
  const { $dimensions, $layout, $radius, $responsive } = props2;
  const width = $dimensions.width || 0;
  const height = $dimensions.width || 0;
  const iconSize = PREVIEW_ICON_SIZE[$layout];
  return nt(_a$a2 || (_a$a2 = __template$a2(["\n    position: relative;\n    width: ", ";\n    height: ", ";\n    min-width: ", ";\n    border-radius: ", ";\n    display: flex;\n    overflow: hidden;\n    overflow: clip;\n    align-items: center;\n    justify-content: center;\n\n    & img {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      object-fit: contain;\n      border-radius: inherit;\n    }\n\n    & svg {\n      display: block;\n      flex: 1;\n      font-size: calc(21 / 16 * 1em);\n    }\n\n    & [data-sanity-icon] {\n      display: block;\n      font-size: calc(", ' / 16 * 1em);\n    }\n\n    /*\n      NOTE on why we cant use the ":after" pseudo-element:\n      The thing is we only want the shadow when then <MediaWrapper> contains\n      something else than <svg>  icons should not have the shadow.\n      This is why we use the "*:not(svg) + span" selector to target only that\n      situation to render the shadow.\n    */\n    & *:not(svg) + span {\n      display: block;\n      position: absolute;\n      left: 0;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      box-shadow: inset 0 0 0 1px var(--card-fg-color);\n      opacity: 0.2;\n      border-radius: inherit;\n    }\n  '])), $responsive ? "100%" : rem(width), $responsive ? "100%" : rem(height), $responsive ? void 0 : rem(width), (_ref564) => {
    let { theme } = _ref564;
    return rem(theme.sanity.radius[$radius]);
  }, iconSize);
});
MediaWrapper.displayName = "MediaWrapper";
function Media(props2) {
  const { border: border2 = true, dimensions, layout: layout2, media, radius = 1, responsive = false, styles } = props2;
  return (0, import_jsx_runtime6.jsxs)(MediaWrapper, { $dimensions: dimensions, $layout: layout2, $radius: radius, $responsive: responsive, className: styles == null ? void 0 : styles.media, "data-testid": "Media", children: [renderMedia({ dimensions, layout: layout2, media }), border2 && (0, import_jsx_runtime6.jsx)("span", {})] });
}
function renderMedia(props2) {
  const { dimensions, layout: layout2, media, styles } = props2;
  if ((0, import_react_is2.isValidElementType)(media)) {
    return (0, import_react51.createElement)(media, { dimensions, layout: layout2 });
  }
  if (typeof media === "string") {
    return (0, import_jsx_runtime6.jsx)(Text3, { as: "span", className: styles == null ? void 0 : styles.mediaString, children: media });
  }
  if ((0, import_react51.isValidElement)(media)) {
    return media;
  }
  return null;
}
function renderPreviewMedia(value, layout2, dimensions) {
  if ((0, import_react_is2.isValidElementType)(value)) {
    return (0, import_react51.createElement)(value, { layout: layout2, dimensions });
  }
  if (typeof value === "string") {
    return (0, import_jsx_runtime6.jsx)("div", { children: value });
  }
  return value;
}
function renderPreviewNode(value, layout2, fallbackNode) {
  if (typeof value === "string") {
    return value;
  }
  if ((0, import_react_is2.isValidElementType)(value)) {
    return (0, import_react51.createElement)(value, { layout: layout2 });
  }
  return value || fallbackNode;
}
var __freeze$92 = Object.freeze;
var __defProp$92 = Object.defineProperty;
var __template$92 = (cooked, raw) => __freeze$92(__defProp$92(cooked, "raw", { value: __freeze$92(raw || cooked.slice()) }));
var _a$92;
var _b$72;
var _c$62;
var DEFAULT_MEDIA_DIMENSIONS$5 = { ...PREVIEW_MEDIA_SIZE.default, aspect: 1, fit: "crop", dpr: getDevicePixelRatio() };
var Root$32 = st(Flex)(_a$92 || (_a$92 = __template$92(["\n  height: ", ";\n"])), rem(PREVIEW_MEDIA_SIZE.default.height));
var TitleSkeleton$2 = st(TextSkeleton).attrs({ animated: true, radius: 1 })(_b$72 || (_b$72 = __template$92(["\n  max-width: ", ";\n  width: 80%;\n"])), rem(160));
var SubtitleSkeleton$2 = st(TextSkeleton).attrs({ animated: true, radius: 1, size: 1 })(_c$62 || (_c$62 = __template$92(["\n  max-width: ", ";\n  width: 60%;\n"])), rem(120));
function DefaultPreview(props2) {
  const { title, subtitle, media, status, isPlaceholder, children, styles } = props2;
  const { t: t3 } = useTranslation2();
  const rootClassName = (0, import_classnames.default)(styles == null ? void 0 : styles.root, Boolean(subtitle) && (styles == null ? void 0 : styles.hasSubtitle));
  const statusNode = status && (0, import_jsx_runtime6.jsx)(Box, { className: styles == null ? void 0 : styles.status, "data-testid": "default-preview__status", paddingLeft: 3, paddingRight: 1, children: renderPreviewNode(status, "default") });
  if (isPlaceholder) {
    return (0, import_jsx_runtime6.jsxs)(Root$32, { align: "center", className: styles == null ? void 0 : styles.placeholder, "data-testid": "default-preview", children: [media !== false && (0, import_jsx_runtime6.jsx)(Skeleton, { animated: true, marginRight: 2, radius: 2, style: PREVIEW_MEDIA_SIZE.default }), (0, import_jsx_runtime6.jsxs)(Stack, { "data-testid": "default-preview__heading", flex: 1, paddingLeft: media === false ? 1 : 2, paddingRight: status ? 0 : 1, space: 2, children: [(0, import_jsx_runtime6.jsx)(TitleSkeleton$2, {}), (0, import_jsx_runtime6.jsx)(SubtitleSkeleton$2, {})] }), statusNode] });
  }
  return (0, import_jsx_runtime6.jsxs)(Root$32, { align: "center", className: rootClassName, "data-testid": "default-preview", children: [media !== false && media !== void 0 && (0, import_jsx_runtime6.jsx)(Media, { dimensions: DEFAULT_MEDIA_DIMENSIONS$5, layout: "default", media, styles }), (0, import_jsx_runtime6.jsxs)(Stack, { className: styles == null ? void 0 : styles.heading, "data-testid": "default-preview__header", flex: 1, paddingLeft: media ? 2 : 1, paddingRight: status ? 0 : 1, space: 2, children: [(0, import_jsx_runtime6.jsxs)(Text3, { className: styles == null ? void 0 : styles.title, style: { color: "inherit" }, textOverflow: "ellipsis", children: [title && renderPreviewNode(title, "default"), !title && (0, import_jsx_runtime6.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t3("preview.default.title-fallback") })] }), subtitle && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", className: styles == null ? void 0 : styles.subtitle, children: renderPreviewNode(subtitle, "default") }), children && (0, import_jsx_runtime6.jsx)("div", { className: styles == null ? void 0 : styles.children, children })] }), statusNode] });
}
var __freeze$82 = Object.freeze;
var __defProp$82 = Object.defineProperty;
var __template$82 = (cooked, raw) => __freeze$82(__defProp$82(cooked, "raw", { value: __freeze$82(raw || cooked.slice()) }));
var _a$82;
var _b$62;
var _c$52;
var _d$22;
var _e$12;
var _f2;
var _g2;
var RootFlex = st(Flex).attrs({ align: "center" })(_a$82 || (_a$82 = __template$82(["\n  height: ", ";\n"])), rem(PREVIEW_MEDIA_SIZE.detail.height));
var StatusBox = st(Box)(_b$62 || (_b$62 = __template$82(["\n  white-space: nowrap;\n"])));
var MediaSkeleton$1 = st(Skeleton).attrs({ animated: true, radius: 2 })(_c$52 || (_c$52 = __template$82(["\n  width: ", ";\n  height: ", ";\n"])), rem(PREVIEW_MEDIA_SIZE.detail.width), rem(PREVIEW_MEDIA_SIZE.detail.height));
var TitleSkeleton$1 = st(TextSkeleton).attrs({ animated: true, radius: 1 })(_d$22 || (_d$22 = __template$82(["\n  max-width: ", "; /* 80% of 200px */\n  width: 80%;\n"])), rem(160));
var SubtitleSkeleton$1 = st(TextSkeleton).attrs({ animated: true, radius: 1, size: 1 })(_e$12 || (_e$12 = __template$82(["\n  max-width: ", "; /* 60% of 200px */\n  width: 60%;\n"])), rem(120));
var DescriptionSkeleton = st(TextSkeleton).attrs({ animated: true, radius: 1, size: 1 })(_f2 || (_f2 = __template$82(["\n  max-width: ", "; /* 90% of 200px */\n  width: 90%;\n"])), rem(180));
var DescriptionText = st(Text3)((_ref565) => {
  let { theme } = _ref565;
  const { fonts: fonts2 } = theme.sanity;
  const textSize1 = fonts2.text.sizes[1];
  const maxLines = 2;
  const maxHeight = textSize1.lineHeight * maxLines;
  return nt(_g2 || (_g2 = __template$82(["\n    & > span {\n      max-height: ", ";\n\n      /* Multi-line text overflow */\n      display: -webkit-box;\n      overflow: hidden;\n      overflow: clip;\n      text-overflow: ellipsis;\n      -webkit-line-clamp: ", ";\n      -webkit-box-orient: vertical;\n    }\n  "])), rem(maxHeight), maxLines);
});
var DEFAULT_MEDIA_DIMENSIONS$4 = { ...PREVIEW_MEDIA_SIZE.detail, fit: "crop", aspect: 1, dpr: getDevicePixelRatio() };
function DetailPreview(props2) {
  const { title, subtitle, description, mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$4, media, status, children, isPlaceholder } = props2;
  const { t: t3 } = useTranslation2();
  const statusNode = status && (0, import_jsx_runtime6.jsx)(StatusBox, { marginLeft: 3, paddingRight: 1, children: renderPreviewNode(status, "detail") });
  if (isPlaceholder) {
    return (0, import_jsx_runtime6.jsxs)(RootFlex, { "data-testid": "detail-preview", children: [media !== false && (0, import_jsx_runtime6.jsx)(MediaSkeleton$1, { "data-testid": "detail-preview__media" }), (0, import_jsx_runtime6.jsxs)(Box, { flex: 1, paddingLeft: media === false ? 1 : 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", "data-testid": "detail-preview__header", children: [(0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_jsx_runtime6.jsx)(TitleSkeleton$1, {}), (0, import_jsx_runtime6.jsx)(SubtitleSkeleton$1, {})] }), statusNode] }), description && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime6.jsx)(DescriptionSkeleton, {}) })] })] });
  }
  return (0, import_jsx_runtime6.jsxs)(RootFlex, { "data-testid": "detail-preview", children: [media !== false && (0, import_jsx_runtime6.jsx)(Media, { dimensions: mediaDimensions, layout: "detail", media }), (0, import_jsx_runtime6.jsxs)(Box, { flex: 1, paddingLeft: media === false ? 1 : 2, children: [(0, import_jsx_runtime6.jsxs)(Flex, { align: "center", "data-testid": "detail-preview__header", children: [(0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_jsx_runtime6.jsxs)(Text3, { textOverflow: "ellipsis", style: { color: "inherit" }, children: [title && renderPreviewNode(title, "detail"), !title && (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: t3("preview.default.title-fallback") })] }), subtitle && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "detail") })] }), statusNode] }), description && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime6.jsx)(DescriptionText, { muted: true, size: 1, children: renderPreviewNode(description, "detail") }) })] }), children] });
}
var __freeze$72 = Object.freeze;
var __defProp$72 = Object.defineProperty;
var __template$72 = (cooked, raw) => __freeze$72(__defProp$72(cooked, "raw", { value: __freeze$72(raw || cooked.slice()) }));
var _a$72;
var _b$52;
var _c$42;
var SIZE = 43;
var STROKE_WIDTH$1 = 3;
var Root$22 = st.svg(_a$72 || (_a$72 = __template$72(["\n  width: ", "px;\n  height: ", "px;\n  transform: rotate(-90deg);\n"])), SIZE, SIZE);
var BgCircle = st.circle((_ref566) => {
  let { theme } = _ref566;
  const { color: color3 } = theme.sanity;
  return nt(_b$52 || (_b$52 = __template$72(["\n    fill: none;\n    stroke: ", ";\n    stroke-width: ", "px;\n  "])), hues.gray[color3.dark ? 900 : 100].hex, STROKE_WIDTH$1);
});
var ProgressCircle = st.circle((_ref567) => {
  let { theme } = _ref567;
  const { color: color3 } = theme.sanity;
  return nt(_c$42 || (_c$42 = __template$72(["\n    fill: none;\n    stroke: ", ";\n    stroke-width: ", "px;\n    transition: stroke-dashoffset 75ms;\n  "])), hues.blue[color3.dark ? 400 : 500].hex, STROKE_WIDTH$1);
});
function CircularProgress(props2) {
  const { value: valueProp } = props2;
  const value = Math.min(Math.max(valueProp, 0), 100);
  const radius = SIZE / 2 - STROKE_WIDTH$1 / 2;
  const circ = 2 * Math.PI * radius;
  const offset2 = (100 - value) / 100 * circ;
  const viewBox = "".concat(SIZE / 2, " ").concat(SIZE / 2, " ").concat(SIZE, " ").concat(SIZE);
  return (0, import_jsx_runtime6.jsxs)(Root$22, { viewBox, children: [(0, import_jsx_runtime6.jsx)(BgCircle, { cx: SIZE, cy: SIZE, r: radius }), (0, import_jsx_runtime6.jsx)(ProgressCircle, { cx: SIZE, cy: SIZE, r: radius, style: { strokeDasharray: circ, strokeDashoffset: "".concat(offset2, "px") } })] });
}
var __freeze$62 = Object.freeze;
var __defProp$62 = Object.defineProperty;
var __template$62 = (cooked, raw) => __freeze$62(__defProp$62(cooked, "raw", { value: __freeze$62(raw || cooked.slice()) }));
var _a$62;
var _b$42;
var STROKE_WIDTH = 0.5;
var Root$12 = st(Card)(_a$62 || (_a$62 = __template$62(["\n  overflow: hidden;\n  overflow: clip;\n"])));
var Bar = st(Card)((_ref568) => {
  let { theme } = _ref568;
  const { color: color3 } = theme.sanity;
  return nt(_b$42 || (_b$42 = __template$62(["\n    height: ", "rem;\n    background: ", ";\n    transition: transform 75ms;\n  "])), STROKE_WIDTH, hues.blue[color3.dark ? 400 : 500].hex);
});
function LinearProgress(props2) {
  const { value } = props2;
  return (0, import_jsx_runtime6.jsx)(Root$12, { radius: 5, children: (0, import_jsx_runtime6.jsx)(Bar, { radius: 5, style: { transform: "translate3d(".concat(value - 100, "%, 0, 0)") } }) });
}
var __freeze$52 = Object.freeze;
var __defProp$53 = Object.defineProperty;
var __template$52 = (cooked, raw) => __freeze$52(__defProp$53(cooked, "raw", { value: __freeze$52(raw || cooked.slice()) }));
var _a$52;
var _b$32;
var _c$32;
var _d$12;
var _e2;
var RootBox$1 = st(Box)(_a$52 || (_a$52 = __template$52(["\n  position: relative;\n"])));
var MediaFlex = st(Flex).attrs({ align: "center", justify: "center" })(_b$32 || (_b$32 = __template$52(["\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n"])));
var MediaSkeleton = st(Skeleton).attrs({ animated: true, radius: 2 })(_c$32 || (_c$32 = __template$52(["\n  width: 100%;\n  height: 100%;\n"])));
var ProgressFlex = st(Flex).attrs({ align: "center", justify: "center" })(_d$12 || (_d$12 = __template$52(["\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n\n  &:before {\n    background-color: var(--card-bg-color);\n    opacity: 0.75;\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n  }\n\n  > svg {\n    position: relative;\n    z-index: 2;\n  }\n"])));
var TooltipContentStack = st(Stack).attrs({ padding: 2, space: 2 })(_e2 || (_e2 = __template$52(["\n  max-width: ", ";\n"])), rem(200));
var DEFAULT_MEDIA_DIMENSIONS$3 = { ...PREVIEW_MEDIA_SIZE.media, aspect: 1, fit: "crop", dpr: getDevicePixelRatio() };
function MediaPreview(props2) {
  const { media, mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$3, children, isPlaceholder, progress: progress3 = -1, subtitle, title, withBorder = true, withRadius = true } = props2;
  const aspect = mediaDimensions.aspect || 1;
  const STYLES_PADDER = (0, import_react51.useMemo)(() => ({ paddingBottom: "".concat(100 / aspect, "%") }), [aspect]);
  const tooltipContent = (0, import_react51.useMemo)(() => {
    if (!title || !subtitle) {
      return null;
    }
    return (0, import_jsx_runtime6.jsxs)(TooltipContentStack, { children: [title && (0, import_jsx_runtime6.jsx)(Text3, { align: "center", size: 1, weight: "semibold", children: renderPreviewNode(title, "media") }), subtitle && (0, import_jsx_runtime6.jsx)(Text3, { align: "center", muted: true, size: 1, children: renderPreviewNode(subtitle, "media") })] });
  }, [subtitle, title]);
  return (0, import_jsx_runtime6.jsxs)(RootBox$1, { "data-testid": "media-preview", overflow: "hidden", flex: 1, children: [(0, import_jsx_runtime6.jsx)("div", { style: STYLES_PADDER }), (0, import_jsx_runtime6.jsx)(Tooltip, { content: tooltipContent, disabled: !tooltipContent, placement: "top", portal: true, children: (0, import_jsx_runtime6.jsxs)(MediaFlex, { children: [isPlaceholder ? (0, import_jsx_runtime6.jsx)(MediaSkeleton, {}) : (0, import_jsx_runtime6.jsx)(Media, { border: withBorder, dimensions: mediaDimensions, layout: "media", media, radius: withRadius ? 1 : 0, responsive: true }), typeof progress3 === "number" && progress3 > -1 && (0, import_jsx_runtime6.jsx)(ProgressFlex, { children: (0, import_jsx_runtime6.jsx)(CircularProgress, { value: progress3 }) })] }) }), children] });
}
var __freeze$42 = Object.freeze;
var __defProp$43 = Object.defineProperty;
var __template$42 = (cooked, raw) => __freeze$42(__defProp$43(cooked, "raw", { value: __freeze$42(raw || cooked.slice()) }));
var _a$42;
var _b$22;
var _c$22;
var HeaderFlex$2 = st(Flex).attrs({ align: "center" })(_a$42 || (_a$42 = __template$42(["\n  box-shadow: 0 0 0 1px var(--card-border-color);\n  height: ", ";\n  white-space: nowrap;\n  position: relative;\n  z-index: 1;\n"])), rem(PREVIEW_MEDIA_SIZE.block.height));
var MediaCard = st(Card)(_b$22 || (_b$22 = __template$42(["\n  position: relative;\n  padding-bottom: ", "%;\n\n  & > span {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n"])), (_ref569) => {
  let { $ratio } = _ref569;
  return $ratio;
});
var RootBox = st(Box).attrs({ overflow: "hidden" })(_c$22 || (_c$22 = __template$42(["\n  border-radius: ", "px;\n"])), (_ref570) => {
  let { theme } = _ref570;
  return theme.sanity.radius[1];
});
var DEFAULT_MEDIA_DIMENSIONS$2 = { ...PREVIEW_MEDIA_SIZE.blockImage, fit: "fillmax", dpr: getDevicePixelRatio() };
var getRatio = (dimensions) => {
  const { height, width } = dimensions;
  if (!height || !width) {
    return 1;
  }
  return height / width * 100;
};
function BlockImagePreview(props2) {
  const { actions, title, subtitle, description, fallbackTitle = "Untitled", mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$2, media, children, status } = props2;
  return (0, import_jsx_runtime6.jsxs)(RootBox, { children: [(0, import_jsx_runtime6.jsxs)(Stack, { children: [(0, import_jsx_runtime6.jsxs)(HeaderFlex$2, { paddingLeft: 2, paddingRight: 1, paddingY: 1, children: [(0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, children: [(title || fallbackTitle) && (0, import_jsx_runtime6.jsx)(Text3, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title ? renderPreviewNode(title, "block") : fallbackTitle }), subtitle && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "block") })] }), (0, import_jsx_runtime6.jsxs)(Flex, { gap: 1, paddingLeft: 1, children: [status && (0, import_jsx_runtime6.jsx)(Box, { paddingX: 2, paddingY: 3, children: renderPreviewNode(status, "block") }), actions] })] }), (0, import_jsx_runtime6.jsx)(MediaCard, { $ratio: getRatio(mediaDimensions), __unstable_checkered: true, display: "flex", sizing: "border", tone: "inherit", children: (0, import_jsx_runtime6.jsx)(Media, { border: false, dimensions: mediaDimensions, layout: "blockImage", media, radius: 0, responsive: true }) })] }), description && (0, import_jsx_runtime6.jsx)(Box, { paddingX: 2, paddingY: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, children: renderPreviewNode(description, "block") }) }), children && (0, import_jsx_runtime6.jsx)("div", { children })] });
}
var __freeze$32 = Object.freeze;
var __defProp$33 = Object.defineProperty;
var __template$32 = (cooked, raw) => __freeze$32(__defProp$33(cooked, "raw", { value: __freeze$32(raw || cooked.slice()) }));
var _a$32;
var DEFAULT_MEDIA_DIMENSIONS$1 = { ...PREVIEW_MEDIA_SIZE.block, aspect: 1, fit: "crop", dpr: getDevicePixelRatio() };
var HeaderFlex$1 = st(Flex).attrs({ align: "center" })(_a$32 || (_a$32 = __template$32(["\n  min-height: ", ";\n"])), rem(PREVIEW_MEDIA_SIZE.block.height));
function BlockPreview(props2) {
  const { actions, title, subtitle, description, mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$1, media, status, children } = props2;
  return (0, import_jsx_runtime6.jsxs)(Stack, { "data-testid": "block-preview", space: 1, children: [(0, import_jsx_runtime6.jsxs)(HeaderFlex$1, { "data-testid": "block-preview__header", children: [media && (0, import_jsx_runtime6.jsx)(Media, { dimensions: mediaDimensions, layout: "block", media }), (0, import_jsx_runtime6.jsxs)(Box, { flex: 1, paddingLeft: media ? 2 : 1, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title ? renderPreviewNode(title, "block") : "Untitled" }), subtitle && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "block") }) }), description && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(description, "block") }) })] }), (0, import_jsx_runtime6.jsxs)(Flex, { gap: 1, paddingLeft: 1, children: [status && (0, import_jsx_runtime6.jsx)(Box, { paddingX: 2, paddingY: 3, children: renderPreviewNode(status, "block") }), actions] })] }), children && (0, import_jsx_runtime6.jsx)("div", { "data-testid": "block-preview__children", children })] });
}
var __freeze$210 = Object.freeze;
var __defProp$210 = Object.defineProperty;
var __template$210 = (cooked, raw) => __freeze$210(__defProp$210(cooked, "raw", { value: __freeze$210(raw || cooked.slice()) }));
var _a$210;
var _b$19;
var _c$12;
var RootSpan = st.span(_a$210 || (_a$210 = __template$210(["\n  display: inline-flex;\n  align-items: center;\n  vertical-align: top;\n  height: calc(1em - 1px);\n  max-width: 100%;\n"])));
var MediaSpan = st.span(_b$19 || (_b$19 = __template$210(["\n  position: relative;\n  display: inline-block;\n  width: calc(1em - 1px);\n  height: calc(1em - 1px);\n  min-width: calc(1em - 1px);\n\n  & img {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    border-radius: ", ";\n  }\n\n  & img + span {\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    box-shadow: inset 0 0 0 1px var(--card-fg-color);\n    opacity: 0.2;\n    border-radius: ", ";\n  }\n\n  & svg {\n    display: block;\n    font-size: calc(14 / 16 * 1em);\n    margin: 1px 0;\n\n    &[data-sanity-icon] {\n      font-size: calc(18 / 16 * 1em);\n      margin: calc(1px + (2 / 18 * -1em)) 0;\n    }\n  }\n"])), (_ref571) => {
  let { theme } = _ref571;
  return rem(theme.sanity.radius[1]);
}, (_ref572) => {
  let { theme } = _ref572;
  return rem(theme.sanity.radius[1]);
});
var TextSpan = st(Text3).attrs({ forwardedAs: "span" })((_ref573) => {
  let { theme } = _ref573;
  const textFont = theme.sanity.fonts.text;
  const textSize2 = textFont.sizes[1];
  return nt(_c$12 || (_c$12 = __template$210(["\n    font-size: calc(", " / 16 * 1em);\n    font-weight: ", ";\n    box-sizing: border-box;\n    display: inline-block;\n    vertical-align: top;\n    line-height: ", ";\n    padding-left: 0.5em;\n    padding-right: calc(0.5em - 2px);\n    min-width: 0;\n\n    & > span {\n      display: block;\n      white-space: nowrap;\n      text-overflow: ellipsis;\n      overflow: hidden;\n      overflow: clip;\n    }\n  "])), textSize2.fontSize, textFont.weights.medium, textSize2.lineHeight / textSize2.fontSize);
});
var DEFAULT_MEDIA_DIMENSIONS = { ...PREVIEW_MEDIA_SIZE.inline, fit: "crop", aspect: 1, dpr: getDevicePixelRatio() };
function InlinePreview(props2) {
  const { title, fallbackTitle = "Untitled", media, mediaDimensions = DEFAULT_MEDIA_DIMENSIONS } = props2;
  return (0, import_jsx_runtime6.jsxs)(RootSpan, { "data-testid": "inline-preview", children: [media && (0, import_jsx_runtime6.jsxs)(MediaSpan, { "data-testid": "inline-preview-media", children: [renderPreviewMedia(media, "inline", mediaDimensions), (0, import_jsx_runtime6.jsx)("span", {})] }), (0, import_jsx_runtime6.jsx)(TextSpan, { "data-testid": "inline-preview-title", size: 1, children: renderPreviewNode(title, "inline", fallbackTitle) })] });
}
var __freeze$110 = Object.freeze;
var __defProp$110 = Object.defineProperty;
var __template$110 = (cooked, raw) => __freeze$110(__defProp$110(cooked, "raw", { value: __freeze$110(raw || cooked.slice()) }));
var _a$110;
var _b3;
var _c3;
var _d3;
var DEFAULT_MEDIA_DIMENSION = { ...PREVIEW_MEDIA_SIZE.default, aspect: 1, fit: "crop", dpr: getDevicePixelRatio() };
var Root2 = st(Box)(_a$110 || (_a$110 = __template$110(["\n  height: 100%;\n\n  a {\n    color: currentColor;\n    text-decoration: none;\n  }\n\n  svg[data-sanity-icon] {\n    margin: 0;\n  }\n"])));
var HeaderFlex = st(Flex).attrs({ align: "center" })(_b3 || (_b3 = __template$110(["\n  height: ", ";\n"])), rem(PREVIEW_MEDIA_SIZE.default.height));
var TitleSkeleton = st(TextSkeleton).attrs({ animated: true, radius: 1 })(_c3 || (_c3 = __template$110(["\n  max-width: ", ";\n  width: 80%;\n"])), rem(160));
var SubtitleSkeleton = st(TextSkeleton).attrs({ animated: true, radius: 1, size: 1 })(_d3 || (_d3 = __template$110(["\n  max-width: ", ";\n  width: 60%;\n"])), rem(120));
function TemplatePreview(props2) {
  const { description, isPlaceholder, media, mediaDimensions = DEFAULT_MEDIA_DIMENSION, subtitle, title = "Untitled" } = props2;
  if (isPlaceholder) {
    return (0, import_jsx_runtime6.jsx)(Root2, { children: (0, import_jsx_runtime6.jsx)(HeaderFlex, { children: (0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_jsx_runtime6.jsx)(TitleSkeleton, {}), (0, import_jsx_runtime6.jsx)(SubtitleSkeleton, {})] }) }) });
  }
  return (0, import_jsx_runtime6.jsxs)(Root2, { children: [(0, import_jsx_runtime6.jsxs)(HeaderFlex, { children: [(0, import_jsx_runtime6.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_react_is2.isValidElementType)(title) && (0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", children: (0, import_react51.createElement)(title, { layout: "default" }) }), (0, import_react51.isValidElement)(title) && (0, import_jsx_runtime6.jsx)(Text3, { textOverflow: "ellipsis", children: title }), (0, import_react_is2.isValidElementType)(subtitle) && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: (0, import_react51.createElement)(subtitle, { layout: "default" }) }), (0, import_react51.isValidElement)(subtitle) && (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, textOverflow: "ellipsis", children: subtitle })] }), media && (0, import_jsx_runtime6.jsx)(Flex, { align: "flex-start", paddingLeft: 2, children: (0, import_jsx_runtime6.jsx)(Media, { dimensions: mediaDimensions, layout: "default", media }) })] }), description && (0, import_jsx_runtime6.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime6.jsx)(Text3, { muted: true, size: 1, style: { whiteSpace: "break-spaces" }, children: description }) })] });
}
var MUTATION_ATTRIBUTE_FILTER = ["aria-hidden", "disabled", "href"];
var FOCUSABLE = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
function getFocusableElements(element) {
  return [...element.querySelectorAll(FOCUSABLE)].filter((el) => !el.hasAttribute("disabled") && el.getAttribute("aria-hidden") !== "true");
}
function useRovingFocus(props2) {
  const { direction = "horizontal", initialFocus, loop = true, navigation = ["arrows"], pause = false, rootElement } = props2;
  const [focusedIndex, setFocusedIndex] = (0, import_react51.useState)(-1);
  const [focusableElements, setFocusableElements] = (0, import_react51.useState)([]);
  const focusableLen = focusableElements.length;
  const lastFocusableIndex = focusableLen - 1;
  const nextKey = direction === "horizontal" ? "ArrowRight" : "ArrowDown";
  const prevKey = direction === "horizontal" ? "ArrowLeft" : "ArrowUp";
  const handleSetElements = (0, import_react51.useCallback)(() => {
    if (rootElement) {
      const els = getFocusableElements(rootElement);
      setFocusableElements(els);
    }
  }, [rootElement]);
  const handleFocus = (0, import_react51.useCallback)((index) => {
    setFocusedIndex(index);
  }, []);
  const handleKeyDown = (0, import_react51.useCallback)((event) => {
    if (pause) {
      return;
    }
    const focusPrev = () => {
      event.preventDefault();
      setFocusedIndex((prevIndex) => {
        const next = (prevIndex + lastFocusableIndex) % focusableLen;
        if (!loop && next === lastFocusableIndex) {
          return prevIndex;
        }
        return next;
      });
    };
    const focusNext = () => {
      event.preventDefault();
      setFocusedIndex((prevIndex) => {
        const next = (prevIndex + 1) % focusableLen;
        if (!loop && next === 0) {
          return prevIndex;
        }
        return next;
      });
    };
    if (event.key === "Tab" && navigation.includes("tab")) {
      if (event.shiftKey) {
        focusPrev();
      } else {
        focusNext();
      }
    }
    if (navigation.includes("arrows")) {
      if (event.key === prevKey) {
        focusPrev();
      }
      if (event.key === nextKey) {
        focusNext();
      }
    }
  }, [pause, prevKey, navigation, nextKey, lastFocusableIndex, focusableLen, loop]);
  (0, import_react51.useEffect)(() => {
    handleSetElements();
  }, [handleSetElements, initialFocus, direction]);
  (0, import_react51.useEffect)(() => {
    const mo = new MutationObserver(handleSetElements);
    if (rootElement) {
      mo.observe(rootElement, { childList: true, subtree: true, attributeFilter: MUTATION_ATTRIBUTE_FILTER });
    }
    return () => {
      mo.disconnect();
    };
  }, [focusableElements, handleSetElements, rootElement]);
  (0, import_react51.useEffect)(() => {
    var _a4;
    focusableElements.forEach((el, index) => {
      if (index === focusedIndex) {
        el.setAttribute("tabIndex", "0");
        el.setAttribute("aria-selected", "true");
        el.focus();
        el.onfocus = () => handleFocus(index);
        el.onblur = () => handleFocus(-1);
      } else {
        el.setAttribute("tabIndex", "-1");
        el.setAttribute("aria-selected", "false");
        el.onfocus = () => handleFocus(index);
      }
    });
    if (focusedIndex === -1 && focusableElements) {
      const initialIndex = initialFocus === "last" ? lastFocusableIndex : 0;
      (_a4 = focusableElements[initialIndex]) == null ? void 0 : _a4.setAttribute("tabIndex", "0");
    }
  }, [focusableElements, focusedIndex, handleFocus, initialFocus, lastFocusableIndex]);
  (0, import_react51.useEffect)(() => {
    rootElement == null ? void 0 : rootElement.addEventListener("keydown", handleKeyDown);
    return () => {
      rootElement == null ? void 0 : rootElement.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleKeyDown, rootElement]);
  return void 0;
}
var IconBox2 = st(Box)({ position: "relative" });
var Dot = st.div({ position: "absolute", top: -4, right: -4, width: 6, height: 6, borderRadius: 3, boxShadow: "0 0 0 1px var(--card-bg-color)" });
var StatusButton = (0, import_react51.forwardRef)(function StatusButton2(props2, ref) {
  const { disabled: disabledProp, fontSize: fontSize2, hotkey, icon, label, mode = "bleed", space = 3, text, tone, tooltip, ...restProps } = props2;
  const theme = useTheme();
  const toneColor = tone && theme.sanity.color.solid[tone];
  const dotStyle = (0, import_react51.useMemo)(() => ({ backgroundColor: toneColor == null ? void 0 : toneColor.enabled.bg }), [toneColor]);
  const disabled = Boolean(disabledProp);
  const tooltipContent = typeof disabledProp === "object" ? (0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: disabledProp.reason }) : (0, import_jsx_runtime6.jsxs)(Flex, { align: "center", gap: 2, style: { lineHeight: 0 }, children: [(0, import_jsx_runtime6.jsx)(Text3, { size: 1, children: label }), hotkey && (0, import_jsx_runtime6.jsx)(Hotkeys3, { fontSize: 0, keys: hotkey, style: { margin: -4 } })] });
  return (0, import_jsx_runtime6.jsx)(Tooltip, { padding: 2, placement: "bottom", ...tooltip, content: tooltipContent, disabled: !label, portal: true, children: (0, import_jsx_runtime6.jsx)("div", { children: (0, import_jsx_runtime6.jsx)(Button, { "data-ui": "StatusButton", ...restProps, "aria-label": label, disabled, mode, ref, children: (0, import_jsx_runtime6.jsxs)(Flex, { gap: space, children: [(0, import_jsx_runtime6.jsxs)(IconBox2, { children: [(0, import_jsx_runtime6.jsxs)(Text3, { size: fontSize2, children: [(0, import_react51.isValidElement)(icon) && icon, (0, import_react_is2.isValidElementType)(icon) && (0, import_react51.createElement)(icon)] }), tone && (0, import_jsx_runtime6.jsx)(Dot, { style: dotStyle })] }), text && (0, import_jsx_runtime6.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime6.jsx)(Text3, { size: fontSize2, children: text }) })] }) }) }) });
});
var TooltipOfDisabled = (0, import_react51.forwardRef)(function DisabledTooltip(props2, ref) {
  const { children, content, disabled, ...restProps } = props2;
  return (0, import_jsx_runtime6.jsx)(Tooltip, { ...restProps, content, disabled: disabled || !content, padding: 2, ref, children: (0, import_jsx_runtime6.jsx)("div", { children }) });
});
var ImperativeToast = (0, import_react51.forwardRef)((_, ref) => {
  const { push } = useToast();
  (0, import_react51.useImperativeHandle)(ref, () => ({ push }));
  return null;
});
ImperativeToast.displayName = "ImperativeToast";
var defaults2 = {
  navbar: 200,
  navbarPopover: 5e5,
  navbarDialog: 500001,
  // pane
  pane: 100,
  paneHeader: [110, 15e3],
  paneFooter: [120, 2e4],
  paneResizer: [130, 25e3],
  //
  popover: 200,
  modal: 200,
  movingItem: 1e4,
  drawershade: 1e6,
  drawer: 1000001,
  fullscreen: 12e5,
  toast: [100, 11e3],
  // NOT IN USE
  portal: 200,
  dropdown: 200,
  navbarFixed: 1010,
  fullscreenEdit: 1050,
  popoverBackground: 1060,
  tooltip: 200,
  modalBackground: 2e3,
  spinner: 3e3
};
var ZIndexContext = (0, import_react51.createContext)(defaults2);
function useZIndex() {
  return (0, import_react51.useContext)(ZIndexContext);
}
function LegacyLayerProvider(_ref574) {
  let { children, zOffset: zOffsetKey } = _ref574;
  const zIndex = useZIndex();
  const zOffset = zIndex[zOffsetKey];
  return (0, import_jsx_runtime6.jsx)(LayerProvider, { zOffset, children });
}
function WithReferringDocuments(_ref575) {
  let { children, id: id4 } = _ref575;
  return children(useReferringDocuments(id4));
}
function ZIndexProvider(_ref576) {
  let { children } = _ref576;
  return (0, import_jsx_runtime6.jsx)(ZIndexContext.Provider, { value: defaults2, children });
}
var __freeze3 = Object.freeze;
var __defProp5 = Object.defineProperty;
var __template3 = (cooked, raw) => __freeze3(__defProp5(cooked, "raw", { value: __freeze3(raw || cooked.slice()) }));
var _a3;
var StyledBadge = st(Badge)((_ref577) => {
  let { theme } = _ref577;
  const fgTint = theme.sanity.color.dark ? 50 : 700;
  const bgTint = theme.sanity.color.dark ? 700 : 100;
  const bg = hues.purple[bgTint].hex;
  const fg = hues.purple[fgTint].hex;
  return nt(_a3 || (_a3 = __template3(["\n    background-color: ", ";\n    box-shadow: inset 0 0 0 1px ", ";\n    color: ", ";\n  "])), bg, bg, fg);
});
function BetaBadge(props2) {
  const { fontSize: fontSize2 = 1, children = "Beta", ...rest } = props2;
  return (0, import_jsx_runtime6.jsx)(StyledBadge, { ...rest, fontSize: fontSize2, children });
}
function TelephoneInput(props2) {
  const { schemaType, validationError, value, elementProps } = props2;
  return (0, import_jsx_runtime6.jsx)(TextInput, { type: "tel", inputMode: "tel", customValidity: validationError, value: value || "", placeholder: schemaType.placeholder, ...elementProps });
}
function setAtPath(currentTree, path2, value) {
  var _a4;
  if (path2.length === 0) {
    return { ...currentTree || {}, value };
  }
  const [head, ...tail] = path2;
  const key2 = isKeySegment(head) ? head._key : String(head);
  const children = (_a4 = currentTree == null ? void 0 : currentTree.children) != null ? _a4 : {};
  return { value: currentTree == null ? void 0 : currentTree.value, children: { ...children, [key2]: setAtPath(children[key2] || {}, tail, value) } };
}
var MAX_FIELD_DEPTH = 20;
var AUTO_COLLAPSE_DEPTH = 3;
var ALL_FIELDS_GROUP = { name: "all-fields", title: "All fields", hidden: false };
function isObjectFormNode(formNode) {
  return isObjectSchemaType(formNode.schemaType);
}
function isArrayOfObjectsFormNode(formNode) {
  return isArrayOfObjectsSchemaType(formNode.schemaType);
}
function hasAllMembers(value) {
  return "_allMembers" in value && Array.isArray(value._allMembers);
}
function getExpandOperations(node, path2) {
  return [
    // make sure to expand all intermediate paths
    ...path2.map((p, i) => ({ type: "expandPath", path: path2.slice(0, i + 1) })),
    // make sure to expand all fieldsets and selects the groups that includes the intermediate nodes
    ...getFieldsetAndFieldGroupOperations(node, path2)
  ];
}
function getFieldsetAndFieldGroupOperations(node, path2) {
  if (path2.length === 0) {
    return [];
  }
  if (isObjectFormNode(node) && hasAllMembers(node)) {
    return getObjectFieldsetAndFieldGroupOperations(node, path2);
  }
  if (isArrayOfObjectsFormNode(node)) {
    return getArrayFieldsetAndFieldGroupOperations(node, path2);
  }
  return [];
}
function getObjectFieldsetAndFieldGroupOperations(node, path2) {
  var _a4, _b4;
  if (path2.length === 0) {
    return [];
  }
  const [fieldName, ...tail] = path2;
  const fieldsetMember = node._allMembers.find((member) => member.kind === "fieldSet" && member.fieldSet.members.some((field) => field.kind === "field" && field.name === fieldName));
  const members = fieldsetMember ? fieldsetMember.fieldSet.members : (
    // Note: we need to use the internal `_allMembers` array here instead of members since hidden/collapsed members are omitted from members
    node._allMembers
  );
  const fieldMember = members.find((member) => member !== null && member.kind === "field" && member.name === fieldName);
  const schemaField = node.schemaType.fields.find((field) => field.name === fieldName);
  const selectedGroupName = (_a4 = node.groups.find((group2) => group2.selected)) == null ? void 0 : _a4.name;
  const defaultGroupName = (_b4 = (node.schemaType.groups || []).find((group2) => group2.default)) == null ? void 0 : _b4.name;
  const inSelectedGroup = selectedGroupName && (selectedGroupName === ALL_FIELDS_GROUP.name || schemaField && (0, import_castArray2.default)(schemaField.group).includes(selectedGroupName));
  const ops = [];
  if (!inSelectedGroup) {
    ops.push({ type: "setSelectedGroup", path: node.path, groupName: defaultGroupName || ALL_FIELDS_GROUP.name });
  }
  if (fieldsetMember) {
    ops.push({ type: "expandFieldSet", path: fieldsetMember.fieldSet.path });
  }
  if (fieldMember && hasAllMembers(fieldMember.field)) {
    if (isMemberArrayOfObjects(fieldMember)) {
      ops.push(...getArrayFieldsetAndFieldGroupOperations(fieldMember.field, tail));
    } else if (isMemberObject(fieldMember)) {
      ops.push(...getObjectFieldsetAndFieldGroupOperations(fieldMember.field, tail));
    }
  }
  return ops;
}
function getArrayFieldsetAndFieldGroupOperations(state, path2) {
  if (path2.length === 0) {
    return [];
  }
  const [segment, ...rest] = path2;
  if (!isKeySegment(segment)) {
    throw new Error("Expected path segment to be an object with a _key property");
  }
  const foundMember = state.members.find((member) => member.key === segment._key);
  if (!foundMember) {
    return [];
  }
  return getFieldsetAndFieldGroupOperations(foundMember.item, rest);
}
function resolveConditionalProperty(property, context) {
  const { currentUser, document: document2, parent, value } = context;
  if (typeof property === "boolean" || property === void 0) {
    return Boolean(property);
  }
  return property({ document: document2, parent, value, currentUser }) === true;
}
function getItemType(arrayType, item) {
  const itemTypeName = resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
function getPrimitiveItemType(arrayType, item) {
  const itemTypeName = resolveTypeName(item);
  return arrayType == null ? void 0 : arrayType.of.find((memberType) => memberType.name === itemTypeName || memberType.jsonType === itemTypeName);
}
function getCollapsedWithDefaults() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let level = arguments.length > 1 ? arguments[1] : void 0;
  if ((options == null ? void 0 : options.collapsible) === false || (options == null ? void 0 : options.collapsable) === false) {
    return { collapsible: false, collapsed: false };
  }
  const collapsed = (
    // eslint-disable-next-line no-nested-ternary
    typeof (options == null ? void 0 : options.collapsed) === "boolean" ? options.collapsed : level >= AUTO_COLLAPSE_DEPTH ? true : void 0
  );
  const collapsible = (options == null ? void 0 : options.collapsible) === true || (options == null ? void 0 : options.collapsable) === true || collapsed === true ? true : void 0;
  return { collapsible, collapsed };
}
function isFieldEnabledByGroupFilter(groupsConfig, fieldGroup, selectedGroup) {
  if (selectedGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  }
  if (fieldGroup === void 0) {
    return false;
  }
  if (groupsConfig.length === 0 && selectedGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  }
  return (0, import_castArray2.default)(fieldGroup).includes(selectedGroup.name);
}
function isAcceptedObjectValue(value) {
  return typeof value === "undefined" || isRecord$4(value);
}
function isValidArrayOfObjectsValue(value) {
  return typeof value === "undefined" || Array.isArray(value);
}
function isValidArrayOfPrimitivesValue(value) {
  return typeof value === "undefined" || Array.isArray(value);
}
function everyItemIsObject(value) {
  return value.length === 0 || value.every((item) => isRecord$4(item));
}
function findDuplicateKeyEntries(array3) {
  const seenKeys = /* @__PURE__ */ new Set();
  return array3.reduce((acc, item, index) => {
    if (seenKeys.has(item._key)) {
      acc.push([index, item._key]);
    }
    seenKeys.add(item._key);
    return acc;
  }, []);
}
function hasKey(value) {
  return "_key" in value;
}
function everyItemHasKey(array3) {
  return array3 == null ? void 0 : array3.every((item) => isRecord$4(item) && hasKey(item));
}
function isChangedValue(value, comparisonValue) {
  if (Array.isArray(value) && typeof comparisonValue === "undefined" || Array.isArray(comparisonValue) && typeof value === "undefined") {
    return false;
  }
  if (value && !comparisonValue) {
    return true;
  }
  return !(0, import_isEqual4.default)(value, comparisonValue);
}
function prepareFieldMember(props2) {
  var _a4, _b4, _c4, _d4, _e3, _f3, _g3, _h2, _i2, _j2, _k, _l, _m, _n, _o, _p, _q, _r;
  const { parent, field, index } = props2;
  const fieldPath = pathFor([...parent.path, field.name]);
  const fieldLevel = getFieldLevel(field.type, parent.level + 1);
  const parentValue = parent.value;
  const parentComparisonValue = parent.comparisonValue;
  if (!isAcceptedObjectValue(parentValue)) {
    throw new Error("Unexpected non-object value");
  }
  const normalizedFieldGroupNames = field.group ? (0, import_castArray2.default)(field.group) : [];
  const inSelectedGroup = isFieldEnabledByGroupFilter(parent.groups, field.group, parent.selectedGroup);
  if (isObjectSchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = isRecord$4(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (!isAcceptedObjectValue(fieldValue)) {
      return { kind: "error", key: field.name, fieldName: field.name, error: { type: "INCOMPATIBLE_TYPE", expectedSchemaType: field.type, resolvedValueType: resolveTypeName(fieldValue), value: fieldValue } };
    }
    const conditionalPropertyContext = { value: fieldValue, parent: parent.value, document: parent.document, currentUser: parent.currentUser };
    const hidden = resolveConditionalProperty(field.type.hidden, conditionalPropertyContext);
    if (hidden) {
      return { kind: "hidden", key: "field-".concat(field.name), name: field.name, index };
    }
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext);
    const fieldGroupState = (_b4 = (_a4 = parent.fieldGroupState) == null ? void 0 : _a4.children) == null ? void 0 : _b4[field.name];
    const scopedCollapsedPaths = (_d4 = (_c4 = parent.collapsedPaths) == null ? void 0 : _c4.children) == null ? void 0 : _d4[field.name];
    const scopedCollapsedFieldsets = (_f3 = (_e3 = parent.collapsedFieldSets) == null ? void 0 : _e3.children) == null ? void 0 : _f3[field.name];
    const inputState = prepareObjectInputState({ schemaType: field.type, currentUser: parent.currentUser, parent: parent.value, document: parent.document, value: fieldValue, changed: isChangedValue(fieldValue, fieldComparisonValue), comparisonValue: fieldComparisonValue, presence: parent.presence, validation: parent.validation, fieldGroupState, path: fieldPath, level: fieldLevel, focusPath: parent.focusPath, openPath: parent.openPath, collapsedPaths: scopedCollapsedPaths, collapsedFieldSets: scopedCollapsedFieldsets, readOnly, changesOpen: parent.changesOpen });
    if (inputState === null) {
      return null;
    }
    const defaultCollapsedState = getCollapsedWithDefaults(field.type.options, fieldLevel);
    const collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return { kind: "field", key: "field-".concat(field.name), name: field.name, index, inSelectedGroup, groups: normalizedFieldGroupNames, open: startsWith(fieldPath, parent.openPath), field: inputState, collapsed, collapsible: defaultCollapsedState.collapsible };
  } else if (isArraySchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = isRecord$4(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (isArrayOfObjectsSchemaType(field.type)) {
      const hasValue2 = typeof fieldValue !== "undefined";
      if (hasValue2 && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = resolveTypeName(fieldValue);
        return { kind: "error", key: field.name, fieldName: field.name, error: { type: "INCOMPATIBLE_TYPE", expectedSchemaType: field.type, resolvedValueType, value: fieldValue } };
      }
      if (hasValue2 && !everyItemIsObject(fieldValue)) {
        return { kind: "error", key: field.name, fieldName: field.name, error: { type: "MIXED_ARRAY", schemaType: field.type, value: fieldValue } };
      }
      if (hasValue2 && !everyItemHasKey(fieldValue)) {
        return { kind: "error", key: field.name, fieldName: field.name, error: { type: "MISSING_KEYS", value: fieldValue, schemaType: field.type } };
      }
      const duplicateKeyEntries = hasValue2 ? findDuplicateKeyEntries(fieldValue) : [];
      if (duplicateKeyEntries.length > 0) {
        return { kind: "error", key: field.name, fieldName: field.name, error: { type: "DUPLICATE_KEYS", duplicates: duplicateKeyEntries, schemaType: field.type } };
      }
      const fieldGroupState = (_h2 = (_g3 = parent.fieldGroupState) == null ? void 0 : _g3.children) == null ? void 0 : _h2[field.name];
      const scopedCollapsedPaths = (_j2 = (_i2 = parent.collapsedPaths) == null ? void 0 : _i2.children) == null ? void 0 : _j2[field.name];
      const scopedCollapsedFieldSets = (_l = (_k = parent.collapsedFieldSets) == null ? void 0 : _k.children) == null ? void 0 : _l[field.name];
      const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, { value: fieldValue, parent: parent.value, document: parent.document, currentUser: parent.currentUser });
      const fieldState = prepareArrayOfObjectsInputState({ schemaType: field.type, parent: parent.value, currentUser: parent.currentUser, document: parent.document, value: fieldValue, changed: isChangedValue(fieldValue, fieldComparisonValue), comparisonValue: fieldComparisonValue, fieldGroupState, focusPath: parent.focusPath, openPath: parent.openPath, presence: parent.presence, validation: parent.validation, collapsedPaths: scopedCollapsedPaths, collapsedFieldSets: scopedCollapsedFieldSets, level: fieldLevel, path: fieldPath, readOnly });
      if (fieldState === null) {
        return null;
      }
      return {
        kind: "field",
        key: "field-".concat(field.name),
        name: field.name,
        index,
        open: startsWith(fieldPath, parent.openPath),
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = resolveTypeName(fieldValue);
        return { kind: "error", key: field.name, fieldName: field.name, error: { type: "INCOMPATIBLE_TYPE", expectedSchemaType: field.type, resolvedValueType, value: fieldValue } };
      }
      const fieldGroupState = (_n = (_m = parent.fieldGroupState) == null ? void 0 : _m.children) == null ? void 0 : _n[field.name];
      const scopedCollapsedPaths = (_p = (_o = parent.collapsedPaths) == null ? void 0 : _o.children) == null ? void 0 : _p[field.name];
      const scopedCollapsedFieldSets = (_r = (_q = parent.collapsedFieldSets) == null ? void 0 : _q.children) == null ? void 0 : _r[field.name];
      const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, { value: fieldValue, parent: parent.value, document: parent.document, currentUser: parent.currentUser });
      const fieldState = prepareArrayOfPrimitivesInputState({ changed: isChangedValue(fieldValue, fieldComparisonValue), comparisonValue: fieldComparisonValue, schemaType: field.type, parent: parent.value, currentUser: parent.currentUser, document: parent.document, value: fieldValue, fieldGroupState, focusPath: parent.focusPath, openPath: parent.openPath, presence: parent.presence, validation: parent.validation, collapsedPaths: scopedCollapsedPaths, collapsedFieldSets: scopedCollapsedFieldSets, level: fieldLevel, path: fieldPath, readOnly });
      if (fieldState === null) {
        return null;
      }
      return {
        kind: "field",
        key: "field-".concat(field.name),
        name: field.name,
        index,
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        open: startsWith(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = isRecord$4(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    const conditionalPropertyContext = { value: fieldValue, parent: parent.value, document: parent.document, currentUser: parent.currentUser };
    const hidden = resolveConditionalProperty(field.type.hidden, conditionalPropertyContext);
    if (hidden) {
      return null;
    }
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext);
    const fieldState = preparePrimitiveInputState({ ...parent, comparisonValue: fieldComparisonValue, value: fieldValue, schemaType: field.type, path: fieldPath, readOnly });
    return {
      kind: "field",
      key: "field-".concat(field.name),
      name: field.name,
      index,
      open: startsWith(fieldPath, parent.openPath),
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      // todo: consider support for collapsible primitive fields
      collapsible: false,
      collapsed: false,
      field: fieldState
    };
  }
}
function prepareObjectInputState(props2) {
  let enableHiddenCheck = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var _a4;
  if (props2.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = { value: props2.value, parent: props2.parent, document: props2.document, currentUser: props2.currentUser };
  const readOnly = props2.readOnly || resolveConditionalProperty(props2.schemaType.readOnly, conditionalPropertyContext);
  const schemaTypeGroupConfig = props2.schemaType.groups || [];
  const defaultGroupName = (_a4 = schemaTypeGroupConfig.find((g) => g.default) || ALL_FIELDS_GROUP) == null ? void 0 : _a4.name;
  const groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap((group2) => {
    var _a22;
    const groupHidden = resolveConditionalProperty(group2.hidden, conditionalPropertyContext);
    const isSelected = group2.name === (((_a22 = props2.fieldGroupState) == null ? void 0 : _a22.value) || defaultGroupName);
    const selected = props2.changesOpen ? group2.name === ALL_FIELDS_GROUP.name : isSelected;
    const disabled = props2.changesOpen ? !selected : false;
    return groupHidden ? [] : [{ disabled, icon: group2 == null ? void 0 : group2.icon, name: group2.name, selected, title: group2.title }];
  });
  const selectedGroup = groups.find((group2) => group2.selected);
  const normalizedSchemaMembers = props2.schemaType.fieldsets ? props2.schemaType.fieldsets : props2.schemaType.fields.map((field) => ({ single: true, field }));
  const members = normalizedSchemaMembers.flatMap((fieldSet, index) => {
    var _a22, _b4, _c4, _d4;
    if (fieldSet.single) {
      const field = fieldSet.field;
      const fieldMember = prepareFieldMember({ field, parent: { ...props2, readOnly, groups, selectedGroup }, index });
      return fieldMember ? [fieldMember] : [];
    }
    const fieldsetFieldNames = fieldSet.fields.map((f) => f.name);
    const fieldsetHidden = resolveConditionalProperty(fieldSet.hidden, { currentUser: props2.currentUser, document: props2.document, parent: props2.value, value: (0, import_pick3.default)(props2.value, fieldsetFieldNames) });
    const fieldsetReadOnly = resolveConditionalProperty(fieldSet.readOnly, { currentUser: props2.currentUser, document: props2.document, parent: props2.value, value: (0, import_pick3.default)(props2.value, fieldsetFieldNames) });
    const fieldsetMembers = fieldSet.fields.flatMap((field) => {
      if (fieldsetHidden) {
        return [{ kind: "hidden", key: "field-".concat(field.name), name: field.name, index }];
      }
      const fieldMember = prepareFieldMember({ field, parent: { ...props2, readOnly: readOnly || fieldsetReadOnly, groups, selectedGroup }, index });
      return fieldMember ? [fieldMember] : [];
    });
    const defaultCollapsedState = getCollapsedWithDefaults(fieldSet.options, props2.level);
    const collapsed = (_c4 = (_b4 = (((_a22 = props2.collapsedFieldSets) == null ? void 0 : _a22.children) || {})[fieldSet.name]) == null ? void 0 : _b4.value) != null ? _c4 : defaultCollapsedState.collapsed;
    return [{ kind: "fieldSet", key: "fieldset-".concat(fieldSet.name), _inSelectedGroup: isFieldEnabledByGroupFilter(groups, fieldSet.group, selectedGroup), groups: fieldSet.group ? (0, import_castArray2.default)(fieldSet.group) : [], fieldSet: { path: pathFor(props2.path.concat(fieldSet.name)), name: fieldSet.name, title: fieldSet.title, description: fieldSet.description, hidden: false, level: props2.level + 1, members: fieldsetMembers.filter((member) => member.kind !== "hidden"), collapsible: defaultCollapsedState == null ? void 0 : defaultCollapsedState.collapsible, collapsed, columns: (_d4 = fieldSet == null ? void 0 : fieldSet.options) == null ? void 0 : _d4.columns } }];
  });
  const hasFieldGroups = schemaTypeGroupConfig.length > 0;
  const filteredPresence = props2.presence.filter((item) => isEqual(item.path, props2.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$b;
  const validation2 = props2.validation.filter((item) => isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.item.message, path: v.path }));
  const visibleMembers = members.filter((member) => member.kind !== "hidden");
  if (visibleMembers.length === 0 && enableHiddenCheck) {
    return null;
  }
  const visibleGroups = hasFieldGroups ? groups.flatMap((group2) => {
    if (group2.name === ALL_FIELDS_GROUP.name) {
      return group2;
    }
    const hasVisibleMembers = visibleMembers.some((member) => {
      if (member.kind === "error") {
        return false;
      }
      if (member.kind === "field") {
        return member.groups.includes(group2.name);
      }
      return member.groups.includes(group2.name) || member.fieldSet.members.some((fieldsetMember) => fieldsetMember.kind !== "error" && fieldsetMember.groups.includes(group2.name));
    });
    return hasVisibleMembers ? group2 : [];
  }) : [];
  const filtereredMembers = visibleMembers.flatMap((member) => {
    if (member.kind === "error") {
      return [member];
    }
    if (member.kind === "field") {
      return member.inSelectedGroup ? [member] : [];
    }
    const filteredFieldsetMembers = member.fieldSet.members.filter((fieldsetMember) => fieldsetMember.kind !== "field" || fieldsetMember.inSelectedGroup);
    return filteredFieldsetMembers.length > 0 ? [{ ...member, fieldSet: { ...member.fieldSet, members: filteredFieldsetMembers } }] : [];
  });
  const node = {
    value: props2.value,
    changed: isChangedValue(props2.value, props2.comparisonValue),
    schemaType: props2.schemaType,
    readOnly,
    path: props2.path,
    id: toString(props2.path),
    level: props2.level,
    focused: isEqual(props2.path, props2.focusPath),
    focusPath: trimChildPath(props2.path, props2.focusPath),
    presence,
    validation: validation2,
    // this is currently needed by getExpandOperations which needs to know about hidden members
    // (e.g. members not matching current group filter) in order to determine what to expand
    members: filtereredMembers,
    groups: visibleGroups
  };
  Object.defineProperty(node, "_allMembers", { value: members, enumerable: false });
  return node;
}
function prepareArrayOfPrimitivesInputState(props2) {
  if (props2.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = { comparisonValue: props2.comparisonValue, value: props2.value, parent: props2.parent, document: props2.document, currentUser: props2.currentUser };
  const hidden = resolveConditionalProperty(props2.schemaType.hidden, conditionalPropertyContext);
  if (hidden) {
    return null;
  }
  const readOnly = props2.readOnly || resolveConditionalProperty(props2.schemaType.readOnly, conditionalPropertyContext);
  const items = Array.isArray(props2.value) ? props2.value : [];
  const filteredPresence = props2.presence.filter((item) => isEqual(item.path, props2.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$b;
  const validation2 = props2.validation.filter((item) => isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.item.message, path: v.path }));
  const members = items.flatMap((item, index) => prepareArrayOfPrimitivesMember({ arrayItem: item, parent: props2, index }));
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props2.changed || members.some((m2) => m2.kind === "item" && m2.item.changed),
    value: props2.value,
    readOnly,
    schemaType: props2.schemaType,
    focused: isEqual(props2.path, props2.focusPath),
    focusPath: trimChildPath(props2.path, props2.focusPath),
    path: props2.path,
    id: toString(props2.path),
    level: props2.level,
    validation: validation2,
    presence,
    members
  };
}
function prepareArrayOfObjectsInputState(props2) {
  if (props2.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = { value: props2.value, parent: props2.parent, document: props2.document, currentUser: props2.currentUser };
  const hidden = resolveConditionalProperty(props2.schemaType.hidden, conditionalPropertyContext);
  if (hidden) {
    return null;
  }
  const readOnly = props2.readOnly || resolveConditionalProperty(props2.schemaType.readOnly, conditionalPropertyContext);
  const items = Array.isArray(props2.value) ? props2.value : [];
  const filteredPresence = props2.presence.filter((item) => isEqual(item.path, props2.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$b;
  const validation2 = props2.validation.filter((item) => isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.item.message, path: v.path }));
  const members = items.flatMap((item, index) => prepareArrayOfObjectsMember({ arrayItem: item, parent: props2, index }));
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props2.changed || members.some((m2) => m2.kind === "item" && m2.item.changed),
    value: props2.value,
    readOnly,
    schemaType: props2.schemaType,
    focused: isEqual(props2.path, props2.focusPath),
    focusPath: trimChildPath(props2.path, props2.focusPath),
    path: props2.path,
    id: toString(props2.path),
    level: props2.level,
    validation: validation2,
    presence,
    members
  };
}
function prepareArrayOfObjectsMember(props2) {
  var _a4, _b4, _c4, _d4, _e3, _f3, _g3;
  const { arrayItem, parent, index } = props2;
  const itemType = getItemType(parent.schemaType, arrayItem);
  const key2 = arrayItem._key;
  if (!itemType) {
    const itemTypeName = resolveTypeName(arrayItem);
    return { kind: "error", key: key2, index, error: { type: "INVALID_ITEM_TYPE", resolvedValueType: itemTypeName, value: arrayItem, validTypes: parent.schemaType.of } };
  }
  const itemPath = pathFor([...parent.path, { _key: key2 }]);
  const itemLevel = parent.level + 1;
  const conditionalPropertyContext = { value: parent.value, parent: props2.parent, document: parent.document, currentUser: parent.currentUser };
  const readOnly = parent.readOnly || resolveConditionalProperty(parent.schemaType.readOnly, conditionalPropertyContext);
  const fieldGroupState = (_b4 = (_a4 = parent.fieldGroupState) == null ? void 0 : _a4.children) == null ? void 0 : _b4[key2];
  const scopedCollapsedPaths = (_d4 = (_c4 = parent.collapsedPaths) == null ? void 0 : _c4.children) == null ? void 0 : _d4[key2];
  const scopedCollapsedFieldsets = (_f3 = (_e3 = parent.collapsedFieldSets) == null ? void 0 : _e3.children) == null ? void 0 : _f3[key2];
  const comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find((i) => i._key === arrayItem._key) || void 0;
  const itemState = prepareObjectInputState({ schemaType: itemType, level: itemLevel, document: parent.document, value: arrayItem, comparisonValue, changed: isChangedValue(arrayItem, comparisonValue), path: itemPath, focusPath: parent.focusPath, openPath: parent.openPath, currentUser: parent.currentUser, collapsedPaths: scopedCollapsedPaths, collapsedFieldSets: scopedCollapsedFieldsets, presence: parent.presence, validation: parent.validation, fieldGroupState, readOnly }, false);
  const defaultCollapsedState = getCollapsedWithDefaults(itemType.options, itemLevel);
  const collapsed = (_g3 = scopedCollapsedPaths == null ? void 0 : scopedCollapsedPaths.value) != null ? _g3 : defaultCollapsedState.collapsed;
  return { kind: "item", key: key2, index, open: startsWith(itemPath, parent.openPath), collapsed, collapsible: true, parentSchemaType: parent.schemaType, item: itemState };
}
function prepareArrayOfPrimitivesMember(props2) {
  var _a4, _b4;
  const { arrayItem, parent, index } = props2;
  const itemType = getPrimitiveItemType(parent.schemaType, arrayItem);
  const itemPath = pathFor([...parent.path, index]);
  const itemValue = (_a4 = parent.value) == null ? void 0 : _a4[index];
  const itemComparisonValue = (_b4 = parent.comparisonValue) == null ? void 0 : _b4[index];
  const itemLevel = parent.level + 1;
  const key2 = "".concat((itemType == null ? void 0 : itemType.name) || "invalid-type", "-").concat(String(index));
  if (!itemType) {
    return { kind: "error", key: key2, index, error: { type: "INVALID_ITEM_TYPE", validTypes: parent.schemaType.of, resolvedValueType: resolveTypeName(itemType), value: itemValue } };
  }
  const readOnly = parent.readOnly || resolveConditionalProperty(itemType.readOnly, { value: itemValue, parent: parent.value, document: parent.document, currentUser: parent.currentUser });
  const item = preparePrimitiveInputState({ ...parent, path: itemPath, schemaType: itemType, level: itemLevel, value: itemValue, comparisonValue: itemComparisonValue, readOnly });
  return { kind: "item", key: key2, index, parentSchemaType: parent.schemaType, open: isEqual(itemPath, parent.openPath), item };
}
function preparePrimitiveInputState(props2) {
  const filteredPresence = props2.presence.filter((item) => isEqual(item.path, props2.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$b;
  const validation2 = props2.validation.filter((item) => isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.item.message, path: v.path }));
  return { schemaType: props2.schemaType, changed: isChangedValue(props2.value, props2.comparisonValue), value: props2.value, level: props2.level, id: toString(props2.path), readOnly: props2.readOnly, focused: isEqual(props2.path, props2.focusPath), path: props2.path, presence, validation: validation2 };
}
function prepareFormState(props2) {
  return prepareObjectInputState(props2);
}
function useFormState(schemaType, _ref578) {
  let { comparisonValue, value, fieldGroupState, collapsedFieldSets, collapsedPaths, focusPath, openPath, presence, validation: validation2, readOnly, changesOpen } = _ref578;
  const currentUser = useCurrentUser();
  const prev = (0, import_react51.useRef)(null);
  (0, import_react51.useLayoutEffect)(() => {
    prev.current = null;
  }, [schemaType]);
  return (0, import_react51.useMemo)(() => {
    const next = prepareFormState({ schemaType, document: value, fieldGroupState, collapsedFieldSets, collapsedPaths, value, comparisonValue, focusPath, openPath, readOnly, path: pathFor([]), level: 0, currentUser, presence, validation: validation2, changesOpen });
    const reconciled = immutableReconcile(prev.current, next);
    prev.current = reconciled;
    return reconciled;
  }, [schemaType, value, fieldGroupState, collapsedFieldSets, collapsedPaths, comparisonValue, focusPath, openPath, readOnly, currentUser, presence, validation2, changesOpen]);
}
var IS_NUMERIC = /^\d+$/;
function unquote(str) {
  return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function splitAttr(segment) {
  const [attr, key2] = segment.split("==");
  return { [attr]: unquote(key2) };
}
function coerce(segment) {
  return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
function parseGradientPath(focusPathStr) {
  return focusPathStr.split(/[[.\]]/g).filter(Boolean).map((seg) => seg.includes("==") ? splitAttr(seg) : coerce(seg));
}
function encodePath(formBuilderPath) {
  return arrayToJSONMatchPath(formBuilderPath);
}
function decodePath(gradientPath) {
  return parseGradientPath(gradientPath);
}
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
function fromMutationPatches(origin, patches) {
  return (0, import_flatten5.default)(patches.map((patch2) => toFormBuilderPatches(origin, patch2)));
}
var notIn = (values2) => (value) => !values2.includes(value);
function toFormBuilderPatches(origin, patch2) {
  return (0, import_flatten5.default)(Object.keys(patch2).filter(notIn(["id", "ifRevisionID", "query"])).map((type) => {
    if (type === "unset") {
      return patch2.unset.map((path2) => {
        return { type: "unset", path: decodePath(path2), origin };
      });
    }
    if (type === "insert") {
      const position = "before" in patch2.insert ? "before" : "after";
      return { type: "insert", position, path: decodePath(patch2.insert[position]), items: patch2.insert.items, origin };
    }
    return Object.keys(patch2[type]).map((gradientPath) => {
      if (type === "set") {
        return { type: "set", path: decodePath(gradientPath), value: patch2[type][gradientPath], origin };
      }
      if (type === "inc" || type === "dec") {
        return { type, path: decodePath(gradientPath), value: patch2[type][gradientPath], origin };
      }
      if (type === "setIfMissing") {
        return { type: "setIfMissing", path: decodePath(gradientPath), value: patch2[type][gradientPath], origin };
      }
      if (type === "diffMatchPatch") {
        return { type, path: decodePath(gradientPath), value: patch2[type][gradientPath], origin };
      }
      console.warn(new Error("Unsupported patch type: ".concat(type)));
      return null;
    }).filter(Boolean);
  }));
}
function toMutationPatch(patch2) {
  if (patch2.patchType !== SANITY_PATCH_TYPE && patch2.type) {
    throw new Error('Patch is missing "patchType" - import and use "'.concat(patch2.type, '()" from "sanity/form"'));
  } else if (patch2.patchType !== SANITY_PATCH_TYPE) {
    throw new Error('Patch is missing "patchType" - import and use the patch method helpers from "sanity/form"');
  }
  const matchPath2 = arrayToJSONMatchPath(patch2.path || []);
  if (patch2.type === "insert") {
    const { position, items } = patch2;
    return { insert: { [position]: matchPath2, items } };
  }
  if (patch2.type === "unset") {
    return { unset: [matchPath2] };
  }
  if (!patch2.type) {
    throw new Error("Missing patch type in patch ".concat(JSON.stringify(patch2)));
  }
  if (matchPath2) {
    return { [patch2.type]: { [matchPath2]: patch2.value } };
  }
  return { [patch2.type]: patch2.value };
}
var TransformPatches = (0, import_react51.memo)(function OnChangeProvider(props2) {
  const { transform: transform2 } = props2;
  const callbacks2 = useFormCallbacks();
  const handleChange = (0, import_react51.useCallback)((patchEvent) => {
    const patches = patchEvent.patches;
    const transformedPatches = transform2(patches);
    callbacks2.onChange(PatchEvent.from(transformedPatches));
  }, [callbacks2, transform2]);
  const contextValue = (0, import_react51.useMemo)(() => ({ ...callbacks2, onChange: handleChange }), [callbacks2, handleChange]);
  return (0, import_jsx_runtime6.jsx)(FormCallbacksContext.Provider, { value: contextValue, children: props2.children });
});
function _buildTints(bg, mid, fg) {
  return { 50: mix$1(0.1, mid, bg), 100: mix$1(0.2, mid, bg), 200: mix$1(0.4, mid, bg), 300: mix$1(0.6, mid, bg), 400: mix$1(0.8, mid, bg), 500: mid, 600: mix$1(0.8, mid, fg), 700: mix$1(0.6, mid, fg), 800: mix$1(0.4, mid, fg), 900: mix$1(0.2, mid, fg), 950: mix$1(0.1, mid, fg) };
}
function _toHex(color3) {
  const { red: red2, green: green2, blue: blue2 } = parseToRgb(color3);
  return rgb(red2, green2, blue2);
}
function _isDark(bg, fg) {
  return getLuminance(bg) < getLuminance(fg);
}
function _multiply(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex2 = rgbToHex(multiply$1(b, s));
  return hex2;
}
function _screen(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex2 = rgbToHex(screen$1(b, s));
  return hex2;
}
var NEUTRAL_TONES2 = ["default", "transparent"];
function buildColor(legacyPalette, legacyTones) {
  return createColorTheme({ base: (_ref579) => {
    let { dark: navbar, name } = _ref579;
    const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
    const dark = stateTones.dark;
    const blend = navbar ? _screen : _multiply;
    const tints = stateTones[name] || stateTones.default;
    if (name === "default") {
      const skeletonFrom2 = stateTones.default[100];
      return { fg: stateTones.fg, bg: stateTones.bg, border: stateTones.default[200], focusRing: legacyPalette.focus.base, shadow: { outline: rgba2(stateTones.default[500], 0.4), umbra: rgba2(dark ? legacyPalette.black : stateTones.default[500], 0.2), penumbra: rgba2(dark ? legacyPalette.black : stateTones.default[500], 0.14), ambient: rgba2(dark ? legacyPalette.black : stateTones.default[500], 0.12) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (name === "transparent") {
      const bg2 = tints[50];
      const skeletonFrom2 = blend(bg2, tints[100]);
      return { fg: tints[900], bg: bg2, border: tints[300], focusRing: legacyPalette.focus.base, shadow: { outline: rgba2(tints[500], dark ? 0.2 : 0.4), umbra: rgba2(dark ? legacyPalette.black : tints[500], 0.2), penumbra: rgba2(dark ? legacyPalette.black : tints[500], 0.14), ambient: rgba2(dark ? legacyPalette.black : tints[500], 0.12) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    const bg = tints[50];
    const skeletonFrom = blend(bg, tints[100]);
    return { fg: tints[900], bg, border: tints[200], focusRing: tints[500], shadow: { outline: rgba2(tints[500], dark ? 0.2 : 0.4), umbra: rgba2(dark ? legacyPalette.black : tints[500], 0.2), penumbra: rgba2(dark ? legacyPalette.black : tints[500], 0.14), ambient: rgba2(dark ? legacyPalette.black : tints[500], 0.12) }, skeleton: { from: skeletonFrom, to: rgba2(skeletonFrom, 0.5) } };
  }, solid: (_ref580) => {
    let { base, dark: navbar, name, state, tone } = _ref580;
    const buttonTones = navbar ? legacyTones.button.navbar : legacyTones.button.default;
    const dark = buttonTones.dark;
    const blend = dark ? _screen : _multiply;
    const blendInvert = dark ? _multiply : _screen;
    const defaultTints = buttonTones[name] || buttonTones.default;
    const isNeutral = NEUTRAL_TONES2.includes(name) && NEUTRAL_TONES2.includes(tone);
    let tints = buttonTones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = blend(base.bg, tints[200]);
      const skeletonFrom2 = blendInvert(bg2, tints[800]);
      return { bg: bg2, border: blend(base.bg, tints[200]), fg: blend(base.bg, buttonTones.bg), muted: { fg: blend(base.bg, tints[50]) }, accent: { fg: blend(base.bg, tints[50]) }, link: { fg: blend(base.bg, tints[50]) }, code: { bg: bg2, fg: blend(base.bg, tints[50]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (state === "hovered") {
      const bg2 = blend(base.bg, tints[600]);
      const skeletonFrom2 = blendInvert(bg2, tints[800]);
      return { bg: bg2, border: blend(base.bg, tints[600]), fg: blend(base.bg, buttonTones.bg), muted: { fg: blend(base.bg, tints[200]) }, accent: { fg: blendInvert(bg2, buttonTones.critical[300]) }, link: { fg: blendInvert(bg2, buttonTones.primary[200]) }, code: { bg: blend(bg2, tints[50]), fg: blend(base.bg, tints[200]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (state === "pressed") {
      const bg2 = blend(base.bg, tints[800]);
      const skeletonFrom2 = blendInvert(bg2, tints[800]);
      return { bg: bg2, border: blend(base.bg, tints[800]), fg: blend(base.bg, buttonTones.bg), muted: { fg: blend(base.bg, tints[200]) }, accent: { fg: blendInvert(bg2, buttonTones.critical[300]) }, link: { fg: blendInvert(bg2, buttonTones.primary[200]) }, code: { bg: blend(bg2, tints[50]), fg: blend(base.bg, tints[200]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = buttonTones.primary;
      }
      const bg2 = blend(base.bg, tints[800]);
      const skeletonFrom2 = blendInvert(bg2, tints[800]);
      return { bg: bg2, border: blend(base.bg, tints[800]), fg: blend(base.bg, buttonTones.bg), muted: { fg: blend(base.bg, tints[200]) }, accent: { fg: blendInvert(bg2, buttonTones.critical[300]) }, link: { fg: blendInvert(bg2, buttonTones.primary[200]) }, code: { bg: blend(bg2, tints[50]), fg: blend(base.bg, tints[200]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    const bg = blend(base.bg, tints[500]);
    const skeletonFrom = blendInvert(bg, tints[800]);
    return { bg, border: blend(base.bg, tints[500]), fg: blend(base.bg, buttonTones.bg), muted: { fg: blend(base.bg, tints[100]) }, accent: { fg: blendInvert(bg, buttonTones.critical[200]) }, link: { fg: blendInvert(bg, buttonTones.primary[100]) }, code: { bg: blend(bg, tints[50]), fg: blend(base.bg, tints[100]) }, skeleton: { from: skeletonFrom, to: rgba2(skeletonFrom, 0.5) } };
  }, muted: (_ref581) => {
    let { base, dark: navbar, name, state, tone } = _ref581;
    const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
    const dark = stateTones.dark;
    const blend = dark ? _screen : _multiply;
    const defaultTints = stateTones[name] || stateTones.default;
    const isNeutral = NEUTRAL_TONES2.includes(name) && NEUTRAL_TONES2.includes(tone);
    let tints = stateTones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = base.bg;
      const skeletonFrom2 = blend(bg2, tints[100]);
      return { bg: bg2, border: blend(base.bg, tints[50]), fg: blend(base.bg, tints[200]), muted: { fg: blend(bg2, tints[100]) }, accent: { fg: blend(bg2, tints[100]) }, link: { fg: blend(bg2, tints[100]) }, code: { bg: bg2, fg: blend(bg2, tints[100]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (state === "hovered") {
      const bg2 = blend(base.bg, tints[50]);
      const skeletonFrom2 = blend(bg2, tints[100]);
      return { bg: bg2, border: blend(bg2, tints[100]), fg: blend(base.bg, tints[900]), muted: { fg: blend(base.bg, tints[600]) }, accent: { fg: blend(base.bg, stateTones.critical[500]) }, link: { fg: blend(base.bg, stateTones.primary[600]) }, code: { bg: blend(bg2, tints[50]), fg: blend(base.bg, tints[600]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (state === "pressed") {
      if (isNeutral) {
        tints = stateTones.primary;
      }
      const bg2 = blend(base.bg, tints[100]);
      const skeletonFrom2 = blend(bg2, tints[100]);
      return { bg: bg2, border: blend(bg2, tints[100]), fg: blend(base.bg, tints[800]), muted: { fg: blend(base.bg, tints[600]) }, accent: { fg: blend(bg2, stateTones.critical[500]) }, link: { fg: blend(bg2, stateTones.primary[600]) }, code: { bg: blend(bg2, tints[50]), fg: blend(bg2, tints[600]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = stateTones.primary;
      }
      const bg2 = blend(base.bg, tints[100]);
      const skeletonFrom2 = blend(bg2, tints[100]);
      return { bg: bg2, border: blend(bg2, tints[100]), fg: blend(bg2, tints[800]), muted: { fg: blend(bg2, tints[600]) }, accent: { fg: blend(bg2, stateTones.critical[500]) }, link: { fg: blend(bg2, stateTones.primary[600]) }, code: { bg: blend(bg2, tints[50]), fg: blend(bg2, tints[600]) }, skeleton: { from: skeletonFrom2, to: rgba2(skeletonFrom2, 0.5) } };
    }
    const bg = base.bg;
    const skeletonFrom = blend(base.bg, tints[100]);
    return { bg, border: blend(bg, tints[100]), fg: blend(bg, tints[700]), muted: { fg: blend(bg, tints[600]) }, accent: { fg: blend(bg, stateTones.critical[500]) }, link: { fg: blend(bg, stateTones.primary[600]) }, code: { bg: blend(bg, tints[50]), fg: blend(bg, tints[600]) }, skeleton: { from: skeletonFrom, to: rgba2(skeletonFrom, 0.5) } };
  }, button: (_ref582) => {
    let { base, mode, muted, solid } = _ref582;
    if (mode === "bleed") {
      return { enabled: { ...muted.enabled, border: muted.enabled.bg }, hovered: { ...muted.hovered, border: muted.hovered.bg }, pressed: { ...muted.pressed, border: muted.pressed.bg }, selected: { ...muted.selected, border: muted.selected.bg }, disabled: { ...muted.disabled, border: muted.disabled.bg } };
    }
    if (mode === "ghost") {
      return { ...solid, enabled: { ...muted.enabled, border: base.border }, disabled: muted.disabled };
    }
    return solid;
  }, card: (_ref583) => {
    let { base, dark: navbar, muted, name, solid, state } = _ref583;
    if (state === "hovered") {
      return muted[name].hovered;
    }
    if (state === "disabled") {
      return muted[name].disabled;
    }
    const isNeutral = NEUTRAL_TONES2.includes(name);
    const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
    const tints = stateTones[name] || stateTones.default;
    const dark = stateTones.dark;
    const blend = dark ? _screen : _multiply;
    if (state === "pressed") {
      if (isNeutral) {
        return muted.primary.pressed;
      }
      return muted[name].pressed;
    }
    if (state === "selected") {
      if (isNeutral) {
        return solid.primary.enabled;
      }
      return solid[name].enabled;
    }
    const bg = base.bg;
    const skeletonFrom = blend(base.bg, tints[dark ? 900 : 100]);
    return { bg, fg: base.fg, border: base.border, muted: { fg: blend(base.bg, tints[dark ? 400 : 600]) }, accent: { fg: blend(base.bg, stateTones.critical[dark ? 400 : 500]) }, link: { fg: blend(base.bg, stateTones.primary[dark ? 400 : 600]) }, code: { bg: blend(base.bg, tints[dark ? 950 : 50]), fg: tints[dark ? 400 : 600] }, skeleton: { from: skeletonFrom, to: rgba2(skeletonFrom, 0.5) } };
  }, input: (_ref584) => {
    let { base, dark: navbar, mode, state } = _ref584;
    const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
    const dark = stateTones.dark;
    const blend = dark ? _screen : _multiply;
    if (mode === "invalid") {
      const tints = stateTones.critical;
      return { bg: blend(base.bg, tints[50]), fg: blend(base.bg, tints[700]), border: blend(base.bg, tints[200]), placeholder: blend(base.bg, tints[400]) };
    }
    if (state === "hovered") {
      return { bg: base.bg, fg: base.fg, border: blend(base.bg, hues.gray[300].hex), placeholder: blend(base.bg, hues.gray[400].hex) };
    }
    if (state === "disabled") {
      return { bg: blend(base.bg, hues.gray[50].hex), fg: blend(base.bg, hues.gray[200].hex), border: blend(base.bg, hues.gray[100].hex), placeholder: blend(base.bg, hues.gray[100].hex) };
    }
    if (state === "readOnly") {
      return { bg: blend(base.bg, hues.gray[50].hex), fg: blend(base.bg, hues.gray[800].hex), border: blend(base.bg, hues.gray[200].hex), placeholder: blend(base.bg, hues.gray[400].hex) };
    }
    return { bg: base.bg, fg: base.fg, border: base.border, placeholder: blend(base.bg, hues.gray[700].hex) };
  }, selectable: (_ref585) => {
    let { base, muted, tone, solid, state } = _ref585;
    if (state === "enabled") {
      return { ...muted[tone].enabled, bg: base.bg };
    }
    if (state === "pressed") {
      if (tone === "default") {
        return muted.primary.pressed;
      }
      return muted[tone].pressed;
    }
    if (state === "selected") {
      if (tone === "default") {
        return solid.primary.enabled;
      }
      return solid[tone].enabled;
    }
    if (state === "disabled") {
      return { ...muted[tone].disabled, bg: base.bg };
    }
    return muted[tone][state];
  }, spot: (_ref586) => {
    let { base, key: key2 } = _ref586;
    const dark = _isDark(base.bg, base.fg);
    const blend = dark ? _screen : _multiply;
    return blend(base.bg, hues[key2][dark ? 400 : 500].hex);
  }, syntax: (_ref587) => {
    let { base, dark: navbar } = _ref587;
    const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
    const dark = stateTones.dark;
    const blend = dark ? _screen : _multiply;
    const mainShade = 600;
    const secondaryShade = 400;
    return { atrule: blend(base.bg, hues.purple[mainShade].hex), attrName: blend(base.bg, stateTones.positive[mainShade]), attrValue: blend(base.bg, stateTones.caution[mainShade]), attribute: blend(base.bg, stateTones.caution[mainShade]), boolean: blend(base.bg, hues.purple[mainShade].hex), builtin: blend(base.bg, hues.purple[mainShade].hex), cdata: blend(base.bg, stateTones.caution[mainShade]), char: blend(base.bg, stateTones.caution[mainShade]), class: blend(base.bg, hues.orange[mainShade].hex), className: blend(base.bg, hues.cyan[mainShade].hex), comment: blend(base.bg, stateTones.default[secondaryShade]), constant: blend(base.bg, hues.purple[mainShade].hex), deleted: blend(base.bg, stateTones.critical[mainShade]), doctype: blend(base.bg, stateTones.default[secondaryShade]), entity: blend(base.bg, stateTones.critical[mainShade]), function: blend(base.bg, stateTones.positive[mainShade]), hexcode: blend(base.bg, stateTones.primary[mainShade]), id: blend(base.bg, hues.purple[mainShade].hex), important: blend(base.bg, hues.purple[mainShade].hex), inserted: blend(base.bg, stateTones.caution[mainShade]), keyword: blend(base.bg, hues.magenta[mainShade].hex), number: blend(base.bg, hues.purple[mainShade].hex), operator: blend(base.bg, hues.magenta[mainShade].hex), prolog: blend(base.bg, stateTones.default[secondaryShade]), property: blend(base.bg, stateTones.primary[mainShade]), pseudoClass: blend(base.bg, stateTones.caution[mainShade]), pseudoElement: blend(base.bg, stateTones.caution[mainShade]), punctuation: blend(base.bg, stateTones.default[mainShade]), regex: blend(base.bg, stateTones.primary[mainShade]), selector: blend(base.bg, stateTones.critical[mainShade]), string: blend(base.bg, stateTones.caution[mainShade]), symbol: blend(base.bg, hues.purple[mainShade].hex), tag: blend(base.bg, stateTones.critical[mainShade]), unit: blend(base.bg, hues.orange[mainShade].hex), url: blend(base.bg, stateTones.critical[mainShade]), variable: blend(base.bg, stateTones.critical[mainShade]) };
  } });
}
function buildFonts(cssCustomProperties) {
  return { ...studioTheme.fonts, code: { ...studioTheme.fonts.code, family: cssCustomProperties["--font-family-monospace"] || studioTheme.fonts.code.family }, heading: { ...studioTheme.fonts.heading, family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family }, label: { ...studioTheme.fonts.label, family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family }, text: { ...studioTheme.fonts.text, family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family } };
}
function buildLegacyPalette(cssCustomProperties) {
  return { black: _toHex(cssCustomProperties["--black"]), component: { bg: _toHex(cssCustomProperties["--component-bg"]), fg: _toHex(cssCustomProperties["--component-text-color"]) }, defaultButton: { default: { base: _toHex(cssCustomProperties["--default-button-color"]) }, primary: { base: _toHex(cssCustomProperties["--default-button-primary-color"]) }, success: { base: _toHex(cssCustomProperties["--default-button-success-color"]) }, warning: { base: _toHex(cssCustomProperties["--default-button-warning-color"]) }, danger: { base: _toHex(cssCustomProperties["--default-button-danger-color"]) } }, focus: { base: _toHex(cssCustomProperties["--focus-color"]) }, gray: { base: _toHex(cssCustomProperties["--gray-base"]) }, mainNavigation: { bg: _toHex(cssCustomProperties["--main-navigation-color"]), fg: _toHex(cssCustomProperties["--main-navigation-color--inverted"]) }, state: { info: { fg: _toHex(cssCustomProperties["--state-info-color"]) }, success: { fg: _toHex(cssCustomProperties["--state-success-color"]) }, warning: { fg: _toHex(cssCustomProperties["--state-warning-color"]) }, danger: { fg: _toHex(cssCustomProperties["--state-danger-color"]) } } };
}
function buildLegacyTones(legacyPalette) {
  return { state: { default: { bg: legacyPalette.component.bg, fg: legacyPalette.component.fg, dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg), default: _buildTints(legacyPalette.component.bg, legacyPalette.gray.base, legacyPalette.component.fg), transparent: _buildTints(legacyPalette.component.bg, legacyPalette.gray.base, legacyPalette.component.fg), primary: _buildTints(legacyPalette.component.bg, legacyPalette.state.info.fg, legacyPalette.component.fg), positive: _buildTints(legacyPalette.component.bg, legacyPalette.state.success.fg, legacyPalette.component.fg), caution: _buildTints(legacyPalette.component.bg, legacyPalette.state.warning.fg, legacyPalette.component.fg), critical: _buildTints(legacyPalette.component.bg, legacyPalette.state.danger.fg, legacyPalette.component.fg) }, navbar: { bg: legacyPalette.mainNavigation.bg, fg: legacyPalette.mainNavigation.fg, dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg), default: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.gray.base, legacyPalette.mainNavigation.fg), transparent: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.gray.base, legacyPalette.mainNavigation.fg), primary: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.info.fg, legacyPalette.mainNavigation.fg), positive: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.success.fg, legacyPalette.mainNavigation.fg), caution: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.warning.fg, legacyPalette.mainNavigation.fg), critical: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.danger.fg, legacyPalette.mainNavigation.fg) } }, button: { default: { bg: legacyPalette.component.bg, fg: legacyPalette.component.fg, dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg), default: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.default.base, legacyPalette.component.fg), transparent: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.default.base, legacyPalette.component.fg), primary: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.primary.base, legacyPalette.component.fg), positive: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.success.base, legacyPalette.component.fg), caution: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.warning.base, legacyPalette.component.fg), critical: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.danger.base, legacyPalette.component.fg) }, navbar: { bg: legacyPalette.mainNavigation.bg, fg: legacyPalette.mainNavigation.fg, dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg), default: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.default.base, legacyPalette.mainNavigation.fg), transparent: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.default.base, legacyPalette.mainNavigation.fg), primary: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.primary.base, legacyPalette.mainNavigation.fg), positive: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.success.base, legacyPalette.mainNavigation.fg), caution: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.warning.base, legacyPalette.mainNavigation.fg), critical: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.danger.base, legacyPalette.mainNavigation.fg) } } };
}
function buildLegacyTheme(partialLegacyTheme) {
  const legacyTheme = resolveLegacyTheme(partialLegacyTheme);
  const legacyPalette = buildLegacyPalette(legacyTheme);
  const legacyTones = buildLegacyTones(legacyPalette);
  const color3 = buildColor(legacyPalette, legacyTones);
  const fonts2 = buildFonts(legacyTheme);
  return { __dark: _isDark(color3.light.default.base.bg, color3.light.default.base.fg), __legacy: true, ...studioTheme, color: color3, focusRing: { offset: -1, width: 2 }, fonts: fonts2, media: [parseInt(legacyTheme["--screen-medium-break"], 10) || 512, parseInt(legacyTheme["--screen-default-break"], 10) || 640, parseInt(legacyTheme["--screen-large-break"], 10) || 960, parseInt(legacyTheme["--screen-xlarge-break"], 10) || 1600] };
}
var defaultCustomProperties = {
  "--font-family-monospace": studioTheme.fonts.code.family,
  "--font-family-base": studioTheme.fonts.text.family,
  "--black": black.hex,
  "--white": white.hex,
  // Brand
  "--brand-primary": blue[500].hex,
  // Component
  "--component-bg": white.hex,
  "--component-text-color": black.hex,
  // Gray
  "--gray": gray[500].hex,
  "--gray-base": gray[500].hex,
  // Default button
  "--default-button-color": gray[500].hex,
  "--default-button-danger-color": red[500].hex,
  "--default-button-primary-color": blue[500].hex,
  "--default-button-success-color": green[500].hex,
  "--default-button-warning-color": yellow[500].hex,
  // Focus
  "--focus-color": blue[500].hex,
  // Screen
  "--screen-medium-break": "512px",
  "--screen-default-break": "640px",
  "--screen-large-break": "960px",
  "--screen-xlarge-break": "1600px",
  // State
  "--state-info-color": blue[500].hex,
  "--state-success-color": green[500].hex,
  "--state-warning-color": yellow[500].hex,
  "--state-danger-color": red[500].hex,
  // Navbar
  "--main-navigation-color": black.hex,
  "--main-navigation-color--inverted": white.hex
};
function resolveLegacyTheme(legacyTheme) {
  const props2 = { ...defaultCustomProperties, ...legacyTheme };
  props2["--focus-color"] = legacyTheme["--focus-color"] || props2["--brand-primary"];
  props2["--default-button-primary-color"] = legacyTheme["--default-button-primary-color"] || props2["--brand-primary"];
  props2["--main-navigation-color"] = legacyTheme["--main-navigation-color"] || props2["--black"];
  props2["--main-navigation-color--inverted"] = legacyTheme["--main-navigation-color--inverted"] || props2["--white"];
  props2["--state-info-color"] = legacyTheme["--brand-primary"] || props2["--brand-primary"];
  return props2;
}
var defaultTheme = { ...studioTheme, focusRing: { offset: -1, width: 2 } };

export {
  isReference,
  isImage,
  isCrossDatasetReference,
  isSanityDocument,
  isTypedObject,
  isKeyedObject,
  isValidationErrorMarker,
  isValidationWarningMarker,
  isValidationInfoMarker,
  isCreateMutation,
  isCreateIfNotExistsMutation,
  isCreateOrReplaceMutation,
  isDeleteMutation,
  isPatchMutation,
  isIndexSegment,
  isKeySegment,
  isIndexTuple,
  isPortableTextTextBlock,
  isPortableTextSpan,
  isPortableTextListBlock,
  isDocumentSchemaType,
  isObjectSchemaType,
  isArraySchemaType,
  isArrayOfBlocksSchemaType,
  isArrayOfObjectsSchemaType,
  isArrayOfPrimitivesSchemaType,
  isBooleanSchemaType,
  isStringSchemaType,
  isNumberSchemaType,
  isPrimitiveSchemaType,
  isReferenceSchemaType,
  isCrossDatasetReferenceSchemaType,
  isTitledListValue,
  isSpanSchemaType,
  isBlockSchemaType,
  isBlockStyleObjectField,
  isBlockListObjectField,
  isBlockChildrenObjectField,
  defineType,
  defineField,
  defineArrayMember,
  typed,
  isSlug,
  isCreateSquashedMutation,
  isValidationError,
  isValidationWarning,
  isValidationInfo,
  get,
  toString,
  resolveKeyedPath,
  fromString,
  hues,
  AddCircleIcon,
  AddIcon,
  ArrowLeftIcon,
  BinaryDocumentIcon,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  CloseIcon,
  CommentIcon,
  ControlsIcon,
  CopyIcon,
  DocumentIcon,
  DocumentsIcon,
  DoubleChevronRightIcon,
  EarthAmericasIcon,
  EditIcon,
  EllipsisVerticalIcon,
  ErrorOutlineIcon,
  EyeOpenIcon,
  FolderIcon,
  HelpCircleIcon,
  InfoOutlineIcon,
  LaunchIcon,
  LinkIcon,
  MasterDetailIcon,
  MenuIcon,
  MoonIcon,
  PlayIcon,
  PublishIcon,
  ReadOnlyIcon,
  ResetIcon,
  RestoreIcon,
  SearchIcon,
  SelectIcon,
  SortIcon,
  SpinnerIcon,
  SplitVerticalIcon,
  StackCompactIcon,
  StackIcon,
  StopIcon,
  SunIcon,
  SyncIcon,
  TrashIcon,
  UndoIcon,
  UnknownIcon,
  UnpublishIcon,
  WarningOutlineIcon,
  motion,
  AnimatePresence,
  rem,
  useClickOutside,
  useElementRect,
  useGlobalKeyDown,
  rgba2 as rgba,
  ThemeColorProvider,
  useTheme,
  useMediaIndex,
  useForwardedRef,
  Text3 as Text,
  Avatar,
  AvatarStack,
  Box,
  Label,
  Badge,
  Flex,
  Spinner,
  Button,
  Card,
  Checkbox,
  Code,
  Container,
  Grid,
  Heading,
  Inline,
  BoundaryElementProvider,
  useBoundaryElement,
  ErrorBoundary,
  useLayer,
  _raf2,
  focusFirstDescendant,
  focusLastDescendant,
  LayerProvider,
  Layer,
  usePortal,
  PortalProvider,
  Popover,
  Select,
  Stack,
  TextArea,
  TextInput,
  TooltipDelayGroupProvider,
  Tooltip,
  Breadcrumbs,
  Dialog,
  DialogProvider,
  Hotkeys,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  TextSkeleton,
  Tab,
  TabList,
  TabPanel,
  ToastProvider,
  useToast,
  Tree,
  TreeItem,
  useRouter,
  useIntentLink,
  IntentLink,
  StateLink,
  decodeJsonParams,
  encodeJsonParams,
  route,
  useRouterState,
  Schema2 as Schema,
  generateHelpUrl2 as generateHelpUrl,
  isActionEnabled,
  defaultKeyGenerator,
  usePortableTextEditorSelection,
  usePortableTextEditor,
  PortableTextEditor,
  PortableTextEditable,
  evaluateQuery,
  parse6 as parse,
  createNoopTrackerScope,
  createUseReporter,
  createTrackerScope,
  Tracker$1,
  useReportedValues$1,
  useReporter$1,
  ConnectorContext,
  ChangeFieldWrapper,
  useUnique2 as useUnique,
  createHookFromObservableFactory,
  isNonNullable$3,
  DRAFTS_FOLDER,
  documentIdEquals,
  isDraft,
  isDraftId,
  getIdPair,
  isPublishedId,
  getDraftId,
  getPublishedId,
  createDraftFrom,
  newDraftFrom,
  createPublishedFrom,
  collate,
  removeDupes,
  EMPTY_OBJECT,
  EMPTY_ARRAY$b,
  globalScope2 as globalScope,
  isArray,
  isRecord$4,
  isString3 as isString,
  isTruthy,
  createSharedResizeObserver,
  resizeObserver,
  _isSanityDocumentTypeDefinition,
  _isCustomDocumentTypeDefinition,
  fieldNeedsEscape,
  escapeField,
  joinPath,
  supportsTouch,
  uncaughtErrorHandler,
  sliceString,
  truncateString,
  useLoadable,
  asLoadable,
  userHasRole,
  useThrottledCallback,
  useTranslation2 as useTranslation,
  ChangeIndicator,
  ChangeIndicatorContext,
  useOnScroll,
  ScrollContainer,
  ScrollMonitor,
  EnabledChangeConnectorRoot,
  DisabledChangeConnectorRoot,
  ChangeConnectorRoot,
  CommandList,
  GlobalErrorHandler,
  DefaultDocument,
  GetHookCollectionState,
  Hotkeys3 as Hotkeys2,
  Translate,
  useCurrentLocale,
  useLocale,
  useIntlListFormat,
  InsufficientPermissionsMessage,
  IntentButton,
  PopoverDialog,
  usePreviewCard,
  PreviewCard$1,
  useIntlNumberFormat,
  useIntlDateTimeFormat,
  useUserColorManager,
  useUserColor,
  createUserColorManager,
  UserColorManagerProvider,
  defineConfig,
  createConfig,
  definePlugin,
  createPlugin,
  defineDocumentFieldAction,
  documentFieldActionsReducer,
  initialDocumentFieldActions,
  defineDocumentInspector,
  defineLocaleResourceBundle,
  defineLocale,
  defineLocalesResources,
  removeUndefinedLocaleResources,
  usEnglishLocale,
  defaultLocale,
  createSchema,
  getSchemaTypeTitle,
  ResourceCacheProvider,
  useResourceCache,
  CorsOriginError,
  _createAuthStore,
  createAuthStore,
  isAuthStore,
  createMockAuthStore,
  getProviderTitle,
  CONNECTING,
  onRetry,
  createConnectionStatusStore,
  useClient,
  useUser,
  useCurrentUser,
  useConnectionState,
  useDataset,
  useDocumentOperation,
  useDocumentOperationEvent,
  useEditState,
  useFormattedDuration,
  useProjectId$1,
  useRelativeTime,
  useSchema,
  useSyncState,
  useTemplates,
  useTimeAgo,
  useTools,
  useUnitFormatter,
  useValidationStatus,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  useFeatureEnabled,
  SanityDefaultPreview,
  useDocumentPreview,
  PreviewLoader,
  useMiddlewareComponents,
  createSearchQuery,
  createPatchChannel,
  SANITY_PATCH_TYPE,
  setIfMissing2 as setIfMissing,
  insert2 as insert,
  set$2,
  unset2 as unset,
  diffMatchPatch2 as diffMatchPatch,
  inc,
  dec,
  prefixPath,
  PatchEvent,
  useDidUpdate,
  pathToString2 as pathToString,
  getValueAtPath,
  findIndex2 as findIndex,
  stringToPath,
  normalizePathSegment2 as normalizePathSegment,
  normalizeIndexSegment2 as normalizeIndexSegment,
  normalizeKeySegment2 as normalizeKeySegment,
  normalizeIndexTupleSegment2 as normalizeIndexTupleSegment,
  pathsAreEqual,
  getItemKey$2,
  getItemKeySegment,
  isEmptyObject$1,
  getAnnotationColor,
  getAnnotationAtPath,
  getDiffAtPath,
  visitDiff,
  useAnnotationColor,
  useDiffAnnotationColor,
  DiffTooltip,
  DiffCard,
  ChangeTitleSegment,
  ChangeBreadcrumb,
  DiffContext,
  getValueError,
  DocumentChangeContext,
  useDocumentChange,
  resolveDiffComponent,
  noop$2,
  isFieldChange,
  isGroupChange,
  isAddedItemDiff,
  isRemovedItemDiff,
  isUnchangedDiff,
  isDev,
  isProd,
  DiffErrorBoundary,
  FromToArrow,
  DiffInspectWrapper,
  FromTo,
  DiffFromTo,
  FallbackDiff,
  RevertChangesButton,
  ValueError,
  FieldChange,
  GroupChange,
  ChangeResolver,
  NoChanges,
  ChangeList,
  DiffStringSegment,
  DiffString,
  MetaInfo,
  diffResolver,
  FormValueProvider,
  useFormValue,
  FormBuilderContext,
  ArrayOfObjectsFunctions,
  useFormBuilder,
  FormCallbacksContext,
  FormCallbacksProvider,
  useFormCallbacks,
  FieldActionMenu,
  FieldActionsResolver,
  useHoveredField,
  FieldActionsProvider,
  useFieldActions,
  HoveredFieldProvider,
  FormProvider,
  FormBuilder,
  useReferenceInputOptions,
  ReferenceInputOptionsProvider,
  ReviewChangesContext,
  useReviewChanges,
  DocumentPreviewPresence,
  UserAvatar,
  FormFieldPresenceContext,
  FieldPresenceInner,
  FieldPresenceWithOverlay,
  FieldPresenceWithoutOverlay,
  FieldPresence,
  PresenceScope,
  OverlayDisabled,
  PresenceOverlay,
  FormFieldValidationStatus,
  FormFieldHeaderText,
  FormField,
  FormFieldSet,
  FormFieldStatus,
  RelativeTime,
  MemberField,
  MemberFieldError,
  MemberFieldSet,
  ArrayOfObjectsItem,
  ArrayOfPrimitivesItem,
  MemberItemError,
  ArrayOfObjectsInputMember,
  ArrayOfObjectsInputMembers,
  ObjectInputMember,
  ObjectInputMembers,
  ObjectMembers,
  FormInput,
  VirtualizerScrollInstanceContext,
  useVirtualizerScrollInstance,
  VirtualizerScrollInstanceProvider,
  defaultRenderAnnotation,
  defaultRenderBlock,
  defaultRenderInlineBlock,
  defaultRenderField,
  defaultRenderInput,
  defaultRenderItem,
  defaultRenderPreview,
  StudioFileInput,
  StudioImageInput,
  StudioCrossDatasetReferenceInput,
  StudioReferenceInput,
  isObjectItemProps,
  isObjectInputProps,
  isStringInputProps,
  isNumberInputProps,
  isBooleanInputProps,
  isArrayOfObjectsInputProps,
  isArrayOfBlocksInputProps,
  isArrayOfPrimitivesInputProps,
  ArrayOfObjectOptionsInput,
  ArrayOfPrimitiveOptionsInput,
  ArrayOfOptionsInput,
  CollapseMenu,
  AutoCollapseMenu,
  CollapseMenuButton,
  PortableTextInput,
  TagsArrayInput,
  ArrayOfPrimitivesFunctions,
  ArrayOfPrimitivesInput,
  ArrayOfObjectsInput,
  SelectInput,
  StringInput,
  NumberInput,
  BooleanInput,
  EmailInput,
  ObjectInput,
  DateTimeInput,
  DateInput,
  TextInput3 as TextInput2,
  UrlInput,
  SlugInput,
  UniversalArrayInput,
  Preview,
  getPreviewPaths,
  getPreviewStateObservable,
  getPreviewValueWithFallback,
  prepareForPreview,
  createDocumentPreviewStore,
  createObservableBufferedDocument,
  createBufferedDocument,
  getPairListener,
  checkoutPair,
  snapshotPair,
  editState,
  emitOperation,
  operationEvents,
  remoteSnapshots,
  validation,
  listenQuery,
  isBuilder,
  resolveInitialValue,
  DEFAULT_MAX_RECURSION_DEPTH,
  resolveInitialValueForType,
  resolveInitialObjectValue,
  prepareTemplates,
  defaultTemplateForType,
  defaultTemplatesForSchema,
  getInitialValueStream,
  createDocumentStore,
  useDocumentType,
  useDocumentValues,
  useInitialValue,
  useInitialValueResolverContext,
  useResolveInitialValueForType,
  getDocumentPairPermissions,
  useDocumentPairPermissionsFromHookFactory,
  useDocumentPairPermissions,
  getDocumentValuePermissions,
  useDocumentValuePermissionsFromHookFactory,
  useDocumentValuePermissions,
  getTemplatePermissions,
  useTemplatePermissionsFromHookFactory,
  useTemplatePermissions,
  createGrantsStore,
  TimelineController,
  Timeline,
  removeMissingReferences,
  createHistoryStore,
  useTimelineStore,
  useTimelineSelector,
  createProjectStore,
  useProject,
  useProjectDatasets,
  createSettingsStore,
  createUserStore,
  SESSION_ID,
  __tmp_wrap_presenceStore,
  useUserStore,
  useGrantsStore,
  useHistoryStore,
  useDocumentPreviewStore,
  useDocumentStore,
  useConnectionStatusStore,
  usePresenceStore,
  useProjectStore,
  useSettingsStore,
  useGlobalPresence,
  useDocumentPresence,
  defineSearchFilter,
  defineSearchFilterOperators,
  defineSearchOperator,
  WorkspaceProvider,
  useWorkspace,
  SourceProvider,
  useSource,
  operatorDefinitions,
  ConfigPropertyError,
  flattenConfig,
  ConfigResolutionError,
  SchemaError,
  prepareConfig,
  resolveConfig,
  createWorkspaceFromConfig,
  createSourceFromConfig,
  useConfigContextFromSource,
  getConfigContextFromSource,
  ActiveWorkspaceMatcherContext,
  WorkspacesContext,
  WorkspacesProvider,
  getWorkspaceIdentifier,
  getNamelessWorkspaceIdentifier,
  useWorkspaces,
  validateWorkspaces,
  validateNames,
  validateBasePaths,
  matchWorkspace,
  ActiveWorkspaceMatcher,
  useActiveWorkspace,
  ColorSchemeValueContext,
  ColorSchemeSetValueContext,
  ColorSchemeProvider,
  ColorSchemeLocalStorageProvider,
  ColorSchemeCustomProvider,
  useColorSchemeSetValue,
  _useColorSchemeInternalValue,
  useColorSchemeValue,
  useColorScheme,
  useColorSchemeOptions,
  StudioProvider,
  StudioLogo,
  TextWithTone,
  SearchDialog,
  SearchField,
  SANITY_VERSION,
  StudioNavbar,
  ToolLink,
  StudioToolMenu,
  NavbarContext,
  StudioLayout,
  StudioLayoutComponent,
  Studio,
  renderStudio,
  LocaleProvider,
  LocaleProviderBase,
  DefaultPreview,
  DetailPreview,
  CircularProgress,
  LinearProgress,
  MediaPreview,
  BlockImagePreview,
  BlockPreview,
  InlinePreview,
  TemplatePreview,
  useRovingFocus,
  StatusButton,
  TooltipOfDisabled,
  ImperativeToast,
  useZIndex,
  LegacyLayerProvider,
  WithReferringDocuments,
  ZIndexProvider,
  BetaBadge,
  TelephoneInput,
  setAtPath,
  getExpandOperations,
  resolveConditionalProperty,
  useFormState,
  encodePath,
  decodePath,
  toMutationPatches,
  fromMutationPatches,
  TransformPatches,
  buildLegacyTheme,
  defaultTheme
};
/*! Bundled license information:

@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs:
  (**
   * react-virtual
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/utils.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/index.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-virtual/build/lib/index.mjs:
  (**
   * react-virtual
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-OWFEO6X2.js.map
